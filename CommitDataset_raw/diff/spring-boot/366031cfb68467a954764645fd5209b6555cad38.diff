[+++ b/spring-boot/src/test/java/org/springframework/boot/context/properties/bind/CollectionBinderTests.java, +import java.util.stream.Collectors;, +import org.springframework.boot.context.properties.bind.BinderTests.JavaBean;, +	@Test, +	public void bindToNonScalarCollectionShouldReturnPopulatedCollection() throws Exception {, +		MockConfigurationPropertySource source = new MockConfigurationPropertySource();, +		source.put("foo[0].value", "a");, +		source.put("foo[1].value", "b");, +		source.put("foo[2].value", "c");, +		this.sources.add(source);, +		Bindable<List<JavaBean>> target = Bindable.listOf(JavaBean.class);, +		List<JavaBean> result = this.binder.bind("foo", target).get();, +		assertThat(result).hasSize(3);, +		List<String> values = result.stream().map(JavaBean::getValue).collect(Collectors.toList());, +		assertThat(values).containsExactly("a", "b", "c");, +	}, +++ b/spring-boot/src/test/java/org/springframework/boot/context/properties/bind/CollectionBinderTests.java, +import java.util.stream.Collectors;, +import org.springframework.boot.context.properties.bind.BinderTests.JavaBean;, +	@Test, +	public void bindToNonScalarCollectionShouldReturnPopulatedCollection() throws Exception {, +		MockConfigurationPropertySource source = new MockConfigurationPropertySource();, +		source.put("foo[0].value", "a");, +		source.put("foo[1].value", "b");, +		source.put("foo[2].value", "c");, +		this.sources.add(source);, +		Bindable<List<JavaBean>> target = Bindable.listOf(JavaBean.class);, +		List<JavaBean> result = this.binder.bind("foo", target).get();, +		assertThat(result).hasSize(3);, +		List<String> values = result.stream().map(JavaBean::getValue).collect(Collectors.toList());, +		assertThat(values).containsExactly("a", "b", "c");, +	}, +++ b/spring-boot/src/test/java/org/springframework/boot/context/properties/bind/MapBinderTests.java, +import org.springframework.boot.context.properties.bind.BinderTests.JavaBean;, +	public void bindToMapNonScalarCollectionShouldTriggerOnSuccess() throws Exception {, +		Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);, +		ResolvableType mapType = ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(String.class), valueType.getType());, +		Bindable<Map<String, List<JavaBean>>> target = Bindable.of(mapType);, +		MockConfigurationPropertySource source = new MockConfigurationPropertySource();, +		source.put("foo.bar[0].value", "a");, +		source.put("foo.bar[1].value", "b");, +		source.put("foo.bar[2].value", "c");, +		this.sources, +				.add(source);, +		BindHandler handler = mock(BindHandler.class,, +				withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS));, +		this.binder.bind("foo", target, handler);, +		InOrder inOrder = inOrder(handler);, +		inOrder.verify(handler).onSuccess(eq(ConfigurationPropertyName.of("foo.bar[0].value")),, +				eq(Bindable.of(String.class)), any(), eq("a"));, +		inOrder.verify(handler).onSuccess(eq(ConfigurationPropertyName.of("foo.bar[1].value")),, +				eq(Bindable.of(String.class)), any(), eq("b"));, +		inOrder.verify(handler).onSuccess(eq(ConfigurationPropertyName.of("foo.bar[2].value")),, +				eq(Bindable.of(String.class)), any(), eq("c"));, +		inOrder.verify(handler).onSuccess(eq(ConfigurationPropertyName.of("foo")),, +				eq(target), any(), isA(Map.class));, +	}, +, +	@Test]