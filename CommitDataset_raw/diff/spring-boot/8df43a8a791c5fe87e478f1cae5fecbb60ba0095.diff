[+++ b/spring-boot-tools/spring-boot-configuration-processor/pom.xml, +		<dependency>, +			<groupId>org.springframework</groupId>, +			<artifactId>spring-core</artifactId>, +		</dependency>, +					<!-- Ensure own annotation processor doesn't kick in -->, +++ b/spring-boot-tools/spring-boot-configuration-processor/pom.xml, +		<dependency>, +			<groupId>org.springframework</groupId>, +			<artifactId>spring-core</artifactId>, +		</dependency>, +					<!-- Ensure own annotation processor doesn't kick in -->, +++ b/spring-boot-tools/spring-boot-configuration-processor/src/main/java/org/springframework/boot/configurationprocessor/ConfigurationMetadataAnnotationProcessor.java, +import java.util.HashSet;, +import java.util.List;, + * @author Kris De Volder, +	public static final String METADATA_PATH = "META-INF/spring-configuration-metadata.json";, +, +	/**, +	 * On incremental builds, holds the 'old' metadata (created by the previous build)., +	 */, +	private ConfigurationMetadata oldmetadata;, +, +	/**, +	 * On incremental builds, keeps track of the types that where presented to the, +	 * processor. This includes types that are not annotated., +	 */, +	protected Set<String> processedSourceTypes;, +, +		this.oldmetadata = readMetadata();, +		if (isIncremental()) {, +			this.processedSourceTypes = new HashSet<String>();, +		}, +	protected boolean isIncremental() {, +		return this.oldmetadata != null;, +	}, +, +	protected boolean isDeleted(String sourceType) {, +		return this.processingEnv.getElementUtils().getTypeElement(sourceType) == null;, +	}, +, +	protected boolean isProcessed(String sourceType) {, +		return this.processedSourceTypes.contains(sourceType);, +	}, +, +	/**, +	 * Called during incremental build on all the 'root elements' that are being presented, +	 * to the processor., +	 */, +	protected void markAsProcessed(Element element) {, +		if (element instanceof TypeElement) {, +			this.processedSourceTypes.add(this.typeUtils.getType(element));, +		}, +	}, +, +		if (isIncremental()) {, +			for (Element element : roundEnv.getRootElements()) {, +				markAsProcessed(element);, +			}, +		}, +	protected ConfigurationMetadata writeMetaData(ConfigurationMetadata metadata) {, +		if (isIncremental()) {, +			mergeOldMetadata(metadata);, +		}, +						StandardLocation.CLASS_OUTPUT, "", METADATA_PATH);, +					return metadata;, +		return null;, +	}, +, +	protected ConfigurationMetadata readMetadata() {, +		try {, +			FileObject resource = this.processingEnv.getFiler().getResource(, +					StandardLocation.CLASS_OUTPUT, "", METADATA_PATH);, +			InputStream in = resource.openInputStream();, +			try {, +				ConfigurationMetadata data = new ConfigurationMetadata();, +				data.addAll(new JsonMarshaller().read(in));, +				if (!data.getItems().isEmpty()) {, +					return data;, +				}, +			}, +			finally {, +				in.close();, +			}, +		}, +		catch (IOException e) {, +			// no 'old' metadata, +		}, +		return null;, +	}, +, +	private void mergeOldMetadata(ConfigurationMetadata metadata) {, +		List<ItemMetadata> items = this.oldmetadata.getItems();, +		for (ItemMetadata oldItem : items) {, +			String sourceType = oldItem.getSourceType();, +			if (sourceType == null || isProcessed(sourceType) || isDeleted(sourceType)) {, +				// skip, +			}, +			else {, +				metadata.add(oldItem);]