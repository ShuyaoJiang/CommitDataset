[+++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +	    |        +-YourClasses.class, +	    |           +-YourClasses.class, +`org.springframework.boot.loader.jar.JarFile`. It allows you to load jar, +	+-------------------+-------------------------+, +	| /BOOT-INF/classes | /BOOT-INF/lib/mylib.jar |, +	|+-----------------+||+-----------+----------+|, +	||     A.class      |||  B.class  |  C.class ||, +	|+-----------------+||+-----------+----------+|, +	+-------------------+-------------------------+, +The example above shows how `A.class` can be found in `/BOOT-INF/classes` in `myapp.jar`, +position `0063`. `B.class` from the nested jar can actually be found in `myapp.jar`, +position `3452` and `C.class` is at position `3980`., +files in directories (as opposed to explicitly on the classpath). In the case of, +`JarLauncher` and `WarLauncher` the nested paths are fixed. `JarLauncher` looks in, +`BOOT-INF/lib/` and `WarLauncher` looks in `WEB-INF/lib/` and `WEB-INF/lib-provided/` so, +you just add extra jars in those locations if you want more. The `PropertiesLauncher`, +looks in `BOOT-INF/lib/` in your application archive by default, but you can add, +additional locations by setting an environment variable `LOADER_PATH` or `loader.path`, +* `loader.path` (if empty) defaults to `lib` (meaning a local directory or a nested one if, +  running from an archive). Because of this `PropertiesLauncher` behaves the same as, +  `JarLauncher` when no additional configuration is provided., +++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +	    |        +-YourClasses.class, +	    |           +-YourClasses.class, +`org.springframework.boot.loader.jar.JarFile`. It allows you to load jar, +	+-------------------+-------------------------+, +	| /BOOT-INF/classes | /BOOT-INF/lib/mylib.jar |, +	|+-----------------+||+-----------+----------+|, +	||     A.class      |||  B.class  |  C.class ||, +	|+-----------------+||+-----------+----------+|, +	+-------------------+-------------------------+, +The example above shows how `A.class` can be found in `/BOOT-INF/classes` in `myapp.jar`, +position `0063`. `B.class` from the nested jar can actually be found in `myapp.jar`, +position `3452` and `C.class` is at position `3980`., +files in directories (as opposed to explicitly on the classpath). In the case of, +`JarLauncher` and `WarLauncher` the nested paths are fixed. `JarLauncher` looks in, +`BOOT-INF/lib/` and `WarLauncher` looks in `WEB-INF/lib/` and `WEB-INF/lib-provided/` so, +you just add extra jars in those locations if you want more. The `PropertiesLauncher`, +looks in `BOOT-INF/lib/` in your application archive by default, but you can add, +additional locations by setting an environment variable `LOADER_PATH` or `loader.path`, +* `loader.path` (if empty) defaults to `lib` (meaning a local directory or a nested one if, +  running from an archive). Because of this `PropertiesLauncher` behaves the same as, +  `JarLauncher` when no additional configuration is provided., +++ b/spring-boot-docs/src/main/asciidoc/howto.adoc, +archive. To make it executable you can either use the `spring-boot-antlib`, +. If you are building a jar, package the application's classes and resources in a nested, +  `BOOT-INF/classes` directory. If you are building a war, package the application's, +  classes in a nested `WEB-INF/classes` directory as usual., +. Add the runtime dependencies in a nested `BOOT-INF/lib` directory for a jar or, +  `WEB-INF/lib` for a war. Remember *not* to compress the entries in the archive., +. Add the `provided` (embedded container) dependencies in a nested `BOOT-INF/lib`, +  directory for jar or `WEB-INF/lib-provided` for a war. Remember *not* to compress the, +  entries in the archive., +. Use the appropriate launcher, e.g. `JarLauncher` for a jar file, as a `Main-Class`, +  attribute in the manifest and specify the other properties it needs as manifest entries,, +  principally a `Start-Class`., +[source,xml,indent=0], +		<jar destfile="target/${ant.project.name}-${spring-boot.version}.jar" compress="false">, +			<mappedresources>, +				<globmapper from="*" to="BOOT-INF/classes/*"/>, +			</mappedresources>, +			<mappedresources>, +				<fileset dir="src/main/resources" erroronmissingdir="false"/>, +				<globmapper from="*" to="BOOT-INF/classes/*"/>, +			</mappedresources>, +			<mappedresources>, +				<fileset dir="${lib.dir}/runtime" />, +				<globmapper from="*" to="BOOT-INF/lib/*"/>, +			</mappedresources>, +			<zipfileset src="${lib.dir}/loader/spring-boot-loader-jar-${spring-boot.version}.jar" />, +The {github-code}/spring-boot-samples/spring-boot-sample-ant[Ant Sample] has a, +`build.xml` with a `manual` task that should work if you run it with, +	$ ant -lib <folder containing ivy-2.2.jar> clean manual, +++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +	    |        +-YourClasses.class, +	    |           +-YourClasses.class, +`org.springframework.boot.loader.jar.JarFile`. It allows you to load jar, +	+-------------------+-------------------------+, +	| /BOOT-INF/classes | /BOOT-INF/lib/mylib.jar |, +	|+-----------------+||+-----------+----------+|, +	||     A.class      |||  B.class  |  C.class ||, +	|+-----------------+||+-----------+----------+|, +	+-------------------+-------------------------+, +The example above shows how `A.class` can be found in `/BOOT-INF/classes` in `myapp.jar`, +position `0063`. `B.class` from the nested jar can actually be found in `myapp.jar`, +position `3452` and `C.class` is at position `3980`., +files in directories (as opposed to explicitly on the classpath). In the case of, +`JarLauncher` and `WarLauncher` the nested paths are fixed. `JarLauncher` looks in, +`BOOT-INF/lib/` and `WarLauncher` looks in `WEB-INF/lib/` and `WEB-INF/lib-provided/` so, +you just add extra jars in those locations if you want more. The `PropertiesLauncher`, +looks in `BOOT-INF/lib/` in your application archive by default, but you can add, +additional locations by setting an environment variable `LOADER_PATH` or `loader.path`, +* `loader.path` (if empty) defaults to `lib` (meaning a local directory or a nested one if, +  running from an archive). Because of this `PropertiesLauncher` behaves the same as, +  `JarLauncher` when no additional configuration is provided., +++ b/spring-boot-docs/src/main/asciidoc/howto.adoc, +archive. To make it executable you can either use the `spring-boot-antlib`, +. If you are building a jar, package the application's classes and resources in a nested, +  `BOOT-INF/classes` directory. If you are building a war, package the application's]