[+++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-actuator/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-actuator/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration.java, +import org.flywaydb.core.api.callback.Callback;, +@SuppressWarnings("deprecation"), +		private final List<Callback> callbacks;, +, +		private final List<FlywayCallback> flywayCallbacks;, +				ObjectProvider<List<Callback>> callbacks,, +			this.callbacks = callbacks.getIfAvailable(Collections::emptyList);, +			if (this.flywayCallbacks.isEmpty()) {, +				flyway.setCallbacks(this.callbacks.toArray(new Callback[0]));, +			}, +			else {, +				if (this.callbacks.isEmpty()) {, +					flyway.setCallbacks(, +							this.flywayCallbacks.toArray(new FlywayCallback[0]));, +				}, +				else {, +					throw new IllegalStateException(, +							"Found a mixture of Callback and FlywayCallback beans.", +									+ " One type must be used exclusively.");, +				}, +			}, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-actuator/src/test/resources/db/migration/V1__init.sql, +DROP TABLE IF EXISTS TEST;, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration.java, +import org.flywaydb.core.api.callback.Callback;, +@SuppressWarnings("deprecation"), +		private final List<Callback> callbacks;, +, +		private final List<FlywayCallback> flywayCallbacks;, +				ObjectProvider<List<Callback>> callbacks,, +			this.callbacks = callbacks.getIfAvailable(Collections::emptyList);, +			if (this.flywayCallbacks.isEmpty()) {, +				flyway.setCallbacks(this.callbacks.toArray(new Callback[0]));, +			}, +			else {, +				if (this.callbacks.isEmpty()) {, +					flyway.setCallbacks(, +							this.flywayCallbacks.toArray(new FlywayCallback[0]));, +				}, +				else {, +					throw new IllegalStateException(, +							"Found a mixture of Callback and FlywayCallback beans.", +									+ " One type must be used exclusively.");, +				}, +			}, +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfigurationTests.java, +import org.flywaydb.core.api.Location;, +import org.flywaydb.core.api.callback.Callback;, +import org.flywaydb.core.api.callback.Context;, +import org.flywaydb.core.api.callback.Event;, +import static org.mockito.BDDMockito.given;, +@SuppressWarnings("deprecation"), +							.containsExactly(new Location("classpath:db/migration"));, +							new Location("classpath:db/changelog"),, +							new Location("classpath:db/migration"));, +							new Location("classpath:db/changelog"),, +							new Location("classpath:db/migration"));, +							new Location("classpath:db/vendors/h2"),, +							new Location("classpath:db/changelog"));, +							.containsExactly(new Location("classpath:db/vendors/h2"));, +					Callback callbackOne = context.getBean("callbackOne", Callback.class);, +					Callback callbackTwo = context.getBean("callbackTwo", Callback.class);, +					orderedCallbacks.verify(callbackTwo).handle(any(Event.class),, +							any(Context.class));, +					orderedCallbacks.verify(callbackOne).handle(any(Event.class),, +							any(Context.class));, +				});, +	}, +, +	@Test, +	public void legacyCallbacksAreConfiguredAndOrdered() {, +		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,, +				LegacyCallbackConfiguration.class).run((context) -> {, +					assertThat(context).hasSingleBean(Flyway.class);, +					Flyway flyway = context.getBean(Flyway.class);, +					FlywayCallback callbackOne = context.getBean("legacyCallbackOne",, +							FlywayCallback.class);, +					FlywayCallback callbackTwo = context.getBean("legacyCallbackTwo",, +							FlywayCallback.class);, +					assertThat(flyway.getCallbacks()).hasSize(2);, +					InOrder orderedCallbacks = inOrder(callbackOne, callbackTwo);, +	@Test, +	public void callbacksAndLegacyCallbacksCannotBeMixed() {, +		this.contextRunner, +				.withUserConfiguration(EmbeddedDataSourceConfiguration.class,, +						LegacyCallbackConfiguration.class, CallbackConfiguration.class), +				.run((context) -> {]