[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricExportAutoConfiguration.java, +		@Value("${spring.application.name:application}.${random.value:0000}"), +		private String prefix = "";, +		private String aggregateKeyPattern = "k.d";, +			export.getRedis().setPrefix(, +					"spring.metrics" + (this.prefix.length() > 0 ? "." : ""), +							+ this.prefix);, +			export.getAggregate().setPrefix(this.prefix);, +			export.getAggregate().setKeyPattern(this.aggregateKeyPattern);, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricExportAutoConfiguration.java, +		@Value("${spring.application.name:application}.${random.value:0000}"), +		private String prefix = "";, +		private String aggregateKeyPattern = "k.d";, +			export.getRedis().setPrefix(, +					"spring.metrics" + (this.prefix.length() > 0 ? "." : ""), +							+ this.prefix);, +			export.getAggregate().setPrefix(this.prefix);, +			export.getAggregate().setKeyPattern(this.aggregateKeyPattern);, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricExportProperties.java, +	private Aggregate aggregate = new Aggregate();, +, +	public Aggregate getAggregate() {, +		return this.aggregate;, +	}, +, +	public void setAggregate(Aggregate aggregate) {, +		this.aggregate = aggregate;, +	}, +, +		 * Prefix for redis repository if active. Should be globally unique across all, +		 * processes sharing the same repository., +		 * system sharing a redis repository across multiple processes., +			// The common case including a standalone aggregator would have a prefix that, +			// starts with the end of the key, so strip that bit off and call it the, +			// aggregate prefix., +				String candidate = this.key.substring("keys.".length());, +				if (this.prefix.startsWith(candidate)) {, +					return candidate;, +				return candidate;, +			}, +			// If the user went off piste, choose something that is safe (not empty) but, +			// not the whole prefix (on the assumption that it contains dimension keys), +			if (this.prefix.contains("."), +					&& this.prefix.indexOf(".") < this.prefix.length() - 1) {, +				return this.prefix.substring(this.prefix.indexOf(".") + 1);, +	public static class Aggregate {, +, +		/**, +		 * Prefix for global repository if active. Should be unique for this JVM, but most, +		 * useful if it also has the form "a.b" where "a" is unique to this logical, +		 * process (this application) and "b" is unique to this physical process. If you, +		 * set spring.application.name elsewhere, then the default will be in the right, +		 * form., +		 */, +		private String prefix = "";, +, +		/**, +		 * Pattern that tells the aggregator what to do with the keys from the source, +		 * repository. The keys in the source repository are assumed to be period, +		 * separated, and the pattern is in the same format, e.g. "d.d.k.d". Here "d", +		 * means "discard" and "k" means "keep" the key segment in the corresponding, +		 * position in the source., +		 */, +		private String keyPattern = "";, +, +		public String getPrefix() {, +			return this.prefix;, +		}, +, +		public void setPrefix(String prefix) {, +			this.prefix = prefix;, +		}, +, +		public String getKeyPattern() {, +			return this.keyPattern;, +		}, +, +		public void setKeyPattern(String keyPattern) {, +			this.keyPattern = keyPattern;, +		}, +, +	}, +, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricExportAutoConfiguration.java, +		@Value("${spring.application.name:application}.${random.value:0000}"), +		private String prefix = "";, +		private String aggregateKeyPattern = "k.d";, +			export.getRedis().setPrefix(, +					"spring.metrics" + (this.prefix.length() > 0 ? "." : ""), +							+ this.prefix);, +			export.getAggregate().setPrefix(this.prefix);, +			export.getAggregate().setKeyPattern(this.aggregateKeyPattern);, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricExportProperties.java, +	private Aggregate aggregate = new Aggregate();, +, +	public Aggregate getAggregate() {, +		return this.aggregate;, +	}, +, +	public void setAggregate(Aggregate aggregate) {]