[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java, +				objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS,, +						true);, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java, +				objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS,, +						true);, +++ b/spring-boot-docs/src/main/asciidoc/build-tool-plugins.adoc, +|The name or value of the `Jar` task (defaults to all tasks of type `Jar`) which is used, + to locate the archive to repackage., +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java, +				objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS,, +						true);, +++ b/spring-boot-docs/src/main/asciidoc/build-tool-plugins.adoc, +|The name or value of the `Jar` task (defaults to all tasks of type `Jar`) which is used, + to locate the archive to repackage., +++ b/spring-boot-docs/src/main/asciidoc/howto.adoc, +If you want to use your project as a library jar for other projects to depend on, and in, +addition have an executable (e.g. demo) version of it, you will want to configure the, +build in a slightly different way., +For Maven the normal JAR plugin and the Spring Boot plugin both have a ``classifier'', +configuration that you can add to create an additional JAR. Example (using the Spring, +Boot Starter Parent to manage the plugin versions and other configuration defaults):, +Two jars are produced, the default one, and an executable one using the Boot plugin with, +classifier ``exec''., +, +, +Often if you have an executable and a non-executable jar as build products, the executable, +version will have additional configuration files that are not needed in a library jar., +E.g. the `application.yml` configuration file might excluded from the non-executable JAR., +Here's how to do that in Maven:, +In Gradle you can create a new JAR archive with standard task DSL features, and then have, +the `bootRepackage` task depend on that one using its `withJarTask` property:, +, +, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java, +				objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS,, +						true);, +++ b/spring-boot-docs/src/main/asciidoc/build-tool-plugins.adoc, +|The name or value of the `Jar` task (defaults to all tasks of type `Jar`) which is used, + to locate the archive to repackage., +++ b/spring-boot-docs/src/main/asciidoc/howto.adoc, +If you want to use your project as a library jar for other projects to depend on, and in, +addition have an executable (e.g. demo) version of it, you will want to configure the, +build in a slightly different way., +For Maven the normal JAR plugin and the Spring Boot plugin both have a ``classifier'', +configuration that you can add to create an additional JAR. Example (using the Spring, +Boot Starter Parent to manage the plugin versions and other configuration defaults):, +Two jars are produced, the default one, and an executable one using the Boot plugin with, +classifier ``exec''., +, +, +Often if you have an executable and a non-executable jar as build products, the executable, +version will have additional configuration files that are not needed in a library jar., +E.g. the `application.yml` configuration file might excluded from the non-executable JAR., +Here's how to do that in Maven:, +In Gradle you can create a new JAR archive with standard task DSL features, and then have, +the `bootRepackage` task depend on that one using its `withJarTask` property:, +, +, +++ b/spring-boot-integration-tests/src/test/java/org/springframework/boot/gradle/FlatdirTests.java, +	private static final String BOOT_VERSION = ManagedDependencies.get(), +			.find("spring-boot").getVersion();, +		if (this.libs.exists()) {, +			FileSystemUtils.deleteRecursively(this.libs);, +		this.project = new ProjectCreator().createProject("flatdir");, +		if (!this.libs.exists()) {, +			this.libs.mkdirs();, +		FileCopyUtils.copy(new File("src/test/resources/foo.jar"), new File(this.libs,, +				"foo-1.0.0.jar"));, +		this.project.newBuild().forTasks("build"), +				.withArguments("-PbootVersion=" + BOOT_VERSION, "--stacktrace").run();, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java, +				objectMapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS,, +						true);, +++ b/spring-boot-docs/src/main/asciidoc/build-tool-plugins.adoc, +|The name or value of the `Jar` task (defaults to all tasks of type `Jar`) which is used, + to locate the archive to repackage., +++ b/spring-boot-docs/src/main/asciidoc/howto.adoc, +If you want to use your project as a library jar for other projects to depend on, and in, +addition have an executable (e.g. demo) version of it, you will want to configure the, +build in a slightly different way., +For Maven the normal JAR plugin and the Spring Boot plugin both have a ``classifier'', +configuration that you can add to create an additional JAR. Example (using the Spring, +Boot Starter Parent to manage the plugin versions and other configuration defaults):, +Two jars are produced, the default one, and an executable one using the Boot plugin with, +classifier ``exec''., +, +, +Often if you have an executable and a non-executable jar as build products, the executable, +version will have additional configuration files that are not needed in a library jar., +E.g. the `application.yml` configuration file might excluded from the non-executable JAR., +Here's how to do that in Maven:, +In Gradle you can create a new JAR archive with standard task DSL features, and then have, +the `bootRepackage` task depend on that one using its `withJarTask` property:, +, +, +++ b/spring-boot-integration-tests/src/test/java/org/springframework/boot/gradle/FlatdirTests.java, +	private static final String BOOT_VERSION = ManagedDependencies.get(), +			.find("spring-boot").getVersion();, +		if (this.libs.exists()) {]