[+++ b/spring-boot/src/main/java/org/springframework/boot/BeanDefinitionLoader.java, +import java.io.IOException;, +import org.springframework.beans.factory.BeanDefinitionStoreException;, +	private static final ResourceLoader DEFAULT_RESOURCE_LOADER = new PathMatchingResourcePatternResolver();, +		String sourceString = xmlReader.getEnvironment().resolvePlaceholders(source.toString());, +			return load(ClassUtils.forName(sourceString, null));, +		ResourceLoader loader = this.resourceLoader != null ? , +			this.resourceLoader : DEFAULT_RESOURCE_LOADER;, +		, +		int loadCount = 0;, +		if( loader instanceof ResourcePatternResolver ) {, +	    	// Resource pattern matching available., +			try {, +				Resource[] resources = ((ResourcePatternResolver) loader).getResources(sourceString);, +				for(Resource resource : resources) {, +					if( resource.exists() ) {, +						loadCount += load(resource);, +					}, +				}, +			}, +			catch (IOException ex) {, +				throw new BeanDefinitionStoreException(, +						"Could not resolve bean definition resource pattern [" + sourceString + "]", ex);, +			}, +		}, +		if( !(loader instanceof ResourcePatternResolver) ) {, +		    	// Can only load single resources by absolute URL., +        		Resource loadedResource = loader.getResource(sourceString);, +		}, +		if( loadCount > 0 ) {, +			return loadCount;, +		}, +		else {, +			// Attempt to treat the source as a package name, common to all PatternResolver types, +		}, +++ b/spring-boot/src/main/java/org/springframework/boot/BeanDefinitionLoader.java, +import java.io.IOException;, +import org.springframework.beans.factory.BeanDefinitionStoreException;, +	private static final ResourceLoader DEFAULT_RESOURCE_LOADER = new PathMatchingResourcePatternResolver();, +		String sourceString = xmlReader.getEnvironment().resolvePlaceholders(source.toString());, +			return load(ClassUtils.forName(sourceString, null));, +		ResourceLoader loader = this.resourceLoader != null ? , +			this.resourceLoader : DEFAULT_RESOURCE_LOADER;, +		, +		int loadCount = 0;, +		if( loader instanceof ResourcePatternResolver ) {, +	    	// Resource pattern matching available., +			try {, +				Resource[] resources = ((ResourcePatternResolver) loader).getResources(sourceString);, +				for(Resource resource : resources) {, +					if( resource.exists() ) {, +						loadCount += load(resource);, +					}, +				}, +			}, +			catch (IOException ex) {, +				throw new BeanDefinitionStoreException(, +						"Could not resolve bean definition resource pattern [" + sourceString + "]", ex);, +			}, +		}, +		if( !(loader instanceof ResourcePatternResolver) ) {, +		    	// Can only load single resources by absolute URL., +        		Resource loadedResource = loader.getResource(sourceString);, +		}, +		if( loadCount > 0 ) {, +			return loadCount;, +		}, +		else {, +			// Attempt to treat the source as a package name, common to all PatternResolver types, +		}, +++ b/spring-boot/src/test/java/org/springframework/boot/SpringApplicationTests.java, +	, +	@Test, +	public void wildcardSources() {, +		Object[] sources = { "classpath:org/springframework/boot/sample-${sample.app.test.prop}.xml" };, +		TestSpringApplication application = new TestSpringApplication(sources);, +		application.setWebEnvironment(false);, +		application.run();, +	}, +++ b/spring-boot/src/main/java/org/springframework/boot/BeanDefinitionLoader.java, +import java.io.IOException;, +import org.springframework.beans.factory.BeanDefinitionStoreException;, +	private static final ResourceLoader DEFAULT_RESOURCE_LOADER = new PathMatchingResourcePatternResolver();, +		String sourceString = xmlReader.getEnvironment().resolvePlaceholders(source.toString());, +			return load(ClassUtils.forName(sourceString, null));, +		ResourceLoader loader = this.resourceLoader != null ? , +			this.resourceLoader : DEFAULT_RESOURCE_LOADER;, +		, +		int loadCount = 0;, +		if( loader instanceof ResourcePatternResolver ) {, +	    	// Resource pattern matching available., +			try {, +				Resource[] resources = ((ResourcePatternResolver) loader).getResources(sourceString);, +				for(Resource resource : resources) {, +					if( resource.exists() ) {, +						loadCount += load(resource);, +					}, +				}, +			}, +			catch (IOException ex) {]