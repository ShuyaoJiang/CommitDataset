[+++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata.java, +		if (ClassUtils.isCglibProxyClass(factoryType)) {, +			factoryType = factoryType.getSuperclass();, +		}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata.java, +		if (ClassUtils.isCglibProxyClass(factoryType)) {, +			factoryType = factoryType.getSuperclass();, +		}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBinder.java, +import org.springframework.core.ResolvableType;, +	 * @param targetType the resolvable type for the target, +	void bind(Object target, ConfigurationProperties annotation, ResolvableType targetType) {, +		Bindable<?> bindable = Bindable.of(targetType).withExistingValue(target);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata.java, +		if (ClassUtils.isCglibProxyClass(factoryType)) {, +			factoryType = factoryType.getSuperclass();, +		}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBinder.java, +import org.springframework.core.ResolvableType;, +	 * @param targetType the resolvable type for the target, +	void bind(Object target, ConfigurationProperties annotation, ResolvableType targetType) {, +		Bindable<?> bindable = Bindable.of(targetType).withExistingValue(target);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBindingPostProcessor.java, +import java.lang.reflect.Method;, +import org.springframework.core.ResolvableType;, +				ResolvableType type = ResolvableType.forClass(bean.getClass());, +				Method factoryMethod = this.beans.findFactoryMethod(beanName);, +				if (factoryMethod != null) {, +					type = ResolvableType.forMethodReturnType(factoryMethod);, +				}, +				getBinder().bind(bean, annotation, type);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata.java, +		if (ClassUtils.isCglibProxyClass(factoryType)) {, +			factoryType = factoryType.getSuperclass();, +		}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBinder.java, +import org.springframework.core.ResolvableType;, +	 * @param targetType the resolvable type for the target, +	void bind(Object target, ConfigurationProperties annotation, ResolvableType targetType) {, +		Bindable<?> bindable = Bindable.of(targetType).withExistingValue(target);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBindingPostProcessor.java, +import java.lang.reflect.Method;, +import org.springframework.core.ResolvableType;, +				ResolvableType type = ResolvableType.forClass(bean.getClass());, +				Method factoryMethod = this.beans.findFactoryMethod(beanName);, +				if (factoryMethod != null) {, +					type = ResolvableType.forMethodReturnType(factoryMethod);, +				}, +				getBinder().bind(bean, annotation, type);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/JavaBeanBinder.java, +import org.springframework.core.MethodParameter;, +		private final ResolvableType resolvableType;, +, +		Bean(ResolvableType resolvableType, Class<?> type) {, +			this.resolvableType = resolvableType;, +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +			Class<?> type = bindable.getType().resolve(Object.class);, +				bean = new Bean<>(bindable.getType(), type);, +		private final ResolvableType declaringClassType;, +, +		BeanProperty(String name, ResolvableType declaringClassType) {, +			this.declaringClassType = declaringClassType;, +				MethodParameter methodParameter = new MethodParameter(this.setter, 0);, +				return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType);, +			MethodParameter methodParameter = new MethodParameter(this.getter, -1);, +			return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata.java, +		if (ClassUtils.isCglibProxyClass(factoryType)) {, +			factoryType = factoryType.getSuperclass();, +		}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBinder.java, +import org.springframework.core.ResolvableType;, +	 * @param targetType the resolvable type for the target, +	void bind(Object target, ConfigurationProperties annotation, ResolvableType targetType) {, +		Bindable<?> bindable = Bindable.of(targetType).withExistingValue(target);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBindingPostProcessor.java, +import java.lang.reflect.Method;, +import org.springframework.core.ResolvableType;, +				ResolvableType type = ResolvableType.forClass(bean.getClass());, +				Method factoryMethod = this.beans.findFactoryMethod(beanName);, +				if (factoryMethod != null) {, +					type = ResolvableType.forMethodReturnType(factoryMethod);, +				}, +				getBinder().bind(bean, annotation, type);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/JavaBeanBinder.java, +import org.springframework.core.MethodParameter;, +		private final ResolvableType resolvableType;, +, +		Bean(ResolvableType resolvableType, Class<?> type) {, +			this.resolvableType = resolvableType;, +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +				this.properties.computeIfAbsent(name, n -> new BeanProperty(n, this.resolvableType)), +			Class<?> type = bindable.getType().resolve(Object.class);, +				bean = new Bean<>(bindable.getType(), type);, +		private final ResolvableType declaringClassType;, +, +		BeanProperty(String name, ResolvableType declaringClassType) {]