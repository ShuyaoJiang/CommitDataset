[+++ b/spring-boot-project/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +== The Executable Jar Format, +The `spring-boot-loader` modules lets Spring Boot support executable jar and, +war files. If you use the Maven plugin or the Gradle plugin, executable jars are, +automatically generated, and you generally do not need to know the details of how, +If you need to create executable jars from a different build system or if you are just, +Java does not provide any standard way to load nested jar files (that is, jar files that, +are themselves contained within a jar). This can be problematic if you need, +to distribute a self-contained application that can be run from the command line, +To solve this problem, many developers use "`shaded`" jars. A shaded jar packages, +all classes, from all jars, into a single "`uber jar`". The problem with shaded jars is, +that it becomes hard to see which libraries are actually in your application., +in multiple jars. Spring Boot takes a different approach and lets you actually nest, +==== The Executable Jar File Structure, +Spring Boot Loader-compatible jar files should be structured in the following way:, +==== The Executable War File Structure, +Spring Boot Loader-compatible war files should be structured in the following way:, +=== Spring Boot's "`JarFile`" Class, +`org.springframework.boot.loader.jar.JarFile`. It lets you load jar, +content from a standard jar file or from nested child jar data. When first loaded, the, +location of each `JarEntry` is mapped to a physical file offset of the outer jar, as, +shown in the following example:, +The preceding example shows how `A.class` can be found in `/BOOT-INF/classes` in `myapp.jar`, +at position `0063`. `B.class` from the nested jar can actually be found in `myapp.jar`, +at position `3452`, and `C.class` is at position `3980`., +Armed with this information, we can load specific nested entries by seeking to, +the appropriate part of the outer jar. We do not need to unpack the archive, and we, +do not need to read all entry data into memory., +==== Compatibility with the Standard Java "`JarFile`", +should work as a drop-in replacement. The `getURL()` method returns a `URL` that, +opens a connection compatible with `java.net.JarURLConnection` and can be used with Java's, +=== Launching Executable Jars, +is used as an executable jar's main entry point. It is the actual `Main-Class` in your jar, +file, and it is used to setup an appropriate `URLClassLoader` and ultimately call your, +There are three launcher subclasses (`JarLauncher`, `WarLauncher`, and `PropertiesLauncher`)., +Their purpose is to load resources (`.class` files and so on.) from nested jar files or war, +files in directories (as opposed to those explicitly on the classpath). In the case of, +`JarLauncher` and `WarLauncher`, the nested paths are fixed. `JarLauncher` looks in, +`BOOT-INF/lib/`, and `WarLauncher` looks in `WEB-INF/lib/` and `WEB-INF/lib-provided/`., +You can add extra jars in those locations if you want more. The `PropertiesLauncher`, +additional locations by setting an environment variable called `LOADER_PATH` or `loader.path`, +in `loader.properties` (which is a comma-separated list of directories, archives, or directories, +==== Launcher Manifest, +`META-INF/MANIFEST.MF`. The actual class that you want to launch (that is, the class that, +contains a `main` method) should be specified  in the `Start-Class`, +The following example shows a typical `MANIFEST.MF` for an executable jar file:, +For a war file, it would be as follows:, +NOTE: You need not specify `Class-Path` entries in your manifest file. The classpath, +is deduced from the nested jars., +==== Exploded Archives, +Cloud Foundry operates this way. You can run an unpacked archive by starting, +the appropriate launcher, as follows:, +=== `PropertiesLauncher` Features, +properties (System properties, environment variables, manifest entries, or, +`loader.properties`). The following table describes these properties:, +|Comma-separated Classpath, such as `lib,${HOME}/app/lib`. Earlier entries take precedence,, + like a regular `-classpath` on the `javac` command line., +|Used to resolve relative paths in `loader.path`. For example, given `loader.path=lib`, then, + directory). This property is also used to locate a `loader.properties` file, as in the, + following example `file:///opt/app`, + It defaults to `${user.dir}`., +|Default arguments for the main method (space separated)., +|Name of main class to launch (for example, `com.app.Application`)., +|Name of properties file (for example, `launcher`) It defaults to `loader`., +|Path to properties file (for example, `classpath:loader.properties`). It defaults to, + `loader.properties`., + It defaults to `false`., +the fat jar is built. If you use that, specify the name of the class to launch by using, +the `Main-Class` attribute and leaving out `Start-Class`., +The following rules apply to working with `PropertiesLauncher`:, +, +* `loader.properties` is searched for in `loader.home`, then in the root of the, +  classpath, and then in `classpath:/BOOT-INF/classes`. The first location where a file, +	with that name exists is used., +* `loader.home` is the directory location of an additional properties file, +  (overriding the default) only when `loader.config.location` is not specified., +* `loader.path` can contain directories (which are scanned recursively for jar and zip files),, +  Archive paths can be relative to `loader.home` or anywhere in the file system with a, +  nested one if running from an archive). Because of this, `PropertiesLauncher` behaves the, +  is environment variables, system properties, `loader.properties`, the exploded archive, +	manifest, and the archive manifest., +=== Executable Jar Restrictions, +You need to consider the following restrictions when working with a Spring, +Boot Loader packaged application:, +* Zip entry compression:, +The `ZipEntry` for a nested jar must be saved by using the `ZipEntry.STORED` method. This, +* System classLoader:, +(most libraries and frameworks do so by default). Trying to load nested jar, +classes with `ClassLoader.getSystemClassLoader()` fails., +`java.util.Logging` always uses the system classloader. For this reason, you should, +=== Alternative Single Jar Solutions, +If the preceding restrictions mean that you cannot use Spring Boot Loader, consider the following, +alternatives:]