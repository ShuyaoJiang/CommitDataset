[+++ b/spring-boot-docs/src/main/asciidoc/appendix-configuration-metadata.adoc, +Spring Boot's configuration file handling is quite flexible; and it is often the case, +that properties may exist that are not bound to a `@ConfigurationProperties` bean. You, +may also need to tune some attributes of an existing key. To support such cases and allow, +you to provide custom "hints", the annotation processor will automatically merge items, +from `META-INF/additional-spring-configuration-metadata.json` into the main meta-data, +file., +, +If you refer to a property that has been detected automatically, the description,, +default value and deprecation information are overridden if specified. If the manual, +property declaration is not identified in the current module, it is added as a brand new, +property., +++ b/spring-boot-docs/src/main/asciidoc/appendix-configuration-metadata.adoc, +Spring Boot's configuration file handling is quite flexible; and it is often the case, +that properties may exist that are not bound to a `@ConfigurationProperties` bean. You, +may also need to tune some attributes of an existing key. To support such cases and allow, +you to provide custom "hints", the annotation processor will automatically merge items, +from `META-INF/additional-spring-configuration-metadata.json` into the main meta-data, +file., +, +If you refer to a property that has been detected automatically, the description,, +default value and deprecation information are overridden if specified. If the manual, +property declaration is not identified in the current module, it is added as a brand new, +property., +++ b/spring-boot-tools/spring-boot-configuration-processor/src/main/java/org/springframework/boot/configurationprocessor/ConfigurationMetadataAnnotationProcessor.java, +			merged.merge(this.metadataStore.readAdditionalMetadata());, +++ b/spring-boot-docs/src/main/asciidoc/appendix-configuration-metadata.adoc, +Spring Boot's configuration file handling is quite flexible; and it is often the case, +that properties may exist that are not bound to a `@ConfigurationProperties` bean. You, +may also need to tune some attributes of an existing key. To support such cases and allow, +you to provide custom "hints", the annotation processor will automatically merge items, +from `META-INF/additional-spring-configuration-metadata.json` into the main meta-data, +file., +, +If you refer to a property that has been detected automatically, the description,, +default value and deprecation information are overridden if specified. If the manual, +property declaration is not identified in the current module, it is added as a brand new, +property., +++ b/spring-boot-tools/spring-boot-configuration-processor/src/main/java/org/springframework/boot/configurationprocessor/ConfigurationMetadataAnnotationProcessor.java, +			merged.merge(this.metadataStore.readAdditionalMetadata());, +++ b/spring-boot-tools/spring-boot-configuration-processor/src/main/java/org/springframework/boot/configurationprocessor/metadata/ConfigurationMetadata.java, +import java.util.ListIterator;, +import org.springframework.util.CollectionUtils;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +import org.springframework.util.ObjectUtils;, +, +	private final MultiValueMap<String, ItemMetadata> items;, +	private final MultiValueMap<String, ItemHint> hints;, +		this.items = new LinkedMultiValueMap<String, ItemMetadata>();, +		this.hints = new LinkedMultiValueMap<String, ItemHint>();, +		this.items = new LinkedMultiValueMap<String, ItemMetadata>(metadata.items);, +		this.hints = new LinkedMultiValueMap<String, ItemHint>(metadata.hints);, +		this.items.add(itemMetadata.getName(), itemMetadata);, +	 * Add item hint., +	 * @param itemHint the item hint to add, +	 */, +	public void add(ItemHint itemHint) {, +		this.hints.add(itemHint.getName(), itemHint);, +	}, +, +	/**, +	 * Merge the content from another {@link ConfigurationMetadata}., +	public void merge(ConfigurationMetadata metadata) {, +		for (ItemMetadata additionalItem : metadata.getItems()) {, +			mergeItemMetadata(additionalItem);, +		}, +		for (ItemHint itemHint : metadata.getHints()) {, +			add(itemHint);, +		}, +		return flattenValues(this.items);, +		return flattenValues(this.hints);, +	protected void mergeItemMetadata(ItemMetadata metadata) {, +		ItemMetadata matching = findMatchingItemMetadata(metadata);, +		if (matching != null) {, +			if (metadata.getDescription() != null) {, +				matching.setDescription(metadata.getDescription());, +			}, +			if (metadata.getDefaultValue() != null) {, +				matching.setDefaultValue(metadata.getDefaultValue());, +			}, +			ItemDeprecation deprecation = metadata.getDeprecation();, +			ItemDeprecation matchingDeprecation = matching.getDeprecation();, +			if (deprecation != null) {, +				if (matchingDeprecation == null) {, +					matching.setDeprecation(deprecation);, +				}, +				else {, +					if (deprecation.getReason() != null) {, +						matchingDeprecation.setReason(deprecation.getReason());, +					}, +					if (deprecation.getReplacement() != null) {, +						matchingDeprecation.setReplacement(deprecation.getReplacement());, +					}, +				}, +			}, +		}, +		else {, +			this.items.add(metadata.getName(), metadata);, +		}]