[+++ b/spring-boot-project/spring-boot-docs/src/main/asciidoc/howto.adoc, +[[how-to-enable-http-response-compression]], +=== Enable HTTP Response Compression, +HTTP response compression is supported by Jetty, Tomcat, and Undertow. It can be enabled, +in `application.properties`, as follows:, +, +[source,properties,indent=0,subs="verbatim,quotes,attributes"], +----, +	server.compression.enabled=true, +----, +, +By default, responses must be at least 2048 bytes in length for compression to be, +performed. You can configure this behavior by setting the, +`server.compression.min-response-size` property., +, +By default, responses are compressed only if their content type is one of the, +following:, +, +* `text/html`, +* `text/xml`, +* `text/plain`, +* `text/css`, +, +You can configure this behavior by setting the `server.compression.mime-types` property., +, +, +, +[[howto-configure-webserver]], +=== Configure the Web Server, +, +Generally, you should first consider using one of the many available configuration keys, +and customize your web server by adding new entries in your `application.properties` (or, +`application.yml`, or environment, etc. see, +"`<<howto-discover-build-in-options-for-external-properties>>`"). The `server.{asterisk}`, +namespace is quite useful here, and it includes namespaces like `server.tomcat.{asterisk}`,, +`server.jetty.{asterisk}` and others, for server-specific features., +See the list of <<common-application-properties>>., +, +The previous sections covered already many common use cases, such as compression, SSL, +or HTTP/2. However, if a configuration key doesn't exist for your use case, you should, +then look at, +{dc-spring-boot}/web/server/WebServerFactoryCustomizer.html[`WebServerFactoryCustomizer`]., +You can declare such a component and get access to the server factory relevant to your, +choice: you should select the variant for the chosen Server (Tomcat, Jetty, Reactor Netty,, +Undertow) and the chosen web stack (Servlet or Reactive)., +, +In the following example, we're using Tomcat in a Servlet-based web application:, +, +[source,java,indent=0,subs="verbatim,quotes,attributes"], +----, +	@Component, +	public class MyTomcatWebServerCustomizer, +			implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {, +, +		@Override, +		public void customize(TomcatServletWebServerFactory factory) {, +			// customize the factory here, +		}, +	}, +----, +, +Spring Boot currently provides:, +, +* `TomcatServletWebServerFactory` and `TomcatReactiveWebServerFactory` for Tomcat, +* `JettyServletWebServerFactory` and `JettyReactiveWebServerFactory` for Jetty, +* `UndertowServletWebServerFactory` and `UndertowReactiveWebServerFactory` for Undertow, +* `NettyReactiveWebServerFactory` for Reactor Netty, +, +Once you've got access to a `WebServerFactory`, you can often add customizers to it to, +configure specific parts, like connectors, server resources, or the server itself - all, +using server-specific APIs., +, +As a last resort, you can also declare your own `WebServerFactory` component, which will, +override the one provided by Spring Boot. In this case, you can't rely on configuration, +properties in the `server` namespace anymore., +, +, +, +[[howto-add-a-servlet-filter-or-listener]], +=== Add a Servlet, Filter, or Listener to an Application, +There are two ways to add `Servlet`, `Filter`, `ServletContextListener`, and the other, +listeners supported by the Servlet spec to your application:, +, +* <<howto-add-a-servlet-filter-or-listener-as-spring-bean>>, +* <<howto-add-a-servlet-filter-or-listener-using-scanning>>, +, +, +, +[[howto-add-a-servlet-filter-or-listener-as-spring-bean]], +==== Add a Servlet, Filter, or Listener by Using a Spring Bean, +To add a `Servlet`, `Filter`, or Servlet `*Listener` by using a Spring bean, you must, +provide a `@Bean` definition for it. Doing so can be very useful when you want to inject, +configuration or dependencies. However, you must be very careful that they do not cause, +eager initialization of too many other beans, because they have to be installed in the, +container very early in the application lifecycle. (For example, it is not a good idea to, +have them depend on your `DataSource` or JPA configuration.) You can work around such, +restrictions by initializing the beans lazily when first used instead of on, +initialization., +, +In the case of `Filters` and `Servlets`, you can also add mappings and init parameters by]