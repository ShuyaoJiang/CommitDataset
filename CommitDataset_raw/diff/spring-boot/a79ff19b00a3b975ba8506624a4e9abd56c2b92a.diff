[+++ b/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc, +In the normal Spring way, you can use a `spring.profiles.active`, +`Environment` property to specify which profiles are active. You can, +specify the property in any of the usual ways, for example you could, +include it in your `application.properties`:, +profiles rather than replace them. The `spring.profiles.include` property can be used, +to unconditionally add active profiles. The `SpringApplication` entry point also has, +a Java API for setting additional profiles (i.e. on top of those activated by the, +`spring.profiles.active` property): see the `setAdditionalProfiles()` method., +	spring.profiles.include: proddb,prodmq, +++ b/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc, +In the normal Spring way, you can use a `spring.profiles.active`, +`Environment` property to specify which profiles are active. You can, +specify the property in any of the usual ways, for example you could, +include it in your `application.properties`:, +profiles rather than replace them. The `spring.profiles.include` property can be used, +to unconditionally add active profiles. The `SpringApplication` entry point also has, +a Java API for setting additional profiles (i.e. on top of those activated by the, +`spring.profiles.active` property): see the `setAdditionalProfiles()` method., +	spring.profiles.include: proddb,prodmq, +++ b/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigFileApplicationListener.java, +	private static final String INCLUDE_PROFILES_PROPERTY = "spring.profiles.include";, +, +				// properties) take precedence over those added in config files., +				maybeActivateProfiles(this.environment, +						.getProperty(ACTIVE_PROFILES_PROPERTY));, +					maybeActivateProfiles(propertySource, +					addIncludeProfiles(propertySource, +							.getProperty(INCLUDE_PROFILES_PROPERTY));, +		private void maybeActivateProfiles(Object value) {, +			if (!this.activatedProfiles == true) {, +				Set<String> profiles = getProfilesForValue(value);, +				activateProfiles(profiles);, +				if (profiles.size() > 0) {, +					this.activatedProfiles = true;, +				}, +			}, +		}, +, +		private void addIncludeProfiles(Object value) {, +			Set<String> profiles = getProfilesForValue(value);, +			activateProfiles(profiles);, +		}, +, +		private Set<String> getProfilesForValue(Object property) {, +			return asResolvedSet((property == null ? null : property.toString()), null);, +		}, +, +		private void activateProfiles(Set<String> profiles) {, +			for (String profile : profiles) {, +++ b/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc, +In the normal Spring way, you can use a `spring.profiles.active`, +`Environment` property to specify which profiles are active. You can, +specify the property in any of the usual ways, for example you could, +include it in your `application.properties`:, +profiles rather than replace them. The `spring.profiles.include` property can be used, +to unconditionally add active profiles. The `SpringApplication` entry point also has, +a Java API for setting additional profiles (i.e. on top of those activated by the, +`spring.profiles.active` property): see the `setAdditionalProfiles()` method., +	spring.profiles.include: proddb,prodmq, +++ b/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigFileApplicationListener.java, +	private static final String INCLUDE_PROFILES_PROPERTY = "spring.profiles.include";, +, +				// properties) take precedence over those added in config files., +				maybeActivateProfiles(this.environment, +						.getProperty(ACTIVE_PROFILES_PROPERTY));, +					maybeActivateProfiles(propertySource, +					addIncludeProfiles(propertySource, +							.getProperty(INCLUDE_PROFILES_PROPERTY));, +		private void maybeActivateProfiles(Object value) {, +			if (!this.activatedProfiles == true) {, +				Set<String> profiles = getProfilesForValue(value);, +				activateProfiles(profiles);, +				if (profiles.size() > 0) {, +					this.activatedProfiles = true;, +				}, +			}, +		}, +, +		private void addIncludeProfiles(Object value) {, +			Set<String> profiles = getProfilesForValue(value);, +			activateProfiles(profiles);, +		}, +, +		private Set<String> getProfilesForValue(Object property) {, +			return asResolvedSet((property == null ? null : property.toString()), null);, +		}, +, +		private void activateProfiles(Set<String> profiles) {, +			for (String profile : profiles) {, +++ b/spring-boot/src/test/java/org/springframework/boot/context/config/ConfigFileApplicationListenerTests.java, +				.run("--spring.profiles.active=includeprofile");, +		assertThat(context.getEnvironment(), acceptsProfiles("includeprofile"));, +++ b/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc, +In the normal Spring way, you can use a `spring.profiles.active`, +`Environment` property to specify which profiles are active. You can, +specify the property in any of the usual ways, for example you could, +include it in your `application.properties`:, +profiles rather than replace them. The `spring.profiles.include` property can be used, +to unconditionally add active profiles. The `SpringApplication` entry point also has]