[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java, +	public ConditionEvaluationReport getDelta(ConditionEvaluationReport previousReport) {, +		ConditionEvaluationReport delta = new ConditionEvaluationReport();, +		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +			ConditionAndOutcomes previous = previousReport.outcomes.get(entry.getKey());, +			if (previous == null, +					|| previous.isFullMatch() != entry.getValue().isFullMatch()) {, +				entry.getValue(), +						.forEach((conditionAndOutcome) -> delta.recordConditionEvaluation(, +								entry.getKey(), conditionAndOutcome.getCondition(),, +								conditionAndOutcome.getOutcome()));, +			}, +		}, +		List<String> newExclusions = new ArrayList<>(this.exclusions);, +		newExclusions.removeAll(previousReport.getExclusions());, +		delta.recordExclusions(newExclusions);, +		List<String> newUnconditionalClasses = new ArrayList<>(this.unconditionalClasses);, +		newUnconditionalClasses.removeAll(previousReport.unconditionalClasses);, +		delta.unconditionalClasses.addAll(newUnconditionalClasses);, +		return delta;, +	}, +, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java, +	public ConditionEvaluationReport getDelta(ConditionEvaluationReport previousReport) {, +		ConditionEvaluationReport delta = new ConditionEvaluationReport();, +		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +			ConditionAndOutcomes previous = previousReport.outcomes.get(entry.getKey());, +			if (previous == null, +					|| previous.isFullMatch() != entry.getValue().isFullMatch()) {, +				entry.getValue(), +						.forEach((conditionAndOutcome) -> delta.recordConditionEvaluation(, +								entry.getKey(), conditionAndOutcome.getCondition(),, +								conditionAndOutcome.getOutcome()));, +			}, +		}, +		List<String> newExclusions = new ArrayList<>(this.exclusions);, +		newExclusions.removeAll(previousReport.getExclusions());, +		delta.recordExclusions(newExclusions);, +		List<String> newUnconditionalClasses = new ArrayList<>(this.unconditionalClasses);, +		newUnconditionalClasses.removeAll(previousReport.unconditionalClasses);, +		delta.unconditionalClasses.addAll(newUnconditionalClasses);, +		return delta;, +	}, +, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/logging/ConditionEvaluationReportMessage.java, +import java.util.Map.Entry;, +import java.util.stream.Collectors;, + * @author Andy Wilkinson, +		this(report, "CONDITIONS EVALUATION REPORT");, +	public ConditionEvaluationReportMessage(ConditionEvaluationReport report,, +			String title) {, +		this.message = getLogMessage(report, title);, +	}, +, +	private StringBuilder getLogMessage(ConditionEvaluationReport report, String title) {, +		StringBuilder separator = new StringBuilder();, +		for (int i = 0; i < title.length(); i++) {, +			separator.append("=");, +		}, +		message.append(String.format("%s%n", separator));, +		message.append(String.format("%s%n", title));, +		message.append(String.format("%s%n%n%n", separator));, +		logPositiveMatches(message, shortOutcomes);, +		logNegativeMatches(message, shortOutcomes);, +		logExclusions(report, message);, +		logUnconditionalClasses(report, message);, +		message.append(String.format("%n%n"));, +		return message;, +, +	private void logPositiveMatches(StringBuilder message,, +			Map<String, ConditionAndOutcomes> shortOutcomes) {, +		message.append(String.format("Positive matches:%n"));, +		message.append(String.format("-----------------%n"));, +		List<Entry<String, ConditionAndOutcomes>> matched = shortOutcomes.entrySet(), +				.stream().filter((entry) -> entry.getValue().isFullMatch()), +				.collect(Collectors.toList());, +		if (matched.isEmpty()) {, +			message.append(String.format("%n    None%n"));, +		}, +		else {, +			matched.forEach((entry) -> addMatchLogMessage(message, entry.getKey(),, +					entry.getValue()));, +	}, +, +	private void logNegativeMatches(StringBuilder message,, +			Map<String, ConditionAndOutcomes> shortOutcomes) {, +		List<Entry<String, ConditionAndOutcomes>> nonMatched = shortOutcomes.entrySet(), +				.stream().filter((entry) -> !entry.getValue().isFullMatch()), +				.collect(Collectors.toList());, +		if (nonMatched.isEmpty()) {, +			message.append(String.format("%n    None%n"));, +		else {, +			nonMatched.forEach((entry) -> addNonMatchLogMessage(message, entry.getKey(),, +					entry.getValue()));, +	}, +, +	private void logExclusions(ConditionEvaluationReport report, StringBuilder message) {, +	}, +, +	private void logUnconditionalClasses(ConditionEvaluationReport report,]