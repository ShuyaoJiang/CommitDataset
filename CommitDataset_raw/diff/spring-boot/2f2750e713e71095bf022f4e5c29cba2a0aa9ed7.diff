[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.Map;, +import org.springframework.boot.actuate.metrics.export.MetricExportProperties;, +import org.springframework.boot.actuate.metrics.export.MetricExporters;, +@EnableConfigurationProperties(MetricExportProperties.class), +		private Map<String, MetricWriter> writers = Collections.emptyMap();, +		private MetricExportProperties metrics;, +		public MetricExporters metricWritersMetricExporter(MetricReader reader) {, +			Map<String, MetricWriter> writers = new HashMap<String, MetricWriter>(, +					this.writers);, +					&& writers.containsValue(this.actuatorMetricRepository)) {, +				for (String name : this.writers.keySet()) {, +					if (writers.get(name).equals(this.actuatorMetricRepository)) {, +						writers.remove(name);, +			MetricExporters exporters = new MetricExporters(reader, writers, this.metrics);, +			return exporters;, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.Map;, +import org.springframework.boot.actuate.metrics.export.MetricExportProperties;, +import org.springframework.boot.actuate.metrics.export.MetricExporters;, +@EnableConfigurationProperties(MetricExportProperties.class), +		private Map<String, MetricWriter> writers = Collections.emptyMap();, +		private MetricExportProperties metrics;, +		public MetricExporters metricWritersMetricExporter(MetricReader reader) {, +			Map<String, MetricWriter> writers = new HashMap<String, MetricWriter>(, +					this.writers);, +					&& writers.containsValue(this.actuatorMetricRepository)) {, +				for (String name : this.writers.keySet()) {, +					if (writers.get(name).equals(this.actuatorMetricRepository)) {, +						writers.remove(name);, +			MetricExporters exporters = new MetricExporters(reader, writers, this.metrics);, +			return exporters;, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricExportProperties.java, +package org.springframework.boot.actuate.metrics.export;, +, +import java.util.Arrays;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.Map.Entry;, +, +import javax.annotation.PostConstruct;, +import org.springframework.util.PatternMatchUtils;, +@ConfigurationProperties("spring.metrics.export"), +public class MetricExportProperties {, +	 * Flag to disable all metric exports (assuming any MetricWriters are available)., +	private Export export = new Export();, +, +	private Map<String, Export> writers = new LinkedHashMap<String, Export>();, +, +	 * Default values for trigger configuration for all writers. Can also be set by, +	 * including a writer with <code>name="*"</code>., +	 *, +	 * @return the default trigger configuration, +	public Export getDefault() {, +		return this.export;, +	/**, +	 * Configuration for triggers on individual named writers. Each value can individually, +	 * specify a name pattern explicitly, or else the map key will be used if the name is, +	 * not set., +	 *, +	 * @return the writers, +	 */, +	public Map<String, Export> getWriters() {, +		return this.writers;, +	@PostConstruct, +	public void setDefaults() {, +		Export defaults = null;, +		for (Entry<String, Export> entry : this.writers.entrySet()) {, +			String key = entry.getKey();, +			Export value = entry.getValue();, +			if (value.getNames() == null || value.getNames().length == 0) {, +				value.setNames(new String[] { key });, +			if (Arrays.asList(value.getNames()).contains("*")) {, +				defaults = value;, +			}, +		}, +		if (defaults == null) {, +			this.export.setNames(new String[] { "*" });, +			this.writers.put("*", this.export);, +			defaults = this.export;, +		}, +		if (defaults.isIgnoreTimestamps() == null) {, +			defaults.setIgnoreTimestamps(false);, +		}, +		if (defaults.isSendLatest() == null) {, +			defaults.setSendLatest(true);, +		}, +		if (defaults.getDelayMillis() == null) {, +			defaults.setDelayMillis(5000);, +		}, +		for (Export value : this.writers.values()) {, +			if (value.isIgnoreTimestamps() == null) {, +				value.setIgnoreTimestamps(false);, +			}, +			if (value.isSendLatest() == null) {, +				value.setSendLatest(true);]