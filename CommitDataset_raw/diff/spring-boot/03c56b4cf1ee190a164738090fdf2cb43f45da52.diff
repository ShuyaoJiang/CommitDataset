[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricCopyExporter.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.boot.actuate.metrics.writer.CounterWriter;, +import org.springframework.boot.actuate.metrics.writer.Delta;, +import org.springframework.boot.actuate.metrics.writer.GaugeWriter;, + * {@link MetricReader} to a destination {@link MetricWriter}. Actually the output writer, + * can be a {@link GaugeWriter}, in which case all metrics are simply output as their, + * current value. If the output writer is also a {@link CounterWriter} then metrics whose, + * names begin with "counter." are special: instead of writing them out as simple gauges, + * the writer will increment the counter value. This involves the exporter storing the, + * previous value of the counter so the delta can be computed. For best results with the, + * counters, do not use the exporter concurrently in multiple threads (normally it will, + * only be used periodically and sequentially, even if it is in a background thread, and, + * this is fine)., +	private final GaugeWriter writer;, +, +	private final CounterWriter counter;, +, +	private ConcurrentMap<String, Long> counts = new ConcurrentHashMap<String, Long>();, +	public MetricCopyExporter(MetricReader reader, GaugeWriter writer) {, +	public MetricCopyExporter(MetricReader reader, GaugeWriter writer, String prefix) {, +		if (writer instanceof CounterWriter) {, +			this.counter = (CounterWriter) writer;, +		}, +		else {, +			this.counter = null;, +		}, +			if (value.getName().startsWith("counter.") && this.counter != null) {, +				this.counter.increment(calculateDelta(value));, +			}, +			else {, +	}, +, +	private Delta<?> calculateDelta(Metric<?> value) {, +		long delta = value.getValue().longValue();, +		Long old = this.counts.replace(value.getName(), delta);, +		if (old != null) {, +			delta = delta - old;, +		}, +		else {, +			this.counts.putIfAbsent(value.getName(), delta);, +		}, +		return new Delta<Long>(value.getName(), delta, value.getTimestamp());, +	}, +	private void flush(GaugeWriter writer) {, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricCopyExporter.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.boot.actuate.metrics.writer.CounterWriter;, +import org.springframework.boot.actuate.metrics.writer.Delta;, +import org.springframework.boot.actuate.metrics.writer.GaugeWriter;, + * {@link MetricReader} to a destination {@link MetricWriter}. Actually the output writer, + * can be a {@link GaugeWriter}, in which case all metrics are simply output as their, + * current value. If the output writer is also a {@link CounterWriter} then metrics whose, + * names begin with "counter." are special: instead of writing them out as simple gauges, + * the writer will increment the counter value. This involves the exporter storing the, + * previous value of the counter so the delta can be computed. For best results with the, + * counters, do not use the exporter concurrently in multiple threads (normally it will, + * only be used periodically and sequentially, even if it is in a background thread, and, + * this is fine)., +	private final GaugeWriter writer;, +, +	private final CounterWriter counter;, +, +	private ConcurrentMap<String, Long> counts = new ConcurrentHashMap<String, Long>();, +	public MetricCopyExporter(MetricReader reader, GaugeWriter writer) {, +	public MetricCopyExporter(MetricReader reader, GaugeWriter writer, String prefix) {, +		if (writer instanceof CounterWriter) {, +			this.counter = (CounterWriter) writer;, +		}, +		else {, +			this.counter = null;, +		}, +			if (value.getName().startsWith("counter.") && this.counter != null) {, +				this.counter.increment(calculateDelta(value));, +			}, +			else {, +	}, +, +	private Delta<?> calculateDelta(Metric<?> value) {, +		long delta = value.getValue().longValue();, +		Long old = this.counts.replace(value.getName(), delta);, +		if (old != null) {, +			delta = delta - old;, +		}, +		else {, +			this.counts.putIfAbsent(value.getName(), delta);, +		}, +		return new Delta<Long>(value.getName(), delta, value.getTimestamp());, +	}, +	private void flush(GaugeWriter writer) {, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/opentsdb/OpenTsdbMetricWriter.java, +import org.springframework.boot.actuate.metrics.writer.GaugeWriter;, +public class OpenTsdbMetricWriter implements GaugeWriter {, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/MetricCopyExporter.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.boot.actuate.metrics.writer.CounterWriter;, +import org.springframework.boot.actuate.metrics.writer.Delta;]