[+++ b/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/DefinitionsParser.java, +import org.springframework.core.ResolvableType;, +		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToMock.isEmpty(),, +				"Unable to deduce type to mock from " + element);, +			Assert.state(typesToMock.size() == 1,, +		for (ResolvableType typeToMock : typesToMock) {, +			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock,, +		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToSpy.isEmpty(),, +				"Unable to deduce type to spy from " + element);, +			Assert.state(typesToSpy.size() == 1,, +		for (ResolvableType typeToSpy : typesToSpy) {, +			SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy,, +	private Set<ResolvableType> getOrDeduceTypes(AnnotatedElement element,, +			Class<?>[] value) {, +		Set<ResolvableType> types = new LinkedHashSet<ResolvableType>();, +		for (Class<?> type : value) {, +			types.add(ResolvableType.forClass(type));, +		if (types.isEmpty() && element instanceof Field) {, +			types.add(ResolvableType.forField((Field) element));, +		}, +		return types;, +++ b/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/DefinitionsParser.java, +import org.springframework.core.ResolvableType;, +		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToMock.isEmpty(),, +				"Unable to deduce type to mock from " + element);, +			Assert.state(typesToMock.size() == 1,, +		for (ResolvableType typeToMock : typesToMock) {, +			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock,, +		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToSpy.isEmpty(),, +				"Unable to deduce type to spy from " + element);, +			Assert.state(typesToSpy.size() == 1,, +		for (ResolvableType typeToSpy : typesToSpy) {, +			SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy,, +	private Set<ResolvableType> getOrDeduceTypes(AnnotatedElement element,, +			Class<?>[] value) {, +		Set<ResolvableType> types = new LinkedHashSet<ResolvableType>();, +		for (Class<?> type : value) {, +			types.add(ResolvableType.forClass(type));, +		if (types.isEmpty() && element instanceof Field) {, +			types.add(ResolvableType.forField((Field) element));, +		}, +		return types;, +++ b/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/MockDefinition.java, +import org.springframework.core.ResolvableType;, +	private final ResolvableType typeToMock;, +		this(ResolvableType.forClass(classToMock));, +	MockDefinition(ResolvableType typeToMock) {, +		this(null, typeToMock, null, null, false, null, true);, +	}, +, +	MockDefinition(String name, ResolvableType typeToMock, Class<?>[] extraInterfaces,, +		Assert.notNull(typeToMock, "TypeToMock must not be null");, +		this.typeToMock = typeToMock;, +	 * Return the type that should be mocked., +	public ResolvableType getTypeToMock() {, +		return this.typeToMock;, +		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.typeToMock);, +		result &= ObjectUtils.nullSafeEquals(this.typeToMock, other.typeToMock);, +				.append("typeToMock", this.typeToMock), +		return (T) Mockito.mock(this.typeToMock.resolve(), settings);, +++ b/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/DefinitionsParser.java, +import org.springframework.core.ResolvableType;, +		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToMock.isEmpty(),, +				"Unable to deduce type to mock from " + element);, +			Assert.state(typesToMock.size() == 1,, +		for (ResolvableType typeToMock : typesToMock) {, +			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock,, +		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value());, +		Assert.state(!typesToSpy.isEmpty(),, +				"Unable to deduce type to spy from " + element);, +			Assert.state(typesToSpy.size() == 1,, +		for (ResolvableType typeToSpy : typesToSpy) {, +			SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy,, +	private Set<ResolvableType> getOrDeduceTypes(AnnotatedElement element,, +			Class<?>[] value) {, +		Set<ResolvableType> types = new LinkedHashSet<ResolvableType>();, +		for (Class<?> type : value) {, +			types.add(ResolvableType.forClass(type));, +		if (types.isEmpty() && element instanceof Field) {, +			types.add(ResolvableType.forField((Field) element));, +		}, +		return types;, +++ b/spring-boot-test/src/main/java/org/springframework/boot/test/mock/mockito/MockDefinition.java, +import org.springframework.core.ResolvableType;, +	private final ResolvableType typeToMock;, +		this(ResolvableType.forClass(classToMock));, +	MockDefinition(ResolvableType typeToMock) {, +		this(null, typeToMock, null, null, false, null, true);, +	}, +, +	MockDefinition(String name, ResolvableType typeToMock, Class<?>[] extraInterfaces,, +		Assert.notNull(typeToMock, "TypeToMock must not be null");, +		this.typeToMock = typeToMock;, +	 * Return the type that should be mocked., +	public ResolvableType getTypeToMock() {]