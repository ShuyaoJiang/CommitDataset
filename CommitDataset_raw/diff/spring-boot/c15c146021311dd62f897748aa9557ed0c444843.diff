[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/DefaultErrorViewResolver.java, +import java.util.LinkedHashMap;, +import java.util.concurrent.ConcurrentHashMap;, +	private static final int CACHE_LIMIT = 1024;, +, +	private static final Object UNRESOLVED = new Object();, +, +	 * resolved template views, returning already cached instances without a global lock., +	 */, +	private final Map<Object, Object> resolved = new ConcurrentHashMap<Object, Object>(, +			CACHE_LIMIT);, +, +	/**, +	 * Map from view name resolve template view, synchronized when accessed., +	 */, +	@SuppressWarnings("serial"), +	private final Map<Object, Object> cache = new LinkedHashMap<Object, Object>(, +			CACHE_LIMIT, 0.75f, true) {, +, +		@Override, +		protected boolean removeEldestEntry(Map.Entry<Object, Object> eldest) {, +			if (size() > CACHE_LIMIT) {, +				DefaultErrorViewResolver.this.resolved.remove(eldest.getKey());, +				return true;, +			}, +			return false;, +		}, +, +	};, +, +	/**, +		Object resolved = this.resolved.get(viewName);, +		if (resolved == null) {, +			synchronized (this.cache) {, +				resolved = resolveTemplateViewName(viewName);, +				resolved = (resolved == null ? UNRESOLVED : resolved);, +				this.resolved.put(viewName, resolved);, +				this.cache.put(viewName, resolved);, +			}, +		}, +		return (resolved == UNRESOLVED ? null, +				: new ModelAndView((String) resolved, model));, +	}, +, +	private String resolveTemplateViewName(String viewName) {, +				return "error/" + viewName;, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/DefaultErrorViewResolver.java, +import java.util.LinkedHashMap;, +import java.util.concurrent.ConcurrentHashMap;, +	private static final int CACHE_LIMIT = 1024;, +, +	private static final Object UNRESOLVED = new Object();, +, +	 * resolved template views, returning already cached instances without a global lock., +	 */, +	private final Map<Object, Object> resolved = new ConcurrentHashMap<Object, Object>(, +			CACHE_LIMIT);, +, +	/**, +	 * Map from view name resolve template view, synchronized when accessed., +	 */, +	@SuppressWarnings("serial"), +	private final Map<Object, Object> cache = new LinkedHashMap<Object, Object>(, +			CACHE_LIMIT, 0.75f, true) {, +, +		@Override, +		protected boolean removeEldestEntry(Map.Entry<Object, Object> eldest) {, +			if (size() > CACHE_LIMIT) {, +				DefaultErrorViewResolver.this.resolved.remove(eldest.getKey());, +				return true;, +			}, +			return false;, +		}, +, +	};, +, +	/**, +		Object resolved = this.resolved.get(viewName);, +		if (resolved == null) {, +			synchronized (this.cache) {, +				resolved = resolveTemplateViewName(viewName);, +				resolved = (resolved == null ? UNRESOLVED : resolved);, +				this.resolved.put(viewName, resolved);, +				this.cache.put(viewName, resolved);, +			}, +		}, +		return (resolved == UNRESOLVED ? null, +				: new ModelAndView((String) resolved, model));, +	}, +, +	private String resolveTemplateViewName(String viewName) {, +				return "error/" + viewName;, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/web/DefaultErrorViewResolverTests.java, +import static org.mockito.Mockito.times;, +	public void resolveShouldCacheTemplate() throws Exception {, +		given(this.templateAvailabilityProvider.isTemplateAvailable(eq("error/4xx"),, +				any(Environment.class), any(ClassLoader.class),, +				any(ResourceLoader.class))).willReturn(true);, +		for (int i = 0; i < 10; i++) {, +			ModelAndView resolved = this.resolver.resolveErrorView(this.request,]