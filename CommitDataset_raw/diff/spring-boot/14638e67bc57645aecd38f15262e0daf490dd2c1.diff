[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration.java, +		DelegatingWebMvcValidator(Validator targetValidator) {, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration.java, +		DelegatingWebMvcValidator(Validator targetValidator) {, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/validation/DelegatingValidatorTests.java, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration.java, +		DelegatingWebMvcValidator(Validator targetValidator) {, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/validation/DelegatingValidatorTests.java, +++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +  Archive paths can be relative to `loader.home`, or anywhere in the file system with a, +  `jar:file:` prefix., +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration.java, +		DelegatingWebMvcValidator(Validator targetValidator) {, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/validation/DelegatingValidatorTests.java, +++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +  Archive paths can be relative to `loader.home`, or anywhere in the file system with a, +  `jar:file:` prefix., +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +			// "" means the user wants root of archive but not current directory, +			path = ("".equals(path) ? "/" : path);, +		Set<URL> urls = new LinkedHashSet<URL>(archives.size());, +		for (Archive archive : archives) {, +			urls.add(archive.getUrl());, +		}, +		ClassLoader loader = new LaunchedURLClassLoader(urls.toArray(new URL[0]),, +				getClass().getClassLoader());, +		debug("Classpath: " + urls);, +		if (!"/".equals(root)) {, +		}, +	private List<Archive> getNestedArchives(String path) throws Exception {, +		Archive parent = this.parent;, +		String root = path;, +		if (!root.equals("/") && root.startsWith("/"), +				|| parent.getUrl().equals(this.home.toURI().toURL())) {, +		if (root.contains("!")) {, +			File file = new File(this.home, root.substring(0, index));, +			if (root.startsWith("jar:file:")) {, +				file = new File(root.substring("jar:file:".length(), index));, +			}, +			parent = new JarFileArchive(file);, +		if (root.endsWith(".jar")) {, +			File file = new File(this.home, root);, +			if (file.exists()) {, +				parent = new JarFileArchive(file);, +				root = "";, +			}, +		}, +		if (root.equals("/") || root.equals("./") || root.equals(".")) {, +			// The prefix for nested jars is actually empty if it's at the root, +			root = "";, +		}, +		List<Archive> archives = new ArrayList<Archive>(parent.getNestedArchives(filter));, +		if (("".equals(root) || ".".equals(root)) && !path.endsWith(".jar"), +				&& parent != this.parent) {, +			// You can't find the root with an entry filter so it has to be added, +			// explicitly. But don't add the root of the parent archive., +			archives.add(parent);, +		}, +		return archives;, +						return entry.getName().equals(JarLauncher.BOOT_INF_CLASSES);, +			if (entry.isDirectory()) {, +				return entry.getName().equals(this.prefix);, +			}, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration.java, +		DelegatingWebMvcValidator(Validator targetValidator) {, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/validation/DelegatingValidatorTests.java, +++ b/spring-boot-docs/src/main/asciidoc/appendix-executable-jar-format.adoc, +  Archive paths can be relative to `loader.home`, or anywhere in the file system with a, +  `jar:file:` prefix., +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +			// "" means the user wants root of archive but not current directory, +			path = ("".equals(path) ? "/" : path);, +		Set<URL> urls = new LinkedHashSet<URL>(archives.size());, +		for (Archive archive : archives) {, +			urls.add(archive.getUrl());, +		}, +		ClassLoader loader = new LaunchedURLClassLoader(urls.toArray(new URL[0]),, +				getClass().getClassLoader());, +		debug("Classpath: " + urls);, +		if (!"/".equals(root)) {, +		}, +	private List<Archive> getNestedArchives(String path) throws Exception {, +		Archive parent = this.parent;, +		String root = path;, +		if (!root.equals("/") && root.startsWith("/"), +				|| parent.getUrl().equals(this.home.toURI().toURL())) {, +		if (root.contains("!")) {, +			File file = new File(this.home, root.substring(0, index));, +			if (root.startsWith("jar:file:")) {, +				file = new File(root.substring("jar:file:".length(), index));, +			}, +			parent = new JarFileArchive(file);, +		if (root.endsWith(".jar")) {, +			File file = new File(this.home, root);, +			if (file.exists()) {, +				parent = new JarFileArchive(file);]