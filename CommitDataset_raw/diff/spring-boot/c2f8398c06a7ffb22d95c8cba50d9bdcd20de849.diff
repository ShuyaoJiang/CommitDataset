[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnBeanCondition.java, +import org.springframework.boot.autoconfigure.AutoConfigurationMetadata;, +class OnBeanCondition extends FilteringSpringBootCondition, +		implements ConfigurationCondition {, +	protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,, +			AutoConfigurationMetadata autoConfigurationMetadata) {, +		ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];, +		for (int i = 0; i < outcomes.length; i++) {, +			String autoConfigurationClass = autoConfigurationClasses[i];, +			if (autoConfigurationClass != null) {, +				Set<String> onBeanTypes = autoConfigurationMetadata, +						.getSet(autoConfigurationClass, "ConditionalOnBean");, +				outcomes[i] = getOutcome(onBeanTypes, ConditionalOnBean.class);, +				if (outcomes[i] == null) {, +					Set<String> onSingleCandidateTypes = autoConfigurationMetadata.getSet(, +							autoConfigurationClass, "ConditionalOnSingleCandidate");, +					outcomes[i] = getOutcome(onSingleCandidateTypes,, +							ConditionalOnSingleCandidate.class);, +				}, +			}, +		}, +		return outcomes;, +	}, +, +	private ConditionOutcome getOutcome(Set<String> requiredBeanTypes,, +			Class<? extends Annotation> annotation) {, +		List<String> missing = filter(requiredBeanTypes, ClassNameFilter.MISSING,, +				getBeanClassLoader());, +		if (!missing.isEmpty()) {, +			ConditionMessage message = ConditionMessage.forCondition(annotation), +					.didNotFind("required type", "required types"), +					.items(Style.QUOTE, missing);, +			return ConditionOutcome.noMatch(message);, +		}, +		return null;, +	}, +, +	@Override, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnBeanCondition.java, +import org.springframework.boot.autoconfigure.AutoConfigurationMetadata;, +class OnBeanCondition extends FilteringSpringBootCondition, +		implements ConfigurationCondition {, +	protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,, +			AutoConfigurationMetadata autoConfigurationMetadata) {, +		ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];, +		for (int i = 0; i < outcomes.length; i++) {, +			String autoConfigurationClass = autoConfigurationClasses[i];, +			if (autoConfigurationClass != null) {, +				Set<String> onBeanTypes = autoConfigurationMetadata, +						.getSet(autoConfigurationClass, "ConditionalOnBean");, +				outcomes[i] = getOutcome(onBeanTypes, ConditionalOnBean.class);, +				if (outcomes[i] == null) {, +					Set<String> onSingleCandidateTypes = autoConfigurationMetadata.getSet(, +							autoConfigurationClass, "ConditionalOnSingleCandidate");, +					outcomes[i] = getOutcome(onSingleCandidateTypes,, +							ConditionalOnSingleCandidate.class);, +				}, +			}, +		}, +		return outcomes;, +	}, +, +	private ConditionOutcome getOutcome(Set<String> requiredBeanTypes,, +			Class<? extends Annotation> annotation) {, +		List<String> missing = filter(requiredBeanTypes, ClassNameFilter.MISSING,, +				getBeanClassLoader());, +		if (!missing.isEmpty()) {, +			ConditionMessage message = ConditionMessage.forCondition(annotation), +					.didNotFind("required type", "required types"), +					.items(Style.QUOTE, missing);, +			return ConditionOutcome.noMatch(message);, +		}, +		return null;, +	}, +, +	@Override, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories, +org.springframework.boot.autoconfigure.condition.OnBeanCondition,\]