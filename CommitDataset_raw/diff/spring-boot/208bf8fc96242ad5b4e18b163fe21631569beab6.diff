[+++ b/spring-boot-cli/pom.xml, +++ b/spring-boot-cli/pom.xml, +++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +import org.springframework.boot.cli.command.jar.JarCommand;, +import org.springframework.boot.cli.util.JavaExecutable;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.equalTo;, +import static org.junit.Assert.assertThat;, + * Integration test for {@link JarCommand}., + * , +		assertThat(invocation.getStandardOutput(), equalTo(""));, +		assertThat(invocation.getErrorOutput(), containsString("The name of the ", +				+ "resulting jar and at least one source file must be specified"));, +		assertThat(invocation.getStandardOutput(), equalTo(""));, +		assertThat(invocation.getErrorOutput(), containsString("The name of the ", +				+ "resulting jar and at least one source file must be specified"));, +		Process process = new JavaExecutable().processBuilder("-jar",, +				jar.getAbsolutePath()).start();, +		invocation = new Invocation(process);, +		invocation.await();, +		assertThat(invocation.getErrorOutput(), equalTo(""));, +		assertThat(invocation.getStandardOutput(), containsString("Hello World!"));, +		assertThat(invocation.getStandardOutput(), containsString("/static/test.txt"));, +++ b/spring-boot-cli/pom.xml, +++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +import org.springframework.boot.cli.command.jar.JarCommand;, +import org.springframework.boot.cli.util.JavaExecutable;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.equalTo;, +import static org.junit.Assert.assertThat;, + * Integration test for {@link JarCommand}., + * , +		assertThat(invocation.getStandardOutput(), equalTo(""));, +		assertThat(invocation.getErrorOutput(), containsString("The name of the ", +				+ "resulting jar and at least one source file must be specified"));, +		assertThat(invocation.getStandardOutput(), equalTo(""));, +		assertThat(invocation.getErrorOutput(), containsString("The name of the ", +				+ "resulting jar and at least one source file must be specified"));, +		Process process = new JavaExecutable().processBuilder("-jar",, +				jar.getAbsolutePath()).start();, +		invocation = new Invocation(process);, +		invocation.await();, +		assertThat(invocation.getErrorOutput(), equalTo(""));, +		assertThat(invocation.getStandardOutput(), containsString("Hello World!"));, +		assertThat(invocation.getStandardOutput(), containsString("/static/test.txt"));, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/jar/JarCommand.java, +import java.io.InputStream;, +import org.springframework.util.Assert;, + * @author Phillip Webb, +		super("jar", "Create a self-contained ", +				+ "executable jar file from a Spring Groovy script",, +			Assert.isTrue(nonOptionArguments.size() >= 2,, +			deleteIfExists(output);, +, +			GroovyCompiler compiler = createCompiler(options);, +, +			List<URL> classpath = getClassPathUrls(compiler);, +			List<MatchedResource> classpathEntries = findMatchingClasspathEntries(, +					classpath, options);, +, +			String[] sources = new SourceOptions(nonOptionArguments).getSourcesArray();, +			Class<?>[] compiledClasses = compiler.compile(sources);, +, +			List<URL> dependencies = getClassPathUrls(compiler);, +			dependencies.removeAll(classpath);, +, +			writeJar(output, compiledClasses, classpathEntries, dependencies);, +		private void deleteIfExists(File file) {, +			if (file.exists() && !file.delete()) {, +				throw new IllegalStateException("Failed to delete existing file ", +						+ file.getPath());, +			groovyCompiler.getAstTransformations().add(0, new GrabAnnotationTransform());, +			return groovyCompiler;, +		}, +, +		private List<URL> getClassPathUrls(GroovyCompiler compiler) {, +			return new ArrayList<URL>(Arrays.asList(compiler.getLoader().getURLs()));, +		}, +, +		private List<MatchedResource> findMatchingClasspathEntries(List<URL> classpath,, +				OptionSet options) throws IOException {, +			ResourceMatcher matcher = new ResourceMatcher(, +					options.valuesOf(this.includeOption),, +					options.valuesOf(this.excludeOption));, +			List<File> roots = new ArrayList<File>();, +			for (URL classpathEntry : classpath) {, +				roots.add(new File(URI.create(classpathEntry.toString())));, +			}, +			return matcher.find(roots);, +		}, +, +		private void writeJar(File file, Class<?>[] compiledClasses,, +				List<MatchedResource> classpathEntries, List<URL> dependencies), +				throws FileNotFoundException, IOException, URISyntaxException {, +			JarWriter writer = new JarWriter(file);, +			try {, +				addManifest(writer, compiledClasses);, +				addCliClasses(writer);, +				for (Class<?> compiledClass : compiledClasses) {, +					addClass(writer, compiledClass);]