[+++ b/spring-boot/src/main/java/org/springframework/boot/bind/RelaxedDataBinder.java, +				TypeDescriptor valueDescriptor = descriptor.getMapValueTypeDescriptor();, +				if (valueDescriptor != null) {, +					Class<?> valueType = valueDescriptor.getObjectType();, +					if (valueType != null, +							&& CharSequence.class.isAssignableFrom(valueType)) {, +						path.collapseKeys(index);, +					}, +				}, +		public void collapseKeys(int index) {, +			List<PathNode> revised = new ArrayList<PathNode>();, +			for (int i = 0; i < index; i++) {, +				revised.add(this.nodes.get(i));, +			}, +			StringBuilder builder = new StringBuilder();, +			for (int i = index; i < this.nodes.size(); i++) {, +				if (i > index) {, +					builder.append(".");, +				}, +				builder.append(this.nodes.get(i).name);, +			}, +			revised.add(new PropertyNode(builder.toString()));, +			this.nodes = revised;, +		}, +, +++ b/spring-boot/src/main/java/org/springframework/boot/bind/RelaxedDataBinder.java, +				TypeDescriptor valueDescriptor = descriptor.getMapValueTypeDescriptor();, +				if (valueDescriptor != null) {, +					Class<?> valueType = valueDescriptor.getObjectType();, +					if (valueType != null, +							&& CharSequence.class.isAssignableFrom(valueType)) {, +						path.collapseKeys(index);, +					}, +				}, +		public void collapseKeys(int index) {, +			List<PathNode> revised = new ArrayList<PathNode>();, +			for (int i = 0; i < index; i++) {, +				revised.add(this.nodes.get(i));, +			}, +			StringBuilder builder = new StringBuilder();, +			for (int i = index; i < this.nodes.size(); i++) {, +				if (i > index) {, +					builder.append(".");, +				}, +				builder.append(this.nodes.get(i).name);, +			}, +			revised.add(new PropertyNode(builder.toString()));, +			this.nodes = revised;, +		}, +, +++ b/spring-boot/src/test/java/org/springframework/boot/bind/RelaxedDataBinderTests.java, +	public void testBindNestedMapOfString() throws Exception {, +		TargetWithNestedMapOfString target = new TargetWithNestedMapOfString();, +		bind(target, "nested.foo: bar\n" + "nested.value.foo: 123");, +		assertEquals("bar", target.getNested().get("foo"));, +		assertEquals("123", target.getNested().get("value.foo"));, +	}, +, +	@Test, +	public static class TargetWithNestedMapOfString {, +		private Map<String, String> nested;, +, +		public Map<String, String> getNested() {, +			return this.nested;, +		}, +, +		public void setNested(Map<String, String> nested) {, +			this.nested = nested;, +		}, +	}, +, +++ b/spring-boot/src/main/java/org/springframework/boot/bind/RelaxedDataBinder.java, +				TypeDescriptor valueDescriptor = descriptor.getMapValueTypeDescriptor();, +				if (valueDescriptor != null) {, +					Class<?> valueType = valueDescriptor.getObjectType();, +					if (valueType != null, +							&& CharSequence.class.isAssignableFrom(valueType)) {, +						path.collapseKeys(index);, +					}, +				}, +		public void collapseKeys(int index) {, +			List<PathNode> revised = new ArrayList<PathNode>();, +			for (int i = 0; i < index; i++) {, +				revised.add(this.nodes.get(i));, +			}, +			StringBuilder builder = new StringBuilder();, +			for (int i = index; i < this.nodes.size(); i++) {, +				if (i > index) {, +					builder.append(".");, +				}, +				builder.append(this.nodes.get(i).name);, +			}, +			revised.add(new PropertyNode(builder.toString()));, +			this.nodes = revised;, +		}, +, +++ b/spring-boot/src/test/java/org/springframework/boot/bind/RelaxedDataBinderTests.java, +	public void testBindNestedMapOfString() throws Exception {, +		TargetWithNestedMapOfString target = new TargetWithNestedMapOfString();, +		bind(target, "nested.foo: bar\n" + "nested.value.foo: 123");]