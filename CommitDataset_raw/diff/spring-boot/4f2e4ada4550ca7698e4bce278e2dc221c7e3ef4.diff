[+++ b/spring-boot/src/main/java/org/springframework/boot/endpoint/AnnotationEndpointDiscoverer.java, +/*, + * Copyright 2012-2017 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.boot.endpoint;, +, +import java.lang.annotation.Annotation;, +import java.lang.reflect.Method;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.function.Consumer;, +import java.util.function.Function;, +, +import org.springframework.context.ApplicationContext;, +import org.springframework.core.MethodIntrospector;, +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.core.annotation.AnnotationAttributes;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.ObjectUtils;, +, +/**, + * A base {@link EndpointDiscoverer} implementation that discovers {@link Endpoint} beans, + * in an application context., + *, + * @param <T> the type of the operation, + * @param <K> the type of the operation key, + * @author Andy Wilkinson, + * @author Stephane Nicoll, + * @since 2.0.0, + */, +public abstract class AnnotationEndpointDiscoverer<T extends EndpointOperation, K>, +		implements EndpointDiscoverer<T> {, +, +	private final ApplicationContext applicationContext;, +, +	private final EndpointOperationFactory<T> operationFactory;, +, +	private final Function<T, K> operationKeyFactory;, +, +	private final Function<String, CachingConfiguration> cachingConfigurationFactory;, +, +	protected AnnotationEndpointDiscoverer(ApplicationContext applicationContext,, +			EndpointOperationFactory<T> operationFactory,, +			Function<T, K> operationKeyFactory,, +			Function<String, CachingConfiguration> cachingConfigurationFactory) {, +		this.applicationContext = applicationContext;, +		this.operationFactory = operationFactory;, +		this.operationKeyFactory = operationKeyFactory;, +		this.cachingConfigurationFactory = cachingConfigurationFactory;, +	}, +, +	/**, +	 * Perform endpoint discovery, including discovery and merging of extensions., +	 * @param extensionType the annotation type of the extension, +	 * @param endpointType the {@link EndpointType} that should be considered, +	 * @return the list of {@link EndpointInfo EndpointInfos} that describes the, +	 * discovered endpoints matching the specified {@link EndpointType}, +	 */, +	protected Collection<EndpointInfoDescriptor<T, K>> discoverEndpointsWithExtension(, +			Class<? extends Annotation> extensionType, EndpointType endpointType) {, +		Map<Class<?>, EndpointInfo<T>> endpoints = discoverGenericEndpoints(endpointType);, +		Map<Class<?>, EndpointExtensionInfo<T>> extensions = discoverExtensions(endpoints,, +				extensionType, endpointType);, +		Collection<EndpointInfoDescriptor<T, K>> result = new ArrayList<>();, +		endpoints.forEach((endpointClass, endpointInfo) -> {, +			EndpointExtensionInfo<T> extension = extensions.remove(endpointClass);, +			result.add(createDescriptor(endpointClass, endpointInfo, extension));, +		});, +		return result;, +	}, +, +	private EndpointInfoDescriptor<T, K> createDescriptor(Class<?> endpointType,, +			EndpointInfo<T> endpoint, EndpointExtensionInfo<T> extension) {, +		Map<OperationKey<K>, List<T>> endpointOperations = indexOperations(, +				endpoint.getId(), endpointType, endpoint.getOperations());, +		if (extension != null) {, +			endpointOperations.putAll(indexOperations(endpoint.getId(),, +					extension.getEndpointExtensionType(), extension.getOperations()));, +			return new EndpointInfoDescriptor<>(mergeEndpoint(endpoint, extension),, +					endpointOperations);, +		}, +		else {]