[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricsDropwizardAutoConfiguration.java, +import org.springframework.beans.factory.ObjectProvider;, +	private final ReservoirFactory reservoirFactory;, +, +	public MetricsDropwizardAutoConfiguration(, +			ObjectProvider<ReservoirFactory> reservoirFactory) {, +		this.reservoirFactory = reservoirFactory.getIfAvailable();, +	}, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricsDropwizardAutoConfiguration.java, +import org.springframework.beans.factory.ObjectProvider;, +	private final ReservoirFactory reservoirFactory;, +, +	public MetricsDropwizardAutoConfiguration(, +			ObjectProvider<ReservoirFactory> reservoirFactory) {, +		this.reservoirFactory = reservoirFactory.getIfAvailable();, +	}, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/dropwizard/DropwizardMetricServices.java, +import org.springframework.core.ResolvableType;, +import org.springframework.util.Assert;, +	private final ReservoirFactory reservoirFactory;, +		this(registry, null);, +		this.reservoirFactory = (reservoirFactory == null ? ReservoirFactory.NONE, +				: reservoirFactory);, +			submitHistogram(name, value);, +			submitTimer(name, value);, +	private void submitTimer(String name, double value) {, +		long longValue = (long) value;, +		Timer metric = register(name, new TimerMetricRegistrar());, +		metric.update(longValue, TimeUnit.MILLISECONDS);, +	private void submitHistogram(String name, double value) {, +		long longValue = (long) value;, +		Histogram metric = register(name, new HistogramMetricRegistrar());, +		metric.update(longValue);, +	private <T extends Metric> T register(String name, MetricRegistrar<T> registrar) {, +		Reservoir reservoir = this.reservoirFactory.getReservoir(name);, +		if (reservoir == null) {, +			return registrar.register(this.registry, name);, +		Metric metric = this.registry.getMetrics().get(name);, +		if (metric != null) {, +			registrar.checkExisting(metric);, +		try {, +			return this.registry.register(name, registrar.createForReservoir(reservoir));, +		catch (IllegalArgumentException ex) {, +			Metric added = this.registry.getMetrics().get(name);, +			registrar.checkExisting(metric);, +			return (T) added;, +	/**, +	 * Strategy used to register metrics., +	 */, +	private static abstract class MetricRegistrar<T extends Metric> {, +, +		private final Class<T> type;, +, +		@SuppressWarnings("unchecked"), +		MetricRegistrar() {, +			this.type = (Class<T>) ResolvableType, +					.forClass(MetricRegistrar.class, getClass()).resolveGeneric();, +		}, +, +		public void checkExisting(Metric metric) {, +			Assert.isInstanceOf(this.type, metric,, +					"Different metric type already registered");, +		}, +, +		protected abstract T register(MetricRegistry registry, String name);, +, +		protected abstract T createForReservoir(Reservoir reservoir);, +, +	}, +, +	/**, +	 * {@link MetricRegistrar} for {@link Timer} metrics., +	 */, +	private static class TimerMetricRegistrar extends MetricRegistrar<Timer> {, +, +		@Override, +		protected Timer register(MetricRegistry registry, String name) {, +			return registry.timer(name);, +		}, +, +		@Override, +		protected Timer createForReservoir(Reservoir reservoir) {, +			return new Timer(reservoir);, +		}, +, +	}, +, +	/**, +	 * {@link MetricRegistrar} for {@link Histogram} metrics., +	 */, +	private static class HistogramMetricRegistrar extends MetricRegistrar<Histogram> {, +, +		@Override, +		protected Histogram register(MetricRegistry registry, String name) {, +			return registry.histogram(name);, +		}, +, +		@Override, +		protected Histogram createForReservoir(Reservoir reservoir) {, +			return new Histogram(reservoir);]