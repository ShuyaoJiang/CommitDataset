[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnSingleCandidate.java, + * The condition will also match if multiple matching bean instances are already contained, + * in the {@link BeanFactory} but a primary candidate has been defined; essentially, the, + * condition match if auto-wiring a bean with the defined type will succeed., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with {@link #type()}, +	 * , but it may be used instead of {@link #type()}., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnSingleCandidate.java, + * The condition will also match if multiple matching bean instances are already contained, + * in the {@link BeanFactory} but a primary candidate has been defined; essentially, the, + * condition match if auto-wiring a bean with the defined type will succeed., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with {@link #type()}, +	 * , but it may be used instead of {@link #type()}., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnBeanCondition.java, +			else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matching)) {, +						+ " found no primary candidate amongst the" + " following ", +						+ matching);, +			matchMessage.append("@ConditionalOnSingleCandidate " + spec + " found ", +					+ "a primary candidate amongst the following " + matching);, +	private boolean hasSingleAutowireCandidate(, +			ConfigurableListableBeanFactory beanFactory, List<String> beanNames) {, +		return (beanNames.size() == 1 || getPrimaryBeans(beanFactory, beanNames).size() == 1);, +	}, +	private List<String> getPrimaryBeans(ConfigurableListableBeanFactory beanFactory,, +			List<String> beanNames) {, +		List<String> primaryBeans = new ArrayList<String>();, +		for (String beanName : beanNames) {, +			BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);, +				primaryBeans.add(beanName);, +		return primaryBeans;, +		protected void collect(MultiValueMap<String, Object> attributes, String key,, +		protected void collect(MultiValueMap<String, Object> attributes, String key,, +				List<String> destination) {, +			super.collect(attributes, key, destination);, +			destination.removeAll(Arrays.asList("", Object.class.getName()));, +		}, +, +		@Override, +			Assert.isTrue(getTypes().size() == 1, annotationName() + " annotations must ", +					+ "specify only one type (got " + getTypes() + ")");, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnSingleCandidate.java, + * The condition will also match if multiple matching bean instances are already contained, + * in the {@link BeanFactory} but a primary candidate has been defined; essentially, the, + * condition match if auto-wiring a bean with the defined type will succeed., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with {@link #type()}, +	 * , but it may be used instead of {@link #type()}., +	 * <p>, +	 * This attribute may <strong>not</strong> be used in conjunction with, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnBeanCondition.java, +			else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matching)) {, +						+ " found no primary candidate amongst the" + " following ", +						+ matching);, +			matchMessage.append("@ConditionalOnSingleCandidate " + spec + " found ", +					+ "a primary candidate amongst the following " + matching);, +	private boolean hasSingleAutowireCandidate(, +			ConfigurableListableBeanFactory beanFactory, List<String> beanNames) {, +		return (beanNames.size() == 1 || getPrimaryBeans(beanFactory, beanNames).size() == 1);, +	}, +	private List<String> getPrimaryBeans(ConfigurableListableBeanFactory beanFactory,, +			List<String> beanNames) {, +		List<String> primaryBeans = new ArrayList<String>();, +		for (String beanName : beanNames) {, +			BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);, +				primaryBeans.add(beanName);, +		return primaryBeans;, +		protected void collect(MultiValueMap<String, Object> attributes, String key,, +		protected void collect(MultiValueMap<String, Object> attributes, String key,, +				List<String> destination) {, +			super.collect(attributes, key, destination);, +			destination.removeAll(Arrays.asList("", Object.class.getName()));, +		}, +, +		@Override, +			Assert.isTrue(getTypes().size() == 1, annotationName() + " annotations must ", +					+ "specify only one type (got " + getTypes() + ")");, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/condition/ConditionalOnSingleCandidateTests.java, +		load(FooConfiguration.class, OnBeanSingleCandidateConfiguration.class);, +		this.thrown.expect(IllegalStateException.class);, +		this.thrown.expectCause(isA(IllegalArgumentException.class));, +		this.thrown.expectMessage(OnBeanSingleCandidateTwoTypesConfiguration.class, +				.getName());, +		this.thrown.expect(IllegalStateException.class);, +		this.thrown.expectCause(isA(IllegalArgumentException.class));, +		this.thrown.expectMessage(OnBeanSingleCandidateNoTypeConfiguration.class, +				.getName());, +, +, +, +, +, +, +, +, +]