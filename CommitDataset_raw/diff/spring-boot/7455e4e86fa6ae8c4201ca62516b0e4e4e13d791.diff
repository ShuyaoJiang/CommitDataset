[+++ b/spring-boot-integration-tests/src/test/java/org/springframework/boot/gradle/RepackagingTests.java, +import java.util.jar.JarFile;, +import org.springframework.util.FileCopyUtils;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.junit.Assert.assertThat;, +, +	@Test, +	public void repackageWithFileDependency() throws Exception {, +		FileCopyUtils.copy(new File("src/test/resources/foo.jar"), new File(, +				"target/repackage/foo.jar"));, +		project.newBuild().forTasks("clean", "build"), +				.withArguments("-PbootVersion=" + BOOT_VERSION, "-Prepackage=true").run();, +		File buildLibs = new File("target/repackage/build/libs");, +		JarFile jarFile = new JarFile(new File(buildLibs, "repackage.jar"));, +		assertThat(jarFile.getEntry("lib/foo.jar"), notNullValue());, +		jarFile.close();, +	}, +, +++ b/spring-boot-integration-tests/src/test/java/org/springframework/boot/gradle/RepackagingTests.java, +import java.util.jar.JarFile;, +import org.springframework.util.FileCopyUtils;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.junit.Assert.assertThat;, +, +	@Test, +	public void repackageWithFileDependency() throws Exception {, +		FileCopyUtils.copy(new File("src/test/resources/foo.jar"), new File(, +				"target/repackage/foo.jar"));, +		project.newBuild().forTasks("clean", "build"), +				.withArguments("-PbootVersion=" + BOOT_VERSION, "-Prepackage=true").run();, +		File buildLibs = new File("target/repackage/build/libs");, +		JarFile jarFile = new JarFile(new File(buildLibs, "repackage.jar"));, +		assertThat(jarFile.getEntry("lib/foo.jar"), notNullValue());, +		jarFile.close();, +	}, +, +++ b/spring-boot-integration-tests/src/test/resources/repackage.gradle, +	compile 'org.springframework.boot:spring-boot-starter-web', +	compile files("foo.jar"), +++ b/spring-boot-integration-tests/src/test/java/org/springframework/boot/gradle/RepackagingTests.java, +import java.util.jar.JarFile;, +import org.springframework.util.FileCopyUtils;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.junit.Assert.assertThat;, +, +	@Test, +	public void repackageWithFileDependency() throws Exception {, +		FileCopyUtils.copy(new File("src/test/resources/foo.jar"), new File(, +				"target/repackage/foo.jar"));, +		project.newBuild().forTasks("clean", "build"), +				.withArguments("-PbootVersion=" + BOOT_VERSION, "-Prepackage=true").run();, +		File buildLibs = new File("target/repackage/build/libs");, +		JarFile jarFile = new JarFile(new File(buildLibs, "repackage.jar"));, +		assertThat(jarFile.getEntry("lib/foo.jar"), notNullValue());, +		jarFile.close();, +	}, +, +++ b/spring-boot-integration-tests/src/test/resources/repackage.gradle, +	compile 'org.springframework.boot:spring-boot-starter-web', +	compile files("foo.jar"), +++ b/spring-boot-tools/spring-boot-gradle-plugin/src/main/groovy/org/springframework/boot/gradle/repackage/ProjectLibraries.java, +import org.gradle.api.artifacts.Dependency;, +import org.gradle.api.artifacts.FileCollectionDependency;, +		Set<Library> custom = getLibraries(this.customConfigurationName,, +				LibraryScope.CUSTOM);, +			libraries(custom, callback);, +			Set<Library> compile = getLibraries("compile", LibraryScope.COMPILE);, +			Set<Library> runtime = getLibraries("runtime", LibraryScope.RUNTIME);, +			Set<Library> provided = getLibraries(this.providedConfigurationName,, +					LibraryScope.PROVIDED);, +			libraries(compile, callback);, +			libraries(runtime, callback);, +			libraries(provided, callback);, +	private Set<Library> getLibraries(String configurationName, LibraryScope scope) {, +		if (configuration == null) {, +			return null;, +		}, +		Set<Library> libraries = new LinkedHashSet<Library>();, +		for (ResolvedArtifact artifact : configuration.getResolvedConfiguration(), +				.getResolvedArtifacts()) {, +			libraries.add(new ResolvedArtifactLibrary(artifact, scope));, +		}, +		for (Dependency dependency : configuration.getIncoming().getDependencies()) {, +			if (dependency instanceof FileCollectionDependency) {, +				FileCollectionDependency fileDependency = (FileCollectionDependency) dependency;, +				for (File file : fileDependency.resolve()) {, +					libraries.add(new Library(file, scope));, +				}, +			}, +		}, +		return libraries;, +	private Set<Library> minus(Set<Library> source, Set<Library> toRemove) {, +		for (Library library : toRemove) {, +			filesToRemove.add(library.getFile());, +		Set<Library> result = new LinkedHashSet<Library>();, +		for (Library library : source) {, +			if (!filesToRemove.contains(library.getFile())) {, +				result.add(library);, +	private void libraries(Set<Library> libraries, LibraryCallback callback), +			throws IOException {]