[+++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/InitCommand.java, +						Commands instance = (Commands) type.newInstance();, +						Map<String, Closure<?>> commands = instance.getCommands();, +						Map<String, OptionHandler> handlers = instance.getOptions();, +							if (handlers.containsKey(command)) {, +								// An OptionHandler is available, +								OptionHandler handler = handlers.get(command);, +								handler.setClosure(commands.get(command));, +								this.cli.register(new ScriptCommand(command, handler));, +							}, +							else {, +								// Otherwise just a plain Closure, +, +							}, +, +		Map<String, OptionHandler> getOptions();, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/InitCommand.java, +						Commands instance = (Commands) type.newInstance();, +						Map<String, Closure<?>> commands = instance.getCommands();, +						Map<String, OptionHandler> handlers = instance.getOptions();, +							if (handlers.containsKey(command)) {, +								// An OptionHandler is available, +								OptionHandler handler = handlers.get(command);, +								handler.setClosure(commands.get(command));, +								this.cli.register(new ScriptCommand(command, handler));, +							}, +							else {, +								// Otherwise just a plain Closure, +, +							}, +, +		Map<String, OptionHandler> getOptions();, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/OptionHandler.java, +	private Closure<?> closure;, +	public void setClosure(Closure<?> closure) {, +		if (this.closure != null) {, +			this.closure.call(options);, +		}, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/InitCommand.java, +						Commands instance = (Commands) type.newInstance();, +						Map<String, Closure<?>> commands = instance.getCommands();, +						Map<String, OptionHandler> handlers = instance.getOptions();, +							if (handlers.containsKey(command)) {, +								// An OptionHandler is available, +								OptionHandler handler = handlers.get(command);, +								handler.setClosure(commands.get(command));, +								this.cli.register(new ScriptCommand(command, handler));, +							}, +							else {, +								// Otherwise just a plain Closure, +, +							}, +, +		Map<String, OptionHandler> getOptions();, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/OptionHandler.java, +	private Closure<?> closure;, +	public void setClosure(Closure<?> closure) {, +		if (this.closure != null) {, +			this.closure.call(options);, +		}, +++ b/spring-boot-cli/src/main/java/org/springframework/boot/cli/command/ScriptCompilationCustomizer.java, +import org.codehaus.groovy.ast.InnerClassNode;, +import org.codehaus.groovy.ast.expr.ConstructorCallExpression;, +import org.codehaus.groovy.ast.stmt.EmptyStatement;, + * Customizer for the compilation of CLI script commands., +	/**, +	 * If the script defines a block in this form:, +	 * , +	 * <pre>, +	 * command("foo") { args ->, +	 *     println "Command foo called with args: ${args}", +	 * }, +	 * </pre>, +	 * , +	 * Then the block is taken and used to create a Command named "foo" that runs the, +	 * closure when it is executed., +	 * , +	 * If you want to declare options (and provide help text), use this form:, +	 * , +	 * <pre>, +	 * command("foo") {, +	 * , +	 *   options {, +	 *     option "foo", "My Foo option", +	 *     option "bar", "Bar has a value" withOptionalArg() ofType Integer, +	 *   }, +	 *   , +	 *   run { options ->, +	 *   	println "Command foo called with bar=${options.valueOf('bar')}", +	 *   }, +	 * , +	 * }, +	 * </pre>, +	 * , +	 * In this case the "options" block is taken and used to override the, +	 * {@link OptionHandler#options()} method. Each "option" is a call to, +	 * {@link OptionHandler#option(String, String)}, and hence returns an, +	 * {@link OptionSpecBuilder}. Makes a nice readable DSL for adding options., +	 * , +	 * @param source the source node]