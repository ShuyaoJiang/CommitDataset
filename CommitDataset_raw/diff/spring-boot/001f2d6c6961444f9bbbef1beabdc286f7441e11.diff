[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/MessageSourceAutoConfiguration.java, +import java.util.Iterator;, +import java.util.Set;, +import org.springframework.util.ConcurrentReferenceHashMap;, + * @author Phillip Webb, +		private static ConcurrentReferenceHashMap<String, ConditionOutcome> cache = new ConcurrentReferenceHashMap<String, ConditionOutcome>();, +, +			ConditionOutcome outcome = cache.get(basename);, +			if (outcome == null) {, +				outcome = getMatchOutcomeForBasename(context, basename);, +				cache.put(basename, outcome);, +			}, +			return outcome;, +		}, +, +		private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context,, +				String basename) {, +				return new SkipPatternPathMatchingResourcePatternResolver(classLoader), +	/**, +	 * {@link PathMatchingResourcePatternResolver} that skips well known JARs that don't, +	 * contain messages.properties., +	 */, +	private static class SkipPatternPathMatchingResourcePatternResolver extends, +			PathMatchingResourcePatternResolver {, +, +		private static final ClassLoader ROOT_CLASSLOADER;, +		static {, +			ClassLoader classLoader = ClassLoader.getSystemClassLoader();, +			while (classLoader.getParent() != null) {, +				classLoader = classLoader.getParent();, +			}, +			ROOT_CLASSLOADER = classLoader;, +		}, +, +		private static final String[] SKIPPED = { "aspectjweaver-", "hibernate-core-",, +				"hsqldb-", "jackson-annotations-", "jackson-core-", "jackson-databind-",, +				"javassist-", "snakeyaml-", "spring-aop-", "spring-beans-",, +				"spring-boot-", "spring-boot-actuator-", "spring-boot-autoconfigure-",, +				"spring-core-", "spring-context-", "spring-data-commons-",, +				"spring-expression-", "spring-jdbc-", "spring-orm-", "spring-tx-",, +				"spring-web-", "spring-webmvc-", "tomcat-embed-", "joda-time-",, +				"hibernate-entitymanager-", "hibernate-validator-", "logback-classic-",, +				"logback-core-", "thymeleaf-" };, +, +		public SkipPatternPathMatchingResourcePatternResolver(ClassLoader classLoader) {, +			super(classLoader);, +		}, +, +		@Override, +		protected void addAllClassLoaderJarRoots(ClassLoader classLoader,, +				Set<Resource> result) {, +			if (classLoader != ROOT_CLASSLOADER) {, +				super.addAllClassLoaderJarRoots(classLoader, result);, +			}, +		};, +, +		@Override, +		protected Set<Resource> doFindAllClassPathResources(String path), +				throws IOException {, +			Set<Resource> resources = super.doFindAllClassPathResources(path);, +			for (Iterator<Resource> iterator = resources.iterator(); iterator.hasNext();) {, +				Resource resource = iterator.next();, +				for (String skipped : SKIPPED) {, +					if (resource.getFilename().startsWith(skipped)) {, +						iterator.remove();, +						break;, +					}, +				}, +			}, +			return resources;, +		}, +, +	}, +]