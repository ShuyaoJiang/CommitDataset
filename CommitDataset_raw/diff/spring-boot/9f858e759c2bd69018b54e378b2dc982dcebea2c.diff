[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/BeanTypeRegistry.java, +	private final Map<String, ResolvableType> beanTypes = new HashMap<>();, +	 * @param typeExtractor function used to extract the actual type, +	public Set<String> getNamesForType(Class<?> type, TypeExtractor typeExtractor) {, +		return this.beanTypes.entrySet().stream().filter((entry) -> {, +			Class<?> beanType = extractType(entry.getValue(), typeExtractor);, +			return beanType != null && type.isAssignableFrom(beanType);, +		}).map(Map.Entry::getKey).collect(Collectors.toCollection(LinkedHashSet::new));, +	}, +, +	private Class<?> extractType(ResolvableType type, TypeExtractor extractor) {, +		return (type != null) ? extractor.getBeanType(type) : null;, +						.findAnnotation(entry.getValue().resolve(), annotation) != null), +		this.beanFactory.getBeanNamesIterator(), +				.forEachRemaining(this::updateTypesIfNecessary);, +	}, +, +	private void updateTypesIfNecessary(String name) {, +			this.beanTypes.put(name, getType(name, null));, +		RootBeanDefinition definition = getBeanDefinition(name);, +		if (definition != null) {, +			addBeanTypeForNonAliasDefinition(name, definition);, +		RootBeanDefinition definition = getBeanDefinition(name);, +		if (definition == null) {, +		RootBeanDefinition previous = this.beanDefinitions.put(name, definition);, +		if (previous != null && !definition.equals(previous)) {, +			addBeanTypeForNonAliasDefinition(name, definition);, +	private void addBeanTypeForNonAliasDefinition(String name,, +			RootBeanDefinition definition) {, +		try {, +			if (!definition.isAbstract(), +					&& !requiresEagerInit(definition.getFactoryBeanName())) {, +				ResolvableType factoryMethodReturnType = getFactoryMethodReturnType(, +						definition);, +				String factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + name;, +				if (this.beanFactory.isFactoryBean(factoryBeanName)) {, +					ResolvableType factoryBeanGeneric = getFactoryBeanGeneric(, +							this.beanFactory, definition, factoryMethodReturnType);, +					this.beanTypes.put(name, factoryBeanGeneric);, +					this.beanTypes.put(factoryBeanName,, +							getType(factoryBeanName, factoryMethodReturnType));, +				}, +				else {, +					this.beanTypes.put(name, getType(name, factoryMethodReturnType));, +				}, +			}, +			this.beanDefinitions.put(name, definition);, +		}, +		catch (CannotLoadBeanClassException ex) {, +			// Probably contains a placeholder, +			logIgnoredError("bean class loading failure for bean", name, ex);, +	private ResolvableType getFactoryMethodReturnType(BeanDefinition definition) {, +				Method method = getFactoryMethod(this.beanFactory, definition);, +				ResolvableType type = (method != null), +						? ResolvableType.forMethodReturnType(method) : null;, +				return type;, +		}, +		catch (Exception ex) {, +	private void logIgnoredError(String message, String name, Exception ex) {, +		if (logger.isDebugEnabled()) {, +			logger.debug("Ignoring " + message + " '" + name + "'", ex);, +		}, +	}, +, +	/**, +	 * Attempt to guess the type that a {@link FactoryBean} will return based on the, +	 * generics in its method signature., +	 * @param beanFactory the source bean factory, +	 * @param definition the bean definition, +	 * @param factoryMethodReturnType the factory method return type, +	 * @return the generic type of the {@link FactoryBean} or {@code null}, +	 */, +	private ResolvableType getFactoryBeanGeneric(, +			ConfigurableListableBeanFactory beanFactory, BeanDefinition definition,, +			ResolvableType factoryMethodReturnType) {, +		try {, +			if (factoryMethodReturnType != null) {, +				return getFactoryBeanType(definition, factoryMethodReturnType);, +			}, +			if (StringUtils.hasLength(definition.getBeanClassName())) {, +				return getDirectFactoryBeanGeneric(beanFactory, definition);, +			}, +		}, +		catch (Exception ex) {, +		}, +		return null;, +	}, +, +	private ResolvableType getDirectFactoryBeanGeneric(, +		return getFactoryBeanType(definition, ResolvableType.forClass(factoryBeanClass));, +	}, +, +	private ResolvableType getFactoryBeanType(BeanDefinition definition,, +			ResolvableType type) throws ClassNotFoundException, LinkageError {, +		ResolvableType generic = type.as(FactoryBean.class).getGeneric();, +		if ((generic == null || generic.resolve().equals(Object.class)), +	private ResolvableType getTypeFromAttribute(Object attribute), +			return ResolvableType.forClass((Class<?>) attribute);, +			return ResolvableType.forClass(ClassUtils.forName((String) attribute, null));, +	private ResolvableType getType(String name, ResolvableType factoryMethodReturnType) {]