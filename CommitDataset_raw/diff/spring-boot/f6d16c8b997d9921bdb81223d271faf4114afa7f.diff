[+++ b/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/web/reactive/server/WebFluxTags.java, +	private static final Tag URI_NOT_FOUND = Tag.of("uri", "NOT_FOUND");, +, +	private static final Tag URI_REDIRECTION = Tag.of("uri", "REDIRECTION");, +, +		if (exchange != null) {, +			PathPattern pathPattern = exchange.getAttribute(, +					HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);, +			if (pathPattern != null) {, +				return Tag.of("uri", pathPattern.getPatternString());, +			else {, +				HttpStatus status = exchange.getResponse().getStatusCode();, +				if (status != null && status.is3xxRedirection()) {, +					return URI_REDIRECTION;, +				}, +				if (status != null && status.equals(HttpStatus.NOT_FOUND)) {, +					return URI_NOT_FOUND;, +				}, +			}, +			String path = exchange.getRequest().getPath().value();, +			return Tag.of("uri", path.isEmpty() ? "root" : path);, +		}, +		return Tag.of("uri", "UNKNOWN");, +++ b/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/web/reactive/server/WebFluxTags.java, +	private static final Tag URI_NOT_FOUND = Tag.of("uri", "NOT_FOUND");, +, +	private static final Tag URI_REDIRECTION = Tag.of("uri", "REDIRECTION");, +, +		if (exchange != null) {, +			PathPattern pathPattern = exchange.getAttribute(, +					HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);, +			if (pathPattern != null) {, +				return Tag.of("uri", pathPattern.getPatternString());, +			else {, +				HttpStatus status = exchange.getResponse().getStatusCode();, +				if (status != null && status.is3xxRedirection()) {, +					return URI_REDIRECTION;, +				}, +				if (status != null && status.equals(HttpStatus.NOT_FOUND)) {, +					return URI_NOT_FOUND;, +				}, +			}, +			String path = exchange.getRequest().getPath().value();, +			return Tag.of("uri", path.isEmpty() ? "root" : path);, +		}, +		return Tag.of("uri", "UNKNOWN");, +++ b/spring-boot-project/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/metrics/web/reactive/server/WebFluxTagsTests.java, +/*, + * Copyright 2012-2018 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.boot.actuate.metrics.web.reactive.server;, +, +import io.micrometer.core.instrument.Tag;, +import org.junit.Before;, +import org.junit.Test;, +, +import org.springframework.http.HttpStatus;, +import org.springframework.mock.http.server.reactive.MockServerHttpRequest;, +import org.springframework.mock.web.server.MockServerWebExchange;, +import org.springframework.web.reactive.HandlerMapping;, +import org.springframework.web.util.pattern.PathPatternParser;, +, +import static org.assertj.core.api.Assertions.assertThat;, +, +/**, + * Tests for {@link WebFluxTags}., + * @author Brian Clozel, + */, +public class WebFluxTagsTests {, +, +	private MockServerWebExchange exchange;, +, +	private PathPatternParser parser = new PathPatternParser();, +, +	@Before, +	public void setup() {, +		this.exchange = MockServerWebExchange, +				.from(MockServerHttpRequest.get(""));, +	}, +, +	@Test, +	public void uriTagValueIsBestMatchingPatternWhenAvailable() {, +		this.exchange.getAttributes().put(, +				HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE, this.parser.parse("/spring"));, +		this.exchange.getResponse().setStatusCode(HttpStatus.MOVED_PERMANENTLY);, +		Tag tag = WebFluxTags.uri(this.exchange);, +		assertThat(tag.getValue()).isEqualTo("/spring");]