[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceInitializer.java, +import java.util.Arrays;, +import org.springframework.jdbc.config.SortedResourcesFactoryBean;, +		return getResources(, +				Arrays.asList(StringUtils.commaDelimitedListToStringArray(locations)));, +	}, +, +	private List<Resource> getResources(List<String> locations) {, +		SortedResourcesFactoryBean factory = new SortedResourcesFactoryBean(, +				this.applicationContext, locations);, +			factory.afterPropertiesSet();, +			List<Resource> resources = new ArrayList<Resource>();, +			for (Resource resource : factory.getObject()) {, +		catch (Exception ex) {, +			throw new IllegalStateException("Unable to load resources from " + locations,, +					ex);, +		}, +	}, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceInitializer.java, +import java.util.Arrays;, +import org.springframework.jdbc.config.SortedResourcesFactoryBean;, +		return getResources(, +				Arrays.asList(StringUtils.commaDelimitedListToStringArray(locations)));, +	}, +, +	private List<Resource> getResources(List<String> locations) {, +		SortedResourcesFactoryBean factory = new SortedResourcesFactoryBean(, +				this.applicationContext, locations);, +			factory.afterPropertiesSet();, +			List<Resource> resources = new ArrayList<Resource>();, +			for (Resource resource : factory.getObject()) {, +		catch (Exception ex) {, +			throw new IllegalStateException("Unable to load resources from " + locations,, +					ex);, +		}, +	}, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/jdbc/DataSourceInitializerTests.java, +import java.io.IOException;, +import java.util.Arrays;, +import java.util.Comparator;, +import org.springframework.core.io.DefaultResourceLoader;, +import org.springframework.core.io.Resource;, +import org.springframework.core.io.ResourceLoader;, +import org.springframework.core.io.support.ResourcePatternResolver;, +import org.springframework.core.io.support.ResourcePatternUtils;, +	@Test, +	public void multipleScriptsAppliedInLexicalOrder() throws Exception {, +		EnvironmentTestUtils.addEnvironment(this.context,, +				"spring.datasource.initialize:true",, +				"spring.datasource.schema:" + ClassUtils, +						.addResourcePathToPackagePath(getClass(), "lexical-schema-*.sql"),, +				"spring.datasource.data:" + ClassUtils, +						.addResourcePathToPackagePath(getClass(), "data.sql"));, +		this.context.register(DataSourceAutoConfiguration.class,, +				PropertyPlaceholderAutoConfiguration.class);, +		ReverseOrderResourceLoader resourceLoader = new ReverseOrderResourceLoader(, +				new DefaultResourceLoader());, +		this.context.setResourceLoader(resourceLoader);, +		this.context.refresh();, +		DataSource dataSource = this.context.getBean(DataSource.class);, +		assertThat(dataSource instanceof org.apache.tomcat.jdbc.pool.DataSource).isTrue();, +		assertThat(dataSource).isNotNull();, +		JdbcOperations template = new JdbcTemplate(dataSource);, +		assertThat(template.queryForObject("SELECT COUNT(*) from FOO", Integer.class)), +				.isEqualTo(1);, +	}, +, +	/**, +	 * {@link ResourcePatternResolver} used to ensure consistently wrong resource, +	 * ordering., +	 */, +	private static class ReverseOrderResourceLoader implements ResourcePatternResolver {, +, +		private final ResourcePatternResolver resolver;, +, +		ReverseOrderResourceLoader(ResourceLoader loader) {, +			this.resolver = ResourcePatternUtils.getResourcePatternResolver(loader);, +		}, +, +		@Override, +		public Resource getResource(String location) {, +			return this.resolver.getResource(location);, +		}, +, +		@Override, +		public ClassLoader getClassLoader() {, +			return this.resolver.getClassLoader();, +		}, +, +		@Override, +		public Resource[] getResources(String locationPattern) throws IOException {, +			Resource[] resources = this.resolver.getResources(locationPattern);, +			Arrays.sort(resources, new Comparator<Resource>() {, +, +				@Override, +				public int compare(Resource r1, Resource r2) {, +					return r2.getFilename().compareTo(r1.getFilename());, +				}, +, +			});]