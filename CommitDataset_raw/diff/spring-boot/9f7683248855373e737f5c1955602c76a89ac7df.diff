[+++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +	private Map<String, String> cachedTokenKeys = new ConcurrentHashMap<>();, +, +		return Mono.just(this.cachedTokenKeys), +				.switchIfEmpty(this.securityService.fetchTokenKeys(), +						.doOnSuccess(fetchedTokenKeys -> {, +							this.cachedTokenKeys.clear();, +							this.cachedTokenKeys.putAll(fetchedTokenKeys);, +						}), +						.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +						.switchIfEmpty((Mono.error(, +										"Key Id present in token header does not match"))))), +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +	private Map<String, String> cachedTokenKeys = new ConcurrentHashMap<>();, +, +		return Mono.just(this.cachedTokenKeys), +				.switchIfEmpty(this.securityService.fetchTokenKeys(), +						.doOnSuccess(fetchedTokenKeys -> {, +							this.cachedTokenKeys.clear();, +							this.cachedTokenKeys.putAll(fetchedTokenKeys);, +						}), +						.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +						.switchIfEmpty((Mono.error(, +										"Key Id present in token header does not match"))))), +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidatorTests.java, +import java.util.LinkedHashMap;, +import reactor.test.publisher.PublisherProbe;, +import org.springframework.test.util.ReflectionTestUtils;, +	private static final Map<String, String> INVALID_KEYS = new LinkedHashMap<>();, +	private static final Map<String, String> VALID_KEYS = new LinkedHashMap<>();, +		VALID_KEYS.put("valid-key", VALID_KEY);, +		INVALID_KEYS.put("invalid-key", INVALID_KEY);, +	public void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception {, +		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));, +		ReflectionTestUtils.setField(this.tokenValidator, "cachedTokenKeys", VALID_KEYS);, +		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());, +		String header = "{\"alg\": \"RS256\",  \"kid\": \"invalid-key\",\"typ\": \"JWT\"}";, +		Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, "cachedTokenKeys");, +		assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS);, +		fetchTokenKeys.assertWasSubscribed();, +	public void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception {, +		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));, +		ReflectionTestUtils.setField(this.tokenValidator, "cachedTokenKeys", INVALID_KEYS);, +		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());, +		Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, "cachedTokenKeys");, +		assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS);, +		fetchTokenKeys.assertWasSubscribed();, +	}, +, +	@Test, +	public void validateTokenWhenCacheIsEmptyShouldFetchTokenKeys() throws Exception {, +		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));, +		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());, +		given(this.securityService.getUaaUrl()), +				.willReturn(Mono.just("http://localhost:8080/uaa"));, +		String header = "{\"alg\": \"RS256\",  \"kid\": \"valid-key\",\"typ\": \"JWT\"}";, +		String claims = "{\"exp\": 2147483647, \"iss\": \"http://localhost:8080/uaa/oauth/token\", \"scope\": [\"actuator.read\"]}";, +		StepVerifier, +				.create(this.tokenValidator.validate(, +						new Token(getSignedToken(header.getBytes(), claims.getBytes())))), +				.verifyComplete();, +		Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, "cachedTokenKeys");, +		assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS);, +		fetchTokenKeys.assertWasSubscribed();, +	}, +, +	@Test, +	public void validateTokenWhenCacheEmptyAndInvalidKeyShouldThrowException() throws Exception {, +		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));, +		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());, +		given(this.securityService.getUaaUrl()), +				.willReturn(Mono.just("http://localhost:8080/uaa"));, +		String header = "{\"alg\": \"RS256\",  \"kid\": \"invalid-key\",\"typ\": \"JWT\"}";, +		String claims = "{\"exp\": 2147483647, \"iss\": \"http://localhost:8080/uaa/oauth/token\", \"scope\": [\"actuator.read\"]}";, +		StepVerifier, +				.create(this.tokenValidator.validate(, +						new Token(getSignedToken(header.getBytes(), claims.getBytes())))), +				.consumeErrorWith((ex) -> {, +					assertThat(ex).isExactlyInstanceOf(, +							CloudFoundryAuthorizationException.class);, +					assertThat(((CloudFoundryAuthorizationException) ex).getReason()), +							.isEqualTo(Reason.INVALID_KEY_ID);, +				}).verify();, +		Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, "cachedTokenKeys");, +		assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS);, +		fetchTokenKeys.assertWasSubscribed();, +	}, +, +	@Test, +	public void validateTokenWhenCacheValidShouldNotFetchTokenKeys() throws Exception {, +		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.empty();, +		ReflectionTestUtils.setField(this.tokenValidator, "cachedTokenKeys", VALID_KEYS);, +		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());, +		given(this.securityService.getUaaUrl()), +				.willReturn(Mono.just("http://localhost:8080/uaa"));, +		String header = "{\"alg\": \"RS256\",  \"kid\": \"valid-key\",\"typ\": \"JWT\"}";]