[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java, +import java.util.Map.Entry;, +import org.springframework.context.annotation.ConditionContext;, +import org.springframework.core.type.AnnotatedTypeMetadata;, + * @author Andy Wilkinson, +	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();, +, +	private boolean addedAncestorOutcomes;, +, +		this.addedAncestorOutcomes = false;, +		if (!this.addedAncestorOutcomes) {, +			for (Map.Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +				if (!entry.getValue().isFullMatch()) {, +					addNoMatchOutcomeToAncestors(entry.getKey());, +				}, +			}, +			this.addedAncestorOutcomes = true;, +		}, +	private void addNoMatchOutcomeToAncestors(String source) {, +		String prefix = source + "$";, +		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +			if (entry.getKey().startsWith(prefix)) {, +				ConditionOutcome outcome = new ConditionOutcome(false, "Ancestor '", +						+ source + "' did not match");, +				entry.getValue().add(ANCESTOR_CONDITION, outcome);, +			}, +		}, +	}, +, +, +		@Override, +		public String toString() {, +			return this.condition.getClass() + " " + this.outcome;, +		}, +	}, +, +	private static class AncestorsMatchedCondition implements Condition {, +, +		@Override, +		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {, +			throw new UnsupportedOperationException();, +		}, +, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java, +import java.util.Map.Entry;, +import org.springframework.context.annotation.ConditionContext;, +import org.springframework.core.type.AnnotatedTypeMetadata;, + * @author Andy Wilkinson, +	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();, +, +	private boolean addedAncestorOutcomes;, +, +		this.addedAncestorOutcomes = false;, +		if (!this.addedAncestorOutcomes) {, +			for (Map.Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +				if (!entry.getValue().isFullMatch()) {, +					addNoMatchOutcomeToAncestors(entry.getKey());, +				}, +			}, +			this.addedAncestorOutcomes = true;, +		}, +	private void addNoMatchOutcomeToAncestors(String source) {, +		String prefix = source + "$";, +		for (Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +			if (entry.getKey().startsWith(prefix)) {, +				ConditionOutcome outcome = new ConditionOutcome(false, "Ancestor '", +						+ source + "' did not match");, +				entry.getValue().add(ANCESTOR_CONDITION, outcome);, +			}, +		}, +	}, +, +, +		@Override, +		public String toString() {, +			return this.condition.getClass() + " " + this.outcome;, +		}, +	}, +, +	private static class AncestorsMatchedCondition implements Condition {, +, +		@Override, +		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {, +			throw new UnsupportedOperationException();, +		}, +, +++ /dev/null, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java, +import java.util.Map.Entry;, +import org.springframework.context.annotation.ConditionContext;, +import org.springframework.core.type.AnnotatedTypeMetadata;, + * @author Andy Wilkinson, +	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();, +, +	private boolean addedAncestorOutcomes;, +, +		this.addedAncestorOutcomes = false;, +		if (!this.addedAncestorOutcomes) {, +			for (Map.Entry<String, ConditionAndOutcomes> entry : this.outcomes.entrySet()) {, +				if (!entry.getValue().isFullMatch()) {]