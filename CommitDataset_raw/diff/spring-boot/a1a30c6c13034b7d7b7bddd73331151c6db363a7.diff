[+++ b/spring-boot-project/spring-boot-docs/src/main/asciidoc/howto.adoc, +This section provides answers to some common '`how do I do that...`' questions, +that often arise when using Spring Boot. Its coverage is not exhaustive, but it, +If you have a specific problem that we do not cover here, you might want to check out, +already provided an answer. This is also a great place to ask new questions (please use, +We are also more than happy to extend this section. If you want to add a '`how-to`',, +send us a {github-code}[pull request]., +== Spring Boot Application, +=== Create Your Own FailureAnalyzer, +in a {dc-spring-boot}/diagnostics/FailureAnalysis.{dc-ext}[`FailureAnalysis`]. Spring, +Boot provides such an analyzer for application-context-related exceptions, JSR-303, +validations, and more. You can also create your own., +actually present. If, for whatever reason, you cannot handle the exception, return `null`, +`FailureAnalyzer` implementations must be registered in `META-INF/spring.factories`., +The following example registers `ProjectConstraintViolationFailureAnalyzer`:, +=== Troubleshoot Auto-configuration, +sometimes things fail, and it can be hard to tell why., +`ApplicationContext`. You can see it if you enable `DEBUG` logging output. If you use, +the `spring-boot-actuator`, there is also an `autoconfig` endpoint that renders the report, +in JSON. Use that endpoint to debug the application and see what features have been added (and, +Many more questions can be answered by looking at the source code and the Javadoc. When, +reading the code, remember the following rules of thumb:, +* Look for classes called `+*AutoConfiguration+` and read their sources. Pay special attention to the, +  Actuator app, look at the `autoconfig` endpoint (`/application/autoconfig` or the JMX, +* Look for classes that are `@ConfigurationProperties` (such as, +  `@ConfigurationProperties` has a `name` attribute that acts as a prefix to external, +  properties. Thus, `ServerProperties` has `prefix="server"` and its configuration properties, +  are `server.port`, `server.address`, and others. In a running Actuator app, look at the, +=== Customize the Environment or ApplicationContext Before It Starts, +* Programmatically, per application, by calling the `addListeners` and `addInitializers`, +* Declaratively, per application, by setting the `context.initializer.classes` or, +  `context.listener.classes` properties., +* Declaratively, for all applications, by adding a `META-INF/spring.factories` and packaging, +The `SpringApplication` sends some special `ApplicationEvents` to the listeners (some, +even before the context is created) and then registers the listeners for events published, +"`<<spring-boot-features.adoc#boot-features-application-events-and-listeners>>`" in the, +refreshed by using `EnvironmentPostProcessor`. Each implementation should be registered in, +`META-INF/spring.factories`, as shown in the following example:, +instance, the following example loads a YAML configuration file from the classpath:, +TIP: The `Environment` has already been prepared with all the usual property sources, +precedence. A custom implementation may define another order., +CAUTION: While using `@PropertySource` on your `@SpringBootApplication` may seem convenient and, +key defined via `@PropertySource` is loaded too late to have any effect on, +=== Build an ApplicationContext Hierarchy (Adding a Parent or Root Context), +hierarchies. See "`<<spring-boot-features.adoc#boot-features-fluent-builder-api>>`", +=== Create a Non-web Application, +execute some code in a `main` method but also bootstrap a Spring application to set up, +the infrastructure to use, you can use the `SpringApplication` features of Spring, +Boot. A `SpringApplication` changes its `ApplicationContext` class, depending on whether it, +thinks it needs a web application or not. The first thing you can do to help it is to, +leave the servlet API dependencies off the classpath. If you cannot do that (for example, you, +run two applications from the same code base) then you can explicitly call, +`setWebEnvironment(false)` on your `SpringApplication` instance or set the, +== Properties and Configuration, +=== Automatically Expand Properties at Build Time, +configuration, you can automatically expand them by instead using the existing build, +configuration. This is possible in both Maven and Gradle., +==== Automatic Property Expansion Using Maven, +You can automatically expand properties from the Maven project by using resource, +filtering. If you use the `spring-boot-starter-parent`, you can then refer to your, +Maven '`project properties`' with `@..@` placeholders, as shown in the following example:, +NOTE: Only production configuration is filtered that way (in other words, no filtering is, +applied on `src/test/resources`)., +TIP: If you enable the `addResources` flag, the `spring-boot:run` goal can add, +`src/main/resources` directly to the classpath (for hot reloading purposes). Doing so, +circumvents the resource filtering and this feature. Instead, you can use the `exec:java`, +goal or customize the plugin's configuration, see the, +If you do not use the starter parent, you need to include the following  element inside, +the `<build/>` element of your `pom.xml`:, +You also need to incude the following element inside `<plugins/>`:, +NOTE: The `useDefaultDelimiters` property is important if you use standard Spring, +placeholders (such as `${placeholder}`) in your configuration. If that property is not, +set to `false`, these may be expanded by the build., +==== Automatic Property Expansion Using Gradle, +Java plugin's `processResources` task to do so, as shown in the following example:, +You can then refer to your Gradle project's properties via placeholders, as shown in the, +following example:, +NOTE: Gradle's `expand` method uses Groovy's `SimpleTemplateEngine`, which transforms, +mechanism. To use Spring property placeholders together with automatic expansion, escape, +the Spring property placeholders as follows: `\${..}`., +=== Externalize the Configuration of SpringApplication, +A `SpringApplication` has bean properties (mainly setters), so you can use its Java API as, +you create the application to modify its behavior. Alternatively, you can externalize the, +configuration using properties in `+spring.main.*+`. For example, in `application.properties`, you, +might have the following settings:, +Then the Spring Boot banner is not printed on startup, and the application is, +not a web application., +NOTE: The preceding example also demonstrates how flexible binding allows the use of, +Properties defined in external configuration overrides the values specified with the Java, +API, with the notable exception of the sources used to create the `ApplicationContext`., +Consider the following application:, +Now consider the following configuration:, +The actual application _now_ shows the banner (as overridden by configuration) and uses, +three sources for the `ApplicationContext` (in the following order): `demo.MyApp`,, +`com.acme.Config`, `com.acme.ExtraConfig`., +=== Change the Location of External Properties of an Application, +By default, properties from different sources are added to the Spring `Environment` in a, +defined order (see "`<<spring-boot-features.adoc#boot-features-external-config>>`" in, +A nice way to augment and modify this ordering is to add `@PropertySource` annotations to your, +methods and those added using `setSources()` are inspected to see if they have]