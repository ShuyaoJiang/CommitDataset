[+++ b/.gitignore, +.factorypath, +.DS_Store, +++ b/.gitignore, +.factorypath, +.DS_Store, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/ConfigurationPropertiesReportEndpoint.java, +import java.io.IOException;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.springframework.beans.BeanWrapperImpl;, +import org.springframework.core.io.Resource;, +import org.springframework.core.io.support.PathMatchingResourcePatternResolver;, +import org.springframework.util.ClassUtils;, +import com.fasterxml.jackson.core.JsonParseException;, +import com.fasterxml.jackson.databind.JsonMappingException;, +	private static final Log logger = LogFactory, +			.getLog(ConfigurationPropertiesReportEndpoint.class);, +, +	private ConfigurationPropertiesMetaData metadata = new ConfigurationPropertiesMetaData();, +, +			String prefix = extractPrefix(context, beanName, bean);, +			root.put("prefix", prefix);, +			root.put("properties", sanitize(safeSerialize(mapper, bean, prefix)));, +	 * Cautiously serialize the bean to a map (returning a map with an error message, +	 * instead of throwing an exception if there is a problem)., +	 */, +	private Map<String, Object> safeSerialize(ObjectMapper mapper, Object bean,, +			String prefix) {, +		try {, +			@SuppressWarnings("unchecked"), +			Map<String, Object> result = new HashMap<String, Object>(mapper.convertValue(, +					this.metadata.extractMap(bean, prefix), Map.class));, +			return result;, +		}, +		catch (Exception e) {, +			return new HashMap<String, Object>(Collections.<String, Object> singletonMap(, +					"error", "Cannot serialize '" + prefix + "'"));, +		}, +	}, +, +	/**, +		mapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);, +	 * Configure PropertyFilter to make sure Jackson doesn't process CGLIB generated bean, +				boolean readable = isReadable(beanDesc, writer);, +				if (readable) {, +		private boolean isReadable(BeanDescription beanDesc, BeanPropertyWriter writer) {, +			String parenType = beanDesc.getType().getTypeName();, +			String type = writer.getType().getTypeName();, +			AnnotatedMethod setter = beanDesc.findMethod(, +					"set" + StringUtils.capitalize(writer.getName()),, +					new Class<?>[] { writer.getPropertyType() });, +			// If there's a setter, we assume it's OK to report on the value,, +			// similarly, if there's no setter but the package names match, we assume, +			// that its a nested class used solely for binding to config props, so it, +			// should be kosher. This filter is not used if there is JSON metadata for, +			// the property, so it's mainly for user-defined beans., +			boolean readable = setter != null, +					|| ClassUtils.getPackageName(parenType).equals(, +							ClassUtils.getPackageName(type));, +			return readable;, +		}, +	}, +, +	/**, +	 * Convenience class for grabbing and caching valid property names from, +	 * /META-INF/spring-configuration-metadata.json so that metadata that is known to be, +	 * valid can be used to pull the correct nested properties out of beans that might, +	 * otherwise be tricky (contain cycles or other unserializable properties)., +	 */, +	protected static class ConfigurationPropertiesMetaData {, +, +		private Map<String, Set<String>> matched = new HashMap<String, Set<String>>();, +		private Set<String> keys = null;, +, +		public boolean matches(String prefix) {, +			if (this.matched.containsKey(prefix)) {, +				return matchesInternal(prefix);, +			}, +			synchronized (this.matched) {, +				if (this.matched.containsKey(prefix)) {, +					return matchesInternal(prefix);, +				}, +				this.matched.put(prefix, findKeys(prefix));, +			}, +			return matchesInternal(prefix);, +		}, +, +		private boolean matchesInternal(String prefix) {, +			if (this.matched.get(prefix) != null) {, +				return true;, +			}, +			else {, +				return false;, +			}, +		}]