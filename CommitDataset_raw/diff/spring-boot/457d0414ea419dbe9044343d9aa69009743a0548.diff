[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnBean.java, + * Copyright 2012-2017 the original author or authors., +	 * The class type of bean that should be checked. The condition matches when all of, +	 * the classes specified are contained in the {@link ApplicationContext}., +	 * The class type names of bean that should be checked. The condition matches when all, +	 * of the classes specified are contained in the {@link ApplicationContext}., +	 * when all of the annotations specified are defined on beans in the, +	 * The names of beans to check. The condition matches when all of the bean names, +	 * specified are contained in the {@link ApplicationContext}., +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnBean.java, + * Copyright 2012-2017 the original author or authors., +	 * The class type of bean that should be checked. The condition matches when all of, +	 * the classes specified are contained in the {@link ApplicationContext}., +	 * The class type names of bean that should be checked. The condition matches when all, +	 * of the classes specified are contained in the {@link ApplicationContext}., +	 * when all of the annotations specified are defined on beans in the, +	 * The names of beans to check. The condition matches when all of the bean names, +	 * specified are contained in the {@link ApplicationContext}., +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnBeanCondition.java, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +			MatchResult matchResult = getMatchingBeans(context, spec);, +			if (!matchResult.isAllMatched()) {, +				String reason = createOnBeanNoMatchReason(matchResult);, +				return ConditionOutcome.noMatch(ConditionMessage, +						.forCondition(ConditionalOnBean.class, spec).because(reason));, +					.found("bean", "beans"), +					.items(Style.QUOTE, matchResult.getNamesOfAllMatches());, +			MatchResult matchResult = getMatchingBeans(context, spec);, +			if (!matchResult.isAllMatched()) {, +			else if (!hasSingleAutowireCandidate(context.getBeanFactory(),, +					matchResult.getNamesOfAllMatches(),, +						.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));, +					.found("a primary bean from beans"), +					.items(Style.QUOTE, matchResult.namesOfAllMatches);, +			MatchResult matchResult = getMatchingBeans(context, spec);, +			if (matchResult.isAnyMatched()) {, +				String reason = createOnMissingBeanNoMatchReason(matchResult);, +						.because(reason));, +	private String createOnBeanNoMatchReason(MatchResult matchResult) {, +		StringBuilder reason = new StringBuilder();, +		appendMessageForNoMatches(reason, matchResult.unmatchedAnnotations,, +				"annotated with");, +		appendMessageForNoMatches(reason, matchResult.unmatchedTypes, "of type");, +		appendMessageForNoMatches(reason, matchResult.unmatchedNames, "named");, +		return reason.toString();, +	}, +, +	private void appendMessageForNoMatches(StringBuilder reason,, +			Collection<String> unmatched, String description) {, +		if (!unmatched.isEmpty()) {, +			if (reason.length() > 0) {, +				reason.append(" and ");, +			}, +			reason.append("did not find any beans ");, +			reason.append(description);, +			reason.append(" ");, +			reason.append(StringUtils.collectionToDelimitedString(unmatched, ", "));, +		}, +	}, +, +	private String createOnMissingBeanNoMatchReason(MatchResult matchResult) {, +		StringBuilder reason = new StringBuilder();, +		appendMessageForMatches(reason, matchResult.matchedAnnotations, "annotated with");, +		appendMessageForMatches(reason, matchResult.matchedTypes, "of type");, +		if (!matchResult.matchedNames.isEmpty()) {, +			if (reason.length() > 0) {, +				reason.append(" and ");, +			}, +			reason.append("found beans named ");, +			reason.append(StringUtils, +					.collectionToDelimitedString(matchResult.matchedNames, ", "));, +		}, +		return reason.toString();, +	}, +, +	private void appendMessageForMatches(StringBuilder reason,, +			Map<String, Collection<String>> matches, String description) {, +		if (!matches.isEmpty()) {, +			for (Map.Entry<String, Collection<String>> match : matches.entrySet()) {, +				if (reason.length() > 0) {, +					reason.append(" and ");, +				}, +				reason.append("found beans ");, +				reason.append(description);, +				reason.append("'");, +				reason.append(match.getKey());, +				reason.append("'");, +				reason.append(, +						StringUtils.collectionToDelimitedString(match.getValue(), ", "));, +			}, +		}, +	}, +, +	private MatchResult getMatchingBeans(ConditionContext context, BeanSearchSpec beans) {, +		MatchResult matchResult = new MatchResult();, +		List<String> beansIgnoredByType = getNamesOfBeansIgnoredByType(, +				beans.getIgnoredTypes(), beanFactory, context, considerHierarchy);, +			Collection<String> typeMatches = getBeanNamesForType(beanFactory, type,]