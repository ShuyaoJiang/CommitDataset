[+++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/web/servlet/WebMvcMetricsConfiguration.java, +import javax.servlet.DispatcherType;, +, +import org.springframework.boot.web.servlet.FilterRegistrationBean;, +	public FilterRegistrationBean<WebMvcMetricsFilter> webMetricsFilter(, +			MeterRegistry registry, MetricsProperties properties,, +			WebMvcTagsProvider tagsProvider, WebApplicationContext context) {, +		WebMvcMetricsFilter filter = new WebMvcMetricsFilter(context, registry,, +				tagsProvider, serverProperties.getRequestsMetricName(),, +		FilterRegistrationBean<WebMvcMetricsFilter> registration = new FilterRegistrationBean<>(, +				filter);, +		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC);, +		return registration;, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/web/servlet/WebMvcMetricsConfiguration.java, +import javax.servlet.DispatcherType;, +, +import org.springframework.boot.web.servlet.FilterRegistrationBean;, +	public FilterRegistrationBean<WebMvcMetricsFilter> webMetricsFilter(, +			MeterRegistry registry, MetricsProperties properties,, +			WebMvcTagsProvider tagsProvider, WebApplicationContext context) {, +		WebMvcMetricsFilter filter = new WebMvcMetricsFilter(context, registry,, +				tagsProvider, serverProperties.getRequestsMetricName(),, +		FilterRegistrationBean<WebMvcMetricsFilter> registration = new FilterRegistrationBean<>(, +				filter);, +		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC);, +		return registration;, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/test/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsAutoConfigurationIntegrationTests.java, +import java.util.concurrent.BrokenBarrierException;, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.TimeUnit;, +	@Autowired, +	private CyclicBarrier cyclicBarrier;, +, +	@Test, +	public void asyncRequestMappingIsInstrumented() throws InterruptedException, BrokenBarrierException {, +		Thread backgroundRequest = new Thread(() -> this.loopback.getForObject("/api/async", String.class));, +		backgroundRequest.start();, +		this.cyclicBarrier.await();, +		MockClock.clock(this.registry).addSeconds(2);, +		this.cyclicBarrier.await();, +		backgroundRequest.join();, +, +		assertThat(this.registry.find("http.server.requests"), +				.tags("uri", "/api/async").timer()), +				.matches(t -> t.count() == 1), +				.matches(t -> t.totalTime(TimeUnit.SECONDS) == 2);, +	}, +, +		@Bean, +		public CyclicBarrier cyclicBarrier() {, +			return new CyclicBarrier(2);, +		}, +		private final CyclicBarrier cyclicBarrier;, +, +		PersonController(CyclicBarrier cyclicBarrier) {, +			this.cyclicBarrier = cyclicBarrier;, +		}, +		@GetMapping("/api/async"), +		CompletableFuture<String> asyncHello() throws BrokenBarrierException, InterruptedException {, +			this.cyclicBarrier.await();, +			return CompletableFuture.supplyAsync(() -> {, +				try {, +					this.cyclicBarrier.await();, +				}, +				catch (InterruptedException | BrokenBarrierException e) {, +					throw new RuntimeException(e);, +				}, +				return "async-hello";, +			});, +		}]