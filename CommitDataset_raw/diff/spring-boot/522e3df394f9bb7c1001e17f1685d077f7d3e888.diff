[+++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/source/ConfigurationPropertySources.java, +	 * automatically tracked. The underlying source should be thread safe, for example a, +	 * {@link MutablePropertySources}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/source/ConfigurationPropertySources.java, +	 * automatically tracked. The underlying source should be thread safe, for example a, +	 * {@link MutablePropertySources}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/source/SpringConfigurationPropertySources.java, + * Copyright 2012-2018 the original author or authors., +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.Map;, +import java.util.NoSuchElementException;, +import java.util.function.Function;, +import org.springframework.util.ConcurrentReferenceHashMap;, +import org.springframework.util.ConcurrentReferenceHashMap.ReferenceType;, +	private final Map<PropertySource<?>, ConfigurationPropertySource> cache = new ConcurrentReferenceHashMap<>(, +			16, ReferenceType.SOFT);, +		return new SourcesIterator(this.sources.iterator(), this::adapt);, +	private ConfigurationPropertySource adapt(PropertySource<?> source) {, +		ConfigurationPropertySource result = this.cache.get(source);, +		// Most PropertySource test quality only using the source name, we need to, +		// check the actual source hasn't also changed., +		if (result != null && result.getUnderlyingSource() == source) {, +			return result;, +		result = SpringConfigurationPropertySource.from(source);, +		this.cache.put(source, result);, +	private static class SourcesIterator, +			implements Iterator<ConfigurationPropertySource> {, +, +		private Deque<Iterator<PropertySource<?>>> iterators;, +, +		private ConfigurationPropertySource next;, +, +		private final Function<PropertySource<?>, ConfigurationPropertySource> adapter;, +, +		SourcesIterator(Iterator<PropertySource<?>> iterator,, +				Function<PropertySource<?>, ConfigurationPropertySource> adapter) {, +			this.iterators = new ArrayDeque<>(4);, +			this.iterators.push(iterator);, +			this.adapter = adapter;, +		}, +, +		public boolean hasNext() {, +			return fetchNext() != null;, +, +		@Override, +		public ConfigurationPropertySource next() {, +			ConfigurationPropertySource next = fetchNext();, +			this.next = null;, +			if (next == null) {, +				throw new NoSuchElementException();, +			return next;, +		}, +, +		private ConfigurationPropertySource fetchNext() {, +			if (this.next == null) {, +				if (this.iterators.isEmpty()) {, +					return null;, +				}, +				if (!this.iterators.peek().hasNext()) {, +					this.iterators.pop();, +					return fetchNext();, +				}, +				PropertySource<?> candidate = this.iterators.peek().next();, +				if (candidate.getSource() instanceof ConfigurableEnvironment) {, +					push((ConfigurableEnvironment) candidate.getSource());, +					return fetchNext();, +				}, +				if (isIgnored(candidate)) {, +					return fetchNext();, +				}, +				this.next = this.adapter.apply(candidate);, +			}, +			return this.next;, +		}, +, +		private void push(ConfigurableEnvironment environment) {, +			this.iterators.push(environment.getPropertySources().iterator());, +		}, +, +		private boolean isIgnored(PropertySource<?> candidate) {, +			return (candidate instanceof StubPropertySource, +					|| candidate instanceof ConfigurationPropertySourcesPropertySource);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/source/ConfigurationPropertySources.java, +	 * automatically tracked. The underlying source should be thread safe, for example a, +	 * {@link MutablePropertySources}, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/source/SpringConfigurationPropertySources.java, + * Copyright 2012-2018 the original author or authors., +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.Map;, +import java.util.NoSuchElementException;, +import java.util.function.Function;, +import org.springframework.util.ConcurrentReferenceHashMap;, +import org.springframework.util.ConcurrentReferenceHashMap.ReferenceType;, +	private final Map<PropertySource<?>, ConfigurationPropertySource> cache = new ConcurrentReferenceHashMap<>(, +			16, ReferenceType.SOFT);, +		return new SourcesIterator(this.sources.iterator(), this::adapt);, +	private ConfigurationPropertySource adapt(PropertySource<?> source) {, +		ConfigurationPropertySource result = this.cache.get(source);]