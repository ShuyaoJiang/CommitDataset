[+++ b/spring-boot-cli/pom.xml, +									<mainClass>org.springframework.boot.loader.PropertiesLauncher</mainClass>, +								<manifestEntries>, +									<Class-Loader>groovy.lang.GroovyClassLoader</Class-Loader>, +								</manifestEntries>, +++ b/spring-boot-cli/pom.xml, +									<mainClass>org.springframework.boot.loader.PropertiesLauncher</mainClass>, +								<manifestEntries>, +									<Class-Loader>groovy.lang.GroovyClassLoader</Class-Loader>, +								</manifestEntries>, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +import java.util.jar.Manifest;, +import java.util.logging.Level;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +	private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");, +, +		if (!isDebug()) {, +			this.logger.setLevel(Level.SEVERE);, +		}, +	private boolean isDebug() {, +		String debug = System.getProperty("debug");, +		if (debug != null && !"false".equals(debug)) {, +			return true;, +		}, +		debug = System.getProperty("DEBUG");, +		if (debug != null && !"false".equals(debug)) {, +			return true;, +		}, +		debug = System.getenv("DEBUG");, +		if (debug != null && !"false".equals(debug)) {, +			return true;, +		}, +		return false;, +	}, +, +		String mainClass = getProperty(MAIN, "Start-Class");, +		if (mainClass == null) {, +			throw new IllegalStateException("No '" + MAIN, +					+ "' or 'Start-Class' specified");, +		}, +, +	@Override, +	protected ClassLoader createClassLoader(List<Archive> archives) throws Exception {, +		ClassLoader loader = super.createClassLoader(archives);, +		String classLoaderType = getProperty("loader.classLoader");, +		if (classLoaderType != null) {, +			Class<?> type = Class.forName(classLoaderType, true, loader);, +			try {, +				loader = (ClassLoader) type.getConstructor(ClassLoader.class), +						.newInstance(loader);, +			}, +			catch (NoSuchMethodException e) {, +				try {, +					loader = (ClassLoader) type.getConstructor(URL[].class,, +							ClassLoader.class).newInstance(new URL[0], loader);, +				}, +				catch (NoSuchMethodException ex) {, +					loader = (ClassLoader) type.newInstance();, +				}, +			}, +			this.logger.info("Using custom class loader: " + classLoaderType);, +		}, +		return loader;, +	}, +, +	private String getProperty(String propertyKey) throws Exception {, +		return getProperty(propertyKey, null);, +	}, +, +	private String getProperty(String propertyKey, String manifestKey) throws Exception {, +		if (manifestKey == null) {, +			manifestKey = propertyKey.replace(".", "-");, +			manifestKey = toCamelCase(manifestKey);, +		}, +		String property = SystemPropertyUtils.getProperty(propertyKey);, +		if (property != null) {, +			String value = SystemPropertyUtils.resolvePlaceholders(property);, +			this.logger.fine("Property '" + propertyKey + "' from environment: " + value);, +			return value;, +		}, +		if (this.properties.containsKey(propertyKey)) {, +			String value = SystemPropertyUtils.resolvePlaceholders(this.properties, +					.getProperty(propertyKey));, +			this.logger.fine("Property '" + propertyKey + "' from properties: " + value);, +			return value;, +			Manifest manifest = new ExplodedArchive(this.home).getManifest();, +			if (manifest != null) {, +				String value = manifest.getMainAttributes().getValue(manifestKey);, +				this.logger.fine("Property '" + manifestKey, +						+ "' from home directory manifest: " + value);, +				return value;, +			}, +		// Otherwise try the parent archive, +		Manifest manifest = createArchive().getManifest();, +		if (manifest != null) {, +			String value = manifest.getMainAttributes().getValue(manifestKey);, +			if (value != null) {, +				this.logger.fine("Property '" + manifestKey + "' from archive manifest: ", +						+ value);]