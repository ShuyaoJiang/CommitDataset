[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/InMemoryMetricRepository.java, +	private ConcurrentMap<String, Object> locks = new ConcurrentHashMap<String, Object>();, +, +			Object lock = this.locks.putIfAbsent(metricName, new Object());, +			if (lock == null) {, +				lock = this.locks.get(metricName);, +			synchronized (lock) {, +				current = this.metrics.get(metricName);, +				Metric metric = current.getMetric();, +				this.metrics.replace(metricName, current, new Measurement(timestamp,, +						metric.increment(amount)));, +				return;, +			}, +		}, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/InMemoryMetricRepository.java, +	private ConcurrentMap<String, Object> locks = new ConcurrentHashMap<String, Object>();, +, +			Object lock = this.locks.putIfAbsent(metricName, new Object());, +			if (lock == null) {, +				lock = this.locks.get(metricName);, +			synchronized (lock) {, +				current = this.metrics.get(metricName);, +				Metric metric = current.getMetric();, +				this.metrics.replace(metricName, current, new Measurement(timestamp,, +						metric.increment(amount)));, +				return;, +			}, +		}, +++ b/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/metrics/InMemoryMetricRepositoryTests.java, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.Date;, +import java.util.List;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +	private InMemoryMetricRepository repository = new InMemoryMetricRepository();, +	public void increment() {, +		this.repository.increment("foo", 1, new Date());, +		assertEquals(1.0, this.repository.findOne("foo").getValue(), 0.01);, +	}, +, +	@Test, +	public void incrementConcurrent() throws Exception {, +		Collection<Callable<Boolean>> tasks = new ArrayList<Callable<Boolean>>();, +		for (int i = 0; i < 100; i++) {, +			tasks.add(new Callable<Boolean>() {, +				@Override, +				public Boolean call() throws Exception {, +					InMemoryMetricRepositoryTests.this.repository.increment("foo", 1,, +							new Date());, +					return true;, +				}, +			});, +			tasks.add(new Callable<Boolean>() {, +				@Override, +				public Boolean call() throws Exception {, +					InMemoryMetricRepositoryTests.this.repository.increment("foo", -1,, +							new Date());, +					return true;, +				}, +			});, +		}, +		List<Future<Boolean>> all = Executors.newFixedThreadPool(10).invokeAll(tasks);, +		for (Future<Boolean> future : all) {, +			assertTrue(future.get(1, TimeUnit.SECONDS));, +		}, +		assertEquals(0, this.repository.findOne("foo").getValue(), 0.01);, +	}, +, +	@Test, +	public void set() {, +		this.repository.set("foo", 1, new Date());, +		assertEquals(1.0, this.repository.findOne("foo").getValue(), 0.01);]