[+++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +		return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey)), +	private Mono<String> getTokenKey(Token token) {, +		String keyId = token.getKeyId();, +		String cached = this.cachedTokenKeys.get(keyId);, +		if (cached != null) {, +			return Mono.just(cached);, +		}, +		return this.securityService.fetchTokenKeys().doOnSuccess(this::cacheTokenKeys), +				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +				.map((tokenKeys) -> tokenKeys.get(keyId)), +				.switchIfEmpty(Mono.error(, +						new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,, +								"Key Id present in token header does not match")));, +	}, +, +	private void cacheTokenKeys(Map<String, String> tokenKeys) {, +		this.cachedTokenKeys.clear();, +		this.cachedTokenKeys.putAll(tokenKeys);, +	}, +, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +		return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey)), +	private Mono<String> getTokenKey(Token token) {, +		String keyId = token.getKeyId();, +		String cached = this.cachedTokenKeys.get(keyId);, +		if (cached != null) {, +			return Mono.just(cached);, +		}, +		return this.securityService.fetchTokenKeys().doOnSuccess(this::cacheTokenKeys), +				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +				.map((tokenKeys) -> tokenKeys.get(keyId)), +				.switchIfEmpty(Mono.error(, +						new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,, +								"Key Id present in token header does not match")));, +	}, +, +	private void cacheTokenKeys(Map<String, String> tokenKeys) {, +		this.cachedTokenKeys.clear();, +		this.cachedTokenKeys.putAll(tokenKeys);, +	}, +, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/atlas/AtlasPropertiesConfigAdapter.java, +class AtlasPropertiesConfigAdapter extends PropertiesConfigAdapter<AtlasProperties>, +		implements AtlasConfig {, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +		return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey)), +	private Mono<String> getTokenKey(Token token) {, +		String keyId = token.getKeyId();, +		String cached = this.cachedTokenKeys.get(keyId);, +		if (cached != null) {, +			return Mono.just(cached);, +		}, +		return this.securityService.fetchTokenKeys().doOnSuccess(this::cacheTokenKeys), +				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +				.map((tokenKeys) -> tokenKeys.get(keyId)), +				.switchIfEmpty(Mono.error(, +						new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,, +								"Key Id present in token header does not match")));, +	}, +, +	private void cacheTokenKeys(Map<String, String> tokenKeys) {, +		this.cachedTokenKeys.clear();, +		this.cachedTokenKeys.putAll(tokenKeys);, +	}, +, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/atlas/AtlasPropertiesConfigAdapter.java, +class AtlasPropertiesConfigAdapter extends PropertiesConfigAdapter<AtlasProperties>, +		implements AtlasConfig {, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/ganglia/GangliaPropertiesConfigAdapter.java, +class GangliaPropertiesConfigAdapter extends PropertiesConfigAdapter<GangliaProperties>, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java, +		return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey)), +	private Mono<String> getTokenKey(Token token) {, +		String keyId = token.getKeyId();, +		String cached = this.cachedTokenKeys.get(keyId);, +		if (cached != null) {, +			return Mono.just(cached);, +		}, +		return this.securityService.fetchTokenKeys().doOnSuccess(this::cacheTokenKeys), +				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)), +				.map((tokenKeys) -> tokenKeys.get(keyId)), +				.switchIfEmpty(Mono.error(, +						new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,, +								"Key Id present in token header does not match")));, +	}, +, +	private void cacheTokenKeys(Map<String, String> tokenKeys) {, +		this.cachedTokenKeys.clear();, +		this.cachedTokenKeys.putAll(tokenKeys);, +	}, +, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/atlas/AtlasPropertiesConfigAdapter.java, +class AtlasPropertiesConfigAdapter extends PropertiesConfigAdapter<AtlasProperties>, +		implements AtlasConfig {, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/ganglia/GangliaPropertiesConfigAdapter.java, +class GangliaPropertiesConfigAdapter extends PropertiesConfigAdapter<GangliaProperties>, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/graphite/GraphitePropertiesConfigAdapter.java, +class GraphitePropertiesConfigAdapter extends PropertiesConfigAdapter<GraphiteProperties>, +++ b/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveTokenValidator.java]