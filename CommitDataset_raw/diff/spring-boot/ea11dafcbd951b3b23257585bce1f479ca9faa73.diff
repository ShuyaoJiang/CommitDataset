[+++ b/spring-boot-tools/spring-boot-gradle-plugin/src/main/resources/org/springframework/boot/git.properties, +#Tue Oct 15 11:07:38 EDT 2013, +git.commit.id.abbrev=d3fa609, +git.commit.message.full=Extend PropertiesLauncher to load nested archives\n\nPropertiesLauncher can now be used to run an executable jar, and by\ndefault it will pick up nested archives in lib/ (where the Boot\ntools puts them). User can provide loader.path (colon-separated)\nto change the nested path.\n\n[\#58837492] [bs-330] Add tooling for PropertiesLauncher\n, +git.commit.id=d3fa60955b06fe78bbf0c914928d794661aca312, +git.commit.message.short=Extend PropertiesLauncher to load nested archives, +git.commit.time=2013-10-15T10\:51\:03-0400, +git.build.time=2013-10-15T11\:07\:38-0400, +++ b/spring-boot-tools/spring-boot-gradle-plugin/src/main/resources/org/springframework/boot/git.properties, +#Tue Oct 15 11:07:38 EDT 2013, +git.commit.id.abbrev=d3fa609, +git.commit.message.full=Extend PropertiesLauncher to load nested archives\n\nPropertiesLauncher can now be used to run an executable jar, and by\ndefault it will pick up nested archives in lib/ (where the Boot\ntools puts them). User can provide loader.path (colon-separated)\nto change the nested path.\n\n[\#58837492] [bs-330] Add tooling for PropertiesLauncher\n, +git.commit.id=d3fa60955b06fe78bbf0c914928d794661aca312, +git.commit.message.short=Extend PropertiesLauncher to load nested archives, +git.commit.time=2013-10-15T10\:51\:03-0400, +git.build.time=2013-10-15T11\:07\:38-0400, +++ b/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/git.properties, +#Tue Oct 15 11:07:33 EDT 2013, +git.commit.id.abbrev=d3fa609, +git.commit.message.full=Extend PropertiesLauncher to load nested archives\n\nPropertiesLauncher can now be used to run an executable jar, and by\ndefault it will pick up nested archives in lib/ (where the Boot\ntools puts them). User can provide loader.path (colon-separated)\nto change the nested path.\n\n[\#58837492] [bs-330] Add tooling for PropertiesLauncher\n, +git.commit.id=d3fa60955b06fe78bbf0c914928d794661aca312, +git.commit.message.short=Extend PropertiesLauncher to load nested archives, +git.commit.time=2013-10-15T10\:51\:03-0400, +git.build.time=2013-10-15T11\:07\:33-0400, +++ b/spring-boot-tools/spring-boot-gradle-plugin/src/main/resources/org/springframework/boot/git.properties, +#Tue Oct 15 11:07:38 EDT 2013, +git.commit.id.abbrev=d3fa609, +git.commit.message.full=Extend PropertiesLauncher to load nested archives\n\nPropertiesLauncher can now be used to run an executable jar, and by\ndefault it will pick up nested archives in lib/ (where the Boot\ntools puts them). User can provide loader.path (colon-separated)\nto change the nested path.\n\n[\#58837492] [bs-330] Add tooling for PropertiesLauncher\n, +git.commit.id=d3fa60955b06fe78bbf0c914928d794661aca312, +git.commit.message.short=Extend PropertiesLauncher to load nested archives, +git.commit.time=2013-10-15T10\:51\:03-0400, +git.build.time=2013-10-15T11\:07\:38-0400, +++ b/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/git.properties, +#Tue Oct 15 11:07:33 EDT 2013, +git.commit.id.abbrev=d3fa609, +git.commit.message.full=Extend PropertiesLauncher to load nested archives\n\nPropertiesLauncher can now be used to run an executable jar, and by\ndefault it will pick up nested archives in lib/ (where the Boot\ntools puts them). User can provide loader.path (colon-separated)\nto change the nested path.\n\n[\#58837492] [bs-330] Add tooling for PropertiesLauncher\n, +git.commit.id=d3fa60955b06fe78bbf0c914928d794661aca312, +git.commit.message.short=Extend PropertiesLauncher to load nested archives, +git.commit.time=2013-10-15T10\:51\:03-0400, +git.build.time=2013-10-15T11\:07\:33-0400, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +import java.net.URI;, +import java.security.CodeSource;, +import java.security.ProtectionDomain;, +import org.springframework.boot.loader.archive.FilteredArchive;, +		String property = SystemPropertyUtils.getProperty(MAIN);, +		if (property != null) {, +			String mainClass = SystemPropertyUtils.resolvePlaceholders(property);, +			this.logger.info("Main class from environment: " + mainClass);, +			return mainClass;, +			String mainClass = SystemPropertyUtils.resolvePlaceholders(this.properties, +			this.logger.info("Main class from properties: " + mainClass);, +			return mainClass;, +		try {, +			// Prefer home dir for MANIFEST if there is one, +			String mainClass = new ExplodedArchive(this.home).getMainClass();, +			this.logger.info("Main class from home directory manifest: " + mainClass);, +			return mainClass;, +		}, +		catch (IllegalStateException e) {, +			// Otherwise try the parent archive, +			String mainClass = createArchive().getMainClass();, +			this.logger.info("Main class from archive manifest: " + mainClass);, +			return mainClass;, +		}, +						archive.getNestedArchives(new ArchiveEntryFilter()));, +	private List<Archive> getClassPathArchives(String path) throws Exception {, +		Archive nested = getNestedArchive(root);, +		if (nested != null) {, +			this.logger.info("Adding classpath entries from nested " + nested.getUrl(), +					+ root);, +			lib.add(nested);, +		}, +	private Archive getNestedArchive(final String root) throws Exception {, +		Archive parent = createArchive();, +		if (root.startsWith("/") || parent.getUrl().equals(this.home.toURI().toURL())) {, +			// If home dir is same as parent archive, no need to add it twice., +			return null;, +		}, +		EntryFilter filter = new PrefixMatchingArchiveFilter(root);, +		if (parent.getNestedArchives(filter).isEmpty()) {, +			return null;, +		}, +		// If there are more archives nested in this subdirectory (root) then create a new, +		// virtual archive for them, and have it added to the classpath, +		return new FilteredArchive(parent, filter);, +	}, +, +	private Archive createArchive() throws Exception {, +		ProtectionDomain protectionDomain = getClass().getProtectionDomain();, +		CodeSource codeSource = protectionDomain.getCodeSource();, +		URI location = (codeSource == null ? null : codeSource.getLocation().toURI());, +		String path = (location == null ? null : location.getPath());, +		if (path == null) {, +			throw new IllegalStateException("Unable to determine code source archive");, +		}, +		File root = new File(path);, +		if (!root.exists()) {, +			throw new IllegalStateException(, +					"Unable to determine code source archive from " + root);]