[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java, +		if (managementPort == ManagementServerPort.SAME) {, +			if (new RelaxedPropertyResolver(this.applicationContext.getEnvironment(),, +					"management.ssl.").getProperty("enabled") != null) {, +				throw new IllegalStateException(, +						"Management-specific SSL cannot be configured as the management ", +								+ "server is not listening on a separate port");, +			}, +			if (this.applicationContext, +						(ConfigurableEnvironment) this.applicationContext, +								.getEnvironment());, +			}, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java, +		if (managementPort == ManagementServerPort.SAME) {, +			if (new RelaxedPropertyResolver(this.applicationContext.getEnvironment(),, +					"management.ssl.").getProperty("enabled") != null) {, +				throw new IllegalStateException(, +						"Management-specific SSL cannot be configured as the management ", +								+ "server is not listening on a separate port");, +			}, +			if (this.applicationContext, +						(ConfigurableEnvironment) this.applicationContext, +								.getEnvironment());, +			}, +++ b/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfigurationTests.java, +import org.apache.http.client.HttpClient;, +import org.apache.http.conn.ssl.SSLConnectionSocketFactory;, +import org.apache.http.conn.ssl.TrustSelfSignedStrategy;, +import org.apache.http.impl.client.HttpClients;, +import org.apache.http.ssl.SSLContextBuilder;, +import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;, +	public void defaultContextPath() {, +		management.setContextPath("");, +		server.setContextPath("");, +	}, +, +	@Before, +	@Test, +	public void managementSpecificSslUsingDifferentPort() throws Exception {, +		EnvironmentTestUtils.addEnvironment(this.applicationContext,, +				"management.ssl.enabled=true",, +				"management.ssl.key-store=classpath:test.jks",, +				"management.ssl.key-password=password");, +		this.applicationContext.register(RootConfig.class, EndpointConfig.class,, +				DifferentPortConfig.class, BaseConfiguration.class,, +				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);, +		this.applicationContext.refresh();, +		assertContent("/controller", ports.get().server, "controlleroutput");, +		assertContent("/endpoint", ports.get().server, null);, +		assertHttpsContent("/controller", ports.get().management, null);, +		assertHttpsContent("/endpoint", ports.get().management, "endpointoutput");, +		assertHttpsContent("/error", ports.get().management, startsWith("{"));, +		ApplicationContext managementContext = this.applicationContext, +				.getBean(ManagementContextResolver.class).getApplicationContext();, +		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(, +				managementContext.getBean(EndpointHandlerMapping.class), "interceptors");, +		assertThat(interceptors).hasSize(1);, +		ManagementServerProperties managementServerProperties = this.applicationContext, +				.getBean(ManagementServerProperties.class);, +		assertThat(managementServerProperties.getSsl()).isNotNull();, +		assertThat(managementServerProperties.getSsl().isEnabled()).isTrue();, +	}, +, +	@Test, +	public void managementSpecificSslUsingSamePortFails() throws Exception {, +		EnvironmentTestUtils.addEnvironment(this.applicationContext,, +				"management.ssl.enabled=true",, +				"management.ssl.key-store=classpath:test.jks",, +				"management.ssl.key-password=password");, +		this.applicationContext.register(RootConfig.class, EndpointConfig.class,, +				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class,, +				ErrorMvcAutoConfiguration.class, ServerPortConfig.class);, +		this.thrown.expect(IllegalStateException.class);, +		this.thrown.expectMessage("Management-specific SSL cannot be configured as the ", +				+ "management server is not listening on a separate port");, +		this.applicationContext.refresh();, +	}, +, +	@Test, +	public void managementServerCanDisableSslWhenUsingADifferentPort() throws Exception {, +		EnvironmentTestUtils.addEnvironment(this.applicationContext,, +				"server.ssl.enabled=true", "server.ssl.key-store=classpath:test.jks",, +				"server.ssl.key-password=password", "management.ssl.enabled=false");, +, +		this.applicationContext.register(RootConfig.class, EndpointConfig.class,, +				DifferentPortConfig.class, BaseConfiguration.class,, +				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);, +		this.applicationContext.refresh();, +		assertHttpsContent("/controller", ports.get().server, "controlleroutput");, +		assertHttpsContent("/endpoint", ports.get().server, null);, +		assertContent("/controller", ports.get().management, null);, +		assertContent("/endpoint", ports.get().management, "endpointoutput");, +		assertContent("/error", ports.get().management, startsWith("{"));, +		ApplicationContext managementContext = this.applicationContext, +				.getBean(ManagementContextResolver.class).getApplicationContext();, +		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(, +				managementContext.getBean(EndpointHandlerMapping.class), "interceptors");, +		assertThat(interceptors).hasSize(1);, +		ManagementServerProperties managementServerProperties = this.applicationContext, +				.getBean(ManagementServerProperties.class);]