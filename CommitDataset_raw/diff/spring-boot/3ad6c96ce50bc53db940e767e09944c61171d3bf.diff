[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java, + * {@link EnableAutoConfiguration Auto-configuration} for Spring Batch. By default a Runner , + * will be created and all jobs in the context will be executed on startup., + * , + * Disable this behaviour with <code>spring.batch.job.enabled=false</code>). , + * , + * Alternatively, discrete Job names to execute on startup can be supplied by the User with, + * a comma-delimited list: <code>spring.batch.job.names=job1,job2</code>.  In this case the , + * Runner will first find jobs registered as Beans, then those in the existing JobRegistry., +	@Value("${spring.batch.job.names:}"), +	private String jobNames;, +		if (StringUtils.hasText(this.jobNames)) {, +			runner.setJobNames(this.jobNames);, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java, + * {@link EnableAutoConfiguration Auto-configuration} for Spring Batch. By default a Runner , + * will be created and all jobs in the context will be executed on startup., + * , + * Disable this behaviour with <code>spring.batch.job.enabled=false</code>). , + * , + * Alternatively, discrete Job names to execute on startup can be supplied by the User with, + * a comma-delimited list: <code>spring.batch.job.names=job1,job2</code>.  In this case the , + * Runner will first find jobs registered as Beans, then those in the existing JobRegistry., +	@Value("${spring.batch.job.names:}"), +	private String jobNames;, +		if (StringUtils.hasText(this.jobNames)) {, +			runner.setJobNames(this.jobNames);, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java, +import org.springframework.batch.core.BatchStatus;, +import org.springframework.batch.core.launch.NoSuchJobException;, +import org.springframework.batch.core.repository.JobRepository;, +	@Autowired, +	private JobRepository jobRepository;, +, +	private String jobNames;, +	public void setJobNames(String jobNames) {, +		this.jobNames = jobNames;, +		executeRegisteredJobs(jobParameters);, +		if (this.jobRegistry != null && StringUtils.hasText(this.jobNames)) {, +			String[] jobsToRun = this.jobNames.split(",");, +			for (String jobName : jobsToRun) {, +				try {, +					Job job = this.jobRegistry.getJob(jobName);, +					JobExecution previousExecution = jobRepository.getLastJobExecution(jobName, jobParameters);, +					if (previousExecution == null || previousExecution.getStatus() != BatchStatus.COMPLETED) {, +				} catch (NoSuchJobException nsje) {, +					logger.debug("No job found in registry for job name: " + jobName);, +					continue;, +				}, +			}, +		}, +			if (StringUtils.hasText(this.jobNames)) {, +				String[] jobsToRun = this.jobNames.split(",");, +				if (!PatternMatchUtils.simpleMatch(jobsToRun, job.getName())) {, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java, + * {@link EnableAutoConfiguration Auto-configuration} for Spring Batch. By default a Runner , + * will be created and all jobs in the context will be executed on startup., + * , + * Disable this behaviour with <code>spring.batch.job.enabled=false</code>). , + * , + * Alternatively, discrete Job names to execute on startup can be supplied by the User with, + * a comma-delimited list: <code>spring.batch.job.names=job1,job2</code>.  In this case the , + * Runner will first find jobs registered as Beans, then those in the existing JobRegistry., +	@Value("${spring.batch.job.names:}"), +	private String jobNames;, +		if (StringUtils.hasText(this.jobNames)) {, +			runner.setJobNames(this.jobNames);, +++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java, +import org.springframework.batch.core.BatchStatus;, +import org.springframework.batch.core.launch.NoSuchJobException;, +import org.springframework.batch.core.repository.JobRepository;, +	@Autowired, +	private JobRepository jobRepository;, +, +	private String jobNames;, +	public void setJobNames(String jobNames) {, +		this.jobNames = jobNames;, +		executeRegisteredJobs(jobParameters);, +		if (this.jobRegistry != null && StringUtils.hasText(this.jobNames)) {, +			String[] jobsToRun = this.jobNames.split(",");, +			for (String jobName : jobsToRun) {, +				try {, +					Job job = this.jobRegistry.getJob(jobName);, +					JobExecution previousExecution = jobRepository.getLastJobExecution(jobName, jobParameters);, +					if (previousExecution == null || previousExecution.getStatus() != BatchStatus.COMPLETED) {, +				} catch (NoSuchJobException nsje) {, +					logger.debug("No job found in registry for job name: " + jobName);, +					continue;, +				}, +			}, +		}, +			if (StringUtils.hasText(this.jobNames)) {, +				String[] jobsToRun = this.jobNames.split(",");, +				if (!PatternMatchUtils.simpleMatch(jobsToRun, job.getName())) {, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfigurationTests.java, +import org.springframework.batch.core.configuration.JobRegistry;, +import org.springframework.batch.core.configuration.support.JobRegistryBeanPostProcessor;, +	public void testDefinesAndLaunchesNamedJob() throws Exception {, +		this.context = new AnnotationConfigApplicationContext();, +		EnvironmentTestUtils.addEnvironment(this.context,, +				"spring.batch.job.names:discreteRegisteredJob");]