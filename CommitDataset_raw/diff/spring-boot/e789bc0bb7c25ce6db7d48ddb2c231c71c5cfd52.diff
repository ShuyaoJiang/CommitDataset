[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration.java, +import org.flywaydb.core.api.configuration.FluentConfiguration;, +import org.springframework.boot.context.properties.PropertyMapper;, +import org.springframework.util.CollectionUtils;, +	@SuppressWarnings("deprecation"), +			FluentConfiguration configuration = new FluentConfiguration();, +			DataSource dataSource = configureDataSource(configuration);, +			checkLocationExists(dataSource);, +			configureProperties(configuration);, +			configureCallbacks(configuration);, +			Flyway flyway = configuration.load();, +			configureFlywayCallbacks(flyway);, +			return flyway;, +		}, +, +		private DataSource configureDataSource(FluentConfiguration configuration) {, +				configuration.dataSource(url, user, password);, +				if (!CollectionUtils.isEmpty(this.properties.getInitSqls())) {, +					String initSql = StringUtils.collectionToDelimitedString(, +							this.properties.getInitSqls(), "\n");, +					configuration.initSql(initSql);, +				}, +				configuration.dataSource(this.flywayDataSource);, +				configuration.dataSource(this.dataSource);, +			return configuration.getDataSource();, +		private void checkLocationExists(DataSource dataSource) {, +				String[] locations = new LocationResolver(dataSource), +		private void configureProperties(FluentConfiguration configuration) {, +			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +			String[] locations = new LocationResolver(configuration.getDataSource()), +					.resolveLocations(this.properties.getLocations());, +			map.from(locations).to(configuration::locations);, +			map.from(this.properties.getEncoding()).to(configuration::encoding);, +			map.from(this.properties.getConnectRetries()), +					.to(configuration::connectRetries);, +			map.from(this.properties.getSchemas()).as(StringUtils::toStringArray), +					.to(configuration::schemas);, +			map.from(this.properties.getTable()).to(configuration::table);, +			map.from(this.properties.getBaselineDescription()), +					.to(configuration::baselineDescription);, +			map.from(this.properties.getBaselineVersion()), +					.to(configuration::baselineVersion);, +			map.from(this.properties.getInstalledBy()).to(configuration::installedBy);, +			map.from(this.properties.getPlaceholders()).to(configuration::placeholders);, +			map.from(this.properties.getPlaceholderPrefix()), +					.to(configuration::placeholderPrefix);, +			map.from(this.properties.getPlaceholderSuffix()), +					.to(configuration::placeholderSuffix);, +			map.from(this.properties.isPlaceholderReplacement()), +					.to(configuration::placeholderReplacement);, +			map.from(this.properties.getSqlMigrationPrefix()), +					.to(configuration::sqlMigrationPrefix);, +			map.from(this.properties.getSqlMigrationSuffixes()), +					.as(StringUtils::toStringArray), +					.to(configuration::sqlMigrationSuffixes);, +			map.from(this.properties.getSqlMigrationSeparator()), +					.to(configuration::sqlMigrationSeparator);, +			map.from(this.properties.getRepeatableSqlMigrationPrefix()), +					.to(configuration::repeatableSqlMigrationPrefix);, +			map.from(this.properties.getTarget()).to(configuration::target);, +			map.from(this.properties.isBaselineOnMigrate()), +					.to(configuration::baselineOnMigrate);, +			map.from(this.properties.isCleanDisabled()).to(configuration::cleanDisabled);, +			map.from(this.properties.isCleanOnValidationError()), +					.to(configuration::cleanOnValidationError);, +			map.from(this.properties.isGroup()).to(configuration::group);, +			map.from(this.properties.isIgnoreMissingMigrations()), +					.to(configuration::ignoreMissingMigrations);, +			map.from(this.properties.isIgnoreIgnoredMigrations()), +					.to(configuration::ignoreIgnoredMigrations);, +			map.from(this.properties.isIgnorePendingMigrations()), +					.to(configuration::ignorePendingMigrations);, +			map.from(this.properties.isIgnoreFutureMigrations()), +					.to(configuration::ignoreFutureMigrations);, +			map.from(this.properties.isMixed()).to(configuration::mixed);, +			map.from(this.properties.isOutOfOrder()).to(configuration::outOfOrder);, +			map.from(this.properties.isSkipDefaultCallbacks()), +					.to(configuration::skipDefaultCallbacks);, +			map.from(this.properties.isSkipDefaultResolvers()), +					.to(configuration::skipDefaultResolvers);, +			map.from(this.properties.isValidateOnMigrate()), +					.to(configuration::validateOnMigrate);, +		}, +, +		private void configureCallbacks(FluentConfiguration configuration) {, +			if (!this.callbacks.isEmpty()) {, +				configuration.callbacks(this.callbacks.toArray(new Callback[0]));, +			}, +		}, +, +		private void configureFlywayCallbacks(Flyway flyway) {, +			if (!this.flywayCallbacks.isEmpty()) {, +				if (!this.callbacks.isEmpty()) {, +					throw new IllegalStateException(, +							"Found a mixture of Callback and FlywayCallback beans.", +									+ " One type must be used exclusively.");, +				}, +				flyway.setCallbacks(this.flywayCallbacks.toArray(new FlywayCallback[0]));, +			}, +		}]