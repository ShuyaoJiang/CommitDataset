[+++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +		assertEquals(invocation.getErrorOutput(), 0, invocation.getErrorOutput().length());, +++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +		assertEquals(invocation.getErrorOutput(), 0, invocation.getErrorOutput().length());, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +			// Empty path (i.e. the archive itself if running from a JAR) is always added, +			// to the classpath so no need for it to be explicitly listed, +		if (paths.isEmpty()) {, +			// On the other hand, we don't want a completely empty path. If the app is, +			// running from an archive (java -jar) then this will make sure the archive, +			// itself is included at the very least., +			paths.add(".");, +		}, +			Archive archive = new ExplodedArchive(file, false);, +			this.logger.info("Adding classpath entries from archive " + archive.getUrl(), +++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +		assertEquals(invocation.getErrorOutput(), 0, invocation.getErrorOutput().length());, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +			// Empty path (i.e. the archive itself if running from a JAR) is always added, +			// to the classpath so no need for it to be explicitly listed, +		if (paths.isEmpty()) {, +			// On the other hand, we don't want a completely empty path. If the app is, +			// running from an archive (java -jar) then this will make sure the archive, +			// itself is included at the very least., +			paths.add(".");, +		}, +			Archive archive = new ExplodedArchive(file, false);, +			this.logger.info("Adding classpath entries from archive " + archive.getUrl(), +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/archive/ExplodedArchive.java, +					if (file.equals(this.root) || this.recursive) {, +++ b/spring-boot-cli/src/it/java/org/springframework/boot/cli/JarCommandIT.java, +		assertEquals(invocation.getErrorOutput(), 0, invocation.getErrorOutput().length());, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +			// Empty path (i.e. the archive itself if running from a JAR) is always added, +			// to the classpath so no need for it to be explicitly listed, +		if (paths.isEmpty()) {, +			// On the other hand, we don't want a completely empty path. If the app is, +			// running from an archive (java -jar) then this will make sure the archive, +			// itself is included at the very least., +			paths.add(".");, +		}, +			Archive archive = new ExplodedArchive(file, false);, +			this.logger.info("Adding classpath entries from archive " + archive.getUrl(), +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/archive/ExplodedArchive.java, +					if (file.equals(this.root) || this.recursive) {, +++ b/spring-boot-tools/spring-boot-loader/src/test/java/org/springframework/boot/loader/PropertiesLauncherTests.java, +	public void testUserSpecifiedDotPath() throws Exception {, +		System.setProperty("loader.path", ".");, +		PropertiesLauncher launcher = new PropertiesLauncher();, +		assertEquals("[.]", ReflectionTestUtils.getField(launcher, "paths").toString());, +	}, +, +	@Test, +	public void testUserSpecifiedWildcardPath() throws Exception {]