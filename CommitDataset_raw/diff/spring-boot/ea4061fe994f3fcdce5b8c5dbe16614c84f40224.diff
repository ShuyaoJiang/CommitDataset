[+++ b/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/AbstractNestedCondition.java, +package org.springframework.boot.autoconfigure.condition;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import java.util.Map;, +, +import org.springframework.beans.BeanUtils;, +import org.springframework.context.annotation.Condition;, +import org.springframework.context.annotation.ConditionContext;, +import org.springframework.context.annotation.Conditional;, +import org.springframework.context.annotation.ConfigurationCondition;, +import org.springframework.core.type.AnnotatedTypeMetadata;, +import org.springframework.core.type.AnnotationMetadata;, +import org.springframework.core.type.classreading.MetadataReaderFactory;, +import org.springframework.core.type.classreading.SimpleMetadataReaderFactory;, +import org.springframework.util.Assert;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +import org.springframework.util.StringUtils;, +, +public abstract class AbstractNestedCondition extends SpringBootCondition implements, +		ConfigurationCondition {, +, +	private final ConfigurationPhase configurationPhase;, +, +	public AbstractNestedCondition(ConfigurationPhase configurationPhase) {, +		Assert.notNull(configurationPhase, "ConfigurationPhase must not be null");, +		this.configurationPhase = configurationPhase;, +	}, +, +	@Override, +	public ConfigurationPhase getConfigurationPhase() {, +		return this.configurationPhase;, +	}, +, +	@Override, +	public ConditionOutcome getMatchOutcome(ConditionContext context,, +			AnnotatedTypeMetadata metadata) {, +		MemberConditions memberConditions = new MemberConditions(context, getClass(), +				.getName());, +		List<ConditionOutcome> outcomes = memberConditions.getMatchOutcomes();, +		return buildConditionOutcome(outcomes);, +	}, +, +	protected abstract ConditionOutcome buildConditionOutcome(, +			List<ConditionOutcome> outcomes);, +, +	private static class MemberConditions {, +, +		private final ConditionContext context;, +, +		private final MetadataReaderFactory readerFactory;, +, +		private final Map<AnnotationMetadata, List<Condition>> memberConditions;, +, +		public MemberConditions(ConditionContext context, String className) {, +			this.context = context;, +			this.readerFactory = new SimpleMetadataReaderFactory(, +					context.getResourceLoader());, +			String[] members = getMetadata(className).getMemberClassNames();, +			this.memberConditions = getMemberConditions(members);, +		}, +, +		private Map<AnnotationMetadata, List<Condition>> getMemberConditions(, +				String[] members) {, +			MultiValueMap<AnnotationMetadata, Condition> memberConditions = new LinkedMultiValueMap<AnnotationMetadata, Condition>();, +			for (String member : members) {, +				AnnotationMetadata metadata = getMetadata(member);, +				for (String[] conditionClasses : getConditionClasses(metadata)) {, +					for (String conditionClass : conditionClasses) {, +						Condition condition = getCondition(conditionClass);, +						memberConditions.add(metadata, condition);, +					}, +				}, +			}, +			return Collections.unmodifiableMap(memberConditions);, +		}, +, +		private AnnotationMetadata getMetadata(String className) {, +			try {, +				return this.readerFactory.getMetadataReader(className), +						.getAnnotationMetadata();, +			}, +			catch (IOException ex) {, +				throw new IllegalStateException(ex);, +			}, +		}, +, +		@SuppressWarnings("unchecked"), +		private List<String[]> getConditionClasses(AnnotatedTypeMetadata metadata) {, +			MultiValueMap<String, Object> attributes = metadata, +					.getAllAnnotationAttributes(Conditional.class.getName(), true);, +			Object values = (attributes != null ? attributes.get("value") : null);, +			return (List<String[]>) (values != null ? values : Collections.emptyList());, +		}, +]