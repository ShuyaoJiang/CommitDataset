[+++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/ArrayBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/ArrayBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/CollectionBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/ArrayBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/CollectionBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/IndexedElementsBinder.java, +import java.lang.annotation.Annotation;, +	 * @param target the target bindable, +	protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,, +			bindIndexed(source, name, target, elementBinder, result, aggregateType,, +					elementType);, +			ConfigurationPropertyName root, Bindable<?> target,, +			AggregateElementBinder elementBinder, IndexedCollectionSupplier collection,, +			ResolvableType aggregateType, ResolvableType elementType) {, +			Object aggregate = convert(property.getValue(), aggregateType,, +					target.getAnnotations());, +	private <C> C convert(Object value, ResolvableType type, Annotation... annotations) {, +		return ResolvableTypeDescriptor.forType(type, annotations), +				.convert(conversionService, value);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/ArrayBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/CollectionBinder.java, +		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/IndexedElementsBinder.java, +import java.lang.annotation.Annotation;, +	 * @param target the target bindable, +	protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,, +			bindIndexed(source, name, target, elementBinder, result, aggregateType,, +					elementType);, +			ConfigurationPropertyName root, Bindable<?> target,, +			AggregateElementBinder elementBinder, IndexedCollectionSupplier collection,, +			ResolvableType aggregateType, ResolvableType elementType) {, +			Object aggregate = convert(property.getValue(), aggregateType,, +					target.getAnnotations());, +	private <C> C convert(Object value, ResolvableType type, Annotation... annotations) {, +		return ResolvableTypeDescriptor.forType(type, annotations), +				.convert(conversionService, value);, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/convert/BinderConversionService.java, + * Copyright 2012-2018 the original author or authors., +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import org.springframework.core.convert.support.GenericConversionService;, +	private final List<ConversionService> conversionServices;, +		List<ConversionService> conversionServices = new ArrayList<>();, +		conversionServices.add(createOverrideConversionService());, +		conversionServices.add(, +				conversionService != null ? conversionService : defaultConversionService);, +		conversionServices.add(createAdditionalConversionService());, +		this.conversionServices = Collections.unmodifiableList(conversionServices);, +	private ConversionService createOverrideConversionService() {, +		GenericConversionService service = new GenericConversionService();, +		service.addConverter(new DelimitedStringToCollectionConverter(this));, +		return service;, +	private ConversionService createAdditionalConversionService() {, +	@Override, +	public boolean canConvert(Class<?> sourceType, Class<?> targetType) {, +		for (ConversionService service : this.conversionServices) {, +			if (service.canConvert(sourceType, targetType)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	@Override, +	public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {, +		for (ConversionService service : this.conversionServices) {, +			if (service.canConvert(sourceType, targetType)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	@Override, +	public <T> T convert(Object source, Class<T> targetType) {, +		return callConversionServices((c) -> c.convert(source, targetType));, +	}, +, +	@Override, +	public Object convert(Object source, TypeDescriptor sourceType,, +			TypeDescriptor targetType) {, +		return callConversionServices((c) -> c.convert(source, sourceType, targetType));, +	}, +, +	private <T> T callConversionServices(Function<ConversionService, T> call) {, +		ConversionException exception = null;, +		for (ConversionService service : this.conversionServices) {, +			try {, +				return call.apply(service);, +			}, +			catch (ConversionException ex) {, +				exception = ex;, +			}]