[+++ b/spring-boot-test/src/main/java/org/springframework/boot/test/context/ContextLoader.java, + * Manage the lifecycle of an {@link ApplicationContext}. Such helper is best used as a, + * field of a test class, describing the shared configuration required for the test:, + * <p>, + * The initialization above makes sure to register {@code FooAutoConfiguration} for all, + * <p>, + * Based on the configuration above, a specific test can simulate what would happen if the, + * user customizes a property and/or provides its own configuration:, + * <p>, + * The test above includes an extra {@code UserConfig} class that is guaranteed to be, + * processed <strong>before</strong> any auto-configuration. Also, {@code spring.foo} has, + * been overwritten to {@code biz}. The {@link #load(ContextConsumer) load} method takes a, + * consumer that can use the context to assert its state. Upon completion, the context is, + * automatically closed., + * <p>, + * If a failure scenario has to be tested, {@link #loadAndFail(Consumer)} can be used, +	 * Set the specified system property prior to loading the context and restore its, +	 * previous value once the consumer has been invoked and the context closed. If the, +	 * {@code value} is {@code null} this removes any prior customization for that key., +	 * Add the specified property pairs. Key-value pairs can be specified with colon (":"), +	 * or equals ("=") separators. Override matching keys that might have been specified, +	 * previously., +	 * @param pairs the key-value pairs for properties that need to be added to the, +	 * is applied before any other existing auto-configurations, but after any user, +	 * configuration. If {@code A} and {@code B} are specified, {@code A} will be, +	 * processed, then {@code B} and finally the rest of the existing auto-configuration., +	 * Customize the {@link ClassLoader} that the {@link ApplicationContext} should use., +	 * Customizing the {@link ClassLoader} is an effective manner to hide resources from, +	 * the classpath., +	 * Create and refresh a new {@link ApplicationContext} based on the current state of, +	 * this loader. The context is consumed by the specified {@link ContextConsumer} and, +	 * closed upon completion., +				throw new IllegalStateException(, +						"An unexpected error occurred: " + ex.getMessage(), ex);, +	 * Create and refresh a new {@link ApplicationContext} based on the current state of, +	 * this loader that this expected to fail. If the context does not fail, an, +	 * Create and refresh a new {@link ApplicationContext} based on the current state of, +	 * this loader that this expected to fail. If the context does not fail, an, +			ctx.register(this.userConfigurations, +					.toArray(new Class<?>[this.userConfigurations.size()]));, +			LinkedHashSet<Class<?>> linkedHashSet = new LinkedHashSet<>(, +					this.autoConfigurations);, +			ctx.register(, +					linkedHashSet.toArray(new Class<?>[this.autoConfigurations.size()]));]