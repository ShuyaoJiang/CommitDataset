[+++ b/spring-bootstrap/src/main/java/org/springframework/bootstrap/context/annotation/AbstractOnBeanCondition.java, +import java.lang.reflect.Method;, +import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;, +import org.springframework.context.annotation.Bean;, +import org.springframework.context.annotation.ConfigurationCondition;, +import org.springframework.core.type.MethodMetadata;, +import org.springframework.util.ReflectionUtils;, +import org.springframework.util.ReflectionUtils.MethodCallback;, +abstract class AbstractOnBeanCondition implements ConfigurationCondition {, +	@Override, +	public ConfigurationPhase getConfigurationPhase() {, +		return ConfigurationPhase.REGISTER_BEAN;, +		MultiValueMap<String, Object> attributes = metadata.getAllAnnotationAttributes(, +				annotationClass().getName(), true);, +		final List<String> beanClasses = collect(attributes, "value");, +		final List<String> beanNames = collect(attributes, "name");, +, +		if (beanClasses.size() == 0) {, +			if (metadata instanceof MethodMetadata, +					&& metadata.isAnnotated(Bean.class.getName())) {, +				try {, +					final MethodMetadata methodMetadata = (MethodMetadata) metadata;, +					// We should be safe to load at this point since we are in the, +					// REGISTER_BEAN phase, +					Class<?> configClass = ClassUtils.forName(, +							methodMetadata.getDeclaringClassName(),, +							context.getClassLoader());, +					ReflectionUtils.doWithMethods(configClass, new MethodCallback() {, +						@Override, +						public void doWith(Method method), +								throws IllegalArgumentException, IllegalAccessException {, +							if (methodMetadata.getMethodName().equals(method.getName())) {, +								beanClasses.add(method.getReturnType().getName());, +							}, +						}, +					});, +				} catch (Exception e) {, +				}, +			}, +		}, +, +		Assert.isTrue(beanClasses.size() > 0 || beanNames.size() > 0,, +				"@" + ClassUtils.getShortName(annotationClass()), +						+ " annotations must specify at least one bean");, +, +		return matches(context, metadata, beanClasses, beanNames);, +	}, +, +	protected boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata,, +			List<String> beanClasses, List<String> beanNames) throws LinkageError {, +		Boolean considerHierarchy = (Boolean) metadata.getAnnotationAttributes(, +				annotationClass().getName()).get("considerHierarchy");, +		considerHierarchy = (considerHierarchy == null ? false : considerHierarchy);, +		for (String beanClass : beanClasses) {, +				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();, +				Class<?> type = ClassUtils.forName(beanClass, context.getClassLoader());, +				String[] beans = (considerHierarchy ? BeanFactoryUtils, +						.beanNamesForTypeIncludingAncestors(beanFactory, type, false,, +								false) : beanFactory.getBeanNamesForType(type, false,, +						false));, +		for (String beanName : beanNames) {, +			if (considerHierarchy ? context.getBeanFactory().containsBean(beanName), +					: context.getBeanFactory().containsLocalBean(beanName)) {, +			logFoundResults(checking, "class", beanClasses, beanClassesFound);, +			logFoundResults(checking, "name", beanNames, beanClassesFound);, +++ b/spring-bootstrap/src/main/java/org/springframework/bootstrap/context/annotation/AbstractOnBeanCondition.java, +import java.lang.reflect.Method;, +import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;, +import org.springframework.context.annotation.Bean;, +import org.springframework.context.annotation.ConfigurationCondition;, +import org.springframework.core.type.MethodMetadata;, +import org.springframework.util.ReflectionUtils;, +import org.springframework.util.ReflectionUtils.MethodCallback;, +abstract class AbstractOnBeanCondition implements ConfigurationCondition {, +	@Override, +	public ConfigurationPhase getConfigurationPhase() {, +		return ConfigurationPhase.REGISTER_BEAN;, +		MultiValueMap<String, Object> attributes = metadata.getAllAnnotationAttributes(, +				annotationClass().getName(), true);, +		final List<String> beanClasses = collect(attributes, "value");, +		final List<String> beanNames = collect(attributes, "name");, +, +		if (beanClasses.size() == 0) {, +			if (metadata instanceof MethodMetadata, +					&& metadata.isAnnotated(Bean.class.getName())) {, +				try {, +					final MethodMetadata methodMetadata = (MethodMetadata) metadata;, +					// We should be safe to load at this point since we are in the, +					// REGISTER_BEAN phase, +					Class<?> configClass = ClassUtils.forName(, +							methodMetadata.getDeclaringClassName(),, +							context.getClassLoader());, +					ReflectionUtils.doWithMethods(configClass, new MethodCallback() {, +						@Override, +						public void doWith(Method method), +								throws IllegalArgumentException, IllegalAccessException {, +							if (methodMetadata.getMethodName().equals(method.getName())) {, +								beanClasses.add(method.getReturnType().getName());, +							}, +						}]