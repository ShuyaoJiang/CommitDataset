[+++ b/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/autoconfigure/HealthIndicatorAutoConfigurationTests.java, +import org.springframework.context.annotation.AnnotationConfigApplicationContext;, +	public final ContextLoader<AnnotationConfigApplicationContext> contextLoader = ContextLoader, +			.standard().autoConfig(HealthIndicatorAutoConfiguration.class,, +					ManagementServerProperties.class);, +	private ContextConsumer<AnnotationConfigApplicationContext> hasSingleHealthIndicator(, +++ b/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/autoconfigure/HealthIndicatorAutoConfigurationTests.java, +import org.springframework.context.annotation.AnnotationConfigApplicationContext;, +	public final ContextLoader<AnnotationConfigApplicationContext> contextLoader = ContextLoader, +			.standard().autoConfig(HealthIndicatorAutoConfiguration.class,, +					ManagementServerProperties.class);, +	private ContextConsumer<AnnotationConfigApplicationContext> hasSingleHealthIndicator(, +++ b/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfigurationTests.java, +import org.springframework.context.annotation.AnnotationConfigApplicationContext;, +	private final ContextLoader<AnnotationConfigApplicationContext> contextLoader = ContextLoader, +			.standard().autoConfig(CacheAutoConfiguration.class);, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +						"spring.cache.couchbase.expiration=2000"), +				.load(context -> {, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + cachingProviderFqn), +				.load(context -> {, +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + cachingProviderFqn,, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + cachingProviderFqn,, +						"spring.cache.cacheNames[1]=two"), +				.load(context -> {, +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + wrongCachingProviderFqn), +				.loadAndFail(BeanCreationException.class, ex -> assertThat(, +						ex.getMessage().contains(wrongCachingProviderFqn)));, +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + cachingProviderFqn,, +						"spring.cache.jcache.config=" + configLocation), +				.load(context -> {, +				.loadAndFail(BeanCreationException.class,, +						ex -> assertThat(ex.getMessage()).contains("does not exist",, +								configLocation));, +					assertThat(cacheManager.getCacheNames()).containsOnly("cacheTest1",, +							"cacheTest2");, +					assertThat(cacheManager.getCacheNames()), +							.containsOnly("cacheOverrideTest1", "cacheOverrideTest2");, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +						"spring.cache.jcache.config=" + configLocation), +				.load(context -> {, +					// NOTE: the hazelcast implementation knows about a cache in a lazy, +					// manner., +				.config(DefaultCacheConfiguration.class), +				.env("spring.cache.type=hazelcast",, +						"spring.hazelcast.config=" + hazelcastConfig), +				.load(context -> {, +					HazelcastInstance hazelcastInstance = context, +							.getBean(HazelcastInstance.class);, +					assertThat(cacheManager.getHazelcastInstance()), +							.isSameAs(hazelcastInstance);, +							"spring.cache.cacheNames[1]=bar"), +					.load(context -> {, +						assertThat(cacheManager.getCacheNames()).containsOnly("foo",, +								"bar");, +							"spring.cache.jcache.config=" + configLocation), +					.load(context -> {, +				.config(DefaultCacheConfiguration.class), +				.env("spring.cache.type=jcache",, +						"spring.cache.jcache.provider=" + cachingProviderFqn), +				.load(context -> {, +					javax.cache.CacheManager jCacheManager = cacheManager, +							.getCacheManager();, +					assertThat(jCacheManager).isInstanceOf(, +							com.hazelcast.cache.HazelcastCacheManager.class);, +					assertThat(context.getBeansOfType(HazelcastInstance.class)), +							.hasSize(1);, +					HazelcastInstance hazelcastInstance = context, +							.getBean(HazelcastInstance.class);, +						"spring.cache.infinispan.config=infinispan.xml"), +				.load(context -> {, +					SpringEmbeddedCacheManager cacheManager = validateCacheManager(, +							context, SpringEmbeddedCacheManager.class);, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +					SpringEmbeddedCacheManager cacheManager = validateCacheManager(, +							context, SpringEmbeddedCacheManager.class);, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +					SpringEmbeddedCacheManager cacheManager = validateCacheManager(, +							context, SpringEmbeddedCacheManager.class);, +						"spring.cache.cacheNames[1]=bar"), +				.load(context -> {, +						"spring.cache.jcache.config=" + configLocation), +				.load(context -> {, +			this.contextLoader.config(JCacheWithCustomizerConfiguration.class), +					.env("spring.cache.type=jcache",]