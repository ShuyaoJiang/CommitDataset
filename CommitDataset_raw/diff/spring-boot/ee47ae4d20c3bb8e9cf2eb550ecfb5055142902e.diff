[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricsFilter.java, +		if (Series.CLIENT_ERROR.equals(series) || Series.SERVER_ERROR.equals(series), +				|| Series.REDIRECTION.equals(series)) {, +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricsFilter.java, +		if (Series.CLIENT_ERROR.equals(series) || Series.SERVER_ERROR.equals(series), +				|| Series.REDIRECTION.equals(series)) {, +++ b/spring-boot-actuator/src/test/java/org/springframework/boot/actuate/autoconfigure/MetricFilterAutoConfigurationTests.java, + * @author Stephane Nicoll, +	@Test, +	public void records5xxxHttpInteractionsAsSingleMetric() throws Exception {, +		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(, +				Config.class, MetricFilterAutoConfiguration.class,, +				ServiceUnavailableFilter.class);, +		MetricsFilter filter = context.getBean(MetricsFilter.class);, +		MockMvc mvc = MockMvcBuilders.standaloneSetup(new MetricFilterTestController()), +				.addFilter(filter), +				.addFilter(context.getBean(ServiceUnavailableFilter.class)).build();, +		mvc.perform(get("/unknownPath/1")).andExpect(status().isServiceUnavailable());, +		mvc.perform(get("/unknownPath/2")).andExpect(status().isServiceUnavailable());, +		verify(context.getBean(CounterService.class), times(2)), +				.increment("status.503.unmapped");, +		verify(context.getBean(GaugeService.class), times(2)), +				.submit(eq("response.unmapped"), anyDouble());, +		context.close();, +	}, +, +	@Component, +	@Order(0), +	public static class ServiceUnavailableFilter extends OncePerRequestFilter {, +, +		@Override, +		protected void doFilterInternal(HttpServletRequest request,, +				HttpServletResponse response, FilterChain chain), +						throws ServletException, IOException {, +, +			response.sendError(HttpStatus.SERVICE_UNAVAILABLE.value());, +		}, +, +	}, +]