[+++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/logging/LoggingApplicationListener.java, +import org.springframework.boot.context.properties.source.ConfigurationPropertyName;, +	private static final ConfigurationPropertyName LOGGING_LEVEL = ConfigurationPropertyName, +			.of("logging.level");, +, +	private static final ConfigurationPropertyName LOGGING_GROUP = ConfigurationPropertyName, +			.of("logging.group");, +, +		binder.bind(LOGGING_GROUP, STRING_STRINGS_MAP.withExistingValue(groups));, +		Map<String, String> levels = binder.bind(LOGGING_LEVEL, STRING_STRING_MAP), +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/logging/LoggingApplicationListener.java, +import org.springframework.boot.context.properties.source.ConfigurationPropertyName;, +	private static final ConfigurationPropertyName LOGGING_LEVEL = ConfigurationPropertyName, +			.of("logging.level");, +, +	private static final ConfigurationPropertyName LOGGING_GROUP = ConfigurationPropertyName, +			.of("logging.group");, +, +		binder.bind(LOGGING_GROUP, STRING_STRINGS_MAP.withExistingValue(groups));, +		Map<String, String> levels = binder.bind(LOGGING_LEVEL, STRING_STRING_MAP), +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/Binder.java, +		if (property == null && containsNoDescendantOf(context.getSources(), name)) {, +		for (ConfigurationPropertySource source : context.getSources()) {, +			ConfigurationProperty property = source.getConfigurationProperty(name);, +			if (property != null) {, +				return property;, +			}, +		}, +		return null;, +		if (containsNoDescendantOf(context.getSources(), name), +		for (ConfigurationPropertySource source : context.getSources()) {, +			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {, +		}, +	private boolean containsNoDescendantOf(Iterable<ConfigurationPropertySource> sources,, +		for (ConfigurationPropertySource source : sources) {, +			if (source.containsDescendantOf(name) != ConfigurationPropertyState.ABSENT) {, +				return false;, +			}, +		}, +		return true;, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/logging/LoggingApplicationListener.java, +import org.springframework.boot.context.properties.source.ConfigurationPropertyName;, +	private static final ConfigurationPropertyName LOGGING_LEVEL = ConfigurationPropertyName, +			.of("logging.level");, +, +	private static final ConfigurationPropertyName LOGGING_GROUP = ConfigurationPropertyName, +			.of("logging.group");, +, +		binder.bind(LOGGING_GROUP, STRING_STRINGS_MAP.withExistingValue(groups));, +		Map<String, String> levels = binder.bind(LOGGING_LEVEL, STRING_STRING_MAP), +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/Binder.java, +		if (property == null && containsNoDescendantOf(context.getSources(), name)) {, +		for (ConfigurationPropertySource source : context.getSources()) {, +			ConfigurationProperty property = source.getConfigurationProperty(name);, +			if (property != null) {, +				return property;, +			}, +		}, +		return null;, +		if (containsNoDescendantOf(context.getSources(), name), +		for (ConfigurationPropertySource source : context.getSources()) {, +			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {, +		}, +	private boolean containsNoDescendantOf(Iterable<ConfigurationPropertySource> sources,, +		for (ConfigurationPropertySource source : sources) {, +			if (source.containsDescendantOf(name) != ConfigurationPropertyState.ABSENT) {, +				return false;, +			}, +		}, +		return true;, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/JavaBeanBinder.java, +import org.springframework.boot.context.properties.source.ConfigurationPropertySource;, +		boolean hasKnownBindableProperties = hasKnownBindableProperties(name, context);, +	private boolean hasKnownBindableProperties(ConfigurationPropertyName name,, +			Context context) {, +		for (ConfigurationPropertySource source : context.getSources()) {, +			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/logging/LoggingApplicationListener.java, +import org.springframework.boot.context.properties.source.ConfigurationPropertyName;, +	private static final ConfigurationPropertyName LOGGING_LEVEL = ConfigurationPropertyName, +			.of("logging.level");, +, +	private static final ConfigurationPropertyName LOGGING_GROUP = ConfigurationPropertyName, +			.of("logging.group");, +, +		binder.bind(LOGGING_GROUP, STRING_STRINGS_MAP.withExistingValue(groups));, +		Map<String, String> levels = binder.bind(LOGGING_LEVEL, STRING_STRING_MAP), +++ b/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/Binder.java, +		if (property == null && containsNoDescendantOf(context.getSources(), name)) {, +		for (ConfigurationPropertySource source : context.getSources()) {, +			ConfigurationProperty property = source.getConfigurationProperty(name);, +			if (property != null) {, +				return property;, +			}]