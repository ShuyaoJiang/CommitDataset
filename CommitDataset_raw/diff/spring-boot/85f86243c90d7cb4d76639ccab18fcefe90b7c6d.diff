[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnClassCondition.java, +import org.springframework.util.StringUtils;, +					String candidates = autoConfigurationMetadata, +							.get(autoConfigurationClass, "ConditionalOnClass");, +		private ConditionOutcome getOutcome(String candidates) {, +				if (!candidates.contains(",")) {, +					return getOutcome(candidates, ClassNameFilter.MISSING,, +				}, +				for (String candidate : StringUtils, +						.commaDelimitedListToStringArray(candidates)) {, +					ConditionOutcome outcome = getOutcome(candidate,, +							ClassNameFilter.MISSING, this.beanClassLoader);, +					if (outcome != null) {, +						return outcome;, +					}, +		private ConditionOutcome getOutcome(String className,, +				ClassNameFilter classNameFilter, ClassLoader classLoader) {, +			if (classNameFilter.matches(className, classLoader)) {, +				return ConditionOutcome.noMatch(ConditionMessage, +						.forCondition(ConditionalOnClass.class), +						.didNotFind("required class").items(Style.QUOTE, className));, +			}, +			return null;, +		}, +, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnClassCondition.java, +import org.springframework.util.StringUtils;, +					String candidates = autoConfigurationMetadata, +							.get(autoConfigurationClass, "ConditionalOnClass");, +		private ConditionOutcome getOutcome(String candidates) {, +				if (!candidates.contains(",")) {, +					return getOutcome(candidates, ClassNameFilter.MISSING,, +				}, +				for (String candidate : StringUtils, +						.commaDelimitedListToStringArray(candidates)) {, +					ConditionOutcome outcome = getOutcome(candidate,, +							ClassNameFilter.MISSING, this.beanClassLoader);, +					if (outcome != null) {, +						return outcome;, +					}, +		private ConditionOutcome getOutcome(String className,, +				ClassNameFilter classNameFilter, ClassLoader classLoader) {, +			if (classNameFilter.matches(className, classLoader)) {, +				return ConditionOutcome.noMatch(ConditionMessage, +						.forCondition(ConditionalOnClass.class), +						.didNotFind("required class").items(Style.QUOTE, className));, +			}, +			return null;, +		}, +, +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/condition/OnClassConditionAutoConfigurationImportFilterTests.java, + * Copyright 2012-2018 the original author or authors., +		given(metadata.get("test.match", "ConditionalOnClass")), +				.willReturn("java.io.InputStream");, +		given(metadata.get("test.nomatch", "ConditionalOnClass")), +				.willReturn("java.io.DoesNotExist");, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/OnClassCondition.java, +import org.springframework.util.StringUtils;, +					String candidates = autoConfigurationMetadata, +							.get(autoConfigurationClass, "ConditionalOnClass");, +		private ConditionOutcome getOutcome(String candidates) {, +				if (!candidates.contains(",")) {, +					return getOutcome(candidates, ClassNameFilter.MISSING,, +				}, +				for (String candidate : StringUtils, +						.commaDelimitedListToStringArray(candidates)) {, +					ConditionOutcome outcome = getOutcome(candidate,, +							ClassNameFilter.MISSING, this.beanClassLoader);, +					if (outcome != null) {, +						return outcome;, +					}, +		private ConditionOutcome getOutcome(String className,, +				ClassNameFilter classNameFilter, ClassLoader classLoader) {, +			if (classNameFilter.matches(className, classLoader)) {, +				return ConditionOutcome.noMatch(ConditionMessage, +						.forCondition(ConditionalOnClass.class), +						.didNotFind("required class").items(Style.QUOTE, className));, +			}, +			return null;, +		}, +, +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/condition/OnClassConditionAutoConfigurationImportFilterTests.java, + * Copyright 2012-2018 the original author or authors., +		given(metadata.get("test.match", "ConditionalOnClass")), +				.willReturn("java.io.InputStream");, +		given(metadata.get("test.nomatch", "ConditionalOnClass")), +				.willReturn("java.io.DoesNotExist");, +++ b/spring-boot-project/spring-boot-tools/spring-boot-autoconfigure-processor/src/main/java/org/springframework/boot/autoconfigureprocessor/AutoConfigureAnnotationProcessor.java, +import java.util.Comparator;, +		attributes.put("ConditionalOnClass", new OnClassConditionValueExtractor());, +		static ValueExtractor allFrom(String... names) {, +			return new NamedValuesExtractor(names);, +	private static class NamedValuesExtractor extends AbstractValueExtractor {, +, +		private final Set<String> names;, +, +		NamedValuesExtractor(String... names) {, +			this.names = new HashSet<>(Arrays.asList(names));, +		};, +]