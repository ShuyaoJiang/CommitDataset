[+++ b/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/MetricsEndpoint.java, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.function.BiFunction;, + * @author Phillip Webb, +		Set<String> names = new LinkedHashSet<>();, +		collectNames(names, this.registry);, +		return new ListNamesResponse(names);, +	private void collectNames(Set<String> names, MeterRegistry registry) {, +			((CompositeMeterRegistry) registry).getRegistries(), +					.forEach((member) -> collectNames(names, member));, +			registry.getMeters().stream().map(this::getName).forEach(names::add);, +	private String getName(Meter meter) {, +		List<Meter> meters = new ArrayList<>();, +		collectMeters(meters, this.registry, requiredMetricName, tags);, +		Map<Statistic, Double> samples = getSamples(meters);, +		Map<String, List<String>> availableTags = getAvailableTags(meters);, +				asList(samples, MetricResponse.Sample::new),, +				asList(availableTags, MetricResponse.AvailableTag::new));, +	private void collectMeters(List<Meter> meters, MeterRegistry registry, String name,, +			Iterable<Tag> tags) {, +		if (registry instanceof CompositeMeterRegistry) {, +			((CompositeMeterRegistry) registry).getRegistries(), +					.forEach((member) -> collectMeters(meters, member, name, tags));, +		}, +		else {, +			meters.addAll(registry.find(name).tags(tags).meters());, +		}, +	}, +, +	private Map<Statistic, Double> getSamples(List<Meter> meters) {, +		Map<Statistic, Double> samples = new LinkedHashMap<>();, +		meters.forEach((meter) -> mergeMeasurements(samples, meter));, +		return samples;, +	}, +, +	private void mergeMeasurements(Map<Statistic, Double> samples, Meter meter) {, +		meter.measure().forEach((measurement) -> samples.merge(measurement.getStatistic(),, +				measurement.getValue(), Double::sum));, +	}, +, +	private Map<String, List<String>> getAvailableTags(List<Meter> meters) {, +		Map<String, List<String>> availableTags = new HashMap<>();, +		meters.forEach((meter) -> mergeAvailableTags(availableTags, meter));, +		return availableTags;, +	}, +, +	private void mergeAvailableTags(Map<String, List<String>> availableTags,, +			Meter meter) {, +		meter.getId().getTags().forEach((tag) -> {, +			List<String> value = Collections.singletonList(tag.getValue());, +			availableTags.merge(tag.getKey(), value, this::merge);, +		});, +	}, +, +	private <T> List<T> merge(List<T> list1, List<T> list2) {, +		List<T> result = new ArrayList<>(list1.size() + list2.size());, +		result.addAll(list1);, +		result.addAll(list2);, +		return result;, +	}, +, +	private <K, V, T> List<T> asList(Map<K, V> map, BiFunction<K, V, T> mapper) {, +		return map.entrySet().stream(), +				.map((entry) -> mapper.apply(entry.getKey(), entry.getValue())), +				.collect(Collectors.toCollection(ArrayList::new));, +	}, +, +, +, +++ b/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/MetricsEndpoint.java, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.function.BiFunction;, + * @author Phillip Webb, +		Set<String> names = new LinkedHashSet<>();, +		collectNames(names, this.registry);, +		return new ListNamesResponse(names);, +	private void collectNames(Set<String> names, MeterRegistry registry) {, +			((CompositeMeterRegistry) registry).getRegistries(), +					.forEach((member) -> collectNames(names, member));, +			registry.getMeters().stream().map(this::getName).forEach(names::add);, +	private String getName(Meter meter) {, +		List<Meter> meters = new ArrayList<>();, +		collectMeters(meters, this.registry, requiredMetricName, tags);, +		Map<Statistic, Double> samples = getSamples(meters);, +		Map<String, List<String>> availableTags = getAvailableTags(meters);, +				asList(samples, MetricResponse.Sample::new),, +				asList(availableTags, MetricResponse.AvailableTag::new));, +	private void collectMeters(List<Meter> meters, MeterRegistry registry, String name,, +			Iterable<Tag> tags) {, +		if (registry instanceof CompositeMeterRegistry) {, +			((CompositeMeterRegistry) registry).getRegistries(), +					.forEach((member) -> collectMeters(meters, member, name, tags));, +		}, +		else {, +			meters.addAll(registry.find(name).tags(tags).meters());, +		}, +	}, +]