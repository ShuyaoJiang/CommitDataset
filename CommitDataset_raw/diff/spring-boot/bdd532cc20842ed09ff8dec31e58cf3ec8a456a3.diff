[+++ b/spring-boot-project/spring-boot-properties-migrator/src/main/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReport.java, +import org.springframework.boot.configurationmetadata.Deprecation;, +		append(report, content, this::determineReason);, +	private String determineReason(ConfigurationMetadataProperty metadata) {, +		Deprecation deprecation = metadata.getDeprecation();, +		if (StringUtils.hasText(deprecation.getShortReason())) {, +			return deprecation.getShortReason();, +		}, +		if (StringUtils.hasText(deprecation.getReplacement())) {, +			return String.format("Reason: Replacement key '%s' uses an incompatible ", +					+ "target type", deprecation.getReplacement());, +		}, +		return "none";, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/main/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReport.java, +import org.springframework.boot.configurationmetadata.Deprecation;, +		append(report, content, this::determineReason);, +	private String determineReason(ConfigurationMetadataProperty metadata) {, +		Deprecation deprecation = metadata.getDeprecation();, +		if (StringUtils.hasText(deprecation.getShortReason())) {, +			return deprecation.getShortReason();, +		}, +		if (StringUtils.hasText(deprecation.getReplacement())) {, +			return String.format("Reason: Replacement key '%s' uses an incompatible ", +					+ "target type", deprecation.getReplacement());, +		}, +		return "none";, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/test/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReporterTests.java, +	@Test, +	public void reasonIsProvidedIfPropertyCouldNotBeRenamed() throws IOException {, +		this.environment.getPropertySources().addFirst(loadPropertySource("test",, +				"config/config-error-no-compatible-type.properties"));, +		String report = createErrorReport(, +				loadRepository("metadata/type-conversion-metadata.json"));, +		assertThat(report).isNotNull();, +		assertThat(report).containsSubsequence("Property source 'test'",, +				"wrong.inconvertible", "Line: 1", "Reason: Replacement key ", +						+ "'test.inconvertible' uses an incompatible target type");, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/main/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReport.java, +import org.springframework.boot.configurationmetadata.Deprecation;, +		append(report, content, this::determineReason);, +	private String determineReason(ConfigurationMetadataProperty metadata) {, +		Deprecation deprecation = metadata.getDeprecation();, +		if (StringUtils.hasText(deprecation.getShortReason())) {, +			return deprecation.getShortReason();, +		}, +		if (StringUtils.hasText(deprecation.getReplacement())) {, +			return String.format("Reason: Replacement key '%s' uses an incompatible ", +					+ "target type", deprecation.getReplacement());, +		}, +		return "none";, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/test/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReporterTests.java, +	@Test, +	public void reasonIsProvidedIfPropertyCouldNotBeRenamed() throws IOException {, +		this.environment.getPropertySources().addFirst(loadPropertySource("test",, +				"config/config-error-no-compatible-type.properties"));, +		String report = createErrorReport(, +				loadRepository("metadata/type-conversion-metadata.json"));, +		assertThat(report).isNotNull();, +		assertThat(report).containsSubsequence("Property source 'test'",, +				"wrong.inconvertible", "Line: 1", "Reason: Replacement key ", +						+ "'test.inconvertible' uses an incompatible target type");, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/test/resources/config/config-error-no-compatible-type.properties, +wrong.inconvertible=abc, +++ b/spring-boot-project/spring-boot-properties-migrator/src/main/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReport.java, +import org.springframework.boot.configurationmetadata.Deprecation;, +		append(report, content, this::determineReason);, +	private String determineReason(ConfigurationMetadataProperty metadata) {, +		Deprecation deprecation = metadata.getDeprecation();, +		if (StringUtils.hasText(deprecation.getShortReason())) {, +			return deprecation.getShortReason();, +		}, +		if (StringUtils.hasText(deprecation.getReplacement())) {, +			return String.format("Reason: Replacement key '%s' uses an incompatible ", +					+ "target type", deprecation.getReplacement());, +		}, +		return "none";, +	}, +, +++ b/spring-boot-project/spring-boot-properties-migrator/src/test/java/org/springframework/boot/context/properties/migrator/PropertiesMigrationReporterTests.java, +	@Test, +	public void reasonIsProvidedIfPropertyCouldNotBeRenamed() throws IOException {, +		this.environment.getPropertySources().addFirst(loadPropertySource("test",, +				"config/config-error-no-compatible-type.properties"));, +		String report = createErrorReport(, +				loadRepository("metadata/type-conversion-metadata.json"));, +		assertThat(report).isNotNull();, +		assertThat(report).containsSubsequence("Property source 'test'",, +				"wrong.inconvertible", "Line: 1", "Reason: Replacement key ", +						+ "'test.inconvertible' uses an incompatible target type");, +	}]