[+++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/repository/redis/RedisMetricRepository.java, + * as zset values plus a regular hash value for the timestamp, both against a key composed, + * of the metric name prefixed with a constant (default "spring.metrics."). If you have, + * multiple metrics repositories all point at the same instance of Redis, it may be useful, + * to change the prefix to be unique (but not if you want them to contribute to the same, + * metrics)., +++ b/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/repository/redis/RedisMetricRepository.java, + * as zset values plus a regular hash value for the timestamp, both against a key composed, + * of the metric name prefixed with a constant (default "spring.metrics."). If you have, + * multiple metrics repositories all point at the same instance of Redis, it may be useful, + * to change the prefix to be unique (but not if you want them to contribute to the same, + * metrics)., +++ b/spring-boot-docs/src/main/asciidoc/production-ready-features.adoc, +Boot provides an `InMemoryMetricRespository` and a `RedisMetricRepository` out of the, +There's nothing to stop you hooking a `MetricRepository` with back-end storage directly, +into your app, but we recommend using the default `InMemoryMetricRespository` , +(possibly with a custom `Map` instance if you are worried about heap usage) and , +populating a back-end repository through a scheduled export job. In that way you get, +some buffering in memory of the metric values and you can reduce the network, +chatter by exporting less frequently or in batches. Spring Boot provides, +an `Exporter` interface and a few basic implementations for you to get started with that.]