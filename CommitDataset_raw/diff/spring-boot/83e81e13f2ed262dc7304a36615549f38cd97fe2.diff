[+++ b/spring-boot-tools/spring-boot-configuration-processor/src/main/java/org/springframework/boot/configurationprocessor/ConfigurationMetadataAnnotationProcessor.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +	static final String ENDPOINT_ANNOTATION = "org.springframework.boot.", +			+ "endpoint.Endpoint";, +, +	protected String endpointAnnotation() {, +		return ENDPOINT_ANNOTATION;, +	}, +, +		TypeElement endpointType = elementUtils.getTypeElement(endpointAnnotation());, +		if (endpointType != null) { // Is @Endpoint available, +			for (Element element : roundEnv.getElementsAnnotatedWith(endpointType)) {, +				processEndpoint(element);, +			}, +		}, +, +	private void processEndpoint(Element element) {, +		try {, +			AnnotationMirror annotation = getAnnotation(element, endpointAnnotation());, +			if (element instanceof TypeElement) {, +				processEndpoint(annotation, (TypeElement) element);, +			}, +		}, +		catch (Exception ex) {, +			throw new IllegalStateException(, +					"Error processing configuration meta-data on " + element, ex);, +		}, +	}, +, +	private void processEndpoint(AnnotationMirror annotation, TypeElement element) {, +		Map<String, Object> elementValues = getAnnotationElementValues(annotation);, +		String endpointId = (String) elementValues.get("id");, +		if (endpointId == null || "".equals(endpointId)) {, +			return; // Can't process that endpoint, +		}, +		Boolean enabledByDefault = (Boolean) elementValues.get("enabledByDefault");, +		if (enabledByDefault == null) {, +			enabledByDefault = Boolean.TRUE;, +		}, +		String type = this.typeUtils.getQualifiedName(element);, +		this.metadataCollector.add(ItemMetadata.newGroup(endpointKey(endpointId),, +				type, type, null));, +		this.metadataCollector.add(ItemMetadata.newProperty(endpointKey(endpointId),, +				"enabled", Boolean.class.getName(), type, null, String.format(, +						"Enable the %s endpoint.", endpointId), enabledByDefault, null));, +		this.metadataCollector.add(ItemMetadata.newProperty(endpointKey(endpointId),, +				"cache.time-to-live", Long.class.getName(), type, null,, +				"Maximum time in milliseconds that a response can be cached.", 0, null));, +, +		EndpointTypes endpointTypes = EndpointTypes.parse(elementValues.get("types"));, +		if (endpointTypes.hasJmx()) {, +			this.metadataCollector.add(ItemMetadata.newProperty(, +					endpointKey(endpointId + ".jmx"), "enabled", Boolean.class.getName(),, +					type, null, String.format("Expose the %s endpoint as a JMX MBean.",, +							endpointId), enabledByDefault, null));, +		}, +		if (endpointTypes.hasWeb()) {, +			this.metadataCollector.add(ItemMetadata.newProperty(, +					endpointKey(endpointId + ".web"), "enabled", Boolean.class.getName(),, +					type, null, String.format("Expose the %s endpoint as a Web endpoint.",, +							endpointId), enabledByDefault, null));, +		}, +	}, +, +	private String endpointKey(String suffix) {, +		return "endpoints." + suffix;, +	}, +, +, +	private static class EndpointTypes {, +, +		private static final List<String> ALL_TYPES = Arrays.asList("JMX", "WEB");, +, +		private final List<String> types;, +, +		EndpointTypes(List<String> types) {, +			this.types = types;, +		}, +, +		static EndpointTypes parse(Object typesAttribute) {, +			if (typesAttribute == null || !(typesAttribute instanceof List)) {, +				return new EndpointTypes(ALL_TYPES);, +			}, +			List<AnnotationValue> values = (List<AnnotationValue>) typesAttribute;, +			if (values.isEmpty()) {, +				return new EndpointTypes(ALL_TYPES);, +			}, +			List<String> types = new ArrayList<>();, +			for (AnnotationValue value : values) {, +				types.add(((VariableElement) value.getValue()).getSimpleName().toString());, +			}, +			return new EndpointTypes(types);, +, +		}, +, +		public boolean hasJmx() {, +			return  this.types.contains("JMX");, +		}]