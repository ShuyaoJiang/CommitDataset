[+++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpProperties.java, +	private final Encoding encoding = new Encoding();, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpProperties.java, +	private final Encoding encoding = new Encoding();, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/ConcurrentKafkaListenerContainerFactoryConfigurer.java, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getConcurrency).to(factory::setConcurrency);, +		map.from(this.messageConverter).to(factory::setMessageConverter);, +		map.from(this.replyTemplate).to(factory::setReplyTemplate);, +		map.from(this.errorHandler).to(factory::setErrorHandler);, +		map.from(this.afterRollbackProcessor).to(factory::setAfterRollbackProcessor);, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getAckMode).to(container::setAckMode);, +		map.from(properties::getClientId).to(container::setClientId);, +		map.from(properties::getAckCount).to(container::setAckCount);, +		map.from(properties::getAckTime).as(Duration::toMillis).to(container::setAckTime);, +		map.from(properties::getPollTimeout).as(Duration::toMillis), +		map.from(properties::getNoPollThreshold).to(container::setNoPollThreshold);, +		map.from(properties::getIdleEventInterval).as(Duration::toMillis), +		map.from(properties::getMonitorInterval).as(Duration::getSeconds), +		map.from(properties::getLogContainerConfig).to(container::setLogContainerConfig);, +		map.from(this.transactionManager).to(container::setTransactionManager);, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpProperties.java, +	private final Encoding encoding = new Encoding();, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/ConcurrentKafkaListenerContainerFactoryConfigurer.java, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getConcurrency).to(factory::setConcurrency);, +		map.from(this.messageConverter).to(factory::setMessageConverter);, +		map.from(this.replyTemplate).to(factory::setReplyTemplate);, +		map.from(this.errorHandler).to(factory::setErrorHandler);, +		map.from(this.afterRollbackProcessor).to(factory::setAfterRollbackProcessor);, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getAckMode).to(container::setAckMode);, +		map.from(properties::getClientId).to(container::setClientId);, +		map.from(properties::getAckCount).to(container::setAckCount);, +		map.from(properties::getAckTime).as(Duration::toMillis).to(container::setAckTime);, +		map.from(properties::getPollTimeout).as(Duration::toMillis), +		map.from(properties::getNoPollThreshold).to(container::setNoPollThreshold);, +		map.from(properties::getIdleEventInterval).as(Duration::toMillis), +		map.from(properties::getMonitorInterval).as(Duration::getSeconds), +		map.from(properties::getLogContainerConfig).to(container::setLogContainerConfig);, +		map.from(this.transactionManager).to(container::setTransactionManager);, +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/condition/OnPropertyListConditionTests.java, +		this.contextRunner.withPropertyValues("spring.test.myList=value1"), +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpProperties.java, +	private final Encoding encoding = new Encoding();, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/ConcurrentKafkaListenerContainerFactoryConfigurer.java, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getConcurrency).to(factory::setConcurrency);, +		map.from(this.messageConverter).to(factory::setMessageConverter);, +		map.from(this.replyTemplate).to(factory::setReplyTemplate);, +		map.from(this.errorHandler).to(factory::setErrorHandler);, +		map.from(this.afterRollbackProcessor).to(factory::setAfterRollbackProcessor);, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getAckMode).to(container::setAckMode);, +		map.from(properties::getClientId).to(container::setClientId);, +		map.from(properties::getAckCount).to(container::setAckCount);, +		map.from(properties::getAckTime).as(Duration::toMillis).to(container::setAckTime);, +		map.from(properties::getPollTimeout).as(Duration::toMillis), +		map.from(properties::getNoPollThreshold).to(container::setNoPollThreshold);, +		map.from(properties::getIdleEventInterval).as(Duration::toMillis), +		map.from(properties::getMonitorInterval).as(Duration::getSeconds), +		map.from(properties::getLogContainerConfig).to(container::setLogContainerConfig);, +		map.from(this.transactionManager).to(container::setTransactionManager);, +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/condition/OnPropertyListConditionTests.java, +		this.contextRunner.withPropertyValues("spring.test.myList=value1"), +++ b/spring-boot-project/spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/webservices/OnWsdlLocationsConditionTests.java, +	public void wsdlLocationsNotDefined() {, +	public void wsdlLocationsDefinedAsCommaSeparated() {, +	public void wsdlLocationsDefinedAsList() {, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java, +	 * property is set to {@code true}, no pre-initialization happens and each item is, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpProperties.java, +	private final Encoding encoding = new Encoding();, +++ b/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/ConcurrentKafkaListenerContainerFactoryConfigurer.java, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getConcurrency).to(factory::setConcurrency);, +		map.from(this.messageConverter).to(factory::setMessageConverter);, +		map.from(this.replyTemplate).to(factory::setReplyTemplate);, +		map.from(this.errorHandler).to(factory::setErrorHandler);, +		map.from(this.afterRollbackProcessor).to(factory::setAfterRollbackProcessor);, +		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();, +		map.from(properties::getAckMode).to(container::setAckMode);, +		map.from(properties::getClientId).to(container::setClientId);, +		map.from(properties::getAckCount).to(container::setAckCount);, +		map.from(properties::getAckTime).as(Duration::toMillis).to(container::setAckTime);, +		map.from(properties::getPollTimeout).as(Duration::toMillis), +		map.from(properties::getNoPollThreshold).to(container::setNoPollThreshold);, +		map.from(properties::getIdleEventInterval).as(Duration::toMillis), +		map.from(properties::getMonitorInterval).as(Duration::getSeconds)]