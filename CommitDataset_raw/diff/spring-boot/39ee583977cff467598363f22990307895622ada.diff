[+++ b/spring-boot/src/main/java/org/springframework/boot/env/YamlPropertySourceLoader.java, +import java.util.LinkedHashMap;, +import java.util.Map;, +import org.springframework.beans.factory.config.YamlProcessor;, +import org.springframework.core.env.MapPropertySource;, +			Processor processor = new Processor(resource, profile);, +			Map<String, Object> source = processor.process();, +			if (!source.isEmpty()) {, +				return new MapPropertySource(name, source);, +	/**, +	 * {@link YamlProcessor} to create a {@link Map} containing the property values., +	 * Similar to {@link YamlPropertiesFactoryBean} but retains the order of entries., +	 */, +	private static class Processor extends YamlProcessor {, +, +		public Processor(Resource resource, String profile) {, +			if (profile == null) {, +				setMatchDefault(true);, +				setDocumentMatchers(new SpringProfileDocumentMatcher());, +			}, +			else {, +				setMatchDefault(false);, +				setDocumentMatchers(new SpringProfileDocumentMatcher(profile));, +			}, +			setResources(new Resource[] { resource });, +		}, +, +		public Map<String, Object> process() {, +			final Map<String, Object> result = new LinkedHashMap<String, Object>();, +			process(new MatchCallback() {, +				@Override, +				public void process(Properties properties, Map<String, Object> map) {, +					result.putAll(map);, +				}, +			});, +			return getFlattenedMap(result);, +		}, +, +	}, +, +++ b/spring-boot/src/main/java/org/springframework/boot/env/YamlPropertySourceLoader.java, +import java.util.LinkedHashMap;, +import java.util.Map;, +import org.springframework.beans.factory.config.YamlProcessor;, +import org.springframework.core.env.MapPropertySource;, +			Processor processor = new Processor(resource, profile);, +			Map<String, Object> source = processor.process();, +			if (!source.isEmpty()) {, +				return new MapPropertySource(name, source);, +	/**, +	 * {@link YamlProcessor} to create a {@link Map} containing the property values., +	 * Similar to {@link YamlPropertiesFactoryBean} but retains the order of entries., +	 */, +	private static class Processor extends YamlProcessor {, +, +		public Processor(Resource resource, String profile) {, +			if (profile == null) {, +				setMatchDefault(true);, +				setDocumentMatchers(new SpringProfileDocumentMatcher());, +			}, +			else {, +				setMatchDefault(false);, +				setDocumentMatchers(new SpringProfileDocumentMatcher(profile));, +			}, +			setResources(new Resource[] { resource });, +		}, +, +		public Map<String, Object> process() {, +			final Map<String, Object> result = new LinkedHashMap<String, Object>();, +			process(new MatchCallback() {, +				@Override, +				public void process(Properties properties, Map<String, Object> map) {, +					result.putAll(map);, +				}, +			});, +			return getFlattenedMap(result);, +		}, +, +	}, +, +++ b/spring-boot/src/test/java/org/springframework/boot/env/YamlPropertySourceLoaderTests.java, +import java.util.ArrayList;, +import java.util.List;, +, +import org.springframework.core.env.EnumerablePropertySource;, +import static org.hamcrest.Matchers.equalTo;, +import static org.junit.Assert.assertThat;, + * @author Phillip Webb, +	@Test, +	public void orderedItems() throws Exception {, +		StringBuilder yaml = new StringBuilder();, +		List<String> expected = new ArrayList<String>();, +		for (char c = 'a'; c <= 'z'; c++) {, +			yaml.append(c + ": value" + c + "\n");, +			expected.add(String.valueOf(c));, +		}, +		ByteArrayResource resource = new ByteArrayResource(yaml.toString().getBytes());, +		EnumerablePropertySource<?> source = (EnumerablePropertySource<?>) this.loader, +				.load("resource", resource, null);, +		assertNotNull(source);]