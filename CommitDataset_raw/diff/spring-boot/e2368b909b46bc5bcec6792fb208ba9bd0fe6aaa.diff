[+++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/ExecutableArchiveLauncher.java, +import java.util.jar.Manifest;, +		Manifest manifest = this.archive.getManifest();, +		String mainClass = null;, +		if (manifest != null) {, +			mainClass = manifest.getMainAttributes().getValue("Start-Class");, +		}, +		if (mainClass == null) {, +			throw new IllegalStateException(, +					"No 'Start-Class' manifest entry specified in " + this);, +		}, +		return mainClass;, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/ExecutableArchiveLauncher.java, +import java.util.jar.Manifest;, +		Manifest manifest = this.archive.getManifest();, +		String mainClass = null;, +		if (manifest != null) {, +			mainClass = manifest.getMainAttributes().getValue("Start-Class");, +		}, +		if (mainClass == null) {, +			throw new IllegalStateException(, +					"No 'Start-Class' manifest entry specified in " + this);, +		}, +		return mainClass;, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/JarLauncher.java, +	private static final String LIB = "lib/";, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/ExecutableArchiveLauncher.java, +import java.util.jar.Manifest;, +		Manifest manifest = this.archive.getManifest();, +		String mainClass = null;, +		if (manifest != null) {, +			mainClass = manifest.getMainAttributes().getValue("Start-Class");, +		}, +		if (mainClass == null) {, +			throw new IllegalStateException(, +					"No 'Start-Class' manifest entry specified in " + this);, +		}, +		return mainClass;, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/JarLauncher.java, +	private static final String LIB = "lib/";, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java, +								if (jarFile.getManifest() != null) {, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/ExecutableArchiveLauncher.java, +import java.util.jar.Manifest;, +		Manifest manifest = this.archive.getManifest();, +		String mainClass = null;, +		if (manifest != null) {, +			mainClass = manifest.getMainAttributes().getValue("Start-Class");, +		}, +		if (mainClass == null) {, +			throw new IllegalStateException(, +					"No 'Start-Class' manifest entry specified in " + this);, +		}, +		return mainClass;, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/JarLauncher.java, +	private static final String LIB = "lib/";, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java, +								if (jarFile.getManifest() != null) {, +++ b/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/PropertiesLauncher.java, +import java.net.MalformedURLException;, +import java.util.Iterator;, +	private List<String> paths = new ArrayList<String>();, +	private Archive getNestedArchive(String root) throws Exception {, +		private final String prefix;, +			this.prefix = prefix;, +, +	/**, +	 * Convenience class for finding nested archives (archive entries that can be, +	 * classpath entries)., +	 */, +	private static final class ArchiveEntryFilter implements EntryFilter {, +, +		private static final String DOT_JAR = ".jar";, +, +		private static final String DOT_ZIP = ".zip";, +, +		@Override, +		public boolean matches(Entry entry) {, +			return entry.getName().endsWith(DOT_JAR) || entry.getName().endsWith(DOT_ZIP);, +		}, +, +	}, +, +	/**, +	 * Decorator to apply an {@link Archive.EntryFilter} to an existing {@link Archive}., +	 */, +	private static class FilteredArchive implements Archive {, +, +		private final Archive parent;, +, +		private final EntryFilter filter;, +, +		FilteredArchive(Archive parent, EntryFilter filter) {, +			this.parent = parent;, +			this.filter = filter;, +		}, +, +		@Override, +		public URL getUrl() throws MalformedURLException {, +			return this.parent.getUrl();]