[+++ b/docs/src/reference/docbook/connecting.xml, +      		In <xref linkend="serviceprovider"/>, you learned how Spring Social's <emphasis>Service Provider 'Connect' Framework</emphasis> can be used to manage user connections that link your application's user accounts with accounts on external service providers., +		<title>Configuring ConnectController</title>		, +			The following class constructs a <classname>ConnectionFactoryRegistry</classname> containing <interfacename>ConnectionFactory</interfacename>s for Twitter, Facebook, and TripIt using Spring's Java configuration style: 		, +public class ConnectionFactoryConfig {, +    @Value("${twitter.consumerKey}"), +    private String twitterConsumerKey;, +	, +    @Value("${twitter.consumerSecret}"), +    private String twitterConsumerSecret;, +, +    @Value("${facebook.clientId}"), +    private String facebookClientId;, +	, +    @Value("${facebook.clientSecret}"), +    private String facebookClientSecret;, +, +    @Value("${tripit.consumerKey}"), +    private String tripItConsumerKey;, +	, +    @Value("${tripit.consumerSecret}"), +    private String tripItConsumerSecret;, +	, +			Here, three connection factories--one each for Twitter, Facebook, and TripIt--are registered with <classname>ConnectionFactoryRegistry</classname> via the <methodname>addConnectionFactory()</methodname> method. , +			Because consumer keys and secrets may be different across environments (e.g., test, production, etc) it is recommended that these values be externalized., +			<classname>ConnectController</classname> will use the <interfacename>ConnectionFactory</interfacename>s that it obtains through <classname>ConnectionFactoryLocator</classname> to perform the authorization exchange with each provider and ultimately to create a connection., +			Once a connection has been created, it must be persisted and associated with the user's account., +			The  <classname>Principal</classname> is passed to the <interfacename>UsersConnectionRepository</interfacename>'s <methodname>createConnectionRepository()</methodname> method to create a <interfacename>ConnectionRepository</interfacename> for the current user in the context of the current web request., +			Here's one configured using Spring's Java configuration style:, +			It will use the <interfacename>DataSource</interfacename> to access the RDBMS when persisting and restoring connections., +			When restoring connections, it will use the <interfacename>ConnectionFactoryLocator</interfacename> to create the Connection instances from ConnectionData., +        return Encryptors.text(password, salt);, +				This is functionally equivalent to the Java-based configuration of <classname>ConnectionFactoryRegistry</classname> shown before., +				The only casual difference is that the connection factories are injected as a list into the <code>connectionFactories</code> property rather than with the <methodname>addConnectionFactory()</methodname> method., +              factory-method="text">, +    public ConnectController connectController(@Value("${application.secureUrl}") String applicationUrl,, +            ConnectionFactoryLocator connectionFactoryLocator,, +            Provider<ConnectionRepository> connectionRepositoryProvider) {, +        return new ConnectController(applicationUrl, connectionFactoryLocator, connectionRepositoryProvider);, +    <constructor-arg value="${application.secureUrl}" />, +    <!-- relies on by-type autowiring for the other constructor-args -->, +			<classname>ConnectController</classname> supports authorization flows for either OAuth 1 or OAuth 2, relying on <interfacename>OAuth1Operations</interfacename> or <interfacename>OAuth2Operations</interfacename> to handle the specifics for each protocol., +			<classname>ConnectController</classname> will obtain the appropriate OAuth operations interface from one of the provider connection factories registered with <classname>ConnectionFactoryRegistry</classname>., +				Continuing with the Twitter example, a JSP view resolved from "connect/twitterConnect" might include the following form:, +public interface ConnectInterceptor<A> {, +	void preConnect(ConnectionFactory<A> connectionFactory, WebRequest request);, +	void postConnect(Connection<A> connection, WebRequest request);, +public ConnectController connectController(@Value("${application.secureUrl}") applicationUrl,, +        ConnectionFactoryLocator connectionFactoryLocator, , +		Provider<ConnectionRepository> connectionRepositoryProvider) {, +    ConnectController controller = new ConnectController(applicationUrl, connectionFactoryLocator, connectionRepositoryProvider);, +    <constructor-arg value="${application.secureUrl}" />]