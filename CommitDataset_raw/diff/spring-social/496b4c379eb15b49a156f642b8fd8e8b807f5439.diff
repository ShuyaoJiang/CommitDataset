[+++ b/build.gradle, +    h2Version = '1.3.156', +++ b/build.gradle, +    h2Version = '1.3.156', +++ b/docs/src/reference/docbook/connecting.xml, +        registry.addConnectionFactory(new FacebookConnectionFactory(, +            environment.getProperty("facebook.clientId"),, +        registry.addConnectionFactory(new TwitterConnectionFactory(, +            environment.getProperty("twitter.consumerKey"),, +    public ConnectionRepository connectionRepository(, +            @Value("#{request.userPrincipal}") Principal principal) {, +        return new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator(), , +                textEncryptor);, +<bean id="connectionFactoryLocator" , +      class="org.springframework.social.connect.support.ConnectionFactoryRegistry">, +<bean id="usersConnectionRepository" , +      class="org.springframework.social.connect.jdbc.JdbcUsersConnectionRepository">, +<bean id="connectionRepository" factory-method="createConnectionRepository" , +      factory-bean="usersConnectionRepository" scope="request">, +    <aop:scoped-proxy proxy-target-class="false" />, +        <bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" , +              factory-method="noOpText" />, +        <bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" , +              factory-method="text">, +        return new ConnectController(connectionFactoryLocator(), , +                connectionRepository());, +    <!-- relies on by-type autowiring for the constructor-args -->, +			When coordinating a connection with a service provider, <classname>ConnectController</classname> constructs a callback URL for the provider to redirect to after the user grants authorization., +			By default <classname>ConnectController</classname> uses information from the request to determine the protocol, host name, and port number to use when creating the callback URL., +			This is fine in many cases, but if your application is hosted behind a proxy those details may point to an internal server and will not be suitable for constructing a public callback URL., +		</para>, +		<para>, +			If you have this problem, you can set the <code>applicationUrl</code> property to the base external URL of your application., +			<classname>ConnectController</classname> will use that URL to construct the callback URL instead of using information from the request., +			For example:, +		</para>, +		<programlisting language="java"><![CDATA[, +@Configuration, +public class SocialConfig {, +, +    @Bean, +    public ConnectController connectController() {, +        ConnectController controller = new ConnectController(, +                connectionFactoryLocator(), connectionRepository());, +        controller.setApplicationUrl(environment.getProperty("application.url"));, +        return controller;, +    }, +    , +}]]>, +		</programlisting>, +		, +		<para>, +			Or if you prefer XML configuration:, +		</para>, +		<programlisting language="xml"><![CDATA[, +<bean class="org.springframework.social.connect.web.ConnectController">, +    <!-- relies on by-type autowiring for the constructor-args -->, +    <property name="applicationUrl" value="${application.url}" />, +</bean>]]>, +		</programlisting>, +		<para>, +			Just as with the authorization keys and secrets, we recommend that you externalize the application URL because it will likely vary across different deployment environments., +		</para>, +		<para>, +    <p><button type="submit"><img src="<c:url value="/resources/social/twitter/signin.png" />"/>, +    </button></p>, +    <p><button type="submit"><img src="<c:url value="/resources/social/twitter/signin.png" />"/>, +    </button></p>, +    ConnectController controller = new ConnectController(connectionFactoryLocator(), , +            connectionRepository());, +++ b/build.gradle, +    h2Version = '1.3.156', +++ b/docs/src/reference/docbook/connecting.xml, +        registry.addConnectionFactory(new FacebookConnectionFactory(, +            environment.getProperty("facebook.clientId"),, +        registry.addConnectionFactory(new TwitterConnectionFactory(, +            environment.getProperty("twitter.consumerKey"),, +    public ConnectionRepository connectionRepository(, +            @Value("#{request.userPrincipal}") Principal principal) {, +        return new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator(), , +                textEncryptor);, +<bean id="connectionFactoryLocator" , +      class="org.springframework.social.connect.support.ConnectionFactoryRegistry">, +<bean id="usersConnectionRepository" , +      class="org.springframework.social.connect.jdbc.JdbcUsersConnectionRepository">, +<bean id="connectionRepository" factory-method="createConnectionRepository" , +      factory-bean="usersConnectionRepository" scope="request">, +    <aop:scoped-proxy proxy-target-class="false" />, +        <bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" , +              factory-method="noOpText" />, +        <bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" , +              factory-method="text">, +        return new ConnectController(connectionFactoryLocator(), , +                connectionRepository());, +    <!-- relies on by-type autowiring for the constructor-args -->, +			When coordinating a connection with a service provider, <classname>ConnectController</classname> constructs a callback URL for the provider to redirect to after the user grants authorization., +			By default <classname>ConnectController</classname> uses information from the request to determine the protocol, host name, and port number to use when creating the callback URL., +			This is fine in many cases, but if your application is hosted behind a proxy those details may point to an internal server and will not be suitable for constructing a public callback URL., +		</para>, +		<para>]