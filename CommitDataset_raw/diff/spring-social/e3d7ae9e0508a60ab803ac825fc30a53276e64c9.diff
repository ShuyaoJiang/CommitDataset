[+++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/OAuth1RequestInterceptor.java, +	private final SigningUtils signingUtils;, +	, +		this.signingUtils = new SigningUtils();, +		return signingUtils.buildAuthorizationHeaderValue(request, body, consumerKey, consumerSecret, accessToken, accessTokenSecret);, +++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/OAuth1RequestInterceptor.java, +	private final SigningUtils signingUtils;, +	, +		this.signingUtils = new SigningUtils();, +		return signingUtils.buildAuthorizationHeaderValue(request, body, consumerKey, consumerSecret, accessToken, accessTokenSecret);, +++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/OAuth1Template.java, +	private final SigningUtils signingUtils;, +, +		this.signingUtils = new SigningUtils();, +		Map<String, String> oauthParameters = signingUtils.commonOAuthParameters(consumerKey);, +		return signingUtils.buildAuthorizationHeaderValue(HttpMethod.POST, tokenUrl, oauthParameters, additionalParameters, consumerSecret, tokenSecret);, +++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/OAuth1RequestInterceptor.java, +	private final SigningUtils signingUtils;, +	, +		this.signingUtils = new SigningUtils();, +		return signingUtils.buildAuthorizationHeaderValue(request, body, consumerKey, consumerSecret, accessToken, accessTokenSecret);, +++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/OAuth1Template.java, +	private final SigningUtils signingUtils;, +, +		this.signingUtils = new SigningUtils();, +		Map<String, String> oauthParameters = signingUtils.commonOAuthParameters(consumerKey);, +		return signingUtils.buildAuthorizationHeaderValue(HttpMethod.POST, tokenUrl, oauthParameters, additionalParameters, consumerSecret, tokenSecret);, +++ b/spring-social-core/src/main/java/org/springframework/social/oauth1/SigningUtils.java, +import java.util.Set;, +	private TimestampGenerator timestampGenerator;, +	, +	public SigningUtils() {, +		this.timestampGenerator = new DefaultTimestampGenerator();, +	/**, +	 * Builds the authorization header., +	 * The elements in additionalParameters should be decoded., +	 */, +	public String buildAuthorizationHeaderValue(HttpMethod method, URI targetUrl, Map<String, String> oauthParameters, MultiValueMap<String, String> additionalParameters, String consumerSecret, String tokenSecret) {, +	/**, +	 * Builds an authorization header from a request., +	 * Expects that the request's query parameters are form-encoded., +	 */, +	public String buildAuthorizationHeaderValue(HttpRequest request, byte[] body, String consumerKey, String consumerSecret, String accessToken, String accessTokenSecret) {, +		MultiValueMap<String, String> additionalParameters = combineMultiValueMaps(, +				readFormParameters(request.getHeaders().getContentType(), body), parseFormParameters(request.getURI().getRawQuery()));, +	/**, +	 * Builds an authorization header from a request., +	 * Expects that the request's query parameters are form-encoded., +	 * This method is a Spring 3.0-compatible version of buildAuthorizationHeaderValue(); planned for removal in Spring Social 1.1, +	 */, +	public String spring30buildAuthorizationHeaderValue(ClientHttpRequest request, byte[] body, String consumerKey, String consumerSecret, String accessToken, String accessTokenSecret) {, +		MultiValueMap<String, String> additionalParameters = combineMultiValueMaps(, +				readFormParameters(request.getHeaders().getContentType(), body), parseFormParameters(request.getURI().getRawQuery()));, +	, +	Map<String, String> commonOAuthParameters(String consumerKey) {, +		Map<String, String> oauthParameters = new HashMap<String, String>();, +		oauthParameters.put("oauth_consumer_key", consumerKey);, +		oauthParameters.put("oauth_signature_method", HMAC_SHA1_SIGNATURE_NAME);, +		long timestamp = timestampGenerator.generateTimestamp();, +		oauthParameters.put("oauth_timestamp", Long.toString(timestamp));, +		oauthParameters.put("oauth_nonce", Long.toString(timestampGenerator.generateNonce(timestamp)));, +		oauthParameters.put("oauth_version", "1.0");, +		return oauthParameters;, +	}, +	, +	String buildBaseString(HttpMethod method, String targetUrl, MultiValueMap<String, String> collectedParameters) {, +	private String normalizeParameters(MultiValueMap<String, String> collectedParameters) {, +				//      null should be equivalent to empty value...add the parameter with no value, +	private String calculateSignature(String baseString, String consumerSecret, String tokenSecret) {, +	private String sign(String signatureBaseString, String key) {, +	private MultiValueMap<String, String> readFormParameters(MediaType bodyType, byte[] bodyBytes) {, +	private MultiValueMap<String, String> parseFormParameters(String parameterString) {, +				result.add(formDecode(pair), "");, +	private String getBaseStringUri(URI uri) {, +	private MultiValueMap<String, String> combineMultiValueMaps(MultiValueMap<String, String> map1, MultiValueMap<String, String> map2) {, +		MultiValueMap<String, String> combinedMap = new LinkedMultiValueMap<String, String>(map1);, +		// can't use putAll here because it will overwrite anything that has the same key in both maps, +		Set<Entry<String, List<String>>> map2Entries = map2.entrySet();, +		for(Iterator<Entry<String, List<String>>> entryIt = map2Entries.iterator(); entryIt.hasNext();) {, +			Entry<String, List<String>> entry = entryIt.next();, +			String key = entry.getKey();, +			List<String> values = entry.getValue();, +			for (String value : values) {, +				combinedMap.add(key, value);, +			}, +		}, +		return combinedMap;, +	}, +	, +	private int getPort(URI uri) {, +	// testing hooks	, +	// tests can implement and inject a custom TimestampGenerator to work with fixed nonce and timestamp values, +	void setTimestampGenerator(TimestampGenerator timestampGenerator) {, +		this.timestampGenerator = timestampGenerator;, +	static interface TimestampGenerator {, +		long generateTimestamp();, +		, +		long generateNonce(long timestamp);, +	}, +	]