[+++ b/docs/src/reference/docbook/serviceprovider.xml, +, +	<section xml:id="section_serviceproviderconfig">, +		<title>Configuring Service Providers</title>, +			Working with the service provider framework starts with configuring the service provider in Spring., +			Spring Social's configuration namespace provides a convenient <code> <![CDATA[<social:service-provider>]]></code> element for declaring a service provider:, +      		<programlisting><![CDATA[, +<?xml version="1.0" encoding="UTF-8"?>, +<beans xmlns="http://www.springframework.org/schema/beans" , +    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", +    xmlns:social="http://www.springframework.org/schema/spring-social", +    xsi:schemaLocation="http://www.springframework.org/schema/spring-social http://www.springframework.org/schema/social/spring-social-1.0.xsd, +                        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">, +    <social:service-provider , +        class="org.springframework.social.twitter.connect.TwitterServiceProvider" , +        client-key="..." , +        client-secret="..." />, +</beans>]]>, +			The <code>class</code> attribute specifies the fully-qualified name of the provider implementation., +			This can be any of the service provider implementations that come with Spring Social or a custom implementation., +			Spring Social comes with the following service provider implementations:, +		<itemizedlist>, +			<listitem><para>org.springframework.social.facebook.connect.FacebookServiceProvider</para></listitem>, +			<listitem><para>org.springframework.social.twitter.connect.TwitterServiceProvider</para></listitem>, +			<listitem><para>org.springframework.social.linkedin.connect.LinkedInServiceProvider</para></listitem>, +			<listitem><para>org.springframework.social.tripit.connect.TripItServiceProvider</para></listitem>, +			<listitem><para>org.springframework.social.github.connect.GitHubServiceProvider</para></listitem>, +			<listitem><para>org.springframework.social.gowalla.connect.GowallaServiceProvider</para></listitem>, +		</itemizedlist>, +			The <code>client-key</code> and <code>client-secret</code> attributes specify the key and secret values assigned to your application when you registered it with the provider., +      <section xml:id="section_config_connectionrepository">, +          <title>Connection Repository</title>, +          , +          <para>When a service provider creates a connection, the connection details must be persisted somewhere for future use. The service provider relies on a connection repository for persistence of connection Spring Social comes with <classname>JdbcConnectionRepository</classname>, a connection repository that persists connections to a relational database via JDBC. The following XML shows how to configure a <classname>JdbcConnectionRepository</classname> bean:</para>, +          , +          <programlisting><![CDATA[<bean id="connectionRepository" class="org.springframework.social.connect.jdbc.JdbcConnectionRepository">, +    <constructor-arg ref="dataSource" />, +    <constructor-arg ref="textEncryptor" />, +</bean>]]></programlisting>, +, +          <para><classname>JdbcConnectionRepository</classname> is constructed with a reference to a <classname>DataSource</classname> through which it will communicate with the database and a <interfacename>TextEncryptor</interfacename> that it will use to encrypt/decrypt sensitive connection details (such as access tokens and secrets).</para>, +          , +          <para>The <interfacename>TextEncryptor</interfacename> is defined in Spring Security 3.1 in the <code>org.springframework.security.crypto.encrypt</code> package. Spring Security 3.1 also includes an <classname>Encryptors</classname> class which acts as a factory for common encryptor implementations. For example, to configure a no-op text encryptor (one that doesn't perform any encryption at all):</para>, +, +          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" />]]></programlisting>, +          , +          <para>Or, to configure a text encryptor that uses standard password-based encryption:</para>, +          , +          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="text">, +    <constructor-arg value="password"/>, +    <constructor-arg value="salt"/>    , +</bean>]]></programlisting>, +, +          <para>Note that the ID of the connection repository bean is significant. By default, the <code><![CDATA[<social:service-provider>]]></code> element will assume that the connection repository bean's ID is "connectionRepository". If, however, you give the connection repository bean a different ID, then you'll need to explicitly specify the connection repository when configuring a <code><![CDATA[<social:service-provider>]]></code>:</para>, +, +          <programlisting><![CDATA[<social:service-provider , +              class="org.springframework.social.twitter.connect.TwitterServiceProvider" , +              client-key="..." , +              client-secret="...", +              connection-repository="connectionStorage" />]]></programlisting>, +              , +              , +          <para><code>JdbcConnectionRepository</code> assumes that a <code>Connection</code> table exists and was created as follows:</para>, +          , +<programlisting><![CDATA[create table Connection (id identity,, +			accountId varchar not null,, +			providerId varchar not null,, +			accessToken varchar not null,					, +			secret varchar, , +			refreshToken varchar,, +			primary key (id));, +create unique index AccessToken on Connection(accountId, providerId, accessToken);]]></programlisting>, +, +          <para>For convenience sake, SQL is available in Spring Social's core module as a resource: /org/springframework/social/connect/jdbc/ConnectionRepositorySchema.sql.</para>, +  </section>, +, +  <section xml:id="section_newserviceprovider">, +      <title>Extending Spring Social with custom service providers</title>, +      , +      <para>Even though Spring Social only comes with a handful of service provider implementations, you can easily extend Spring Social's reach into other services by creating a custom service provider implementation.</para>, +      , +      <para>The first step in creating a new service provider implementation is to determine what kind of authorization the service requires. Spring Social provides abstract service provider classes for both OAuth 1 and OAuth 2-based services in <classname>AbstractOAuth1ServiceProvider</classname> and <classname>AbstractOAuth1ServiceProvider</classname>, respectively. If your service uses some authorization mechanism other than OAuth, you may choose to base your service provider on <classname>AbstractServiceProvider</classname> instead.</para>, +      , +      <para>To understand how this works, have a look at how some of the existing service provider implementations have been created. For example, consider <classname>TwitterServiceProvider</classname> as an example of how to develop an OAuth 1-based service provider:</para>, +      , +      <programlisting><![CDATA[package org.springframework.social.twitter.connect;, +public final class TwitterServiceProvider extends AbstractOAuth1ServiceProvider<TwitterOperations> {, +	protected TwitterOperations getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {, +}]]></programlisting>, +      <para>The first thing to note is that <classname>TwitterServiceProvider</classname> extends <classname>AbstractOAuth1ServiceProvider</classname>, parameterized with <interfacename>TwitterOperations</interfacename>. This indicates that <classname>TwitterServiceProvider</classname> is an OAuth 1-based provider and that its service API is a <interfacename>TwitterOperations</interfacename>.</para>, +      , +      <para><classname>TwitterServiceProvider</classname>'s constructor is given the provider's consumer key and secret along with a connection repository for persisting connection details. It calls the super constructor, passing the provider's ID, the connection repository, the consumer key and secret, and an instance of <classname>OAuth1Template</classname> that will be used to perform the authorization calls to Twitter.</para>, +      , +      <para>The <classname>OAuth1Template</classname> itself is constructed with the consumer key and secret, along with Twitter's request token URL, authorization URL, and access token URL. Note that the authorization URL is parameterized and must have a "requestToken" placeholder.</para>, +      , +      <para>In addition to the constructor, a subclass of <classname>AbstractOAuth1ServiceProvider</classname> must also override the <methodname>getApi()</methodname>. This method's job is to return an instance of the service API. In this case, it uses the consumer key and secret and the access token and secret to instantiate a <classname>TwitterTemplate</classname>.</para>, +      , +      <para>If you have a look at some of the other OAuth 1-based service providers in Spring Social, you'll see that they aren't much different than this one, aside from their ID, their OAuth 1 URLs, and their service API.</para>, +      , +      <para>Speaking of the service API, that's the one other thing you'll need to write in order to create a new service provider. In the case of <classname>TwitterServiceProvider</classname>, the service API is defined by the <interfacename>TwitterOperations</interfacename> interface and <classname>TwitterTemplate</classname> implementation of that interface.</para>]