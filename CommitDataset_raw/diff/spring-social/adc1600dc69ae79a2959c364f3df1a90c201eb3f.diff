[+++ b/docs/src/reference/docbook/connecting.xml, +<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="connecting" xmlns:xlink="http://www.w3.org/1999/xlink">, +			As <classname>ConnectController</classname> directs the overall connection flow, it depends on several other objects to do its job., +			Before getting into those, first we'll define a single Java @Configuration class where the various Spring Social objects, including ConnectController, will be configured:, +			<programlisting language="java"><![CDATA[, +@Configuration, +public class SocialConfig {, +, +}]]>, +			</programlisting>			, +			Now, <classname>ConnectController</classname> first delegates to one or more ConnectionFactory instances to establish connections to providers on behalf of users., +			Once a connection has been established, it delegates to a <interfacename>ConnectionRepository</interfacename> to persist user connection data., +		</para>, +		<para>, +			Each of the Spring Social provider modules includes a <interfacename>ConnectionFactory</interfacename> implementation:, +			<listitem><para><classname>org.springframework.social.twitter.connect.TwitterConnectionFactory</classname></para></listitem>, +			<listitem><para><classname>org.springframework.social.facebook.connect.FacebookConnectionFactory</classname></para></listitem>, +			<listitem><para><classname>org.springframework.social.linkedin.connect.LinkedInConnectionFactory</classname></para></listitem>, +			<listitem><para><classname>org.springframework.social.tripit.connect.TripItConnectionFactory</classname></para></listitem>, +			<listitem><para><classname>org.springframework.social.github.connect.GitHubConnectionFactory</classname></para></listitem>, +			<listitem><para><classname>org.springframework.social.gowalla.connect.GowallaConnectionFactory</classname></para></listitem>, +			To register one or more ConnectionFactories, simply define a ConnectionFactoryLocator @Bean as follows:, +public class SocialConfig {, +        registry.addConnectionFactory(new FacebookConnectionFactory(environment.getProperty("facebook.clientId"),, +            environment.getProperty("facebook.clientSecret")));, +        registry.addConnectionFactory(new TwitterConnectionFactory(environment.getProperty("twitter.consumerKey"),, +            environment.getProperty("twitter.consumerSecret")));, +    @Inject, +    private Environment environment;, +}]]></programlisting>, +			Above, two connection factories, one for Facebook and one for Twitter, have been registered., +			If you would like to support other providers, simply register their connection factories here., +			Because client ids and secrets may be different across environments (e.g., test, production, etc), we recommend you externalize these values., +			Therefore, when configuring a <interfacename>ConnectionRepository</interfacename> bean for use by ConnectController, it must be scoped such that it can be created on a per-user basis., +			The following Java-based configuration shows how to construct an proxy to a request-scoped <interfacename>ConnectionRepository</interfacename> instance for the currently authenticated user:, +public class SocialConfig {, +, +    @Bean, +    @Scope(value="request", proxyMode=ScopedProxyMode.INTERFACES), +    public ConnectionRepository connectionRepository(@Value("#{request.userPrincipal}") Principal principal) {, +        return usersConnectionRepository().createConnectionRepository(principal.getName());, +    }, +	, +}]]>, +		</programlisting>	, +		<para>, +			The @Bean method above is injected with a <classname>Principal</classname> representing the current user's identity., +			This is passed to UsersConnectionRepository to construct a ConnectionRepository instance for that user., +		</para>	, +		<para>, +			This means that we're also going to need to configure a <interfacename>UsersConnectionRepository</interfacename> @Bean:, +		</para>, +		<programlisting language="java"><![CDATA[, +@Configuration, +public class SocialConfig {, +, +    @Bean, +    public UsersConnectionRepository usersConnectionRepository() {, +        return new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator(), textEncryptor);, +    }, +    private DataSource dataSource;, +    @Inject, +    private TextEncryptor textEncryptor;	, +			UsersConnectionRepository is a singleton data store for connections across all users., +			<classname>JdbcUsersConnectionRepository</classname> is the RDMS-based implementation and needs a <interfacename>DataSource</interfacename>, <interfacename>ConnectionFactoryLocator</interfacename>, and <interfacename>TextEncryptor</interfacename> to do its job., +			<classname>JdbcUsersConnectionRepository</classname> uses the <interfacename>TextEncryptor</interfacename> to encrypt credentials when persisting connections., +public class SecurityConfig {, +, +    @Configuration, +    static class Dev {, +    }, +, +			Notice that the inner configuration class is annotated with <code>@Profile("dev")</code>. , +public class SecurityConfig {, +, +    @Configuration, +    @Profile("prod"), +    static class Prod {, +        public TextEncryptor textEncryptor() {, +            return Encryptors.queryableText(environment.getProperty("security.encryptPassword"),, +                environment.getProperty("security.encryptSalt"));, +        }, +, +        @Inject, +        private Environment environment;, +, +                <constructor-arg value="${facebook.clientId}" />, +                <constructor-arg value="${facebook.clientSecret}" />				, +    <aop:scoped-proxy />, +    <beans profile="prod">, +			With its dependencies configured, <classname>ConnectController</classname> now has what it needs to allow users to establish connections with registered service providers., +			Now, simply add it to your Social @Configuration:, +public class SocialConfig {, +    public ConnectController connectController() {, +        return new ConnectController(environment.getProperty("application.secureUrl"),, +            connectionFactoryLocator(), connectionRepository());, +			In either case, <classname>ConnectController</classname> should be constructed with the base "secure URL" for the application., +			It will use this URL to construct callback URLs used in the authorization flow., +			Since your application URL will typically vary between environments, its value should be externalized., +			<classname>ConnectController</classname> supports authorization flows for OAuth 1 and OAuth 2, relying on <interfacename>OAuth1Operations</interfacename> or <interfacename>OAuth2Operations</interfacename> to handle the specifics for each protocol.]