[+++ b/MPChartLib/src/com/github/mikephil/charting/renderer/PieChartRenderer.java, +    private Path mPathBuffer = new Path();, +    private RectF mInnerRectBuffer = new RectF();, +, +        final RectF circleBox = mChart.getCircleBox();, +        final int entryCount = dataSet.getEntryCount();, +        final float[] drawAngles = mChart.getDrawAngles();, +        final PointF center = mChart.getCenterCircleBox();, +        final float radius = mChart.getRadius();, +        final float innerRadius = mChart.isDrawHoleEnabled() && mChart.isHoleTransparent(), +                ? radius * (mChart.getHoleRadius() / 100.f), +                : 0.f;, +, +        // API < 21 does not receive floats in addArc, but a RectF, +        mInnerRectBuffer.set(, +                center.x - innerRadius,, +                center.y - innerRadius,, +                center.x + innerRadius,, +                center.y + innerRadius);, +, +        for (int j = 0; j < entryCount; j++) {, +            float sliceSpace = dataSet.getSliceSpace();, +            final float sliceSpaceOuterAngle = sliceSpace / (Utils.FDEG2RAD * radius);, +            final float sliceSpaceInnerAngle = sliceSpace / (Utils.FDEG2RAD * innerRadius);, +, +                    final float startAngleOuter = rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;, +                    float sweepAngleOuter = (sliceAngle - sliceSpaceOuterAngle) * phaseY;, +                    if (sweepAngleOuter < 0.f), +                    {, +                        sweepAngleOuter = 0.f;, +                    mPathBuffer.reset();, +                    mPathBuffer.moveTo(, +                            center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),, +                            center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD));, +, +                    mPathBuffer.arcTo(, +                            circleBox,, +                            startAngleOuter,, +                            sweepAngleOuter, +                    );, +, +                    if (innerRadius > 0.0), +                    {, +                        final float startAngleInner = rotationAngle + (angle + sliceSpaceInnerAngle / 2.f) * phaseY;, +                        float sweepAngleInner = (sliceAngle - sliceSpaceInnerAngle) * phaseY;, +                        if (sweepAngleInner < 0.f), +                        {, +                            sweepAngleInner = 0.f;, +                        }, +                        final float endAngleInner = startAngleInner + sweepAngleInner;, +, +                        mPathBuffer.lineTo(, +                                center.x + innerRadius * (float) Math.cos(endAngleInner * Utils.FDEG2RAD),, +                                center.y + innerRadius * (float) Math.sin(endAngleInner * Utils.FDEG2RAD));, +, +                        mPathBuffer.arcTo(, +                                mInnerRectBuffer,, +                                endAngleInner,, +                                -sweepAngleInner, +                        );, +                    }, +, +                    mPathBuffer.close();, +, +                    mBitmapCanvas.drawPath(mPathBuffer, mRenderPaint);, +                }, +                final float sliceSpace = dataSet.getSliceSpace();, +                final float sliceSpaceMiddleAngle = sliceSpace / (Utils.FDEG2RAD * r);, +                final float offset = (sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;, +            float innerRadius = mChart.isDrawHoleEnabled() && mChart.isHoleTransparent(), +        final PointF center = mChart.getCenterCircleBox();, +        final float radius = mChart.getRadius();, +        final float innerRadius = mChart.isDrawHoleEnabled() && mChart.isHoleTransparent(), +                ? radius * (mChart.getHoleRadius() / 100.f), +                : 0.f;, +, +        final RectF highlightedCircleBox = new RectF();, +            float sliceSpace = set.getSliceSpace();, +            final float sliceSpaceOuterAngle = sliceSpace / (Utils.FDEG2RAD * radius);, +            final float sliceSpaceInnerAngle = sliceSpace / (Utils.FDEG2RAD * innerRadius);, +            final float highlightedRadius = radius + shift;, +            highlightedCircleBox.set(mChart.getCircleBox());, +            highlightedCircleBox.inset(-shift, -shift);, +            final float startAngleOuter = rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;, +            float sweepAngleOuter = (sliceAngle - sliceSpaceOuterAngle) * phaseY;, +            if (sweepAngleOuter < 0.f), +            {, +                sweepAngleOuter = 0.f;, +            }, +, +            mPathBuffer.reset();, +, +            mPathBuffer.moveTo(, +                    center.x + highlightedRadius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),, +                    center.y + highlightedRadius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD));, +, +            mPathBuffer.arcTo(, +                    highlightedCircleBox,, +                    startAngleOuter,, +                    sweepAngleOuter]