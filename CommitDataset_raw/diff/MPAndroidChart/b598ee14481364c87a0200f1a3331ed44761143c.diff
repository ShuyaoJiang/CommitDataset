[+++ b/MPChartExample/src/com/xxmassdeveloper/mpchartexample/LineChartActivity1.java, +        Log.i("", "low: " + mChart.getLowestVisibleXIndex() + ", high: " + mChart.getHighestVisibleXIndex());, +++ b/MPChartExample/src/com/xxmassdeveloper/mpchartexample/LineChartActivity1.java, +        Log.i("", "low: " + mChart.getLowestVisibleXIndex() + ", high: " + mChart.getHighestVisibleXIndex());, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +import com.github.mikephil.charting.utils.ColorTemplate;, +     * if true, the hole will see-through to the inner ends of the slices, +     */, +    private boolean mDrawHoleTransparent = true;, +, +    /**, +        if (color == ColorTemplate.COLOR_NONE || color == ColorTemplate.COLOR_SKIP) {, +            color = 0; // Transparent, +        }, +     * Set the hole in the center of the PieChart transparent., +        mDrawHoleTransparent = enable;, +        return mDrawHoleTransparent;, +++ b/MPChartExample/src/com/xxmassdeveloper/mpchartexample/LineChartActivity1.java, +        Log.i("", "low: " + mChart.getLowestVisibleXIndex() + ", high: " + mChart.getHighestVisibleXIndex());, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +import com.github.mikephil.charting.utils.ColorTemplate;, +     * if true, the hole will see-through to the inner ends of the slices, +     */, +    private boolean mDrawHoleTransparent = true;, +, +    /**, +        if (color == ColorTemplate.COLOR_NONE || color == ColorTemplate.COLOR_SKIP) {, +            color = 0; // Transparent, +        }, +     * Set the hole in the center of the PieChart transparent., +        mDrawHoleTransparent = enable;, +        return mDrawHoleTransparent;, +++ b/MPChartLib/src/com/github/mikephil/charting/interfaces/dataprovider/ChartInterface.java, +++ b/MPChartExample/src/com/xxmassdeveloper/mpchartexample/LineChartActivity1.java, +        Log.i("", "low: " + mChart.getLowestVisibleXIndex() + ", high: " + mChart.getHighestVisibleXIndex());, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +import com.github.mikephil.charting.utils.ColorTemplate;, +     * if true, the hole will see-through to the inner ends of the slices, +     */, +    private boolean mDrawHoleTransparent = true;, +, +    /**, +        if (color == ColorTemplate.COLOR_NONE || color == ColorTemplate.COLOR_SKIP) {, +            color = 0; // Transparent, +        }, +     * Set the hole in the center of the PieChart transparent., +        mDrawHoleTransparent = enable;, +        return mDrawHoleTransparent;, +++ b/MPChartLib/src/com/github/mikephil/charting/interfaces/dataprovider/ChartInterface.java, +++ b/MPChartLib/src/com/github/mikephil/charting/renderer/PieChartRenderer.java, +    private Path mPathBuffer = new Path();, +    private RectF mInnerRectBuffer = new RectF();, +, +        final RectF circleBox = mChart.getCircleBox();, +        final int entryCount = dataSet.getEntryCount();, +        final float[] drawAngles = mChart.getDrawAngles();, +        float sliceSpace = dataSet.getSliceSpace();, +        final PointF center = mChart.getCenterCircleBox();, +        final float radius = mChart.getRadius();, +        final float innerRadius = mChart.isDrawHoleEnabled() && mChart.isHoleTransparent(), +                ? radius * (mChart.getHoleRadius() / 100.f), +                : 0.f;, +, +        // API < 21 does not receive floats in addArc, but a RectF, +        mInnerRectBuffer.set(, +                center.x - innerRadius,, +                center.y - innerRadius,, +                center.x + innerRadius,, +                center.y + innerRadius);, +, +        int visibleAngleCount = 0;, +        for (int j = 0; j < entryCount; j++) {, +            // draw only if the value is greater than zero, +            if ((Math.abs(dataSet.getEntryForIndex(j).getVal()) > 0.000001)) {, +                visibleAngleCount++;, +            }, +        }, +, +        for (int j = 0; j < entryCount; j++) {, +, +                    final float sliceSpaceOuterAngle = visibleAngleCount == 1 ?, +                            0.f :, +                            sliceSpace / (Utils.FDEG2RAD * radius);, +                    final float startAngleOuter = rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;, +                    float sweepAngleOuter = (sliceAngle - sliceSpaceOuterAngle) * phaseY;, +                    if (sweepAngleOuter < 0.f), +                    {, +                        sweepAngleOuter = 0.f;, +                    mPathBuffer.reset();, +                    if (sweepAngleOuter % 360f == 0.f) {, +                        // Android is doing "mod 360", +                        mPathBuffer.addCircle(center.x, center.y, radius, Path.Direction.CW);, +                    } else {, +, +                        mPathBuffer.moveTo(, +                                center.x + radius * (float) Math.cos(startAngleOuter * Utils.FDEG2RAD),, +                                center.y + radius * (float) Math.sin(startAngleOuter * Utils.FDEG2RAD));, +, +                        mPathBuffer.arcTo(, +                                circleBox,]