[+++ b/MPChartLib/src/com/github/mikephil/charting/renderer/PieChartRenderer.java, +        final boolean drawInnerArc = mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();, +        final float userInnerRadius = drawInnerArc, +                    final float sliceSpaceAngleOuter = visibleAngleCount == 1 ?, +                    final float startAngleOuter = rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;, +                    float sweepAngleOuter = (sliceAngle - sliceSpaceAngleOuter) * phaseY;, +                    if (drawInnerArc &&, +                            (innerRadius > 0.f || sliceSpace > 0.f)) {, +, +                        if (sliceSpace > 0.f) {, +                            float minSpacedRadius =, +                                    calculateMinimumRadiusForSpacedSlice(, +                                            center, radius,, +                                            sliceAngle * phaseY,, +                                            arcStartPointX, arcStartPointY,, +                                            startAngleOuter,, +                                            sweepAngleOuter);, +, +                            if (minSpacedRadius < 0.f), +                                minSpacedRadius = -minSpacedRadius;, +, +                            innerRadius = Math.max(innerRadius, minSpacedRadius);, +                        }, +, +                        final float sliceSpaceAngleInner = visibleAngleCount == 1 || innerRadius == 0.f ?, +                        final float startAngleInner = rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;, +                        float sweepAngleInner = (sliceAngle - sliceSpaceAngleInner) * phaseY;, +                            if (sliceSpace > 0.f) {, +, +                                float angleMiddle = startAngleOuter + sweepAngleOuter / 2.f;, +, +                                float sliceSpaceOffset =, +                                        calculateMinimumRadiusForSpacedSlice(, +                                                center,, +                                                radius,, +                                                sliceAngle * phaseY,, +                                                arcStartPointX,, +                                                arcStartPointY,, +                                                startAngleOuter,, +                                                sweepAngleOuter);, +, +                                float arcEndPointX = center.x +, +                                        sliceSpaceOffset * (float) Math.cos(angleMiddle * Utils.FDEG2RAD);, +                                float arcEndPointY = center.y +, +                                        sliceSpaceOffset * (float) Math.sin(angleMiddle * Utils.FDEG2RAD);, +, +                                mPathBuffer.lineTo(, +                                        arcEndPointX,, +                                        arcEndPointY);, +, +                            } else {, +                        }, +        final boolean drawInnerArc = mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();, +        final float userInnerRadius = drawInnerArc, +            final float sliceSpaceAngleOuter = visibleAngleCount == 1 ?, +                    0.f :, +                    sliceSpace / (Utils.FDEG2RAD * radius);, +, +            final float sliceSpaceAngleShifted = visibleAngleCount == 1 ?, +                    0.f :, +                    sliceSpace / (Utils.FDEG2RAD * highlightedRadius);, +, +            final float startAngleOuter = rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;, +            float sweepAngleOuter = (sliceAngle - sliceSpaceAngleOuter) * phaseY;, +            final float startAngleShifted = rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;, +            float sweepAngleShifted = (sliceAngle - sliceSpaceAngleShifted) * phaseY;, +            if (sweepAngleShifted < 0.f), +            {, +                sweepAngleShifted = 0.f;, +            }, +, +                        center.x + highlightedRadius * (float) Math.cos(startAngleShifted * Utils.FDEG2RAD),, +                        center.y + highlightedRadius * (float) Math.sin(startAngleShifted * Utils.FDEG2RAD));, +                        startAngleShifted,, +                        sweepAngleShifted, +            float sliceSpaceRadius = 0.f;, +                sliceSpaceRadius =, +                                sweepAngleOuter);, +            if (drawInnerArc &&, +                    (innerRadius > 0.f || sliceSpace > 0.f)) {, +, +                if (sliceSpace > 0.f) {, +                    float minSpacedRadius = sliceSpaceRadius;, +, +                    if (minSpacedRadius < 0.f), +                        minSpacedRadius = -minSpacedRadius;, +, +                    innerRadius = Math.max(innerRadius, minSpacedRadius);, +                }, +, +                final float sliceSpaceAngleInner = visibleAngleCount == 1 || innerRadius == 0.f ?, +                final float startAngleInner = rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;, +                float sweepAngleInner = (sliceAngle - sliceSpaceAngleInner) * phaseY;, +, +                    if (sliceSpace > 0.0) {, +                        final float angleMiddle = startAngleOuter + sweepAngleOuter / 2.f;, +, +                        final float arcEndPointX = center.x +, +                                sliceSpaceRadius * (float) Math.cos(angleMiddle * Utils.FDEG2RAD);, +                        final float arcEndPointY = center.y +]