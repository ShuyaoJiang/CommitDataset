[+++ b/MPChartLib/src/com/github/mikephil/charting/renderer/HorizontalBarChartRenderer.java, +import com.github.mikephil.charting.data.BarDataSet;, +    protected void drawDataSet(Canvas c, BarDataSet dataSet, int index) {, +, +        Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());, +, +        // the space between bar-groups, +        float space = mChart.getBarData().getGroupSpace();, +, +        boolean noStacks = dataSet.getStackSize() == 1 ? true : false;, +, +        ArrayList<BarEntry> entries = dataSet.getYVals();, +, +        // do the drawing, +        for (int j = 0; j < dataSet.getEntryCount() * mAnimator.getPhaseX(); j++) {, +, +            BarEntry e = entries.get(j);, +, +            // calculate the x-position, depending on datasetcount, +            float x = e.getXIndex() + j * (mChart.getBarData().getDataSetCount() - 1) + index, +                    + space * j + space / 2f;, +            float y = e.getVal();, +, +            // no stacks, +            if (noStacks) {, +, +                prepareBar(x, y, dataSet.getBarSpace(), trans);, +                , +                // avoid drawing outofbounds values, +                if (!mViewPortHandler.isInBoundsTop(mBarRect.bottom)), +                    break;, +, +                if (!mViewPortHandler.isInBoundsBottom(mBarRect.top)), +                    continue;, +, +                // if drawing the bar shadow is enabled, +                if (mChart.isDrawBarShadowEnabled()) {, +                    mRenderPaint.setColor(dataSet.getBarShadowColor());, +                    c.drawRect(mBarShadow, mRenderPaint);, +                }, +, +                // Set the color for the currently drawn value. If the index, +                // is, +                // out of bounds, reuse colors., +                mRenderPaint.setColor(dataSet.getColor(j));, +                c.drawRect(mBarRect, mRenderPaint);, +, +            } else { // stacked bars, +, +                float[] vals = e.getVals();, +, +                // we still draw stacked bars, but there could be one, +                // non-stacked, +                // in between, +                if (vals == null) {, +, +                    prepareBar(x, y, dataSet.getBarSpace(), trans);, +, +                    // if drawing the bar shadow is enabled, +                    if (mChart.isDrawBarShadowEnabled()) {, +                        mRenderPaint.setColor(dataSet.getBarShadowColor());, +                        c.drawRect(mBarShadow, mRenderPaint);, +                    }, +, +                    mRenderPaint.setColor(dataSet.getColor(0));, +                    c.drawRect(mBarRect, mRenderPaint);, +, +                } else {, +, +                    float all = e.getVal();, +, +                    // if drawing the bar shadow is enabled, +                    if (mChart.isDrawBarShadowEnabled()) {, +, +                        prepareBar(x, y, dataSet.getBarSpace(), trans);, +                        mRenderPaint.setColor(dataSet.getBarShadowColor());, +                        c.drawRect(mBarShadow, mRenderPaint);, +                    }, +, +                    // draw the stack, +                    for (int k = 0; k < vals.length; k++) {, +, +                        all -= vals[k];, +, +                        prepareBar(x, vals[k] + all, dataSet.getBarSpace(), trans);, +, +                        mRenderPaint.setColor(dataSet.getColor(k));, +                        c.drawRect(mBarRect, mRenderPaint);, +                    }, +                }, +                , +                // avoid drawing outofbounds values, +                if (!mViewPortHandler.isInBoundsTop(mBarRect.bottom)), +                    break;, +            }, +        }, +    }, +, +    @Override, +    public void drawValues(Canvas c) {]