[+++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 2.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 2.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieRadarChartBase.java, +                float yOffset = getRequiredBottomOffset(); // It's possible that we do not need this offset anymore as it is available through the extraOffsets, +                legendBottom = Math.min(mLegend.mNeededHeight + yOffset, mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());, +, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 2.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieRadarChartBase.java, +                float yOffset = getRequiredBottomOffset(); // It's possible that we do not need this offset anymore as it is available through the extraOffsets, +                legendBottom = Math.min(mLegend.mNeededHeight + yOffset, mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());, +, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/RadarChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 4.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 2.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieRadarChartBase.java, +                float yOffset = getRequiredBottomOffset(); // It's possible that we do not need this offset anymore as it is available through the extraOffsets, +                legendBottom = Math.min(mLegend.mNeededHeight + yOffset, mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());, +, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/RadarChart.java, +        return mLegendRenderer.getLabelPaint().getTextSize() * 4.f;, +++ b/MPChartLib/src/com/github/mikephil/charting/components/Legend.java, +import com.github.mikephil.charting.utils.FSize;, +import com.github.mikephil.charting.utils.ViewPortHandler;, +import java.util.ArrayList;, +    /// should the legend word wrap?, +    public boolean mWordWrapEnabled = false;, +, +    /// should the legend word wrap?, +    /// this is currently supported only for: BelowChartLeft, BelowChartRight, BelowChartCenter., +    /// note that word wrapping a legend takes a toll on performance., +    /// you may want to set maxSizePercent when word wrapping, to set the point where the text wraps., +    /// default: false, +    public void setWordWrapEnabled(boolean enabled) {, +        mWordWrapEnabled = enabled;, +    }, +, +    /// if this is set, then word wrapping the legend is enabled., +    public boolean isWordWrapEnabled() {, +        return mWordWrapEnabled;, +    }, +, +    private FSize[] mCalculatedLabelSizes = new FSize[]{};, +    private Boolean[] mCalculatedLabelBreakPoints = new Boolean[]{};, +    private FSize[] mCalculatedLineSizes = new FSize[]{};, +, +    public FSize[] getCalculatedLabelSizes() {, +        return mCalculatedLabelSizes;, +    }, +, +    public Boolean[] getCalculatedLabelBreakPoints() {, +        return mCalculatedLabelBreakPoints;, +    }, +, +    public FSize[] getCalculatedLineSizes() {, +        return mCalculatedLineSizes;, +    }, +, +    public void calculateDimensions(Paint labelpaint, ViewPortHandler viewPortHandler) {, +        } else if (mPosition == LegendPosition.BELOW_CHART_LEFT, +                    || mPosition == LegendPosition.BELOW_CHART_RIGHT, +                    || mPosition == LegendPosition.BELOW_CHART_CENTER) {, +, +            int labelCount = mLabels.length;, +            float labelLineHeight = - labelpaint.ascent() - labelpaint.descent();, +            float contentWidth = viewPortHandler.contentWidth();, +, +            // Prepare arrays for calculated layout, +            ArrayList<FSize> calculatedLabelSizes = new ArrayList<>(labelCount);, +            ArrayList<Boolean> calculatedLabelBreakPoints = new ArrayList<>(labelCount);, +            ArrayList<FSize> calculatedLineSizes = new ArrayList<>();, +, +            // Start calculating layout, +, +            float maxLineWidth = 0.f;, +            float currentLineWidth = 0.f;, +            float requiredWidth = 0.f;, +            int stackedStartIndex = -1;, +, +            for (int i = 0; i < labelCount; i++), +            {, +                boolean drawingForm = mColors[i] != ColorTemplate.COLOR_SKIP;, +, +                calculatedLabelBreakPoints.add(false);, +, +                if (stackedStartIndex == -1), +                {, +                    // we are not stacking, so required width is for this label only, +                    requiredWidth = 0.f;, +                }, +                else, +                {, +                    // add the spacing appropriate for stacked labels/forms, +                    requiredWidth += mStackSpace;, +                }, +, +                // grouped forms have null labels]