[+++ b/MPChartLib/src/main/java/com/github/mikephil/charting/charts/RadarChart.java, +//        if (mYAxis.isEnabled()), +//            mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum, mYAxis.mAxisMaximum, mYAxis.isInverted());, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/charts/RadarChart.java, +//        if (mYAxis.isEnabled()), +//            mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum, mYAxis.mAxisMaximum, mYAxis.isInverted());, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/renderer/AxisRenderer.java, +    /** base axis this axis renderer works with */, +    protected AxisBase mAxis;, +    /** transformer to transform values to screen pixels and return */, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/charts/RadarChart.java, +//        if (mYAxis.isEnabled()), +//            mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum, mYAxis.mAxisMaximum, mYAxis.isInverted());, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/renderer/AxisRenderer.java, +    /** base axis this axis renderer works with */, +    protected AxisBase mAxis;, +    /** transformer to transform values to screen pixels and return */, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/renderer/YAxisRendererRadarChart.java, +, +        int labelCount = mAxis.getLabelCount();, +            mAxis.mEntries = new float[]{};, +            mAxis.mEntryCount = 0;, +        // Find out how much spacing (in yPx yValue space) between axis values, +, +        // If granularity is enabled, then do not allow the interval to go below specified granularity., +        // This is used to avoid repeated values when rounding values for display., +        if (mAxis.isGranularityEnabled()), +            interval = interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;, +, +        // Normalize interval, +        double intervalMagnitude = Utils.roundToNextSignificant(Math.pow(10, (int) Math.log10(interval)));, +        boolean centeringEnabled = mAxis.isCenterAxisLabelsEnabled();, +        int n = centeringEnabled ? 1 : 0;, +, +        if (mAxis.isForceLabelsEnabled()) {, +            mAxis.mEntryCount = labelCount;, +            if (mAxis.mEntries.length < labelCount) {, +                mAxis.mEntries = new float[labelCount];, +                mAxis.mEntries[i] = v;, +            n = labelCount;, +, +            double first = interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;, +            if (centeringEnabled) {, +                first -= interval;, +            }, +            double last = interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);, +, +            if (interval != 0.0) {, +            }, +            n++;, +            mAxis.mEntryCount = n;, +            if (mAxis.mEntries.length < n) {, +                mAxis.mEntries = new float[n];, +, +                if (f == 0.0) // Fix for negative zero case (Where yValue == -0.0, and 0.0 == -0.0), +                    f = 0.0;, +, +                mAxis.mEntries[i] = (float) f;, +        // set decimals, +            mAxis.mDecimals = (int) Math.ceil(-Math.log10(interval));, +            mAxis.mDecimals = 0;, +        if (centeringEnabled) {, +, +            if (mAxis.mCenteredEntries.length < n) {, +                mAxis.mCenteredEntries = new float[n];, +            float offset = (mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;, +, +            for (int i = 0; i < n; i++) {, +                mAxis.mCenteredEntries[i] = mAxis.mEntries[i] + offset;, +            }, +        }, +, +        mAxis.mAxisMinimum = mAxis.mEntries[0];, +        mAxis.mAxisMaximum = mAxis.mEntries[n-1];, +        mAxis.mAxisRange = Math.abs(mAxis.mAxisMaximum - mAxis.mAxisMinimum);]