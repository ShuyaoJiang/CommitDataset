[+++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +import com.github.mikephil.charting.utils.ColorTemplate;, +     * if true, the hole will see-through to the inner ends of the slices, +     */, +    private boolean mDrawHoleTransparent = true;, +, +    /**, +        if (color == ColorTemplate.COLOR_NONE || color == ColorTemplate.COLOR_SKIP) {, +            color = 0; // Transparent, +        }, +     * Set the hole in the center of the PieChart transparent., +        mDrawHoleTransparent = enable;, +        return mDrawHoleTransparent;, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/PieChart.java, +import com.github.mikephil.charting.utils.ColorTemplate;, +     * if true, the hole will see-through to the inner ends of the slices, +     */, +    private boolean mDrawHoleTransparent = true;, +, +    /**, +        if (color == ColorTemplate.COLOR_NONE || color == ColorTemplate.COLOR_SKIP) {, +            color = 0; // Transparent, +        }, +     * Set the hole in the center of the PieChart transparent., +        mDrawHoleTransparent = enable;, +        return mDrawHoleTransparent;, +++ b/MPChartLib/src/com/github/mikephil/charting/renderer/PieChartRenderer.java, +            final float sliceSpaceInnerAngle = innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);, +                    else {, +                        mPathBuffer.lineTo(, +                                center.x,, +                                center.y);, +                    }, +    private Path mHoleCirclePath = new Path();, +, +            float holeRadius = radius * (mChart.getHoleRadius() / 100);, +            boolean hasHoleColor = mHolePaint.getColor() != 0;, +, +            if (hasHoleColor) {, +                // draw the hole-circle, +                mBitmapCanvas.drawCircle(, +                        center.x, center.y,, +                        holeRadius, mHolePaint);, +            }, +            if (hasHoleColor && mChart.getTransparentCircleRadius() > mChart.getHoleRadius()) {, +                float secondHoleRadius = radius * (mChart.getTransparentCircleRadius() / 100);, +, +                mHoleCirclePath.reset();, +                mHoleCirclePath.addCircle(center.x, center.y, secondHoleRadius, Path.Direction.CW);, +                mHoleCirclePath.addCircle(center.x, center.y, holeRadius, Path.Direction.CCW);, +                mBitmapCanvas.drawPath(mHoleCirclePath, mTransparentCirclePaint);, +            final float sliceSpaceInnerAngle = innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);, +            if (innerRadius > 0.0) {, +            else {, +                mPathBuffer.lineTo(, +                        center.x,, +                        center.y);, +            }]