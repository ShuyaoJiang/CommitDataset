[+++ b/MPChartLib/src/main/java/com/github/mikephil/charting/components/Legend.java, +import com.github.mikephil.charting.data.Entry;, +        /**, +         * Avoid drawing a form, +         */, +        NONE,, +, +        /**, +         * Do not draw the a form, but leave space for it, +         */, +        EMPTY,, +, +        /**, +         * Use default (default dataset's form to the legend's form), +         */, +        DEFAULT,, +, +        /**, +         * Draw a square, +         */, +        SQUARE,, +, +        /**, +         * Draw a circle, +         */, +        CIRCLE,, +, +        /**, +         * Draw a horizontal line, +         */, +        LINE, +     * The legend entries array, +    private LegendEntry[] mEntries = new LegendEntry[]{};, +     * Entries that will be appended to the end of the auto calculated entries after calculating the legend., +     * (if the legend has already been calculated, you will need to call notifyDataSetChanged() to let the changes take effect), +    private LegendEntry[] mExtraEntries;, +     * the size of the legend forms/shapes, +     */, +    private float mFormLineWidth = 3f;, +, +    /**, +        mFormLineWidth = Utils.convertDpToPixel(3f);, +     * Constructor. Provide entries for the legend., +     * @param entries, +    public Legend(LegendEntry[] entries) {, +        this();, +, +        if (entries == null) {, +            throw new IllegalArgumentException("entries array is NULL");, +        }, +, +        this.mEntries = entries;, +    }, +, +    @Deprecated, +        List<LegendEntry> entries = new ArrayList<>();, +, +        for (int i = 0; i < Math.min(colors.length, labels.length); i++) {, +            final LegendEntry entry = new LegendEntry();, +            entry.formColor = colors[i];, +            entry.label = labels[i];, +, +            if (entry.formColor == ColorTemplate.COLOR_SKIP), +                entry.form = LegendForm.NONE;, +            else if (entry.formColor == ColorTemplate.COLOR_NONE ||, +                    entry.formColor == 0), +                entry.form = LegendForm.EMPTY;, +, +            entries.add(entry);, +        mEntries = entries.toArray(new LegendEntry[entries.size()]);, +    }, +, +    @Deprecated, +        this(Utils.convertIntegers(colors), Utils.convertStrings(labels));, +     * @param entries, +    public void setEntries(List<LegendEntry> entries) {, +        mEntries = entries.toArray(new LegendEntry[entries.size()]);, +    public LegendEntry[] getEntries() {, +        return mEntries;, +        float maxFormSize = 0f;, +        for (LegendEntry entry : mEntries) {, +            final float formSize = Float.isNaN(entry.formSize), +                    ? mFormSize : entry.formSize;, +            if (formSize > maxFormSize), +                maxFormSize = formSize;, +            String label = entry.label;, +            if (label == null) continue;, +            float length = (float) Utils.calcTextWidth(p, label);, +        return max + maxFormSize + mFormToTextSpace;, +        for (LegendEntry entry : mEntries) {, +            String label = entry.label;, +            if (label == null) continue;, +            float length = (float) Utils.calcTextHeight(p, label);, +    @Deprecated, +, +        int[] old = new int[mEntries.length];, +        for (int i = 0; i < mEntries.length; i++) {, +            old[i] = mEntries[i].form == LegendForm.NONE ? ColorTemplate.COLOR_SKIP :, +                    (mEntries[i].form == LegendForm.EMPTY ? ColorTemplate.COLOR_NONE :, +                            mEntries[i].formColor);]