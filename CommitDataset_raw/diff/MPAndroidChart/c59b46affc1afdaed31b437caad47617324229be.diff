[+++ b/MPChartLib/src/main/java/com/github/mikephil/charting/data/LineDataSet.java, +    public int getCircleColorCount(){, +        return mCircleColors.size();, +    }, +, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/data/LineDataSet.java, +    public int getCircleColorCount(){, +        return mCircleColors.size();, +    }, +, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/interfaces/datasets/ILineDataSet.java, +     * Returns the number of colors in this DataSet's circle-color array., +     *, +     * @return, +     */, +    int getCircleColorCount();, +, +    /**, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/data/LineDataSet.java, +    public int getCircleColorCount(){, +        return mCircleColors.size();, +    }, +, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/interfaces/datasets/ILineDataSet.java, +     * Returns the number of colors in this DataSet's circle-color array., +     *, +     * @return, +     */, +    int getCircleColorCount();, +, +    /**, +++ b/MPChartLib/src/main/java/com/github/mikephil/charting/renderer/LineChartRenderer.java, +import com.github.mikephil.charting.interfaces.datasets.IDataSet;, +import java.util.HashMap;, +    private class DataSetImageCache {, +, +, +        private Bitmap[] circleBitmaps;, +        private int[] circleColors;, +, +        private void ensureCircleCache(int size){, +            if(circleBitmaps == null){, +                circleBitmaps = new Bitmap[size];, +            }else if(circleBitmaps.length < size){, +                Bitmap[] tmp = new Bitmap[size];, +                for(int i = 0 ; i < circleBitmaps.length ; i++){, +                    tmp[i] = circleBitmaps[size];, +                }, +                circleBitmaps = tmp;, +            }, +, +            if(circleColors == null){, +                circleColors = new int[size];, +            }else if(circleColors.length < size){, +                int[] tmp = new int[size];, +                for(int i = 0 ; i < circleColors.length ; i++){, +                    tmp[i] = circleColors[size];, +                }, +                circleColors = tmp;, +            }, +        }, +, +    }, +, +, +            if (mLineBuffer.length <= pointsPerEntryPair * 2), +                mLineBuffer = new float[pointsPerEntryPair * 4];, +    private float[] mCirclesBuffer = new float[2];, +    private HashMap<IDataSet, DataSetImageCache> mImageCaches = new HashMap<>();, +        float[] circlesBuffer = mCirclesBuffer;, +        final int dataSetCount = dataSets.size();, +        for (int i = 0; i < dataSetCount ; i++) {, +            DataSetImageCache imageCache;, +, +            if(mImageCaches.containsKey(dataSet)){, +                imageCache = mImageCaches.get(dataSet);, +            }else{, +                imageCache = new DataSetImageCache();, +                mImageCaches.put(dataSet, imageCache);, +            }, +            imageCache.ensureCircleCache(dataSet.getCircleColorCount());, +, +            int entryCount = dataSet.getEntryCount();, +            int boundsRangeCount = bounds.range + bounds.min;, +            for (int j = bounds.min; j <= boundsRangeCount; j++) {, +                final int circleColor = dataSet.getCircleColor(j);, +                mRenderPaint.setColor(circleColor);, +, +                Bitmap circleBitmap = null;, +, +                final int dataSetColorCount = imageCache.circleColors.length;, +                int colorIndex;, +                for(colorIndex = 0 ; colorIndex < dataSetColorCount ; colorIndex++) {, +                    int tempColor = imageCache.circleColors[colorIndex];, +                    Bitmap tempBitmap = imageCache.circleBitmaps[colorIndex];, +                    if(tempColor == circleColor) {, +                        circleBitmap = tempBitmap;, +                        break;, +                    }else if(tempBitmap == null){, +                        break;]