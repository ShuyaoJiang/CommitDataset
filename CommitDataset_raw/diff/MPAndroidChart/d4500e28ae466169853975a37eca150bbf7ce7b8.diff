[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/MPChartLib/src/com/github/mikephil/charting/renderer/LineChartRenderer.java, +        int minx = Math.max(dataSet.getEntryIndex(entryFrom) - diff, 0);, +        int maxx = Math.min(Math.max(minx + 2, dataSet.getEntryIndex(entryTo) + 1), entryCount);, +                    minx, size);, +    private float[] mLineBuffer = new float[4];, +, +        int diff = (entryFrom == entryTo) ? 1 : 0;, +        int minx = Math.max(dataSet.getEntryIndex(entryFrom) - diff, 0);, +        int maxx = Math.min(Math.max(minx + 2, dataSet.getEntryIndex(entryTo) + 1), entryCount);, +        final int count = (int)(Math.ceil((float)(maxx - minx) * phaseX + (float)(minx)));, +            if (mLineBuffer.length != 2 * 2), +                mLineBuffer = new float[2 * 2];, +            for (int j = minx;, +                 j < count;, +                 j++) {, +, +                if (count > 1 && j == count - 1) {, +                    // Last point, we have already drawn a line to this point, +                    break;, +                }, +, +                Entry e = dataSet.getEntryForIndex(j);, +                if (e == null) continue;, +, +                mLineBuffer[0] = e.getXIndex();, +                mLineBuffer[1] = e.getVal() * phaseY;, +, +                if (j + 1 < count) {, +, +                    e = dataSet.getEntryForIndex(j + 1);, +, +                    if (e == null) break;, +, +                    mLineBuffer[2] = e.getXIndex();, +                    mLineBuffer[3] = e.getVal() * phaseY;, +                } else {, +                    mLineBuffer[2] = mLineBuffer[0];, +                    mLineBuffer[3] = mLineBuffer[1];, +                }, +, +                trans.pointValuesToPixel(mLineBuffer);, +, +                if (!mViewPortHandler.isInBoundsRight(mLineBuffer[0])), +                if (!mViewPortHandler.isInBoundsLeft(mLineBuffer[2]), +                        || (!mViewPortHandler.isInBoundsTop(mLineBuffer[1]) && !mViewPortHandler, +                        .isInBoundsBottom(mLineBuffer[3])), +                        || (!mViewPortHandler.isInBoundsTop(mLineBuffer[1]) && !mViewPortHandler, +                        .isInBoundsBottom(mLineBuffer[3]))), +                mRenderPaint.setColor(dataSet.getColor(j));, +                canvas.drawLine(mLineBuffer[0], mLineBuffer[1],, +                        mLineBuffer[2], mLineBuffer[3], mRenderPaint);, +            if (mLineBuffer.length != Math.max((entryCount - 1) * 2, 2) * 2), +                mLineBuffer = new float[Math.max((entryCount - 1) * 2, 2) * 2];, +, +            Entry e1, e2;, +, +            e1 = dataSet.getEntryForIndex(minx);, +, +            if (e1 != null) {, +, +                for (int x = count > 1 ? minx + 1 : minx, j = 0; x < count; x++) {, +, +                    e1 = dataSet.getEntryForIndex(x == 0 ? 0 : (x - 1));, +                    e2 = dataSet.getEntryForIndex(x);, +, +                    if (e1 == null || e2 == null) continue;, +, +                    mLineBuffer[j] = e1.getXIndex();, +                    mLineBuffer[j + 1] = e1.getVal() * phaseY;, +                    mLineBuffer[j + 2] = e2.getXIndex();, +                    mLineBuffer[j + 3] = e2.getVal() * phaseY;, +                    j += 4;, +, +                }, +, +                trans.pointValuesToPixel(mLineBuffer);, +, +                final int size = Math.max((count - minx - 1) * 2, 2) * 2;, +, +                canvas.drawLines(mLineBuffer, 0, size,, +        }, +                Entry entryFrom = dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,, +                        DataSet.Rounding.DOWN);, +                int diff = (entryFrom == entryTo) ? 1 : 0;, +                int minx = Math.max(dataSet.getEntryIndex(entryFrom) - diff, 0);, +                int maxx = Math.min(Math.max(minx + 2, dataSet.getEntryIndex(entryTo) + 1), entryCount);, +        float[] circlesBuffer = new float[2];, +, +            Entry entryFrom = dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,, +                    DataSet.Rounding.DOWN);, +            int diff = (entryFrom == entryTo) ? 1 : 0;, +            int minx = Math.max(dataSet.getEntryIndex(entryFrom) - diff, 0);, +            int maxx = Math.min(Math.max(minx + 2, dataSet.getEntryIndex(entryTo) + 1), entryCount);, +            for (int j = minx,, +                 count = (int) Math.ceil((maxx - minx) * phaseX + minx);]