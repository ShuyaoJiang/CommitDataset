[+++ b/MPChartLib/src/com/github/mikephil/charting/animation/EasingFunction.java, +, +    public float getInterpolation(float input);, +++ b/MPChartLib/src/com/github/mikephil/charting/animation/EasingFunction.java, +, +    public float getInterpolation(float input);, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/BarLineChartBase.java, +        // Consider sticking one of the edges of the axis to zero (0.0), +            if (minLeft < 0.f && maxLeft < 0.f) {, +                mAxisLeft.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mAxisLeft.mAxisMaximum = 0.f;, +            else if (minLeft >= 0.0) {, +                // We have positive values only, stay in the positive zone, +                mAxisLeft.mAxisMinimum = 0.f;, +                mAxisLeft.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }, +            else {, +                // Stick the minimum to 0.0 or less, and maximum to 0.0 or more (startAtZero for negative/positive at the same time), +                mAxisLeft.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mAxisLeft.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }, +        }, +        else {, +            // Use the values as they are, +            mAxisLeft.mAxisMinimum = !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft);, +            mAxisLeft.mAxisMaximum = !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft);, +            if (minRight < 0.f && maxRight < 0.f) {, +                mAxisRight.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));, +                mAxisRight.mAxisMaximum = 0.f;, +            else if (minRight >= 0.f) {, +                // We have positive values only, stay in the positive zone, +                mAxisRight.mAxisMinimum = 0.f;, +                mAxisRight.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));, +            }, +            else {, +                // Stick the minimum to 0.0 or less, and maximum to 0.0 or more (startAtZero for negative/positive at the same time), +                mAxisRight.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));, +                mAxisRight.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));, +            }, +        }, +        else {, +            mAxisRight.mAxisMinimum = !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight);, +            mAxisRight.mAxisMaximum = !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight);, +++ b/MPChartLib/src/com/github/mikephil/charting/animation/EasingFunction.java, +, +    public float getInterpolation(float input);, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/BarLineChartBase.java, +        // Consider sticking one of the edges of the axis to zero (0.0), +            if (minLeft < 0.f && maxLeft < 0.f) {, +                mAxisLeft.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mAxisLeft.mAxisMaximum = 0.f;, +            else if (minLeft >= 0.0) {, +                // We have positive values only, stay in the positive zone, +                mAxisLeft.mAxisMinimum = 0.f;, +                mAxisLeft.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }, +            else {, +                // Stick the minimum to 0.0 or less, and maximum to 0.0 or more (startAtZero for negative/positive at the same time), +                mAxisLeft.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mAxisLeft.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }, +        }, +        else {, +            // Use the values as they are, +            mAxisLeft.mAxisMinimum = !Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft);, +            mAxisLeft.mAxisMaximum = !Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft);, +            if (minRight < 0.f && maxRight < 0.f) {, +                mAxisRight.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));, +                mAxisRight.mAxisMaximum = 0.f;, +            else if (minRight >= 0.f) {, +                // We have positive values only, stay in the positive zone, +                mAxisRight.mAxisMinimum = 0.f;, +                mAxisRight.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));, +            }, +            else {, +                // Stick the minimum to 0.0 or less, and maximum to 0.0 or more (startAtZero for negative/positive at the same time), +                mAxisRight.mAxisMinimum = Math.min(0.f, !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));, +                mAxisRight.mAxisMaximum = Math.max(0.f, !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));, +            }, +        }, +        else {, +            mAxisRight.mAxisMinimum = !Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight);, +            mAxisRight.mAxisMaximum = !Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight);, +++ b/MPChartLib/src/com/github/mikephil/charting/charts/RadarChart.java, +        if (mYAxis.isStartAtZeroEnabled()) {, +            if (minLeft < 0.f && maxLeft < 0.f) {, +                // If the values are all negative, let's stay in the negative zone, +                mYAxis.mAxisMinimum = Math.min(0.f, !Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mYAxis.mAxisMaximum = 0.f;, +            }, +            else if (minLeft >= 0.0) {, +                // We have positive values only, stay in the positive zone, +                mYAxis.mAxisMinimum = 0.f;, +                mYAxis.mAxisMaximum = Math.max(0.f, !Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }, +            else {, +                // Stick the minimum to 0.0 or less, and maximum to 0.0 or more (startAtZero for negative/positive at the same time), +                mYAxis.mAxisMinimum = Math.min(0.f, !Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));, +                mYAxis.mAxisMaximum = Math.max(0.f, !Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));, +            }]