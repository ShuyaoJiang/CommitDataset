[+++ b/src/main/java/rx/internal/operators/OperatorElementAt.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.Producer;, +    public Subscriber<? super T> call(final Subscriber<? super T> child) {, +        Subscriber<T> parent = new Subscriber<T>() {, +                if (currentIndex++ == index) {, +                    child.onNext(value);, +                    child.onCompleted();, +                    unsubscribe();, +                child.onError(e);, +                        child.onNext(defaultValue);, +                        child.onCompleted();, +                        child.onError(new IndexOutOfBoundsException(index + " is out of bounds"));, +            @Override, +            public void setProducer(Producer p) {, +                child.setProducer(new InnerProducer(p));, +            }, +        };, +        child.add(parent);, +        , +        return parent;, +    }, +    /**, +     * A producer that wraps another Producer and requests Long.MAX_VALUE, +     * when the first positive request() call comes in., +     */, +    static class InnerProducer extends AtomicBoolean implements Producer {, +        /** */, +        private static final long serialVersionUID = 1L;, +        , +        final Producer actual;, +        , +        public InnerProducer(Producer actual) {, +            this.actual = actual;, +        }, +        @Override, +        public void request(long n) {, +            if (n < 0) {, +                throw new IllegalArgumentException("n >= 0 required");, +            }, +            if (n > 0 && compareAndSet(false, true)) {, +                // trigger the fast-path since the operator is going, +                // to skip all but the indexth element, +                actual.request(Long.MAX_VALUE);, +            }, +        }, +    }]