[+++ b/src/main/java/io/reactivex/Flowable.java, +     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct, +     * based on {@link Object#equals(Object)} comparison., +     * <p>, +     * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, +     * meaningful comparison between items as the default Java implementation only considers reference equivalence., +     * <p>, +     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember, +     * previously seen items and uses {@link java.util.Set#add(Object)} returning {@code false} as the, +     * indicator for duplicates., +     * <p>, +     * Note that this internal {@code HashSet} may grow unbounded as items won't be removed from it by, +     * the operator. Therefore, using very long or infinite upstream (with very distinct elements) may lead, +     * to {@code OutOfMemoryError}., +     * <p>, +     * Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementation, +     * to the {@link #distinct(Function, Callable)} overload., +     * @see #distinct(Function), +     * @see #distinct(Function, Callable), +     * to a key selector function and based on {@link Object#equals(Object)} comparison of the objects, +     * returned by the key selector function., +     * <p>, +     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, +     * meaningful comparison between the key objects as the default Java implementation only considers reference equivalence., +     * <p>, +     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember, +     * previously seen keys and uses {@link java.util.Set#add(Object)} returning {@code false} as the, +     * indicator for duplicates., +     * <p>, +     * Note that this internal {@code HashSet} may grow unbounded as keys won't be removed from it by, +     * the operator. Therefore, using very long or infinite upstream (with very distinct keys) may lead, +     * to {@code OutOfMemoryError}., +     * <p>, +     * Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementation, +     * to the {@link #distinct(Function, Callable)} overload., +     * @see #distinct(Function, Callable), +     * to a key selector function and based on {@link Object#equals(Object)} comparison of the objects, +     * returned by the key selector function., +     * <p>, +     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, +     * meaningful comparison between the key objects as the default Java implementation only considers reference equivalence., +     * immediate predecessors based on {@link Object#equals(Object)} comparison., +     * <p>, +     * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} to provide, +     * meaningful comparison between items as the default Java implementation only considers reference equivalence., +     * Alternatively, use the {@link #distinctUntilChanged(BiPredicate)} overload and provide a comparison function, +     * in case the class {@code T} can't be overridden with custom {@code equals()} or the comparison itself, +     * should happen on different terms or properties of the class {@code T}., +     * <p>, +     * Note that the operator always retains the latest item from upstream regardless of the comparison result, +     * and uses it in the next comparison with the next upstream item., +     * @see #distinctUntilChanged(BiPredicate), +     * immediate predecessors, according to a key selector function and based on {@link Object#equals(Object)} comparison, +     * of those objects returned by the key selector function., +     * <p>, +     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} to provide, +     * meaningful comparison between the key objects as the default Java implementation only considers reference equivalence., +     * Alternatively, use the {@link #distinctUntilChanged(BiPredicate)} overload and provide a comparison function, +     * in case the class {@code K} can't be overridden with custom {@code equals()} or the comparison itself, +     * should happen on different terms or properties of the item class {@code T} (for which the keys can be, +     * derived via a similar selector)., +     * <p>, +     * Note that the operator always retains the latest key from upstream regardless of the comparison result, +     * and uses it in the next comparison with the next key derived from the next upstream item., +     * <p>, +     * Note that the operator always retains the latest item from upstream regardless of the comparison result, +     * and uses it in the next comparison with the next upstream item., +++ b/src/main/java/io/reactivex/Flowable.java, +     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct, +     * based on {@link Object#equals(Object)} comparison., +     * <p>, +     * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, +     * meaningful comparison between items as the default Java implementation only considers reference equivalence., +     * <p>, +     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember, +     * previously seen items and uses {@link java.util.Set#add(Object)} returning {@code false} as the, +     * indicator for duplicates., +     * <p>, +     * Note that this internal {@code HashSet} may grow unbounded as items won't be removed from it by, +     * the operator. Therefore, using very long or infinite upstream (with very distinct elements) may lead, +     * to {@code OutOfMemoryError}., +     * <p>, +     * Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementation, +     * to the {@link #distinct(Function, Callable)} overload., +     * @see #distinct(Function), +     * @see #distinct(Function, Callable), +     * to a key selector function and based on {@link Object#equals(Object)} comparison of the objects, +     * returned by the key selector function., +     * <p>, +     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, +     * meaningful comparison between the key objects as the default Java implementation only considers reference equivalence., +     * <p>, +     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember, +     * previously seen keys and uses {@link java.util.Set#add(Object)} returning {@code false} as the, +     * indicator for duplicates., +     * <p>, +     * Note that this internal {@code HashSet} may grow unbounded as keys won't be removed from it by, +     * the operator. Therefore, using very long or infinite upstream (with very distinct keys) may lead, +     * to {@code OutOfMemoryError}., +     * <p>]