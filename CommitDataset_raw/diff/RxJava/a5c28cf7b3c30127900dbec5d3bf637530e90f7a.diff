[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +        return create(OperationTakeWhile.takeWhile(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>(), +        {, +            public Boolean call(T t, Integer integer), +            {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +        return create(OperationTakeWhile.takeWhile(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>(), +        {, +            public Boolean call(T t, Integer integer), +            {, +++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import rx.subscriptions.Subscriptions;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static rx.testing.TrustedObservableTester.assertTrustedObservable;, +                return new Take<T>(items, num).call(observer);, +    private static class Take<T> implements Func1<Observer<T>, Subscription> {, +        private final int num;, +        private Take(Observable<T> items, int num) {, +            this.num = num;, +            if (num < 1) {, +                items.subscribe(new Observer<T>(), +                {, +                    @Override, +                    public void onCompleted(), +                    {, +                    }, +, +                    @Override, +                    public void onError(Exception e), +                    {, +                    }, +, +                    @Override, +                    public void onNext(T args), +                    {, +                    }, +                }).unsubscribe();, +                observer.onCompleted();, +                return Subscriptions.empty();, +            }, +, +                if (counter.getAndSet(num) < num) {, +            }, +                if (counter.getAndSet(num) < num) {, +            }, +                final int count = counter.incrementAndGet();, +                if (count <= num) {, +                    if (count == num) {, +                    }, +                }, +                if (count >= num) {, +            Observable<String> take = Observable.create(assertTrustedObservable(take(w, 2)));, +            Observable<String> take = Observable.create(assertTrustedObservable(take(w, 1)));, +        public void testTakeDoesntLeakErrors() {, +            Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>(), +            {, +                @Override, +                public Subscription call(Observer<String> observer), +                {, +                    observer.onNext("one");, +                    observer.onError(new Exception("test failed"));, +                    return Subscriptions.empty();, +                }, +            });, +            Observable.create(assertTrustedObservable(take(source, 1))).last();, +        }, +, +        @Test, +        public void testTakeZeroDoesntLeakError() {, +            final AtomicBoolean subscribed = new AtomicBoolean(false);, +            final AtomicBoolean unSubscribed = new AtomicBoolean(false);, +            Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>(), +            {, +                @Override, +                public Subscription call(Observer<String> observer), +                {, +                    subscribed.set(true);, +                    observer.onError(new Exception("test failed"));, +                    return new Subscription(), +                    {, +                        @Override, +                        public void unsubscribe()]