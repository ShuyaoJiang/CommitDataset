[+++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/internal/operators/OperatorAsObservable.java, +    /** Lazy initialization via inner-class holder. */, +    private static final class Holder {, +        /** A singleton instance. */, +        static final OperatorAsObservable<Object> INSTANCE = new OperatorAsObservable<Object>();, +    }, +    /**, +     * @return a singleton instance of this stateless operator., +     */, +    @SuppressWarnings("unchecked"), +    public static <T> OperatorAsObservable<T> instance() {, +        return (OperatorAsObservable<T>)Holder.INSTANCE;, +    }, +    private OperatorAsObservable() { }, +++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/internal/operators/OperatorAsObservable.java, +    /** Lazy initialization via inner-class holder. */, +    private static final class Holder {, +        /** A singleton instance. */, +        static final OperatorAsObservable<Object> INSTANCE = new OperatorAsObservable<Object>();, +    }, +    /**, +     * @return a singleton instance of this stateless operator., +     */, +    @SuppressWarnings("unchecked"), +    public static <T> OperatorAsObservable<T> instance() {, +        return (OperatorAsObservable<T>)Holder.INSTANCE;, +    }, +    private OperatorAsObservable() { }, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +    /** Lazy initialization via inner-class holder. */, +    private static final class Holder {, +        /** A singleton instance. */, +        static final OperatorConcat<Object> INSTANCE = new OperatorConcat<Object>();, +    }, +    /**, +     * @return a singleton instance of this stateless operator., +     */, +    @SuppressWarnings("unchecked"), +    public static <T> OperatorConcat<T> instance() {, +        return (OperatorConcat<T>)Holder.INSTANCE;, +    }, +    private OperatorConcat() { }, +++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/internal/operators/OperatorAsObservable.java, +    /** Lazy initialization via inner-class holder. */, +    private static final class Holder {, +        /** A singleton instance. */, +        static final OperatorAsObservable<Object> INSTANCE = new OperatorAsObservable<Object>();, +    }, +    /**, +     * @return a singleton instance of this stateless operator., +     */, +    @SuppressWarnings("unchecked")]