[+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java, +import static org.junit.Assert.*;, +import static org.mockito.Mockito.*;, +, +import java.util.Iterator;, +import java.util.concurrent.ArrayBlockingQueue;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.Callable;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, +import rx.util.functions.Func1;, +        @SuppressWarnings("serial"), +        /**, +         * Confirm that no buffering or blocking of the Observable onNext calls occurs and it just grabs the next emitted value., +         * , +         * This results in output such as => a: 1 b: 2 c: 89, +         * , +         * @throws Exception, +         */, +        @Test, +        public void testNoBufferingOrBlockingOfSequence() throws Exception {, +            final CountDownLatch finished = new CountDownLatch(1);, +            final AtomicBoolean running = new AtomicBoolean(true);, +            final AtomicInteger count = new AtomicInteger(0);, +            final Observable<Integer> obs = Observable.create(new Func1<Observer<Integer>, Subscription>() {, +, +                @Override, +                public Subscription call(final Observer<Integer> o) {, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +                            try {, +                                while (running.get()) {, +                                    o.onNext(count.incrementAndGet());, +                                    Thread.sleep(0, 100);, +                                }, +                                o.onCompleted();, +                            } catch (Exception e) {, +                                o.onError(e);, +                            } finally {, +                                finished.countDown();, +                            }, +                        }, +                    }).start();, +                    return Observable.noOpSubscription();, +                }, +, +            });, +, +            Iterator<Integer> it = next(obs).iterator();, +, +            assertTrue(it.hasNext());, +            int a = it.next();, +            assertTrue(it.hasNext());, +            int b = it.next();, +            // we should have a different value, +            assertTrue("a and b should be different", a != b);, +, +            // wait for some time, +            Thread.sleep(100);, +            // make sure the counter in the observable has increased beyond b, +            while (count.get() <= (b + 10)) {, +                Thread.sleep(100);, +            }, +, +            assertTrue(it.hasNext());, +            int expectedHigherThan = count.get();, +            int c = it.next();, +, +            assertTrue("c should not just be the next in sequence", c != (b + 1));, +            assertTrue("expected that c [" + c + "] is higher than " + expectedHigherThan, c > expectedHigherThan);, +, +            assertTrue(it.hasNext());, +, +            // shut down the thread, +            running.set(false);, +, +            finished.await();, +, +            assertFalse(it.hasNext());, +, +            System.out.println("a: " + a + " b: " + b + " c: " + c);, +        }]