[+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import rx.internal.producers.ProducerArbiter;, +import rx.observers.Subscribers;, +import rx.subjects.BehaviorSubject;, +    static final Func1<Observable<? extends Notification<?>>, Observable<?>> REDO_INFINITE = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {, +       return retry(source, REDO_INFINITE);, +        return repeat(source, REDO_INFINITE, scheduler);, +    private final Observable<T> source;, +    private final boolean stopOnComplete;, +    private final boolean stopOnError;, +        , +        // when true is a marker to say we are ready to resubscribe to source, +        , +        // use a subject to receive terminals (onCompleted and onError signals) from , +        // the source observable. We use a BehaviorSubject because subscribeToSource , +        // may emit a terminal before the restarts observable (transformed terminals) , +        // is subscribed, +        final BehaviorSubject<Notification<?>> terminals = BehaviorSubject.create();, +        final Subscriber<Notification<?>> dummySubscriber = Subscribers.empty();, +        // subscribe immediately so the last emission will be replayed to the next , +        // subscriber (which is the one we care about), +        terminals.subscribe(dummySubscriber);, +, +        final ProducerArbiter arbiter = new ProducerArbiter();, +, +                            decrementConsumerCapacity();, +                            arbiter.produced(1);, +                        }, +                    }, +, +                    private void decrementConsumerCapacity() {, +                        // use a CAS loop because we don't want to decrement the, +                        // value if it is Long.MAX_VALUE, +                        while (true) {, +                            long cc = consumerCapacity.get();, +                            if (cc != Long.MAX_VALUE) {, +                                if (consumerCapacity.compareAndSet(cc, cc - 1)) {, +                                    break;, +                                }, +                            } else {, +                                break;, +                            }, +                        arbiter.setProducer(producer);, +                                if (t.isOnCompleted() && stopOnComplete) {, +                                    filteredTerminals.onCompleted();, +                                } else if (t.isOnError() && stopOnError) {, +                                    filteredTerminals.onError(t.getThrowable());, +                                } else {, +                        if (!child.isUnsubscribed()) {, +                            // perform a best endeavours check on consumerCapacity , +                            // with the intent of only resubscribing immediately , +                            // if there is outstanding capacity, +                                // set this to true so that on next request, +                                // subscribeToSource will be scheduled, +                if (n > 0) {, +                    BackpressureUtils.getAndAddRequest(consumerCapacity, n);, +                    arbiter.request(n);, +                    if (resumeBoundary.compareAndSet(true, false)), +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import rx.internal.producers.ProducerArbiter;, +import rx.observers.Subscribers;, +import rx.subjects.BehaviorSubject;, +    static final Func1<Observable<? extends Notification<?>>, Observable<?>> REDO_INFINITE = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {, +       return retry(source, REDO_INFINITE);, +        return repeat(source, REDO_INFINITE, scheduler);, +    private final Observable<T> source;, +    private final boolean stopOnComplete;, +    private final boolean stopOnError;, +        , +        // when true is a marker to say we are ready to resubscribe to source, +        , +        // use a subject to receive terminals (onCompleted and onError signals) from , +        // the source observable. We use a BehaviorSubject because subscribeToSource , +        // may emit a terminal before the restarts observable (transformed terminals) , +        // is subscribed, +        final BehaviorSubject<Notification<?>> terminals = BehaviorSubject.create();, +        final Subscriber<Notification<?>> dummySubscriber = Subscribers.empty();, +        // subscribe immediately so the last emission will be replayed to the next , +        // subscriber (which is the one we care about), +        terminals.subscribe(dummySubscriber);, +, +        final ProducerArbiter arbiter = new ProducerArbiter();, +, +                            decrementConsumerCapacity();, +                            arbiter.produced(1);, +                        }, +                    }, +, +                    private void decrementConsumerCapacity() {, +                        // use a CAS loop because we don't want to decrement the, +                        // value if it is Long.MAX_VALUE, +                        while (true) {, +                            long cc = consumerCapacity.get();, +                            if (cc != Long.MAX_VALUE) {, +                                if (consumerCapacity.compareAndSet(cc, cc - 1)) {, +                                    break;, +                                }, +                            } else {, +                                break;, +                            }]