[+++ b/src/main/java/io/reactivex/internal/operators/PublisherFutureSource.java, +            } catch (ExecutionException ex) {, +                Throwable cause = ex.getCause();, +                if (cause != null) {, +                    s.onError(cause);, +                } else {, +                    s.onError(ex);, +                }, +                return;, +            } catch (Throwable ex) {, +            } finally {, +                future.cancel(true); // TODO ?? not sure about this, +++ b/src/main/java/io/reactivex/internal/operators/PublisherFutureSource.java, +            } catch (ExecutionException ex) {, +                Throwable cause = ex.getCause();, +                if (cause != null) {, +                    s.onError(cause);, +                } else {, +                    s.onError(ex);, +                }, +                return;, +            } catch (Throwable ex) {, +            } finally {, +                future.cancel(true); // TODO ?? not sure about this, +++ b/src/main/java/io/reactivex/internal/operators/PublisherUsing.java, +import java.util.concurrent.atomic.AtomicBoolean;, +            try {, +                disposer.accept(resource);, +            } catch (Throwable ex) {, +                e.addSuppressed(ex);, +            }, +    static final class UsingSubscriber<T, D> extends AtomicBoolean implements Subscriber<T>, Subscription {, +        /** */, +        private static final long serialVersionUID = 5904473792286235046L;, +        , +                if (compareAndSet(false, true)) {, +                }, +                , +                s.cancel();, +                s.cancel();, +                if (compareAndSet(false, true)) {, +                }, +                , +                s.cancel();, +                s.cancel();, +            s.cancel();, +            if (compareAndSet(false, true)) {, +}, +++ b/src/main/java/io/reactivex/internal/operators/PublisherFutureSource.java, +            } catch (ExecutionException ex) {, +                Throwable cause = ex.getCause();, +                if (cause != null) {, +                    s.onError(cause);, +                } else {, +                    s.onError(ex);, +                }, +                return;, +            } catch (Throwable ex) {, +            } finally {, +                future.cancel(true); // TODO ?? not sure about this, +++ b/src/main/java/io/reactivex/internal/operators/PublisherUsing.java, +import java.util.concurrent.atomic.AtomicBoolean;, +            try {, +                disposer.accept(resource);, +            } catch (Throwable ex) {, +                e.addSuppressed(ex);, +            }, +    static final class UsingSubscriber<T, D> extends AtomicBoolean implements Subscriber<T>, Subscription {, +        /** */, +        private static final long serialVersionUID = 5904473792286235046L;, +        , +                if (compareAndSet(false, true)) {, +                }, +                , +                s.cancel();, +                s.cancel();, +                if (compareAndSet(false, true)) {, +                }, +                , +                s.cancel();, +                s.cancel();, +            s.cancel();, +            if (compareAndSet(false, true)) {, +}, +++ b/src/main/java/io/reactivex/observables/BlockingObservable.java, +                        resource.dispose();, +                    resource.dispose();, +                    resource.dispose();, +++ b/src/main/java/io/reactivex/internal/operators/PublisherFutureSource.java, +            } catch (ExecutionException ex) {, +                Throwable cause = ex.getCause();, +                if (cause != null) {, +                    s.onError(cause);, +                } else {, +                    s.onError(ex);, +                }, +                return;, +            } catch (Throwable ex) {, +            } finally {, +                future.cancel(true); // TODO ?? not sure about this]