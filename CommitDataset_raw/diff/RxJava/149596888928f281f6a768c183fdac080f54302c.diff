[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  /**, +   * Returns an Observable that emits the items emitted by two or more Observables, one after the, +   * other., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">, +   *, +   * @return an Observable that emits items that are the result of combining the items emitted by, +   *         the source Observables, one after the other, +   */, +  def concat[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.concat[U](o4), +    Observable[U](o5), +  }, +  def replay: (() => Subscription, Observable[T]) = {, +  // Naming: We follow C# (switch), not Java (switchOnNext), because Java just had to avoid clash with keyword, +   * Observable by using this method., +  def flatten[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +   * Returns an Observable that counts the total number of elements in the source Observable., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">, +   *, +   * @return an Observable emitting the number of counted elements of the source Observable, +   *         as its single item., +   */, +  def length: Observable[Int] = {, +    Observable[Integer](asJava.count()).map(_.intValue()), +  }, +, +  /**, +   * Retry subscription to origin Observable upto given retry count., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png">, +   * <p>, +   * If {@link Observer#onError} is invoked the source Observable will be re-subscribed to as many times as defined by retryCount., +   * <p>, +   * Any {@link Observer#onNext} calls received on each attempt will be emitted and concatenated together., +   * <p>, +   * For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and, +   * emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted]., +   *, +   * @param retryCount, +   *            Number of retry attempts before failing., +   * @return Observable with retry logic., +   */, +  def retry(retryCount: Int): Observable[T] = {, +    Observable[T](asJava.retry(retryCount)), +  }, +, +  /**, +   * Retry subscription to origin Observable whenever onError is called (infinite retry count)., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png">, +   * <p>, +   * If {@link Observer#onError} is invoked the source Observable will be re-subscribed to., +   * <p>, +   * Any {@link Observer#onNext} calls received on each attempt will be emitted and concatenated together., +   * <p>, +   * For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and, +   * emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted]., +   * @return Observable with retry logic., +   */, +  def retry: Observable[T] = {, +    Observable[T](asJava.retry()), +  }, +  , +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  /**, +   * Returns an Observable that emits the items emitted by two or more Observables, one after the, +   * other., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">, +   *, +   * @return an Observable that emits items that are the result of combining the items emitted by, +   *         the source Observables, one after the other, +   */, +  def concat[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.concat[U](o4), +    Observable[U](o5), +  }, +  def replay: (() => Subscription, Observable[T]) = {, +  // Naming: We follow C# (switch), not Java (switchOnNext), because Java just had to avoid clash with keyword, +   * Observable by using this method., +  def flatten[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +   * Returns an Observable that counts the total number of elements in the source Observable., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">, +   *, +   * @return an Observable emitting the number of counted elements of the source Observable, +   *         as its single item., +   */, +  def length: Observable[Int] = {, +    Observable[Integer](asJava.count()).map(_.intValue())]