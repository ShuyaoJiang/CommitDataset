[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.List;, +import java.util.Set;, +    /**, +     * Combines the two given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 The first source observable., +     * @param w1 The second source observable., +     * @param combineLatestFunction The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +     */, +    /**, +     * @see #combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineLatestFunction), +     */, +    /**, +     * @see #combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineLatestFunction), +     */, +            a.error(e);, +        public void onNext(T args) {, +     * Receive notifications from each of the observables we are reducing and execute the combineLatestFunction , +     * whenever we have received an event from one of the observables, as soon as each Observable has received , +     * at least one event., +        private Observer<R> observer;, +, +        private final AtomicBoolean running = new AtomicBoolean(true);, +, +        // used as an internal lock for handling the latest values and the completed state of each observer, +        private final Object lockObject = new Object();, +         * Store when an observer completes., +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Set<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();, +, +        /**, +         * The latest value from each observer, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Map<CombineObserver<R, ?>, Object> latestValue = new HashMap<CombineObserver<R, ?>, Object>();, +        , +        /**, +         * Whether each observer has a latest value at all., +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Set<CombineObserver<R, ?>> hasLatestValue = new HashSet<CombineObserver<R, ?>>();, +, +        /**, +         * Ordered list of observers to combine., +         * No synchronization is necessary as these can not be added or changed asynchronously., +        private final List<CombineObserver<R, ?>> observers = new LinkedList<CombineObserver<R, ?>>();, +         * @param w The observer to add., +        <T> void addObserver(CombineObserver<R, T> w) {, +            observers.add(w);, +         * @param w The observer that has completed., +        <T> void complete(CombineObserver<R, T> w) {, +            synchronized(lockObject) {, +                // store that this CombineLatestObserver is completed, +                if (completed.size() == observers.size()) {, +                        observer.onCompleted();, +        }, +        void error(Exception e) {, +            observer.onError(e);, +            /* tell all observers to unsubscribe since we had an error */, +         * Receive the next value from an observer., +         * If we have received values from all observers, trigger the combineLatest function, otherwise store the value and keep waiting., +        <T> void next(CombineObserver<R, T> w, T arg) {, +            if (observer == null) {, +                throw new RuntimeException("This shouldn't be running if an Observer isn't registered");, +            Object[] argsToCombineLatest = new Object[observers.size()];, +            // we synchronize everything that touches latest values, +            synchronized (lockObject) {, +                // remember this as the latest value for this observer, +                latestValue.put(w, arg);, +                // remember that this observer now has a latest value set, +                hasLatestValue.add(w);, +, +                // if all observers in the 'observers' list have a value, invoke the combineLatestFunction, +                for (CombineObserver<R, ?> rw : observers) {, +                    if (!hasLatestValue.contains(rw)) {, +                        // we don't have a value yet for each observer to combine, so we don't have a combined value yet either, +                // if we get to here this means all the queues have data, +                for (CombineObserver<R, ?> _w : observers) {, +                    argsToCombineLatest[i++] = latestValue.get(_w);, +            observer.onNext(combineLatestFunction.call(argsToCombineLatest));, +        public Subscription call(Observer<R> observer) {, +            if (this.observer != null) {, +            this.observer = observer;, +            /* start the observers */, +            for (CombineObserver<R, ?> rw : observers) {, +            /* propogate to all observers to unsubscribe */]