[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def toSortedList() {, +    assertEquals(Seq(7, 8, 9, 10), Observable(10, 7, 8, 9).toSeq.map(_.sorted).toBlockingObservable.single), +    val f = (a: Int, b: Int) => b < a, +    assertEquals(Seq(10, 9, 8, 7), Observable(10, 7, 8, 9).toSeq.map(_.sortWith(f)).toBlockingObservable.single), +  }, +  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def toSortedList() {, +    assertEquals(Seq(7, 8, 9, 10), Observable(10, 7, 8, 9).toSeq.map(_.sorted).toBlockingObservable.single), +    val f = (a: Int, b: Int) => b < a, +    assertEquals(Seq(10, 9, 8, 7), Observable(10, 7, 8, 9).toSeq.map(_.sortWith(f)).toBlockingObservable.single), +  }, +  , +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +import java.util.Date, +import java.util.Calendar, +  val averageProblem = "[We can't have a general average method because Scala's `Numeric` does not have " +, +     "scalar multiplication (we would need to calculate `(1.0/numberOfElements)*sum`). " + , +     "You can use `fold` instead to accumulate `sum` and `numberOfElements` and divide at the end.]", +  val commentForFirstWithPredicate = "[use `.filter(condition).first`]", +      "firstOrDefault(Func1[_ >: T, Boolean], T)" -> "[use `.filter(condition).firstOrElse(default)`]",, +      "groupBy(Func1[_ >: T, _ <: K], Func1[_ >: T, _ <: R])" -> "[use `groupBy` and `map`]",, +      "mapWithIndex(Func2[_ >: T, Integer, _ <: R])" -> "[combine `zipWithIndex` with `map` or with a for comprehension]",, +      "startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",, +      "toSortedList()" -> "[Sorting is already done in Scala's collection library, use `.toSeq.map(_.sorted)`]",, +      "toSortedList(Func2[_ >: T, _ >: T, Integer])" -> "[Sorting is already done in Scala's collection library, use `.toSeq.map(_.sortWith(f))`]",, +      "sequenceEqual(Observable[_ <: T], Observable[_ <: T])" -> "[use `(first zip second) map (p => p._1 == p._2)`]",, +      "sequenceEqual(Observable[_ <: T], Observable[_ <: T], Func2[_ >: T, _ >: T, Boolean])" -> "[use `(first zip second) map (p => equality(p._1, p._2))`]",, +      "zip(Observable[_ <: T1], Observable[_ <: T2], Func2[_ >: T1, _ >: T2, _ <: R])" -> "[use instance method `zip` and `map`]",, +      "zip(Observable[_ <: Observable[_]], FuncN[_ <: R])" -> "[use `zip` in companion object and `map`]",, +      "zip(Iterable[_ <: Observable[_]], FuncN[_ <: R])" -> "[use `zip` in companion object and `map`]", +      "startWith(" + _ + ")" -> "[unnecessary because we can just use `++` instead]", +      "concat(" + _ + ")" -> "[unnecessary because we can use `++` instead or `Observable(o1, o2, ...).concat`]", +      "merge(" + _ + ")" -> "[unnecessary because we can use `Observable(o1, o2, ...).flatten` instead]", +      "mergeDelayError(" + _ + ")" -> "[unnecessary because we can use `Observable(o1, o2, ...).flattenDelayError` instead]", +  def setTodoForMissingMethods(corresp: Map[String, String]): Map[String, String] = {, +    val actualMethods = getPublicInstanceAndCompanionMethods(typeOf[rx.lang.scala.Observable[_]]).toSet, +    for ((javaM, scalaM) <- corresp) yield, +      (javaM, if (actualMethods.contains(scalaM) || scalaM.charAt(0) == '[') scalaM else "[**TODO: missing**]"), +  }, +   , +  def scalaToJavaSignature(s: String) = , +    s.replaceAllLiterally("_ <:", "? extends"), +     .replaceAllLiterally("_ >:", "? super"), +     .replaceAllLiterally("[", "<"), +     .replaceAllLiterally("]", ">"), +     .replaceAllLiterally("Array<T>", "T[]"), +  , +  def escapeJava(s: String) =, +    s.replaceAllLiterally("<", "&lt;"), +     .replaceAllLiterally(">", "&gt;"), +    , +  @Test def printMarkdownCorrespondenceTable() {, +    def isInteresting(p: (String, String)): Boolean =, +      p._1.replaceAllLiterally("()", "") != p._2, +    def groupingKey(p: (String, String)): (String, String) = , +      (if (p._1.startsWith("average")) "average" else p._1.takeWhile(_ != '('), p._2), +    def formatJavaCol(name: String, alternatives: Iterable[String]): String = {, +      alternatives.toList.sorted.map(scalaToJavaSignature(_)).map(s => {, +        if (s.length > 50) {, +          val toolTip = escapeJava(s), +          "<span title=\"" + toolTip + "\"><code>" + name + "(...)</code></span>", +        } else {, +          "`" + s + "`", +        }, +      }).mkString("<br/>"), +    }, +    def formatScalaCol(s: String): String = , +      if (s.startsWith("[") && s.endsWith("]")) s.drop(1).dropRight(1) else "`" + s + "`", +    def escape(s: String) = s.replaceAllLiterally("[", "&lt;").replaceAllLiterally("]", "&gt;"), +    , +    println(""", +## Comparison of Scala Observable and Java Observable, +   , +Note: , +*    This table contains both static methods and instance methods., +*    If a signature is too long, move your mouse over it to get the full signature., +, +   , +| Java Method | Scala Method |, +|-------------|--------------|"""), +    , +    val ps = setTodoForMissingMethods(correspondence), +, +    (for (((javaName, scalaCol), pairs) <- ps.groupBy(groupingKey(_)).toList.sortBy(_._1._1)) yield {, +      "| " + formatJavaCol(javaName, pairs.map(_._1)) + " | " + formatScalaCol(scalaCol) + " |", +    }).foreach(println(_)), +    println(s"\nThis table was generated on ${Calendar.getInstance().getTime()}."), +    println(s"**Do not edit**. Instead, edit `${getClass().getCanonicalName()}`."), +  }, +  ]