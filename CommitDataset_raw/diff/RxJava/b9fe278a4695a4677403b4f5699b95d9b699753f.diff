[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +    public void awaitTerminalEventAndUnsubscribeOnTimeout(long timeout, TimeUnit unit) {, +        try {, +            awaitTerminalEvent(timeout, unit);, +        } catch (RuntimeException e) {, +            unsubscribe();, +        }, +    }, +, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +    public void awaitTerminalEventAndUnsubscribeOnTimeout(long timeout, TimeUnit unit) {, +        try {, +            awaitTerminalEvent(timeout, unit);, +        } catch (RuntimeException e) {, +            unsubscribe();, +        }, +    }, +, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.LinkedList;, +import java.util.Queue;, +import rx.Subscriber;, +import rx.subscriptions.CompositeSubscription;, +, +/**, + * Buffers the incoming events until notified, then replays the, + * buffered events and continues as a simple pass-through subscriber., + * @param <T> the streamed value type, + */, +public class BufferUntilSubscriber<T> extends Subscriber<T> {, +    /** The actual subscriber. */, +    private final Subscriber<? super T> actual;, +    /** Indicate the pass-through mode. */, +    private volatile boolean passthroughMode;, +    /** Protect mode transition. */, +    private final Object gate = new Object();, +    /** The buffered items. */, +    private final Queue<Object> queue = new LinkedList<Object>();, +    /** The queue capacity. */, +    private final int capacity;, +    /** Null sentinel (in case queue type is changed). */, +    private static final Object NULL_SENTINEL = new Object();, +    /** Complete sentinel. */, +    private static final Object COMPLETE_SENTINEL = new Object();, +    /**, +     * Container for an onError event., +     */, +    private static final class ErrorSentinel {, +        final Throwable t;, +, +        public ErrorSentinel(Throwable t) {, +            this.t = t;, +        }, +        , +    }, +    /**, +     * Constructor that wraps the actual subscriber and shares its subscription., +     * @param capacity the queue capacity to accept before blocking, negative value indicates an unbounded queue, +     * @param actual, +     */, +    public BufferUntilSubscriber(int capacity, Subscriber<? super T> actual) {, +        super(actual);, +        this.actual = actual;, +        this.capacity = capacity;, +    }, +    /**, +     * Constructor that wraps the actual subscriber and uses the given composite, +     * subscription., +     * @param capacity the queue capacity to accept before blocking, negative value indicates an unbounded queue, +     * @param actual, +     * @param cs , +     */, +    public BufferUntilSubscriber(int capacity, Subscriber<? super T> actual, CompositeSubscription cs) {, +        super(cs);, +        this.actual = actual;, +        this.capacity = capacity;, +    }]