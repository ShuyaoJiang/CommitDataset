[+++ b/src/main/java/io/reactivex/Observable.java, +        // using onSubscribe so the fusing has access to the underlying raw Publisher, +        return create(new PublisherLift<>(onSubscribe, lifter));, +    , +    public <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {, +        Objects.requireNonNull(other);, +        Objects.requireNonNull(combiner);, +        , +        return lift(new OperatorWithLatestFrom<>(combiner, other));, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +        // using onSubscribe so the fusing has access to the underlying raw Publisher, +        return create(new PublisherLift<>(onSubscribe, lifter));, +    , +    public <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {, +        Objects.requireNonNull(other);, +        Objects.requireNonNull(combiner);, +        , +        return lift(new OperatorWithLatestFrom<>(combiner, other));, +    }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorWithLatestFrom.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.concurrent.atomic.*;, +import java.util.function.BiFunction;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Observable.Operator;, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.subscribers.SerializedSubscriber;, +, +public final class OperatorWithLatestFrom<T, U, R> implements Operator<R, T> {, +    final BiFunction<? super T, ? super U, ? extends R> combiner;, +    final Publisher<? extends U> other;, +    public OperatorWithLatestFrom(BiFunction<? super T, ? super U, ? extends R> combiner, Publisher<? extends U> other) {, +        this.combiner = combiner;, +        this.other = other;, +    }, +    , +    @Override, +    public Subscriber<? super T> apply(Subscriber<? super R> t) {, +        SerializedSubscriber<R> serial = new SerializedSubscriber<>(t);, +        WithLatestFromSubscriber<T, U, R> wlf = new WithLatestFromSubscriber<>(serial, combiner);, +        , +        other.subscribe(new Subscriber<U>() {, +            @Override, +            public void onSubscribe(Subscription s) {, +                if (wlf.setOther(s)) {, +                    s.request(Long.MAX_VALUE);, +                }, +            }, +            , +            @Override, +            public void onNext(U t) {, +                wlf.lazySet(t);, +            }, +            , +            @Override, +            public void onError(Throwable t) {, +                wlf.otherError(t);, +            }, +            , +            @Override, +            public void onComplete() {, +                // nothing to do, the wlf will complete on its own pace, +            }, +        });, +        , +        return wlf;, +    }, +    , +    static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U> implements Subscriber<T>, Subscription {, +        /** */, +        private static final long serialVersionUID = -312246233408980075L;, +        , +        final Subscriber<? super R> actual;, +        final BiFunction<? super T, ? super U, ? extends R> combiner;, +        , +        volatile Subscription s;, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<WithLatestFromSubscriber, Subscription> S =, +                AtomicReferenceFieldUpdater.newUpdater(WithLatestFromSubscriber.class, Subscription.class, "s");, +        , +        volatile Subscription other;, +        @SuppressWarnings("rawtypes")]