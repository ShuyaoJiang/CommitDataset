[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +    static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>, +    implements ConditionalSubscriber<T>, Subscription {, +            if (!tryOnNext(t)) {, +                s.get().request(1);, +            }, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +                    return false;, +                return true;, +                return false;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +    static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>, +    implements ConditionalSubscriber<T>, Subscription {, +            if (!tryOnNext(t)) {, +                s.get().request(1);, +            }, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +                    return false;, +                return true;, +                return false;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +    implements ConditionalSubscriber<T>, Subscription {, +                if (SubscriptionHelper.isCancelled(s.get())) {, +            if (!tryOnNext(t) && !done) {, +                s.get().request(1);, +            }, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +                return false;, +                    return false;, +                return false;, +            return true;, +            for (WithLatestInnerSubscriber s : subscribers) {, +                SubscriptionHelper.cancel(s);, +    implements FlowableSubscriber<Object> {, +        void dispose() {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +    static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>, +    implements ConditionalSubscriber<T>, Subscription {, +            if (!tryOnNext(t)) {, +                s.get().request(1);, +            }, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +                    return false;, +                return true;, +                return false;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +    implements ConditionalSubscriber<T>, Subscription {, +                if (SubscriptionHelper.isCancelled(s.get())) {, +            if (!tryOnNext(t) && !done) {, +                s.get().request(1);, +            }, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +                return false;, +                    return false;, +                return false;, +            return true;, +            for (WithLatestInnerSubscriber s : subscribers) {, +                SubscriptionHelper.cancel(s);, +    implements FlowableSubscriber<Object> {, +        void dispose() {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java, +    public void singleRequestNotForgottenWhenNoData() {, +, +    @Test, +    public void coldSourceConsumedWithoutOther() {, +        Flowable.range(1, 10).withLatestFrom(Flowable.never(),, +        new BiFunction<Integer, Object, Object>() {, +            @Override, +            public Object apply(Integer a, Object b) throws Exception {, +                return a;, +            }, +        }), +        .test(1), +        .assertResult();, +    }, +, +    @Test, +    public void coldSourceConsumedWithoutManyOthers() {, +        Flowable.range(1, 10).withLatestFrom(Flowable.never(), Flowable.never(), Flowable.never(),, +        new Function4<Integer, Object, Object, Object, Object>() {]