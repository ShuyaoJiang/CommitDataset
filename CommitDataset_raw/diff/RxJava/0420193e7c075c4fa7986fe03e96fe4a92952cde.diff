[+++ b/src/main/java/rx/Observable.java, +import rx.subjects.*;, +    /** An empty observable which just emits onCompleted to any subscriber. */, +    private static final Observable<Object> EMPTY = create(new OnSubscribe<Object>() {, +        public void call(Subscriber<? super Object> t1) {, +            t1.onCompleted();, +        return (Observable<T>)EMPTY;, +    @SuppressWarnings({"unchecked", "rawtypes"}), +        if (source.getClass() == ScalarSynchronousObservable.class) {, +            return ((ScalarSynchronousObservable<T>)source).scalarFlatMap((Func1)UtilityFunctions.identity());, +        }, +    @Experimental, +    @SuppressWarnings({"unchecked", "rawtypes"}), +        if (source.getClass() == ScalarSynchronousObservable.class) {, +            return ((ScalarSynchronousObservable<T>)source).scalarFlatMap((Func1)UtilityFunctions.identity());, +        }, +        return source.lift(OperatorMerge.<T>instance(false, maxConcurrent));, +     * Flattens an Array of Observables into one Observable, without any transformation, while limiting the, +     * number of concurrent subscriptions to these Observables., +     * <p>, +     * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png" alt="">, +     * <p>, +     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by, +     * using the {@code merge} method., +     * <dl>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     * , +     * @param sequences, +     *            the Array of Observables, +     * @param maxConcurrent, +     *            the maximum number of Observables that may be subscribed to concurrently, +     * @return an Observable that emits all of the items emitted by the Observables in the Array, +     * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>, +     */, +    @Experimental, +    public final static <T> Observable<T> merge(Observable<? extends T>[] sequences, int maxConcurrent) {, +        return merge(from(sequences), maxConcurrent);, +    }, +    /**, +    /**, +     * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to, +     * receive all successfully emitted items from all of the source Observables without being interrupted by, +     * an error notification from one of them, while limiting the, +     * number of concurrent subscriptions to these Observables., +     * <p>, +     * This behaves like {@link #merge(Observable)} except that if any of the merged Observables notify of an, +     * error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * error notification until all of the merged Observables have finished emitting items., +     * <p>, +     * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png" alt="">, +     * <p>, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only, +     * invoke the {@code onError} method of its Observers once., +     * <dl>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     * , +     * @param source, +     *            an Observable that emits Observables, +     * @param maxConcurrent, +     *            the maximum number of Observables that may be subscribed to concurrently, +     * @return an Observable that emits all of the items emitted by the Observables emitted by the, +     *         {@code source} Observable, +     * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>, +     */, +    @Experimental, +    public final static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> source, int maxConcurrent) {, +        return source.lift(OperatorMerge.<T>instance(true, maxConcurrent));, +    }, +     * @param capacity hint for number of items to cache (for optimizing underlying data structure), +    public final Observable<T> cache(int capacity) {, +        return CachedObservable.from(this, capacity);, +    public final Observable<T> defaultIfEmpty(T defaultValue) {, +        return lift(new OperatorDefaultIfEmpty<T>(defaultValue));, +        if (getClass() == ScalarSynchronousObservable.class) {, +            return ((ScalarSynchronousObservable<T>)this).scalarFlatMap(func);, +        }, +        if (getClass() == ScalarSynchronousObservable.class) {, +            return ((ScalarSynchronousObservable<T>)this).scalarFlatMap(func);, +        }, +     * Returns an Observable that emits only the first {@code num} items emitted by the source Observable., +     * {@link Observer#onNext onNext} function a maximum of {@code num} times before invoking, +     * @param num, +     * @return an Observable that emits only the first {@code num} items emitted by the source Observable, or, +     *         all of the items from the source Observable if that Observable emits fewer than {@code num} items, +    public final Observable<T> limit(int num) {, +        return take(num);, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return new OperatorMulticast<T, T>(this, new Func0<Subject<? super T, ? extends T>>() {, +, +            @Override, +            public Subject<? super T, ? extends T> call() {, +                return ReplaySubject.<T> create();, +            }, +            ]