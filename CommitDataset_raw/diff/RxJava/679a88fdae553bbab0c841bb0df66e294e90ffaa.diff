[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val medals = Olympics.mountainBikeMedals.publish, +    medals.connect, +    val shared = unshared.publish, +    shared.connect, +    val sharedNumbers = numbers.publish, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val medals = Olympics.mountainBikeMedals.publish, +    medals.connect, +    val shared = unshared.publish, +    shared.connect, +    val sharedNumbers = numbers.publish, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import rx.lang.scala.observables.ConnectableObservable, +   * @return an [[rx.lang.scala.observables.ConnectableObservable]]., +  def publish: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.publish()), +   *            Observable, whose result will be emitted to [[rx.lang.scala.Observer]]s via, +   *            [[rx.lang.scala.Observer.onNext onNext]] and used in the next accumulator call., +   * Returns an Observable that applies a function of your choosing to the, +   * first item emitted by a source Observable, then feeds the result of that, +   * function along with the second item emitted by an Observable into the, +   * same function, and so on until all items have been emitted by the source, +   * Observable, emitting the result of each of these iterations., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scan.png">, +   * <p>, +   *, +   * @param accumulator, +   *            an accumulator function to be invoked on each item emitted by the source, +   *            Observable, whose result will be emitted to [[rx.lang.scala.Observer]]s via, +   *            [[rx.lang.scala.Observer.onNext onNext]] and used in the next accumulator call., +   * @return, +   *         an Observable that emits the results of each call to the, +   *         accumulator function, +   */, +  def scan[U >: T](accumulator: (U, U) => U): Observable[U] = {, +    val func: Func2[_ >: U, _ >: U, _ <: U] = accumulator, +    val func2 = func.asInstanceOf[Func2[T, T, T]], +    toScalaObservable[U](asJavaObservable.asInstanceOf[rx.Observable[T]].scan(func2)), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val medals = Olympics.mountainBikeMedals.publish, +    medals.connect, +    val shared = unshared.publish, +    shared.connect, +    val sharedNumbers = numbers.publish, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import rx.lang.scala.observables.ConnectableObservable, +   * @return an [[rx.lang.scala.observables.ConnectableObservable]]., +  def publish: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.publish()), +   *            Observable, whose result will be emitted to [[rx.lang.scala.Observer]]s via, +   *            [[rx.lang.scala.Observer.onNext onNext]] and used in the next accumulator call., +   * Returns an Observable that applies a function of your choosing to the, +   * first item emitted by a source Observable, then feeds the result of that, +   * function along with the second item emitted by an Observable into the, +   * same function, and so on until all items have been emitted by the source, +   * Observable, emitting the result of each of these iterations., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scan.png">, +   * <p>, +   *, +   * @param accumulator, +   *            an accumulator function to be invoked on each item emitted by the source, +   *            Observable, whose result will be emitted to [[rx.lang.scala.Observer]]s via, +   *            [[rx.lang.scala.Observer.onNext onNext]] and used in the next accumulator call., +   * @return, +   *         an Observable that emits the results of each call to the, +   *         accumulator function, +   */, +  def scan[U >: T](accumulator: (U, U) => U): Observable[U] = {, +    val func: Func2[_ >: U, _ >: U, _ <: U] = accumulator, +    val func2 = func.asInstanceOf[Func2[T, T, T]], +    toScalaObservable[U](asJavaObservable.asInstanceOf[rx.Observable[T]].scan(func2)), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/BlockingObservable.scala, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val medals = Olympics.mountainBikeMedals.publish, +    medals.connect, +    val shared = unshared.publish, +    shared.connect, +    val sharedNumbers = numbers.publish, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import rx.lang.scala.observables.ConnectableObservable, +   * @return an [[rx.lang.scala.observables.ConnectableObservable]]., +  def publish: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.publish()), +   *            Observable, whose result will be emitted to [[rx.lang.scala.Observer]]s via, +   *            [[rx.lang.scala.Observer.onNext onNext]] and used in the next accumulator call., +   * Returns an Observable that applies a function of your choosing to the]