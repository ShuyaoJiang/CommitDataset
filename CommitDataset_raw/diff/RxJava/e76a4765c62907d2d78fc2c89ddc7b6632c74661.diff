[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, +            if (!done && errors.addThrowable(t)) {, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, +            if (!done && errors.addThrowable(t)) {, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java, +, +    @Test, +    public void innerCancelledOnMainError() {, +        final PublishProcessor<Integer> main = PublishProcessor.create();, +        final PublishProcessor<Integer> inner = PublishProcessor.create();, +, +        TestSubscriber<Integer> to = main.switchMap(Functions.justFunction(inner)), +        .test();, +, +        assertTrue(main.hasSubscribers());, +, +        main.onNext(1);, +, +        assertTrue(inner.hasSubscribers());, +, +        main.onError(new TestException());, +, +        assertFalse(inner.hasSubscribers());, +, +        to.assertFailure(TestException.class);, +    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, +            if (!done && errors.addThrowable(t)) {, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java, +, +    @Test, +    public void innerCancelledOnMainError() {, +        final PublishProcessor<Integer> main = PublishProcessor.create();, +        final PublishProcessor<Integer> inner = PublishProcessor.create();, +, +        TestSubscriber<Integer> to = main.switchMap(Functions.justFunction(inner)), +        .test();, +, +        assertTrue(main.hasSubscribers());, +, +        main.onNext(1);, +, +        assertTrue(inner.hasSubscribers());, +, +        main.onError(new TestException());, +, +        assertFalse(inner.hasSubscribers());, +, +        to.assertFailure(TestException.class);, +    }, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java, +import java.util.concurrent.atomic.*;, +        for (int i = 0; i < 5000; i++) {, +                ps1.onNext(1);, +, +                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);, +, +    @Test, +    public void innerDisposedOnMainError() {, +        final PublishSubject<Integer> main = PublishSubject.create();, +        final PublishSubject<Integer> inner = PublishSubject.create();, +, +        TestObserver<Integer> to = main.switchMap(Functions.justFunction(inner)), +        .test();, +, +        assertTrue(main.hasObservers());, +, +        main.onNext(1);, +, +        assertTrue(inner.hasObservers());, +, +        main.onError(new TestException());, +, +        assertFalse(inner.hasObservers());, +, +        to.assertFailure(TestException.class);, +    }, +, +    @Test, +    public void outerInnerErrorRaceIgnoreDispose() {, +        for (int i = 0; i < 5000; i++) {, +            List<Throwable> errors = TestHelper.trackPluginErrors();, +            try {, +, +                final AtomicReference<Observer<? super Integer>> obs1 = new AtomicReference<Observer<? super Integer>>();, +                final Observable<Integer> ps1 = new Observable<Integer>() {, +                    @Override, +                    protected void subscribeActual(, +                            Observer<? super Integer> observer) {, +                        obs1.set(observer);, +                    }]