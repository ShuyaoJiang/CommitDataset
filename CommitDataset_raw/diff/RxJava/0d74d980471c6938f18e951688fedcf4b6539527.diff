[+++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Observable;, +import rx.Observer;, +import rx.Producer;, +import rx.subjects.Subject;, + * @param <K>, + *            the key type, + * @param <T>, + *            the source and group value type, + * @param <R>, + *            the value type of the groups, +public class OperatorGroupBy<T, K, R> implements Operator<GroupedObservable<K, R>, T> {, +    final Func1<? super T, ? extends R> valueSelector;, +    public OperatorGroupBy(, +            Func1<? super T, ? extends K> keySelector,, +            Func1<? super T, ? extends R> valueSelector) {, +        this.valueSelector = valueSelector;, +        return new GroupBySubscriber<K, T, R>(keySelector, valueSelector, child);, +, +        private static final int MAX_QUEUE_SIZE = 1024;, +        final GroupBySubscriber<K, T, R> self = this;, +, +        public GroupBySubscriber(, +                Func1<? super T, ? extends K> keySelector,, +                Func1<? super T, ? extends R> elementSelector,, +                Subscriber<? super GroupedObservable<K, R>> child) {, +, +        private static class GroupState<K, T> {, +            private final Subject<T, T> s = BufferUntilSubscriber.create();, +            private final AtomicLong requested = new AtomicLong();, +            private final AtomicLong count = new AtomicLong();, +            private final Queue<Object> buffer = new ConcurrentLinkedQueue<Object>(); // TODO should this be lazily created?, +, +            public Observable<T> getObservable() {, +                return s;, +            }, +, +            public Observer<T> getObserver() {, +                return s;, +            }, +, +        }, +, +        private final ConcurrentHashMap<K, GroupState<K, T>> groups = new ConcurrentHashMap<K, GroupState<K, T>>();, +, +        private static final NotificationLite<Object> nl = NotificationLite.instance();, +, +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_EMITTED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "completionEmitted");, +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> TERMINATED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "terminated");, +, +        volatile long requested;, +        static final AtomicLongFieldUpdater<GroupBySubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "requested");, +, +        volatile long bufferedCount;, +        @SuppressWarnings("rawtypes"), +        static final AtomicLongFieldUpdater<GroupBySubscriber> BUFFERED_COUNT = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "bufferedCount");, +            REQUESTED.set(this, MAX_QUEUE_SIZE);, +            request(MAX_QUEUE_SIZE);, +                // for each group check if it is ready to accept more events if so pass the oncomplete through else buffer it., +                for (GroupState<K, T> group : groups.values()) {, +                    emitItem(group, nl.completed());, +                // special case (no groups emitted ... or all unsubscribed), +                if (groups.size() == 0) {, +                    if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {, +        // The grouped observable propagates the 'producer.request' call from it's subscriber to this method, +        // Here we keep track of the requested count for each group, +        // If we already have items queued when a request comes in we vend those and decrement the outstanding request count, +, +        void requestFromGroupedObservable(long n, GroupState<K, T> group) {, +            group.requested.getAndAdd(n);, +            if (group.count.getAndIncrement() == 0) {, +                pollQueue(group);, +            }, +        }, +, +                GroupState<K, T> group = groups.get(key);, +                    group = createNewGroup(key);, +                }, +                emitItem(group, nl.next(t));, +            } catch (Throwable e) {, +                onError(OnErrorThrowable.addValueAsLastCause(e, t));, +            }, +        }, +, +        private GroupState<K, T> createNewGroup(final K key) {, +            final GroupState<K, T> groupState = new GroupState<K, T>();, +                    o.setProducer(new Producer() {, +, +                        @Override, +                        public void request(long n) {, +                            requestFromGroupedObservable(n, groupState);, +                        }]