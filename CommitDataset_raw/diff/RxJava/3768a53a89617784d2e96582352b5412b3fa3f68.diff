[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +import static org.mockito.ArgumentMatchers.any;, +, +    @Test, +    public void noCrossBoundaryFusion() {, +        for (int i = 0; i < 500; i++) {, +            TestSubscriber<Object> ts = Flowable.merge(, +                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);, +                        }, +                    }),, +                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);, +                        }, +                    }), +            ), +            .test(), +            .awaitDone(5, TimeUnit.SECONDS), +            .assertValueCount(2);, +, +            List<Object> list = ts.values();, +, +            assertTrue(list.toString(), list.contains("RxSi"));, +            assertTrue(list.toString(), list.contains("RxCo"));, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +import static org.mockito.ArgumentMatchers.any;, +, +    @Test, +    public void noCrossBoundaryFusion() {, +        for (int i = 0; i < 500; i++) {, +            TestSubscriber<Object> ts = Flowable.merge(, +                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);, +                        }, +                    }),, +                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);, +                        }, +                    }), +            ), +            .test(), +            .awaitDone(5, TimeUnit.SECONDS), +            .assertValueCount(2);, +, +            List<Object> list = ts.values();, +, +            assertTrue(list.toString(), list.contains("RxSi"));, +            assertTrue(list.toString(), list.contains("RxCo"));, +        }, +    }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java, +, +    @Test, +    public void noCrossBoundaryFusion() {, +        for (int i = 0; i < 500; i++) {, +            TestSubscriber<List<Object>> ts = Flowable.zip(, +                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);, +                        }, +                    }),, +                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {, +                        @Override, +                        public Object apply(Integer v) throws Exception {, +                            return Thread.currentThread().getName().substring(0, 4);]