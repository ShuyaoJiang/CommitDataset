[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        try {, +        } catch (Exception e) {, +            // if an unhandled error occurs executing the onSubscribe we will propagate it, +            try {, +                observer.onError(e);, +            } catch (Exception e2) {, +                // if this happens it means the onError itself failed (perhaps an invalid function implementation), +                // so we are unable to propagate the error correctly and will just throw, +                throw new RuntimeException("Error occurred attempting to subscribe [" + e.getMessage() + "] and then again while trying to pass to onError.", e2);, +            }, +            return Subscriptions.empty();, +        }, +    /**, +     * Invokes an action for each element in the observable sequence, and blocks until the sequence is terminated., +     * <p>, +     * NOTE: This will block even if the Observable is asynchronous., +     * <p>, +     * This is similar to {@link #subscribe(Observer)} but blocks. Because it blocks it does not need the {@link Observer#onCompleted()} or {@link Observer#onError(Exception)} methods., +     * , +     * @param onNext, +     *            {@link Action1}, +     * @throws RuntimeException, +     *             if error occurs, +     */, +        public void testOnSubscribeFails() {, +            @SuppressWarnings("unchecked"), +            Observer<String> observer = mock(Observer.class);, +            final RuntimeException re = new RuntimeException("bad impl");, +            Observable<String> o = Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(Observer<String> t1) {, +                    throw re;, +                }, +, +            });, +            o.subscribe(observer);, +            verify(observer, times(0)).onNext(anyString());, +            verify(observer, times(0)).onCompleted();, +            verify(observer, times(1)).onError(re);, +        }, +, +        @Test]