[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java, +        final AtomicBoolean stopWindows = new AtomicBoolean();, +, +                if (stopWindows.get()) {, +            if (stopWindows.compareAndSet(false, true)) {, +                DisposableHelper.dispose(boundary);, +                if (windows.decrementAndGet() == 0) {, +                    upstream.cancel();, +                }, +            }, +                        if (stopWindows.get()) {, +                            cancel();, +                            cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java, +        final AtomicBoolean stopWindows = new AtomicBoolean();, +, +                if (stopWindows.get()) {, +            if (stopWindows.compareAndSet(false, true)) {, +                DisposableHelper.dispose(boundary);, +                if (windows.decrementAndGet() == 0) {, +                    upstream.cancel();, +                }, +            }, +                        if (stopWindows.get()) {, +                            cancel();, +                            cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java, +        final AtomicBoolean stopWindows = new AtomicBoolean();, +, +                if (stopWindows.get()) {, +            if (stopWindows.compareAndSet(false, true)) {, +                DisposableHelper.dispose(boundary);, +                if (windows.decrementAndGet() == 0) {, +                    upstream.dispose();, +                }, +            }, +            return stopWindows.get();, +                        if (stopWindows.get()) {, +                            stopWindows.set(true);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java, +        final AtomicBoolean stopWindows = new AtomicBoolean();, +, +                if (stopWindows.get()) {, +            if (stopWindows.compareAndSet(false, true)) {, +                DisposableHelper.dispose(boundary);, +                if (windows.decrementAndGet() == 0) {, +                    upstream.cancel();, +                }, +            }, +                        if (stopWindows.get()) {, +                            cancel();, +                            cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java, +        final AtomicBoolean stopWindows = new AtomicBoolean();, +, +                if (stopWindows.get()) {, +            if (stopWindows.compareAndSet(false, true)) {, +                DisposableHelper.dispose(boundary);, +                if (windows.decrementAndGet() == 0) {, +                    upstream.dispose();, +                }, +            }, +            return stopWindows.get();, +                        if (stopWindows.get()) {, +                            stopWindows.set(true);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithStartEndFlowableTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import io.reactivex.exceptions.*;, +        // Disposing the outer sequence stops the opening of new windows, +        assertFalse(open.hasSubscribers());, +, +    static Flowable<Integer> flowableDisposed(final AtomicBoolean ref) {, +        return Flowable.just(1).concatWith(Flowable.<Integer>never()), +                .doOnCancel(new Action() {, +                    @Override, +                    public void run() throws Exception {, +                        ref.set(true);, +                    }, +                });, +    }, +, +    @Test, +    public void mainAndBoundaryDisposeOnNoWindows() {, +        AtomicBoolean mainDisposed = new AtomicBoolean();, +        AtomicBoolean openDisposed = new AtomicBoolean();, +        final AtomicBoolean closeDisposed = new AtomicBoolean();, +, +        flowableDisposed(mainDisposed), +        .window(flowableDisposed(openDisposed), new Function<Integer, Flowable<Integer>>() {, +            @Override, +            public Flowable<Integer> apply(Integer v) throws Exception {, +                return flowableDisposed(closeDisposed);, +            }, +        }), +        .test(), +        .assertSubscribed(), +        .assertNoErrors(), +        .assertNotComplete(), +        .dispose();, +]