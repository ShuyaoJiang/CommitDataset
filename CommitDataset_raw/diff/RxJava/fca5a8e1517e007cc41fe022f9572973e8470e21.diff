[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.*;, +    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).concatMap((Function)Functions.identity());, +    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources, int prefetch) {, +        return fromIterable(sources).concatMap((Function)Functions.identity(), prefetch);, +    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {, +        return concatArrayEager(bufferSize(), bufferSize(), sources);, +    }, +, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {, +        return new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);, +    }, +, +    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {, +        return concatEager(sources, bufferSize(), bufferSize());, +    }, +, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {, +        return new FlowableConcatMapEager(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);, +    }, +, +    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {, +        return concatEager(sources, bufferSize(), bufferSize());, +    }, +, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {, +        return new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);, +    }, +, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {, +        Objects.requireNonNull(sources, "sources is null");, +        return concatDelayError(sources, bufferSize(), true);, +    }, +, +    @SuppressWarnings({ "unchecked", "rawtypes" }), +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {, +        Objects.requireNonNull(sources, "sources is null");, +        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);, +    }, +, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {, +        return concatDelayError(sources, bufferSize(), true);, +    }, +, +    @SuppressWarnings({ "unchecked", "rawtypes" }), +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {, +        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);, +    }, +, +    , +    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {, +        return concatMapDelayError(mapper, 2, true);, +    }, +, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean tillTheEnd) {, +        Objects.requireNonNull(mapper, "mapper is null");, +        if (this instanceof ScalarCallable) {, +            @SuppressWarnings("unchecked"), +            T v = ((ScalarCallable<T>)this).call();, +            if (v == null) {, +                return empty();, +            }, +            return ScalarXMap.scalarXMap(v, mapper);, +        }, +        if (prefetch <= 0) {, +            throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);, +        }, +        return new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.IMMEDIATE);, +    }, +, +, +    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {, +        return concatMapEager(mapper, bufferSize(), bufferSize());, +    }, +, +    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper, , +            int maxConcurrency, int prefetch) {, +        return new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE);, +    }, +, +    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean tillTheEnd) {, +        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);, +    }, +, +    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, , +            int maxConcurrency, int prefetch, boolean tillTheEnd) {]