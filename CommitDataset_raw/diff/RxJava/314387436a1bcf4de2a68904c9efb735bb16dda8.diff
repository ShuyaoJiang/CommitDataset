[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.lang.scala.examples, +, +import java.io.IOException, +, +import scala.concurrent.duration.Duration, +import scala.concurrent.duration.DurationInt, +import scala.concurrent.duration.DurationLong, +import scala.language.postfixOps, +, +import org.junit.Assert.assertEquals, +import org.junit.Assert.assertTrue, +import org.junit.Ignore, +import org.junit.Test, +import org.scalatest.junit.JUnitSuite, +, +import rx.lang.scala.Notification, +import rx.lang.scala.Observable, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, +, +@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +class RxScalaDemo extends JUnitSuite {, +, +  @Test def intervalExample() {, +    val o = Observable.interval(200 millis).take(5), +    o.subscribe(n => println("n = " + n)), +, +    // need to wait here because otherwise JUnit kills the thread created by interval(), +    waitFor(o), +, +    println("done"), +  }, +, +  def msTicks(start: Long, step: Long): Observable[Long] = {, +    // will be easier once we have Observable.generate method, +    Observable.interval(step millis) map (_ * step + start), +  }, +, +  def prefixedTicks(start: Long, step: Long, prefix: String): Observable[String] = {, +    msTicks(start, step).map(prefix + _), +  }, +, +  @Test def testTicks() {, +    val o = prefixedTicks(5000, 500, "t = ").take(5), +    o.subscribe(output(_)), +    waitFor(o), +  }, +, +  @Test def testSwitch() {, +    // We do not have ultimate precision: Sometimes, 747 gets through, sometimes not, +    val o = Observable.interval(1000 millis).map(n => prefixedTicks(0, 249, s"Observable#$n: ")), +      .switch.take(16), +    o.subscribe(output(_)), +    waitFor(o), +  }, +, +  @Test def testSwitchOnObservableOfInt() {, +    // Correctly rejected with error , +    // "Cannot prove that Observable[Int] <:< Observable[Observable[U]]", +    // val o = Observable(1, 2).switch, +  }, +, +  @Test def testObservableComparison() {, +    val first = Observable(10, 11, 12), +    val second = Observable(10, 11, 12), +, +    val b1 = (first zip second) map (p => p._1 == p._2) forall (b => b), +, +    val equality = (a: Any, b: Any) => a == b, +    val b2 = (first zip second) map (p => equality(p._1, p._2)) forall (b => b), +, +    assertTrue(b1.toBlockingObservable.single), +    assertTrue(b2.toBlockingObservable.single), +  }, +, +  @Test def testObservableComparisonWithForComprehension() {, +    val first = Observable(10, 11, 12), +    val second = Observable(10, 11, 12), +, +    val booleans = for ((n1, n2) <- (first zip second)) yield (n1 == n2), +, +    val b1 = booleans.forall(_ == true) // without `== true`, b1 is assigned the forall function, +, +    assertTrue(b1.toBlockingObservable.single)]