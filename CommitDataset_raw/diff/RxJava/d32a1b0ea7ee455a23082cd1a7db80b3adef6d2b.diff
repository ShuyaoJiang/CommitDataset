[+++ b/src/main/java/rx/internal/operators/OperatorSwitch.java, +                            long r = initialRequested + n;, +                            if (r < 0) {, +                                infinite = true;, +                                initialRequested = r;, +                            }, +                        } else {, +                            long r = currentSubscriber.requested + n;, +                            if (r < 0) {, +                                infinite = true;, +                            } else {, +                                currentSubscriber.requested = r;, +                            }, +                        if (infinite), +                            localSubscriber.requestMore(Long.MAX_VALUE);, +                        else , +                    if (innerSubscriber.requested != Long.MAX_VALUE), +                            if (innerSubscriber.requested != Long.MAX_VALUE), +++ b/src/main/java/rx/internal/operators/OperatorSwitch.java, +                            long r = initialRequested + n;, +                            if (r < 0) {, +                                infinite = true;, +                                initialRequested = r;, +                            }, +                        } else {, +                            long r = currentSubscriber.requested + n;, +                            if (r < 0) {, +                                infinite = true;, +                            } else {, +                                currentSubscriber.requested = r;, +                            }, +                        if (infinite), +                            localSubscriber.requestMore(Long.MAX_VALUE);, +                        else , +                    if (innerSubscriber.requested != Long.MAX_VALUE), +                            if (innerSubscriber.requested != Long.MAX_VALUE), +++ b/src/test/java/rx/internal/operators/OperatorSwitchTest.java, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.CopyOnWriteArrayList;, +import rx.functions.Action1;, +    , +    @Test(timeout = 10000), +    public void testInitialRequestsAreAdditive() {, +        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);, +        Observable.switchOnNext(, +                Observable.interval(100, TimeUnit.MILLISECONDS), +                          .map(, +                                new Func1<Long, Observable<Long>>() {, +                                    @Override, +                                    public Observable<Long> call(Long t) {, +                                        return Observable.just(1L, 2L, 3L);, +                                    }, +                                }, +                          ).take(3)), +                          .subscribe(ts);, +        ts.requestMore(Long.MAX_VALUE - 100);, +        ts.requestMore(1);, +        ts.awaitTerminalEvent();, +    }, +    , +    @Test(timeout = 10000), +    public void testInitialRequestsDontOverflow() {, +        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);, +        Observable.switchOnNext(, +                Observable.interval(100, TimeUnit.MILLISECONDS), +                        .map(new Func1<Long, Observable<Long>>() {, +                            @Override, +                            public Observable<Long> call(Long t) {, +                                return Observable.from(Arrays.asList(1L, 2L, 3L));, +                            }, +                        }).take(3)).subscribe(ts);, +        ts.requestMore(Long.MAX_VALUE - 1);, +        ts.requestMore(2);, +        ts.awaitTerminalEvent();, +        assertTrue(ts.getOnNextEvents().size() > 0);, +    }, +    , +    , +    @Test(timeout = 10000), +    public void testSecondaryRequestsDontOverflow() throws InterruptedException {, +        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);, +        Observable.switchOnNext(, +                Observable.interval(100, TimeUnit.MILLISECONDS), +                        .map(new Func1<Long, Observable<Long>>() {, +                            @Override, +                            public Observable<Long> call(Long t) {, +                                return Observable.from(Arrays.asList(1L, 2L, 3L));, +                            }, +                        }).take(3)).subscribe(ts);, +        ts.requestMore(1);, +        //we will miss two of the first observable, +        Thread.sleep(250);, +        ts.requestMore(Long.MAX_VALUE - 1);]