[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +  (:import [rx Observable Observer Subscriber Subscription Observable$Operator Observable$OnSubscribe], +(declare concat map map-indexed reduce take take-while), +(defn ^Subscriber ->subscriber, +  "", +  ([o on-next-action] (->subscriber o on-next-action nil nil)), +  ([o on-next-action on-error-action] (->subscriber o on-next-action on-error-action)), +  ([^Subscriber o on-next-action on-error-action on-completed-action], +   (proxy [Subscriber] [o], +     (onCompleted [], +       (if on-completed-action, +         (on-completed-action o), +         (on-completed o))), +     (onError [e], +       (if on-error-action, +         (on-error-action o e), +         (on-error o e))), +     (onNext [t], +       (if on-next-action, +         (on-next-action o t), +         (on-next o t)))))), +, +(defn ^Observable$Operator ->operator, +  "Create a basic Operator with the given handler fns. If a handler is omitted or nil, +  it's treated as a pass-through., +, +  on-next-action  Passed Subscriber and value, +  on-error-action Passed Throwable, +  on-completed-action No-args, +, +  See:, +  lift, +  rx.Observable$Operator, +  ", +  [input], +  {:pre [(fn? input)]}, +  (reify Observable$Operator, +    (call [this o], +      (input o)))), +, +(defn lift, +  "Lift the Operator op over the given Observable xs, +, +  Example:, +, +    (->> my-observable, +         (rx/lift (rx/->operator ...)), +         ...), +, +  See:, +    rx.Observable/lift, +    ->operator, +  ", +  [^Observable$Operator op ^Observable xs], +  (.lift xs op)), +(defn unsubscribed?, +  "Returns true if the given Subscription (or Subscriber) is unsubscribed., +, +  See:, +    rx.Observable/create, +    fn->o, +  ", +  [^Subscription s], +  (.isUnsubscribed s)), +, +(defn ^Observable fn->o, +  "Create an Observable from the given function., +, +  When subscribed to, (f subscriber) is called at which point, f can start emitting values, etc., +  The passed subscriber is of type rx.Subscriber., +, +  See:, +    rx.Subscriber, +    rx.Observable/create, +  ", +  [f], +  (Observable/create ^Observable$OnSubscribe (iop/action* f))), +, +  "caches the observable value so that multiple subscribers don't re-evaluate it., +, +  See:, +    rx.Observable/cache", +  (concat (return x) xs)), +  [do-fn xs], +  (map #(do (do-fn %) %) xs)), +  [p ^Observable xs], +  (.skipWhile xs (fn->predicate p))), +(defn ^Observable first, +  "Returns an Observable that emits the first item emitted by xs, or an, +  empty Observable if xs is empty., +, +  See:, +    rx.Observable/takeFirst, +  ", +  [^Observable xs], +  (.takeFirst xs)), +, +  (let [op (->operator (fn [o], +                           (->subscriber o (fn [o v]]