[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMergeDelayError;, +import rx.operators.OperatorMergeMaxConcurrent;, +        return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7));, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7, t8));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMergeDelayError;, +import rx.operators.OperatorMergeMaxConcurrent;, +        return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7));, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7, t8));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.List;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.exceptions.CompositeException;, +import rx.observers.SerializedObserver;, +import rx.subscriptions.BooleanSubscription;, +import rx.subscriptions.CompositeSubscription;, +, +/**, + * This behaves like {@link OperatorMerge} except that if any of the merged Observables notify of, + * an error via <code>onError</code>, mergeDelayError will refrain from propagating that error, + * notification until all of the merged Observables have finished emitting items., + * <p>, + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/mergeDelayError.png">, + * <p>, + * Even if multiple merged Observables send <code>onError</code> notifications, mergeDelayError will, + * only invoke the <code>onError</code> method of its Observers once., + * <p>, + * This operation allows an Observer to receive all successfully emitted items from all of the, + * source Observables without being interrupted by an error notification from one of them., + * <p>]