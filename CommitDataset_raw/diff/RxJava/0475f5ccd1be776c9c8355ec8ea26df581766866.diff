[+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import rx.subscriptions.SerialSubscription;, +                    if (value < count), +                        return Notification.createOnNext(value + 1);, +                    else, +                        return (Notification<Long>) term;, +                    if (predicate.call(value, term.getThrowable()).booleanValue()), +                        return Notification.createOnNext(value + 1);, +                    else, +                        return (Notification<Integer>) term;, +        if (count < 0), +            throw new IllegalArgumentException("count >= 0 expected");, +        if (count == 0), +            return source;, +        if (count < 0), +            throw new IllegalArgumentException("count >= 0 expected");, +        final AtomicBoolean isLocked = new AtomicBoolean(true);, +        final AtomicBoolean isStarted = new AtomicBoolean(false);, +        // incremented when requests are made, decremented when requests are fulfilled, +        final AtomicLong consumerCapacity = new AtomicLong(0l);, +        final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        final Scheduler.Worker worker = scheduler.createWorker();, +        child.add(worker);, +        final SerialSubscription sourceSubscriptions = new SerialSubscription();, +                sourceSubscriptions.set(terminalDelegatingSubscriber);, +                                if (t.isOnCompleted() && stopOnComplete), +                                    child.onCompleted();, +                                else if (t.isOnError() && stopOnError), +                                    child.onError(t.getThrowable());, +        worker.schedule(new Action0() {, +                            if (consumerCapacity.get() > 0) {, +                                worker.schedule(subscribeToSource);, +                            }, +        });, +                    worker.schedule(subscribeToSource);, +                } else {, +                    if (consumerCapacity.getAndAdd(n) == 0) {, +                        // restart, +                        worker.schedule(subscribeToSource);, +                    } else {, +                        if (currentProducer.get() != null) {, +                }, +            }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import rx.subscriptions.SerialSubscription;, +                    if (value < count), +                        return Notification.createOnNext(value + 1);, +                    else, +                        return (Notification<Long>) term;, +                    if (predicate.call(value, term.getThrowable()).booleanValue()), +                        return Notification.createOnNext(value + 1);, +                    else, +                        return (Notification<Integer>) term;, +        if (count < 0), +            throw new IllegalArgumentException("count >= 0 expected");, +        if (count == 0), +            return source;, +        if (count < 0), +            throw new IllegalArgumentException("count >= 0 expected");, +        final AtomicBoolean isLocked = new AtomicBoolean(true);, +        final AtomicBoolean isStarted = new AtomicBoolean(false);, +        // incremented when requests are made, decremented when requests are fulfilled, +        final AtomicLong consumerCapacity = new AtomicLong(0l);, +        final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        final Scheduler.Worker worker = scheduler.createWorker();, +        child.add(worker);, +        final SerialSubscription sourceSubscriptions = new SerialSubscription();, +                sourceSubscriptions.set(terminalDelegatingSubscriber);, +                                if (t.isOnCompleted() && stopOnComplete), +                                    child.onCompleted();, +                                else if (t.isOnError() && stopOnError), +                                    child.onError(t.getThrowable());, +        worker.schedule(new Action0() {, +                            if (consumerCapacity.get() > 0) {, +                                worker.schedule(subscribeToSource);, +                            }, +        });, +                    worker.schedule(subscribeToSource);, +                } else {, +                    if (consumerCapacity.getAndAdd(n) == 0) {, +                        // restart, +                        worker.schedule(subscribeToSource);, +                    } else {, +                        if (currentProducer.get() != null) {, +                }, +            }, +++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java, +import rx.internal.util.RxRingBuffer;, +    @Test, +    public void testRetryWithBackpressure() {, +        @SuppressWarnings("unchecked"), +        Observer<String> observer = mock(Observer.class);, +        int NUM_RETRIES = RxRingBuffer.SIZE * 2;, +        Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));, +        TestSubscriber<String> ts = new TestSubscriber<String>(observer);, +        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);, +        ts.awaitTerminalEvent();, +        , +        InOrder inOrder = inOrder(observer);, +        // should show 3 attempts]