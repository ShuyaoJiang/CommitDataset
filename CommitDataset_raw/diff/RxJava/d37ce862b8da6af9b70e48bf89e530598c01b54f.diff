[+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, +    public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, +    public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, +    public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +    println(doubleAverage(Observable.empty[Double]).toBlockingObservable.single), +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, +    public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +    println(doubleAverage(Observable.empty[Double]).toBlockingObservable.single), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Opening, Closing](openings: Observable[Opening], closings: Opening => Observable[Closing]): Observable[Seq[T]] = {, +    val closing: Func1[_ >: Opening, _ <: rx.Observable[_ <: Closing]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Opening, Closing](opening, closing), +  def window[Closing](closings: () => Observable[Closing]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Closing](func), +  def window[Opening, Closing](openings: Observable[Opening], closings: Opening => Observable[Closing]) = {, +      asJavaObservable.window[Opening, Closing](openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +   * @tparam Closing, +   *            the type of the element emitted from the closings observable., +  def groupByUntil[K, Closing](f: T => K, closings: (K, Observable[T])=>Observable[Closing]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Closing]] =, +    val o1 = asJavaObservable.groupByUntil[K, Closing](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +   * @param scheduler the scheduler to call the, +                        [[rx.lang.scala.Observer#onCompleted onCompleted]] method, +   * @param T the type of the items (ostensibly) emitted by the Observable, +  def empty[T]: Observable[T] = {, +    toScalaObservable(rx.Observable.empty[T]()), +   * @param T the type of the items (ostensibly) emitted by the Observable, +  def empty[T](scheduler: Scheduler): Observable[T] = {, +    toScalaObservable(rx.Observable.empty[T](scalaSchedulerToJavaScheduler(scheduler))), +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, +    public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +    println(doubleAverage(Observable.empty[Double]).toBlockingObservable.single), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Opening, Closing](openings: Observable[Opening], closings: Opening => Observable[Closing]): Observable[Seq[T]] = {, +    val closing: Func1[_ >: Opening, _ <: rx.Observable[_ <: Closing]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Opening, Closing](opening, closing), +  def window[Closing](closings: () => Observable[Closing]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Closing](func), +  def window[Opening, Closing](openings: Observable[Opening], closings: Opening => Observable[Closing]) = {, +      asJavaObservable.window[Opening, Closing](openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +   * @tparam Closing, +   *            the type of the element emitted from the closings observable., +  def groupByUntil[K, Closing](f: T => K, closings: (K, Observable[T])=>Observable[Closing]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Closing]] =, +    val o1 = asJavaObservable.groupByUntil[K, Closing](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +   * @param scheduler the scheduler to call the, +                        [[rx.lang.scala.Observer#onCompleted onCompleted]] method, +   * @param T the type of the items (ostensibly) emitted by the Observable, +  def empty[T]: Observable[T] = {]