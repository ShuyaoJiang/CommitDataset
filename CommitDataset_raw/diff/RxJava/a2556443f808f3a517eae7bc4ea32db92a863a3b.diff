[+++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java, +        // TODO start with size hint, +                    pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child) {, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java, +        // TODO start with size hint, +                    pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child) {, +++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java, +import static org.junit.Assert.assertEquals;, +, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java, +        // TODO start with size hint, +                    pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +                pollQueue(wip, requested, queue, child);, +    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child) {, +++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java, +import static org.junit.Assert.assertEquals;, +, +++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java, +import rx.observables.GroupedObservable;, +                System.out.println("FuncWithErrors @ " + count.get()); , +                System.out.println("FuncWithErrors @ onSuccessOnly"); ]