[+++ b/language-adaptors/rxjava-clojure/README.md, +Clojure bindings for RxJava., +Example for Leiningen:, +, +```clojure, +[com.netflix.rxjava/rxjava-clojure "x.y.z"], +```, +, +and for Gradle:, +, +```groovy, +compile 'com.netflix.rx:rxjava-clojure:x.y.z', +```, +, +and for Maven:, +# Clojure Bindings, +This library provides convenient, idiomatic Clojure bindings for RxJava., +, +The bindings try to present an API that will be comfortable and familiar to a Clojure programmer that's familiar with the sequence operations in `clojure.core`. It "fixes" several issues with using RxJava with raw Java interop, for example:, +, +* Argument lists are in the "right" order. So in RxJava, the function applied in `Observable.map` is the second argument, while here it's the first argument with one or more Observables as trailing arguments, +* Operators take normal Clojure functions as arguments, bypassing need for the interop described below, +* Predicates accomodate Clojure's notion of truth, +* Operators are generally names as they would be in `clojure.core` rather than the Rx names, +, +There is no object wrapping going on. That is, all functions return normal `rx.Observable` objects, so you can always drop back to Java interop for anything that's missing in this wrapper., +, +## Basic Usage, +Most functionality resides in the `rx.lang.clojure.core` namespace and for the most part looks like normal Clojure sequence manipulation:, +(require '[rx.lang.clojure.core :as rx]), +, +(->> my-observable, +     (rx/map (comp clojure.string/lower-case :first-name)), +     (rx/map clojure.string/lower-case), +     (rx/filter #{"bob"}), +     (rx/distinct), +     (rx/into [])), +;=> An Observable that emits a single vector of names, +, +Blocking operators, which are useful for testing, but should otherwise be avoided, reside in `rx.lang.clojure.blocking`. For example:, +, +```clojure, +(require '[rx.lang.clojure.blocking :as rxb]), +, +(rxb/doseq [{:keys [first-name]} users-observable], +  (println "Hey," first-name)), +;=> nil, +```, +, +## What's Missing, +This library is an ongoing work in progress driven primarily by the needs of one team at Netflix. As such some things are currently missing:, +, +* Highly-specific operators that we felt cluttered the API and were easily composed from existing operators, especially since we're in not-Java land. For example, `Observable.sumLong()`., +* Most everything involving schedulers, +* Most everything involving time, +* `Observable.window` and `Observable.buffer`. Who knows which parts of these beasts to wrap?, +, +Of course, contributions that cover these cases are welcome., +, +# Low-level Interop, +This adaptor provides functions and macros to ease Clojure/RxJava interop. In particular, there are functions and macros for turning Clojure functions and code into RxJava `Func*` and `Action*` interfaces without the tedium of manually reifying the interfaces., +, +## Basic Usage, +, +### Requiring the interop namespace, +The first thing to do is to require the namespace:, +, +```clojure, +(ns my.namespace, +  (:require [rx.lang.clojure.interop :as rx]), +  (:import [rx Observable])), +```, +, +or, at the REPL:, +, +```clojure, +(require '[rx.lang.clojure.interop :as rx]), +```, +, +### Using rx/fn, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.util.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +, +```clojure, +(-> my-observable, +    (.map (rx/fn [v] (* 2 v)))), +```, +, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.util.functions.Func`:, +, +```clojure, +(-> my-numbers, +    (.reduce (rx/fn* +))), +```, +, +### Using rx/action, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.util.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +, +```clojure, +(-> my-observable, +    (.map (rx/fn* transform-data))]