[+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import rx.subscriptions.SerialSubscription;, +                return new Observation(observer).init();, +        /** Observe through individual queue per observer. */, +        private class Observation implements Action1<Notification<? extends T>> {, +            final Observer<? super T> observer;, +            final CompositeSubscription s;, +            final ConcurrentLinkedQueue<Notification<? extends T>> queue;, +            final AtomicInteger counter;, +            private volatile Scheduler recursiveScheduler;, +            public Observation(Observer<? super T> observer) {, +                this.observer = observer;, +                this.queue = new ConcurrentLinkedQueue<Notification<? extends T>>();, +                this.counter = new AtomicInteger(0);, +                this.s = new CompositeSubscription();, +            }, +            public Subscription init() {, +                s.add(source.materialize().subscribe(this));, +                return s;, +            }, +                                    processQueue();, +                        processQueue();, +            void processQueue() {, +    }, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import rx.subscriptions.SerialSubscription;, +                return new Observation(observer).init();, +        /** Observe through individual queue per observer. */, +        private class Observation implements Action1<Notification<? extends T>> {, +            final Observer<? super T> observer;, +            final CompositeSubscription s;, +            final ConcurrentLinkedQueue<Notification<? extends T>> queue;, +            final AtomicInteger counter;, +            private volatile Scheduler recursiveScheduler;, +            public Observation(Observer<? super T> observer) {, +                this.observer = observer;, +                this.queue = new ConcurrentLinkedQueue<Notification<? extends T>>();, +                this.counter = new AtomicInteger(0);, +                this.s = new CompositeSubscription();, +            }, +            public Subscription init() {, +                s.add(source.materialize().subscribe(this));, +                return s;, +            }, +                                    processQueue();, +                        processQueue();, +            void processQueue() {, +    }, +++ b/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java, +import rx.concurrency.TestScheduler;, +    @Test, +    public void observeOnTheSameSchedulerTwice() {, +        TestScheduler scheduler = new TestScheduler();, +        , +        Observable<Integer> o = Observable.from(1, 2, 3);, +        Observable<Integer> o2 = o.observeOn(scheduler);, +, +        @SuppressWarnings("unchecked"), +        Observer<Object> observer1 = mock(Observer.class);, +        @SuppressWarnings("unchecked"), +        Observer<Object> observer2 = mock(Observer.class);, +        , +        InOrder inOrder1 = inOrder(observer1);, +        InOrder inOrder2 = inOrder(observer2);, +        , +        o2.subscribe(observer1);, +        o2.subscribe(observer2);, +        , +        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);, +        , +        inOrder1.verify(observer1, times(1)).onNext(1);, +        inOrder1.verify(observer1, times(1)).onNext(2);, +        inOrder1.verify(observer1, times(1)).onNext(3);, +        inOrder1.verify(observer1, times(1)).onCompleted();, +        verify(observer1, never()).onError(any(Throwable.class));, +        inOrder1.verifyNoMoreInteractions();, +, +        inOrder2.verify(observer2, times(1)).onNext(1);, +        inOrder2.verify(observer2, times(1)).onNext(2);, +        inOrder2.verify(observer2, times(1)).onNext(3);, +        inOrder2.verify(observer2, times(1)).onCompleted();, +        verify(observer2, never()).onError(any(Throwable.class));, +        inOrder2.verifyNoMoreInteractions();, +, +    }, +    @Test, +    public void observeSameOnMultipleSchedulers() {, +        TestScheduler scheduler1 = new TestScheduler();, +        TestScheduler scheduler2 = new TestScheduler();, +        , +        Observable<Integer> o = Observable.from(1, 2, 3);, +        Observable<Integer> o1 = o.observeOn(scheduler1);, +        Observable<Integer> o2 = o.observeOn(scheduler2);, +, +        @SuppressWarnings("unchecked"), +        Observer<Object> observer1 = mock(Observer.class);, +        @SuppressWarnings("unchecked"), +        Observer<Object> observer2 = mock(Observer.class);, +        , +        InOrder inOrder1 = inOrder(observer1);]