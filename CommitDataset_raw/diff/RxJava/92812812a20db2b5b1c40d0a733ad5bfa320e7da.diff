[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +        final AtomicReference<InnerSubscriber<T>[]> subscribers;, +        @SuppressWarnings("unchecked"), +            this.subscribers = new AtomicReference<InnerSubscriber<T>[]>(EMPTY);, +                @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] c = subscribers.get();, +                @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] u = new InnerSubscriber[len + 1];, +        @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] c = subscribers.get();, +                InnerSubscriber<T>[] u;, +        @SuppressWarnings("unchecked"), +, +            // saving a local copy because this will be accessed after every item, +            // delivered to detect changes in the subscribers due to an onNext, +            // and thus not dropping items, +            AtomicReference<InnerSubscriber<T>[]> subscribers = this.subscribers;, +, +            // We take a snapshot of the current child subscribers., +            // Concurrent subscribers may miss this iteration, but it is to be expected, +            InnerSubscriber<T>[] ps = subscribers.get();, +, +            outer:, +                        if (r != CANCELLED) {, +                            maxRequested = Math.min(maxRequested, r - ip.emitted);, +                        } else {, +, +                        boolean subscribersChanged = false;, +, +                            long ipr = ip.get();, +                            if (ipr != CANCELLED) {, +                                if (ipr != Long.MAX_VALUE) {, +                                    ip.emitted++;, +                                }, +                                ip.child.onNext(value);, +                            } else {, +                                subscribersChanged = true;, +, +                        // see if the array of subscribers changed as a consequence, +                        // of emission or concurrent activity, +                        InnerSubscriber<T>[] freshArray = subscribers.get();, +                        if (subscribersChanged || freshArray != ps) {, +                            ps = freshArray;, +                            continue outer;, +                        }, +, +                // get a fresh copy of the current subscribers, +                ps = subscribers.get();, +        /** Track the number of emitted items (avoids decrementing the request counter). */, +        long emitted;, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +        final AtomicReference<InnerSubscriber<T>[]> subscribers;, +        @SuppressWarnings("unchecked"), +            this.subscribers = new AtomicReference<InnerSubscriber<T>[]>(EMPTY);, +                @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] c = subscribers.get();, +                @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] u = new InnerSubscriber[len + 1];, +        @SuppressWarnings("unchecked"), +                InnerSubscriber<T>[] c = subscribers.get();, +                InnerSubscriber<T>[] u;, +        @SuppressWarnings("unchecked"), +, +            // saving a local copy because this will be accessed after every item, +            // delivered to detect changes in the subscribers due to an onNext, +            // and thus not dropping items, +            AtomicReference<InnerSubscriber<T>[]> subscribers = this.subscribers;, +, +            // We take a snapshot of the current child subscribers., +            // Concurrent subscribers may miss this iteration, but it is to be expected, +            InnerSubscriber<T>[] ps = subscribers.get();, +, +            outer:, +                        if (r != CANCELLED) {, +                            maxRequested = Math.min(maxRequested, r - ip.emitted);, +                        } else {, +, +                        boolean subscribersChanged = false;, +, +                            long ipr = ip.get();, +                            if (ipr != CANCELLED) {, +                                if (ipr != Long.MAX_VALUE) {, +                                    ip.emitted++;, +                                }, +                                ip.child.onNext(value);, +                            } else {, +                                subscribersChanged = true;, +, +                        // see if the array of subscribers changed as a consequence, +                        // of emission or concurrent activity, +                        InnerSubscriber<T>[] freshArray = subscribers.get();, +                        if (subscribersChanged || freshArray != ps) {, +                            ps = freshArray;, +                            continue outer;, +                        }, +, +                // get a fresh copy of the current subscribers, +                ps = subscribers.get();, +        /** Track the number of emitted items (avoids decrementing the request counter). */]