[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +  , +  implicit def scalaFuncNToRxFuncN[R](f: Seq[java.lang.Object] => R): FuncN[R] =, +    new FuncN[R] {, +      def call(args: java.lang.Object*): R = f(args), +    }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +  , +  implicit def scalaFuncNToRxFuncN[R](f: Seq[java.lang.Object] => R): FuncN[R] =, +    new FuncN[R] {, +      def call(args: java.lang.Object*): R = f(args), +    }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  // public static <R> Observable<R> zip(Observable<? extends Observable<?>> ws, final FuncN<? extends R> zipFunction) {, +  , +   * Returns an Observable that bypasses all items from the source Observable as long as the specified, +   * condition holds true. Emits all further source items as soon as the condition becomes false., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipWhile.png">, +   *, +   * @param predicate, +   *            A function to test each item emitted from the source Observable for a condition., +   * @return an Observable that emits all items from the source Observable as soon as the condition, +   *         becomes false., +   */, +  def dropWhile(predicate: T => Boolean): Observable[T] = {, +    Observable[T](asJava.skipWhile(predicate)), +  }, +, +  /**, +   * TODO doc&test, +   */, +  def firstOrElse[U >: T](default: => U): Observable[U] = {, +    this.materialize.take(1).map((n: Notification[T]) => {, +      if (n.getKind() == rx.Notification.Kind.OnNext), +        n.getValue, +      else, +        default, +    }), +  }, +  , +  // TODO which of these two find variants do we want?, +  , +  /**, +   * Finds the first element of the list satisfying a predicate, if any., +   * @param p , +   *        the predicate used to test elements., +   * @return an Observable emitting an Option containing the first element in the source , +   *         Observable that satisfies p, or None if none exists or onError was called., +   */  , +  def find(p: T => Boolean): Observable[Option[T]] = {, +    this.filter(p).materialize.take(1).map((n: Notification[T]) => {, +      if (n.getKind() == rx.Notification.Kind.OnNext), +        Some(n.getValue()), +      else, +        None, +    }), +  }, +  , +  /**, +   * Finds the first element of the list satisfying a predicate, if any., +   * @param p , +   *        the predicate used to test elements., +   * @return an Observable emitting an Option containing the first element in the source , +   *         Observable that satisfies p, or None if none exists., +   */  , +  private def findWhichTransmitsError(p: T => Boolean): Observable[Option[T]] = {, +    val o: Observable[Notification[Option[T]]] = , +      this.filter(p).materialize.take(1).map((n: Notification[T]) => {, +      if (n.getKind() == rx.Notification.Kind.OnCompleted), +        Notification(None), +      else if (n.getKind() == rx.Notification.Kind.OnNext), +        Notification(Some(n.getValue())), +      else , +        Notification(n.getThrowable()), +    })    , +    o.dematerialize, +  }, +, +  /**, +  import rx.util.functions._, +  /**, +   * Given a Seq of N observables, returns an observable that emits Seqs of N elements each., +   * The first emitted Seq will contain the first element of each source observable,, +   * the second Seq the second element of each source observable, and so on., +   * , +   * @param observables, +   *            A Seq of source Observables, +   * @return an Observable that emits the zipped Seqs, +   */, +  def zip[T](observables: Seq[Observable[T]]): Observable[Seq[T]] = {, +    val f: FuncN[Seq[T]] = (args: Seq[java.lang.Object]) => {, +      val asSeq: Seq[Object] = args.toSeq, +      asSeq.asInstanceOf[Seq[T]], +    }, +    val list = observables.map(_.asJava).asJava, +    val o = rx.Observable.zip(list, f), +    Observable[Seq[T]](o), +  }, +  ]