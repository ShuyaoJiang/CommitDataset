[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.plugins.RxJavaPlugins;, +        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +        , +                decoratedRun.run();, +        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +        , +                decoratedRun.run();, +            Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +            , +                    decoratedRun.run();, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.plugins.RxJavaPlugins;, +        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +        , +                decoratedRun.run();, +        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +        , +                decoratedRun.run();, +            Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, +            , +                    decoratedRun.run();, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package io.reactivex.internal.schedulers;, +, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicReference;, +, +import io.reactivex.Scheduler;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.*;, +, +/**, + * Holds a fixed pool of worker threads and assigns them, + * to requested Scheduler.Workers in a round-robin fashion. , + */, +public final class ComputationScheduler extends Scheduler {, +    /** Manages a fixed number of workers. */, +    private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool-";, +    private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);, +    /** , +     * Key to setting the maximum number of computation scheduler threads., +     * Zero or less is interpreted as use available. Capped by available., +     */, +    static final String KEY_MAX_THREADS = "rx2.computation-threads";, +    /** The maximum number of computation scheduler threads. */, +    static final int MAX_THREADS;, +    static {, +        int maxThreads = Integer.getInteger(KEY_MAX_THREADS, 0);, +        int ncpu = Runtime.getRuntime().availableProcessors();, +        int max;, +        if (maxThreads <= 0 || maxThreads > ncpu) {, +            max = ncpu;, +        } else {, +            max = maxThreads;, +        }, +        MAX_THREADS = max;, +    }, +    , +    static final PoolWorker SHUTDOWN_WORKER;, +    static {, +        SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory("RxComputationShutdown-"));, +        SHUTDOWN_WORKER.dispose();, +    }, +    , +    static final class FixedSchedulerPool {, +        final int cores;, +, +        final PoolWorker[] eventLoops;, +        long n;, +, +        FixedSchedulerPool(int maxThreads) {, +            // initialize event loops, +            this.cores = maxThreads;, +            this.eventLoops = new PoolWorker[maxThreads];, +            for (int i = 0; i < maxThreads; i++) {, +                this.eventLoops[i] = new PoolWorker(THREAD_FACTORY);, +            }, +        }, +, +        public PoolWorker getEventLoop() {, +            int c = cores;, +            if (c == 0) {, +                return SHUTDOWN_WORKER;, +            }]