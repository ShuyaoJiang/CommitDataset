[+++ b/CHANGES.md, +                while (s.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +                while (subscriber.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +++ b/CHANGES.md, +                while (s.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +                while (subscriber.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java, +        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();, +++ b/CHANGES.md, +                while (s.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +                while (subscriber.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java, +        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();, +++ b/rxjava-core/src/main/java/rx/operators/OperationToFuture.java, +import java.util.concurrent.CancellationException;, +                } else if (cancelled) {, +                    // Contract of Future.get() requires us to throw this:, +                    throw new CancellationException("Subscription unsubscribed");, +++ b/CHANGES.md, +                while (s.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +                while (subscriber.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java, +        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();, +++ b/rxjava-core/src/main/java/rx/operators/OperationToFuture.java, +import java.util.concurrent.CancellationException;, +                } else if (cancelled) {, +                    // Contract of Future.get() requires us to throw this:, +                    throw new CancellationException("Subscription unsubscribed");, +++ b/rxjava-core/src/test/java/rx/operators/OperationToFutureTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static rx.operators.OperationToFuture.toFuture;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.TimeUnit;, +import rx.Subscriber;, +    @Test(expected=CancellationException.class), +    public void testGetAfterCancel() throws Exception {, +        Observable<String> obs = Observable.create(new OperationNeverComplete<String>());, +        Future<String> f = toFuture(obs);, +        boolean cancelled = f.cancel(true);, +        assertTrue(cancelled);  // because OperationNeverComplete never does, +        f.get();                // Future.get() docs require this to throw, +    }, +, +    @Test(expected=CancellationException.class), +    public void testGetWithTimeoutAfterCancel() throws Exception {, +        Observable<String> obs = Observable.create(new OperationNeverComplete<String>());, +        Future<String> f = toFuture(obs);, +        boolean cancelled = f.cancel(true);, +        assertTrue(cancelled);  // because OperationNeverComplete never does, +        f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);    // Future.get() docs require this to throw, +    }, +, +    /**, +     * Emits no observations. Used to simulate a long-running asynchronous operation., +     */, +    private static class OperationNeverComplete<T> implements Observable.OnSubscribe<T> {, +        @Override, +        public void call(Subscriber<? super T> unused) {, +            // do nothing, +        }, +    }, +, +++ b/CHANGES.md, +                while (s.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +                while (subscriber.isUnsubscribed()) {, +        while (subscriber.isUnsubscribed()) {, +++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java, +        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();, +++ b/rxjava-core/src/main/java/rx/operators/OperationToFuture.java, +import java.util.concurrent.CancellationException;, +                } else if (cancelled) {, +                    // Contract of Future.get() requires us to throw this:, +                    throw new CancellationException("Subscription unsubscribed");, +++ b/rxjava-core/src/test/java/rx/operators/OperationToFutureTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static rx.operators.OperationToFuture.toFuture;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.TimeUnit;, +import rx.Subscriber;, +    @Test(expected=CancellationException.class), +    public void testGetAfterCancel() throws Exception {, +        Observable<String> obs = Observable.create(new OperationNeverComplete<String>());, +        Future<String> f = toFuture(obs);, +        boolean cancelled = f.cancel(true);, +        assertTrue(cancelled);  // because OperationNeverComplete never does, +        f.get();                // Future.get() docs require this to throw, +    }]