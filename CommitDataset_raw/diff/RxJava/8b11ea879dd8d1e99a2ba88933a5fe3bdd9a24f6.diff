[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +     * <p>, +     * Undeliverable errors are those {@code Observer.onError()} invocations that are not allowed to happen on, +     * the given consumer type ({@code Observer}, {@code Subscriber}, etc.) due to protocol restrictions, +     * because the consumer has either disposed/cancelled its {@code Disposable}/{@code Subscription} or, +     * has already terminated with an {@code onError()} or {@code onComplete()} signal., +     * <p>, +     * By default, this global error handler prints the stacktrace via {@link Throwable#printStackTrace()}, +     * and calls {@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)}, +     * on the current thread., +     * <p>, +     * Note that on some platforms, the platform runtime terminates the current application with an error if such, +     * uncaught exceptions happen. In this case, it is recommended the application installs a global error, +     * handler via the {@link #setErrorHandler(Consumer)} plugin method., +     *, +     * @see #getErrorHandler(), +     * @see #setErrorHandler(Consumer), +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling">Error handling Wiki</a>, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +     * <p>, +     * Undeliverable errors are those {@code Observer.onError()} invocations that are not allowed to happen on, +     * the given consumer type ({@code Observer}, {@code Subscriber}, etc.) due to protocol restrictions, +     * because the consumer has either disposed/cancelled its {@code Disposable}/{@code Subscription} or, +     * has already terminated with an {@code onError()} or {@code onComplete()} signal., +     * <p>, +     * By default, this global error handler prints the stacktrace via {@link Throwable#printStackTrace()}, +     * and calls {@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)}, +     * on the current thread., +     * <p>, +     * Note that on some platforms, the platform runtime terminates the current application with an error if such, +     * uncaught exceptions happen. In this case, it is recommended the application installs a global error, +     * handler via the {@link #setErrorHandler(Consumer)} plugin method., +     *, +     * @see #getErrorHandler(), +     * @see #setErrorHandler(Consumer), +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling">Error handling Wiki</a>, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + * {@code BehaviorProcessor} can be created via the {@link #create()} method and, + * if the processor is used as a standalone source. However, calling {@code onSubscribe}, + * after the {@code BehaviorProcessor} reached its terminal state will result in the, + * consuming this processor also wants to call {@link #onNext(Object)} on this processor recursively)., + *  <dt><b>Error handling:</b></dt>, + *  <dd>When the {@link #onError(Throwable)} is called, the {@code BehaviorProcessor} enters into a terminal state, + *  and emits the same {@code Throwable} instance to the last set of {@code Subscriber}s. During this emission,, + *  if one or more {@code Subscriber}s cancel their respective {@code Subscription}s, the, + *  {@code Throwable} is delivered to the global error handler via, + *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} (multiple times if multiple {@code Subscriber}s, + *  cancel at once)., + *  If there were no {@code Subscriber}s subscribed to this {@code BehaviorProcessor} when the {@code onError()}, + *  was called, the global error handler is not invoked., + *  </dd>, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +     * <p>, +     * Undeliverable errors are those {@code Observer.onError()} invocations that are not allowed to happen on, +     * the given consumer type ({@code Observer}, {@code Subscriber}, etc.) due to protocol restrictions, +     * because the consumer has either disposed/cancelled its {@code Disposable}/{@code Subscription} or, +     * has already terminated with an {@code onError()} or {@code onComplete()} signal., +     * <p>, +     * By default, this global error handler prints the stacktrace via {@link Throwable#printStackTrace()}, +     * and calls {@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)}, +     * on the current thread., +     * <p>, +     * Note that on some platforms, the platform runtime terminates the current application with an error if such, +     * uncaught exceptions happen. In this case, it is recommended the application installs a global error, +     * handler via the {@link #setErrorHandler(Consumer)} plugin method., +     *, +     * @see #getErrorHandler(), +     * @see #setErrorHandler(Consumer), +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling">Error handling Wiki</a>, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + * {@code BehaviorProcessor} can be created via the {@link #create()} method and, + * if the processor is used as a standalone source. However, calling {@code onSubscribe}, + * after the {@code BehaviorProcessor} reached its terminal state will result in the, + * consuming this processor also wants to call {@link #onNext(Object)} on this processor recursively)., + *  <dt><b>Error handling:</b></dt>, + *  <dd>When the {@link #onError(Throwable)} is called, the {@code BehaviorProcessor} enters into a terminal state, + *  and emits the same {@code Throwable} instance to the last set of {@code Subscriber}s. During this emission,, + *  if one or more {@code Subscriber}s cancel their respective {@code Subscription}s, the, + *  {@code Throwable} is delivered to the global error handler via, + *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} (multiple times if multiple {@code Subscriber}s, + *  cancel at once)., + *  If there were no {@code Subscriber}s subscribed to this {@code BehaviorProcessor} when the {@code onError()}, + *  was called, the global error handler is not invoked., + *  </dd>, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, + * This subject does not have a public constructor by design; a new empty instance of this, + * {@code BehaviorSubject} can be created via the {@link #create()} method and, + * a new non-empty instance can be created via {@link #createDefault(Object)} (named as such to avoid, + * overload resolution conflict with {@code Observable.create} that creates an Observable, not a {@code BehaviorSubject})., + * <p>, + * Since the {@code Subject} is conceptionally derived from the {@code Processor} type in the Reactive Streams specification,, + * {@code null}s are not allowed (<a href="https://github.com/reactive-streams/reactive-streams-jvm#2.13">Rule 2.13</a>) as, + * default initial values in {@link #createDefault(Object)} or as parameters to {@link #onNext(Object)} and, + * {@link #onError(Throwable)}., + * <p>, + * Since a {@code BehaviorSubject} is an {@link io.reactivex.Observable}, it does not support backpressure., + * <p>, + * When this {@code BehaviorSubject} is terminated via {@link #onError(Throwable)} or {@link #onComplete()}, the, + * last observed item (if any) is cleared and late {@link io.reactivex.Observer}s only receive, + * the respective terminal event.]