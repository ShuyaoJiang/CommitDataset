[+++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.util.AtomicObservableSubscription;, +import rx.util.SynchronizedObserver;, +, +            /**, +             * We must synchronize a merge because we subscribe to multiple sequences in parallel that will each be emitting., +             * <p>, +             * The calls from each sequence must be serialized., +             * <p>, +             * Bug report: https://github.com/Netflix/RxJava/issues/200, +             */, +            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, new AtomicObservableSubscription(ourSubscription));, +, +            sequences.subscribe(new ParentObserver(synchronizedObserver));, +        @Test, +        public void testSynchronizationOfMultipleSequences() throws Exception {, +            final TestASynchronousObservable o1 = new TestASynchronousObservable();, +            final TestASynchronousObservable o2 = new TestASynchronousObservable();, +, +            // use this latch to cause onNext to wait until we're ready to let it go, +            final CountDownLatch endLatch = new CountDownLatch(1);, +, +            final AtomicInteger concurrentCounter = new AtomicInteger();, +            final AtomicInteger totalCounter = new AtomicInteger();, +, +            @SuppressWarnings("unchecked"), +            Observable<String> m = Observable.create(merge(o1, o2));, +            m.subscribe(new Observer<String>() {, +, +                @Override, +                public void onCompleted() {, +, +                }, +, +                @Override, +                public void onError(Exception e) {, +                    throw new RuntimeException("failed", e);, +                }, +, +                @Override, +                public void onNext(String v) {, +                    totalCounter.incrementAndGet();, +                    concurrentCounter.incrementAndGet();, +                    try {, +                        // wait here until we're done asserting, +                        endLatch.await();, +                    } catch (InterruptedException e) {, +                        e.printStackTrace();, +                        throw new RuntimeException("failed", e);, +                    } finally {, +                        concurrentCounter.decrementAndGet();, +                    }, +                }, +, +            });, +, +            // wait for both observables to send (one should be blocked), +            o1.onNextBeingSent.await();, +            o2.onNextBeingSent.await();, +            , +            assertEquals(1, concurrentCounter.get());, +, +            // release so it can finish, +            endLatch.countDown();, +, +            try {, +                o1.t.join();, +                o2.t.join();, +            } catch (InterruptedException e) {, +                throw new RuntimeException(e);, +            }, +, +            assertEquals(2, totalCounter.get());, +            assertEquals(0, concurrentCounter.get());, +        }, +, +            final CountDownLatch onNextBeingSent = new CountDownLatch(1);, +                        onNextBeingSent.countDown();, +++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.util.AtomicObservableSubscription;, +import rx.util.SynchronizedObserver;, +, +            /**, +             * We must synchronize a merge because we subscribe to multiple sequences in parallel that will each be emitting., +             * <p>, +             * The calls from each sequence must be serialized., +             * <p>, +             * Bug report: https://github.com/Netflix/RxJava/issues/200, +             */, +            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, new AtomicObservableSubscription(ourSubscription));, +, +            sequences.subscribe(new ParentObserver(synchronizedObserver));, +        @Test, +        public void testSynchronizationOfMultipleSequences() throws Exception {, +            final TestASynchronousObservable o1 = new TestASynchronousObservable();, +            final TestASynchronousObservable o2 = new TestASynchronousObservable();]