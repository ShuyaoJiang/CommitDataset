[+++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +import static rx.operators.AbstractOperation.UnitTest.*;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, +++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +import static rx.operators.AbstractOperation.UnitTest.*;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +                Boolean isSelected;, +                try {, +                    isSelected = predicate.call(args, counter.getAndIncrement());, +                }, +                catch (Exception e) {, +                    observer.onError(e);, +                    return;, +                }, +                if (isSelected) {, +            Subject<Integer> s = Subject.create();, +            Observable<Integer> w = (Observable<Integer>)s;, +        public void testTakeWhileProtectsPredicateCall() {, +            TestObservable source = new TestObservable(mock(Subscription.class), "one");, +            final RuntimeException testException = new RuntimeException("test exception");, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            Observable<String> take = Observable.create(takeWhile(source, new Func1<String, Boolean>(), +            {, +                @Override, +                public Boolean call(String s), +                {, +                    throw testException;, +                }, +            }));, +            take.subscribe(aObserver);, +, +            // wait for the Observable to complete, +            try {, +                source.t.join();, +            } catch (Exception e) {, +                e.printStackTrace();, +                fail(e.getMessage());, +            }, +, +            verify(aObserver, never()).onNext(any(String.class));, +            verify(aObserver, times(1)).onError(testException);, +        }, +, +        @Test, +++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +import static rx.operators.AbstractOperation.UnitTest.*;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +                Boolean isSelected;, +                try {, +                    isSelected = predicate.call(args, counter.getAndIncrement());, +                }, +                catch (Exception e) {, +                    observer.onError(e);, +                    return;, +                }, +                if (isSelected) {, +            Subject<Integer> s = Subject.create();, +            Observable<Integer> w = (Observable<Integer>)s;, +        public void testTakeWhileProtectsPredicateCall() {, +            TestObservable source = new TestObservable(mock(Subscription.class), "one");, +            final RuntimeException testException = new RuntimeException("test exception");, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            Observable<String> take = Observable.create(takeWhile(source, new Func1<String, Boolean>(), +            {, +                @Override, +                public Boolean call(String s), +                {, +                    throw testException;, +                }, +            }));, +            take.subscribe(aObserver);, +, +            // wait for the Observable to complete]