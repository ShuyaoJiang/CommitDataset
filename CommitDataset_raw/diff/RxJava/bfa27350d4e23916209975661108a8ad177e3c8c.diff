[+++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy, +import java.util.concurrent.atomic.AtomicBoolean;, +        AtomicBoolean isRunning = new AtomicBoolean(true); , +                    if(!isRunning.get()) {, +                        // we have received an unsubscribe, +                        break;, +                    }, +                    //println("****** emitting list: " + i), +        return Observable.createSubscription({, +            // see https://github.com/Netflix/RxJava/issues/173 for a possibly simpler way of doing this, +            isRunning.set(false);, +        });, +            // NOTE: This will always execute all 50 even if take(2) asks for only 2, +            //       as it performs synchronously and is not lazy., +                //println("emitting video: " + i), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy, +import java.util.concurrent.atomic.AtomicBoolean;, +        AtomicBoolean isRunning = new AtomicBoolean(true); , +                    if(!isRunning.get()) {, +                        // we have received an unsubscribe, +                        break;, +                    }, +                    //println("****** emitting list: " + i), +        return Observable.createSubscription({, +            // see https://github.com/Netflix/RxJava/issues/173 for a possibly simpler way of doing this, +            isRunning.set(false);, +        });, +            // NOTE: This will always execute all 50 even if take(2) asks for only 2, +            //       as it performs synchronously and is not lazy., +                //println("emitting video: " + i), +++ b/rxjava-core/src/main/java/rx/GroupedObservable.java, +package rx;, +, +import rx.util.functions.*;, +, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +, +public class GroupedObservable<K, T> extends Observable<T> {, +    private final K key;, +    private final Observable<T> delegate;, +, +    public GroupedObservable(K key, Observable<T> delegate) {, +        this.key = key;, +        this.delegate = delegate;, +    }, +, +    public K getKey() {, +        return key;, +    }, +, +    public Subscription subscribe(Observer<T> observer) {, +        return delegate.subscribe(observer);, +    }, +, +    @Override, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public Subscription subscribe(Map<String, Object> callbacks) {, +        return delegate.subscribe(callbacks);, +    }, +, +    @Override, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public Subscription subscribe(Object o) {, +        return delegate.subscribe(o);, +    }, +, +    public Subscription subscribe(Action1<T> onNext) {, +        return delegate.subscribe(onNext);, +    }, +, +    @Override, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public Subscription subscribe(Object onNext, Object onError) {, +        return delegate.subscribe(onNext, onError);, +    }, +, +    public Subscription subscribe(Action1<T> onNext, Action1<Exception> onError) {, +        return delegate.subscribe(onNext, onError);, +    }, +, +    @Override, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public Subscription subscribe(Object onNext, Object onError, Object onComplete) {, +        return delegate.subscribe(onNext, onError, onComplete);, +    }, +, +    public Subscription subscribe(Action1<T> onNext, Action1<Exception> onError, Action0 onComplete) {, +        return delegate.subscribe(onNext, onError, onComplete);, +    }, +, +    public void forEach(Action1<T> onNext) {, +        delegate.forEach(onNext);, +    }, +, +    @Override, +    @SuppressWarnings({ "rawtypes", "unchecked" }), +    public void forEach(Object o) {]