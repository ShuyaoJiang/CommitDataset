[+++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // only execute this from schedule(), +            do {, +                /*, +                 * Set to 1 otherwise it could have grown very large while in the last poll loop, +                 * and then we can end up looping all those times again here before exiting even once we've drained, +                 */, +                COUNTER_UPDATER.set(this, 1);, +, +                    if (failure) {, +                        // special handling to short-circuit an error propagation, +                        Object o = queue.poll();, +                        // completed so we will skip onNext if they exist and only emit terminal events, +                        if (on.isError(o)) {, +                            // only emit error, +                            on.accept(child, o);, +                            // we have emitted a terminal event so return (exit the loop we're in), +                            return;, +                        }, +                    } else {, +                }, +            } while (COUNTER_UPDATER.decrementAndGet(this) > 0);, +, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // only execute this from schedule(), +            do {, +                /*, +                 * Set to 1 otherwise it could have grown very large while in the last poll loop, +                 * and then we can end up looping all those times again here before exiting even once we've drained, +                 */, +                COUNTER_UPDATER.set(this, 1);, +, +                    if (failure) {, +                        // special handling to short-circuit an error propagation, +                        Object o = queue.poll();, +                        // completed so we will skip onNext if they exist and only emit terminal events, +                        if (on.isError(o)) {, +                            // only emit error, +                            on.accept(child, o);, +                            // we have emitted a terminal event so return (exit the loop we're in), +                            return;, +                        }, +                    } else {, +                }, +            } while (COUNTER_UPDATER.decrementAndGet(this) > 0);, +, +++ b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java, +import org.junit.Ignore;, +import rx.Notification;, +import rx.functions.Func2;, +, +    /**, +     * Make sure we get a MissingBackpressureException propagated through when we have a fast temporal (hot) producer., +     */, +    @Test, +    public void testHotOperatorBackpressure() {, +        TestSubscriber<String> ts = new TestSubscriber<String>();, +        Observable.timer(0, 1, TimeUnit.MICROSECONDS), +                .observeOn(Schedulers.computation()), +                .map(new Func1<Long, String>() {, +, +                    @Override, +                    public String call(Long t1) {, +                        System.out.println(t1);, +                        try {, +                            Thread.sleep(100);, +                        } catch (InterruptedException e) {, +                        }, +                        return t1 + " slow value";, +                    }, +, +                }).subscribe(ts);, +, +        ts.awaitTerminalEvent();, +        System.out.println("Errors: " + ts.getOnErrorEvents());, +        assertEquals(1, ts.getOnErrorEvents().size());, +        assertEquals(MissingBackpressureException.class, ts.getOnErrorEvents().get(0).getClass());, +    }, +, +    @Test, +    public void testErrorPropagatesWhenNoOutstandingRequests() {, +        Observable<Long> timer = Observable.timer(0, 1, TimeUnit.MICROSECONDS), +                .doOnEach(new Action1<Notification<? super Long>>() {, +, +                    @Override, +                    public void call(Notification<? super Long> n) {, +                        //                        System.out.println("BEFORE " + n);, +                    }, +, +                }), +                .observeOn(Schedulers.newThread()), +                .doOnEach(new Action1<Notification<? super Long>>() {, +, +                    @Override, +                    public void call(Notification<? super Long> n) {, +                        //                        System.out.println("AFTER " + n);, +                    }, +, +                });, +]