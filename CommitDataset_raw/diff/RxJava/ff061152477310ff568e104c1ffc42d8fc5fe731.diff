[+++ b/src/main/java/io/reactivex/Observable.java, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        Objects.requireNonNull(biFunction);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +     // the internal buffer holds pairs of (timestamp, value) so double the default buffer size, +        int s = bufferSize << 1; , +        return lift(new OperatorSkipLastTimed<>(time, unit, scheduler, s, delayError));, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        validateBufferSize(bufferSize);, +        return create(new PublisherSequenceEqual<>(p1, p2, isEqual, bufferSize));, +    }, +, +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, +        return combineLatest(sources, combiner, false, bufferSize());, +    }, +, +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, +        return combineLatest(sources, combiner, delayError, bufferSize());, +    }, +, +    @SafeVarargs, +    public static <T, R> Observable<R> combineLatest(Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize, Publisher<? extends T>... sources) {, +        return combineLatest(sources, combiner, delayError, bufferSize);, +    }, +    , +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {, +        validateBufferSize(bufferSize);, +        Objects.requireNonNull(combiner);, +        if (sources.length == 0) {, +            return empty();, +        }, +        // the queue holds a pair of values so we need to double the capacity, +        int s = bufferSize << 1;, +        return create(new PublisherCombineLatest<>(sources, null, combiner, s, delayError));, +    }, +, +    public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner) {, +        return combineLatest(sources, combiner, false, bufferSize());, +    }, +    , +    public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, +        return combineLatest(sources, combiner, delayError, bufferSize());, +    }, +    , +    public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {, +        Objects.requireNonNull(sources);, +        Objects.requireNonNull(combiner);, +        validateBufferSize(bufferSize);, +        , +        // the queue holds a pair of values so we need to double the capacity, +        int s = bufferSize << 1;, +        return create(new PublisherCombineLatest<>(null, sources, combiner, s, delayError));, +    }, +, +    private static void validateBufferSize(int bufferSize) {, +, +    public static <T1, T2, R> Observable<R> combineLatest(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            BiFunction<? super T1, ? super T2, ? extends R> combiner) {, +        Function<Object[], R> f = toFunction(combiner);, +        return combineLatest(f, false, bufferSize(), p1, p2);, +    }, +, +    public static <T1, T2, T3, R> Observable<R> combineLatest(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            Publisher<? extends T3> p3, , +            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {, +        return combineLatest(combiner, false, bufferSize(), p1, p2, p3);, +    }, +, +    public static <T1, T2, T3, T4, R> Observable<R> combineLatest(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            Publisher<? extends T3> p3, Publisher<? extends T4> p4,, +            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {, +        return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4);, +    }, +, +    public static <T1, T2, T3, T4, T5, R> Observable<R> combineLatest(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            Publisher<? extends T3> p3, Publisher<? extends T4> p4,, +            Publisher<? extends T5> p5,, +            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {, +        return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5);, +    }, +, +    public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            Publisher<? extends T3> p3, Publisher<? extends T4> p4,, +            Publisher<? extends T5> p5, Publisher<? extends T6> p6,, +            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {, +        return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5, p6);, +    }, +]