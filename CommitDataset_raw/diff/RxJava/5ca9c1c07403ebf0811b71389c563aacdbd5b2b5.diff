[+++ b/rxjava-core/src/main/java/rx/operators/OperationMap.java, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import java.util.concurrent.CountDownLatch;, +import rx.concurrency.Schedulers;, +        return mapWithIndex(sequence, new Func2<T, Integer, R>() {, +                });, +            final SafeObservableSubscription subscription = new SafeObservableSubscription();, +            return subscription.wrap(sequence.subscribe(new SafeObserver<T>(subscription, new Observer<T>() {, +            })));, +        @Test(expected = IllegalArgumentException.class), +        public void testMapWithIssue417() {, +            Observable.from(1).observeOn(Schedulers.threadPoolForComputation()), +            .map(new Func1<Integer, Integer>() {, +                public Integer call(Integer arg0) {, +                    throw new IllegalArgumentException("any error");, +                }, +            }).toBlockingObservable().single();, +        }, +, +        @Test, +        public void testMapWithErrorInFuncAndThreadPoolScheduler() throws InterruptedException {, +            // The error will throw in one of threads in the thread pool., +            // If map does not handle it, the error will disappear., +            // so map needs to handle the error by itself., +            final CountDownLatch latch = new CountDownLatch(1);, +            Observable<String> m = Observable.from("one"), +                    .observeOn(Schedulers.threadPoolForComputation()), +                    .map(new Func1<String, String>() {, +                        public String call(String arg0) {, +                            try {, +                                throw new IllegalArgumentException("any error");, +                            } finally {, +                                latch.countDown();, +                            }, +                        }, +                    });, +, +            m.subscribe(stringObserver);, +            latch.await();, +            InOrder inorder = inOrder(stringObserver);, +            inorder.verify(stringObserver, times(1)).onError(any(IllegalArgumentException.class));, +            inorder.verifyNoMoreInteractions();, +        }, +]