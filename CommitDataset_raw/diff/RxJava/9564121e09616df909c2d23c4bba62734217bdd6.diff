[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.plugins.RxJavaPlugins;, +    protected void subscribeActual(SingleObserver<? super T> observer) {, +        Disposable d = Disposables.empty();, +        observer.onSubscribe(d);, +        if (d.isDisposed()) {, +            return;, +        }, +        T value;, +, +            value = ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");, +        } catch (Throwable ex) {, +            Exceptions.throwIfFatal(ex);, +            if (!d.isDisposed()) {, +                observer.onError(ex);, +                RxJavaPlugins.onError(ex);, +            return;, +        if (!d.isDisposed()) {, +            observer.onSuccess(value);, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.plugins.RxJavaPlugins;, +    protected void subscribeActual(SingleObserver<? super T> observer) {, +        Disposable d = Disposables.empty();, +        observer.onSubscribe(d);, +        if (d.isDisposed()) {, +            return;, +        }, +        T value;, +, +            value = ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");, +        } catch (Throwable ex) {, +            Exceptions.throwIfFatal(ex);, +            if (!d.isDisposed()) {, +                observer.onError(ex);, +                RxJavaPlugins.onError(ex);, +            return;, +        if (!d.isDisposed()) {, +            observer.onSuccess(value);, +        }, +    }, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableFromCallableTest.java, +import java.util.concurrent.CountDownLatch;, +, +import io.reactivex.Observable;, +import io.reactivex.Observer;, +import io.reactivex.TestHelper;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.observers.TestObserver;, +import io.reactivex.schedulers.Schedulers;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import static org.mockito.ArgumentMatchers.any;, +import static org.mockito.Mockito.*;, +, +    @SuppressWarnings("unchecked"), +    @Test, +    public void shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission() throws Exception {, +        Callable<String> func = mock(Callable.class);, +, +        final CountDownLatch funcLatch = new CountDownLatch(1);, +        final CountDownLatch observerLatch = new CountDownLatch(1);, +, +        when(func.call()).thenAnswer(new Answer<String>() {, +            @Override, +            public String answer(InvocationOnMock invocation) throws Throwable {, +                observerLatch.countDown();, +, +                try {, +                    funcLatch.await();, +                } catch (InterruptedException e) {, +                    // It's okay, unsubscription causes Thread interruption, +, +                    // Restoring interruption status of the Thread, +                    Thread.currentThread().interrupt();, +                }, +, +                return "should_not_be_delivered";, +            }, +        });, +, +        Completable fromCallableObservable = Completable.fromCallable(func);, +, +        Observer<Object> observer = TestHelper.mockObserver();, +, +        TestObserver<String> outer = new TestObserver<String>(observer);, +, +        fromCallableObservable, +                .subscribeOn(Schedulers.computation()), +                .subscribe(outer);, +, +        // Wait until func will be invoked, +        observerLatch.await();]