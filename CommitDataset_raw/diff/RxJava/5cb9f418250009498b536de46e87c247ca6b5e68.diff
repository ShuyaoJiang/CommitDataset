[+++ b/src/main/java/rx/functions/Actions.java, +    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {, +    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements, +++ b/src/main/java/rx/functions/Actions.java, +    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {, +    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/functions/Actions.java, +    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {, +    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            Thread.currentThread().interrupt();, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +++ b/src/main/java/rx/functions/Actions.java, +    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {, +    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            Thread.currentThread().interrupt();, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +++ b/src/test/java/rx/internal/operators/BlockingOperatorNextTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static rx.internal.operators.BlockingOperatorNext.next;, +import org.junit.Assert;, +import org.junit.Test;, +, +import rx.internal.operators.BlockingOperatorNext;, +++ b/src/main/java/rx/functions/Actions.java, +    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {, +    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            Thread.currentThread().interrupt();, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +++ b/src/test/java/rx/internal/operators/BlockingOperatorNextTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static rx.internal.operators.BlockingOperatorNext.next;, +import org.junit.Assert;, +import org.junit.Test;, +, +import rx.internal.operators.BlockingOperatorNext;, +++ b/src/test/java/rx/observables/BlockingObservableTest.java]