[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +import io.reactivex.plugins.RxJavaPlugins;, +        boolean done;, +, +            if (done) {, +                return;, +            }, +                    onError(e);, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            done = true;, +            if (done) {, +                return;, +            }, +            done = true;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +import io.reactivex.plugins.RxJavaPlugins;, +        boolean done;, +, +            if (done) {, +                return;, +            }, +                    onError(e);, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            done = true;, +            if (done) {, +                return;, +            }, +            done = true;, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java, +import java.util.concurrent.CopyOnWriteArrayList;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.plugins.RxJavaPlugins;, +    , +    @Test, +    public void testScanFunctionThrowsAndUpstreamErrorsDoesNotResultInTwoTerminalEvents() {, +        final RuntimeException err = new RuntimeException();, +        final RuntimeException err2 = new RuntimeException();, +        final List<Throwable> list = new CopyOnWriteArrayList<Throwable>();, +        final Consumer<Throwable> errorConsumer = new Consumer<Throwable>() {, +            @Override, +            public void accept(Throwable t) throws Exception {, +                list.add(t);, +            }};, +        try {, +            RxJavaPlugins.setErrorHandler(errorConsumer);, +            Observable.unsafeCreate(new ObservableSource<Integer>() {, +                @Override, +                public void subscribe(Observer<? super Integer> o) {, +                    Disposable d = Disposables.empty();, +                    o.onSubscribe(d);, +                    o.onNext(1);, +                    o.onNext(2);, +                    o.onError(err2);, +                }}), +            .scan(new BiFunction<Integer,Integer,Integer>() {, +                @Override, +                public Integer apply(Integer t1, Integer t2) throws Exception {, +                    throw err;, +                }}), +            .test(), +            .assertError(err), +            .assertValue(1);, +        } finally {, +            RxJavaPlugins.reset();, +        }, +    }, +    , +    @Test, +    public void testScanFunctionThrowsAndUpstreamCompletesDoesNotResultInTwoTerminalEvents() {, +        final RuntimeException err = new RuntimeException();, +        Observable.unsafeCreate(new ObservableSource<Integer>() {, +            @Override, +            public void subscribe(Observer<? super Integer> o) {, +                Disposable d = Disposables.empty();, +                o.onSubscribe(d);, +                o.onNext(1);, +                o.onNext(2);, +                o.onComplete();, +            }}), +        .scan(new BiFunction<Integer,Integer,Integer>() {, +            @Override, +            public Integer apply(Integer t1, Integer t2) throws Exception {, +                throw err;, +            }}), +        .test(), +        .assertError(err), +        .assertValue(1);, +    }, +    , +    @Test, +    public void testScanFunctionThrowsAndUpstreamEmitsOnNextResultsInScanFunctionBeingCalledOnlyOnce() {, +        final RuntimeException err = new RuntimeException();, +        final AtomicInteger count = new AtomicInteger();]