[+++ b/src/main/java/io/reactivex/Observable.java, +    , +++ b/src/main/java/io/reactivex/Observable.java, +    , +++ b/src/main/java/io/reactivex/internal/operators/PublisherRefCount.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.concurrent.atomic.*;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.function.Consumer;, +, +import org.reactivestreams.*;, +, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.SetCompositeResource;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.observables.ConnectableObservable;, +, +/**, + * Returns an observable sequence that stays connected to the source as long as, + * there is at least one subscription to the observable sequence., + * , + * @param <T>, + *            the value type, + */, +public final class PublisherRefCount<T> implements Publisher<T> {, +, +    final class ConnectionSubscriber implements Subscriber<T>, Subscription {, +        final Subscriber<? super T> subscriber;, +        final SetCompositeResource<Disposable> currentBase;, +        final Disposable resource;, +, +        Subscription s;, +        , +        private ConnectionSubscriber(Subscriber<? super T> subscriber,, +                SetCompositeResource<Disposable> currentBase, Disposable resource) {, +            this.subscriber = subscriber;, +            this.currentBase = currentBase;, +            this.resource = resource;, +        }, +, +        @Override, +        public void onSubscribe(Subscription s) {, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +                return;, +            }, +            this.s = s;, +            subscriber.onSubscribe(this);, +        }, +, +        @Override, +        public void onError(Throwable e) {, +            cleanup();, +            subscriber.onError(e);, +        }, +, +        @Override, +        public void onNext(T t) {, +            subscriber.onNext(t);, +        }, +, +        @Override, +        public void onComplete() {, +            cleanup();, +            subscriber.onComplete();, +        }, +        , +        @Override, +        public void request(long n) {, +            s.request(n);, +        }, +        , +        @Override, +        public void cancel() {, +            s.cancel();, +            resource.dispose();, +        }, +, +        void cleanup() {, +            // on error or completion we need to unsubscribe the base subscription, +            // and set the subscriptionCount to 0 , +            lock.lock();, +            try {, +                if (baseSubscription == currentBase) {, +                    baseSubscription.dispose();, +                    baseSubscription = new SetCompositeResource<>(Disposable::dispose);, +                    subscriptionCount.set(0);]