[+++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios., +++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios., +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +, +    @Override, +    public void accept(Observer<? super V> a, U v) {, +        // ignored by default, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios., +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +, +    @Override, +    public void accept(Observer<? super V> a, U v) {, +        // ignored by default, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java, +                if (de != null) {, +                }, +++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios., +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +, +    @Override, +    public void accept(Observer<? super V> a, U v) {, +        // ignored by default, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java, +                if (de != null) {, +                }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java, +                if (t.isOnError()) {, +                    RxJavaPlugins.onError(t.getError());, +                }, +++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios., +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +, +    @Override, +    public void accept(Observer<? super V> a, U v) {, +        // ignored by default, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java, +                if (de != null) {, +                }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java, +                if (t.isOnError()) {, +                    RxJavaPlugins.onError(t.getError());, +                }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java, +                } else {, +                }, +++ b/src/main/java/io/reactivex/Observable.java, +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, +     * on the other side of the asynchronous boundary., +     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., +     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed]