[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Groups the items emitted by this Observable according to a specified discriminator function., +   * @param f, +   *            the type of keys returned by the discriminator function., +   * @return an Observable that emits {@code (key, observable)} pairs, where {@code observable}, +   *         contains all items for which {@code f} returned {@code key}., +  def groupBy[K](f: T => K): Observable[(K, Observable[T])] = {, +    val o1 = asJava.groupBy[K](f) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]] , +    val func = (o: rx.observables.GroupedObservable[K, _ <: T]) => (o.getKey(), Observable[T](o)), +    Observable[(K, Observable[T])](o1.map[(K, Observable[T])](func)), +  // There's no method corresponding to, +  // public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) , +  // because this can be obtained by combining groupBy and map (as in Scala), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Groups the items emitted by this Observable according to a specified discriminator function., +   * @param f, +   *            the type of keys returned by the discriminator function., +   * @return an Observable that emits {@code (key, observable)} pairs, where {@code observable}, +   *         contains all items for which {@code f} returned {@code key}., +  def groupBy[K](f: T => K): Observable[(K, Observable[T])] = {, +    val o1 = asJava.groupBy[K](f) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]] , +    val func = (o: rx.observables.GroupedObservable[K, _ <: T]) => (o.getKey(), Observable[T](o)), +    Observable[(K, Observable[T])](o1.map[(K, Observable[T])](func)), +  // There's no method corresponding to, +  // public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) , +  // because this can be obtained by combining groupBy and map (as in Scala), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.lang.scala, +, +/**, + * This is the old Scala adaptor. It is kept here for backwards compatibility., + * The new adaptor is {@code rx.lang.scala.Observable}., + */, +@deprecated("use rx.lang.scala.Observable instead", "0.14"), +object RxImplicits {, +    import java.{ lang => jlang }, +    import language.implicitConversions, +, +    import rx.{ Observable, Observer, Subscription }, +    import rx.Observable.OnSubscribeFunc, +    import rx.observables.BlockingObservable, +    import rx.util.functions._, +    , +    /**, +     * Converts 0-arg function to Rx Action0, +     */, +    implicit def scalaFunction0ProducingUnitToAction0(f: (() => Unit)): Action0 =, +        new Action0 {, +            def call(): Unit = f(), +        }, +    , +    /**, +     * Converts 1-arg function to Rx Action1, +     */, +    implicit def scalaFunction1ProducingUnitToAction1[A](f: (A => Unit)): Action1[A] =, +        new Action1[A] {, +            def call(a: A): Unit = f(a), +        }, +    , +    /**, +     * Converts 1-arg predicate to Rx Func1[A, java.lang.Boolean], +     */, +    implicit def scalaBooleanFunction1ToRxBooleanFunc1[A](f: (A => Boolean)): Func1[A, jlang.Boolean] =, +        new Func1[A, jlang.Boolean] {, +            def call(a: A): jlang.Boolean = f(a).booleanValue, +        }, +    , +    /**, +     * Converts a specific function shape (used in takeWhile) to the equivalent Java types with an Rx Func2, +     */, +    implicit def convertTakeWhileFuncToRxFunc2[A](f: (A, Int) => Boolean): Func2[A, jlang.Integer, jlang.Boolean] =, +        new Func2[A, jlang.Integer, jlang.Boolean] {, +            def call(a: A, b: jlang.Integer): jlang.Boolean = f(a, b).booleanValue, +        }, +    , +    /**, +     * Converts a function shaped like compareTo into the equivalent Rx Func2, +     */, +    implicit def convertComparisonFuncToRxFunc2[A](f: (A, A) => Int): Func2[A, A, jlang.Integer] =, +        new Func2[A, A, jlang.Integer] {, +            def call(a1: A, a2: A): jlang.Integer = f(a1, a2).intValue, +        }, +    , +    /*, +     * This implicit allows Scala code to use any exception type and still work]