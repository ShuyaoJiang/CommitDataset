[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.observables.BlockingObservable, +   * Combines two observables, emitting a pair of the latest values of each of, +   * the source observables each time an event is received from one of the source observables, where the, +   * aggregation is defined by the given function., +   *, +   * @param that, +   *            The second source observable., +   * @return An Observable that combines the source Observables, +   */, +  def combineLatest[U](that: Observable[U]): Observable[(T, U)] = {, +    val f: Func2[_ >: T, _ >: U, _ <: (T, U)] = (t: T, u: U) => (t, u), +    Observable[(T, U)](rx.Observable.combineLatest[T, U, (T, U)](this.asJava, that.asJava, f)), +  }, +, +  /**, +  // TODO also support Scala Futures, but think well before. Do we want to Future and Observable, +  // to share a common base interface?, +  , +  // private because it's not RxScala's responsability to provide this alias, +  private type Future[+T] = java.util.concurrent.Future[_ <: T], +  , +    Observable[T](rx.Observable.from(f)), +    Observable[T](rx.Observable.from(f, scheduler)), +    Observable[T](rx.Observable.from(f, duration.length, duration.unit)), +class UnitTestSuite extends org.scalatest.junit.JUnitSuite {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.observables.BlockingObservable, +   * Combines two observables, emitting a pair of the latest values of each of, +   * the source observables each time an event is received from one of the source observables, where the, +   * aggregation is defined by the given function., +   *, +   * @param that, +   *            The second source observable., +   * @return An Observable that combines the source Observables, +   */, +  def combineLatest[U](that: Observable[U]): Observable[(T, U)] = {, +    val f: Func2[_ >: T, _ >: U, _ <: (T, U)] = (t: T, u: U) => (t, u), +    Observable[(T, U)](rx.Observable.combineLatest[T, U, (T, U)](this.asJava, that.asJava, f)), +  }, +, +  /**, +  // TODO also support Scala Futures, but think well before. Do we want to Future and Observable, +  // to share a common base interface?, +  , +  // private because it's not RxScala's responsability to provide this alias, +  private type Future[+T] = java.util.concurrent.Future[_ <: T], +  , +    Observable[T](rx.Observable.from(f)), +    Observable[T](rx.Observable.from(f, scheduler)), +    Observable[T](rx.Observable.from(f, duration.length, duration.unit)), +class UnitTestSuite extends org.scalatest.junit.JUnitSuite {, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "combineLatest(Observable[_ <: T1], Observable[_ <: T2], Func2[_ >: T1, _ >: T2, _ <: R])" -> "combineLatest(Observable[U])",, +      "from(Future[_ <: T])" -> "apply(Future[T])",, +      "from(Future[_ <: T], Long, TimeUnit)" -> "apply(Future[T], Duration)",, +      "from(Future[_ <: T], Scheduler)" -> "apply(Future[T], Scheduler)",, +  ).drop(2).toMap ++ (3 to 9).map(i => {, +    // combineLatest 3-9:, +    val obsArgs = (1 to i).map(j => s"Observable[_ <: T$j], ").mkString(""), +    val funcParams = (1 to i).map(j => s"_ >: T$j, ").mkString(""), +    ("combineLatest(" + obsArgs + "Func" + i + "[" + funcParams + "_ <: R])", "[If C# doesn't need it, Scala doesn't need it either ;-)]"), +  }).toMap]