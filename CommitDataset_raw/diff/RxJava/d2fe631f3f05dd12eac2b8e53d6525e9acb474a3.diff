[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelRunOn.java, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport;, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback;, +    public void subscribe(final Subscriber<? super T>[] subscribers) {, +        final Subscriber<T>[] parents = new Subscriber[n];, +        if (scheduler instanceof SchedulerMultiWorkerSupport) {, +            SchedulerMultiWorkerSupport multiworker = (SchedulerMultiWorkerSupport) scheduler;, +            multiworker.createWorkers(n, new MultiWorkerCallback(subscribers, parents));, +            for (int i = 0; i < n; i++) {, +                createSubscriber(i, subscribers, parents, scheduler.createWorker());, +    void createSubscriber(int i, Subscriber<? super T>[] subscribers,, +            Subscriber<T>[] parents, Scheduler.Worker worker) {, +, +        Subscriber<? super T> a = subscribers[i];, +, +        SpscArrayQueue<T> q = new SpscArrayQueue<T>(prefetch);, +, +        if (a instanceof ConditionalSubscriber) {, +            parents[i] = new RunOnConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, prefetch, q, worker);, +        } else {, +            parents[i] = new RunOnSubscriber<T>(a, prefetch, q, worker);, +        }, +    }, +, +    final class MultiWorkerCallback implements WorkerCallback {, +, +        final Subscriber<? super T>[] subscribers;, +, +        final Subscriber<T>[] parents;, +, +        MultiWorkerCallback(Subscriber<? super T>[] subscribers,, +                Subscriber<T>[] parents) {, +            this.subscribers = subscribers;, +            this.parents = parents;, +        }, +, +        @Override, +        public void onWorker(int i, Worker w) {, +            createSubscriber(i, subscribers, parents, w);, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelRunOn.java, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport;, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback;, +    public void subscribe(final Subscriber<? super T>[] subscribers) {, +        final Subscriber<T>[] parents = new Subscriber[n];, +        if (scheduler instanceof SchedulerMultiWorkerSupport) {, +            SchedulerMultiWorkerSupport multiworker = (SchedulerMultiWorkerSupport) scheduler;, +            multiworker.createWorkers(n, new MultiWorkerCallback(subscribers, parents));, +            for (int i = 0; i < n; i++) {, +                createSubscriber(i, subscribers, parents, scheduler.createWorker());, +    void createSubscriber(int i, Subscriber<? super T>[] subscribers,, +            Subscriber<T>[] parents, Scheduler.Worker worker) {, +, +        Subscriber<? super T> a = subscribers[i];, +, +        SpscArrayQueue<T> q = new SpscArrayQueue<T>(prefetch);, +, +        if (a instanceof ConditionalSubscriber) {, +            parents[i] = new RunOnConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, prefetch, q, worker);, +        } else {, +            parents[i] = new RunOnSubscriber<T>(a, prefetch, q, worker);, +        }, +    }, +, +    final class MultiWorkerCallback implements WorkerCallback {, +, +        final Subscriber<? super T>[] subscribers;, +, +        final Subscriber<T>[] parents;, +, +        MultiWorkerCallback(Subscriber<? super T>[] subscribers,, +                Subscriber<T>[] parents) {, +            this.subscribers = subscribers;, +            this.parents = parents;, +        }, +, +        @Override, +        public void onWorker(int i, Worker w) {, +            createSubscriber(i, subscribers, parents, w);, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicReference;, +, +import io.reactivex.internal.functions.ObjectHelper;, +public final class ComputationScheduler extends Scheduler implements SchedulerMultiWorkerSupport {, +    static final class FixedSchedulerPool implements SchedulerMultiWorkerSupport {, +, +        @Override, +        public void createWorkers(int number, WorkerCallback callback) {, +            int c = cores;, +            if (c == 0) {, +                for (int i = 0; i < number; i++) {, +                    callback.onWorker(i, SHUTDOWN_WORKER);, +                }, +            } else {, +                int index = (int)n % c;, +                for (int i = 0; i < number; i++) {]