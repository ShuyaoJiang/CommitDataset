[+++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for `take(1)`., +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = take(1), +, +  /*, +  , +  TODO once https://github.com/Netflix/RxJava/issues/417 is fixed, we can add head and tail methods, +  , +  /**, +   * emits NoSuchElementException("head of empty Observable") if empty, +   */, +  def head: Observable[T] = {, +    this.take(1).fold[Option[T]](None)((v: Option[T], e: T) => Some(e)).map({, +      case Some(element) => element, +      case None => throw new NoSuchElementException("head of empty Observable"), +    }), +   * emits an UnsupportedOperationException("tail of empty list") if empty, +  def tail: Observable[T] = ???, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for `take(1)`., +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = take(1), +, +  /*, +  , +  TODO once https://github.com/Netflix/RxJava/issues/417 is fixed, we can add head and tail methods, +  , +  /**, +   * emits NoSuchElementException("head of empty Observable") if empty, +   */, +  def head: Observable[T] = {, +    this.take(1).fold[Option[T]](None)((v: Option[T], e: T) => Some(e)).map({, +      case Some(element) => element, +      case None => throw new NoSuchElementException("head of empty Observable"), +    }), +   * emits an UnsupportedOperationException("tail of empty list") if empty, +  def tail: Observable[T] = ???, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/BlockingObservable.scala, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for `take(1)`., +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = take(1), +, +  /*, +  , +  TODO once https://github.com/Netflix/RxJava/issues/417 is fixed, we can add head and tail methods, +  , +  /**, +   * emits NoSuchElementException("head of empty Observable") if empty, +   */, +  def head: Observable[T] = {, +    this.take(1).fold[Option[T]](None)((v: Option[T], e: T) => Some(e)).map({, +      case Some(element) => element, +      case None => throw new NoSuchElementException("head of empty Observable"), +    }), +   * emits an UnsupportedOperationException("tail of empty list") if empty, +  def tail: Observable[T] = ???, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/BlockingObservable.scala, +++ b/rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperationMinMaxTest.java, +                isA(IllegalArgumentException.class));, +                isA(IllegalArgumentException.class));, +                isA(IllegalArgumentException.class));, +                isA(IllegalArgumentException.class));, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, +    (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for `take(1)`., +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = take(1), +, +  /*, +  ]