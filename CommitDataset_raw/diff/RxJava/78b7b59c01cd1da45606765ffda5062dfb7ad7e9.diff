[+++ b/CHANGES.md, +### Version 0.20.6 – October 15th 2014 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.6%22)) ###, +, +* [Pull 1721] (https://github.com/ReactiveX/RxJava/pull/1721) Bug in the onBackpressure operators , +* [Pull 1695] (https://github.com/ReactiveX/RxJava/pull/1695) rewrite OnSubscribeRefCount to handle synchronous source, +* [Pull 1761] (https://github.com/ReactiveX/RxJava/pull/1761) Fix null-emitting combineLatest, +, +++ b/CHANGES.md, +### Version 0.20.6 – October 15th 2014 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.6%22)) ###, +, +* [Pull 1721] (https://github.com/ReactiveX/RxJava/pull/1721) Bug in the onBackpressure operators , +* [Pull 1695] (https://github.com/ReactiveX/RxJava/pull/1695) rewrite OnSubscribeRefCount to handle synchronous source, +* [Pull 1761] (https://github.com/ReactiveX/RxJava/pull/1761) Fix null-emitting combineLatest, +, +++ /dev/null, +++ b/CHANGES.md, +### Version 0.20.6 – October 15th 2014 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.6%22)) ###, +, +* [Pull 1721] (https://github.com/ReactiveX/RxJava/pull/1721) Bug in the onBackpressure operators , +* [Pull 1695] (https://github.com/ReactiveX/RxJava/pull/1695) rewrite OnSubscribeRefCount to handle synchronous source, +* [Pull 1761] (https://github.com/ReactiveX/RxJava/pull/1761) Fix null-emitting combineLatest, +, +++ /dev/null, +++ b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +import org.junit.Before;, +import org.mockito.InOrder;, +import org.mockito.MockitoAnnotations;, +import rx.Observer;, +import rx.functions.Func2;, +import rx.observers.Subscribers;, +import rx.schedulers.TestScheduler;, +import rx.subjects.ReplaySubject;, +import rx.subscriptions.Subscriptions;, +    @Before, +    public void setUp() {, +        MockitoAnnotations.initMocks(this);, +    }, +, +    public void onlyFirstShouldSubscribeAndLastUnsubscribe() {, +        final AtomicInteger subscriptionCount = new AtomicInteger();, +        final AtomicInteger unsubscriptionCount = new AtomicInteger();, +        Observable<Integer> observable = Observable.create(new OnSubscribe<Integer>() {, +            @Override, +            public void call(Subscriber<? super Integer> observer) {, +                subscriptionCount.incrementAndGet();, +                observer.add(Subscriptions.create(new Action0() {, +                    @Override, +                    public void call() {, +                        unsubscriptionCount.incrementAndGet();, +                    }, +                }));, +            }, +        });, +        Observable<Integer> refCounted = observable.publish().refCount();, +        @SuppressWarnings("unchecked"), +        Observer<Integer> observer = mock(Observer.class);, +        Subscription first = refCounted.subscribe(observer);, +        assertEquals(1, subscriptionCount.get());, +        Subscription second = refCounted.subscribe(observer);, +        assertEquals(1, subscriptionCount.get());, +        first.unsubscribe();, +        assertEquals(0, unsubscriptionCount.get());, +        second.unsubscribe();, +        assertEquals(1, unsubscriptionCount.get());, +    }, +, +    @Test, +    public void testRefCount() {, +        TestScheduler s = new TestScheduler();, +        Observable<Long> interval = Observable.interval(100, TimeUnit.MILLISECONDS, s).publish().refCount();, +, +        // subscribe list1, +        final List<Long> list1 = new ArrayList<Long>();, +        Subscription s1 = interval.subscribe(new Action1<Long>() {, +, +            @Override, +            public void call(Long t1) {, +                list1.add(t1);, +            }, +, +        });, +        s.advanceTimeBy(200, TimeUnit.MILLISECONDS);, +, +        assertEquals(2, list1.size());, +        assertEquals(0L, list1.get(0).longValue());, +        assertEquals(1L, list1.get(1).longValue());, +, +        // subscribe list2, +        final List<Long> list2 = new ArrayList<Long>();, +        Subscription s2 = interval.subscribe(new Action1<Long>() {, +, +            @Override]