[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +     * @param subject the subject to push source elements into., +     * @param <R> result type, +     * @param source the source sequence whose elements will be pushed into the specified subject., +     * @param subject the subject to push source elements into., +     * @param <T> source type, +     * @param <R> result type, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +     * @param subject the subject to push source elements into., +     * @param <R> result type, +     * @param source the source sequence whose elements will be pushed into the specified subject., +     * @param subject the subject to push source elements into., +     * @param <T> source type, +     * @param <R> result type, +++ b/rxjava-core/src/main/java/rx/operators/OperationSample.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.mockito.InOrder;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Subscription;, +import rx.concurrency.Schedulers;, +import rx.concurrency.TestScheduler;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action0;, +import rx.util.functions.Func1;, +, +/**, + * Samples the observable sequence at each interval., + */, +public final class OperationSample {, +, +    /**, +     * Samples the observable sequence at each interval., +     */, +    public static <T> Func1<Observer<T>, Subscription> sample(final Observable<T> source, long period, TimeUnit unit) {, +        return new Sample<T>(source, period, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));, +    }, +, +    /**, +     * Samples the observable sequence at each interval., +     */, +    public static <T> Func1<Observer<T>, Subscription> sample(final Observable<T> source, long period, TimeUnit unit, Scheduler scheduler) {, +        return new Sample<T>(source, period, unit, scheduler);, +    }, +    , +    private static class Sample<T> implements Func1<Observer<T>, Subscription> {, +        private final Observable<T> source;, +        private final long period;, +        private final TimeUnit unit;, +        private final Scheduler scheduler;, +        , +        private final AtomicBoolean hasValue = new AtomicBoolean();, +        private final AtomicReference<T> latestValue = new AtomicReference<T>();, +        , +        private Sample(Observable<T> source, long interval, TimeUnit unit, Scheduler scheduler) {, +            this.source = source;, +            this.period = interval;, +            this.unit = unit;, +            this.scheduler = scheduler;, +        }, +, +        @Override, +        public Subscription call(final Observer<T> observer) {, +            Observable<Long> clock = Observable.create(OperationInterval.interval(period, unit, scheduler));, +            final Subscription clockSubscription = clock.subscribe(new Observer<Long>() {, +                @Override, +                public void onCompleted() { /* the clock never completes */ }, +                , +                @Override, +                public void onError(Exception e) { /* the clock has no errors */ }]