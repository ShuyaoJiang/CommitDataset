[+++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +import java.util.ArrayList;, +import java.util.List;, +import rx.Subscriber;, +    /**, +     * Create a {@link BehaviorSubject} without a default value., +     * @param <T> the value type, +     * @return the constructed {@link BehaviorSubject}, +     */, +    public static <T> BehaviorSubject<T> create() {, +        return create(null, false);, +    }, +     * @param <T> the value type, +        return create(defaultValue, true);, +    }, +    private static <T> BehaviorSubject<T> create(T defaultValue, boolean hasDefault) {, +        final State<T> state = new State<T>();, +        if (hasDefault) {, +            state.lastNotification.set(Notification.createOnNext(defaultValue));, +        }, +        final OnSubscribe<T> onSubscribeBase = subscriptionManager.getOnSubscribeFunc(, +                        state.addPending(o);, +                        state.removePending(o);, +                }, new Action1<SubjectObserver<? super T>>() {, +                    @Override, +                    public void call(SubjectObserver<? super T> o) {, +                        state.removePending(o);, +                });, +        OnSubscribe<T> onSubscribe = new OnSubscribe<T>() {, +, +            @Override, +            public void call(Subscriber<? super T> t1) {, +                onSubscribeBase.call(t1);, +                state.removePendingSubscriber(t1);, +            }, +        };, +        return new BehaviorSubject<T>(onSubscribe, subscriptionManager, state);, +    }, +, +    static final class State<T> {, +        /** Guarded by this. */, +        List<Object> pendingSubscriptions;, +        public State() {, +            this.lastNotification = new AtomicReference<Notification<T>>();, +        }, +        public void addPending(SubjectObserver<? super T> subscriber) {, +            synchronized (this) {, +                if (pendingSubscriptions == null) {, +                    pendingSubscriptions = new ArrayList<Object>(4);, +                }, +                pendingSubscriptions.add(subscriber);, +                List<Notification<T>> list = new ArrayList<Notification<T>>(4);, +                list.add(lastNotification.get());, +                pendingSubscriptions.add(list);, +            }, +        }, +        public void bufferValue(Notification<T> value) {, +            synchronized (this) {, +                if (pendingSubscriptions == null) {, +                    return;, +                }, +                for (int i = 1; i < pendingSubscriptions.size(); i += 2) {, +                    @SuppressWarnings("unchecked"), +                    List<Notification<T>> list = (List<Notification<T>>)pendingSubscriptions.get(i);, +                    list.add(value);, +                }, +            }, +        }, +        public void removePending(SubjectObserver<? super T> subscriber) {, +            List<Notification<T>> toCatchUp = null;, +            synchronized (this) {, +                if (pendingSubscriptions == null) {, +                    return;, +                }, +                int idx = pendingSubscriptions.indexOf(subscriber);, +                if (idx >= 0) {, +                    pendingSubscriptions.remove(idx);, +                    @SuppressWarnings("unchecked"), +                    List<Notification<T>> list = (List<Notification<T>>)pendingSubscriptions.remove(idx);, +                    toCatchUp = list;, +                    subscriber.caughtUp = true;, +                    if (pendingSubscriptions.isEmpty()) {, +                        pendingSubscriptions = null;, +                    }, +                }, +            }, +            if (toCatchUp != null) {, +                for (Notification<T> n : toCatchUp) {, +                    if (n != null) {, +                        n.accept(subscriber);, +                    }, +                }, +            }, +        }, +        public void removePendingSubscriber(Subscriber<? super T> subscriber) {, +            List<Notification<T>> toCatchUp = null;, +            synchronized (this) {, +                if (pendingSubscriptions == null) {, +                    return;, +                }]