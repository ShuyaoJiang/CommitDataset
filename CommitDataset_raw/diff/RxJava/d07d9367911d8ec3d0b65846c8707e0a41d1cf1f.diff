[+++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java, +                innerObservable.subscribe(new InnerObserver());, +                    super(o);, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java, +                innerObservable.subscribe(new InnerObserver());, +                    super(o);, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java, +    private final AtomicReference<RxJavaSchedulers> schedulerOverrides = new AtomicReference<RxJavaSchedulers>();, +, +    /**, +     * Retrieve instance of {@link RxJavaSchedulers} to use based on order of precedence as defined in {@link RxJavaPlugins} class header., +     * <p>, +     * Override default by using {@link #registerSchedulers(RxJavaSchedulers)} or setting property: <code>rxjava.plugin.RxJavaDefaultSchedulers.implementation</code> with the full, +     * classname to, +     * load., +     * , +     * @return {@link RxJavaErrorHandler} implementation to use, +     */, +    public RxJavaSchedulers getSchedulers() {, +        if (schedulerOverrides.get() == null) {, +            // check for an implementation from System.getProperty first, +            Object impl = getPluginImplementationViaProperty(RxJavaSchedulers.class);, +            if (impl == null) {, +                // nothing set via properties so initialize with default , +                schedulerOverrides.compareAndSet(null, RxJavaSchedulersDefault.getInstance());, +                // we don't return from here but call get() again in case of thread-race so the winner will always get returned, +            } else {, +                // we received an implementation from the system property so use it, +                schedulerOverrides.compareAndSet(null, (RxJavaSchedulers) impl);, +            }, +        }, +        return schedulerOverrides.get();, +    }, +, +    /**, +     * Register a {@link RxJavaSchedulers} implementation as a global override of any injected or default implementations., +     * , +     * @param impl, +     *            {@link RxJavaSchedulers} implementation, +     * @throws IllegalStateException, +     *             if called more than once or after the default was initialized (if usage occurs before trying to register), +     */, +    public void registerSchedulers(RxJavaSchedulers impl) {, +        if (!schedulerOverrides.compareAndSet(null, impl)) {, +            throw new IllegalStateException("Another strategy was already registered: " + schedulerOverrides.get());, +        }, +    }, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java, +                innerObservable.subscribe(new InnerObserver());, +                    super(o);, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java, +    private final AtomicReference<RxJavaSchedulers> schedulerOverrides = new AtomicReference<RxJavaSchedulers>();, +, +    /**, +     * Retrieve instance of {@link RxJavaSchedulers} to use based on order of precedence as defined in {@link RxJavaPlugins} class header., +     * <p>, +     * Override default by using {@link #registerSchedulers(RxJavaSchedulers)} or setting property: <code>rxjava.plugin.RxJavaDefaultSchedulers.implementation</code> with the full, +     * classname to, +     * load., +     * , +     * @return {@link RxJavaErrorHandler} implementation to use, +     */, +    public RxJavaSchedulers getSchedulers() {, +        if (schedulerOverrides.get() == null) {, +            // check for an implementation from System.getProperty first, +            Object impl = getPluginImplementationViaProperty(RxJavaSchedulers.class);, +            if (impl == null) {, +                // nothing set via properties so initialize with default , +                schedulerOverrides.compareAndSet(null, RxJavaSchedulersDefault.getInstance());, +                // we don't return from here but call get() again in case of thread-race so the winner will always get returned, +            } else {, +                // we received an implementation from the system property so use it, +                schedulerOverrides.compareAndSet(null, (RxJavaSchedulers) impl);, +            }, +        }, +        return schedulerOverrides.get();, +    }, +, +    /**, +     * Register a {@link RxJavaSchedulers} implementation as a global override of any injected or default implementations., +     * , +     * @param impl, +     *            {@link RxJavaSchedulers} implementation, +     * @throws IllegalStateException, +     *             if called more than once or after the default was initialized (if usage occurs before trying to register), +     */, +    public void registerSchedulers(RxJavaSchedulers impl) {, +        if (!schedulerOverrides.compareAndSet(null, impl)) {, +            throw new IllegalStateException("Another strategy was already registered: " + schedulerOverrides.get());, +        }, +    }, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaSchedulers.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");]