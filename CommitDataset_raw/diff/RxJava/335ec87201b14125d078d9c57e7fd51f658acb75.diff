[+++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +All factory methods now have their own name corresponding to the Java and .NET operators, +(plus overloads that take a `Scheduler`)., +* `def from[T](future: Future[T]): Observable[T]`, +* `def empty[T]: Observable[T]`, +* `def items[T](items: T*): Observable[T], +, +In the *pre-release* of this version, we expose both `apply` and `create` for the mother of all creation functions., +We would like to solicit feedback which of these two names is preferred, +(or both, but there is a high probability that only one will be chosen)., +, +* `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +All factory methods now have their own name corresponding to the Java and .NET operators, +(plus overloads that take a `Scheduler`)., +* `def from[T](future: Future[T]): Observable[T]`, +* `def empty[T]: Observable[T]`, +* `def items[T](items: T*): Observable[T], +, +In the *pre-release* of this version, we expose both `apply` and `create` for the mother of all creation functions., +We would like to solicit feedback which of these two names is preferred, +(or both, but there is a high probability that only one will be chosen)., +, +* `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +  def mountainBikeMedals: Observable[Medal] = Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +All factory methods now have their own name corresponding to the Java and .NET operators, +(plus overloads that take a `Scheduler`)., +* `def from[T](future: Future[T]): Observable[T]`, +* `def empty[T]: Observable[T]`, +* `def items[T](items: T*): Observable[T], +, +In the *pre-release* of this version, we expose both `apply` and `create` for the mother of all creation functions., +We would like to solicit feedback which of these two names is preferred, +(or both, but there is a high probability that only one will be chosen)., +, +* `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +  def mountainBikeMedals: Observable[Medal] = Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.items(, +    Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val first = Observable.from(List(10, 11, 12)), +    val second = Observable.from(List(10, 11, 12)), +    val first = Observable.from(List(10, 11, 12)), +    val second = Observable.from(List(10, 11, 12)), +    val before = List(-2, -1, 0).toObservable, +    val source = List(1, 2, 3).toObservable, +    List(, +    ).toObservable.flatten.take(12).toBlockingObservable.foreach(println(_)), +    assertEquals(10, List(1, 2, 3, 4).toObservable.reduce(_ + _).toBlockingObservable.single), +    val observables = List(List(1, 2, 3).toObservable, List(10, 20, 30).toObservable).toObservable, +    val m = List(1, 2, 3, 4).toObservable, +    val m = List(1, 2, 3, 4).toObservable, +    val unshared = List(1 to 4).toObservable, +    val unshared = List(1 to 4).toObservable, +    assertEquals(None,    List(1, 2).toObservable.toBlockingObservable.singleOption), +    assertEquals(Some(1), List(1).toObservable.toBlockingObservable.singleOption), +    assertEquals(None,    List().toObservable.toBlockingObservable.singleOption), +    println(doubleAverage(Observable.empty[Double]).toBlockingObservable.single), +    println(doubleAverage(List(0.0).toObservable).toBlockingObservable.single), +    println(doubleAverage(List(4.44).toObservable).toBlockingObservable.single), +    println(doubleAverage(List(1, 2, 3.5).toObservable).toBlockingObservable.single), +    assertEquals(10, List(1, 2, 3, 4).toObservable.sum.toBlockingObservable.single), +    assertEquals(6, List(4, 2).toObservable.sum.toBlockingObservable.single), +    assertEquals(0, List[Int]().toObservable.sum.toBlockingObservable.single), +    assertEquals(24, List(1, 2, 3, 4).toObservable.product.toBlockingObservable.single), +    assertEquals(8, List(4, 2).toObservable.product.toBlockingObservable.single), +    assertEquals(1, List[Int]().toObservable.product.toBlockingObservable.single), +    List("a", "b", "c").toObservable.zipWithIndex.map(pair => pair._1 + " has index " + pair._2), +    (for ((letter, index) <- List("a", "b", "c").toObservable.zipWithIndex) yield letter + " has index " + index), +    val o = Observable.zip(List(1, 2).toObservable, List(10, 20).toObservable, List(100, 200).toObservable), +    val observables = List(List(1, 2).toObservable, List(10, 20).toObservable, List(100, 200).toObservable).toObservable, +    assertEquals(3, List(1, 2, 3, 4).toObservable.filter(condition).first.toBlockingObservable.single), +    assertEquals(3, List(1, 2, 3, 4).toObservable.filter(condition).firstOrElse(10).toBlockingObservable.single), +    assertEquals(10, List(-1, 0, 1).toObservable.filter(condition).firstOrElse(10).toBlockingObservable.single), +    assertEquals(Seq(7, 8, 9, 10), List(10, 7, 8, 9).toObservable.toSeq.map(_.sorted).toBlockingObservable.single), +    assertEquals(Seq(10, 9, 8, 7), List(10, 7, 8, 9).toObservable.toSeq.map(_.sortWith(f)).toBlockingObservable.single), +    List(1, 2, 3).toObservable.materialize.subscribe(n => n match {, +    assertEquals("b", List("a", "b", "c").toObservable.drop(1).first.toBlockingObservable.single), +    assertEquals("b", List("a", "b", "c").toObservable.drop(1).firstOrElse("!").toBlockingObservable.single), +    assertEquals("!!", List("a", "b", "c").toObservable.drop(10).firstOrElse("!!").toBlockingObservable.single), +    List("a", "b").toObservable.zipWithIndex.takeWhile{case (elem, index) => condition}.map(_._1), +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +All factory methods now have their own name corresponding to the Java and .NET operators, +(plus overloads that take a `Scheduler`).]