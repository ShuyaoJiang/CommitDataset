[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.immediate());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.immediate());, +++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java, +        return toObservableIterable(list, Schedulers.immediate());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.immediate());, +++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java, +        return toObservableIterable(list, Schedulers.immediate());, +++ b/rxjava-core/src/test/java/rx/schedulers/SchedulerPerformanceTests.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.schedulers;, +, +import java.util.Arrays;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +import rx.util.functions.Action0;, +, +public class SchedulerPerformanceTests {, +, +    private static final int REPETITIONS = 5 * 1000 * 1000;, +    private static final int NUM_PRODUCERS = 1;, +, +    public static void main(String args[]) {, +, +        final SchedulerPerformanceTests spt = new SchedulerPerformanceTests();, +        try {, +            spt.runTest(new Action0() {, +, +                @Override, +                public void call() {, +                    //                    spt.singleResponse(Schedulers.immediate());, +                    //                    spt.singleResponse(Schedulers.currentThread());, +                    //                    spt.singleResponse(Schedulers.threadPoolForComputation());, +, +                    spt.arrayResponse(Schedulers.immediate());, +                    //                    spt.arrayResponse(Schedulers.currentThread());, +                    //                    spt.arrayResponse(Schedulers.threadPoolForComputation());, +                }, +            });, +        } catch (Exception e) {, +            e.printStackTrace();, +        }, +, +    }, +, +    private void runTest(Action0 action) throws InterruptedException {, +        for (int runNum = 0; runNum < 15; runNum++) {, +            System.gc();, +            Thread.sleep(1000L);, +, +            final long start = System.nanoTime();, +, +            action.call();, +, +            long duration = System.nanoTime() - start;, +            long opsPerSec = (REPETITIONS * NUM_PRODUCERS * 1000L * 1000L * 1000L) / duration;, +            System.out.printf("Run: %d - %,d ops/sec \n",, +                    Integer.valueOf(runNum),, +                    Long.valueOf(opsPerSec));, +        }, +    }, +, +    /**, +     * Baseline ops/second without a subject., +     * , +     * Perf along this order of magnitude:, +     * , +     * Run: 10 - 316,235,532 ops/sec, +     * Run: 11 - 301,886,792 ops/sec, +     * Run: 12 - 310,472,228 ops/sec, +     * Run: 13 - 313,469,797 ops/sec, +     * Run: 14 - 305,380,809 ops/sec, +     */, +    public long baseline() {, +        LongObserver o = new LongObserver();, +        for (long l = 0; l < REPETITIONS; l++) {, +            o.onNext(l);, +        }, +        o.onCompleted();, +        return o.sum;, +    }, +]