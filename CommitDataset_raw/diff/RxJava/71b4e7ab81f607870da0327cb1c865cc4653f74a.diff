[+++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java, +, +        final List<CountedSubject<T>> chunks = new LinkedList<CountedSubject<T>>();, +        Subscription parentSubscription = this;, +, +            /**, +             * See https://github.com/ReactiveX/RxJava/issues/1546, +             * We cannot compose through a Subscription because unsubscribing, +             * applies to the outer, not the inner., +             */, +            /*, +             * Add unsubscribe hook to child to get unsubscribe on outer (unsubscribing on next window, not on the inner window itself), +             */, +            child.add(Subscriptions.create(new Action0() {, +, +                @Override, +                public void call() {, +                    // if no window we unsubscribe up otherwise wait until window ends, +                    if (chunks == null || chunks.size() == 0) {, +                        parentSubscription.unsubscribe();, +                    }, +                }, +, +            }));, +                if (!child.isUnsubscribed()) {, +            }, +, +            if (chunks.size() == 0 && child.isUnsubscribed()) {, +                parentSubscription.unsubscribe();, +                return;, +            }, +, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java, +, +        final List<CountedSubject<T>> chunks = new LinkedList<CountedSubject<T>>();, +        Subscription parentSubscription = this;, +, +            /**, +             * See https://github.com/ReactiveX/RxJava/issues/1546, +             * We cannot compose through a Subscription because unsubscribing, +             * applies to the outer, not the inner., +             */, +            /*, +             * Add unsubscribe hook to child to get unsubscribe on outer (unsubscribing on next window, not on the inner window itself), +             */, +            child.add(Subscriptions.create(new Action0() {, +, +                @Override, +                public void call() {, +                    // if no window we unsubscribe up otherwise wait until window ends, +                    if (chunks == null || chunks.size() == 0) {, +                        parentSubscription.unsubscribe();, +                    }, +                }, +, +            }));, +                if (!child.isUnsubscribed()) {, +            }, +, +            if (chunks.size() == 0 && child.isUnsubscribed()) {, +                parentSubscription.unsubscribe();, +                return;, +            }, +, +++ b/src/test/java/rx/internal/operators/OperatorWindowWithSizeTest.java, +    @Test, +    public void testWindowUnsubscribeOverlapping() {, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +        final AtomicInteger count = new AtomicInteger();, +        Observable.merge(Observable.range(1, 10000).doOnNext(new Action1<Integer>() {, +, +            @Override, +            public void call(Integer t1) {, +                count.incrementAndGet();, +            }, +, +        }).window(5, 4).take(2)).subscribe(ts);, +        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);, +        ts.assertTerminalEvent();, +        //        System.out.println(ts.getOnNextEvents());, +        ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 5, 6, 7, 8, 9));, +        assertEquals(9, count.get());, +    }, +, +    @Test, +    public void testWindowUnsubscribeOverlappingAsyncSource() {, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +        final AtomicInteger count = new AtomicInteger();, +        Observable.merge(Observable.range(1, 100000), +                .doOnNext(new Action1<Integer>() {, +, +                    @Override, +                    public void call(Integer t1) {, +                        count.incrementAndGet();, +                    }, +, +                }), +                .observeOn(Schedulers.computation()), +                .window(5, 4), +                .take(2))]