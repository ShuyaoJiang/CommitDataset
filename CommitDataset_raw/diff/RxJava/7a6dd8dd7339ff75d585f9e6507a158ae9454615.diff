[+++ b/src/main/java/rx/Observable.java, +        return reduce(0, new Func2<Integer, T, Integer>() {, +            public final Integer call(Integer t1, T t2) {, +                return t1 + 1;, +        });, +        return reduce(0L, new Func2<Long, T, Long>() {, +            public final Long call(Long t1, T t2) {, +                return t1 + 1;, +        });, +++ b/src/main/java/rx/Observable.java, +        return reduce(0, new Func2<Integer, T, Integer>() {, +            public final Integer call(Integer t1, T t2) {, +                return t1 + 1;, +        });, +        return reduce(0L, new Func2<Long, T, Long>() {, +            public final Long call(Long t1, T t2) {, +                return t1 + 1;, +        });, +++ b/src/test/java/rx/exceptions/ExceptionsTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +, +    @Test, +    public void testStackOverflowWouldOccur() {, +        final int MAX_STACK_DEPTH = 1000;, +        final AtomicInteger depth = new AtomicInteger();, +            public void onNext(Integer n) {, +                b.onNext(n + 1);, +            public void onNext(Integer n) {, +                if (depth.get() < MAX_STACK_DEPTH) { , +                    depth.set(Thread.currentThread().getStackTrace().length);, +                    a.onNext(n + 1);, +                }, +        assertTrue(depth.get() > MAX_STACK_DEPTH);, +    }, +    , +    @Test(expected = StackOverflowError.class), +    public void testStackOverflowErrorIsThrown() {, +        Observable.just(1).subscribe(new Observer<Integer>() {, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                e.printStackTrace();, +            }, +, +            @Override, +            public void onNext(Integer t) {, +                throw new StackOverflowError();, +            }, +, +        });]