[+++ b/rxjava-core/src/main/java/rx/operators/OperationJoin.java, +                int id;, +                    for (TRight r : rightMap.values()) {, +                int id = 0;, +                    for (TLeft lv : leftMap.values()) {, +++ b/rxjava-core/src/main/java/rx/operators/OperationJoin.java, +                int id;, +                    for (TRight r : rightMap.values()) {, +                int id = 0;, +                    for (TLeft lv : leftMap.values()) {, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTake.java, +    public Subscriber<? super T> call(final Subscriber<? super T> child) {, +        final CompositeSubscription parent = new CompositeSubscription();, +            child.onCompleted();, +, +         * , +         * However, if we receive an unsubscribe from the child we still want to propagate it upwards so we register 'parent' with 'child', +        child.add(parent);, +                    child.onCompleted();, +                    child.onError(e);, +                    child.onNext(i);, +                        child.onCompleted();, +++ b/rxjava-core/src/main/java/rx/operators/OperationJoin.java, +                int id;, +                    for (TRight r : rightMap.values()) {, +                int id = 0;, +                    for (TLeft lv : leftMap.values()) {, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTake.java, +    public Subscriber<? super T> call(final Subscriber<? super T> child) {, +        final CompositeSubscription parent = new CompositeSubscription();, +            child.onCompleted();, +, +         * , +         * However, if we receive an unsubscribe from the child we still want to propagate it upwards so we register 'parent' with 'child', +        child.add(parent);, +                    child.onCompleted();, +                    child.onError(e);, +                    child.onNext(i);, +                        child.onCompleted();, +++ b/rxjava-core/src/test/java/rx/operators/OperatorTakeTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +    @Test(timeout = 2000), +    public void testMultiTake() {, +        final AtomicInteger count = new AtomicInteger();, +        Observable.create(new OnSubscribe<Integer>() {, +, +            @Override, +            public void call(Subscriber<? super Integer> s) {, +                for (int i = 0; !s.isUnsubscribed(); i++) {, +                    System.out.println("Emit: " + i);, +                    count.incrementAndGet();, +                    s.onNext(i);, +                }, +            }, +, +        }).take(100).take(1).toBlockingObservable().forEach(new Action1<Integer>() {, +, +            @Override, +            public void call(Integer t1) {, +                System.out.println("Receive: " + t1);, +, +            }, +, +        });, +, +        assertEquals(1, count.get());, +    }, +]