[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationJoin;, +import rx.operators.OperatorMergeDelayError;, +        return source.lift(new OperatorMergeDelayError<T>());, +        return mergeDelayError(from(t1, t2));, +        return mergeDelayError(from(t1, t2, t3));, +        return mergeDelayError(from(t1, t2, t3, t4));, +        return mergeDelayError(from(t1, t2, t3, t4, t5));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +        return create(new OperationJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationJoin;, +import rx.operators.OperatorMergeDelayError;, +        return source.lift(new OperatorMergeDelayError<T>());, +        return mergeDelayError(from(t1, t2));, +        return mergeDelayError(from(t1, t2, t3));, +        return mergeDelayError(from(t1, t2, t3, t4));, +        return mergeDelayError(from(t1, t2, t3, t4, t5));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +        return create(new OperationJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ b/rxjava-core/src/main/java/rx/operators/OperationJoin.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.HashMap;, +import java.util.Map;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.functions.Func1;, +import rx.functions.Func2;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.SerialSubscription;, +, +/**, + * Correlates the elements of two sequences based on overlapping durations., + */, +public class OperationJoin<TLeft, TRight, TLeftDuration, TRightDuration, R> implements OnSubscribeFunc<R> {, +    final Observable<TLeft> left;, +    final Observable<TRight> right;, +    final Func1<TLeft, Observable<TLeftDuration>> leftDurationSelector;, +    final Func1<TRight, Observable<TRightDuration>> rightDurationSelector;, +    final Func2<TLeft, TRight, R> resultSelector;, +, +    public OperationJoin(, +            Observable<TLeft> left,, +            Observable<TRight> right,, +            Func1<TLeft, Observable<TLeftDuration>> leftDurationSelector,, +            Func1<TRight, Observable<TRightDuration>> rightDurationSelector,, +            Func2<TLeft, TRight, R> resultSelector) {, +        this.left = left;, +        this.right = right;, +        this.leftDurationSelector = leftDurationSelector;, +        this.rightDurationSelector = rightDurationSelector;, +        this.resultSelector = resultSelector;, +    }, +, +    @Override, +    public Subscription onSubscribe(Observer<? super R> t1) {, +        SerialSubscription cancel = new SerialSubscription();, +        ResultSink result = new ResultSink(t1, cancel);, +        cancel.set(result.run());, +        return cancel;, +    }, +, +    /** Manage the left and right sources. */, +    class ResultSink {, +        final Object gate = new Object();, +        final CompositeSubscription group = new CompositeSubscription();, +        boolean leftDone;, +        int leftId;, +        final Map<Integer, TLeft> leftMap = new HashMap<Integer, TLeft>();, +        boolean rightDone;, +        int rightId;, +        final Map<Integer, TRight> rightMap = new HashMap<Integer, TRight>();, +        final Observer<? super R> observer;, +        final Subscription cancel;]