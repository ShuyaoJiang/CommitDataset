[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> rebatchRequests(int bufferSize) {, +        return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);, +    }, +    , +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> rebatchRequests(int bufferSize) {, +        return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);, +    }, +    , +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                Queue<U> q = queue;, +                if (r != 0L && (q == null || q.isEmpty())) {, +                    if (q == null) {, +                        q = getMainQueue();, +                    }, +                Queue<U> q = inner.queue;, +                if (r != 0L && (q == null || q.isEmpty())) {, +                    if (q == null) {, +                        q = getInnerQueue(inner);, +                    }, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> rebatchRequests(int bufferSize) {, +        return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);, +    }, +    , +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                Queue<U> q = queue;, +                if (r != 0L && (q == null || q.isEmpty())) {, +                    if (q == null) {, +                        q = getMainQueue();, +                    }, +                Queue<U> q = inner.queue;, +                if (r != 0L && (q == null || q.isEmpty())) {, +                    if (q == null) {, +                        q = getInnerQueue(inner);, +                    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java, +public final class FlowableMapNotification<T, R> extends Flowable<R> {, +    final Function<? super T, ? extends R> onNextMapper;, +    final Function<? super Throwable, ? extends R> onErrorMapper;, +    final Supplier<? extends R> onCompleteSupplier;, +            Function<? super T, ? extends R> onNextMapper, , +            Function<? super Throwable, ? extends R> onErrorMapper, , +            Supplier<? extends R> onCompleteSupplier) {, +    protected void subscribeActual(Subscriber<? super R> s) {, +        final Subscriber<? super R> actual;, +        final Function<? super T, ? extends R> onNextMapper;, +        final Function<? super Throwable, ? extends R> onErrorMapper;, +        final Supplier<? extends R> onCompleteSupplier;, +        R value;, +        public MapNotificationSubscriber(Subscriber<? super R> actual,, +                Function<? super T, ? extends R> onNextMapper,, +                Function<? super Throwable, ? extends R> onErrorMapper,, +                Supplier<? extends R> onCompleteSupplier) {, +            R p;, +            R p;, +            R p;, +        void tryEmit(R p) {, +                            R p = value;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {, +    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> rebatchRequests(int bufferSize) {, +        return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);, +    }, +    , +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                Queue<U> q = queue;, +                if (r != 0L && (q == null || q.isEmpty())) {]