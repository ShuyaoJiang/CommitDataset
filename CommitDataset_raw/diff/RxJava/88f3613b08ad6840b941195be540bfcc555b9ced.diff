[+++ b/rxjava-core/src/main/java/rx/Observable.java, +    public static interface OnSubscribe<T> extends Function {, +        , +        public void onSubscribe(Operator<? super T> op);, +        , +    }, +    , +     * Lift a function to the current Observable and return a new Observable that when subscribed to will pass the values of the current Observable through the function., +     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +    public <R> Observable<R> lift(final Func1<Operator<? super R>, Operator<? super T>> bind) {, +        return source.lift(new OperatorMerge()); // any idea how to get these generics working?!, +        return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +        return lift(new OperatorCast<T, R>(klass));, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +        return lift(new OperatorMap<T, R>(func));, +        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));, +        return lift(new OperatorParallel<T, R>(f, s));, +        return lift(new OperatorTake<T>(num));, +        return lift(new OperatorTimestamp<T>(scheduler));, +        return lift(new OperatorToObservableList<T>());, +        return lift(new OperatorToObservableSortedList<T>());, +        return lift(new OperatorToObservableSortedList<T>(sortFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    public static interface OnSubscribe<T> extends Function {, +        , +        public void onSubscribe(Operator<? super T> op);, +        , +    }, +    , +     * Lift a function to the current Observable and return a new Observable that when subscribed to will pass the values of the current Observable through the function., +     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +    public <R> Observable<R> lift(final Func1<Operator<? super R>, Operator<? super T>> bind) {, +        return source.lift(new OperatorMerge()); // any idea how to get these generics working?!, +        return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +        return lift(new OperatorCast<T, R>(klass));, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +        return lift(new OperatorMap<T, R>(func));, +        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));, +        return lift(new OperatorParallel<T, R>(f, s));, +        return lift(new OperatorTake<T>(num));, +        return lift(new OperatorTimestamp<T>(scheduler));, +        return lift(new OperatorToObservableList<T>());, +        return lift(new OperatorToObservableSortedList<T>());, +        return lift(new OperatorToObservableSortedList<T>(sortFunction));, +++ b/rxjava-core/src/main/java/rx/Operator.java, +    public Operator() {, +        this.cs = new CompositeSubscription();, +    }, +    , +++ b/rxjava-core/src/main/java/rx/Observable.java, +    public static interface OnSubscribe<T> extends Function {, +        , +        public void onSubscribe(Operator<? super T> op);, +        , +    }, +    , +     * Lift a function to the current Observable and return a new Observable that when subscribed to will pass the values of the current Observable through the function., +     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +    public <R> Observable<R> lift(final Func1<Operator<? super R>, Operator<? super T>> bind) {, +        return source.lift(new OperatorMerge()); // any idea how to get these generics working?!, +        return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +        return lift(new OperatorCast<T, R>(klass));, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +        return lift(new OperatorMap<T, R>(func));, +        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));, +        return lift(new OperatorParallel<T, R>(f, s));, +        return lift(new OperatorTake<T>(num));, +        return lift(new OperatorTimestamp<T>(scheduler));, +        return lift(new OperatorToObservableList<T>());, +        return lift(new OperatorToObservableSortedList<T>());, +        return lift(new OperatorToObservableSortedList<T>(sortFunction));, +++ b/rxjava-core/src/main/java/rx/Operator.java, +    public Operator() {, +        this.cs = new CompositeSubscription();, +    }, +    , +++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java, +        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));, +        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));, +        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    public static interface OnSubscribe<T> extends Function {, +        , +        public void onSubscribe(Operator<? super T> op);, +        , +    }, +    , +     * Lift a function to the current Observable and return a new Observable that when subscribed to will pass the values of the current Observable through the function., +     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +    public <R> Observable<R> lift(final Func1<Operator<? super R>, Operator<? super T>> bind) {, +        return source.lift(new OperatorMerge()); // any idea how to get these generics working?!, +        return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +        return lift(new OperatorCast<T, R>(klass));, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +        return lift(new OperatorMap<T, R>(func));, +        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));, +        return lift(new OperatorParallel<T, R>(f, s));, +        return lift(new OperatorTake<T>(num));, +        return lift(new OperatorTimestamp<T>(scheduler));, +        return lift(new OperatorToObservableList<T>());]