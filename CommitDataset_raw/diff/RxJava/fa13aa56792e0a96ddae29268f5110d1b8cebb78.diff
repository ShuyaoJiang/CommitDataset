[+++ b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java, +        TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable("one", "two", "three");, +        TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable("one", "two", "three");, +        TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable("one", "two", "three", null);, +        int n = 10;, +        for (int i = 0; i < n; i++) {, +            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable("one", "two", "three", null, , +                    "four", "five", "six", "seven", "eight", "nine");, +            assertTrue(busyObserver.onError);, +            assertTrue(busyObserver.onNextCount.get() < 9);, +            // no onCompleted because onError was invoked, +    }, +        try {, +            int n = 10;, +            for (int i = 0; i < n; i++) {, +                final CountDownLatch running = new CountDownLatch(2);, +                Future<?> f1 = tp.submit(new OnNextThread(o, 1, onNextCount, running));, +                Future<?> f2 = tp.submit(new OnNextThread(o, 1, onNextCount, running));, +, +                running.await(); // let one of the OnNextThread actually run before proceeding, +        } finally {, +            tp.shutdown();, +        }, +    }, +        private final CountDownLatch running;, +        OnNextThread(Observer<String> observer, int numStringsToSend, CountDownLatch latch, CountDownLatch running) {, +            this(observer, numStringsToSend, new AtomicInteger(), latch, running);, +            this(observer, numStringsToSend, produced, null, null);, +        OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced, CountDownLatch latch, CountDownLatch running) {, +            this.running = running;, +            if (running != null) {, +                running.countDown();, +            }, +    private static class TestSingleThreadedObservable implements Observable.OnSubscribe<String> {, +        public TestSingleThreadedObservable(final String... values) {, +        @Override, +        public void call(final Subscriber<? super String> observer) {, +    private static class TestMultiThreadedObservable implements Observable.OnSubscribe<String> {, +        public TestMultiThreadedObservable(String... values) {, +        public void call(final Subscriber<? super String> observer) {, +                        int j = 0;, +                            final int fj = ++j;, +                                        System.out.println("TestMultiThreadedObservable onNext: " + s + " on thread " + Thread.currentThread().getName());, +                                        } else {, +                                             // allow the exception to queue up, +                                            int sleep = (fj % 3) * 10;, +                                            if (sleep != 0) {, +                                                Thread.sleep(sleep);, +                                            }, +                        if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {, +                            System.out.println("Threadpool did not terminate in time.");, +                        }, +                    Thread.sleep(100);]