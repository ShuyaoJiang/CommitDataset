[+++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.operators.SafeObservableSubscription;, +    private final SafeObservableSubscription subscription;, +    private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        subscription = new SafeObservableSubscription();, +        if (subscribed.compareAndSet(false, true)) {, +            subscription.wrap(source.materialize().subscribe(this));, +        } else {, +            throw new IllegalStateException("Can only be subscribed to once.");, +        }, +++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.operators.SafeObservableSubscription;, +    private final SafeObservableSubscription subscription;, +    private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        subscription = new SafeObservableSubscription();, +        if (subscribed.compareAndSet(false, true)) {, +            subscription.wrap(source.materialize().subscribe(this));, +        } else {, +            throw new IllegalStateException("Can only be subscribed to once.");, +        }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +        /**, +         * Store the latest value but do not send it. It only gets sent when 'onCompleted' occurs., +         */, +++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.operators.SafeObservableSubscription;, +    private final SafeObservableSubscription subscription;, +    private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        subscription = new SafeObservableSubscription();, +        if (subscribed.compareAndSet(false, true)) {, +            subscription.wrap(source.materialize().subscribe(this));, +        } else {, +            throw new IllegalStateException("Can only be subscribed to once.");, +        }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +        /**, +         * Store the latest value but do not send it. It only gets sent when 'onCompleted' occurs., +         */, +++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java, +++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.operators.SafeObservableSubscription;, +    private final SafeObservableSubscription subscription;, +    private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        subscription = new SafeObservableSubscription();, +        if (subscribed.compareAndSet(false, true)) {, +            subscription.wrap(source.materialize().subscribe(this));, +        } else {, +            throw new IllegalStateException("Can only be subscribed to once.");, +        }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +        /**, +         * Store the latest value but do not send it. It only gets sent when 'onCompleted' occurs., +         */, +++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java, +++ b/rxjava-core/src/main/java/rx/subscriptions/BooleanSubscription.java, +import rx.util.functions.Action0;, +    private final Action0 action;, +, +    public BooleanSubscription() {, +        action = null;, +    }, +, +    private BooleanSubscription(Action0 action) {, +        this.action = action;, +    }, +, +    public static BooleanSubscription create() {, +        return new BooleanSubscription();, +    }, +, +    public static BooleanSubscription create(Action0 onUnsubscribe) {, +        return new BooleanSubscription(onUnsubscribe);, +    }, +    public final void unsubscribe() {, +        if (unsubscribed.compareAndSet(false, true)) {, +            if (action != null) {, +                action.call();, +            }, +        }, +++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.operators.SafeObservableSubscription;, +    private final SafeObservableSubscription subscription;, +    private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        subscription = new SafeObservableSubscription();, +        if (subscribed.compareAndSet(false, true)) {, +            subscription.wrap(source.materialize().subscribe(this));, +        } else {, +            throw new IllegalStateException("Can only be subscribed to once.");, +        }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java]