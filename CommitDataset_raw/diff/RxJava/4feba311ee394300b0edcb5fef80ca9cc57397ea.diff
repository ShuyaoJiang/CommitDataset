[+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import java.util.NoSuchElementException;, +import rx.concurrency.Schedulers;, +        private T next;, +        private boolean hasNext = true;, +        private boolean isNextConsumed = true;, +        private Throwable error = null;, +            if(error != null) {, +                // If any error has already been thrown, throw it again., +                throw Exceptions.propagate(error);, +            }, +            // Since an iterator should not be used in different thread,, +            // so we do not need any synchronization., +            if(hasNext == false) {, +                // the iterator has reached the end., +                return false;, +            }, +            if(isNextConsumed == false) {, +                // next has not been used yet., +                return true;, +            }, +            return moveToNext();, +        }, +, +        private boolean moveToNext() {, +            try {, +                Notification<? extends T> nextNotification = observer.takeNext();, +                if(nextNotification.isOnNext()) {, +                    isNextConsumed = false;, +                    next = nextNotification.getValue();, +                    return true;, +                }, +                // If an observable is completed or fails,, +                // hasNext() always return false., +                hasNext = false;, +                if(nextNotification.isOnCompleted()) {, +                    return false;, +                }, +                if(nextNotification.isOnError()) {, +                    error = nextNotification.getThrowable();, +                    throw Exceptions.propagate(error);, +                }, +                throw new IllegalStateException("Should not reach here");, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +                error = e;, +                throw Exceptions.propagate(error);, +            }, +            if(error != null) {, +                // If any error has already been thrown, throw it again., +                throw Exceptions.propagate(error);, +            if(hasNext()) {, +                isNextConsumed = true;, +                return next;, +            else {, +                throw new NoSuchElementException("No more elements");, +            }, +                    if (concurrentItem != null && !concurrentItem.isOnNext()) {, +        public Notification<? extends T> takeNext() throws InterruptedException {, +            return buf.take();, +, +        private void fireOnNextInNewThread(final Subject<String, String> o, final String value) {, +            new Thread() {, +                @Override, +                public void run() {, +                    try {, +                        Thread.sleep(500);, +                    } catch (InterruptedException e) {, +                        // ignore, +                    }, +                    o.onNext(value);, +                }, +            }.start();, +        }, +, +        private void fireOnErrorInNewThread(final Subject<String, String> o) {, +            new Thread() {, +                @Override, +                public void run() {, +                    try {, +                        Thread.sleep(500);, +                    } catch (InterruptedException e) {, +                        // ignore, +                    }, +                    o.onError(new TestException());, +                }, +            }.start();, +        }, +, +        public void testNext() {, +            fireOnNextInNewThread(obs, "one");, +            assertEquals("one", it.next());, +            fireOnNextInNewThread(obs, "two");, +            assertEquals("two", it.next());, +            try {, +                it.next();]