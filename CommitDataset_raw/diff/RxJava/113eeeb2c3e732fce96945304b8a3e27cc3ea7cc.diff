[+++ b/src/main/java/io/reactivex/Flowable.java, +        return new FlowableAmb<T>(null, sources);, +        return new FlowableAmb<T>(sources, null);, +        return new FlowableCombineLatest<T, R>(null, sources, combiner, s, delayError);, +        return new FlowableCombineLatest<T, R>(sources, null, combiner, s, delayError);, +        if (onSubscribe instanceof Flowable) {, +            throw new IllegalArgumentException("create(Flowable) should be upgraded");, +        }, +        return new FlowableDefer<T>(supplier);, +        return FlowableEmpty.empty();, +        return new FlowableError<T>(errorSupplier);, +        return new FlowableFromArray<T>(values);, +        return new FlowableFromCallable<T>(supplier);, +        Flowable<T> o = new FlowableFromFuture<T>(future, 0L, null);, +        Flowable<T> o = new FlowableFromFuture<T>(future, timeout, unit);, +        return new FlowableFromIterable<T>(source);, +        return new FlowableGenerate<T, S>(initialState, generator, disposeState);, +        return new FlowableInterval(initialDelay, period, unit, scheduler);, +        return new FlowableIntervalRange(start, end, initialDelay, period, unit, scheduler);, +        return new FlowableJust<T>(value);, +        return new FlowableRange(start, count);, +        return new FlowableSequenceEqual<T>(p1, p2, isEqual, bufferSize);, +        return new FlowableTimer(delay, unit, scheduler);, +        return new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager);, +        return new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false);, +        return new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError);, +        return new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError);, +        return new FlowableAll<T>(this, predicate);, +        return new FlowableAny<T>(this, predicate);, +        return new FlowableBuffer<T, U>(this, count, skip, bufferSupplier);, +        return new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);, +        return new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);, +        return new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);, +        return new FlowableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);, +        return new FlowableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);, +        return FlowableCache.from(this);, +        return FlowableCache.from(this, capacityHint);, +        return new FlowableCollect<T, U>(this, initialValueSupplier, collector);, +        return new FlowableConcatMap<T, R>(this, mapper, prefetch);, +                return new FlowableFromIterable<U>(mapper.apply(v));, +        return new FlowableCount<T>(this);, +        return new FlowableDebounce<T, U>(this, debounceSelector);, +        return new FlowableDebounceTimed<T>(this, timeout, unit, scheduler);, +        return new FlowableDelay<T>(this, delay, unit, scheduler, delayError);, +        return new FlowableDelaySubscriptionOther<T, U>(this, other);, +        return new FlowableDematerialize<T2>(m);, +        return FlowableDistinct.withCollection(this, keySelector, collectionSupplier);, +        return FlowableDistinct.<T>untilChanged(this);, +        return FlowableDistinct.untilChanged(this, keySelector);, +        return new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate);, +        return new FlowableElementAt<T>(this, index, null);, +        return new FlowableElementAt<T>(this, index, defaultValue);, +        return new FlowableFilter<T>(this, predicate);, +        if (this instanceof FlowableJust) {, +            FlowableJust<T> scalar = (FlowableJust<T>) this;, +        return new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize);, +        // FIXME run flatMap directly, +        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        // FIXME run flatMap directly, +        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +                return new FlowableFromIterable<U>(mapper.apply(v));, +                return new FlowableFromIterable<U>(mapper.apply(t));, +                return new FlowableFromIterable<U>(mapper.apply(v));, +        return new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError);, +        return new FlowableIgnoreElements<T>(this);, +        return new FlowableLift<R, T>(this, lifter);, +        return new FlowableMap<T, R>(this, mapper);, +        return new FlowableMaterialize<T>(this);, +        return new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize);, +        return new FlowableOnBackpressureBuffer<T>(this, bufferSize, unbounded, delayError, Functions.emptyRunnable());, +        return new FlowableOnBackpressureBuffer<T>(this, bufferSize, unbounded, delayError, onOverflow);, +        return new FlowableOnBackpressureDrop<T>(this);, +        return new FlowableOnBackpressureDrop<T>(this, onDrop);, +        return new FlowableOnBackpressureLatest<T>(this);, +        return new FlowableOnErrorNext<T>(this, resumeFunction, false);, +        return new FlowableOnErrorReturn<T>(this, valueSupplier);, +        return new FlowableOnErrorNext<T>(this, new Function<Throwable, Publisher<? extends T>>() {, +        }, true);, +        return FlowablePublish.create(this, selector, bufferSize);, +        return FlowablePublish.create(this, bufferSize);, +        return new FlowableRepeat<T>(this, times);, +        return new FlowableRepeatUntil<T>(this, stop);, +        return new FlowableRedo<T>(this, f);, +        return FlowableReplay.createFrom(this);, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {, +        return FlowableReplay.create(this, bufferSize);, +        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);, +        return FlowableReplay.observeOn(replay(bufferSize), scheduler);, +        return FlowableReplay.create(this, time, unit, scheduler);, +        return FlowableReplay.observeOn(replay(), scheduler);, +        return new FlowableRetryBiPredicate<T>(this, predicate);, +        return new FlowableRetryPredicate<T>(this, times, predicate);, +        return new FlowableRedo<T>(this, f);, +        return new FlowableSampleTimed<T>(this, period, unit, scheduler);, +        return new FlowableSamplePublisher<T>(this, sampler);]