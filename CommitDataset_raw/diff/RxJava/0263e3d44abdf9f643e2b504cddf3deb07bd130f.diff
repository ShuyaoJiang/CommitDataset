[+++ b/src/main/java/io/reactivex/Observable.java, +    public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {, +        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());, +    }, +, +    public final <R> Observable<R> flatMap(, +            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , +            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, , +            Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {, +        return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)));, +    }, +, +    public final <R> Observable<R> flatMap(, +            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , +            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper, , +            Supplier<? extends Publisher<? extends R>> onCompleteSupplier, , +            int maxConcurrency) {, +        return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)), maxConcurrency);, +    }, +, +    public final <U, V> Observable<V> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends V> resultSelector) {, +        return flatMap(t -> new PublisherIterableSource<>(mapper.apply(t)), resultSelector, false, bufferSize(), bufferSize());, +    }, +, +++ b/src/main/java/io/reactivex/Observable.java, +    public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {, +        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());, +    }, +, +    public final <R> Observable<R> flatMap(, +            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , +            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, , +            Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {, +        return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)));, +    }, +, +    public final <R> Observable<R> flatMap(, +            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , +            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper, , +            Supplier<? extends Publisher<? extends R>> onCompleteSupplier, , +            int maxConcurrency) {, +        return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)), maxConcurrency);, +    }, +, +    public final <U, V> Observable<V> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends V> resultSelector) {, +        return flatMap(t -> new PublisherIterableSource<>(mapper.apply(t)), resultSelector, false, bufferSize(), bufferSize());, +    }, +, +++ b/src/main/java/io/reactivex/internal/operators/OperatorMapNotification.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.concurrent.atomic.*;, +import java.util.function.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Observable.Operator;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.BackpressureHelper;, +, +public final class OperatorMapNotification<T, R> implements Operator<Publisher<? extends R>, T>{, +, +    final Function<? super T, ? extends Publisher<? extends R>> onNextMapper;, +    final Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper;, +    final Supplier<? extends Publisher<? extends R>> onCompleteSupplier;, +, +    public OperatorMapNotification(Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , +            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, , +            Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {, +        this.onNextMapper = onNextMapper;, +        this.onErrorMapper = onErrorMapper;, +        this.onCompleteSupplier = onCompleteSupplier;, +    }, +    , +    @Override, +    public Subscriber<? super T> apply(Subscriber<? super Publisher<? extends R>> t) {, +        return new MapNotificationSubscriber<>(t, onNextMapper, onErrorMapper, onCompleteSupplier);, +    }, +    , +    static final class MapNotificationSubscriber<T, R>, +    extends AtomicLong, +    implements Subscriber<T>, Subscription {, +        /** */, +        private static final long serialVersionUID = 2757120512858778108L;, +        ]