[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * An [[Observer]] must call an Observable's `subscribe` method in order to, +   * A typical implementation of `subscribe` does the following:, +   *, +   * It stores a reference to the Observer in a collection object, such as a `List[T]` object., +   *, +   * It returns a reference to the [[Subscription]] interface. This enables Observers to, +   * sending them, which also invokes the Observer's [[Observer.onCompleted onCompleted]] method., +   *, +   * An `Observable[T]` instance is responsible for accepting all subscriptions, +   * `Observable[T]` implementation indicates otherwise, Observers should make no, +   *, +   * @return a [[Subscription]] reference with which the [[Observer]] can stop receiving items, +   *             if the [[Observer]] provided as the argument to `subscribe()` is `null`, +   * An [[Observer]] must call an Observable's `subscribe` method in order to, +   * A typical implementation of `subscribe` does the following:, +   *, +   * It stores a reference to the Observer in a collection object, such as a `List[T]` object., +   *, +   * It returns a reference to the [[Subscription]] interface. This enables Observers to, +   * sending them, which also invokes the Observer's [[Observer.onCompleted onCompleted]] method., +   *, +   * An `Observable[T]` instance is responsible for accepting all subscriptions, +   * and notifying all Observers. Unless the documentation for a particular `Observable[T]` implementation indicates otherwise, Observers should make no, +   *, +   *            the [[Scheduler]] on which Observers subscribe to the Observable, +   * @return a [[Subscription]] reference with which Observers can stop receiving items and, +   *             if an argument to `subscribe()` is `null`, +   * Returns a [[ConnectableObservable]] that upon connection causes the source Observable to, +   *            the [[Subject]] for the [[ConnectableObservable]] to push source items, +   * @tparam R, +   * @return a pair of a start function and an [[Observable]] such that when the start function, +   *         is called, the Observable starts to push results into the specified [[Subject]], +   *, +   *, +   *, +   *, +   * A well-behaved Observable does not interleave its invocations of the [[Observer.onNext onNext]], [[Observer.onCompleted onCompleted]], and [[Observer.onError onError]] methods of, +   * its [[Observer]]s; it invokes `onCompleted` or `onError` only once; and it never invokes `onNext` after invoking either `onCompleted` or `onError`., +   * `synchronize` enforces this, and the Observable it returns invokes `onNext` and `onCompleted` or `onError` synchronously., +   * @tparam T, +   *         Observable, and that synchronously notifies its [[Observer]]s, +   * Wraps each item emitted by a source Observable in a [[Timestamped]] object., +   *, +   * The number of `onNext` invocations of the resulting `Observable[(T, U)]`, +   * is the minumum of the number of `onNext` invocations of `this` and `that`. , +  // public static [R] Observable[R] zip(Observable<? extends Observable<?>> ws, final FuncN<? extends R> zipFunction) {, +   * This Observable produces connected non-overlapping buffers. The current buffer is, +   * emitted and replaced with a new buffer when the Observable produced by the specified [[Func0]] produces a [[rx.lang.scala.util.Closing]] object. The * [[Func0]] will then, +   *            The [[Func0]] which is used to produce an [[Observable]] for every buffer created., +   *            When this [[Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +   *         An [[Observable]] which produces connected non-overlapping buffers, which are emitted, +   *         when the current [[Observable]] created with the [[Func0]] argument produces a [[rx.lang.scala.util.Closing]] object., +   * This Observable produces buffers. Buffers are created when the specified "bufferOpenings", +   * Observable produces a [[rx.lang.scala.util.Opening]] object. Additionally the [[Func0]] argument, +   * is used to create an Observable which produces [[rx.lang.scala.util.Closing]] objects. When this, +   *            The [[Observable]] which, when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            The [[Func0]] which is used to produce an [[Observable]] for every buffer created., +   *            When this [[Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +   *         An [[Observable]] which produces buffers which are created and emitted when the specified [[Observable]]s publish certain objects., +   * This Observable produces connected non-overlapping buffers, each containing "count", +   *         An [[Observable]] which produces connected non-overlapping buffers containing at most, +   * This Observable produces buffers every "skip" values, each containing "count", +   *            "count" are equals that this is the same operation as [[Observable.buffer(int)]]., +   *         An [[Observable]] which produces buffers every "skipped" values containing at most, +   * This Observable produces connected non-overlapping buffers, each of a fixed duration, +   * specified by the `timespan` argument. When the source Observable completes or encounters, +   *         An [[Observable]] which produces connected non-overlapping buffers with a fixed duration., +   * This Observable produces connected non-overlapping buffers, each of a fixed duration, +   * specified by the `timespan` argument. When the source Observable completes or encounters, +   *            The [[Scheduler]] to use when determining the end and start of a buffer., +   *         An [[Observable]] which produces connected non-overlapping buffers with a fixed duration., +   * non-overlapping buffers, each of a fixed duration specified by the `timespan` argument or a maximum size, +   *         An [[Observable]] which produces connected non-overlapping buffers which are emitted after, +   * non-overlapping buffers, each of a fixed duration specified by the `timespan` argument or a maximum size, +   *            The [[Scheduler]] to use when determining the end and start of a buffer., +   *         An [[Observable]] which produces connected non-overlapping buffers which are emitted after, +   * periodically, which is determined by the `timeshift` argument. Each buffer is emitted after a fixed timespan, +   * specified by the `timespan` argument. When the source Observable completes or encounters an error, the, +   *         An [[Observable]] which produces new buffers periodically, and these are emitted after, +   * periodically, which is determined by the `timeshift` argument. Each buffer is emitted after a fixed timespan, +   * specified by the `timespan` argument. When the source Observable completes or encounters an error, the, +   *            The [[Scheduler]] to use when determining the end and start of a buffer., +   *         An [[Observable]] which produces new buffers periodically, and these are emitted after, +   * Observable produced by the specified [[Func0]] produces a [[rx.lang.scala.util.Closing]] object. The [[Func0]] will then be used to create a new Observable to listen for the end of the next, +   *            The [[Func0]] which is used to produce an [[Observable]] for every window created., +   *            When this [[Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +   *         An [[Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[Observable]] created with the [[Func0]] argument produces a [[rx.lang.scala.util.Closing]] object., +   * Chunks are created when the specified "windowOpenings" Observable produces a [[rx.lang.scala.util.Opening]] object., +   * Additionally the [[Func0]] argument is used to create an Observable which produces [[rx.lang.scala.util.Closing]] objects. When this Observable produces such an object, the associated window is, +   *            The [[Observable]] which when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            The [[Func0]] which is used to produce an [[Observable]] for every window created., +   *            When this [[Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +   *         An [[Observable]] which produces windows which are created and emitted when the specified [[Observable]]s publish certain objects., +   *         An [[Observable]] which produces connected non-overlapping windows containing at most, +   *            "count" are equals that this is the same operation as [[Observable.window(Observable, int)]]., +   *         An [[Observable]] which produces windows every "skipped" values containing at most, +   * non-overlapping windows, each of a fixed duration specified by the `timespan` argument. When the source, +   *         An [[Observable]] which produces connected non-overlapping windows with a fixed duration.]