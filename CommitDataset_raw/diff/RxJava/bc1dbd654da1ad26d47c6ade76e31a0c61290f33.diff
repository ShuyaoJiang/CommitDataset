[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Long): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable.asInstanceOf[rx.Observable[T]])), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Long): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable.asInstanceOf[rx.Observable[T]])), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "flatMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "flatMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])`]",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]])" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]])",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "retryWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_]])" -> "retryWhen(Observable[Notification[Any]] => Observable[Any])",, +      "defer(Func0[Observable[T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)`]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]",, +      "zipWith(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter {, +      m =>, +        m.isMethod && m.isPublic &&, +          m.annotations.forall(_.toString != "java.lang.Deprecated") // don't check deprecated classes, +    }), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Long): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable.asInstanceOf[rx.Observable[T]])), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "flatMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "flatMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])`]",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]])" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]])",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "retryWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_]])" -> "retryWhen(Observable[Notification[Any]] => Observable[Any])",, +      "defer(Func0[Observable[T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)`]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]",, +      "zipWith(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter {, +      m =>, +        m.isMethod && m.isPublic &&, +          m.annotations.forall(_.toString != "java.lang.Deprecated") // don't check deprecated classes, +    }), +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +        final QueueProducer<T> producer = new QueueProducer<T>(notification, deque, subscriber);, +, +    private static final class QueueProducer<T> implements Producer {, +, +        private final NotificationLite<T> notification;, +        private final Deque<Object> deque;, +        private final Subscriber<? super T> subscriber;, +        private volatile boolean emittingStarted = false;, +, +        public QueueProducer(NotificationLite<T> n, Deque<Object> q, Subscriber<? super T> subscriber) {, +            this.notification = n;, +            this.deque = q;, +            this.subscriber = subscriber;, +        }, +, +        private volatile long requested = 0;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<QueueProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(QueueProducer.class, "requested");, +, +        void startEmitting() {, +            if (!emittingStarted) {, +                emittingStarted = true;, +                emit(0); // start emitting, +            }, +        }, +, +        @Override, +        public void request(long n) {, +            if (requested == Long.MAX_VALUE) {, +                return;, +            }, +            long _c;, +            if (n == Long.MAX_VALUE) {, +                _c = REQUESTED_UPDATER.getAndSet(this, Long.MAX_VALUE);, +            } else {, +                _c = REQUESTED_UPDATER.getAndAdd(this, n);, +            }, +            if (!emittingStarted) {, +                // we haven't started yet, so record what was requested and return, +                return;, +            }, +            emit(_c);, +        }, +, +        void emit(long previousRequested) {, +            if (requested == Long.MAX_VALUE) {, +                // fast-path without backpressure, +                if (previousRequested == 0) {, +                    try {, +                        for (Object value : deque) {, +                            notification.accept(subscriber, value);, +                        }, +                    } catch (Throwable e) {, +                        subscriber.onError(e);]