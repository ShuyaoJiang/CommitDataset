[+++ b/src/main/java/io/reactivex/Observable.java, +, +    public final Observable<T> sample(long period, TimeUnit unit) {, +        return sample(period, unit, Schedulers.computation());, +    }, +, +    public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {, +        Objects.requireNonNull(unit);, +        Objects.requireNonNull(scheduler);, +        return lift(new OperatorSampleTimed<>(period, unit, scheduler));, +    }, +    , +    public final <U> Observable<T> sample(Publisher<U> sampler) {, +        Objects.requireNonNull(sampler);, +        return lift(new OperatorSamplePublisher<>(sampler));, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +, +    public final Observable<T> sample(long period, TimeUnit unit) {, +        return sample(period, unit, Schedulers.computation());, +    }, +, +    public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {, +        Objects.requireNonNull(unit);, +        Objects.requireNonNull(scheduler);, +        return lift(new OperatorSampleTimed<>(period, unit, scheduler));, +    }, +    , +    public final <U> Observable<T> sample(Publisher<U> sampler) {, +        Objects.requireNonNull(sampler);, +        return lift(new OperatorSamplePublisher<>(sampler));, +    }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSamplePublisher.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.concurrent.atomic.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Observable.Operator;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.BackpressureHelper;, +import io.reactivex.subscribers.SerializedSubscriber;, +, +public final class OperatorSamplePublisher<T> implements Operator<T, T> {, +    final Publisher<?> other;, +    , +    public OperatorSamplePublisher(Publisher<?> other) {, +        this.other = other;, +    }, +    , +    , +    @Override, +    public Subscriber<? super T> apply(Subscriber<? super T> t) {, +        SerializedSubscriber<T> serial = new SerializedSubscriber<>(t);, +        return new SamplePublisherSubscriber<>(serial, other);, +    }, +    , +    static final class SamplePublisherSubscriber<T> extends AtomicReference<T> implements Subscriber<T>, Subscription {, +        /** */, +        private static final long serialVersionUID = -3517602651313910099L;, +, +        final Subscriber<? super T> actual;, +        final Publisher<?> sampler;, +        , +        volatile long requested;, +        @SuppressWarnings("rawtypes"), +        static final AtomicLongFieldUpdater<SamplePublisherSubscriber> REQUESTED =, +                AtomicLongFieldUpdater.newUpdater(SamplePublisherSubscriber.class, "requested");, +, +        volatile Subscription other;, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<SamplePublisherSubscriber, Subscription> OTHER =, +                AtomicReferenceFieldUpdater.newUpdater(SamplePublisherSubscriber.class, Subscription.class, "other");, +        , +        static final Subscription CANCELLED = new Subscription() {, +            @Override, +            public void request(long n) {, +                , +            }, +            , +            @Override, +            public void cancel() {, +                , +            }, +        };, +        ]