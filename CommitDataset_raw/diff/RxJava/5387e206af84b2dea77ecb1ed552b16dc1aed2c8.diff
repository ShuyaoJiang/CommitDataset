[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.disposables.SequentialDisposable;, +import io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSupport;, +            TimeoutSubscriber<T> parent = new TimeoutSubscriber<T>(s, itemTimeoutIndicator);, +            s.onSubscribe(parent);, +            parent.startFirstTimeout(firstTimeoutIndicator);, +            source.subscribe(parent);, +            TimeoutFallbackSubscriber<T> parent = new TimeoutFallbackSubscriber<T>(s, itemTimeoutIndicator, other);, +            s.onSubscribe(parent);, +            parent.startFirstTimeout(firstTimeoutIndicator);, +            source.subscribe(parent);, +    interface TimeoutSelectorSupport extends TimeoutSupport {, +        void onTimeoutError(long idx, Throwable ex);, +    }, +, +    static final class TimeoutSubscriber<T> extends AtomicLong, +    implements FlowableSubscriber<T>, Subscription, TimeoutSelectorSupport {, +, +        private static final long serialVersionUID = 3764492702657003550L;, +, +        final Function<? super T, ? extends Publisher<?>> itemTimeoutIndicator;, +        final SequentialDisposable task;, +        final AtomicReference<Subscription> upstream;, +        final AtomicLong requested;, +        TimeoutSubscriber(Subscriber<? super T> actual, Function<? super T, ? extends Publisher<?>> itemTimeoutIndicator) {, +            this.task = new SequentialDisposable();, +            this.upstream = new AtomicReference<Subscription>();, +            this.requested = new AtomicLong();, +            SubscriptionHelper.deferredSetOnce(upstream, requested, s);, +            long idx = get();, +            if (idx == Long.MAX_VALUE || !compareAndSet(idx, idx + 1)) {, +                return;, +            }, +            Disposable d = task.get();, +            actual.onNext(t);, +, +            Publisher<?> itemTimeoutPublisher;, +                itemTimeoutPublisher = ObjectHelper.requireNonNull(, +                        itemTimeoutIndicator.apply(t),, +                        "The itemTimeoutIndicator returned a null Publisher.");, +            } catch (Throwable ex) {, +                Exceptions.throwIfFatal(ex);, +                upstream.get().cancel();, +                getAndSet(Long.MAX_VALUE);, +                actual.onError(ex);, +            TimeoutConsumer consumer = new TimeoutConsumer(idx + 1, this);, +            if (task.replace(consumer)) {, +                itemTimeoutPublisher.subscribe(consumer);, +            }, +        }, +        void startFirstTimeout(Publisher<?> firstTimeoutIndicator) {, +            if (firstTimeoutIndicator != null) {, +                TimeoutConsumer consumer = new TimeoutConsumer(0L, this);, +                if (task.replace(consumer)) {, +                    firstTimeoutIndicator.subscribe(consumer);, +                }, +            if (getAndSet(Long.MAX_VALUE) != Long.MAX_VALUE) {, +                task.dispose();, +, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +            if (getAndSet(Long.MAX_VALUE) != Long.MAX_VALUE) {, +                task.dispose();, +, +        }, +, +        @Override, +        public void onTimeout(long idx) {, +            if (compareAndSet(idx, Long.MAX_VALUE)) {, +                SubscriptionHelper.cancel(upstream);, +, +                actual.onError(new TimeoutException());, +            }, +        }, +, +        @Override, +        public void onTimeoutError(long idx, Throwable ex) {, +            if (compareAndSet(idx, Long.MAX_VALUE)) {, +                SubscriptionHelper.cancel(upstream);, +, +                actual.onError(ex);, +            } else {, +                RxJavaPlugins.onError(ex);, +            }, +        }, +            SubscriptionHelper.deferredRequest(upstream, requested, n);, +            SubscriptionHelper.cancel(upstream);, +            task.dispose();, +    static final class TimeoutFallbackSubscriber<T> extends SubscriptionArbiter, +    implements FlowableSubscriber<T>, TimeoutSelectorSupport {, +, +        private static final long serialVersionUID = 3764492702657003550L;, +, +        final Function<? super T, ? extends Publisher<?>> itemTimeoutIndicator;, +        final SequentialDisposable task;, +        final AtomicReference<Subscription> upstream;, +        final AtomicLong index;, +        Publisher<? extends T> fallback;]