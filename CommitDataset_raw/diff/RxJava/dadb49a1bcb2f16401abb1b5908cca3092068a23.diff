[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, +    }, +, +    public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, +            Function<? super T, ? extends Publisher<? extends U>> mapper,, +            boolean delayErrors, int maxConcurrency, int bufferSize) {, +        return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, +    }, +, +    public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, +            Function<? super T, ? extends Publisher<? extends U>> mapper,, +            boolean delayErrors, int maxConcurrency, int bufferSize) {, +        return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelCollect.java, +import io.reactivex.internal.functions.ObjectHelper;, +    final Callable<? extends C> initialCollection;, +    final BiConsumer<? super C, ? super T> collector;, +            Callable<? extends C> initialCollection, BiConsumer<? super C, ? super T> collector) {, +                initialValue = ObjectHelper.requireNonNull(initialCollection.call(), "The initialSupplier returned a null value");, +        final BiConsumer<? super C, ? super T> collector;, +                C initialValue, BiConsumer<? super C, ? super T> collector) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, +    }, +, +    public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, +            Function<? super T, ? extends Publisher<? extends U>> mapper,, +            boolean delayErrors, int maxConcurrency, int bufferSize) {, +        return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelCollect.java, +import io.reactivex.internal.functions.ObjectHelper;, +    final Callable<? extends C> initialCollection;, +    final BiConsumer<? super C, ? super T> collector;, +            Callable<? extends C> initialCollection, BiConsumer<? super C, ? super T> collector) {, +                initialValue = ObjectHelper.requireNonNull(initialCollection.call(), "The initialSupplier returned a null value");, +        final BiConsumer<? super C, ? super T> collector;, +                C initialValue, BiConsumer<? super C, ? super T> collector) {, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelConcatMap.java, +            parents[i] = FlowableConcatMap.subscribe(subscribers[i], mapper, prefetch, errorMode);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, +    }, +, +    public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, +            Function<? super T, ? extends Publisher<? extends U>> mapper,, +            boolean delayErrors, int maxConcurrency, int bufferSize) {, +        return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelCollect.java, +import io.reactivex.internal.functions.ObjectHelper;, +    final Callable<? extends C> initialCollection;, +    final BiConsumer<? super C, ? super T> collector;, +            Callable<? extends C> initialCollection, BiConsumer<? super C, ? super T> collector) {, +                initialValue = ObjectHelper.requireNonNull(initialCollection.call(), "The initialSupplier returned a null value");, +        final BiConsumer<? super C, ? super T> collector;, +                C initialValue, BiConsumer<? super C, ? super T> collector) {, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelConcatMap.java, +            parents[i] = FlowableConcatMap.subscribe(subscribers[i], mapper, prefetch, errorMode);, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFilter.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +            Subscriber<? super T> a = subscribers[i];, +            if (a instanceof ConditionalSubscriber) {, +                parents[i] = new ParallelFilterConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, predicate);, +            } else {, +                parents[i] = new ParallelFilterSubscriber<T>(a, predicate);, +            }, +    abstract static class BaseFilterSubscriber<T> implements ConditionalSubscriber<T>, Subscription {, +        BaseFilterSubscriber(Predicate<? super T> predicate) {, +        public final void request(long n) {, +        public final void cancel() {, +        public final void onNext(T t) {, +            if (!tryOnNext(t)) {, +                s.request(1);, +            }, +        }, +    }, +, +    static final class ParallelFilterSubscriber<T> extends BaseFilterSubscriber<T> {, +, +        final Subscriber<? super T> actual;, +, +        ParallelFilterSubscriber(Subscriber<? super T> actual, Predicate<? super T> predicate) {, +            super(predicate);, +            this.actual = actual;, +        }, +, +        @Override, +        public boolean tryOnNext(T t) {, +            if (!done) {, +                    return false;, +                    return true;, +            return false;, +        }, +            if (!done) {, +        }, +    }, +    static final class ParallelFilterConditionalSubscriber<T> extends BaseFilterSubscriber<T> {, +]