[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleLift.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.ObjectHelper;, +        SingleObserver<? super T> sr;, +        try {, +            sr = ObjectHelper.requireNonNull(onLift.apply(s), "The onLift returned a null SingleObserver");, +            Exceptions.throwIfFatal(ex);, +            EmptyDisposable.error(ex, s);, +            return;, +, +        source.subscribe(sr);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleLift.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.ObjectHelper;, +        SingleObserver<? super T> sr;, +        try {, +            sr = ObjectHelper.requireNonNull(onLift.apply(s), "The onLift returned a null SingleObserver");, +            Exceptions.throwIfFatal(ex);, +            EmptyDisposable.error(ex, s);, +            return;, +, +        source.subscribe(sr);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.*;, +                       Function<? super U, ? extends SingleSource<? extends T>> singleFunction,, +                       Consumer<? super U> disposer,, +        SingleSource<? extends T> source;, +            source = ObjectHelper.requireNonNull(singleFunction.apply(resource), "The singleFunction returned a null SingleSource");, +, +            if (eager) {, +                try {, +                    disposer.accept(resource);, +                } catch (Throwable exc) {, +                    Exceptions.throwIfFatal(exc);, +                    ex = new CompositeException(ex, exc);, +                }, +            }, +            if (!eager) {, +                try {, +                    disposer.accept(resource);, +                } catch (Throwable exc) {, +                    Exceptions.throwIfFatal(exc);, +                    RxJavaPlugins.onError(exc);, +                }, +            }, +        source.subscribe(new UsingSingleObserver<T, U>(s, resource, eager, disposer));, +    }, +, +    static final class UsingSingleObserver<T, U> extends, +    AtomicReference<Object> implements SingleObserver<T>, Disposable {, +        /** */, +        private static final long serialVersionUID = -5331524057054083935L;, +, +        final SingleObserver<? super T> actual;, +, +        final Consumer<? super U> disposer;, +, +        final boolean eager;, +, +        Disposable d;, +, +        public UsingSingleObserver(SingleObserver<? super T> actual, U resource, boolean eager,, +                Consumer<? super U> disposer) {, +            super(resource);, +            this.actual = actual;, +            this.eager = eager;, +            this.disposer = disposer;, +        }, +, +        @Override, +        public void dispose() {, +            d.dispose();, +            d = DisposableHelper.DISPOSED;, +            disposeAfter();, +        }, +, +        @Override, +        public boolean isDisposed() {, +            return d.isDisposed();, +        }, +            if (DisposableHelper.validate(this.d, d)) {, +                this.d = d;, +, +                actual.onSubscribe(this);, +        @SuppressWarnings("unchecked"), +            d = DisposableHelper.DISPOSED;, +, +                Object u = getAndSet(this);, +                if (u != this) {, +                        disposer.accept((U)u);, +                    } catch (Throwable ex) {, +                        Exceptions.throwIfFatal(ex);, +                        actual.onError(ex);, +                        return;, +                    }, +                } else {]