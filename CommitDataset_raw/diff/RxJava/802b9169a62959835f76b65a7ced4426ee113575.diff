[+++ b/src/main/java/io/reactivex/Observable.java, +    , +    public final Observable<T> first() {, +        return take(1).single();, +    }, +    , +    public final Observable<T> first(T defaultValue) {, +        return take(1).single(defaultValue);, +    }, +    , +    public final Observable<T> last() {, +        return takeLast(1).single();, +    }, +    , +    public final Observable<T> last(T defaultValue) {, +        return takeLast(1).single(defaultValue);, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +    , +    public final Observable<T> first() {, +        return take(1).single();, +    }, +    , +    public final Observable<T> first(T defaultValue) {, +        return take(1).single(defaultValue);, +    }, +    , +    public final Observable<T> last() {, +        return takeLast(1).single();, +    }, +    , +    public final Observable<T> last(T defaultValue) {, +        return takeLast(1).single(defaultValue);, +    }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSkipLastTimed.java, +import io.reactivex.Scheduler;, +            final SpscLinkedArrayQueue<Object> q = queue;, +            q.offer(now, t);, +++ b/src/main/java/io/reactivex/Observable.java, +    , +    public final Observable<T> first() {, +        return take(1).single();, +    }, +    , +    public final Observable<T> first(T defaultValue) {, +        return take(1).single(defaultValue);, +    }, +    , +    public final Observable<T> last() {, +        return takeLast(1).single();, +    }, +    , +    public final Observable<T> last(T defaultValue) {, +        return takeLast(1).single(defaultValue);, +    }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSkipLastTimed.java, +import io.reactivex.Scheduler;, +            final SpscLinkedArrayQueue<Object> q = queue;, +            q.offer(now, t);, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +    , +    /**, +     * Offer two elements at the same time., +     * <p>Don't use the regular offer() with this at all!, +     * @param first, +     * @param second, +     * @return, +     */, +    public boolean offer(T first, T second) {, +        final AtomicReferenceArray<Object> buffer = producerBuffer;, +        final long p = producerIndex;, +        final int m = producerMask;, +        , +        int pi = calcWrappedOffset(p + 1, m);, +        , +        if (null == lvElement(buffer, pi)) {, +            soElement(buffer, pi, second);, +            soProducerIndex(p + 2);, +            soElement(buffer, pi - 1, first);, +        } else {, +            final int capacity = buffer.length();, +            final AtomicReferenceArray<Object> newBuffer = new AtomicReferenceArray<>(capacity);, +            producerBuffer = newBuffer;, +            , +            soElement(newBuffer, pi, second);// StoreStore, +            soElement(newBuffer, pi - 1, first);, +            soNext(buffer, newBuffer);, +            , +            soProducerIndex(p + 2);// this ensures correctness on 32bit platforms, +            , +            soElement(buffer, pi - 1, HAS_NEXT); // new buffer is visible after element is, +        }, +, +        return true;, +    }]