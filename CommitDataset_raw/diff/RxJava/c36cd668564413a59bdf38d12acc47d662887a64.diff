[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        if (count < 1) {, +            throw new IllegalArgumentException("Count must be positive");, +        }, +        return Observable.create(new OnSubscribeRange(start, start + (count - 1)));, +        return range(start, count).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        if (count < 1) {, +            throw new IllegalArgumentException("Count must be positive");, +        }, +        return Observable.create(new OnSubscribeRange(start, start + (count - 1)));, +        return range(start, count).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/operators/OnSubscribeRange.java, + * Emit ints from start to end inclusive., +        for (int i = start; i <= end; i++) {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        if (count < 1) {, +            throw new IllegalArgumentException("Count must be positive");, +        }, +        return Observable.create(new OnSubscribeRange(start, start + (count - 1)));, +        return range(start, count).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/operators/OnSubscribeRange.java, + * Emit ints from start to end inclusive., +        for (int i = start; i <= end; i++) {, +++ b/rxjava-core/src/test/java/rx/operators/OnSubscribeRangeTest.java, +import static org.junit.Assert.*;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import rx.util.functions.Action1;, +, +    @Test, +    public void testRangeUnsubscribe() {, +        @SuppressWarnings("unchecked"), +        Observer<Integer> observer = mock(Observer.class);, +        final AtomicInteger count = new AtomicInteger();, +        Observable.range(1, 1000).doOnNext(new Action1<Integer>() {, +, +            @Override, +            public void call(Integer t1) {, +                count.incrementAndGet();, +            }, +, +        }).take(3).subscribe(observer);, +, +        verify(observer, times(1)).onNext(1);, +        verify(observer, times(1)).onNext(2);, +        verify(observer, times(1)).onNext(3);, +        verify(observer, never()).onNext(4);, +        verify(observer, never()).onError(org.mockito.Matchers.any(Throwable.class));, +        verify(observer, times(1)).onCompleted();, +        assertEquals(3, count.get());, +    }]