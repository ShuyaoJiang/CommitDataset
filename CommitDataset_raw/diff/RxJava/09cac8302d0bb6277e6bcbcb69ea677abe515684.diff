[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.Opening;, +import rx.util.functions.Func5;, +import rx.util.functions.Func6;, +import rx.util.functions.Func7;, +import rx.util.functions.Func8;, +import rx.util.functions.Func9;, + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +    /**, +     * Executed when 'subscribe' is invoked., +     */, +    private final OnSubscribeFunc<T> onSubscribe;, +    /**, +     * Function interface for work to be performed when an {@link Observable} is subscribed to via {@link Observable#subscribe(Observer)}, +     * , +     * @param <T>, +     */, +    public static interface OnSubscribeFunc<T> extends Function {, +        public Subscription onSubscribe(Observer<? super T> t1);, +, +    }, +     *            {@link OnSubscribeFunc} to be executed when {@link #subscribe(Observer)} is called., +    protected Observable(OnSubscribeFunc<T> onSubscribe) {, +    private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, +    public Subscription subscribe(Observer<? super T> observer) {, +        OnSubscribeFunc<T> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);, +                Subscription s = onSubscribeFunction.onSubscribe(observer);, +                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));, +    public Subscription subscribe(Observer<? super T> observer, Scheduler scheduler) {, +    private Subscription protectivelyWrapAndSubscribe(Observer<? super T> o) {, +    public Subscription subscribe(final Action1<? super T> onNext) {, +    public Subscription subscribe(final Action1<? super T> onNext, Scheduler scheduler) {, +    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) {, +    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, Scheduler scheduler) {, +    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onComplete) {, +    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onComplete, Scheduler scheduler) {, +            super(new OnSubscribeFunc<T>() {, +                public Subscription onSubscribe(Observer<? super T> t1) {, +            super(new OnSubscribeFunc<T>() {, +                public Subscription onSubscribe(Observer<? super T> observer) {, +    public static <T> Observable<T> create(OnSubscribeFunc<T> func) {, +    public static <T> Observable<T> from(Iterable<? extends T> iterable) {, +    public static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {, +    public static <T> Observable<T> merge(List<? extends Observable<? extends T>> source) {, +    public static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> source) {, +    public static <T> Observable<T> merge(Observable<? extends T>... source) {, +    public static <T> Observable<T> concat(Observable<? extends T>... source) {, +    public static <T> Observable<T> mergeDelayError(List<? extends Observable<? extends T>> source) {, +    public static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> source) {, +    public static <T> Observable<T> mergeDelayError(Observable<? extends T>... source) {, +    public static <T> Observable<T> switchDo(Observable<? extends Observable<? extends T>> sequenceOfSequences) {, +        return create(OperationSwitch.switchDo((Observable<? extends Observable<? extends T>>) this));, +    public static <T> Observable<T> synchronize(Observable<? extends T> observable) {, +    public static <T> Observable<T> from(Future<? extends T> future) {, +    public static <T> Observable<T> from(Future<? extends T> future, Scheduler scheduler) {, +    public static <T> Observable<T> from(Future<? extends T> future, long timeout, TimeUnit unit) {, +     * @param o1, +     * @param o2, +     * @param zipFunction, +     *            a function that, when applied to an item emitted by each of the source, +     *            Observables, results in an item that will be emitted by the resulting Observable, +    public static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, zipFunction));, +    public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second) {, +    public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality) {, +     * @param o1, +     * @param o2, +     *            a second source Observable, +     * @param o3, +     * @param zipFunction, +    public static <T1, T2, T3, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, Func3<? super T1, ? super T2, ? super T3, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, o3, zipFunction));, +     * @param o1, +     * @param o2, +     *            a second source Observable, +     * @param o3, +     * @param o4, +     * @param zipFunction, +    public static <T1, T2, T3, T4, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, Observable<? extends T4> o4, Func4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, o3, o4, zipFunction));, +    }, +, +    /**, +     * Returns an Observable that emits the results of a function of your choosing applied to, +     * combinations of four items emitted, in sequence, by four other Observables., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0}, the first item emitted by {@code w1}, the first item emitted by {@code w2}, and the first item, +     * emitted by {@code w3}; the second item emitted by, +     * the new Observable will be the result of the function applied to the second item emitted by, +     * each of those Observables; and so forth., +     * <p>, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * of the source Observable that emits the fewest items., +     * , +     * @param o1, +     *            one source Observable, +     * @param o2, +     *            a second source Observable]