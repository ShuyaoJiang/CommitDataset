[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.functions.Function;, +            if (isInternalImplementation(observer)) {, +    /**, +     * Used for protecting against errors being thrown from Observer implementations and ensuring onNext/onError/onCompleted contract compliance., +     * <p>, +     * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +     */, +    private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {, +        AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +        return subscription.wrap(subscribe(new AtomicObserver<T>(subscription, o)));, +    }, +, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        protectivelyWrapAndSubscribe(new Observer<T>() {, +    /**, +     * Whether a given {@link Function} is an internal implementation inside rx.* packages or not., +     * <p>, +     * For why this is being used see https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +     * , +     * NOTE: If strong reasons for not depending on package names comes up then the implementation of this method can change to looking for a marker interface., +     * , +     * @param f, +     * @return, +     */, +    private boolean isInternalImplementation(Object o) {, +        if (o == null) {, +            return true;, +        }, +        return (o.getClass().getPackage().getName().startsWith("rx."));, +    }, +, +        @Test, +        public void testForEachWithError() {, +            try {, +                Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                    @Override, +                    public Subscription call(final Observer<String> observer) {, +                        final BooleanSubscription subscription = new BooleanSubscription();, +                        new Thread(new Runnable() {, +, +                            @Override, +                            public void run() {, +                                observer.onNext("one");, +                                observer.onNext("two");, +                                observer.onNext("three");, +                                observer.onCompleted();, +                            }, +                        }).start();, +                        return subscription;, +                    }, +                }).forEach(new Action1<String>() {, +]