[+++ b/DESIGN.md, +- `Observable` (RxJS, Rx.Net, RxJava v1.x without backpressure, RxJava v2)., +- Callbacks (the producer calls the function at its convenience)., +- IRQ, mouse events, IO interrupts., +- 2.x `Flowable` (with `request(n)` credit always granted faster or in larger quantity than producer)., +- Reactive Streams `Publisher` (with `request(n)` credit always granted faster or in larger quantity than producer)., +- Java 9 `Flow.Publisher` (with `request(n)` credit always granted faster than or in larger quantity than producer)., +- `Iterable`., +- 2.x/1.x `Observable` (without concurrency, producer and consumer on the same thread)., +- 2.x `Flowable` (without concurrency, producer and consumer on the same thread)., +- Reactive Streams `Publisher` (without concurrency, producer and consumer on the same thread)., +- Java 9 `Flow.Publisher` (without concurrency, producer and consumer on the same thread)., +- `Future` & `Promise`., +- `Single` (lazy `Future`)., +- 2.x `Flowable`., +- Reactive Streams `Publisher`., +- Java 9 `Flow.Publisher`., +- 1.x `Observable` (with backpressure)., +- `AsyncEnumerable`/`AsyncIterable`., +Flow control is any mitigation strategy that a consumer applies to reduce the flow of data., +- Controlling the production of data, such as with `Iterator.next` or `Subscription.request(n)`., +- Sync or async., +- Push., +- 0, 1, many or infinite items., +- Buffering, sampling, throttling, windowing, dropping, etc., +- Temporal and count-based strategies., +- Pull sources., +- Push Observables with backpressure strategy (i.e. `Observable.toFlowable(onBackpressureStrategy)`)., +- Sync or async., +- 0, 1, many or infinite items., +- Buffering, sampling, throttling, windowing, dropping, etc., +- Temporal and count-based strategies., +- `request(n)` consumer demand signal:, +	- For pull-based sources, this allows batched "async pull"., +	- For push-based sources, this allows backpressure signals to conditionally apply strategies (i.e. drop, first, buffer, sample, fail, etc.)., +You get a `Flowable` from:, +- Converting a Observable with a backpressure strategy., +- Create from sync/async `onSubscribe` API (which participate in backpressure semantics)., +- Pull sources., +- Push sources being windowed or flow controlled (such as `window(1)` or `take(1)`)., +- Sync or async., +- 1 item., +- Not applicable (don't subscribe if the single response is not wanted)., +Lazy representation of a unit of work that can complete or fail., +- Sync or async., +- 0 items., +Unlike RxJava 1.x, 2.x base classes are to be abstract, stateless and generally no longer wrap an `onSubscribe` callback - this saves allocation in assembly time without limiting the expressiveness. Operator methods and standard factories still live as final on the base classes., +Instead of the indirection of an `onSubscribe` and `lift`, operators are to be implemented by extending the base classes. For example, the `map`, +Since Java still doesn't have extension methods, "adding" more operators can only happen through helper methods such as `lift(C -> C)` and `compose(R -> P)` where `C` is the default consumer type (i.e. `rs.Subscriber`), `R` is the base type (i.e. `Flowable`) and `P` is the base interface (i.e. `rs.Publisher`). As before, the library itself may gain or lose standard operators and/or overloads through the same community process., +In concert, `create(onSubscribe)` will not be available; standard operators extend the base types directly. The conversion of other RS-based libraries will happen through the `Flowable.wrap(Publisher<T>)` static method. , +   - `create(SyncGenerator<T, S>)`: safe, synchronous generation of signals, one-by-one., +   - `create(AsyncOnSubscribe<T, S>)`: batch-create signals based on request patterns., +   - `create(Consumer<? super FlowEmitter<T>>)`: relay multiple values or error from multi-valued reactive-sources (i.e. button-clicks) while also give flow control options right there (buffer, drop, error, etc.)., +   - `createSingle(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e. addListener callbacks)., +   - `createEmpty(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources., +   - `create(SyncGenerator<T, S>)`: safe, synchronous generation of signals, one-by-one., +   - `create(Consumer<? super FlowEmitter<T>>)`: relay multiple values or error from multi-valued reactive-sources (i.e. button-clicks) while also give flow control options right there (buffer, drop, error, etc.)., +   - `createSingle(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e. addListener callbacks)., +   - `createEmpty(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources., +   - `create(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e. addListener callbacks)., +   - `create(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources., +  - `b` identifies `a` and decides to not apply itself. Example: `empty().flatMap()` is functionally a no-op., +  - `a` is `b` and the two operator's parameter set can be combined into a single application. Example: `filter(p1).filter(p2)` combined into `filter(p1 && p2)`., +This extends the RS `Subscriber`interface with an extra method: `boolean tryOnNext(T value)` and can help avoiding small request amounts in case an operator didn't forward but dropped the value. The canonical use is for the `filter()` operator where if the predicate returns false, the operator has to request 1 from upstream (since the downstream doesn't know there was a value dropped and thus not request itself). Operators wanting to participate in this fusion have to implement and subscribe with an extended `Subscriber` interface:, +The second category is when two (or more) operators share the same underlying queue and each append activity at the exit point (i.e. `poll()`) of the queue. This can work in two modes: synchronous and asynchronous., +In synchronous mode, the elements of the sequence is already available (i.e. a fixed `range()` or `fromArray()`, or can be synchronously calculated in a pull fashion in `fromIterable`. In this mode, the requesting and regular onError-path is bypassed and is forbidden. Sources have to return null from `pull()` and false from `isEmpty()` if they have no more values and throw from these methods if they want to indicate an exceptional case., +  - `poll()`., +  - `isEmpty()`., +  - `clear()`., +  - `size()`.]