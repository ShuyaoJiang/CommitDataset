[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, +            boolean callError = false;, +                       callError = true;, +            } else if(callError) {, +            } else {, +                drain();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, +            boolean callError = false;, +                       callError = true;, +            } else if(callError) {, +            } else {, +                drain();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java, +import org.junit.Test;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static io.reactivex.BackpressureOverflowStrategy.DROP_LATEST;, +import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;, +import static io.reactivex.internal.functions.Functions.EMPTY_ACTION;, +import static org.junit.Assert.assertEquals;, +, +    public void backpressureWithBufferDropOldest() throws InterruptedException {, +        int bufferSize = 3;, +        TestSubscriber<Long> ts = createTestSubscriber();, +        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_OLDEST)), +                .subscribe(ts);, +        // we request 10 but only 3 should come from the buffer, +        ts.request(10);, +        ts.awaitTerminalEvent();, +        assertEquals(bufferSize, ts.values().size());, +        ts.assertNoErrors();, +        assertEquals(497, ts.values().get(0).intValue());, +        assertEquals(498, ts.values().get(1).intValue());, +        assertEquals(499, ts.values().get(2).intValue());, +        assertEquals(droppedCount.get(), 500 - bufferSize);, +    }, +, +    private TestSubscriber<Long> createTestSubscriber() {, +        return new TestSubscriber<Long>(new DefaultSubscriber<Long>() {, +    }, +    @Test(timeout = 2000), +    public void backpressureWithBufferDropLatest() throws InterruptedException {, +        int bufferSize = 3;, +        final AtomicInteger droppedCount = new AtomicInteger(0);, +        Action incrementOnDrop = new Action() {, +            @Override, +            public void run() throws Exception {, +                droppedCount.incrementAndGet();, +            }, +        };, +        TestSubscriber<Long> ts = createTestSubscriber();, +        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_LATEST)), +                .subscribe(ts);, +        // we request 10 but only 3 should come from the buffer, +        ts.request(10);, +        assertEquals(bufferSize, ts.values().size());, +        assertEquals(1, ts.values().get(1).intValue());, +        assertEquals(499, ts.values().get(2).intValue());, +        assertEquals(droppedCount.get(), 500 - bufferSize);, +    private static final Flowable<Long> send500ValuesAndComplete = Flowable.unsafeCreate(new Publisher<Long>() {, +            while (!bs.isCancelled() && i < 500) {, +            if(!bs.isCancelled()){, +                s.onComplete();, +        }, +    public void backpressureBufferNegativeCapacity() throws InterruptedException {, +        Flowable.empty().onBackpressureBuffer(-1, EMPTY_ACTION , DROP_OLDEST);, +    public void backpressureBufferZeroCapacity() throws InterruptedException {, +        Flowable.empty().onBackpressureBuffer(0, EMPTY_ACTION , DROP_OLDEST);]