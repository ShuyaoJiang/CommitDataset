[+++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Set;, +     * @param w0 The first source observable., +     * @param w1 The second source observable., +     * @param combineLatestFunction The aggregation function used to combine the source observable values., +    public static <T0, T1, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineLatestFunction) {, +    public static <T0, T1, T2, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineLatestFunction) {, +    public static <T0, T1, T2, T3, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineLatestFunction) {, +        final Observable<T> w;, +        final Aggregator<R> a;, +        public CombineObserver(Aggregator<R> a, Observable<T> w) {, +        public synchronized void startWatching() {, +    private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {, +        private Observer<R> observer;, +        private final FuncN<R> combineLatestFunction;, +        // used as an internal lock for handling the latest values and the completed state of each observer, +        private final Object lockObject = new Object();, +         * Store when an observer completes., +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Set<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();, +, +        /**, +         * The latest value from each observer, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Map<CombineObserver<R, ?>, Object> latestValue = new HashMap<CombineObserver<R, ?>, Object>();, +        , +        /**, +         * Whether each observer has a latest value at all., +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED via 'lockObject' above., +         * */, +        private final Set<CombineObserver<R, ?>> hasLatestValue = new HashSet<CombineObserver<R, ?>>();, +        public Aggregator(FuncN<R> combineLatestFunction) {, +        <T> void complete(CombineObserver<R, T> w) {, +            synchronized(lockObject) {, +                // store that this CombineLatestObserver is completed, +                completed.add(w);, +                if (completed.size() == observers.size()) {, +        }, +        <T> void next(CombineObserver<R, T> w, T arg) {, +            // define here so the variable is out of the synchronized scope, +            Object[] argsToCombineLatest = new Object[observers.size()];, +, +            // we synchronize everything that touches latest values, +            synchronized (lockObject) {, +                // remember that this observer now has a latest value set, +                hasLatestValue.add(w);, +, +                // if all observers in the 'observers' list have a value, invoke the combineLatestFunction, +                for (CombineObserver<R, ?> rw : observers) {, +                    if (!hasLatestValue.contains(rw)) {, +                }, +                // if we get to here this means all the queues have data, +            // if we did not return above from the synchronized block we can now invoke the combineLatestFunction with all of the args, +            // we do this outside the synchronized block as it is now safe to call this concurrently and don't need to block other threads from calling, +            // this 'next' method while another thread finishes calling this combineLatestFunction, +            observer.onNext(combineLatestFunction.call(argsToCombineLatest));, +        public Subscription call(Observer<R> observer) {, +        @SuppressWarnings("unchecked"), +        /* mock calls don't do generics */, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Set;, +     * @param w0 The first source observable., +     * @param w1 The second source observable., +     * @param combineLatestFunction The aggregation function used to combine the source observable values., +    public static <T0, T1, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineLatestFunction) {, +    public static <T0, T1, T2, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineLatestFunction) {, +    public static <T0, T1, T2, T3, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineLatestFunction) {, +        final Observable<T> w;]