[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.subscribers.*;, +    public final <U> Observable<T> skipUntil(Publisher<? extends U> other) {, +    public final Observable<Timed<T>> timestamp() {, +    public final Observable<Timed<T>> timestamp(Scheduler scheduler) {, +    public final Observable<Timed<T>> timestamp(TimeUnit unit) {, +    public final Observable<Timed<T>> timestamp(TimeUnit unit, Scheduler scheduler) {, +        return map(v -> new Timed<>(v, scheduler.now(unit), unit));, +    , +    public final Observable<T> distinct() {, +        return distinct(HashSet::new);, +    }, +    , +    public final Observable<T> distinct(Supplier<? extends Collection<? super T>> collectionSupplier) {, +        return lift(OperatorDistinct.withCollection(collectionSupplier));, +    }, +    , +    public final Observable<T> distinctUntilChanged() {, +        return lift(OperatorDistinct.untilChanged());, +    }, +    , +    @Deprecated, +    public final Observable<Observable<T>> nest() {, +        return just(this);, +    }, +    , +    public final Observable<T> serialize() {, +        return lift(s -> new SerializedSubscriber<>(s));, +    }, +    , +    public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {, +        // TODO consider inlining this behavior, +        return takeUntil(timer(time, unit, scheduler));, +    }, +    , +    public final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {, +        // TODO consider inlining this behavior, +        return skipUntil(timer(time, unit, scheduler));, +    }, +, +    public final Observable<Timed<T>> timeInterval() {, +        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.trampoline());, +    }, +    , +    public final Observable<Timed<T>> timeInterval(Scheduler scheduler) {, +        return timeInterval(TimeUnit.MILLISECONDS, scheduler);, +    }, +    , +    public final Observable<Timed<T>> timeInterval(TimeUnit unit) {, +        return timeInterval(unit, Schedulers.trampoline());, +    }, +    , +    public final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {, +        return lift(new OperatorTimeInterval<>(unit, scheduler));, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.subscribers.*;, +    public final <U> Observable<T> skipUntil(Publisher<? extends U> other) {, +    public final Observable<Timed<T>> timestamp() {, +    public final Observable<Timed<T>> timestamp(Scheduler scheduler) {, +    public final Observable<Timed<T>> timestamp(TimeUnit unit) {, +    public final Observable<Timed<T>> timestamp(TimeUnit unit, Scheduler scheduler) {, +        return map(v -> new Timed<>(v, scheduler.now(unit), unit));, +    , +    public final Observable<T> distinct() {, +        return distinct(HashSet::new);, +    }, +    , +    public final Observable<T> distinct(Supplier<? extends Collection<? super T>> collectionSupplier) {, +        return lift(OperatorDistinct.withCollection(collectionSupplier));, +    }, +    , +    public final Observable<T> distinctUntilChanged() {, +        return lift(OperatorDistinct.untilChanged());, +    }, +    , +    @Deprecated, +    public final Observable<Observable<T>> nest() {, +        return just(this);, +    }, +    , +    public final Observable<T> serialize() {, +        return lift(s -> new SerializedSubscriber<>(s));, +    }, +    , +    public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {, +        // TODO consider inlining this behavior, +        return takeUntil(timer(time, unit, scheduler));, +    }, +    , +    public final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {, +        // TODO consider inlining this behavior, +        return skipUntil(timer(time, unit, scheduler));, +    }, +, +    public final Observable<Timed<T>> timeInterval() {, +        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.trampoline());, +    }, +    , +    public final Observable<Timed<T>> timeInterval(Scheduler scheduler) {]