[+++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        if (sources.size() > 128) {, +            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , +            // the design of how RxRingBuffer is used in the implementation below., +            throw new IllegalArgumentException("More than 128 sources to combineLatest is not supported.");, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        if (sources.size() > 128) {, +            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , +            // the design of how RxRingBuffer is used in the implementation below., +            throw new IllegalArgumentException("More than 128 sources to combineLatest is not supported.");, +++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java, +            boolean localHasValue;, +                localHasValue = hasValue;, +            if  (localHasValue) {, +            }, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        if (sources.size() > 128) {, +            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , +            // the design of how RxRingBuffer is used in the implementation below., +            throw new IllegalArgumentException("More than 128 sources to combineLatest is not supported.");, +++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java, +            boolean localHasValue;, +                localHasValue = hasValue;, +            if  (localHasValue) {, +            }, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // the status of the current stream, +        volatile boolean finished = false;, +, +        @SuppressWarnings("unused"), +        , +        , +            if (isUnsubscribed()) {, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            // polling thread should skip any onNext still in the queue, +                    if (finished) {, +                        // only read volatile error once, +                        Throwable err = error;, +                        if (err != null) {, +                            // clear the queue to enable gc , +                            queue.clear();, +                            // even if there are onNext in the queue we eagerly notify of error, +                            child.onError(err);, +                        } else if (queue.isEmpty()) {, +                    }, +                            // nothing in queue (but be careful, something could be added concurrently right now), +                            if (finished) {, +                                // only read volatile error once, +                                Throwable err = error;, +                                if (err != null) {, +                                    // clear the queue to enable gc , +                                    queue.clear();, +                                    // even if there are onNext in the queue we eagerly notify of error, +                                    child.onError(err);, +                                    return;, +                                } else if (queue.isEmpty()) {, +                            }, +                            BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);, +                        BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        if (sources.size() > 128) {, +            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , +            // the design of how RxRingBuffer is used in the implementation below., +            throw new IllegalArgumentException("More than 128 sources to combineLatest is not supported.");, +++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java, +            boolean localHasValue;, +                localHasValue = hasValue;, +            if  (localHasValue) {, +            }, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // the status of the current stream, +        volatile boolean finished = false;, +, +        @SuppressWarnings("unused"), +        , +        , +            if (isUnsubscribed()) {, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            // polling thread should skip any onNext still in the queue, +                    if (finished) {, +                        // only read volatile error once, +                        Throwable err = error;, +                        if (err != null) {, +                            // clear the queue to enable gc , +                            queue.clear();, +                            // even if there are onNext in the queue we eagerly notify of error, +                            child.onError(err);, +                        } else if (queue.isEmpty()) {, +                    }, +                            // nothing in queue (but be careful, something could be added concurrently right now), +                            if (finished) {, +                                // only read volatile error once, +                                Throwable err = error;, +                                if (err != null) {]