[+++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java, + * ublishSubject<Object> subject = PublishSubject.create();, +        return new PublishSubject<T>(onSubscribe, observers);, +    protected PublishSubject(OnSubscribeFunc<T> onSubscribe, ConcurrentHashMap<Subscription, Observer<? super T>> observers) {, +        /**, +         * Should be able to unsubscribe all Observers, have it stop emitting, then subscribe new ones and it start emitting again., +         */, +        @Test, +        public void testReSubscribe() {, +            final PublishSubject<Integer> ps = PublishSubject.create();, +, +            Observer<Integer> o1 = mock(Observer.class);, +            Subscription s1 = ps.subscribe(o1);, +, +            // emit, +            ps.onNext(1);, +, +            // validate we got it, +            InOrder inOrder1 = inOrder(o1);, +            inOrder1.verify(o1, times(1)).onNext(1);, +            inOrder1.verifyNoMoreInteractions();, +, +            // unsubscribe, +            s1.unsubscribe();, +, +            // emit again but nothing will be there to receive it, +            ps.onNext(2);, +, +            Observer<Integer> o2 = mock(Observer.class);, +            Subscription s2 = ps.subscribe(o2);, +, +            // emit, +            ps.onNext(3);, +, +            // validate we got it, +            InOrder inOrder2 = inOrder(o2);, +            inOrder2.verify(o2, times(1)).onNext(3);, +            inOrder2.verifyNoMoreInteractions();, +, +            s2.unsubscribe();, +        }, +, +        /**, +         * Even if subject received an onError/onCompleted, new subscriptions should be able to restart it., +         */, +        @Test, +        public void testReSubscribeAfterTerminalState() {, +            final PublishSubject<Integer> ps = PublishSubject.create();, +, +            Observer<Integer> o1 = mock(Observer.class);, +            Subscription s1 = ps.subscribe(o1);, +, +            // emit, +            ps.onNext(1);, +, +            // validate we got it, +            InOrder inOrder1 = inOrder(o1);, +            inOrder1.verify(o1, times(1)).onNext(1);, +            inOrder1.verifyNoMoreInteractions();, +, +            // unsubscribe, +            s1.unsubscribe();, +, +            ps.onCompleted();, +, +            // emit again but nothing will be there to receive it, +            ps.onNext(2);, +, +            Observer<Integer> o2 = mock(Observer.class);, +            Subscription s2 = ps.subscribe(o2);, +, +            // emit, +            ps.onNext(3);, +, +            // validate we got it, +            InOrder inOrder2 = inOrder(o2);, +            inOrder2.verify(o2, times(1)).onNext(3);, +            inOrder2.verifyNoMoreInteractions();, +, +            s2.unsubscribe();, +        }, +, +++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java, + * ublishSubject<Object> subject = PublishSubject.create();, +        return new PublishSubject<T>(onSubscribe, observers);, +    protected PublishSubject(OnSubscribeFunc<T> onSubscribe, ConcurrentHashMap<Subscription, Observer<? super T>> observers) {, +        /**, +         * Should be able to unsubscribe all Observers, have it stop emitting, then subscribe new ones and it start emitting again., +         */, +        @Test, +        public void testReSubscribe() {, +            final PublishSubject<Integer> ps = PublishSubject.create();, +, +            Observer<Integer> o1 = mock(Observer.class);, +            Subscription s1 = ps.subscribe(o1);, +, +            // emit, +            ps.onNext(1);, +, +            // validate we got it]