[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.operators.OperationBuffer.BufferClosing;, +import rx.operators.OperationBuffer.BufferOpening;, + * It provides overloaded methods for subscribing as well as delegate methods to the various operators., + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +    protected Observable() {, +        this(null);, +    }, +, +     * Construct an Observable with Function to execute when subscribed to., +     * NOTE: Generally you're better off using {@link #create(Func1)} to create an Observable instead of using inheritance., +     * an {@link Observer} must call an Observable's <code>subscribe</code> method in order to register itself, +     * to receive push-based notifications from the Observable. A typical implementation of the, +     * <code>subscribe</code> method does the following:, +     * It stores a reference to the Observer in a collection object, such as a <code>List<T></code>, +     * object., +     * It returns a reference to the {@link Subscription} interface. This enables, +     * Observers to unsubscribe (that is, to stop receiving notifications) before the Observable has, +     * finished sending them and has called the Observer's {@link Observer#onCompleted()} method., +     * At any given time, a particular instance of an <code>Observable<T></code> implementation is, +     * responsible for accepting all subscriptions and notifying all subscribers. Unless the, +     * documentation for a particular <code>Observable<T></code> implementation indicates otherwise,, +     * Observers should make no assumptions about the <code>Observable<T></code> implementation, such, +     * as the order of notifications that multiple Observers will receive., +     * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * , +     * @return a {@link Subscription} reference that allows observers, +     *         to stop receiving notifications before the provider has finished sending them, +     * an {@link Observer} must call an Observable's <code>subscribe</code> method in order to register itself, +     * to receive push-based notifications from the Observable. A typical implementation of the, +     * It stores a reference to the Observer in a collection object, such as a <code>List<T></code>, +     * object., +     * It returns a reference to the {@link Subscription} interface. This enables, +     * Observers to unsubscribe (that is, to stop receiving notifications) before the Observable has, +     * finished sending them and has called the Observer's {@link Observer#onCompleted()} method., +     * At any given time, a particular instance of an <code>Observable<T></code> implementation is, +     * responsible for accepting all subscriptions and notifying all subscribers. Unless the, +     * documentation for a particular <code>Observable<T></code> implementation indicates otherwise,, +     * Observers should make no assumptions about the <code>Observable<T></code> implementation, such, +     * as the order of notifications that multiple Observers will receive., +     * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * , +     *            The {@link Scheduler} that the sequence is subscribed to on., +     * @return a {@link Subscription} reference that allows observers, +     *         to stop receiving notifications before the provider has finished sending them, +        // lookup and memoize onNext, +            throw new RuntimeException("onNext must be implemented");, +        if (o == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                // no callback defined, +                // no callback defined, +                if (onNext == null) {, +                    throw new RuntimeException("onNext must be implemented");, +                }, +        if (onNext == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                if (onError != null) {, +            }, +                if (onError != null) {, +            }, +                if (onNext == null) {, +                    throw new RuntimeException("onNext must be implemented");, +                }, +        if (onNext == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                if (onComplete != null) {, +            }, +                if (onError != null) {, +            }, +                if (onError != null) {, +            }, +                if (onNext == null) {, +                    throw new RuntimeException("onNext must be implemented");, +                }, +     * Returns a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     *            the subject to push source elements into., +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     * an Observable that calls {@link Observer#onError(Exception)} when the Observer subscribes., +     *            the type of object returned by the Observable, +                 * Accepts an {@link Observer} and calls its <code>onError</code> method., +     * Creates an Observable which produces buffers of collected values. This Observable produces connected, +     * non-overlapping buffers. The current buffer is emitted and replaced with a new buffer when the, +     * Observable produced by the specified {@link Func0} produces a {@link BufferClosing} object. The, +     * {@link Func0} will then be used to create a new Observable to listen for the end of the next buffer., +     *, +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param bufferClosingSelector, +     *            The {@link Func0} which is used to produce an {@link Observable} for every buffer created., +     *            When this {@link Observable} produces a {@link BufferClosing} object, the associated buffer, +     *            is emitted and replaced with a new one., +     * @return, +     *            An {@link Observable} which produces connected non-overlapping buffers, which are emitted, +     *            when the current {@link Observable} created with the {@link Func0} argument produces a]