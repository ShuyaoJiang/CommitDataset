[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationInterval;, +import rx.operators.OperationSample;, +import rx.operators.OperationTimer;, +import rx.operators.OperatorToMultimap;, +        return create(OperationInterval.interval(interval, unit));, +        return create(OperationInterval.interval(interval, unit, scheduler));, +        return create(new OperationTimer.TimerPeriodically(initialDelay, period, unit, scheduler));, +        return create(new OperationTimer.TimerOnce(delay, unit, scheduler));, +        return create(OperationSample.sample(this, period, unit));, +        return create(OperationSample.sample(this, period, unit, scheduler));, +        return create(new OperationSample.SampleWithObservable<T, U>(this, sampler));, +        return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory, collectionFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationInterval;, +import rx.operators.OperationSample;, +import rx.operators.OperationTimer;, +import rx.operators.OperatorToMultimap;, +        return create(OperationInterval.interval(interval, unit));, +        return create(OperationInterval.interval(interval, unit, scheduler));, +        return create(new OperationTimer.TimerPeriodically(initialDelay, period, unit, scheduler));, +        return create(new OperationTimer.TimerOnce(delay, unit, scheduler));, +        return create(OperationSample.sample(this, period, unit));, +        return create(OperationSample.sample(this, period, unit, scheduler));, +        return create(new OperationSample.SampleWithObservable<T, U>(this, sampler));, +        return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, +        return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory, collectionFactory));, +++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.concurrent.TimeUnit;, +, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Scheduler.Worker;, +import rx.Subscription;, +import rx.functions.Action0;, +import rx.schedulers.Schedulers;, +, +/**, + * Returns an observable sequence that produces a value after each period., + * The value starts at 0 and counts up each period., + */, +public final class OperationInterval {, +, +    /**, +     * Creates an event each time interval., +     */, +    public static OnSubscribeFunc<Long> interval(long interval, TimeUnit unit) {, +        return interval(interval, unit, Schedulers.computation());, +    }, +, +    /**, +     * Creates an event each time interval., +     */, +    public static OnSubscribeFunc<Long> interval(final long interval, final TimeUnit unit, final Scheduler scheduler) {, +        // wrapped in order to work with multiple subscribers, +        return new OnSubscribeFunc<Long>() {, +            @Override, +            public Subscription onSubscribe(Observer<? super Long> observer) {, +                return new Interval(interval, unit, scheduler).onSubscribe(observer);, +            }, +        };, +    }, +, +    private static class Interval implements OnSubscribeFunc<Long> {, +        private final long period;, +        private final TimeUnit unit;, +        private final Scheduler scheduler;, +, +        private long currentValue;, +, +        private Interval(long period, TimeUnit unit, Scheduler scheduler) {, +            this.period = period;, +            this.unit = unit;, +            this.scheduler = scheduler;, +        }, +, +        @Override]