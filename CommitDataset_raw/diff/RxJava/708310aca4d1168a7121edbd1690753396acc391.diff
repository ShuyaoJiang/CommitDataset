[+++ b/src/main/java/io/reactivex/Flowable.java, +        return new FlowableSubscribeOn<T>(this, scheduler);, +++ b/src/main/java/io/reactivex/Flowable.java, +        return new FlowableSubscribeOn<T>(this, scheduler);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.util.BackpressureHelper;, +    public FlowableSubscribeOn(Publisher<? extends T> source, Scheduler scheduler) {, +        s.onSubscribe(sos);, +        , +                sos.lazySet(Thread.currentThread());, +    static final class SubscribeOnSubscriber<T> extends AtomicReference<Thread>, +    implements Subscriber<T>, Subscription {, +        final AtomicReference<Subscription> s;, +        , +        final AtomicLong requested;, +            this.s = new AtomicReference<Subscription>();, +            this.requested = new AtomicLong();, +            if (SubscriptionHelper.setOnce(this.s, s)) {, +                long r = requested.getAndSet(0L);, +                if (r != 0L) {, +                    requestUpstream(r, s);, +                }, +            Subscription s = this.s.get();, +            if (s != null) {, +                requestUpstream(n, s);, +            } else {, +                BackpressureHelper.add(requested, n);, +                s = this.s.get();, +                if (s != null) {, +                    long r = requested.getAndSet(0L);, +                    if (r != 0L) {, +                        requestUpstream(r, s);, +                    }, +                }, +                , +            }, +        }, +        , +        void requestUpstream(final long n, final Subscription s) {, +            SubscriptionHelper.dispose(s);, +++ b/src/main/java/io/reactivex/Flowable.java, +        return new FlowableSubscribeOn<T>(this, scheduler);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.util.BackpressureHelper;, +    public FlowableSubscribeOn(Publisher<? extends T> source, Scheduler scheduler) {, +        s.onSubscribe(sos);, +        , +                sos.lazySet(Thread.currentThread());, +    static final class SubscribeOnSubscriber<T> extends AtomicReference<Thread>, +    implements Subscriber<T>, Subscription {, +        final AtomicReference<Subscription> s;, +        , +        final AtomicLong requested;, +            this.s = new AtomicReference<Subscription>();, +            this.requested = new AtomicLong();, +            if (SubscriptionHelper.setOnce(this.s, s)) {, +                long r = requested.getAndSet(0L);, +                if (r != 0L) {, +                    requestUpstream(r, s);, +                }, +            Subscription s = this.s.get();, +            if (s != null) {, +                requestUpstream(n, s);, +            } else {, +                BackpressureHelper.add(requested, n);, +                s = this.s.get();, +                if (s != null) {, +                    long r = requested.getAndSet(0L);, +                    if (r != 0L) {, +                        requestUpstream(r, s);, +                    }, +                }, +                , +            }, +        }, +        , +        void requestUpstream(final long n, final Subscription s) {, +            SubscriptionHelper.dispose(s);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java, +        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);, +        , +        s.onSubscribe(parent);, +        , +        parent.setDisposable(scheduler.scheduleDirect(new Runnable() {, +                source.subscribe(parent);, +        }));, +    static final class SubscribeOnObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {, +        final AtomicReference<Disposable> s;, +        public SubscribeOnObserver(Observer<? super T> actual) {, +            this.s = new AtomicReference<Disposable>();, +            DisposableHelper.setOnce(this.s, s);, +            DisposableHelper.dispose(s);, +            DisposableHelper.dispose(this);, +            return DisposableHelper.isDisposed(get());, +        }, +        , +        void setDisposable(Disposable d) {, +            DisposableHelper.setOnce(this, d);]