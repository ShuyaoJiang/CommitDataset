[+++ b/rxjava-core/src/main/java/rx/Scheduler.java, +        final Action1<Recurse> action;, +        final Inner inner;, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +        final Action1<Recurse> action;, +        final Inner inner;, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +    public void assertUnsubscribed() {, +        if (!isUnsubscribed()) {, +            throw new AssertionError("Not unsubscribed.");, +        }, +    }, +, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +        final Action1<Recurse> action;, +        final Inner inner;, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +    public void assertUnsubscribed() {, +        if (!isUnsubscribed()) {, +            throw new AssertionError("Not unsubscribed.");, +        }, +    }, +, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java, +import rx.subscriptions.CompositeSubscription;, +        final CompositeSubscription childrenSubscriptions = new CompositeSubscription();, +        outerOperation.add(childrenSubscriptions);, +, +                Subscriber<T> i = new InnerObserver();, +                childrenSubscriptions.add(i);, +                innerObservable.subscribe(i);, +                    cleanup();, +                    cleanup();, +                private void cleanup() {, +                    // remove subscription onCompletion so it cleans up immediately and doesn't memory leak, +                    // see https://github.com/Netflix/RxJava/issues/897, +                    childrenSubscriptions.remove(this);, +                }, +, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +        final Action1<Recurse> action;, +        final Inner inner;, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +    public void assertUnsubscribed() {, +        if (!isUnsubscribed()) {, +            throw new AssertionError("Not unsubscribed.");, +        }, +    }, +, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java, +import rx.subscriptions.CompositeSubscription;, +        final CompositeSubscription childrenSubscriptions = new CompositeSubscription();, +        outerOperation.add(childrenSubscriptions);, +, +                Subscriber<T> i = new InnerObserver();, +                childrenSubscriptions.add(i);, +                innerObservable.subscribe(i);, +                    cleanup();, +                    cleanup();, +                private void cleanup() {, +                    // remove subscription onCompletion so it cleans up immediately and doesn't memory leak, +                    // see https://github.com/Netflix/RxJava/issues/897, +                    childrenSubscriptions.remove(this);, +                }, +, +++ b/rxjava-core/src/test/java/rx/operators/OperatorMergeTest.java, +import java.util.Arrays;, +import java.util.Collections;, +import rx.Observable.OnSubscribe;, +import rx.Scheduler;, +import rx.observers.TestSubscriber;, +import rx.schedulers.Schedulers;, +import rx.schedulers.TestScheduler;, +    @Test, +    public void testUnsubscribeAsObservablesComplete() {, +        TestScheduler scheduler1 = Schedulers.test();, +        AtomicBoolean os1 = new AtomicBoolean(false);, +        Observable<Long> o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);, +, +        TestScheduler scheduler2 = Schedulers.test();, +        AtomicBoolean os2 = new AtomicBoolean(false);, +        Observable<Long> o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);, +, +        TestSubscriber<Long> ts = new TestSubscriber<Long>();, +        Observable.merge(o1, o2).subscribe(ts);, +, +        // we haven't incremented time so nothing should be received yet, +        ts.assertReceivedOnNext(Collections.<Long> emptyList());, +, +        scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);, +        scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);, +, +        ts.assertReceivedOnNext(Arrays.asList(0L, 1L, 2L, 0L, 1L));, +        // not unsubscribed yet, +        assertFalse(os1.get());, +        assertFalse(os2.get());, +, +        // advance to the end at which point it should complete, +        scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);, +]