[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test, +    public void testAll() {, +        Observable.toObservable(1, 2, 3).all({ x -> x > 0 }).subscribe({ result -> a.received(result) });, +        verify(a, times(1)).received(true);, +    }, +, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test, +    public void testAll() {, +        Observable.toObservable(1, 2, 3).all({ x -> x > 0 }).subscribe({ result -> a.received(result) });, +        verify(a, times(1)).received(true);, +    }, +, +++ b/rxjava-core/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test, +    public void testAll() {, +        Observable.toObservable(1, 2, 3).all({ x -> x > 0 }).subscribe({ result -> a.received(result) });, +        verify(a, times(1)).received(true);, +    }, +, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.operators.OperationAll;, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperationWhere;, +import rx.subscriptions.BooleanSubscription;, +import rx.util.functions.Function;, +        this(null);, +            /**, +             * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +             */, +            if (isInternalImplementation(observer)) {, +    /**, +     * Used for protecting against errors being thrown from Observer implementations and ensuring onNext/onError/onCompleted contract compliance., +     * <p>, +     * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +     */, +    private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {, +        AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +        return subscription.wrap(subscribe(new AtomicObserver<T>(subscription, o)));, +    }, +, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        return protectivelyWrapAndSubscribe(new Observer<T>() {, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        protectivelyWrapAndSubscribe(new Observer<T>() {, +            });, +            });, +        return create(OperationFilter.filter(that, predicate));, +        return create(OperationWhere.where(that, predicate));, +        return create(OperationDefer.defer(observableFactory));, +        return create(OperationDefer.defer(new Func0<Observable<T>>() {, +        return create(OperationMap.map(sequence, func));]