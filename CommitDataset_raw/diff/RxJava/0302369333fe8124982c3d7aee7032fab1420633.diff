[+++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.ScheduledAction;, +    /** Manages a fixed number of workers. */, +    static final class FixedSchedulerPool {, +        final int cores;, +        final PoolWorker[] eventLoops;, +        long n;, +        FixedSchedulerPool() {, +            this.cores = Runtime.getRuntime().availableProcessors();, +            this.eventLoops = new PoolWorker[cores];, +                this.eventLoops[i] = new PoolWorker(factory);, +        public PoolWorker getEventLoop() {, +            // simple round robin, improvements to come, +    }, +    final FixedSchedulerPool pool;, +    , +    /**, +     * Create a scheduler with pool size equal to the available processor, +     * count and using least-recent worker selection policy., +     */, +    EventLoopsScheduler() {, +        pool = new FixedSchedulerPool();, +        return new EventLoopWorker(pool.getEventLoop());, +    private static class EventLoopWorker extends Scheduler.Worker {, +        private final PoolWorker poolWorker;, +        EventLoopWorker(PoolWorker poolWorker) {, +            this.poolWorker = poolWorker;, +            return schedule(action, 0, null);, +            ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);, +            innerSubscription.add(s);, +            s.addParent(innerSubscription);, +            return s;, +        }, +    private static final class PoolWorker extends NewThreadScheduler.NewThreadWorker {, +        PoolWorker(ThreadFactory threadFactory) {, +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.ScheduledAction;, +    /** Manages a fixed number of workers. */, +    static final class FixedSchedulerPool {, +        final int cores;, +        final PoolWorker[] eventLoops;, +        long n;, +        FixedSchedulerPool() {, +            this.cores = Runtime.getRuntime().availableProcessors();, +            this.eventLoops = new PoolWorker[cores];, +                this.eventLoops[i] = new PoolWorker(factory);, +        public PoolWorker getEventLoop() {, +            // simple round robin, improvements to come, +    }, +    final FixedSchedulerPool pool;, +    , +    /**, +     * Create a scheduler with pool size equal to the available processor, +     * count and using least-recent worker selection policy., +     */, +    EventLoopsScheduler() {, +        pool = new FixedSchedulerPool();, +        return new EventLoopWorker(pool.getEventLoop());, +    private static class EventLoopWorker extends Scheduler.Worker {, +        private final PoolWorker poolWorker;, +        EventLoopWorker(PoolWorker poolWorker) {, +            this.poolWorker = poolWorker;, +            return schedule(action, 0, null);, +            ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);, +            innerSubscription.add(s);, +            s.addParent(innerSubscription);, +            return s;, +        }, +    private static final class PoolWorker extends NewThreadScheduler.NewThreadWorker {, +        PoolWorker(ThreadFactory threadFactory) {, +++ b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java, +import java.util.concurrent.Future;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.atomic.AtomicBoolean;, +        return new NewThreadWorker(THREAD_FACTORY);, +    /* package */static class NewThreadWorker extends Scheduler.Worker implements Subscription {, +        private final ScheduledExecutorService executor;, +        /* package */NewThreadWorker(ThreadFactory threadFactory) {, +            executor = Executors.newScheduledThreadPool(1, threadFactory);, +            return schedule(action, 0, null);, +            if (innerSubscription.isUnsubscribed()) {, +                return Subscriptions.empty();, +            }, +            return scheduleActual(action, delayTime, unit);, +        /* package */ScheduledAction scheduleActual(final Action0 action, long delayTime, TimeUnit unit) {, +            ScheduledAction run = new ScheduledAction(action, innerSubscription);, +            Future<?> f;, +            if (delayTime <= 0) {, +                f = executor.submit(run);, +            } else {, +                f = executor.schedule(run, delayTime, unit);, +            }, +            run.add(Subscriptions.from(f));, +            , +            return run;, +        }, +        , +        /** Remove a child subscription from a composite when unsubscribing. */, +        private static final class Remover implements Subscription {, +            final Subscription s;]