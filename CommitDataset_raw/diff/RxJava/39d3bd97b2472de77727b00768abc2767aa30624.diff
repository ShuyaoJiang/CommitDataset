[+++ b/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservableFactory<T, TClosing>(closingSelector));, +++ b/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservableFactory<T, TClosing>(closingSelector));, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +import java.util.*;, +, +import rx.*;, +import rx.Observable;, +    final Observable<U> other;, +        this.other = other;, +        child.add(sub);, +        child.add(bs);, +        , +++ b/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservableFactory<T, TClosing>(closingSelector));, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +import java.util.*;, +, +import rx.*;, +import rx.Observable;, +    final Observable<U> other;, +        this.other = other;, +        child.add(sub);, +        child.add(bs);, +        , +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservableFactory.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +package rx.internal.operators;, +, +import java.util.*;, +, +import rx.*;, +import rx.Observable.Operator;, +import rx.Observable;, +import rx.Observer;, +import rx.functions.Func0;, +import rx.observers.SerializedSubscriber;, +import rx.subscriptions.SerialSubscription;, +, +/**, + * Creates non-overlapping windows of items where each window is terminated by, + * an event from a secondary observable and a new window is started immediately., + * , + * @param <T> the value type, + * @param <U> the boundary value type, + */, +public final class OperatorWindowWithObservableFactory<T, U> implements Operator<Observable<T>, T> {, +    final Func0<? extends Observable<? extends U>> otherFactory;, +, +    public OperatorWindowWithObservableFactory(Func0<? extends Observable<? extends U>> otherFactory) {, +        this.otherFactory = otherFactory;, +    }, +    , +    @Override, +    public Subscriber<? super T> call(Subscriber<? super Observable<T>> child) {, +        , +        SourceSubscriber<T, U> sub = new SourceSubscriber<T, U>(child, otherFactory);, +        , +        child.add(sub);, +        , +        sub.replaceWindow();, +        , +        return sub;, +    }, +    /** Indicate the current subject should complete and a new subject be emitted. */, +    static final Object NEXT_SUBJECT = new Object();, +    /** For error and completion indication. */, +    static final NotificationLite<Object> nl = NotificationLite.instance();, +    /** Observes the source. */, +    static final class SourceSubscriber<T, U> extends Subscriber<T> {, +        final Subscriber<? super Observable<T>> child;, +        final Object guard;, +        /** Accessed from the serialized part. */, +        Observer<T> consumer;, +        /** Accessed from the serialized part. */, +        Observable<T> producer;, +        /** Guarded by guard. */, +        boolean emitting;, +        /** Guarded by guard. */, +        List<Object> queue;, +        , +        final SerialSubscription ssub;, +        , +        final Func0<? extends Observable<? extends U>> otherFactory;, +        ]