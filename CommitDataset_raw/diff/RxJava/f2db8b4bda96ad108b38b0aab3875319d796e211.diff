[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.ConcurrentHashMap;, +    private final static ConcurrentHashMap<Class, Boolean> internalClassMap = new ConcurrentHashMap<Class, Boolean>();, +, +        if (o instanceof SafeObserver) {, +        }, +, +        Class<?> clazz = o.getClass();, +        if (internalClassMap.containsKey(clazz)) {, +            //don't need to do reflection, +            return internalClassMap.get(clazz);, +        } else {, +            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));, +            internalClassMap.put(clazz, isInternal);, +            return isInternal;, +        }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.ConcurrentHashMap;, +    private final static ConcurrentHashMap<Class, Boolean> internalClassMap = new ConcurrentHashMap<Class, Boolean>();, +, +        if (o instanceof SafeObserver) {, +        }, +, +        Class<?> clazz = o.getClass();, +        if (internalClassMap.containsKey(clazz)) {, +            //don't need to do reflection, +            return internalClassMap.get(clazz);, +        } else {, +            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));, +            internalClassMap.put(clazz, isInternal);, +            return isInternal;, +        }, +++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +import java.util.concurrent.atomic.AtomicReference;, + * Transforms an Observable that emits Observables into a single Observable that emits the items, + * emitted by the most recently published of those Observables., + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">, +     * This function transforms an {@link Observable} sequence of {@link Observable} sequences into a single {@link Observable} sequence which produces values from the most recently published, +     * {@link Observable}., +     *            The {@link Observable} sequence consisting of {@link Observable} sequences., +            SafeObservableSubscription subscription = new SafeObservableSubscription();, +            subscription.wrap(sequences.subscribe(new SwitchObserver<T>(observer, subscription)));, +            return subscription;, +        private final AtomicReference<Subscription> subsequence = new AtomicReference<Subscription>();, +        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent) {, +        }, +, +        @Override, +        public void onCompleted() {, +            unsubscribeFromSubSequence();, +            observer.onCompleted();, +        }, +, +        @Override, +        public void onError(Throwable e) {, +            unsubscribeFromSubSequence();, +            observer.onError(e);, +            unsubscribeFromSubSequence();, +, +            subsequence.set(args.subscribe(new Observer<T>() {, +                @Override, +                public void onCompleted() {, +                    // Do nothing., +                @Override, +                public void onError(Throwable e) {, +                    parent.unsubscribe();, +                    observer.onError(e);, +                }, +, +                    observer.onNext(args);, +        private void unsubscribeFromSubSequence() {, +            Subscription previousSubscription = subsequence.get();, +            if (previousSubscription != null) {, +                previousSubscription.unsubscribe();, +                            publishNext(observer, 50, "one");, +            inOrder.verify(observer, never()).onNext(anyString());, +            verify(observer, times(1)).onCompleted();]