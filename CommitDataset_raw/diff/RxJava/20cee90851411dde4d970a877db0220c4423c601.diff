[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * {@code cache} with initial capacity., +     *, +     * @param capacity, +     *            initial cache size, +     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the, +     *         benefit of subsequent subscribers, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache">RxJava Wiki: cache()</a>, +     */, +    public final Observable<T> cache(int capacity) {, +        return create(new OnSubscribeCache<T>(this, capacity));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * {@code cache} with initial capacity., +     *, +     * @param capacity, +     *            initial cache size, +     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the, +     *         benefit of subsequent subscribers, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache">RxJava Wiki: cache()</a>, +     */, +    public final Observable<T> cache(int capacity) {, +        return create(new OnSubscribeCache<T>(this, capacity));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java, +    public OnSubscribeCache(Observable<? extends T> source, int capacity) {, +        this(source, ReplaySubject.<T> create(capacity));, +    }, +, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * {@code cache} with initial capacity., +     *, +     * @param capacity, +     *            initial cache size, +     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the, +     *         benefit of subsequent subscribers, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache">RxJava Wiki: cache()</a>, +     */, +    public final Observable<T> cache(int capacity) {, +        return create(new OnSubscribeCache<T>(this, capacity));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java, +    public OnSubscribeCache(Observable<? extends T> source, int capacity) {, +        this(source, ReplaySubject.<T> create(capacity));, +    }, +, +++ b/rxjava-core/src/test/java/rx/ObservableTests.java, +    @Test, +    public void testCacheWithCapacity() throws InterruptedException {, +        final AtomicInteger counter = new AtomicInteger();, +        Observable<String> o = Observable.create(new OnSubscribe<String>() {, +, +            @Override, +            public void call(final Subscriber<? super String> observer) {, +                new Thread(new Runnable() {, +, +                    @Override, +                    public void run() {, +                        counter.incrementAndGet();, +                        observer.onNext("one");, +                        observer.onCompleted();, +                    }, +                }).start();, +            }, +        }).cache(1);, +, +        // we then expect the following 2 subscriptions to get that same value, +        final CountDownLatch latch = new CountDownLatch(2);, +, +        // subscribe once, +        o.subscribe(new Action1<String>() {, +, +            @Override, +            public void call(String v) {, +                assertEquals("one", v);, +                latch.countDown();, +            }, +        });, +, +        // subscribe again, +        o.subscribe(new Action1<String>() {, +, +            @Override, +            public void call(String v) {, +                assertEquals("one", v);, +                latch.countDown();, +            }, +        });, +, +        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {, +            fail("subscriptions did not receive values");, +        }, +        assertEquals(1, counter.get());, +    }]