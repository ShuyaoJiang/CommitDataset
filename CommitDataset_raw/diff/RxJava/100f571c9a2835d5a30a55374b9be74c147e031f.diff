[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +import static org.junit.Assert.*;, +        try {, +            Observable.create(new AsyncObservable()).forEach({ result -> throw new RuntimeException('err')});, +            fail("we expect an exception to be thrown");, +        }catch(Exception e) {, +        }, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +import static org.junit.Assert.*;, +        try {, +            Observable.create(new AsyncObservable()).forEach({ result -> throw new RuntimeException('err')});, +            fail("we expect an exception to be thrown");, +        }catch(Exception e) {, +        }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.atomic.AtomicReference;, +     * Invokes an action for each element in the observable sequence, and blocks until the sequence is terminated., +     * <p>, +     * This is similar to {@link #subscribe(Observer)} but blocks. Because it blocks it does not need the {@link Observer#onCompleted()} or {@link Observer#onError(Exception)} methods., +     * @param onNext, +     *            {@link Action1}, +     * @throws RuntimeException, +     *             if error occurs, +    public void forEach(final Action1<T> onNext) {, +        final AtomicReference<Exception> exceptionFromOnError = new AtomicReference<Exception>();, +, +                /*, +                 * If we receive an onError event we set the reference on the outer thread, +                 * so we can git it and throw after the latch.await()., +                 * , +                 * We do this instead of throwing directly since this may be on a different thread and the latch is still waiting., +                 */, +                exceptionFromOnError.set(e);, +                onNext.call(args);, +        if (exceptionFromOnError.get() != null) {, +            if (exceptionFromOnError.get() instanceof RuntimeException) {, +                throw (RuntimeException) exceptionFromOnError.get();, +            } else {, +                throw new RuntimeException(exceptionFromOnError.get());, +        if (o instanceof Action1) {, +            // in case a dynamic language is not correctly handling the overloaded methods and we receive an Action1 just forward to the correct method., +            forEach((Action1) o);, +        forEach(new Action1() {, +            public void call(Object args) {]