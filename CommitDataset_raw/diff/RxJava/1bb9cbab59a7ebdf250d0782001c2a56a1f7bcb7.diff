[+++ b/src/main/java/rx/internal/operators/OperatorMaterialize.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +import rx.Producer;, +, +, +, +    private OperatorMaterialize() {, +    }, +, +        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child);, +        child.add(parent);, +        child.setProducer(new Producer() {, +            @Override, +            public void request(long n) {, +                if (n > 0) {, +                    parent.requestMore(n);, +                }, +            }, +        });, +        return parent;, +    }, +, +    private static class ParentSubscriber<T> extends Subscriber<T> {, +, +        private final Subscriber<? super Notification<T>> child;, +, +        private volatile Notification<T> terminalNotification;, +        , +        // guarded by this, +        private boolean busy = false;, +        // guarded by this, +        private boolean missed = false;, +, +        private volatile long requested;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<ParentSubscriber> REQUESTED = AtomicLongFieldUpdater, +                .newUpdater(ParentSubscriber.class, "requested");, +, +        ParentSubscriber(Subscriber<? super Notification<T>> child) {, +            this.child = child;, +        }, +, +        @Override, +        public void onStart() {, +            request(0);, +        }, +, +        void requestMore(long n) {, +            BackpressureUtils.getAndAddRequest(REQUESTED, this, n);, +            request(n);, +            drain();, +        }, +            terminalNotification = Notification.createOnCompleted();, +            drain();, +            terminalNotification = Notification.createOnError(e);, +            drain();, +            child.onNext(Notification.createOnNext(t));, +            decrementRequested();, +        private void decrementRequested() {, +            // atomically decrement requested, +            while (true) {, +                long r = requested;, +                if (r == Long.MAX_VALUE) {, +                    // don't decrement if unlimited requested, +                    return;, +                } else if (REQUESTED.compareAndSet(this, r, r - 1)) {, +                    return;, +                }, +            }, +        }, +, +        private void drain() {, +            synchronized (this) {, +                if (busy) {, +                    // set flag to force extra loop if drain loop running, +                    missed = true;, +                    return;, +                } , +            }, +            // drain loop, +            while (!child.isUnsubscribed()) {, +                Notification<T> tn;, +                tn = terminalNotification;, +                if (tn != null) {, +                    if (requested > 0) {, +                        // allow tn to be GC'd after the onNext call, +                        terminalNotification = null;, +                        // emit the terminal notification, +                        child.onNext(tn);, +                        if (!child.isUnsubscribed()) {, +                            child.onCompleted();, +                        }, +                        // note that we leave busy=true here, +                        // which will prevent further drains, +                        return;, +                    }, +                }, +                // continue looping if drain() was called while in, +                // this loop]