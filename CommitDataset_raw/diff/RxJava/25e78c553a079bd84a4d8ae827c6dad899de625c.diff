[+++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, +        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, +        return RxJavaPlugins.onAssembly(new ObservableTimer(Math.max(delay, 0L), unit, scheduler));, +        verifyPositive(count, "count");, +        verifyPositive(skip, "skip");, +        verifyPositive(count, "count");, +        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");, +        return doOnEach(Functions.emptyConsumer(), , +                Functions.actionConsumer(onTerminate), onTerminate, , +                Functions.EMPTY_ACTION);, +        verifyPositive(maxConcurrency, "maxConcurrency");, +     * @param times, +    public final Observable<T> repeat(long times) {, +        if (times < 0) {, +            throw new IllegalArgumentException("times >= 0 required but it was " + times);, +        if (times == 0) {, +        return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, times));, +        verifyPositive(bufferSize, "bufferSize");, +        verifyPositive(bufferSize, "bufferSize");, +     * @param times, +    public final Observable<T> retry(long times) {, +        return retry(times, Functions.alwaysTrue());, +            throw new IllegalArgumentException("count >= 0 required but it was " + count);, +        verifyPositive(capacityHint, "capacityHint");, +            return o.onBackpressureBuffer();, +        verifyPositive(timespan, "timespan");, +        verifyPositive(timeskip, "timeskip");, +        verifyPositive(count, "count");, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, +        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, +        return RxJavaPlugins.onAssembly(new ObservableTimer(Math.max(delay, 0L), unit, scheduler));, +        verifyPositive(count, "count");, +        verifyPositive(skip, "skip");, +        verifyPositive(count, "count");, +        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");, +        return doOnEach(Functions.emptyConsumer(), , +                Functions.actionConsumer(onTerminate), onTerminate, , +                Functions.EMPTY_ACTION);, +        verifyPositive(maxConcurrency, "maxConcurrency");, +     * @param times, +    public final Observable<T> repeat(long times) {, +        if (times < 0) {, +            throw new IllegalArgumentException("times >= 0 required but it was " + times);, +        if (times == 0) {, +        return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, times));, +        verifyPositive(bufferSize, "bufferSize");, +        verifyPositive(bufferSize, "bufferSize");, +     * @param times, +    public final Observable<T> retry(long times) {, +        return retry(times, Functions.alwaysTrue());, +            throw new IllegalArgumentException("count >= 0 required but it was " + count);, +        verifyPositive(capacityHint, "capacityHint");, +            return o.onBackpressureBuffer();, +        verifyPositive(timespan, "timespan");, +        verifyPositive(timeskip, "timeskip");, +        verifyPositive(count, "count");, +++ b/src/main/java/io/reactivex/Scheduler.java, +            first.replace(schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, +                    periodInNanoseconds), initialDelay, unit));, +            , +            return sd;, +        }, +        , +        /**, +         * Returns the 'current time' of the Worker in the specified time unit., +         * @param unit the time unit, +         * @return the 'current time', +         * @since 2.0, +         */, +        public long now(TimeUnit unit) {, +            return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);, +        }, +, +        /**, +         * Holds state and logic to calculate when the next delayed invocation, +         * of this task has to happen (accounting for clock drifts)., +         */, +        final class PeriodicTask implements Runnable {, +            final long firstStartInNanoseconds;, +            final Runnable decoratedRun;, +            final long firstNowNanoseconds;, +            final SequentialDisposable sd;, +            final long periodInNanoseconds;, +            long lastNowNanoseconds;, +            long startInNanoseconds;, +, +            PeriodicTask(long firstStartInNanoseconds, Runnable decoratedRun,, +                    long firstNowNanoseconds, SequentialDisposable sd, long periodInNanoseconds) {, +                this.firstStartInNanoseconds = firstStartInNanoseconds;, +                this.decoratedRun = decoratedRun;, +                this.firstNowNanoseconds = firstNowNanoseconds;, +                this.sd = sd;, +                this.periodInNanoseconds = periodInNanoseconds;, +                lastNowNanoseconds = firstNowNanoseconds;, +                startInNanoseconds = firstStartInNanoseconds;]