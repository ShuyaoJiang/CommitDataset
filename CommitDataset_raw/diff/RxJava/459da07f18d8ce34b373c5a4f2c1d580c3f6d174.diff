[+++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, +    private final SubscriptionList cs;, +        this.cs = new SubscriptionList();, +        this.cs = new SubscriptionList();, +        this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, +    private final SubscriptionList cs;, +        this.cs = new SubscriptionList();, +        this.cs = new SubscriptionList();, +        this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            super();, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, +    private final SubscriptionList cs;, +        this.cs = new SubscriptionList();, +        this.cs = new SubscriptionList();, +        this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            super();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Subscription;, +        final PivotSubscriber<K1, K2, T> pivotSubscriber = new PivotSubscriber<K1, K2, T>(child, state);, +        private PivotSubscriber(Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child, AtomicReference<State> state) {, +            this.groups = new GroupState<K1, K2, T>(this, child);, +            k1Group.unsafeSubscribe(new Subscriber<GroupedObservable<K2, T>>(this) {, +                    k2Group.unsafeSubscribe(new Subscriber<T>(this) {, +        private final Subscription parentSubscription;, +        static final AtomicIntegerFieldUpdater<GroupState> COMPLETED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupState.class, "completed");, +        public GroupState(Subscription parentSubscription, Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child) {, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, +    private final SubscriptionList cs;, +        this.cs = new SubscriptionList();, +        this.cs = new SubscriptionList();, +        this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            super();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Subscription;, +        final PivotSubscriber<K1, K2, T> pivotSubscriber = new PivotSubscriber<K1, K2, T>(child, state);, +        private PivotSubscriber(Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child, AtomicReference<State> state) {, +            this.groups = new GroupState<K1, K2, T>(this, child);, +            k1Group.unsafeSubscribe(new Subscriber<GroupedObservable<K2, T>>(this) {, +                    k2Group.unsafeSubscribe(new Subscriber<T>(this) {, +        private final Subscription parentSubscription;, +        static final AtomicIntegerFieldUpdater<GroupState> COMPLETED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupState.class, "completed");, +        public GroupState(Subscription parentSubscription, Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child) {, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTake.java, +        Subscriber<T> parent = new Subscriber<T>() {, +        , +        if (limit == 0) {, +            child.onCompleted();, +            parent.unsubscribe();, +        }, +        , +        /*, +         * We decouple the parent and child subscription so there can be multiple take() in a chain, +         * such as for the groupBy Observer use case where you may take(1) on groups and take(20) on the children., +         * , +         * Thus, we only unsubscribe UPWARDS to the parent and an onComplete DOWNSTREAM., +         * , +         * However, if we receive an unsubscribe from the child we still want to propagate it upwards so we register 'parent' with 'child', +         */, +        child.add(parent);, +        return parent;, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, +    private final SubscriptionList cs;, +        this.cs = new SubscriptionList();, +        this.cs = new SubscriptionList();, +        this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            super();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Subscription;, +        final PivotSubscriber<K1, K2, T> pivotSubscriber = new PivotSubscriber<K1, K2, T>(child, state);, +        private PivotSubscriber(Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child, AtomicReference<State> state) {, +            this.groups = new GroupState<K1, K2, T>(this, child);, +            k1Group.unsafeSubscribe(new Subscriber<GroupedObservable<K2, T>>(this) {, +                    k2Group.unsafeSubscribe(new Subscriber<T>(this) {, +        private final Subscription parentSubscription;, +        static final AtomicIntegerFieldUpdater<GroupState> COMPLETED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupState.class, "completed");, +        public GroupState(Subscription parentSubscription, Subscriber<? super GroupedObservable<K2, GroupedObservable<K1, T>>> child) {, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTake.java, +        Subscriber<T> parent = new Subscriber<T>() {, +        , +        if (limit == 0) {, +            child.onCompleted();, +            parent.unsubscribe();, +        }, +        , +        /*, +         * We decouple the parent and child subscription so there can be multiple take() in a chain, +         * such as for the groupBy Observer use case where you may take(1) on groups and take(20) on the children., +         * , +         * Thus, we only unsubscribe UPWARDS to the parent and an onComplete DOWNSTREAM., +         * ]