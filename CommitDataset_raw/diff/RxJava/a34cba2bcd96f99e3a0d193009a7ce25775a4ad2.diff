[+++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +import rx.functions.Functions;, +        return from(o.map(Functions.<T>identity()).singleOrDefault(defaultValue)).single();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +import rx.functions.Functions;, +        return from(o.map(Functions.<T>identity()).singleOrDefault(defaultValue)).single();, +++ b/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java, +import static org.junit.Assert.assertTrue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import rx.Observable.OnSubscribe;, +import rx.functions.Action0;, +import rx.schedulers.Schedulers;, +import rx.subscriptions.Subscriptions;, +, +    @Test, +    public void testSingleOrDefaultUnsubscribe() throws InterruptedException {, +        final CountDownLatch unsubscribe = new CountDownLatch(1);, +        Observable<Integer> o = Observable.create(new OnSubscribe<Integer>() {, +            @Override, +            public void call(Subscriber<? super Integer> subscriber) {, +                subscriber.add(Subscriptions.create(new Action0() {, +                    @Override, +                    public void call() {, +                        unsubscribe.countDown();, +                    }, +                }));, +                subscriber.onNext(1);, +                subscriber.onNext(2);, +                // Don't call `onCompleted` to emulate an infinite stream, +            }, +        }).subscribeOn(Schedulers.newThread());, +        try {, +            o.toBlocking().singleOrDefault(-1);, +            fail("Expected IllegalArgumentException because there are 2 elements");, +        } catch (IllegalArgumentException e) {, +            // Expected, +        }, +        assertTrue("Timeout means `unsubscribe` is not called", unsubscribe.await(30, TimeUnit.SECONDS));, +    }]