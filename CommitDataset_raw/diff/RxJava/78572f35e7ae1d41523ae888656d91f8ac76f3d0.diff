[+++ b/rxjava-core/src/perf/java/rx/PerfBaseline.java, +    , +    @Benchmark, +    public void observableConsumptionUnsafe(Input input) throws InterruptedException {, +        input.firehose.unsafeSubscribe(input.newSubscriber());, +    }, +, +    @Benchmark, +    public void observableViaRangeUnsafe(Input input) throws InterruptedException {, +        input.observable.unsafeSubscribe(input.newSubscriber());, +    }, +++ b/rxjava-core/src/perf/java/rx/PerfBaseline.java, +    , +    @Benchmark, +    public void observableConsumptionUnsafe(Input input) throws InterruptedException {, +        input.firehose.unsafeSubscribe(input.newSubscriber());, +    }, +, +    @Benchmark, +    public void observableViaRangeUnsafe(Input input) throws InterruptedException {, +        input.observable.unsafeSubscribe(input.newSubscriber());, +    }, +++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java, +    public Blackhole bh;, +    public Subscriber<Integer> newSubscriber() {, +        return new Subscriber<Integer>() {, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +, +            }, +, +            @Override, +            public void onNext(Integer t) {, +                bh.consume(t);, +            }, +, +        };, +    }, +, +++ b/rxjava-core/src/perf/java/rx/PerfBaseline.java, +    , +    @Benchmark, +    public void observableConsumptionUnsafe(Input input) throws InterruptedException {, +        input.firehose.unsafeSubscribe(input.newSubscriber());, +    }, +, +    @Benchmark, +    public void observableViaRangeUnsafe(Input input) throws InterruptedException {, +        input.observable.unsafeSubscribe(input.newSubscriber());, +    }, +++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java, +    public Blackhole bh;, +    public Subscriber<Integer> newSubscriber() {, +        return new Subscriber<Integer>() {, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +, +            }, +, +            @Override, +            public void onNext(Integer t) {, +                bh.consume(t);, +            }, +, +        };, +    }, +, +++ b/rxjava-core/src/perf/java/rx/operators/OperatorMergePerf.java, +import org.openjdk.jmh.annotations.BenchmarkMode;, +    // flatMap, +    @Benchmark, +    public void oneStreamOfNthatMergesIn1(final InputMillion input) throws InterruptedException {, +        Observable<Observable<Integer>> os = Observable.range(1, input.size).map(new Func1<Integer, Observable<Integer>>() {, +            public Observable<Integer> call(Integer i) {, +                return Observable.just(i);, +        });, +        LatchedObserver<Integer> o = input.newLatchedObserver();, +        Observable.merge(os).subscribe(o);, +        o.latch.await();, +    // flatMap, +    public void merge1SyncStreamOfN(final InputMillion input) throws InterruptedException {, +    public void mergeNSyncStreamsOfN(final InputThousand input) throws InterruptedException {, +    public void mergeNAsyncStreamsOfN(final InputThousand input) throws InterruptedException {, +    public void mergeTwoAsyncStreamsOfN(final InputThousand input) throws InterruptedException {, +        //        @Param({ "1000" }), +    @State(Scope.Thread), +    public static class InputMillion extends InputWithIncrementingInteger {, +]