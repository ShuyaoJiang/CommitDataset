[+++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyString;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.MultipleAssignmentSubscription;, + * Transforms an Observable that emits Observables into a single Observable that, + * emits the items emitted by the most recently published of those Observables., + * <img width="640" src=, + * "https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">, +     * This function transforms an {@link Observable} sequence of, +     * {@link Observable} sequences into a single {@link Observable} sequence, +     * which produces values from the most recently published {@link Observable}, +     * ., +     *            The {@link Observable} sequence consisting of, +     *            {@link Observable} sequences., +            SafeObservableSubscription parent;, +            parent = new SafeObservableSubscription();, +, +            MultipleAssignmentSubscription child;, +            child = new MultipleAssignmentSubscription();, +, +            parent.wrap(sequences.subscribe(new SwitchObserver<T>(observer, parent, child)));, +, +            return new CompositeSubscription(parent, child);, +        private final Object                         gate;, +        private final MultipleAssignmentSubscription child;, +        private long                                 latest;, +        private boolean                              stopped;, +        private boolean                              hasLatest;, +        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent,, +                MultipleAssignmentSubscription child) {, +            this.child = child;, +            this.gate = new Object();, +            final long id;, +            synchronized (gate) {, +                id = ++latest;, +                this.hasLatest = true;, +            }, +            final SafeObservableSubscription sub;, +            sub = new SafeObservableSubscription();, +            sub.wrap(args.subscribe(new Observer<T>() {, +                public void onNext(T args) {, +                    synchronized (gate) {, +                        if (latest == id) {, +                            SwitchObserver.this.observer.onNext(args);, +                        }, +                    }, +                    synchronized (gate) {, +                        sub.unsubscribe();, +                        if (latest == id) {, +                            SwitchObserver.this.observer.onError(e);, +                            SwitchObserver.this.parent.unsubscribe();, +                        }, +                    }, +                public void onCompleted() {, +                    synchronized (gate) {, +                        sub.unsubscribe();, +                        if (latest == id) {, +                            SwitchObserver.this.hasLatest = false;, +                        if (stopped) {, +                            SwitchObserver.this.observer.onCompleted();, +                            SwitchObserver.this.parent.unsubscribe();, +                        }, +, +, +            }));, +, +            this.child.setSubscription(sub);, +        }, +, +        @Override, +        public void onError(Throwable e) {, +            synchronized (gate) {, +                this.observer.onError(e);, +            }, +, +            this.parent.unsubscribe();, +        }, +, +        @Override, +        public void onCompleted() {, +            synchronized (gate) {, +                this.stopped = true;, +                if (!this.hasLatest) {, +                    this.observer.onCompleted();, +                    this.parent.unsubscribe();, +                }, +            }, +        }, +, +        public void testSwitchWhenOuterCompleteBeforeInner() {, +            Observable<Observable<String>> source = Observable.create(new OnSubscribeFunc<Observable<String>>() {, +                @Override, +                public Subscription onSubscribe(Observer<? super Observable<String>> observer) {, +                    publishNext(observer, 50, Observable.create(new OnSubscribeFunc<String>() {]