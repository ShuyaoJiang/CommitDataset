[+++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, +        return from(Observers.empty());, +++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, +        return from(Observers.empty());, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java, +import java.util.BitSet;, +        Subscriber<T> s = null;, +                s = new Subscriber<T>() {, +                };, +                subscription = s;, +        if (s != null) {, +            source.unsafeSubscribe(s);, +        }, +                Subscription s;, +                    s = subscription;, +                if (s != null) {, +                    s.unsubscribe();, +++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, +        return from(Observers.empty());, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java, +import java.util.BitSet;, +        Subscriber<T> s = null;, +                s = new Subscriber<T>() {, +                };, +                subscription = s;, +        if (s != null) {, +            source.unsafeSubscribe(s);, +        }, +                Subscription s;, +                    s = subscription;, +                if (s != null) {, +                    s.unsubscribe();, +++ b/rxjava-core/src/main/java/rx/operators/OperatorRefCount.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.Map;, +import java.util.WeakHashMap;, +    int index;, +    boolean emitting;, +    /** Guarded by guard. If true, indicates a connection request, false indicates a disconnect request. */, +    List<Token> queue;, +    /** Manipulated while in the serialized section. */, +    int count;, +    /** Manipulated while in the serialized section. */, +    /** Manipulated while in the serialized section. */, +    final Map<Token, Object> connectionStatus;, +    /** Occupied indicator. */, +    private static final Object OCCUPIED = new Object();, +        this.connectionStatus = new WeakHashMap<Token, Object>();, +        int id;, +        synchronized (guard) {, +            id = ++index;, +        }, +        final Token t = new Token(id);, +                disconnect(t);, +            }, +        }));, +        source.unsafeSubscribe(t1);, +        connect(t);, +    }, +    private void connect(Token id) {, +        List<Token> localQueue;, +            if (emitting) {, +                if (queue == null) {, +                    queue = new ArrayList<Token>();, +                }, +                queue.add(id);, +                return;, +            }, +            , +            localQueue = queue;, +            queue = null;, +            emitting = true;, +        }, +        boolean once = true;, +        do {, +            drain(localQueue);, +            if (once) {, +                once = false;, +                doConnect(id);, +            }, +            synchronized (guard) {, +                localQueue = queue;, +                queue = null;, +                if (localQueue == null) {, +                    emitting = false;, +                    return;, +                }, +            }, +        } while (true);, +    }, +    private void disconnect(Token id) {, +        List<Token> localQueue;, +        synchronized (guard) {, +            if (emitting) {, +                if (queue == null) {, +                    queue = new ArrayList<Token>();, +                }, +                queue.add(id.toDisconnect()); // negative value indicates disconnect, +                return;]