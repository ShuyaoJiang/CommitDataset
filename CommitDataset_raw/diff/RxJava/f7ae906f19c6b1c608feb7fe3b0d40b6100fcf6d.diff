[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import java.util.Deque;, +import java.util.LinkedList;, +import java.util.concurrent.locks.ReentrantLock;, +            if (count < 0) {, +                throw new IndexOutOfBoundsException(, +                        "count could not be negative");, +            }, +            /**, +             * Store the last count elements until now., +             */, +            private Deque<T> deque = new LinkedList<T>();, +            private final ReentrantLock lock = new ReentrantLock();, +                try {, +                    for (T value : deque) {, +                        observer.onNext(value);, +                } catch (Throwable e) {, +                    observer.onError(e);, +                }, +            public void onNext(T value) {, +                if (count == 0) {, +                    // If count == 0, we do not need to put value into deque and, +                    // remove it at once. We can ignore the value directly., +                    return;, +                }, +                lock.lock();, +                try {, +                    deque.offerLast(value);, +                    if (deque.size() > count) {, +                        // Now deque has count + 1 elements, so the first, +                        // element in the deque definitely does not belong, +                        // to the last count elements of the source, +                        // sequence. We can drop it now., +                        deque.removeFirst();, +                    }, +                } catch (Throwable e) {, +                    observer.onError(e);, +                    subscription.unsubscribe();, +                } finally {, +                    lock.unlock();, +        @Test, +        public void testTakeLastWithZeroCount() {, +            Observable<String> w = Observable.from("one");, +            Observable<String> take = Observable.create(takeLast(w, 0));, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            take.subscribe(aObserver);, +            verify(aObserver, never()).onNext("one");, +            verify(aObserver, never()).onError(any(Throwable.class));, +            verify(aObserver, times(1)).onCompleted();, +        }, +, +        @Test, +        public void testTakeLastWithNull() {, +            Observable<String> w = Observable.from("one", null, "three");, +            Observable<String> take = Observable.create(takeLast(w, 2));, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            take.subscribe(aObserver);, +            verify(aObserver, never()).onNext("one");, +            verify(aObserver, times(1)).onNext(null);, +            verify(aObserver, times(1)).onNext("three");, +            verify(aObserver, never()).onError(any(Throwable.class));, +            verify(aObserver, times(1)).onCompleted();, +        }, +, +        @Test, +        public void testTakeLastWithNegativeCount() {, +            Observable<String> w = Observable.from("one");, +            Observable<String> take = Observable.create(takeLast(w, -1));, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            take.subscribe(aObserver);, +            verify(aObserver, never()).onNext("one");, +            verify(aObserver, times(1)).onError(, +                    any(IndexOutOfBoundsException.class));, +            verify(aObserver, never()).onCompleted();, +        }, +]