[+++ b/src/main/java/rx/internal/operators/BackpressureUtils.java, +     *            atomic long that should be updated, +++ b/src/main/java/rx/internal/operators/BackpressureUtils.java, +     *            atomic long that should be updated, +++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +    private static final class RangeProducer implements Producer {, +        // accessed by REQUESTED_UPDATER, +        private volatile long requested;, +        private static final AtomicLongFieldUpdater<RangeProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(RangeProducer.class, "requested");, +        private final int end;, +            if (requested == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {, +                for (long i = index; i <= end; i++) {, +            } else if (n > 0) {, +                // backpressure is requested, +                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER,this, n);, +                if (_c == 0) {, +                    while (true) {, +                        /*, +                         * This complicated logic is done to avoid touching the volatile `index` and `requested` values, +                         * during the loop itself. If they are touched during the loop the performance is impacted significantly., +                         */, +                        long r = requested;, +                        long idx = index;, +                        long numLeft = end - idx + 1;, +                        long e = Math.min(numLeft, r);, +                        boolean completeOnFinish = numLeft <= r;, +                        long stopAt = e + idx;, +                        for (long i = idx; i < stopAt; i++) {, +                            if (o.isUnsubscribed()) {, +                                return;, +                            }, +                            o.onNext((int) i);, +                        }, +                        index = stopAt;, +                        , +                        if (completeOnFinish) {, +                            o.onCompleted();, +                            return;, +                        }, +                        if (REQUESTED_UPDATER.addAndGet(this, -e) == 0) {, +                            // we're done emitting the number requested so return, +                            return;, +                        }, +                    }, +                }, +            }, +++ b/src/main/java/rx/internal/operators/BackpressureUtils.java, +     *            atomic long that should be updated, +++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +    private static final class RangeProducer implements Producer {, +        // accessed by REQUESTED_UPDATER, +        private volatile long requested;, +        private static final AtomicLongFieldUpdater<RangeProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(RangeProducer.class, "requested");, +        private final int end;, +            if (requested == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {, +                for (long i = index; i <= end; i++) {, +            } else if (n > 0) {, +                // backpressure is requested, +                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER,this, n);, +                if (_c == 0) {, +                    while (true) {, +                        /*, +                         * This complicated logic is done to avoid touching the volatile `index` and `requested` values, +                         * during the loop itself. If they are touched during the loop the performance is impacted significantly., +                         */, +                        long r = requested;, +                        long idx = index;, +                        long numLeft = end - idx + 1;, +                        long e = Math.min(numLeft, r);, +                        boolean completeOnFinish = numLeft <= r;, +                        long stopAt = e + idx;, +                        for (long i = idx; i < stopAt; i++) {, +                            if (o.isUnsubscribed()) {, +                                return;, +                            }, +                            o.onNext((int) i);, +                        }, +                        index = stopAt;, +                        , +                        if (completeOnFinish) {, +                            o.onCompleted();, +                            return;, +                        }, +                        if (REQUESTED_UPDATER.addAndGet(this, -e) == 0) {, +                            // we're done emitting the number requested so return, +                            return;, +                        }, +                    }, +                }, +            }, +++ b/src/perf/java/rx/operators/OperatorRangePerf.java, +import org.openjdk.jmh.annotations.Benchmark;]