[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def createExampleWithBackpressure() {, +    val o = Observable {, +      subscriber: Subscriber[String] => {, +        var emitted = 0, +        subscriber.setProducer(n => {, +            val intN = if (n >= 10) 10 else n.toInt, +            (0 until intN), +              .takeWhile(_ => emitted < 10 && !subscriber.isUnsubscribed), +              .foreach {, +              i =>, +                emitted += 1, +                subscriber.onNext(s"item ${emitted}"), +            }, +            if (emitted == 10 && !subscriber.isUnsubscribed) {, +              subscriber.onCompleted(), +            }, +        }), +      }, +    }.subscribeOn(IOScheduler()) // Use `subscribeOn` to make sure `Producer` will run in the same Scheduler, +    o.observeOn(ComputationScheduler()).subscribe(new Subscriber[String] {, +      override def onStart() {, +        println("Request a new one at the beginning"), +        request(1), +      }, +, +      override def onNext(v: String) {, +        println("Received " + v), +        println("Request a new one after receiving " + v), +        request(1), +      }, +, +      override def onError(e: Throwable) {, +        e.printStackTrace(), +      }, +, +      override def onCompleted() {, +        println("Done"), +      }, +    }), +    Thread.sleep(10000), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def createExampleWithBackpressure() {, +    val o = Observable {, +      subscriber: Subscriber[String] => {, +        var emitted = 0, +        subscriber.setProducer(n => {, +            val intN = if (n >= 10) 10 else n.toInt, +            (0 until intN), +              .takeWhile(_ => emitted < 10 && !subscriber.isUnsubscribed), +              .foreach {, +              i =>, +                emitted += 1, +                subscriber.onNext(s"item ${emitted}"), +            }, +            if (emitted == 10 && !subscriber.isUnsubscribed) {, +              subscriber.onCompleted(), +            }, +        }), +      }, +    }.subscribeOn(IOScheduler()) // Use `subscribeOn` to make sure `Producer` will run in the same Scheduler, +    o.observeOn(ComputationScheduler()).subscribe(new Subscriber[String] {, +      override def onStart() {, +        println("Request a new one at the beginning"), +        request(1), +      }, +, +      override def onNext(v: String) {, +        println("Received " + v), +        println("Request a new one after receiving " + v), +        request(1), +      }, +, +      override def onError(e: Throwable) {, +        e.printStackTrace(), +      }, +, +      override def onCompleted() {, +        println("Done"), +      }, +    }), +    Thread.sleep(10000), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Producer.scala, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and]