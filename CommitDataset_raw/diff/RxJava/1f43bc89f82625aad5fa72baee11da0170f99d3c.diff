[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, false));, +    }, +    /**, +     * Asynchronously subscribes and unsubscribes Observers to this Observable on the specified {@link Scheduler}, +     * and allows buffering some events emitted from the source in the time gap between the original and, +     * actual subscription, and any excess events will block the source until the actual subscription happens., +     * <p>, +     * This overload should help mitigate issues when subscribing to a PublishSubject (and derivatives, +     * such as GroupedObservable in operator groupBy) and events fired between the original and actual subscriptions, +     * are lost. , +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/subscribeOn.png">, +     * , +     * @param scheduler, +     *            the {@link Scheduler} to perform subscription and unsubscription actions on, +     * @param bufferSize the number of events to buffer before blocking the source while in the time gap,, +     *                   negative value indicates an unlimited buffer, +     * @return the source Observable modified so that its subscriptions and unsubscriptions happen, +     *         on the specified {@link Scheduler}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-subscribeon">RxJava Wiki: subscribeOn()</a>, +     */, +    public final Observable<T> subscribeOn(Scheduler scheduler, int bufferSize) {, +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, true, bufferSize));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, false));, +    }, +    /**, +     * Asynchronously subscribes and unsubscribes Observers to this Observable on the specified {@link Scheduler}, +     * and allows buffering some events emitted from the source in the time gap between the original and, +     * actual subscription, and any excess events will block the source until the actual subscription happens., +     * <p>, +     * This overload should help mitigate issues when subscribing to a PublishSubject (and derivatives, +     * such as GroupedObservable in operator groupBy) and events fired between the original and actual subscriptions, +     * are lost. , +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/subscribeOn.png">, +     * , +     * @param scheduler, +     *            the {@link Scheduler} to perform subscription and unsubscription actions on, +     * @param bufferSize the number of events to buffer before blocking the source while in the time gap,, +     *                   negative value indicates an unlimited buffer, +     * @return the source Observable modified so that its subscriptions and unsubscriptions happen, +     *         on the specified {@link Scheduler}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-subscribeon">RxJava Wiki: subscribeOn()</a>, +     */, +    public final Observable<T> subscribeOn(Scheduler scheduler, int bufferSize) {, +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, true, bufferSize));, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.LinkedList;, +import java.util.Queue;, +import rx.Subscriber;, +import rx.subscriptions.CompositeSubscription;, +, +/**, + * Buffers the incoming events until notified, then replays the, + * buffered events and continues as a simple pass-through subscriber., + * @param <T> the streamed value type, + */, +public class BufferUntilSubscriber<T> extends Subscriber<T> {, +    /** The actual subscriber. */, +    private final Subscriber<? super T> actual;, +    /** Indicate the pass-through mode. */, +    private volatile boolean passthroughMode;, +    /** Protect mode transition. */, +    private final Object gate = new Object();, +    /** The buffered items. */, +    private final Queue<Object> queue = new LinkedList<Object>();, +    /** The queue capacity. */, +    private final int capacity;, +    /** Null sentinel (in case queue type is changed). */, +    private static final Object NULL_SENTINEL = new Object();, +    /** Complete sentinel. */, +    private static final Object COMPLETE_SENTINEL = new Object();, +    /**, +     * Container for an onError event., +     */, +    private static final class ErrorSentinel {, +        final Throwable t;, +, +        public ErrorSentinel(Throwable t) {]