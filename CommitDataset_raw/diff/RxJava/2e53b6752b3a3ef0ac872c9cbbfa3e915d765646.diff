[+++ b/rxjava-core/src/test/java/rx/ObserveOnTests.java, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +++ b/rxjava-core/src/test/java/rx/ObserveOnTests.java, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +        Observable.range(1, 1000).map(new Func1<Integer, Integer>() {, +++ b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java, +    /**, +     * The order of execution is nondeterministic., +     * @throws InterruptedException, +     */, +        final CountDownLatch latch = new CountDownLatch(2);, +        // make it wait until both the first and second are called, +        doAnswer(new Answer() {, +, +            @Override, +            public Object answer(InvocationOnMock invocation) throws Throwable {, +                try {, +                    return invocation.getMock();, +                } finally {, +                    latch.countDown();, +                }, +            }, +        }).when(first).call();]