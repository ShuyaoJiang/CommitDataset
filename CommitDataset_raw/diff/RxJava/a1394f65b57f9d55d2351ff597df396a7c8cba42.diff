[+++ b/src/main/java/io/reactivex/Observable.java, +        return buffer(boundarySupplier, ArrayList::new);, +        , +    }, +, +    public final <B, U extends Collection<? super T>> Observable<U> buffer(Supplier<? extends Observable<B>> boundarySupplier, Supplier<U> bufferSupplier) {, +        Objects.requireNonNull(bufferSupplier);, +        return lift(new OperatorBufferBoundarySupplier<>(boundarySupplier, bufferSupplier));, +++ b/src/main/java/io/reactivex/Observable.java, +        return buffer(boundarySupplier, ArrayList::new);, +        , +    }, +, +    public final <B, U extends Collection<? super T>> Observable<U> buffer(Supplier<? extends Observable<B>> boundarySupplier, Supplier<U> bufferSupplier) {, +        Objects.requireNonNull(bufferSupplier);, +        return lift(new OperatorBufferBoundarySupplier<>(boundarySupplier, bufferSupplier));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorBufferBoundarySupplier.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.Collection;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +import java.util.function.Supplier;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Observable.Operator;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.queue.MpscLinkedQueue;, +import io.reactivex.internal.subscribers.*;, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.subscribers.SerializedSubscriber;, +, +public final class OperatorBufferBoundarySupplier<T, U extends Collection<? super T>, B> implements Operator<U, T> {, +    final Supplier<? extends Publisher<B>> boundarySupplier;, +    final Supplier<U> bufferSupplier;, +    , +    public OperatorBufferBoundarySupplier(Supplier<? extends Publisher<B>> boundarySupplier, Supplier<U> bufferSupplier) {, +        this.boundarySupplier = boundarySupplier;, +        this.bufferSupplier = bufferSupplier;, +    }, +, +    @Override, +    public Subscriber<? super T> apply(Subscriber<? super U> t) {, +        return new BufferBondarySupplierSubscriber<>(new SerializedSubscriber<>(t), bufferSupplier, boundarySupplier);, +    }, +    , +    static final class BufferBondarySupplierSubscriber<T, U extends Collection<? super T>, B>, +    extends QueueDrainSubscriber<T, U, U> implements Subscriber<T>, Subscription, Disposable {, +        /** */, +        final Supplier<U> bufferSupplier;, +        final Supplier<? extends Publisher<B>> boundarySupplier;, +        , +        Subscription s;, +        , +        volatile Disposable other;, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<BufferBondarySupplierSubscriber, Disposable> OTHER =, +                AtomicReferenceFieldUpdater.newUpdater(BufferBondarySupplierSubscriber.class, Disposable.class, "other");, +        , +        static final Disposable DISPOSED = () -> { };, +        , +        U buffer;, +        , +        public BufferBondarySupplierSubscriber(Subscriber<? super U> actual, Supplier<U> bufferSupplier,, +                Supplier<? extends Publisher<B>> boundarySupplier) {, +            super(actual, new MpscLinkedQueue<>());, +            this.bufferSupplier = bufferSupplier;, +            this.boundarySupplier = boundarySupplier;, +        }, +        , +        @Override, +        public void onSubscribe(Subscription s) {, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +                return;, +            }, +            this.s = s;, +            , +            Subscriber<? super U> actual = this.actual;, +            , +            U b;, +            , +            try {, +                b = bufferSupplier.get();, +            } catch (Throwable e) {, +                cancelled = true;, +                s.cancel();]