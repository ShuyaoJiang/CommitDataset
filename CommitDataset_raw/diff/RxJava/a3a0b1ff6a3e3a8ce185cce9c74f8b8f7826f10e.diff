[+++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    Notification<? extends T> poll = notifications.poll();, +                    if (poll != null) {, +                        return poll;, +                    }, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    Notification<? extends T> poll = notifications.poll();, +                    if (poll != null) {, +                        return poll;, +                    }, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        awaitForComplete(latch, subscription);, +        awaitForComplete(latch, subscription);, +, +    private void awaitForComplete(CountDownLatch latch, Subscription subscription) {, +        if (latch.getCount() == 0) {, +            // Synchronous observable completes before awaiting for it., +            // Skip await so InterruptedException will never be thrown., +            return;, +        }, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +    }, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    Notification<? extends T> poll = notifications.poll();, +                    if (poll != null) {, +                        return poll;, +                    }, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        awaitForComplete(latch, subscription);, +        awaitForComplete(latch, subscription);, +, +    private void awaitForComplete(CountDownLatch latch, Subscription subscription) {, +        if (latch.getCount() == 0) {, +            // Synchronous observable completes before awaiting for it., +            // Skip await so InterruptedException will never be thrown., +            return;, +        }, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +    }, +++ b/src/test/java/rx/internal/operators/BlockingOperatorNextTest.java, +import org.junit.Assert;, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static rx.internal.operators.BlockingOperatorNext.next;, +, +        fireOnNextInNewThread(obs, "three");, +        try {, +            assertEquals("three", it.next());, +        } catch (NoSuchElementException e) {, +            fail("Calling next() without hasNext() should wait for next fire");, +        }, +, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    Notification<? extends T> poll = notifications.poll();, +                    if (poll != null) {, +                        return poll;, +                    }, +++ b/src/main/java/rx/observables/BlockingObservable.java, +        awaitForComplete(latch, subscription);, +        awaitForComplete(latch, subscription);, +, +    private void awaitForComplete(CountDownLatch latch, Subscription subscription) {, +        if (latch.getCount() == 0) {, +            // Synchronous observable completes before awaiting for it., +            // Skip await so InterruptedException will never be thrown., +            return;, +        }, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            subscription.unsubscribe();, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);]