[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalArgumentException.class), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalArgumentException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalArgumentException>())], +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalArgumentException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalArgumentException>())], +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (override val asJavaSubscription: rx.subscriptions.SerialSubscription) extends Subscription {, +  override def unsubscribe(): Unit =  asJavaSubscription.unsubscribe(), +  override def isUnsubscribed: Boolean = asJavaSubscription.isUnsubscribed, +  def subscription_=(value: Subscription): this.type = {, +      asJavaSubscription.setSubscription(value.asJavaSubscription), +      this, +  }, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalArgumentException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalArgumentException>())], +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (override val asJavaSubscription: rx.subscriptions.SerialSubscription) extends Subscription {, +  override def unsubscribe(): Unit =  asJavaSubscription.unsubscribe(), +  override def isUnsubscribed: Boolean = asJavaSubscription.isUnsubscribed, +  def subscription_=(value: Subscription): this.type = {, +      asJavaSubscription.setSubscription(value.asJavaSubscription), +      this, +  }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationConditionals;, +import rx.operators.OperationSingle;, +        return from(iterable, Schedulers.currentThread());, +        return create(OperationToObservableIterable.toObservableIterable(iterable, scheduler));, +     * @param items the source array, +        return from(Arrays.asList(items));, +    }, +, +    /**, +     * Converts an Array into an Observable., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">, +     * <p>, +     * Note: the entire array is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     *, +     * @param items the source array, +     * @param scheduler the scheduler to emit the items of the array, +     * @param <T> the type of items in the Array and the type of items to be, +     *            emitted by the resulting Observable, +     * @return an Observable that emits each item in the source Array, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a>, +     */, +    public static <T> Observable<T> from(T[] items, Scheduler scheduler) {, +        return from(Arrays.asList(items), scheduler);, +        return from(Range.createWithCount(start, count), scheduler);, +        return from(Arrays.asList((value)));, +        return from(Arrays.asList((value)), scheduler);, +     * Given an Observable that emits Observables, returns an Observable that, +     * emits the items emitted by the most recently emitted of those, +     * Observables., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/switchDo.png">, +     * , +     * @param sequenceOfSequences the source Observable that emits Observables, +     * @return an Observable that emits only the items emitted by the Observable, +     *         most recently emitted by the source Observable, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#switchonnext">RxJava Wiki: switchOnNext()</a>, +     * @see {@link #switchOnNext(Observable)}, +     */, +    public static <T> Observable<T> switchLatest(Observable<? extends Observable<? extends T>> sequenceOfSequences) {, +        return create(OperationSwitch.switchDo(sequenceOfSequences));, +    }, +, +    /**, +     * Return a particular one of several possible Observables based on a case, +     * selector., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/switchCase.png">, +     *, +     * @param <K> the case key type, +     * @param <R> the result value type, +     * @param caseSelector the function that produces a case key when an, +     *                     Observer subscribes, +     * @param mapOfCases a map that maps a case key to an Observable, +     * @return a particular Observable chosen by key from the map of, +     *         Observables, or an empty Observable if no Observable matches the, +     *         key, +     */, +    public static <K, R> Observable<R> switchCase(Func0<? extends K> caseSelector, , +            Map<? super K, ? extends Observable<? extends R>> mapOfCases) {, +        return switchCase(caseSelector, mapOfCases, Observable.<R>empty());, +    }, +    , +    /**, +     * Return a particular one of several possible Observables based on a case, +     * selector and run it on the designated scheduler.]