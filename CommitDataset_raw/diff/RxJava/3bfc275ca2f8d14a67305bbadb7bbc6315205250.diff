[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java, +            int m = subscribers.length;, +            this.requests = new AtomicLongArray(m + m + 1);, +            this.requests.lazySet(m + m, m);, +            this.emissions = new long[m];, +            Subscriber<? super T>[] subs = subscribers;, +            final int m = subs.length;, +                subs[i].onSubscribe(new RailSubscription(i, m));, +            }, +        }, +, +        final class RailSubscription implements Subscription {, +, +            final int j;, +, +            final int m;, +, +            RailSubscription(int j, int m) {, +                this.j = j;, +                this.m = m;, +            }, +, +                if (requests.compareAndSet(m + j, 0L, 1L)) {, +                    ParallelDispatcher.this.cancel(m + m);, +        void cancel(int m) {, +            if (requests.decrementAndGet(m) == 0L) {, +                    if (ridx != eidx && r.get(n + idx) == 0) {, +                    if (ridx != eidx && r.get(n + idx) == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java, +            int m = subscribers.length;, +            this.requests = new AtomicLongArray(m + m + 1);, +            this.requests.lazySet(m + m, m);, +            this.emissions = new long[m];, +            Subscriber<? super T>[] subs = subscribers;, +            final int m = subs.length;, +                subs[i].onSubscribe(new RailSubscription(i, m));, +            }, +        }, +, +        final class RailSubscription implements Subscription {, +, +            final int j;, +, +            final int m;, +, +            RailSubscription(int j, int m) {, +                this.j = j;, +                this.m = m;, +            }, +, +                if (requests.compareAndSet(m + j, 0L, 1L)) {, +                    ParallelDispatcher.this.cancel(m + m);, +        void cancel(int m) {, +            if (requests.decrementAndGet(m) == 0L) {, +                    if (ridx != eidx && r.get(n + idx) == 0) {, +                    if (ridx != eidx && r.get(n + idx) == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelJoin.java, +import io.reactivex.internal.util.*;, +    final boolean delayErrors;, +, +    public ParallelJoin(ParallelFlowable<? extends T> source, int prefetch, boolean delayErrors) {, +        this.delayErrors = delayErrors;, +        JoinSubscriptionBase<T> parent;, +        if (delayErrors) {, +            parent = new JoinSubscriptionDelayError<T>(s, source.parallelism(), prefetch);, +        } else {, +            parent = new JoinSubscription<T>(s, source.parallelism(), prefetch);, +        }, +    abstract static class JoinSubscriptionBase<T> extends AtomicInteger, +        final AtomicThrowable errors = new AtomicThrowable();, +        JoinSubscriptionBase(Subscriber<? super T> actual, int n, int prefetch) {, +        abstract void onNext(JoinInnerSubscriber<T> inner, T value);, +, +        abstract void onError(Throwable e);, +, +        abstract void onComplete();, +, +        abstract void drain();, +    }, +, +    static final class JoinSubscription<T> extends JoinSubscriptionBase<T> {, +, +        private static final long serialVersionUID = 6312374661811000451L;, +, +        JoinSubscription(Subscriber<? super T> actual, int n, int prefetch) {, +            super(actual, n, prefetch);, +        }, +, +        @Override, +        public void onNext(JoinInnerSubscriber<T> inner, T value) {, +                        if (errors.compareAndSet(null, mbe)) {, +        @Override, +        public void onError(Throwable e) {, +            if (errors.compareAndSet(null, e)) {, +                if (e != errors.get()) {, +        @Override, +        public void onComplete() {, +                    Throwable ex = errors.get();, +                    Throwable ex = errors.get();, +    static final class JoinSubscriptionDelayError<T> extends JoinSubscriptionBase<T> {]