[+++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java, +import io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.*;, +    final boolean interruptibleWorker;, +, +    public ExecutorScheduler(@NonNull Executor executor, boolean interruptibleWorker) {, +        this.interruptibleWorker = interruptibleWorker;, +        return new ExecutorWorker(executor, interruptibleWorker);, +            if (interruptibleWorker) {, +                InterruptibleRunnable interruptibleTask = new InterruptibleRunnable(decoratedRun, null);, +                executor.execute(interruptibleTask);, +                return interruptibleTask;, +            } else {, +            }, +, +        final boolean interruptibleWorker;, +, +        public ExecutorWorker(Executor executor, boolean interruptibleWorker) {, +            this.interruptibleWorker = interruptibleWorker;, +            Runnable task;, +            Disposable disposable;, +, +            if (interruptibleWorker) {, +                InterruptibleRunnable interruptibleTask = new InterruptibleRunnable(decoratedRun, tasks);, +                tasks.add(interruptibleTask);, +, +                task = interruptibleTask;, +                disposable = interruptibleTask;, +            } else {, +                BooleanRunnable runnableTask = new BooleanRunnable(decoratedRun);, +, +                task = runnableTask;, +                disposable = runnableTask;, +            }, +, +            queue.offer(task);, +            return disposable;, +, +        /**, +         * Wrapper for a {@link Runnable} with additional logic for handling interruption on, +         * a shared thread, similar to how Java Executors do it., +         */, +        static final class InterruptibleRunnable extends AtomicInteger implements Runnable, Disposable {, +, +            private static final long serialVersionUID = -3603436687413320876L;, +, +            final Runnable run;, +, +            final DisposableContainer tasks;, +, +            volatile Thread thread;, +, +            static final int READY = 0;, +, +            static final int RUNNING = 1;, +, +            static final int FINISHED = 2;, +, +            static final int INTERRUPTING = 3;, +, +            static final int INTERRUPTED = 4;, +, +            InterruptibleRunnable(Runnable run, DisposableContainer tasks) {, +                this.run = run;, +                this.tasks = tasks;, +            }, +, +            @Override, +            public void run() {, +                if (get() == READY) {, +                    thread = Thread.currentThread();, +                    if (compareAndSet(READY, RUNNING)) {, +                        try {, +                            run.run();, +                        } finally {, +                            thread = null;, +                            if (compareAndSet(RUNNING, FINISHED)) {, +                                cleanup();, +                            } else {, +                                while (get() == INTERRUPTING) {, +                                    Thread.yield();, +                                }, +                                Thread.interrupted();, +                            }, +                        }, +                    } else {, +                        thread = null;, +                    }, +                }, +            }, +, +            @Override, +            public void dispose() {, +                for (;;) {, +                    int state = get();, +                    if (state >= FINISHED) {, +                        break;, +                    } else if (state == READY) {, +                        if (compareAndSet(READY, INTERRUPTED)) {, +                            cleanup();, +                            break;]