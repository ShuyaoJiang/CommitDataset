[+++ b/operators.html, +   dl#outer>dt { font-weight: bold;, +                 font-size: 120%;, +                 margin-right: -1em; }, +   dd::before { content: ": "; }, +   dd.a::after { content: " ⓐⓈ"; }, +   dd.b::after { content: " ⓑ"; }, +   dd.c::after { content: " ⓒ"; }, +   dd.m::after { content: " ⓜ"; }, +, +   dl dt, dl dd { background: #fff; }, +   dl dl dt, dl dl dd { background: #eef; }, +   dl dl dl dt, dl dl dl dd { background: #ffe; }, +   dl dl dl dl dt, dl dl dl dl dd { background: #efe; }, +   dl dl dl dl dl dt, dl dl dl dl dl dd { background: #fef; }, +   dl dl dl dl dl dl dt, dl dl dl dl dl dl dd { background: #fee; }, +     <dt>that was returned from a function called at subscribe-time</dt>, +      <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#start"><code>start(&#8239;)</code></a></dd>, +      <dd class="sub"><dl>, +       <dt>anew for each subscriber</dt>, +        <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#toasync-or-asyncaction-or-asyncfunc"><code>toAsync(&#8239;)</code></a></dd>, +      </dl></dd>, +     <dt>that was returned from an <code>Action</code> called at subscribe-time</dt>, +      <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#fromaction"><code>fromAction(&#8239;)</code></a></dd>, +     <dt>that was returned from a <code>Callable</code> called at subscribe-time</dt>, +      <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#fromcallable"><code>fromCallable(&#8239;)</code></a></dd>, +     <dt>that was returned from a <code>Runnable</code> called at subscribe-time</dt>, +      <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#fromrunnable"><code>fromRunnable(&#8239;)</code></a></dd>, +   <dt>that obtains its sequence from an Array or Iterable</dt>, +   <dt>by retrieving it from a Future</dt>, +    <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#deferfuture"><code>deferFuture(&#8239;)</code></a></dd>, +   <dt>that obtains its sequence from a Future</dt>, +   <dt>that obtains its sequence from an <code>Action</code> called periodically</dt>, +    <dd class="a"><a href="https://github.com/Netflix/RxJava/wiki/Async-Operators#runasync"><code>runAsync(&#8239;)</code></a></dd>, +    <dd class="sub"><dl>, +     <dt>as long as a predicate remains true</dt>, +      <dd class="c"><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#whileDo"><code>whileDo(&#8239;)</code></a></dd>, +      <dd class="sub"><dl>, +       <dt>but at least once, no matter what</dt>, +       <dd class="c"><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#doWhile"><code>doWhile(&#8239;)</code></a></dd>, +      </dl></dd>, +    </dl></dd>, +   <dt>and emitting all of the items from all of the Observables in whatever order they are received</dt>, +     <dt>where the source Observables are found in an Iterable or Observable</dt>, +      <dd><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror"><code>mergeDelayError(&#8239;)</code></a></dd>, +   <dt>and emitting all of the items from all of the Observables, one Observable at a time</dt>, +    <dd><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat"><code>concat(&#8239;)</code></a></dd>, +     <dt>whenever <em>each</em> of the Observables has emitted a new item</dt>, +      <dd><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip"><code>zip(&#8239;)</code></a></dd>, +     <dt>whenever <em>any</em> of the Observables has emitted a new item</dt>, +      <dd><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest"><code>combineLatest(&#8239;)</code></a></dd>, +   <dt>and emitting the items from only the most-recently emitted of those Observables</dt>, +   <dt>and mirroring only one of those Observables (which one depends on a parameter I am passed)</dt>, +    <dd class="c"><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#switchCase"><code>switchCase(&#8239;)</code></a></dd>, +   <dt>reducing an Observable that emits many Observables to one that emits as many Observables as I have processes to process them on</dt>, +    <dd class="s"><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#parallelmerge"><code>parallelMerge(&hellip;)</code></a></dd>, +   <dt>based on all of the items that preceded them</dt>, +    <dd><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#scan"><code>scan(&#8239;)</code></a></dd>, +   <dt>into an indicator of the amount of time that lapsed before the emission of the item</dt>, +    <dd class="sub"><dl>, +  </dl></dd>, +   <dt>only if its sequence is empty</dt>, +    <dd><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#defaultifempty"><code>defaultIfEmpty(&hellip;)</code></a></dd>, + <dt>I want to retrieve from an Observable</dt>, +  <dd class="sub"><dl>, +   <dt>the last item emitted before it completed</dt>, +    <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#last-and-lastordefault"><code>last(&#8239;)</code></a></dd>, +    <dd class="sub"><dl>, +     <dt>or a default item if none were emitted</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#last-and-lastordefault"><code>lastOrDefault(&#8239;)</code></a></dd>, +     <dt>that matches a predicate</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#last-and-lastordefault"><code>last(predicate)</code></a></dd>, +      <dd class="sub"><dl>, +       <dt>or a default item if none did</dt>, +        <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#last-and-lastordefault"><code>lastOrDefault(predicate)</code></a></dd>, +      </dl></dd>, +    </dl></dd>, +   <dt>the sole item it emitted</dt>, +    <dd class="sub"><dl>, +     <dt>or an exception if it did not emit exactly one</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#single-and-singleordefault"><code>single(&#8239;)</code></a></dd>, +      <dd class="sub"><dl>, +       <dt>or rather a default item if it did not emit any</dt>, +        <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#single-and-singleordefault"><code>singleOrDefault(&#8239;)</code></a></dd>, +      </dl></dd>, +     <dt>that matches a predicate, or an exception if exactly one did not</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#single-and-singleordefault"><code>single(predicate)</code></a></dd>, +      <dd class="sub"><dl>, +       <dt>or rather a default item if none did</dt>, +        <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#single-and-singleordefault"><code>singleOrDefault(predicate)</code></a></dd>, +      </dl></dd>, +    </dl></dd>, +   <dt>the first item it emitted</dt>, +    <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#first-and-firstordefault"><code>first(&#8239;)</code></a></dd>, +    <dd class="sub"><dl>, +     <dt>or a default item if none were emitted</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#first-and-firstordefault"><code>firstOrDefault(&#8239;)</code></a></dd>, +     <dt>that matches a predicate</dt>, +      <dd class="b"><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#first-and-firstordefault"><code>first(predicate)</code></a></dd>, +      <dd class="sub"><dl>]