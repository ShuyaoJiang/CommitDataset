[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.operators.flowable.FlowableStrict.StrictSubscriber;, +        return RxJavaPlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));, +            subscribe((SafeSubscriber<? super T>)s);, +     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict, +    @Deprecated, +        return this;, +        if (s instanceof FlowableSubscriber) {, +            subscribe((FlowableSubscriber<? super T>)s);, +        } else {, +            ObjectHelper.requireNonNull(s, "s is null");, +            subscribe(new StrictSubscriber<T>(s));, +        }, +    }, +, +    /**, +     * Establish a connection between this Flowable and the given FlowableSubscriber and, +     * start streaming events based on the demand of the FlowableSubscriber., +     * <p>, +     * This is a "factory method" and can be called multiple times, each time starting a new {@link Subscription}., +     * <p>, +     * Each {@link Subscription} will work for only a single {@link FlowableSubscriber}., +     * <p>, +     * If the same {@link FlowableSubscriber} instance is subscribed to multiple {@link Flowable}s and/or the, +     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}, +     * methods manually., +     * <p>, +     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal, +     * the error via {@link FlowableSubscriber#onError(Throwable)}., +     * <p>, +     * This subscribe method relaxes the following Reactive-Streams rules:, +     * <ul>, +     * <li>§1.3: onNext should not be called concurrently until onSubscribe returns., +     *     <b>FlowableSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.</b></li>, +     * <li>§2.3: onError or onComplete must not call cancel., +     *     <b>Calling request() or cancel() is NOP at this point.</b></li>, +     * <li>§2.12: onSubscribe must be called at most once on the same instance., +     *     <b>FlowableSubscriber reuse is not checked and if happens, it is the responsibility of, +     *     the FlowableSubscriber to ensure proper serialization of its onXXX methods.</b></li>, +     * <li>§3.9: negative requests should emit an onError(IllegalArgumentException)., +     *     <b>Non-positive requests signal via RxJavaPlugins.onError and the stream is not affected.</b></li>, +     * </ul>, +     * <dl>, +     *  <dt><b>Backpressure:</b></dt>, +     *  <dd>The backpressure behavior/expectation is determined by the supplied {@code FlowableSubscriber}.</dd>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     * @param s the FlowableSubscriber that will consume signals from this Flowable, +     * @since 2.0.7 - experimental, +     */, +    @BackpressureSupport(BackpressureKind.SPECIAL), +    @SchedulerSupport(SchedulerSupport.NONE), +    @Experimental, +    public final void subscribe(FlowableSubscriber<? super T> s) {, +            Subscriber<? super T> z = RxJavaPlugins.onSubscribe(this, s);, +            ObjectHelper.requireNonNull(z, "Plugin returned null Subscriber");, +            subscribeActual(z);, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.operators.flowable.FlowableStrict.StrictSubscriber;, +        return RxJavaPlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));, +            subscribe((SafeSubscriber<? super T>)s);, +     * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict, +    @Deprecated, +        return this;, +        if (s instanceof FlowableSubscriber) {, +            subscribe((FlowableSubscriber<? super T>)s);, +        } else {, +            ObjectHelper.requireNonNull(s, "s is null");, +            subscribe(new StrictSubscriber<T>(s));, +        }, +    }, +, +    /**, +     * Establish a connection between this Flowable and the given FlowableSubscriber and, +     * start streaming events based on the demand of the FlowableSubscriber., +     * <p>, +     * This is a "factory method" and can be called multiple times, each time starting a new {@link Subscription}., +     * <p>, +     * Each {@link Subscription} will work for only a single {@link FlowableSubscriber}., +     * <p>, +     * If the same {@link FlowableSubscriber} instance is subscribed to multiple {@link Flowable}s and/or the, +     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}, +     * methods manually., +     * <p>, +     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal, +     * the error via {@link FlowableSubscriber#onError(Throwable)}., +     * <p>, +     * This subscribe method relaxes the following Reactive-Streams rules:, +     * <ul>, +     * <li>§1.3: onNext should not be called concurrently until onSubscribe returns., +     *     <b>FlowableSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.</b></li>, +     * <li>§2.3: onError or onComplete must not call cancel., +     *     <b>Calling request() or cancel() is NOP at this point.</b></li>, +     * <li>§2.12: onSubscribe must be called at most once on the same instance., +     *     <b>FlowableSubscriber reuse is not checked and if happens, it is the responsibility of, +     *     the FlowableSubscriber to ensure proper serialization of its onXXX methods.</b></li>, +     * <li>§3.9: negative requests should emit an onError(IllegalArgumentException).]