[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0} and the first item emitted by {@code w1}; the second item emitted by, +     * the new Observable will be the result of the function applied to the second item emitted by {@code w0} and the second item emitted by {@code w1}; and so forth., +     * <p>, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * of the source Observable that emits the fewest items., +     * , +     * @param o1, +     *            one source Observable, +     * @param o2, +     *            another source Observable, +     * @param zipFunction, +     *            a function that, when applied to an item emitted by each of the source, +     *            Observables, results in an item that will be emitted by the resulting Observable, +     * @return an Observable that emits the zipped results, +     */, +    public static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, zipFunction));, +    }, +, +    /**, +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +    public static <R> Observable<R> zip(Collection<? extends Observable<?>> ws, FuncN<? extends R> zipFunction) {, +    public Observable<T> reduce(Func2<T, T, T> accumulator) {, +    public Observable<T> aggregate(Func2<T, T, T> accumulator) {, +    public <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> accumulator) {, +    public <R> Observable<R> aggregate(R initialValue, Func2<R, ? super T, R> accumulator) {, +    public Observable<T> scan(Func2<T, T, T> accumulator) {, +    public <R> Observable<R> scan(R initialValue, Func2<R, ? super T, R> accumulator) {, +     * @param o, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0} and the first item emitted by {@code w1}; the second item emitted by, +     * the new Observable will be the result of the function applied to the second item emitted by {@code w0} and the second item emitted by {@code w1}; and so forth., +     * <p>, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * of the source Observable that emits the fewest items., +     * , +     * @param o1, +     *            one source Observable, +     * @param o2, +     *            another source Observable, +     * @param zipFunction, +     *            a function that, when applied to an item emitted by each of the source, +     *            Observables, results in an item that will be emitted by the resulting Observable, +     * @return an Observable that emits the zipped results, +     */, +    public static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, zipFunction));, +    }, +, +    /**, +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +     * combinations of four items emitted, in sequence, by four other Observables., +    public static <R> Observable<R> zip(Collection<? extends Observable<?>> ws, FuncN<? extends R> zipFunction) {, +    public Observable<T> reduce(Func2<T, T, T> accumulator) {, +    public Observable<T> aggregate(Func2<T, T, T> accumulator) {, +    public <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> accumulator) {, +    public <R> Observable<R> aggregate(R initialValue, Func2<R, ? super T, R> accumulator) {, +    public Observable<T> scan(Func2<T, T, T> accumulator) {, +    public <R> Observable<R> scan(R initialValue, Func2<R, ? super T, R> accumulator) {]