[+++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.BitSet;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.SingleAssignmentSubscription;, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1), Functions.fromFunc(combineLatestFunction));, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2), Functions.fromFunc(combineLatestFunction));    , +                return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3), Functions.fromFunc(combineLatestFunction));, +                return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4), Functions.fromFunc(combineLatestFunction));, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5), Functions.fromFunc(combineLatestFunction));, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5, w6), Functions.fromFunc(combineLatestFunction));, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5, w6, w7), Functions.fromFunc(combineLatestFunction));, +        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5, w6, w7, w8), Functions.fromFunc(combineLatestFunction));, +    static final class CombineLatest<T, R> implements OnSubscribeFunc<R> {, +        final List<Observable<? extends T>> sources;, +        final FuncN<? extends R> combiner;, +        public CombineLatest(Iterable<? extends Observable<? extends T>> sources, FuncN<? extends R> combiner) {, +            this.sources = new ArrayList<Observable<? extends T>>();, +            this.combiner = combiner;, +            for (Observable<? extends T> source : sources) {, +                this.sources.add(source);, +        public Subscription onSubscribe(Observer<? super R> t1) {, +            CompositeSubscription csub = new CompositeSubscription();, +            , +            Collector collector = new Collector(t1, csub, sources.size());, +            , +            int index = 0;, +            List<SourceObserver> observers = new ArrayList<SourceObserver>(sources.size() + 1);, +            for (Observable<? extends T> source : sources) {, +                SingleAssignmentSubscription sas = new SingleAssignmentSubscription();, +                csub.add(sas);, +                observers.add(new SourceObserver(collector, sas, index, source));, +                index++;, +            }, +            , +            for (SourceObserver so : observers) {, +                // if we run to completion, don't bother any further, +                if (!csub.isUnsubscribed()) {, +                    so.connect();, +                }, +            }, +            , +            return csub;, +        }, +        /**, +         * The collector that combines the latest values from many sources., +         */, +        final class Collector {, +            final Observer<? super R> observer;, +            final Subscription cancel;, +            final Lock lock;, +            final Object[] values;, +            /** Bitmap to keep track who produced a value already. */, +            final BitSet hasValue;, +            /** Bitmap to keep track who has completed. */, +            final BitSet completed;, +            /** Number of source observers who have produced a value. */, +            int hasCount;, +            /** Number of completed source observers. */, +            int completedCount;, +            public Collector(Observer<? super R> observer, Subscription cancel, int count) {, +                this.observer = observer;, +                this.cancel = cancel;, +                this.values = new Object[count];, +                this.hasValue = new BitSet(count);, +                this.completed = new BitSet(count);, +                this.lock = new ReentrantLock();, +            }, +            public void next(int index, T value) {, +                lock.lock();, +                try {, +                    values[index] = value;, +                    if (!hasValue.get(index)) {, +                        hasValue.set(index);, +                        hasCount++;, +                    }, +                    if (hasCount == values.length) {, +                        // clone: defensive copy due to varargs, +                        try {, +                            observer.onNext(combiner.call(values.clone()));, +                        } catch (Throwable t) {, +                            terminate();, +                            observer.onError(t);, +                            cancel.unsubscribe();, +                        }, +                    }, +                } finally {, +                    lock.unlock();, +                }, +            }, +            public void error(int index, Throwable e) {, +                lock.lock();, +                try {, +                    if (!isTerminated()) {, +                        terminate();, +                        observer.onError(e);, +                        cancel.unsubscribe();]