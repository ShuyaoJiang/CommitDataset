[+++ b/rxjava-core/src/main/java/rx/internal/util/IndexedRingBuffer.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.internal.util;, +, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReferenceArray;, +, +import rx.Subscription;, +import rx.functions.Func1;, +import rx.internal.util.unsafe.AtomicIntReferenceArray;, +import rx.internal.util.unsafe.UnsafeAccess;, +, +/**, + * Add/Remove without object allocation (after initial construction)., + * <p>, + * This is meant for hundreds or single-digit thousands of elements that need, + * to be rapidly added and randomly or sequentially removed while avoiding object allocation., + * <p>, + * On Intel Core i7, 2.3Mhz, Mac Java 8:, + * <p>, + * - adds per second single-threaded => ~32,598,500 for 100, + * - adds per second single-threaded => ~23,200,000 for 10,000, + * - adds + removes per second single-threaded => 15,562,100 for 100, + * - adds + removes per second single-threaded => 8,760,000 for 10,000, + * , + * <pre> {@code, + * Benchmark                                                (size)   Mode   Samples         Mean   Mean error    Units, + * r.i.u.PerfIndexedRingBuffer.indexedRingBufferAdd            100  thrpt         5   307403.329    17487.185    ops/s, + * r.i.u.PerfIndexedRingBuffer.indexedRingBufferAdd          10000  thrpt         5     1819.151      764.603    ops/s, + * r.i.u.PerfIndexedRingBuffer.indexedRingBufferAddRemove      100  thrpt         5   149649.075     4765.899    ops/s, + * r.i.u.PerfIndexedRingBuffer.indexedRingBufferAddRemove    10000  thrpt         5      825.304       14.079    ops/s, + * } </pre>, + * , + * @param <E>, + */, +public class IndexedRingBuffer<E> implements Subscription {, +, +    private static final ObjectPool<IndexedRingBuffer> POOL = new ObjectPool<IndexedRingBuffer>() {, +, +        @Override, +        protected IndexedRingBuffer createObject() {, +            return new IndexedRingBuffer();, +        }, +, +    };, +, +    public final static IndexedRingBuffer getInstance() {, +        return POOL.borrowObject();, +    }, +, +    private final ElementSection<E> elements = new ElementSection<E>();, +    private final IndexSection removed = new IndexSection();, +    /* package for unit testing */final AtomicInteger index = new AtomicInteger();, +    /* package for unit testing */final AtomicInteger removedIndex = new AtomicInteger();, +    /* package for unit testing */static final int SIZE = 512;, +, +    /**, +     * This resets the arrays, nulls out references and returns it to the pool., +     * This extra CPU cost is far smaller than the object allocation cost of not pooling., +     */, +    public void releaseToPool() {, +        // need to clear all elements so we don't leak memory, +        int maxIndex = index.get();, +        int realIndex = 0;, +        ElementSection<E> section = elements;, +        outer: while (section != null) {, +            for (int i = 0; i < SIZE; i++, realIndex++) {, +                if (realIndex >= maxIndex) {, +                    section = null;, +                    break outer;, +                }, +                // we can use lazySet here because we are nulling things out and not accessing them again, +                // (relative on Mac Intel i7) lazySet gets us ~30m vs ~26m ops/second in the JMH test (100 adds per release), +                section.array.set(i, null);, +            }, +            section = section.next;, +        }, +, +        index.set(0);, +        removedIndex.set(0);, +        POOL.returnObject(this);, +    }, +, +    @Override, +    public void unsubscribe() {, +        releaseToPool();]