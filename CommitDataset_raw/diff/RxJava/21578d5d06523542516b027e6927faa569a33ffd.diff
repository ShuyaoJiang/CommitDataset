[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, +, +    private static final Subscriber<Object> EMPTY = new Subscriber<Object>() {, +, +        @Override, +        public final void onCompleted() {, +            // do nothing, +        }, +, +        @Override, +        public final void onError(Throwable e) {, +            throw new OnErrorNotImplementedException(e);, +        }, +, +        @Override, +        public final void onNext(Object args) {, +            // do nothing, +        }, +, +    };, +, +        return (Subscriber<T>) EMPTY;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, +, +    private static final Subscriber<Object> EMPTY = new Subscriber<Object>() {, +, +        @Override, +        public final void onCompleted() {, +            // do nothing, +        }, +, +        @Override, +        public final void onError(Throwable e) {, +            throw new OnErrorNotImplementedException(e);, +        }, +, +        @Override, +        public final void onNext(Object args) {, +            // do nothing, +        }, +, +    };, +, +        return (Subscriber<T>) EMPTY;, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.functions.Action0;, +import rx.observers.Subscribers;, +import rx.subscriptions.Subscriptions;, +        State<T> state = new State<T>();, +        return new BufferUntilSubscriber<T>(state);, +    /** The common state. */, +    static final class State<T> {, +        /** Lite notifications of type T. */, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /** The first observer or the one which buffers until the first arrives. */, +        final AtomicReference<Observer<? super T>> observerRef = new AtomicReference<Observer<? super T>>(new BufferedObserver<T>());, +        /** How many subscribers. */, +        final AtomicBoolean first = new AtomicBoolean();, +        /** The rest of the subscribers without buffering. Guarded by this. */, +        final Set<Subscriber<? super T>> subscribers = new LinkedHashSet<Subscriber<? super T>>();, +        /** Guarded by this. */]