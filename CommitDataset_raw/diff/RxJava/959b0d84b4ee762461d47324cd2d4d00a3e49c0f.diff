[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWindow;, +import rx.util.Closing;, +import rx.util.Opening;, +     * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you, +        // TODO should this static remain? I have left it because it is an Observable<Observable>, +     * On an Observable that emits Observables, creates a single Observable that, +     * @throws ClassCastException, +     *             if sequence not of type {@code Observable<Observable<T>}, +    @SuppressWarnings("unchecked"), +    public Observable<T> switchDo() {, +        // TODO can we come up with a better name than this? It should be 'switch' but that is reserved., +        // Perhaps 'switchOnNext'?, +        return create(OperationSwitch.switchDo((Observable<? extends Observable<? extends T>>) this));, +     * emitted and replaced with a new buffer when the Observable produced by the specified {@link Func0} produces a {@link rx.util.Closing} object. The * {@link Func0} will then, +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +     *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link rx.util.Closing} object., +    public Observable<List<T>> buffer(Func0<? extends Observable<? extends Closing>> bufferClosingSelector) {, +     * Observable produces a {@link rx.util.Opening} object. Additionally the {@link Func0} argument, +     * is used to create an Observable which produces {@link rx.util.Closing} objects. When this, +     *            The {@link Observable} which, when it produces a {@link rx.util.Opening} object, will cause, +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +    public Observable<List<T>> buffer(Observable<? extends Opening> bufferOpenings, Func1<? super Opening, ? extends Observable<? extends Closing>> bufferClosingSelector) {, +     * Creates an Observable which produces windows of collected values. This Observable produces connected, +     * non-overlapping windows. The current window is emitted and replaced with a new window when the, +     * Observable produced by the specified {@link Func0} produces a {@link rx.util.Closing} object. The {@link Func0} will then be used to create a new Observable to listen for the end of the next, +     * window., +     * , +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param closingSelector, +     *            The {@link Func0} which is used to produce an {@link Observable} for every window created., +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated window, +     *            is emitted and replaced with a new one., +     * @return, +     *         An {@link Observable} which produces connected non-overlapping windows, which are emitted, +     *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link rx.util.Closing} object., +     */, +    public Observable<Observable<T>> window(Observable<T> source, Func0<Observable<Closing>> closingSelector) {, +        return create(OperationWindow.window(source, closingSelector));, +    }, +, +    /**, +     * Creates an Observable which produces windows of collected values. This Observable produces windows., +     * Chunks are created when the specified "windowOpenings" Observable produces a {@link rx.util.Opening} object., +     * Additionally the {@link Func0} argument is used to create an Observable which produces {@link rx.util.Closing} objects. When this Observable produces such an object, the associated window is, +     * emitted., +     * , +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param windowOpenings, +     *            The {@link Observable} which when it produces a {@link rx.util.Opening} object, will cause, +     *            another window to be created., +     * @param closingSelector, +     *            The {@link Func0} which is used to produce an {@link Observable} for every window created., +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated window, +     *            is emitted., +     * @return, +     *         An {@link Observable} which produces windows which are created and emitted when the specified {@link Observable}s publish certain objects., +     */, +    public Observable<Observable<T>> window(Observable<T> source, Observable<Opening> windowOpenings, Func1<Opening, Observable<Closing>> closingSelector) {, +        return create(OperationWindow.window(source, windowOpenings, closingSelector));, +    }, +, +    /**, +     * Creates an Observable which produces windows of collected values. This Observable produces connected, +     * non-overlapping windows, each containing "count" elements. When the source Observable completes or, +     * encounters an error, the current window is emitted, and the event is propagated., +     * , +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param count, +     *            The maximum size of each window before it should be emitted., +     * @return, +     *         An {@link Observable} which produces connected non-overlapping windows containing at most, +     *         "count" produced values., +     */, +    public Observable<Observable<T>> window(Observable<T> source, int count) {, +        return create(OperationWindow.window(source, count));, +    }, +, +    /**, +     * Creates an Observable which produces windows of collected values. This Observable produces windows every, +     * "skip" values, each containing "count" elements. When the source Observable completes or encounters an error,, +     * the current window is emitted and the event is propagated., +     * , +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param count, +     *            The maximum size of each window before it should be emitted., +     * @param skip, +     *            How many produced values need to be skipped before starting a new window. Note that when "skip" and, +     *            "count" are equals that this is the same operation as {@link Observable#window(Observable, int)}., +     * @return, +     *         An {@link Observable} which produces windows every "skipped" values containing at most, +     *         "count" produced values., +     */, +    public Observable<Observable<T>> window(Observable<T> source, int count, int skip) {, +        return create(OperationWindow.window(source, count, skip));, +    }]