[+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.subjects;, +, +import java.lang.reflect.Array;, +import java.util.*;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Scheduler;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.*;, +, +/**, + * Replays events to Subscribers., + * , + * <p>This Subject respects the backpressure behavior of its Subscribers (individually)., + * , + * @param <T> the value type, + */, +public final class ReplaySubject<T> extends Subject<T, T> {, +, +    public static <T> ReplaySubject<T> create() {, +        return create(16);, +    }, +, +    public static <T> ReplaySubject<T> create(int capacityHint) {, +        if (capacityHint <= 0) {, +            throw new IllegalArgumentException("capacityHint > 0 required but it was " + capacityHint);, +        }, +        ReplayBuffer<T> buffer = new UnboundedReplayBuffer<>(capacityHint);, +        return createWithBuffer(buffer);, +    }, +, +    public static <T> ReplaySubject<T> createWithSize(int size) {, +        if (size <= 0) {, +            throw new IllegalArgumentException("size > 0 required but it was " + size);, +        }, +        SizeBoundReplayBuffer<T> buffer = new SizeBoundReplayBuffer<>(size);, +        return createWithBuffer(buffer);, +    }, +, +    public static <T> ReplaySubject<T> createWithTime(long maxAge, TimeUnit unit) {, +        return createWithTime(maxAge, unit, Schedulers.trampoline());, +    }, +, +    public static <T> ReplaySubject<T> createWithTime(long maxAge, TimeUnit unit, Scheduler scheduler) {, +        return createWithTimeAndSize(maxAge, unit, scheduler, Integer.MAX_VALUE);, +    }, +, +    public static <T> ReplaySubject<T> createWithTimeAndSize(long maxAge, TimeUnit unit, Scheduler scheduler, int size) {, +        Objects.requireNonNull(unit);, +        Objects.requireNonNull(scheduler);, +        if (size <= 0) {, +            throw new IllegalArgumentException("size > 0 required but it was " + size);, +        }, +        SizeAndTimeBoundReplayBuffer<T> buffer = new SizeAndTimeBoundReplayBuffer<>(size, maxAge, unit, scheduler);, +        return createWithBuffer(buffer);, +    }, +    , +    static <T> ReplaySubject<T> createWithBuffer(ReplayBuffer<T> buffer) {, +        State<T> state = new State<>(buffer);, +        return new ReplaySubject<>(state);, +    }, +, +, +    final State<T> state;, +    , +    protected ReplaySubject(State<T> state) {, +        super(state);, +        this.state = state;, +    }, +    , +    @Override, +    public void onSubscribe(Subscription s) {, +        state.onSubscribe(s);, +    }, +, +    @Override, +    public void onNext(T t) {, +        state.onNext(t);, +    }, +, +    @Override]