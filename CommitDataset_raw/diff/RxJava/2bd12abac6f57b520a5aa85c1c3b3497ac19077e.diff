[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def withFilter(p: T => Boolean): WithFilter[T] = {, +    new WithFilter[T](p, asJava), +  }, +  , +// "implementation restriction: nested class is not allowed in value class., +// This restriction is planned to be removed in subsequent releases."  , +class WithFilter[+T] private[scala] (p: T => Boolean, asJava: rx.Observable[_ <: T]) {, +  def map[B](f: T => B): Observable[B] = {, +    Observable[B](asJava.filter(p).map[B](f)), +  , +  def flatMap[B](f: T => Observable[B]): Observable[B] = {, +    Observable[B](asJava.filter(p).flatMap[B]((x: T) => f(x).asJava)), +  }, +  , +  def withFilter(q: T => Boolean): Observable[T] = {, +    Observable[T](asJava.filter((x: T) => p(x) && q(x))), +  }, +  , +  // there is no foreach here, that's only available on BlockingObservable, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def withFilter(p: T => Boolean): WithFilter[T] = {, +    new WithFilter[T](p, asJava), +  }, +  , +// "implementation restriction: nested class is not allowed in value class., +// This restriction is planned to be removed in subsequent releases."  , +class WithFilter[+T] private[scala] (p: T => Boolean, asJava: rx.Observable[_ <: T]) {, +  def map[B](f: T => B): Observable[B] = {, +    Observable[B](asJava.filter(p).map[B](f)), +  , +  def flatMap[B](f: T => Observable[B]): Observable[B] = {, +    Observable[B](asJava.filter(p).flatMap[B]((x: T) => f(x).asJava)), +  }, +  , +  def withFilter(q: T => Boolean): Observable[T] = {, +    Observable[T](asJava.filter((x: T) => p(x) && q(x))), +  }, +  , +  // there is no foreach here, that's only available on BlockingObservable, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def testForComprehension() {, +    val observables = Observable(Observable(1, 2, 3), Observable(10, 20, 30)), +    val squares = (for (o <- observables; i <- o if i % 2 == 0) yield i*i), +    assertEquals(squares.toBlockingObservable.toList, List(4, 100, 400, 900)), +  }, +  ]