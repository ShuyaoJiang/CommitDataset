[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalaimpl/Observable.scala, +import scala.collection.Seq, +  import scala.collection.Seq, +  def buffer(bufferClosingSelector: () => Observable[Closing]) : Observable[Seq[T]] = {, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(f), +    Observable.jObsOfListToScObsOfSeq(jObs.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  def buffer(count: Int): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(count), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def window(count: Int): Observable[Observable[T]] = {, +    // this line makes the compiler crash (if it's the last line of the method):, +    // Observable.jObsOfJObsToScObsOfScObs(asJava.window(count)), +    , +    // this line gives an error:, +    // "type mismatch; found : rx.Observable[rx.Observable[_$1]] required: rx.Observable[rx.Observable[T]]", +    // Observable.jObsOfJObsToScObsOfScObs(asJava.window(count) : JObservable[JObservable[T]]), +    , +    // workaround with a cast:, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(count).asInstanceOf[JObservable[JObservable[T]]]), +  }, +    new Observable[R](asJava.reduce(initialValue, accumulator)), +    new Observable[R](asJava.scan(initialValue, accumulator)), +  def zipWithIndex: Observable[(T, Int)] = {, +    ???, +  }, +, +  import scala.collection.immutable.Range, +  private[scalaimpl] , +  def jObsOfListToScObsOfSeq[T](jObs: rx.Observable[_ <: java.util.List[T]]): Observable[Seq[T]] = {, +    val oScala1: Observable[java.util.List[T]] = new Observable[java.util.List[T]](jObs), +    oScala1.map((lJava: java.util.List[T]) => lJava.asScala), +  }, +  , +  private[scalaimpl] , +  def jObsOfJObsToScObsOfScObs[T](jObs: rx.Observable[_ <: rx.Observable[_ <: T]]): Observable[Observable[T]] = {, +    val oScala1: Observable[rx.Observable[_ <: T]] = new Observable[rx.Observable[_ <: T]](jObs), +    oScala1.map((oJava: rx.Observable[_ <: T]) => new Observable[T](oJava)), +  }, +  , +    new Observable[T](JObservable.create(func)), +    new Observable[Nothing](JObservable.error(exception)), +    new Observable[T](JObservable.from(args.toIterable.asJava)), +  def apply(range: Range): Observable[Int] = {, +    new Observable[Int](JObservable.from(range.toIterable.asJava)), +  }, +  , +    new Observable[T](JObservable.defer(observable.asJava)), +    new Observable[T](JObservable.just(value)), +    new Observable[Nothing](JObservable.never()), +  def map[B](f: T => B): Observable[B] = new Observable[B](wrapped.filter(p).map(f)), +  def withFilter(p: T => Boolean): Observable[T] = new Observable[T](wrapped.filter(p)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalaimpl/Observable.scala, +import scala.collection.Seq, +  import scala.collection.Seq, +  def buffer(bufferClosingSelector: () => Observable[Closing]) : Observable[Seq[T]] = {, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(f), +    Observable.jObsOfListToScObsOfSeq(jObs.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  def buffer(count: Int): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(count), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def window(count: Int): Observable[Observable[T]] = {, +    // this line makes the compiler crash (if it's the last line of the method):, +    // Observable.jObsOfJObsToScObsOfScObs(asJava.window(count)), +    , +    // this line gives an error:, +    // "type mismatch; found : rx.Observable[rx.Observable[_$1]] required: rx.Observable[rx.Observable[T]]", +    // Observable.jObsOfJObsToScObsOfScObs(asJava.window(count) : JObservable[JObservable[T]]), +    , +    // workaround with a cast:, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(count).asInstanceOf[JObservable[JObservable[T]]]), +  }, +    new Observable[R](asJava.reduce(initialValue, accumulator)), +    new Observable[R](asJava.scan(initialValue, accumulator)), +  def zipWithIndex: Observable[(T, Int)] = {, +    ???, +  }, +, +  import scala.collection.immutable.Range, +  private[scalaimpl] , +  def jObsOfListToScObsOfSeq[T](jObs: rx.Observable[_ <: java.util.List[T]]): Observable[Seq[T]] = {, +    val oScala1: Observable[java.util.List[T]] = new Observable[java.util.List[T]](jObs), +    oScala1.map((lJava: java.util.List[T]) => lJava.asScala), +  }, +  , +  private[scalaimpl] , +  def jObsOfJObsToScObsOfScObs[T](jObs: rx.Observable[_ <: rx.Observable[_ <: T]]): Observable[Observable[T]] = {, +    val oScala1: Observable[rx.Observable[_ <: T]] = new Observable[rx.Observable[_ <: T]](jObs), +    oScala1.map((oJava: rx.Observable[_ <: T]) => new Observable[T](oJava)), +  }, +  , +    new Observable[T](JObservable.create(func)), +    new Observable[Nothing](JObservable.error(exception)), +    new Observable[T](JObservable.from(args.toIterable.asJava)), +  def apply(range: Range): Observable[Int] = {, +    new Observable[Int](JObservable.from(range.toIterable.asJava)), +  }, +  , +    new Observable[T](JObservable.defer(observable.asJava))]