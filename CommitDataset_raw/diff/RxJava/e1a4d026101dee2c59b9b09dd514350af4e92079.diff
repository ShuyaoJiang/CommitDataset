[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.util._, +   * emitted and replaced with a new buffer when the Observable produced by the specified function produces a [[rx.lang.scala.util.Closing]] object. The function will then, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces a [[rx.lang.scala.util.Closing]] object., +  def buffer(closings: () => Observable[Closing]) : Observable[Seq[T]] = {, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer(f), +, +   * Observable produces a [[rx.lang.scala.util.Opening]] object. Additionally the function argument, +   *            The [[rx.lang.scala.Observable]] which, when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +  def buffer(openings: Observable[Opening], closings: Opening => Observable[Closing]): Observable[Seq[T]] = {, +    val closing: Func1[Opening, _ <: rx.Observable[_ <: Closing]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer(opening, closing), +   * Observable produced by the specified function produces a [[rx.lang.scala.util.Closing]] object. , +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces a [[rx.lang.scala.util.Closing]] object., +  def window(closings: () => Observable[Closing]): Observable[Observable[T]] = {, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window(func), +    val o2 = toScalaObservable[rx.Observable[_]](o1).map((x: rx.Observable[_]) => {, +   * Chunks are created when the specified `openings` Observable produces a [[rx.lang.scala.util.Opening]] object., +   *            The [[rx.lang.scala.Observable]] which when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +  def window(openings: Observable[Opening], closings: Opening => Observable[Closing]) = {, +      asJavaObservable.window(openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +   * When you call `cache`, it does not yet subscribe to the, +   * source Observable. This only happens when `subscribe` is called, +   * the first time on the Observable returned by `cache()`., +   * , +   * Note: You sacrifice the ability to unsubscribe from the origin when you use the, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.util._, +   * emitted and replaced with a new buffer when the Observable produced by the specified function produces a [[rx.lang.scala.util.Closing]] object. The function will then, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces a [[rx.lang.scala.util.Closing]] object., +  def buffer(closings: () => Observable[Closing]) : Observable[Seq[T]] = {, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer(f), +, +   * Observable produces a [[rx.lang.scala.util.Opening]] object. Additionally the function argument, +   *            The [[rx.lang.scala.Observable]] which, when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated buffer, +  def buffer(openings: Observable[Opening], closings: Opening => Observable[Closing]): Observable[Seq[T]] = {, +    val closing: Func1[Opening, _ <: rx.Observable[_ <: Closing]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer(opening, closing), +   * Observable produced by the specified function produces a [[rx.lang.scala.util.Closing]] object. , +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces a [[rx.lang.scala.util.Closing]] object., +  def window(closings: () => Observable[Closing]): Observable[Observable[T]] = {, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window(func), +    val o2 = toScalaObservable[rx.Observable[_]](o1).map((x: rx.Observable[_]) => {, +   * Chunks are created when the specified `openings` Observable produces a [[rx.lang.scala.util.Opening]] object., +   *            The [[rx.lang.scala.Observable]] which when it produces a [[rx.lang.scala.util.Opening]] object, will cause, +   *            When this [[rx.lang.scala.Observable]] produces a [[rx.lang.scala.util.Closing]] object, the associated window, +  def window(openings: Observable[Opening], closings: Opening => Observable[Closing]) = {, +      asJavaObservable.window(openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +   * When you call `cache`, it does not yet subscribe to the, +   * source Observable. This only happens when `subscribe` is called, +   * the first time on the Observable returned by `cache()`., +   * , +   * Note: You sacrifice the ability to unsubscribe from the origin when you use the, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/util/package.scala, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.lang.scala, +, +/**, + * Provides [[Opening]]s, [[Closing]]s, and [[Timestamped]].  , + */, +package object util {, +, +  /**, +   * Tagging interface for objects which can open buffers., +   * @see [[Observable `Observable.buffer(Observable[Opening], Opening => Observable[Closing])`]], +   */, +  type Opening = rx.util.Opening, +, +  /**, +   * Creates an object which can open buffers., +   * @see [[Observable `Observable.buffer(Observable[Opening], Opening => Observable[Closing])`]], +   */, +  def Opening() = rx.util.Openings.create(), +  , +  /**, +   * Tagging interface for objects which can close buffers., +   * @see [[Observable `Observable.buffer(Observable[Opening], Opening => Observable[Closing])`]], +   */, +  type Closing = rx.util.Closing]