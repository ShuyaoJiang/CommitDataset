[+++ b/src/main/java/io/reactivex/Observable.java, +        return (new ObservableAll<T>(this, predicate));, +        return new ObservableAny<T>(this, predicate);, +        return new ObservableBuffer<T, U>(this, count, skip, bufferSupplier);, +        return new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);, +        return new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);, +        return new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);, +        return new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);, +        return new ObservableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);, +++ b/src/main/java/io/reactivex/Observable.java, +        return (new ObservableAll<T>(this, predicate));, +        return new ObservableAny<T>(this, predicate);, +        return new ObservableBuffer<T, U>(this, count, skip, bufferSupplier);, +        return new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);, +        return new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);, +        return new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);, +        return new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);, +        return new ObservableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    public boolean add(Disposable d) {, +                    return true;, +        return false;, +    public boolean addAll(Disposable... ds) {, +                    return true;, +        return false;, +    public boolean remove(Disposable d) {, +        if (delete(d)) {, +            return true;, +        }, +        return false;, +    public boolean delete(Disposable d) {, +            return false;, +                return false;, +                return false;, +        return true;, +++ b/src/main/java/io/reactivex/Observable.java, +        return (new ObservableAll<T>(this, predicate));, +        return new ObservableAny<T>(this, predicate);, +        return new ObservableBuffer<T, U>(this, count, skip, bufferSupplier);, +        return new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);, +        return new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);, +        return new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);, +        return new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);, +        return new ObservableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    public boolean add(Disposable d) {, +                    return true;, +        return false;, +    public boolean addAll(Disposable... ds) {, +                    return true;, +        return false;, +    public boolean remove(Disposable d) {, +        if (delete(d)) {, +            return true;, +        }, +        return false;, +    public boolean delete(Disposable d) {, +            return false;, +                return false;, +                return false;, +        return true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +import io.reactivex.internal.subscribers.flowable.*;, +    final Function<? super T, ? extends U> mapper;, +    public FlowableMap(Publisher<T> source, Function<? super T, ? extends U> mapper) {, +        this.mapper = mapper;, +        if (s instanceof ConditionalSubscriber) {, +            source.subscribe(new MapConditionalSubscriber<T, U>((ConditionalSubscriber<? super U>)s, mapper));, +        } else {, +            source.subscribe(new MapSubscriber<T, U>(s, mapper));, +, +    static final class MapSubscriber<T, U> extends BasicFuseableSubscriber<T, U> {, +        final Function<? super T, ? extends U> mapper;, +, +        public MapSubscriber(Subscriber<? super U> actual, Function<? super T, ? extends U> mapper) {, +            super(actual);, +            this.mapper = mapper;, +        }, +, +            , +            if (sourceMode == ASYNC) {, +                actual.onNext(null);, +                return;, +            }, +            , +            U v;, +            , +                v = nullCheck(mapper.apply(t), "The mapper function returned a null value.");, +            } catch (Throwable ex) {, +                fail(ex);, +            actual.onNext(v);, +, +        public int requestFusion(int mode) {, +            return transitiveBoundaryFusion(mode);, +, +        public U poll() {, +            T t = qs.poll();, +            return t != null ? nullCheck(mapper.apply(t), "The mapper function returned a null value.") : null;, +        }]