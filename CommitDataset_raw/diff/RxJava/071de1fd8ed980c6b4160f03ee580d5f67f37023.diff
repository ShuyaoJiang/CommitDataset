[+++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, +import java.util.*;, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +        Object last = "1";, +        void combine(T value, int index) {, +                // see if either all sources completed, +                empty = c == len , +                        || (value == null && o == null); // or this source completed without any value, +                    if (value != null && f) {, +                    }, +                if (e != 0L) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, +import java.util.*;, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +        Object last = "1";, +        void combine(T value, int index) {, +                // see if either all sources completed, +                empty = c == len , +                        || (value == null && o == null); // or this source completed without any value, +                    if (value != null && f) {, +                    }, +                if (e != 0L) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherZip.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, +import java.util.*;, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +        Object last = "1";, +        void combine(T value, int index) {, +                // see if either all sources completed, +                empty = c == len , +                        || (value == null && o == null); // or this source completed without any value, +                    if (value != null && f) {, +                    }, +                if (e != 0L) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherZip.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +        int pi = calcWrappedOffset(p + 2, m);, +            pi = calcWrappedOffset(p, m);, +            soElement(buffer, pi + 1, second);, +            soElement(buffer, pi, first);, +            pi = calcWrappedOffset(p, m);, +            soElement(newBuffer, pi + 1, second);// StoreStore, +            soElement(newBuffer, pi, first);, +            soElement(buffer, pi, HAS_NEXT); // new buffer is visible after element is, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, +import java.util.*;, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +        Object last = "1";, +        void combine(T value, int index) {, +                // see if either all sources completed, +                empty = c == len , +                        || (value == null && o == null); // or this source completed without any value, +                    if (value != null && f) {, +                    }, +                if (e != 0L) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherZip.java, +                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +        int pi = calcWrappedOffset(p + 2, m);, +            pi = calcWrappedOffset(p, m);, +            soElement(buffer, pi + 1, second);, +            soElement(buffer, pi, first);, +            pi = calcWrappedOffset(p, m);, +            soElement(newBuffer, pi + 1, second);// StoreStore]