[+++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private static final ThreadLocal<Queue<DiscardableAction<?>>> QUEUE = new ThreadLocal<Queue<DiscardableAction<?>>>();, +        enqueue(discardableAction);, +        // since we are executing immediately on this thread we must cause this thread to sleep, +        // TODO right now the 'enqueue' does not take delay into account so if another task is enqueued after this it will , +        // wait behind the sleeping action ... should that be the case or should it be allowed to proceed ahead of the delayed action?, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +    private void enqueue(DiscardableAction<?> action) {, +        Queue<DiscardableAction<?>> queue = QUEUE.get();, +            queue = new LinkedList<DiscardableAction<?>>();, +        queue.add(action);, +                queue.poll().call(this);, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private static final ThreadLocal<Queue<DiscardableAction<?>>> QUEUE = new ThreadLocal<Queue<DiscardableAction<?>>>();, +        enqueue(discardableAction);, +        // since we are executing immediately on this thread we must cause this thread to sleep, +        // TODO right now the 'enqueue' does not take delay into account so if another task is enqueued after this it will , +        // wait behind the sleeping action ... should that be the case or should it be allowed to proceed ahead of the delayed action?, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +    private void enqueue(DiscardableAction<?> action) {, +        Queue<DiscardableAction<?>> queue = QUEUE.get();, +            queue = new LinkedList<DiscardableAction<?>>();, +        queue.add(action);, +                queue.poll().call(this);, +++ b/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private static final ThreadLocal<Queue<DiscardableAction<?>>> QUEUE = new ThreadLocal<Queue<DiscardableAction<?>>>();, +        enqueue(discardableAction);, +        // since we are executing immediately on this thread we must cause this thread to sleep, +        // TODO right now the 'enqueue' does not take delay into account so if another task is enqueued after this it will , +        // wait behind the sleeping action ... should that be the case or should it be allowed to proceed ahead of the delayed action?, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +    private void enqueue(DiscardableAction<?> action) {, +        Queue<DiscardableAction<?>> queue = QUEUE.get();, +            queue = new LinkedList<DiscardableAction<?>>();, +        queue.add(action);, +                queue.poll().call(this);, +++ b/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java, +    public SleepingAction(Func2<Scheduler, T, Subscription> underlying, Scheduler scheduler, long timespan, TimeUnit timeUnit) {, +        this.execTime = scheduler.now() + timeUnit.toMillis(timespan);, +        if (execTime < scheduler.now()) {, +                Thread.sleep(scheduler.now() - execTime);, +            } catch (InterruptedException e) {, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private static final ThreadLocal<Queue<DiscardableAction<?>>> QUEUE = new ThreadLocal<Queue<DiscardableAction<?>>>();, +        enqueue(discardableAction);, +        // since we are executing immediately on this thread we must cause this thread to sleep, +        // TODO right now the 'enqueue' does not take delay into account so if another task is enqueued after this it will , +        // wait behind the sleeping action ... should that be the case or should it be allowed to proceed ahead of the delayed action?, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +    private void enqueue(DiscardableAction<?> action) {, +        Queue<DiscardableAction<?>> queue = QUEUE.get();, +            queue = new LinkedList<DiscardableAction<?>>();, +        queue.add(action);, +                queue.poll().call(this);, +++ b/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java, +        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));, +++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java, +    public SleepingAction(Func2<Scheduler, T, Subscription> underlying, Scheduler scheduler, long timespan, TimeUnit timeUnit) {, +        this.execTime = scheduler.now() + timeUnit.toMillis(timespan);, +        if (execTime < scheduler.now()) {, +                Thread.sleep(scheduler.now() - execTime);, +            } catch (InterruptedException e) {, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import static org.junit.Assert.*;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, +import org.mockito.InOrder;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +        @Test, +        @SuppressWarnings("unchecked"), +        public void testOrdering() throws InterruptedException {, +            Observable<String> obs = Observable.from("one", null, "two", "three", "four");, +, +            Observer<String> observer = mock(Observer.class);, +, +            InOrder inOrder = inOrder(observer);, +, +            final CountDownLatch completedLatch = new CountDownLatch(1);, +            doAnswer(new Answer<Void>() {, +, +                @Override, +                public Void answer(InvocationOnMock invocation) throws Throwable {, +                    completedLatch.countDown();, +                    return null;, +                }, +            }).when(observer).onCompleted();]