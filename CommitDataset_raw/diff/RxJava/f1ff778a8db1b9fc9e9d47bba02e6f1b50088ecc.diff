[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +  "Call onNext on the given observer and return o.", +  (.onNext o value), +  o), +  "Call onCompleted on the given observer and return o.", +  (.onCompleted o), +  o), +  "Call onError on the given observer and return o.", +  (.onError o e), +  o), +, +(defmacro catch-error-value, +  "Experimental, +, +  TODO: Better name, better abstraction., +, +  Evaluate body and return its value.  If an exception e is thrown, inject the, +  given value into the exception's cause and call (on-error error-observer e),, +  returning e., +, +  This is meant to facilitate implementing Observers that call user-supplied code, +  safely. The general pattern is something like:, +, +    (fn [o v], +      (rx/catch-error-value o v, +        (rx/on-next o (some-func v)))), +, +  If (some-func v) throws an exception, it is caught, v is injected into the, +  exception's cause (with OnErrorThrowable/addValueAsLastCause) and, +  (rx/on-error o e) is invoked., +, +  See:, +    rx.exceptions.OnErrorThrowable/addValueAsLastCause, +  ", +  [error-observer value & body], +  `(try, +    ~@body, +    (catch Throwable e#, +      (on-error ~error-observer, +                (rx.exceptions.OnErrorThrowable/addValueAsLastCause e# ~value)), +      e#))), +                                        (catch-error-value o v, +                                          (on-next o (f (swap! n inc) v))))))))], +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +  "Call onNext on the given observer and return o.", +  (.onNext o value), +  o), +  "Call onCompleted on the given observer and return o.", +  (.onCompleted o), +  o), +  "Call onError on the given observer and return o.", +  (.onError o e), +  o), +, +(defmacro catch-error-value, +  "Experimental, +, +  TODO: Better name, better abstraction., +, +  Evaluate body and return its value.  If an exception e is thrown, inject the, +  given value into the exception's cause and call (on-error error-observer e),, +  returning e., +, +  This is meant to facilitate implementing Observers that call user-supplied code, +  safely. The general pattern is something like:, +, +    (fn [o v], +      (rx/catch-error-value o v, +        (rx/on-next o (some-func v)))), +, +  If (some-func v) throws an exception, it is caught, v is injected into the, +  exception's cause (with OnErrorThrowable/addValueAsLastCause) and, +  (rx/on-error o e) is invoked., +, +  See:, +    rx.exceptions.OnErrorThrowable/addValueAsLastCause, +  ", +  [error-observer value & body], +  `(try, +    ~@body, +    (catch Throwable e#, +      (on-error ~error-observer, +                (rx.exceptions.OnErrorThrowable/addValueAsLastCause e# ~value)), +      e#))), +                                        (catch-error-value o v, +                                          (on-next o (f (swap! n inc) v))))))))], +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +(deftest test-on-next, +  (testing "calls onNext", +    (let [called (atom []), +          o (reify rx.Observer (onNext [this value] (swap! called conj value)))], +      (is (identical? o (rx/on-next o 1))), +      (is (= [1] @called))))), +, +(deftest test-on-completed, +  (testing "calls onCompleted", +    (let [called (atom 0), +          o (reify rx.Observer (onCompleted [this] (swap! called inc)))], +      (is (identical? o (rx/on-completed o))), +      (is (= 1 @called)))))]