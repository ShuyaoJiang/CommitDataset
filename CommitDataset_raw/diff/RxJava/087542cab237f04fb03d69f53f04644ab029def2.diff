[+++ b/src/main/java/io/reactivex/Observable.java, +        if (onSubscribe instanceof PublisherScalarSource) {, +            PublisherScalarSource<T> scalar = (PublisherScalarSource<T>) onSubscribe;, +            return create(scalar.flatMap(mapper));, +        }, +        Objects.requireNonNull(scheduler);, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return lift(new OperatorObserveOn<>(scheduler, delayError, bufferSize));, +        return subscribeOn(scheduler, true);, +    }, +    , +    public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {, +        Objects.requireNonNull(scheduler);, +        return create(new PublisherSubscribeOn<>(this, scheduler, requestOn));, +        Objects.requireNonNull(scheduler);, +        return lift(new OperatorUnsubscribeOn<>(scheduler));, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +++ b/src/main/java/io/reactivex/Observable.java, +        if (onSubscribe instanceof PublisherScalarSource) {, +            PublisherScalarSource<T> scalar = (PublisherScalarSource<T>) onSubscribe;, +            return create(scalar.flatMap(mapper));, +        }, +        Objects.requireNonNull(scheduler);, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return lift(new OperatorObserveOn<>(scheduler, delayError, bufferSize));, +        return subscribeOn(scheduler, true);, +    }, +    , +    public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {, +        Objects.requireNonNull(scheduler);, +        return create(new PublisherSubscribeOn<>(this, scheduler, requestOn));, +        Objects.requireNonNull(scheduler);, +        return lift(new OperatorUnsubscribeOn<>(scheduler));, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +        Objects.requireNonNull(selector);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import java.util.Queue;, +import java.util.concurrent.atomic.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Observable.Operator;, +import io.reactivex.Scheduler;, +import io.reactivex.internal.queue.*;, +import io.reactivex.internal.schedulers.TrampolineScheduler;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +, +public final class OperatorObserveOn<T> implements Operator<T, T> {, +    final Scheduler scheduler;, +    final boolean delayError;, +    final int bufferSize;, +    public OperatorObserveOn(Scheduler scheduler, boolean delayError, int bufferSize) {, +        this.scheduler = scheduler;, +        this.delayError = delayError;, +        this.bufferSize = bufferSize;, +    }, +    , +    @Override, +    public Subscriber<? super T> apply(Subscriber<? super T> t) {, +        if (scheduler instanceof TrampolineScheduler) {, +            return t;, +        }, +        , +        Scheduler.Worker w = scheduler.createWorker();, +        , +        return new ObserveOnSubscriber<>(t, w, delayError, bufferSize);, +    }, +    , +    /**, +     * Pads the base atomic integer used for wip counting., +     */, +    static class Padding0 extends AtomicInteger {, +        /** */, +        private static final long serialVersionUID = 3172843496016154809L;, +        ]