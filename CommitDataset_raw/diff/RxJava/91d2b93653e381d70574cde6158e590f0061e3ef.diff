[+++ b/src/main/java/io/reactivex/Scheduler.java, +     * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where, +++ b/src/main/java/io/reactivex/Scheduler.java, +     * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where, +++ b/src/main/java/io/reactivex/internal/schedulers/SchedulerWhen.java, + * When the {@link io.reactivex.Scheduler.Worker Worker} is unsubscribed the {@link Completable} emits an, + * the number of concurrent {@link io.reactivex.Scheduler.Worker Worker}s rather than individual actions., + * Generally each {@link Observable} uses its own {@link io.reactivex.Scheduler.Worker Worker}. This means, + * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where, +    abstract static class ScheduledAction extends AtomicReference<Disposable>implements Disposable {, +        ScheduledAction() {, +        void call(Worker actualWorker, CompletableObserver actionCompletable) {, +        ImmediateAction(Runnable action) {, +        DelayedAction(Runnable action, long delayTime, TimeUnit unit) {, +        OnCompletedAction(Runnable action, CompletableObserver actionCompletable) {]