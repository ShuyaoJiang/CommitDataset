[+++ b/src/main/java/rx/internal/operators/OperatorAny.java, +import rx.exceptions.Exceptions;, +import rx.exceptions.OnErrorThrowable;, +import rx.internal.producers.SingleDelayedProducer;, +        final SingleDelayedProducer<Boolean> producer = new SingleDelayedProducer<Boolean>(child);, +                boolean result;, +                try {, +                    result = predicate.call(t);, +                } catch (Throwable e) {, +                    Exceptions.throwIfFatal(e);, +                    onError(OnErrorThrowable.addValueAsLastCause(e, t));, +                    return;, +                }, +                    producer.setValue(!returnOnEmpty);, +                // note that don't need to request more of upstream because this subscriber , +                // defaults to requesting Long.MAX_VALUE, +                        producer.setValue(false);, +                        producer.setValue(returnOnEmpty);, +        child.setProducer(producer);, +++ b/src/main/java/rx/internal/operators/OperatorAny.java, +import rx.exceptions.Exceptions;, +import rx.exceptions.OnErrorThrowable;, +import rx.internal.producers.SingleDelayedProducer;, +        final SingleDelayedProducer<Boolean> producer = new SingleDelayedProducer<Boolean>(child);, +                boolean result;, +                try {, +                    result = predicate.call(t);, +                } catch (Throwable e) {, +                    Exceptions.throwIfFatal(e);, +                    onError(OnErrorThrowable.addValueAsLastCause(e, t));, +                    return;, +                }, +                    producer.setValue(!returnOnEmpty);, +                // note that don't need to request more of upstream because this subscriber , +                // defaults to requesting Long.MAX_VALUE, +                        producer.setValue(false);, +                        producer.setValue(returnOnEmpty);, +        child.setProducer(producer);, +++ b/src/test/java/rx/internal/operators/OperatorAnyTest.java, +import java.util.List;, +import rx.observers.TestSubscriber;, +    , +    @Test, +    public void testBackpressureIfNoneRequestedNoneShouldBeDelivered() {, +        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0);, +        Observable.just(1).exists(new Func1<Object, Boolean>() {, +            @Override, +            public Boolean call(Object t1) {, +                return true;, +            }, +        }).subscribe(ts);, +        ts.assertNoValues();, +        ts.assertNoErrors();, +        ts.assertNotCompleted();, +    }, +    , +    @Test, +    public void testBackpressureIfOneRequestedOneShouldBeDelivered() {, +        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(1);, +        Observable.just(1).exists(new Func1<Object, Boolean>() {, +            @Override, +            public Boolean call(Object object) {, +                return true;, +            }, +        }).subscribe(ts);, +        ts.assertTerminalEvent();, +        ts.assertNoErrors();, +        ts.assertCompleted();, +        ts.assertValue(true);, +    }, +    , +    @Test, +    public void testPredicateThrowsExceptionAndValueInCauseMessage() {, +        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0);, +        final IllegalArgumentException ex = new IllegalArgumentException();, +        Observable.just("Boo!").exists(new Func1<Object, Boolean>() {, +            @Override, +            public Boolean call(Object object) {, +                throw ex;, +            }, +        }).subscribe(ts);, +        ts.assertTerminalEvent();, +        ts.assertNoValues();, +        ts.assertNotCompleted();, +        List<Throwable> errors = ts.getOnErrorEvents();, +        assertEquals(1, errors.size());, +        assertEquals(ex, errors.get(0));, +        assertTrue(ex.getCause().getMessage().contains("Boo!"));, +    }]