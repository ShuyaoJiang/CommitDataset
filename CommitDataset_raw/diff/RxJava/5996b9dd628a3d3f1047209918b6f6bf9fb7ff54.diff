[+++ b/rxjava-core/src/main/java/rx/Observable.java, +                return OperatorReplay.replayBuffered(bufferSize);, +                return OperatorReplay.replayWindowed(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(OperatorReplay.<T> replayBuffered(bufferSize), scheduler);, +                return OperatorReplay.replayWindowed(time, unit, -1, scheduler);, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayBuffered(bufferSize));, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayWindowed(time, unit, bufferSize, scheduler));, +                        OperatorReplay.<T> replayBuffered(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayWindowed(time, unit, -1, scheduler));, +     * Converts an Observable into a {@link BlockingObservable} (an Observable with blocking operators)., +     *, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +     * @return a {@code BlockingObservable} version of this Observable, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">RxJava Wiki: Blocking Observable Observers</a>, +     */, +    public final BlockingObservable<T> toBlocking() {, +        return toBlockingObservable();, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +                return OperatorReplay.replayBuffered(bufferSize);, +                return OperatorReplay.replayWindowed(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(OperatorReplay.<T> replayBuffered(bufferSize), scheduler);, +                return OperatorReplay.replayWindowed(time, unit, -1, scheduler);, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayBuffered(bufferSize));, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayWindowed(time, unit, bufferSize, scheduler));, +                        OperatorReplay.<T> replayBuffered(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, OperatorReplay.<T> replayWindowed(time, unit, -1, scheduler));, +     * Converts an Observable into a {@link BlockingObservable} (an Observable with blocking operators)., +     *, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +     * @return a {@code BlockingObservable} version of this Observable, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">RxJava Wiki: Blocking Observable Observers</a>, +     */, +    public final BlockingObservable<T> toBlocking() {, +        return toBlockingObservable();, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperatorReplay.java, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import rx.Subscription;, +import rx.functions.Action0;, +import rx.functions.Func1;, +import rx.functions.Functions;, +import rx.schedulers.Timestamped;, +     * Create a CustomReplaySubject with the given buffer size., +     * , +     * @param <T> the element type, +     * @param bufferSize the maximum number of items to keep in the buffer, +     * @return the created subject, +     */, +    public static <T> Subject<T, T> replayBuffered(int bufferSize) {, +        return CustomReplaySubject.create(bufferSize);, +    }, +, +    /**, +     * Create a CustomReplaySubject with the given time window length, +     * and optional buffer size., +     * , +     * @param <T>, +     *            the source and return type, +     * @param time, +     *            the length of the time window, +     * @param unit, +     *            the unit of the time window length, +     * @param bufferSize, +     *            the buffer size if >= 0, otherwise, the buffer will be unlimited, +     * @param scheduler, +     *            the scheduler from where the current time is retrieved. The, +     *            observers will not observe on this scheduler., +     * @return a Subject with the required replay behavior, +     */, +    public static <T> Subject<T, T> replayWindowed(long time, TimeUnit unit, int bufferSize, final Scheduler scheduler) {, +        final long ms = unit.toMillis(time);, +        if (ms <= 0) {, +            throw new IllegalArgumentException("The time window is less than 1 millisecond!");, +        }, +        Func1<T, Timestamped<T>> timestamp = new Func1<T, Timestamped<T>>() {, +            @Override, +            public Timestamped<T> call(T t1) {, +                return new Timestamped<T>(scheduler.now(), t1);, +            }, +        };, +        Func1<Timestamped<T>, T> untimestamp = new Func1<Timestamped<T>, T>() {, +            @Override, +            public T call(Timestamped<T> t1) {, +                return t1.getValue();, +            }]