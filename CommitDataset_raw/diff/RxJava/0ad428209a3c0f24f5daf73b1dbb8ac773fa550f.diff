[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import scala.concurrent.duration.{Duration, TimeUnit}, +  import rx.util.functions._, +    val f: Func0[_ <: rx.Observable[_ <: Closing]] = bufferClosingSelector().asJava, +  def buffer(bufferOpenings: Observable[Opening], bufferClosingSelector: Opening => Observable[Closing]): Observable[Seq[T]] = {, +    val opening: rx.Observable[_ <: Opening] = bufferOpenings.asJava , +    val closing: Func1[Opening, _ <: rx.Observable[_ <: Closing]] = (o: Opening) => bufferClosingSelector(o).asJava, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(opening, closing), +    Observable.jObsOfListToScObsOfSeq(jObs.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  def buffer(count: Int, skip: Int): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(count, skip), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def buffer(timespan: Duration): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(timespan.length, timespan.unit), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def buffer(timespan: Duration, scheduler: Scheduler): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(timespan.length, timespan.unit, scheduler), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  } , +  def buffer(timespan: Duration, count: Int): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(timespan.length, timespan.unit, count), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def buffer(timespan: Duration, count: Int, scheduler: Scheduler): Observable[Seq[T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(timespan.length, timespan.unit, count, scheduler), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  def buffer(timespan: Duration, timeshift: Duration): Observable[Seq[T]] = {, +    val span: Long = timespan.length, +    val shift: Long = timespan.unit.convert(timeshift.length, timeshift.unit), +    val unit: TimeUnit = timespan.unit, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(span, shift, unit), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  } , +  def buffer(timespan: Duration, timeshift: Duration, scheduler: Scheduler): Observable[Seq[T]] = {, +    val span: Long = timespan.length, +    val shift: Long = timespan.unit.convert(timeshift.length, timeshift.unit), +    val unit: TimeUnit = timespan.unit, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(span, shift, unit, scheduler), +    Observable.jObsOfListToScObsOfSeq(oJava.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  } , +    val func : Func0[_ <: rx.Observable[_ <: Closing]] = closingSelector().asJava, +  def window(windowOpenings: Observable[Opening], closingSelector: Opening => Observable[Closing]) = {, +    Observable.jObsOfJObsToScObsOfScObs(, +        asJava.window(windowOpenings.asJava, (op: Opening) => closingSelector(op).asJava)), +             : Observable[Observable[T]] // SI-7818, +  } , +  def window(count: Int, skip: Int): Observable[Observable[T]] = {, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(count, skip)), +        : Observable[Observable[T]] // SI-7818, +  }, +  def window(timespan: Duration): Observable[Observable[T]] = {, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(timespan.length, timespan.unit)), +        : Observable[Observable[T]] // SI-7818, +  } , +  def window(timespan: Duration, scheduler: Scheduler): Observable[Observable[T]] = {, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(timespan.length, timespan.unit, scheduler)), +        : Observable[Observable[T]] // SI-7818, +  } , +  def window(timespan: Duration, count: Int): Observable[Observable[T]] = {, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(timespan.length, timespan.unit, count)), +        : Observable[Observable[T]] // SI-7818, +  } , +  def window(timespan: Duration, count: Int, scheduler: Scheduler): Observable[Observable[T]] = {, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(timespan.length, timespan.unit, count, scheduler)), +        : Observable[Observable[T]] // SI-7818, +  } , +  def window(timespan: Duration, timeshift: Duration): Observable[Observable[T]] = {, +    val span: Long = timespan.length, +    val shift: Long = timespan.unit.convert(timeshift.length, timeshift.unit), +    val unit: TimeUnit = timespan.unit, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(span, shift, unit)), +        : Observable[Observable[T]] // SI-7818, +  } , +  def window(timespan: Duration, timeshift: Duration, scheduler: Scheduler): Observable[Observable[T]] = {, +    val span: Long = timespan.length, +    val shift: Long = timespan.unit.convert(timeshift.length, timeshift.unit), +    val unit: TimeUnit = timespan.unit, +    Observable.jObsOfJObsToScObsOfScObs(asJava.window(span, shift, unit, scheduler)), +        : Observable[Observable[T]] // SI-7818, +  } , +    val f: Func1[Throwable, rx.Observable[_ <: U]] = (t: Throwable) => resumeFunction(t).asJava, +    val f2 = f.asInstanceOf[Func1[Throwable, rx.Observable[Nothing]]], +    val f1: Func1[Throwable, _ <: U] = resumeFunction, +    val f2 = f1.asInstanceOf[Func1[Throwable, Nothing]], +    val func: Func2[_ >: U, _ >: U, _ <: U] = f, +    val func2 = func.asInstanceOf[Func2[T, T, T]], +  /* TODO zipWithIndex once it's in RxJava, +  */, +  def toSeq: Observable[Seq[T]] = {, +    Observable.jObsOfListToScObsOfSeq(asJava.toList()), +        : Observable[Seq[T]] // SI-7818, +  // corresponds to Java's method, +  // public Observable<List<T>> toList() {, +  /* TODO make a Scala GroupedObservable and groupBy, +  /* TODO , +  // TODO we have merge and concat (++) as binary instance methods, but do we also need them as, +  // static methods with arity > 2?]