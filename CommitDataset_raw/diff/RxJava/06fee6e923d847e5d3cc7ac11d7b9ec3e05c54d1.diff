[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def flattenSomeExample() {, +  @Test def flattenExample() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten.toBlocking.foreach(println(_)), +  }, +, +  @Test def flattenExample2() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten(2).toBlocking.foreach(println(_)), +  }, +, +  @Test def groupByUntilExample2() {, +    val numbers = Observable.interval(250 millis).take(14), +    val grouped = numbers.groupByUntil[Long, Long](x => x % 2, x => x * 10, {case (key, obs) => Observable.interval(2 seconds)}), +    val sequenced = (grouped.map({ case (key, obs) => obs.toSeq })).flatten, +    sequenced.toBlocking.foreach(x => println(s"Emitted group: $x")), +  }, +, +  @Test def combineLatestExample2() {, +    val firstCounter = Observable.interval(250 millis), +    val secondCounter = Observable.interval(550 millis), +    val thirdCounter = Observable.interval(850 millis), +    val sources = Seq(firstCounter, secondCounter, thirdCounter), +    val combinedCounter = Observable.combineLatest(sources, (items: Seq[Long]) => items.toList).take(10), +, +    combinedCounter subscribe {x => println(s"Emitted group: $x")}, +    waitFor(combinedCounter), +  }, +, +  @Test def toMultimapExample1(): Unit = {, +    val o : Observable[String] = List("alice", "bob", "carol", "allen", "clarke").toObservable, +    val keySelector = (s: String) => s.head, +    val m = o.toMultimap(keySelector), +    println(m.toBlocking.single.mapValues(_.toList)), +  }, +, +  @Test def toMultimapExample2(): Unit = {, +    val o : Observable[String] = List("alice", "bob", "carol", "allen", "clarke").toObservable, +    val keySelector = (s: String) => s.head, +    val valueSelector = (s: String) => s.tail, +    val m = o.toMultimap(keySelector, valueSelector), +    println(m.toBlocking.single.mapValues(_.toList)), +  }, +, +  @Test def toMultimapExample3(): Unit = {, +    val o : Observable[String] = List("alice", "bob", "carol", "allen", "clarke").toObservable, +    val keySelector = (s: String) => s.head, +    val valueSelector = (s: String) => s.tail, +    val mapFactory = () => Map('d' -> List("oug")), +    val m = o.toMultimap(keySelector, valueSelector, mapFactory), +    println(m.toBlocking.single.mapValues(_.toList)), +  }, +, +  @Test def toMultimapExample4(): Unit = {, +    val o : Observable[String] = List("alice", "bob", "carol", "allen", "clarke").toObservable, +    val keySelector = (s: String) => s.head, +    val valueSelector = (s: String) => s.tail, +    val mapFactory = () => Map('d' -> List("oug")), +    val valueFactor = (k: Char) => List[String](), +    val m = o.toMultimap(keySelector, valueSelector, mapFactory, valueFactor), +    println(m.toBlocking.single), +  }, +, +  @Test def retryExample3(): Unit = {, +    var isFirst = true, +    val o = Observable {, +      (subscriber: Subscriber[String]) =>, +        if (isFirst) {, +          subscriber.onNext("alice"), +          subscriber.onError(new IOException("Oops")), +          isFirst = false, +        }, +        else {, +          subscriber.onNext("bob"), +          subscriber.onError(new RuntimeException("Oops")), +        }, +    }, +    o.retry {, +      (times, e) => e match {, +        case e: IOException => times <= 3, +        case _ => false, +      }, +    }.subscribe(s => println(s), e => e.printStackTrace()), +  }, +, +, +  @Test def onErrorResumeNextExample() {, +    val o = Observable {, +      (subscriber: Subscriber[Int]) =>, +        subscriber.onNext(1), +        subscriber.onNext(2)]