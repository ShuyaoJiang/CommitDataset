[+++ b/build.gradle, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                     * We need to read terminalEvent before checking the queue for emptyness because, +                     * all enqueue happens before setting the terminal event., +                     * If it were the other way around, when the emission is paused between, +                     * checking isEmpty and checking terminalEvent, some other thread might, +                     * have produced elements and set the terminalEvent and we'd quit emitting, +                     * prematurely., +                     */, +                    Object term = terminalEvent;, +                    /*, +                    if (checkTerminated(term, empty)) {, +                            term = terminalEvent;, +                            if (checkTerminated(term, v == null)) {, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                     * We need to read terminalEvent before checking the queue for emptyness because, +                     * all enqueue happens before setting the terminal event., +                     * If it were the other way around, when the emission is paused between, +                     * checking isEmpty and checking terminalEvent, some other thread might, +                     * have produced elements and set the terminalEvent and we'd quit emitting, +                     * prematurely., +                     */, +                    Object term = terminalEvent;, +                    /*, +                    if (checkTerminated(term, empty)) {, +                            term = terminalEvent;, +                            if (checkTerminated(term, v == null)) {, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java, +import java.util.*;, +import rx.*;, +import rx.Observable;, +import rx.Observer;, +            child.setProducer(new Producer() {, +                @Override, +                public void request(long n) {, +                    if (n > 0) {, +                        long u = n * size;, +                        if (((u >>> 31) != 0) && (u / n != size)) {, +                            u = Long.MAX_VALUE;, +                        }, +                        requestMore(u);, +                    }, +                }, +            });, +        void requestMore(long n) {, +            request(n);, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables , +     *  but each of them will emit at most {@code count} elements.</dd>, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                     * We need to read terminalEvent before checking the queue for emptyness because, +                     * all enqueue happens before setting the terminal event., +                     * If it were the other way around, when the emission is paused between, +                     * checking isEmpty and checking terminalEvent, some other thread might, +                     * have produced elements and set the terminalEvent and we'd quit emitting, +                     * prematurely., +                     */, +                    Object term = terminalEvent;, +                    /*, +                    if (checkTerminated(term, empty)) {, +                            term = terminalEvent;, +                            if (checkTerminated(term, v == null)) {, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java, +import java.util.*;, +import rx.*;, +import rx.Observable;, +import rx.Observer;, +            child.setProducer(new Producer() {, +                @Override, +                public void request(long n) {, +                    if (n > 0) {, +                        long u = n * size;, +                        if (((u >>> 31) != 0) && (u / n != size)) {, +                            u = Long.MAX_VALUE;, +                        }, +                        requestMore(u);, +                    }, +                }, +            });]