[+++ b/build.gradle, +    group = "com.netflix.rxjava", +++ b/build.gradle, +    group = "com.netflix.rxjava", +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map(f), +        override def subscribe(observer: Observer[String]): Subscription = {, +        val merged = Observable.merge(observable), +        val characters = Observable.zip(numbers, colors, names, Character.apply _), +        val characters = Observable.zip(numbers, colors, names, isLeader, Character.apply _), +        numbers.map((x: Int) => x * x).subscribe((squareVal: Int) => {, +    /**, +     * Both testTake and testTakeWhileWithIndex exposed a bug with unsubscribes not properly propagating., +     * observable.take(2) produces onNext(first), onNext(second), and 4 onCompleteds, +     * it should produce onNext(first), onNext(second), and 1 onCompleted, +     *, +     * Switching to Observable.create(OperationTake.take(observable, 2)) works as expected, +     */, +        import rx.operators._, +        , +        val took = Observable.create(OperationTake.take(observable, 2)), +    /*@Test def testTakeWhileWithIndex {, +     val observable = Observable.from(1, 3, 5, 6, 7, 9, 11, 12, 13, 15, 17), +     val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx > 4), +     assertSubscribeReceives(took)(9, 11), +     }*/, +        val filteredObservable = for {, +++ b/build.gradle, +    group = "com.netflix.rxjava", +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map(f), +        override def subscribe(observer: Observer[String]): Subscription = {, +        val merged = Observable.merge(observable), +        val characters = Observable.zip(numbers, colors, names, Character.apply _), +        val characters = Observable.zip(numbers, colors, names, isLeader, Character.apply _), +        numbers.map((x: Int) => x * x).subscribe((squareVal: Int) => {, +    /**, +     * Both testTake and testTakeWhileWithIndex exposed a bug with unsubscribes not properly propagating., +     * observable.take(2) produces onNext(first), onNext(second), and 4 onCompleteds, +     * it should produce onNext(first), onNext(second), and 1 onCompleted, +     *, +     * Switching to Observable.create(OperationTake.take(observable, 2)) works as expected, +     */, +        import rx.operators._, +        , +        val took = Observable.create(OperationTake.take(observable, 2)), +    /*@Test def testTakeWhileWithIndex {, +     val observable = Observable.from(1, 3, 5, 6, 7, 9, 11, 12, 13, 15, 17), +     val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx > 4), +     assertSubscribeReceives(took)(9, 11), +     }*/, +        val filteredObservable = for {, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {, +++ b/build.gradle, +    group = "com.netflix.rxjava", +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map(f), +        override def subscribe(observer: Observer[String]): Subscription = {, +        val merged = Observable.merge(observable), +        val characters = Observable.zip(numbers, colors, names, Character.apply _), +        val characters = Observable.zip(numbers, colors, names, isLeader, Character.apply _), +        numbers.map((x: Int) => x * x).subscribe((squareVal: Int) => {, +    /**, +     * Both testTake and testTakeWhileWithIndex exposed a bug with unsubscribes not properly propagating., +     * observable.take(2) produces onNext(first), onNext(second), and 4 onCompleteds, +     * it should produce onNext(first), onNext(second), and 1 onCompleted, +     *, +     * Switching to Observable.create(OperationTake.take(observable, 2)) works as expected, +     */, +        import rx.operators._, +        , +        val took = Observable.create(OperationTake.take(observable, 2)), +    /*@Test def testTakeWhileWithIndex {, +     val observable = Observable.from(1, 3, 5, 6, 7, 9, 11, 12, 13, 15, 17), +     val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx > 4), +     assertSubscribeReceives(took)(9, 11), +     }*/, +        val filteredObservable = for {, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action, long dueTime, TimeUnit unit) {, +    public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit) {, +++ b/build.gradle, +    group = "com.netflix.rxjava", +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map(f), +        override def subscribe(observer: Observer[String]): Subscription = {, +        val merged = Observable.merge(observable), +        val characters = Observable.zip(numbers, colors, names, Character.apply _), +        val characters = Observable.zip(numbers, colors, names, isLeader, Character.apply _), +        numbers.map((x: Int) => x * x).subscribe((squareVal: Int) => {, +    /**, +     * Both testTake and testTakeWhileWithIndex exposed a bug with unsubscribes not properly propagating., +     * observable.take(2) produces onNext(first), onNext(second), and 4 onCompleteds, +     * it should produce onNext(first), onNext(second), and 1 onCompleted]