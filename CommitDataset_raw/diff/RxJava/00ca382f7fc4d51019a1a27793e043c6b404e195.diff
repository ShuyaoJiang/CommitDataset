[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/AsyncTest.java, +import static org.mockito.Matchers.*;, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/AsyncTest.java, +import static org.mockito.Matchers.*;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationZip;, +     * <em>Note:</em> Use {@link #create(OnSubscribe)} to create an Observable, instead of this, +     * @param f, +     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called, +     * Returns an Observable that will execute the specified function when a {@link Subscriber}, +     * subscribes to it., +     * invoke the Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError},, +     * and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * A well-formed Observable must invoke either the Subscriber's {@code onCompleted} method, +     * @param f, +     *            a function that accepts an {@code Subscriber<T>}, and invokes its {@code onNext},, +     *            {@code onError}, and {@code onCompleted} methods as appropriate, +     * @return an Observable that, when a {@link Subscriber} subscribes to it, will execute the, +    /**, +     * , +     */, +    /**, +     * , +     */, +    /**, +     * , +     */, +     * observes is determined by the factory function., +     * @deprecated Use {@link #from(T)}, +    @Deprecated, +        return from(Arrays.asList((value)));, +        return create(OperationZip.zip(ws, zipFunction));, +        return ws.toList().mergeMap(new Func1<List<? extends Observable<?>>, Observable<? extends R>>() {, +            public final Observable<R> call(List<? extends Observable<?>> wsList) {, +                return create(OperationZip.zip(wsList, zipFunction));, +        });, +    public final static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, o6, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, o6, o7, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, o6, o7, o8, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, o6, o7, o8, o9, zipFunction));, +     * subscribe/unsubscribe behavior of all the {@link Subscriber}s., +     * happens when {@code subscribe} is called the first time on the Observable returned by, +     * {@code cache()}., +     *                             <!-- IS THIS NOTE STILL VALID??? -->, +     * <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the, +     * {@code cache()} Observer so be careful not to use this Observer on Observables that emit an, +        return create(OperationZip.zipIterable(this, other, zipFunction));, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/AsyncTest.java, +import static org.mockito.Matchers.*;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationZip;, +     * <em>Note:</em> Use {@link #create(OnSubscribe)} to create an Observable, instead of this, +     * @param f, +     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called, +     * Returns an Observable that will execute the specified function when a {@link Subscriber}, +     * subscribes to it., +     * invoke the Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError},, +     * and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * A well-formed Observable must invoke either the Subscriber's {@code onCompleted} method, +     * @param f, +     *            a function that accepts an {@code Subscriber<T>}, and invokes its {@code onNext},, +     *            {@code onError}, and {@code onCompleted} methods as appropriate, +     * @return an Observable that, when a {@link Subscriber} subscribes to it, will execute the, +    /**, +     * , +     */, +    /**, +     * , +     */, +    /**, +     * , +     */, +     * observes is determined by the factory function., +     * @deprecated Use {@link #from(T)}, +    @Deprecated, +        return from(Arrays.asList((value)));, +        return create(OperationZip.zip(ws, zipFunction));, +        return ws.toList().mergeMap(new Func1<List<? extends Observable<?>>, Observable<? extends R>>() {, +            public final Observable<R> call(List<? extends Observable<?>> wsList) {, +                return create(OperationZip.zip(wsList, zipFunction));, +        });, +    public final static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return create(OperationZip.zip(o1, o2, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, zipFunction));, +        return create(OperationZip.zip(o1, o2, o3, o4, o5, zipFunction));]