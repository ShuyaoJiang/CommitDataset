[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases such as scheduling work on a computer cluster., +  def degreeOfParallelism: Int =  asJavaScheduler.degreeOfParallelism, +   * Schedules a cancelable action to be executed in delayTime., +  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =, +        override def call(): Unit = action(), +      delayTime.length,, +      delayTime.unit), +   * Schedules a cancelable action to be executed immediately., +  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(, +      override def call(): Unit = action(), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases such as scheduling work on a computer cluster., +  def degreeOfParallelism: Int =  asJavaScheduler.degreeOfParallelism, +   * Schedules a cancelable action to be executed in delayTime., +  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =, +        override def call(): Unit = action(), +      delayTime.length,, +      delayTime.unit), +   * Schedules a cancelable action to be executed immediately., +  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(, +      override def call(): Unit = action(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +   * {@link Scheduler} intended for computational work., +   * Do not perform IO-bound work on this scheduler. Use {@link IOScheduler()} instead., +   * @return { @link Scheduler} for computation-bound work., +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases such as scheduling work on a computer cluster., +  def degreeOfParallelism: Int =  asJavaScheduler.degreeOfParallelism, +   * Schedules a cancelable action to be executed in delayTime., +  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =, +        override def call(): Unit = action(), +      delayTime.length,, +      delayTime.unit), +   * Schedules a cancelable action to be executed immediately., +  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(, +      override def call(): Unit = action(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +   * {@link Scheduler} intended for computational work., +   * Do not perform IO-bound work on this scheduler. Use {@link IOScheduler()} instead., +   * @return { @link Scheduler} for computation-bound work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/IOScheduler.scala, +   * {@link Scheduler} intended for IO-bound work., +   * The implementation is backed by an {@link Executor} thread-pool that will grow as needed., +   * Do not perform computational work on this scheduler. Use {@link ComputationScheduler()} instead., +   * @return { @link ExecutorScheduler} for IO-bound work., +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases such as scheduling work on a computer cluster., +  def degreeOfParallelism: Int =  asJavaScheduler.degreeOfParallelism, +   * Schedules a cancelable action to be executed in delayTime., +  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =, +        override def call(): Unit = action(), +      delayTime.length,, +      delayTime.unit), +   * Schedules a cancelable action to be executed immediately., +  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(, +      override def call(): Unit = action(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +   * {@link Scheduler} intended for computational work., +   * Do not perform IO-bound work on this scheduler. Use {@link IOScheduler()} instead., +   * @return { @link Scheduler} for computation-bound work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/IOScheduler.scala, +   * {@link Scheduler} intended for IO-bound work., +   * The implementation is backed by an {@link Executor} thread-pool that will grow as needed., +   * Do not perform computational work on this scheduler. Use {@link ComputationScheduler()} instead., +   * @return { @link ExecutorScheduler} for IO-bound work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/NewThreadScheduler.scala, +   * Returns a [[rx.lang.scala.Scheduler]] that creates a new {@link Thread} for each unit of work., +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases such as scheduling work on a computer cluster., +  def degreeOfParallelism: Int =  asJavaScheduler.degreeOfParallelism, +   * Schedules a cancelable action to be executed in delayTime., +  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =, +        override def call(): Unit = action(), +      delayTime.length,, +      delayTime.unit), +   * Schedules a cancelable action to be executed immediately., +  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(, +      override def call(): Unit = action(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +   * {@link Scheduler} intended for computational work., +   * Do not perform IO-bound work on this scheduler. Use {@link IOScheduler()} instead., +   * @return { @link Scheduler} for computation-bound work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/IOScheduler.scala, +   * {@link Scheduler} intended for IO-bound work., +   * The implementation is backed by an {@link Executor} thread-pool that will grow as needed., +   * Do not perform computational work on this scheduler. Use {@link ComputationScheduler()} instead., +   * @return { @link ExecutorScheduler} for IO-bound work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/NewThreadScheduler.scala, +   * Returns a [[rx.lang.scala.Scheduler]] that creates a new {@link Thread} for each unit of work., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/TrampolineScheduler.scala, +   * {@link Scheduler} that queues work on the current thread to be executed after the current work completes., +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala]