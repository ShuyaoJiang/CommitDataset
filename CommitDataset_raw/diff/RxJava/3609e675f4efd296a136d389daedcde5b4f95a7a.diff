[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def exampleWithReplay2() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(3), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the 3 buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay3() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(300 millis), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay4() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(2, 300 millis), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay5() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay[Long, Long]((o: Observable[Long]) => o.map(_ * 2)), +    sharedNumbers.subscribe(n => println(s"subscriber gets $n")), +    waitFor(sharedNumbers), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def exampleWithReplay2() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(3), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the 3 buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay3() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(300 millis), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay4() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay(2, 300 millis), +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    sharedNumbers.connect, +    // subscriber 2 subscribes later but only gets the buffered numbers and the following numbers, +    Thread.sleep(700), +    sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")), +    waitFor(sharedNumbers), +  }, +, +  @Test def exampleWithReplay5() {, +    val numbers = Observable.interval(100 millis).take(10), +    val sharedNumbers = numbers.replay[Long, Long]((o: Observable[Long]) => o.map(_ * 2)), +    sharedNumbers.subscribe(n => println(s"subscriber gets $n")), +    waitFor(sharedNumbers), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits items that are the results of invoking a specified selector on the items, +   * emitted by a `ConnectableObservable` that shares a single subscription to the source Observable., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.f.png">, +   *, +   * @param selector the selector function, which can use the multicasted sequence as many times as needed, without, +   *                 causing multiple subscriptions to the Observable, +   * @return an Observable that emits items that are the results of invoking the selector on a `ConnectableObservable`, +   *         that shares a single subscription to the source Observable, +   */, +  def replay[U >: T, R](selector: Observable[U] => Observable[R]): Observable[R] = {, +    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[U]], +    val fJava: Func1[rx.Observable[U], rx.Observable[R]] =, +      (jo: rx.Observable[U]) => selector(toScalaObservable[U](jo)).asJavaObservable.asInstanceOf[rx.Observable[R]], +    toScalaObservable[R](thisJava.replay(fJava)), +  }, +]