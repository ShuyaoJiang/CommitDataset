[+++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.junit.Test;, +import org.mockito.InOrder;, +import org.mockito.Mockito;, +, +import rx.concurrency.TestScheduler;, +     * Schedules a cancelable action to be executed periodically., +     * This default implementation schedules recursively and waits for actions to complete (instead of potentially executing, +     * long-running actions concurrently). Each scheduler that can do periodic scheduling in a better way should override this., +     *, +     * @param state , +     *            State to pass into the action., +     * @param action , +     *            The action to execute periodically., +     * @param initialDelay , +     *            Time to wait before executing the action for the first time., +     * @param period , +     *            The time interval to wait each time in between executing the action., +     * @param unit , +     *            The time unit the interval above is given in., +     * @return A subscription to be able to unsubscribe from action., +     */, +    public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit) {, +        final long periodInNanos = unit.toNanos(period);, +        final AtomicBoolean complete = new AtomicBoolean();, +  , +        final Func2<Scheduler, T, Subscription> recursiveAction = new Func2<Scheduler, T, Subscription>() {, +            @Override, +            public Subscription call(Scheduler scheduler, T state0) {, +                if (!complete.get()) {, +                    long startedAt = now();, +                    final Subscription sub1 = action.call(scheduler, state0);, +                    long timeTakenByActionInNanos = TimeUnit.MILLISECONDS.toNanos(now() - startedAt);, +                    final Subscription sub2 = schedule(state0, this, periodInNanos - timeTakenByActionInNanos, TimeUnit.NANOSECONDS);, +                    return Subscriptions.create(new Action0() {, +                        @Override, +                        public void call() {, +                            sub1.unsubscribe();, +                            sub2.unsubscribe();, +                        }, +                    });, +                }, +                return Subscriptions.empty();, +            }, +        };, +        final Subscription sub = schedule(state, recursiveAction, initialDelay, unit);, +        return Subscriptions.create(new Action0() {, +            @Override, +            public void call() {, +                complete.set(true);, +                sub.unsubscribe();, +            }, +        });, +    }, +    , +    /**, +            public Subscription call(Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +            public Subscription call(@SuppressWarnings("unused") Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +            public Subscription call(@SuppressWarnings("unused") Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +            public Subscription call(Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +            public Subscription call(@SuppressWarnings("unused") Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +            public Subscription call(@SuppressWarnings("unused") Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +     * Schedules a cancelable action to be executed periodically., +     * , +     * @param action , +     *            The action to execute periodically., +     * @param initialDelay , +     *            Time to wait before executing the action for the first time., +     * @param period , +     *            The time interval to wait each time in between executing the action., +     * @param unit , +     *            The time unit the interval above is given in., +     * @return A subscription to be able to unsubscribe from action., +     */, +    public Subscription schedulePeriodically(final Func1<Scheduler, Subscription> action, long initialDelay, long period, TimeUnit unit) {, +        return schedulePeriodically(null, new Func2<Scheduler, Void, Subscription>() {, +            @Override, +            public Subscription call(Scheduler scheduler, @SuppressWarnings("unused") Void state) {, +                return action.call(scheduler);, +            }, +        }, initialDelay, period, unit);, +    }, +, +    /**, +     * Schedules a cancelable action to be executed periodically., +     * , +     * @param action , +     *            The action to execute periodically., +     * @param initialDelay , +     *            Time to wait before executing the action for the first time., +     * @param period , +     *            The time interval to wait each time in between executing the action., +     * @param unit , +     *            The time unit the interval above is given in., +     * @return A subscription to be able to unsubscribe from action., +     */]