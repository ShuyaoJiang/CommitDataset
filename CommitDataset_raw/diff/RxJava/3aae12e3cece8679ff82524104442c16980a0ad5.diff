[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, +                    if (tryEmitScalar(((Callable<? extends U>)p)) && maxConcurrency != Integer.MAX_VALUE) {, +                        boolean empty = false;, +                                empty = true;, +                        if (empty) {, +                            drain();, +                            break;, +                        }, +        boolean tryEmitScalar(Callable<? extends U> value) {, +                return true;, +                return true;, +                    return true;, +                    return true;, +                    return false;, +            return true;, +                int nSources = 0;, +                if (maxConcurrency != Integer.MAX_VALUE) {, +                    synchronized (this) {, +                        nSources = sources.size();, +                    }, +                }, +, +                if (d && (svq == null || svq.isEmpty()) && n == 0 && nSources == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, +                    if (tryEmitScalar(((Callable<? extends U>)p)) && maxConcurrency != Integer.MAX_VALUE) {, +                        boolean empty = false;, +                                empty = true;, +                        if (empty) {, +                            drain();, +                            break;, +                        }, +        boolean tryEmitScalar(Callable<? extends U> value) {, +                return true;, +                return true;, +                    return true;, +                    return true;, +                    return false;, +            return true;, +                int nSources = 0;, +                if (maxConcurrency != Integer.MAX_VALUE) {, +                    synchronized (this) {, +                        nSources = sources.size();, +                    }, +                }, +, +                if (d && (svq == null || svq.isEmpty()) && n == 0 && nSources == 0) {, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java, +import io.reactivex.exceptions.*;, +, +    @Test, +    public void reentrantNoOverflow() {, +        List<Throwable> errors = TestHelper.trackPluginErrors();, +        try {, +            final PublishSubject<Integer> ps = PublishSubject.create();, +, +            TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {, +                @Override, +                public Observable<Integer> apply(Integer v), +                        throws Exception {, +                    return Observable.just(v + 1);, +                }, +            }, 1), +            .subscribeWith(new TestObserver<Integer>() {, +                @Override, +                public void onNext(Integer t) {, +                    super.onNext(t);, +                    if (t == 1) {, +                        for (int i = 1; i < 10; i++) {, +                            ps.onNext(i);, +                        }, +                        ps.onComplete();, +                    }, +                }, +            });, +, +            ps.onNext(0);, +, +            if (!errors.isEmpty()) {, +                to.onError(new CompositeException(errors));, +            }, +, +            to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);, +        } finally {, +            RxJavaPlugins.reset();, +        }, +    }, +, +    @Test, +    public void reentrantNoOverflowHidden() {, +        final PublishSubject<Integer> ps = PublishSubject.create();, +, +        TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {, +            @Override, +            public Observable<Integer> apply(Integer v), +                    throws Exception {, +                return Observable.just(v + 1).hide();, +            }, +        }, 1), +        .subscribeWith(new TestObserver<Integer>() {, +            @Override]