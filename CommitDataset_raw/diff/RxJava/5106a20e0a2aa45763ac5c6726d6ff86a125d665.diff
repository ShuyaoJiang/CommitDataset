[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                    output.index = null;, +                        output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                    output.index = null;, +                        output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                        output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                    output.index = null;, +                        output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                        output.index = null;, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, +import java.lang.management.*;, +, +    @Test, +    public void noBoundedRetentionViaThreadLocal() throws Exception {, +        Flowable<byte[]> source = Flowable.range(1, 200), +        .map(new Function<Integer, byte[]>() {, +            @Override, +            public byte[] apply(Integer v) throws Exception {, +                return new byte[1024 * 1024];, +            }, +        }), +        .replay(new Function<Flowable<byte[]>, Publisher<byte[]>>() {, +            @Override, +            public Publisher<byte[]> apply(final Flowable<byte[]> f) throws Exception {, +                return f.take(1), +                .concatMap(new Function<byte[], Publisher<byte[]>>() {, +                    @Override, +                    public Publisher<byte[]> apply(byte[] v) throws Exception {, +                        return f;, +                    }, +                });, +            }, +        }, 1), +        .takeLast(1), +        ;, +, +        System.out.println("Bounded Replay Leak check: Wait before GC");, +        Thread.sleep(1000);, +, +        System.out.println("Bounded Replay Leak check: GC");, +        System.gc();, +, +        Thread.sleep(500);, +, +        final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();, +        MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();, +        long initial = memHeap.getUsed();, +, +        System.out.printf("Bounded Replay Leak check: Starting: %.3f MB%n", initial / 1024.0 / 1024.0);, +, +        final AtomicLong after = new AtomicLong();, +, +        source.subscribe(new Consumer<byte[]>() {, +            @Override, +            public void accept(byte[] v) throws Exception {, +                System.out.println("Bounded Replay Leak check: Wait before GC 2");, +                Thread.sleep(1000);, +, +                System.out.println("Bounded Replay Leak check:  GC 2");, +                System.gc();, +, +                Thread.sleep(500);, +, +                after.set(memoryMXBean.getHeapMemoryUsage().getUsed());, +            }, +        });, +, +        System.out.printf("Bounded Replay Leak check: After: %.3f MB%n", after.get() / 1024.0 / 1024.0);, +, +        if (initial + 100 * 1024 * 1024 < after.get()) {, +            Assert.fail("Bounded Replay Leak check: Memory leak detected: " + (initial / 1024.0 / 1024.0), +                    + " -> " + after.get() / 1024.0 / 1024.0);, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                    output.index = null;, +                        output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +                // make sure the last known node is not retained, +                index = null;, +                        output.index = null;, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, +import java.lang.management.*;, +]