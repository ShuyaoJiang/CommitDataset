[+++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java, +import java.util.concurrent.Semaphore;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action0;, + * Delivers events on the specified Scheduler., + * This provides backpressure by blocking the incoming onNext when there is already one in the queue., + * <p>, + * This means that at any given time the max number of "onNext" in flight is 3:, + * -> 1 being delivered on the Scheduler, + * -> 1 in the queue waiting for the Scheduler, + * -> 1 blocking on the queue waiting to deliver it, + * , + * I have chosen to allow 1 in the queue rather than using an Exchanger style process so that the Scheduler, + * can loop and have something to do each time around to optimize for avoiding rescheduling when it, + * can instead just loop. I'm avoiding having the Scheduler thread ever block as it could be an event-loop, + * thus if the queue is empty it exits and next time something is added it will reschedule., + * , +        private final InterruptibleBlockingQueue queue = new InterruptibleBlockingQueue();, +                if (!isUnsubscribed()) {, +        }, +                    // first time through, register a Subscription, +                    // that can interrupt this thread, +                    add(Subscriptions.create(new Action0() {, +, +                        @Override, +                        public void call() {, +                            // we have to interrupt the parent thread because, +                            // it can be blocked on queue.put, +                            queue.interrupt();, +                        }, +, +                    }));, +    /**, +     * Same behavior as ArrayBlockingQueue<Object>(1) except that we can interrupt/unsubscribe it., +     */, +    private class InterruptibleBlockingQueue {, +, +        private final Semaphore semaphore = new Semaphore(1);, +        private volatile Object item;, +        private volatile boolean interrupted = false;, +, +        public Object poll() {, +            if (interrupted) {, +                return null;, +            }, +            if (item == null) {, +                return null;, +            }, +            try {, +                return item;, +            } finally {, +                item = null;, +                semaphore.release();, +            }, +        }, +, +        /**, +         * Add an Object, blocking if an item is already in the queue., +         * , +         * @param o, +         * @throws InterruptedException, +         */, +        public void put(Object o) throws InterruptedException {, +            if (interrupted) {, +                throw new InterruptedException("Interrupted by Unsubscribe");, +            }, +            semaphore.acquire();, +            if (interrupted) {, +                throw new InterruptedException("Interrupted by Unsubscribe");, +            }, +            if (o == null) {, +                throw new IllegalArgumentException("Can not put null");, +            }, +            item = o;, +        }, +, +        /**, +         * Used to unsubscribe and interrupt the producer if blocked in put(), +         */, +        public void interrupt() {, +            interrupted = true;, +            semaphore.release();, +        }, +    }, +]