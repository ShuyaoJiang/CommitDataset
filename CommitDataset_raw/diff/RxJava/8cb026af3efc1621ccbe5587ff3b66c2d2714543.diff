[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/test/java/README.md, +Not all unit tests are here, many are also embedded as inner classes of the main code (such as here: [rxjava-core/src/main/java/rx/operators](https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/operators))., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/test/java/README.md, +Not all unit tests are here, many are also embedded as inner classes of the main code (such as here: [rxjava-core/src/main/java/rx/operators](https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/operators))., +++ b/rxjava-core/src/test/java/rx/ObservableTests.java, +package rx;, +, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.mockito.Mock;, +import org.mockito.Mockito;, +import org.mockito.MockitoAnnotations;, +, +import rx.observables.ConnectableObservable;, +import rx.subscriptions.BooleanSubscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action1;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, +, +public class ObservableTests {, +, +    @Mock, +    Observer<Integer> w;, +, +    @Before, +    public void before() {, +        MockitoAnnotations.initMocks(this);, +    }, +, +    @Test, +    public void testCreate() {, +, +        Observable<String> observable = Observable.create(new Func1<Observer<String>, Subscription>() {, +, +            @Override, +            public Subscription call(Observer<String> Observer) {, +                Observer.onNext("one");, +                Observer.onNext("two");, +                Observer.onNext("three");, +                Observer.onCompleted();, +                return Subscriptions.empty();, +            }, +, +        });, +, +        @SuppressWarnings("unchecked"), +        Observer<String> aObserver = mock(Observer.class);, +        observable.subscribe(aObserver);, +        verify(aObserver, times(1)).onNext("one");, +        verify(aObserver, times(1)).onNext("two");, +        verify(aObserver, times(1)).onNext("three");, +        verify(aObserver, Mockito.never()).onError(any(Throwable.class));, +        verify(aObserver, times(1)).onCompleted();, +    }, +, +    @Test, +    public void testReduce() {, +        Observable<Integer> observable = Observable.from(1, 2, 3, 4);, +        observable.reduce(new Func2<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer call(Integer t1, Integer t2) {, +                return t1 + t2;, +            }, +, +        }).subscribe(w);, +        // we should be called only once, +        verify(w, times(1)).onNext(anyInt());, +        verify(w).onNext(10);, +    }, +, +    @Test, +    public void testReduceWithInitialValue() {, +        Observable<Integer> observable = Observable.from(1, 2, 3, 4);, +        observable.reduce(50, new Func2<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer call(Integer t1, Integer t2) {, +                return t1 + t2;, +            }, +, +        }).subscribe(w);, +        // we should be called only once, +        verify(w, times(1)).onNext(anyInt());, +        verify(w).onNext(60);, +    }, +]