[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Move notifications to the specified {@link Scheduler} one `onNext` at a time., +     * Move notifications to the specified {@link Scheduler} asynchronously with a buffer of the given size., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/observeOn.png">, +     * , +     * @param scheduler, +     *            the {@link Scheduler} to notify {@link Observer}s on, +     * @param bufferSize, +     *            that will be rounded up to the next power of 2, +     * @return the source Observable modified so that its {@link Observer}s are notified on the, +     *         specified {@link Scheduler}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-observeon">RxJava Wiki: observeOn()</a>, +     */, +    public final Observable<T> observeOn(Scheduler scheduler, int bufferSize) {, +        return lift(new OperatorObserveOn<T>(scheduler, bufferSize));, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Move notifications to the specified {@link Scheduler} one `onNext` at a time., +     * Move notifications to the specified {@link Scheduler} asynchronously with a buffer of the given size., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/observeOn.png">, +     * , +     * @param scheduler, +     *            the {@link Scheduler} to notify {@link Observer}s on, +     * @param bufferSize, +     *            that will be rounded up to the next power of 2, +     * @return the source Observable modified so that its {@link Observer}s are notified on the, +     *         specified {@link Scheduler}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-observeon">RxJava Wiki: observeOn()</a>, +     */, +    public final Observable<T> observeOn(Scheduler scheduler, int bufferSize) {, +        return lift(new OperatorObserveOn<T>(scheduler, bufferSize));, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java, +    private final int bufferSize;, +, +    /**, +     * , +     * @param scheduler, +     * @param bufferSize, +     *            that will be rounded up to the next power of 2, +     */, +    public OperatorObserveOn(Scheduler scheduler, int bufferSize) {, +        this.scheduler = scheduler;, +        this.bufferSize = roundToNextPowerOfTwoIfNecessary(bufferSize);, +    }, +        this(scheduler, 1);, +    }, +, +    private static int roundToNextPowerOfTwoIfNecessary(int num) {, +        if ((num & -num) == num) {, +            return num;, +        } else {, +            int result = 1;, +            while (num != 0), +            {, +                num >>= 1;, +                result <<= 1;, +            }, +            return result;, +        }, +        private final InterruptibleBlockingQueue queue = new InterruptibleBlockingQueue(bufferSize);, +                    queue.addBlocking(NULL_SENTINEL);, +                    queue.addBlocking(t);, +                queue.addBlocking(COMPLETE_SENTINEL);, +                queue.addBlocking(new ErrorSentinel(e));, +        private final Semaphore semaphore;, +        private final Object[] buffer;, +        private AtomicLong tail = new AtomicLong();, +        private AtomicLong head = new AtomicLong();, +        private final int capacity;, +        private final int mask;, +, +        public InterruptibleBlockingQueue(final int size) {, +            this.semaphore = new Semaphore(size);, +            this.capacity = size;, +            this.mask = size - 1;, +            buffer = new Object[size];, +, +        public void addBlocking(final Object e) throws InterruptedException {, +            if (interrupted) {, +                throw new InterruptedException("Interrupted by Unsubscribe");, +            }, +            semaphore.acquire();, +            if (interrupted) {, +                throw new InterruptedException("Interrupted by Unsubscribe");, +            }, +            if (e == null) {, +                throw new IllegalArgumentException("Can not put null");, +            }, +, +            if (offer(e)) {, +                return;, +            } else {, +                throw new IllegalStateException("Queue is full");]