[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * <p>, +     * This is a scheduler version of {@link #just(Object)}., +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * <p>, +     * This is a scheduler version of {@link #just(Object)}., +++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java, +import rx.observers.TestSubscriber;, +    private BlackHole bh;, +        this.bh = bh;, +    }, +    public TestSubscriber<Integer> newSubscriber() {, +        return new TestSubscriber<Integer>(new Observer<Integer>() {, +        });, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * <p>, +     * This is a scheduler version of {@link #just(Object)}., +++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java, +import rx.observers.TestSubscriber;, +    private BlackHole bh;, +        this.bh = bh;, +    }, +    public TestSubscriber<Integer> newSubscriber() {, +        return new TestSubscriber<Integer>(new Observer<Integer>() {, +        });, +++ b/rxjava-core/src/perf/java/rx/operators/OperatorMapPerf.java, +import rx.observers.TestSubscriber;, +        TestSubscriber<Integer> ts = input.newSubscriber();, +        input.observable.lift(MAP_OPERATOR).subscribe(ts);, +        ts.awaitTerminalEvent();, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     * <p>, +     * This is a scheduler version of {@link #just(Object)}., +++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java, +import rx.observers.TestSubscriber;, +    private BlackHole bh;, +        this.bh = bh;, +    }, +    public TestSubscriber<Integer> newSubscriber() {, +        return new TestSubscriber<Integer>(new Observer<Integer>() {, +        });, +++ b/rxjava-core/src/perf/java/rx/operators/OperatorMapPerf.java, +import rx.observers.TestSubscriber;, +        TestSubscriber<Integer> ts = input.newSubscriber();, +        input.observable.lift(MAP_OPERATOR).subscribe(ts);, +        ts.awaitTerminalEvent();, +++ b/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerf.java, +import java.util.concurrent.TimeUnit;, +import rx.schedulers.Schedulers;, +    public static void main(String[] args) {, +, +    }, +, +        TestSubscriber<Long> ts = input.newSubscriber();, +        input.firehose.subscribe(ts);, +        ts.awaitTerminalEvent();, +        TestSubscriber<Long> ts = input.newSubscriber();, +        input.firehose.serialize().subscribe(ts);, +        ts.awaitTerminalEvent();, +    @GenerateMicroBenchmark, +    public void serializedTwoStreamsSlightlyContended(final Input input) {, +        TestSubscriber<Long> ts = input.newSubscriber();, +        Observable.create(new OnSubscribe<Long>() {, +, +            @Override, +            public void call(Subscriber<? super Long> s) {, +                // break the contract here and concurrently onNext, +                input.interval.subscribeOn(Schedulers.computation()).unsafeSubscribe(s);, +                input.interval.subscribeOn(Schedulers.computation()).unsafeSubscribe(s);, +                // they will be serialized after, +            }, +, +        }).serialize().subscribe(ts);, +        ts.awaitTerminalEvent();, +    }, +, +    @GenerateMicroBenchmark, +    public void serializedTwoStreamsHighlyContended(final Input input) {, +        TestSubscriber<Long> ts = input.newSubscriber();, +        Observable.create(new OnSubscribe<Long>() {, +, +            @Override, +            public void call(Subscriber<? super Long> s) {, +                // break the contract here and concurrently onNext, +                input.firehose.subscribeOn(Schedulers.computation()).unsafeSubscribe(s);, +                input.firehose.subscribeOn(Schedulers.computation()).unsafeSubscribe(s);, +                // they will be serialized after, +            }, +, +        }).serialize().subscribe(ts);, +        ts.awaitTerminalEvent();, +    }, +, +    @GenerateMicroBenchmark, +    public void serializedTwoStreamsOneFastOneSlow(final Input input) {, +        TestSubscriber<Long> ts = input.newSubscriber();]