[+++ b/rxjava-core/src/test/java/rx/operators/OperatorParallelTest.java, +import java.util.concurrent.TimeUnit;, +        final AtomicInteger innerCount = new AtomicInteger();, +                                try {, +                                    // randomize to try and force non-determinism, +                                    // if we see these tests fail randomly then we have a problem with merging it all back together, +                                    Thread.sleep((int) (Math.random() * 10));, +                                } catch (InterruptedException e) {, +                                    System.out.println("*********** error!!!!!!!");, +                                    e.printStackTrace();, +                                    // TODO why is this exception not being thrown?, +                                    throw new RuntimeException(e);, +                                }, +                                //                                System.out.println("V: " + t  + " Thread: " + Thread.currentThread());, +                                innerCount.incrementAndGet();, +                }), +                .toBlockingObservable().forEach(new Action1<Integer[]>() {, +                        //                System.out.println("V: " + v[0] + " R: " + v[1] + " Thread: " + Thread.currentThread());, +                    }, +, +                });, +        System.out.println("parallel test completed ----------");, +, +        // just making sure we finish and get the number we expect, +        assertEquals("innerCount", NUM, innerCount.get());, +        assertEquals("finalCount", NUM, count.get());, +    }, +, +    @Test, +    public void testParallelWithNestedAsyncWork() {, +        int NUM = 20;, +        final AtomicInteger count = new AtomicInteger();, +        Observable.range(1, NUM).parallel(, +                new Func1<Observable<Integer>, Observable<String>>() {, +, +                    @Override, +                    public Observable<String> call(Observable<Integer> o) {, +                        return o.flatMap(new Func1<Integer, Observable<String>>() {, +, +                            @Override, +                            public Observable<String> call(Integer t) {, +                                return Observable.from(String.valueOf(t)).delay(100, TimeUnit.MILLISECONDS);, +                            }, +, +                        });, +                    }, +                }).toBlockingObservable().forEach(new Action1<String>() {, +, +            @Override, +            public void call(String v) {, +                count.incrementAndGet();]