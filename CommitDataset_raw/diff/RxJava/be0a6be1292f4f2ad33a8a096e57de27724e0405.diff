[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val (startFunc, sharedNumbers) = numbers.replay, +    startFunc(), +    val o : Observable[String] = List("alice", "bob", "carol").toObservable.repeat().take(6), +  @Test def startWithExample(): Unit = {, +    val o2 = 1 +: 2 +: o1, +  @Test def appendExample(): Unit = {, +    val o = List(1, 2).toObservable :+ 3 :+ 4, +    assertEquals(List(1, 2, 3, 4), o.toBlockingObservable.toList), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val (startFunc, sharedNumbers) = numbers.replay, +    startFunc(), +    val o : Observable[String] = List("alice", "bob", "carol").toObservable.repeat().take(6), +  @Test def startWithExample(): Unit = {, +    val o2 = 1 +: 2 +: o1, +  @Test def appendExample(): Unit = {, +    val o = List(1, 2).toObservable :+ 3 :+ 4, +    assertEquals(List(1, 2, 3, 4), o.toBlockingObservable.toList), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): (() => Subscription, Observable[R]) = {, +    val javaCO: rx.observables.ConnectableObservable[R] = asJavaObservable.multicast(s), +    (() => javaCO.connect(), toScalaObservable(javaCO)), +   * Returns an Observable that first emits the items emitted by `this`, and then `elem`., +   * @param elem the item to be appended, +   * @return  an Observable that first emits the items emitted by `this`, and then `elem`., +  def :+[U >: T](elem: U): Observable[U] = {, +    this ++ Observable.items(elem), +  def +:[U >: T](elem: U): Observable[U] = {, +  def replay: (() => Subscription, Observable[T]) = {, +    val javaCO = asJavaObservable.replay(), +    (() => javaCO.connect(), toScalaObservable[T](javaCO)), +  def contains[U >: T](elem: U): Observable[Boolean] = {, +  def publish(): ConnectableObservable[T] = {, +  def retry(): Observable[T] = {, +  def repeat(): Observable[T] = {, +   * This differs from `finallyDo` in that this happens **before** `onCompleted/onError` are emitted., +   * @see `Observable.elementAt`, +   * @deprecated("Use `elementAt`", "0.18.0"), +   */, +  def apply(index: Int): Observable[T] = elementAt(index), +, +  /**, +   * Returns an Observable that emits the single item at a specified index in a sequence of emissions from a, +   * source Observbable., +   * , +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAt.png">, +   * , +   * @param index, +   *            the zero-based index of the item to retrieve, +   * @return an Observable that emits a single item: the item at the specified position in the sequence of, +   *         those emitted by the source Observable, +   * @throws IndexOutOfBoundsException, +   *             if index is greater than or equal to the number of items emitted by the source, +   *             Observable, +   * @throws IndexOutOfBoundsException, +   *             if index is less than 0, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val (startFunc, sharedNumbers) = numbers.replay, +    startFunc(), +    val o : Observable[String] = List("alice", "bob", "carol").toObservable.repeat().take(6), +  @Test def startWithExample(): Unit = {, +    val o2 = 1 +: 2 +: o1, +  @Test def appendExample(): Unit = {, +    val o = List(1, 2).toObservable :+ 3 :+ 4, +    assertEquals(List(1, 2, 3, 4), o.toBlockingObservable.toList), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): (() => Subscription, Observable[R]) = {, +    val javaCO: rx.observables.ConnectableObservable[R] = asJavaObservable.multicast(s), +    (() => javaCO.connect(), toScalaObservable(javaCO)), +   * Returns an Observable that first emits the items emitted by `this`, and then `elem`., +   * @param elem the item to be appended, +   * @return  an Observable that first emits the items emitted by `this`, and then `elem`., +  def :+[U >: T](elem: U): Observable[U] = {, +    this ++ Observable.items(elem), +  def +:[U >: T](elem: U): Observable[U] = {, +  def replay: (() => Subscription, Observable[T]) = {, +    val javaCO = asJavaObservable.replay(), +    (() => javaCO.connect(), toScalaObservable[T](javaCO)), +  def contains[U >: T](elem: U): Observable[Boolean] = {, +  def publish(): ConnectableObservable[T] = {, +  def retry(): Observable[T] = {, +  def repeat(): Observable[T] = {, +   * This differs from `finallyDo` in that this happens **before** `onCompleted/onError` are emitted., +   * @see `Observable.elementAt`, +   * @deprecated("Use `elementAt`", "0.18.0"), +   */, +  def apply(index: Int): Observable[T] = elementAt(index), +, +  /**, +   * Returns an Observable that emits the single item at a specified index in a sequence of emissions from a, +   * source Observbable., +   * , +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAt.png">, +   * , +   * @param index, +   *            the zero-based index of the item to retrieve, +   * @return an Observable that emits a single item: the item at the specified position in the sequence of, +   *         those emitted by the source Observable, +   * @throws IndexOutOfBoundsException, +   *             if index is greater than or equal to the number of items emitted by the source]