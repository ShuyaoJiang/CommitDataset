[+++ b/rxjava-core/build.gradle, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/org/rx/functions/FunctionLanguageAdaptor.java, +package org.rx.functions;, +, +public interface FunctionLanguageAdaptor {, +, +    /**, +     * Invoke the function and return the results., +     * , +     * @param function, +     * @param args, +     * @return Object results from function execution, +     */, +    Object call(Object function, Object[] args);, +, +    /**, +     * The Class of the Function that this adaptor serves., +     * <p>, +     * Example: groovy.lang.Closure, +     * , +     * @return Class, +     */, +    public Class<?> getFunctionClass();, +}, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/org/rx/functions/FunctionLanguageAdaptor.java, +package org.rx.functions;, +, +public interface FunctionLanguageAdaptor {, +, +    /**, +     * Invoke the function and return the results., +     * , +     * @param function, +     * @param args, +     * @return Object results from function execution, +     */, +    Object call(Object function, Object[] args);, +, +    /**, +     * The Class of the Function that this adaptor serves., +     * <p>, +     * Example: groovy.lang.Closure, +     * , +     * @return Class, +     */, +    public Class<?> getFunctionClass();, +}, +++ b/rxjava-core/src/main/java/org/rx/functions/Functions.java, +import java.util.Collection;, +import java.util.concurrent.ConcurrentHashMap;, +/**, + * Allows execution of functions from multiple different languages., + * <p>, + * Language support is provided via implementations of {@link FunctionLanguageAdaptor}., + * <p>, + * This class will dynamically look for known language adaptors on the classpath at startup or new ones can be registered using {@link #registerLanguageAdaptor(Class, FunctionLanguageAdaptor)}., + */, +    private final static ConcurrentHashMap<Class<?>, FunctionLanguageAdaptor> languageAdaptors = new ConcurrentHashMap<Class<?>, FunctionLanguageAdaptor>();, +, +    static {, +        /* optimistically look for supported languages if they are in the classpath */, +        loadLanguageAdaptor("Groovy");, +        loadLanguageAdaptor("JRuby");, +        loadLanguageAdaptor("Clojure");, +        loadLanguageAdaptor("Scala");, +        // as new languages arise we can add them here but this does not prevent someone from using 'registerLanguageAdaptor' directly, +    }, +, +    private static void loadLanguageAdaptor(String name) {, +        String className = "org.rx.lang." + name.toLowerCase() + "." + name + "Adaptor";, +        try {, +            Class<?> c = Class.forName(className);, +            FunctionLanguageAdaptor a = (FunctionLanguageAdaptor) c.newInstance();, +            registerLanguageAdaptor(a.getFunctionClass(), a);, +        } catch (ClassNotFoundException e) {, +            logger.info("Could not found function language adaptor: " + name + " with path: " + className);, +        } catch (Exception e) {, +            logger.error("Failed trying to initialize function language adaptor: " + className, e);, +        }, +    }, +, +    public static void registerLanguageAdaptor(Class<?> functionClass, FunctionLanguageAdaptor adaptor) {, +        languageAdaptors.put(functionClass, adaptor);, +    }, +, +    public static void removeLanguageAdaptor(Class<?> functionClass) {, +        languageAdaptors.remove(functionClass);, +    }, +, +    public static Collection<FunctionLanguageAdaptor> getRegisteredLanguageAdaptors() {, +        return languageAdaptors.values();, +    }, +, +     * @param function, +    public static <R> R execute(Object function, Object... args) {, +                tracer.traceStart(function, args);, +            if (function == null) {, +                throw new RuntimeException("function is null. Can't send arguments to null function.");]