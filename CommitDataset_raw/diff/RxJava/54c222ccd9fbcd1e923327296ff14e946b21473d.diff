[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSwitch.java, +import rx.Producer;, +        return new SwitchSubscriber(child);, +    }, +    private static final class SwitchSubscriber<T> extends Subscriber<Observable<? extends T>> {, +        final SerializedSubscriber<T> s;, +        final SerialSubscription ssub;, +        /** Guarded by guard. */, +        InnerSubscriber currentSubscriber;, +        /** Guarded by guard. */, +        long initialRequested;, +, +        volatile boolean infinite = false;, +, +        public SwitchSubscriber(Subscriber<? super T> child) {, +            s = new SerializedSubscriber<T>(child);, +            ssub = new SerialSubscription();, +            child.add(ssub);, +            child.setProducer(new Producer(){, +, +                @Override, +                public void request(long n) {, +                    if (infinite) {, +                        return;, +                    }, +                    if(n == Long.MAX_VALUE) {, +                        infinite = true;, +                    }, +                    InnerSubscriber localSubscriber;, +                    synchronized (guard) {, +                        localSubscriber = currentSubscriber;, +                        if (currentSubscriber == null) {, +                            initialRequested = n;, +                        } else {, +                            // If n == Long.MAX_VALUE, infinite will become true. Then currentSubscriber.requested won't be used., +                            // Therefore we don't need to worry about overflow., +                            currentSubscriber.requested += n;, +                        }, +                    }, +                    if (localSubscriber != null) {, +                        localSubscriber.requestMore(n);, +                    }, +                }, +            });, +        }, +, +            long remainingRequest;, +                if (infinite) {, +                    remainingRequest = Long.MAX_VALUE;, +                } else {, +                    remainingRequest = currentSubscriber == null ? initialRequested : currentSubscriber.requested;, +                currentSubscriber = new InnerSubscriber(id, remainingRequest);, +                currentSubscriber.requested = remainingRequest;, +            ssub.set(currentSubscriber);, +            t.unsafeSubscribe(currentSubscriber);, +        void emit(T value, int id, InnerSubscriber innerSubscriber) {, +                    innerSubscriber.requested--;, +                        synchronized (guard) {, +                            innerSubscriber.requested--;, +                        }, +, +        final class InnerSubscriber extends Subscriber<T> {, +, +            /**, +             * The number of request that is not acknowledged., +             *, +             * Guarded by guard., +             */, +            private long requested = 0;, +, +            private final int id;, +, +            private final long initialRequested;, +, +            public InnerSubscriber(int id, long initialRequested) {, +                this.id = id;, +                this.initialRequested = initialRequested;, +            @Override, +            public void onStart() {, +                requestMore(initialRequested);, +            }, +, +            public void requestMore(long n) {, +                request(n);, +            }, +, +            @Override, +            public void onNext(T t) {, +                emit(t, id, this);, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                error(e, id);, +            }, +, +            @Override, +            public void onCompleted() {, +                complete(id);, +            }]