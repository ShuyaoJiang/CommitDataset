[+++ b/pmd.xml, +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, +    /** Single instance of a complete Completable. */, +    static final Completable COMPLETE = new CompletableEmpty();, +    , +    /** Single instance of a never Completable. */, +    static final Completable NEVER = new CompletableNever();, +    , +        } catch (NullPointerException ex) { // NOPMD, +        } catch (NullPointerException ex) { // NOPMD, +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, +    /** Single instance of a complete Completable. */, +    static final Completable COMPLETE = new CompletableEmpty();, +    , +    /** Single instance of a never Completable. */, +    static final Completable NEVER = new CompletableNever();, +    , +        } catch (NullPointerException ex) { // NOPMD, +        } catch (NullPointerException ex) { // NOPMD, +++ b/src/main/java/io/reactivex/Flowable.java, +    private static final Object OBJECT = new Object(); , +    /** The default buffer size. */, +    static final int BUFFER_SIZE;, +    static {, +        BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, +    }, +    , +        return new FlowableFromFuture<T>(future, timeout, unit);, +            public Object call() {, +        } catch (NullPointerException e) { // NOPMD, +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, +    /** Single instance of a complete Completable. */, +    static final Completable COMPLETE = new CompletableEmpty();, +    , +    /** Single instance of a never Completable. */, +    static final Completable NEVER = new CompletableNever();, +    , +        } catch (NullPointerException ex) { // NOPMD, +        } catch (NullPointerException ex) { // NOPMD, +++ b/src/main/java/io/reactivex/Flowable.java, +    private static final Object OBJECT = new Object(); , +    /** The default buffer size. */, +    static final int BUFFER_SIZE;, +    static {, +        BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, +    }, +    , +        return new FlowableFromFuture<T>(future, timeout, unit);, +            public Object call() {, +        } catch (NullPointerException e) { // NOPMD, +++ b/src/main/java/io/reactivex/Notification.java, +    static final Try<Optional<Object>> COMPLETE = Try.ofValue(Optional.<Object>empty());, +    , +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, +    /** Single instance of a complete Completable. */, +    static final Completable COMPLETE = new CompletableEmpty();, +    , +    /** Single instance of a never Completable. */, +    static final Completable NEVER = new CompletableNever();, +    , +        } catch (NullPointerException ex) { // NOPMD, +        } catch (NullPointerException ex) { // NOPMD, +++ b/src/main/java/io/reactivex/Flowable.java, +    private static final Object OBJECT = new Object(); , +    /** The default buffer size. */, +    static final int BUFFER_SIZE;, +    static {, +        BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, +    }, +    , +        return new FlowableFromFuture<T>(future, timeout, unit);, +            public Object call() {, +        } catch (NullPointerException e) { // NOPMD, +++ b/src/main/java/io/reactivex/Notification.java, +    static final Try<Optional<Object>> COMPLETE = Try.ofValue(Optional.<Object>empty());, +    , +++ b/src/main/java/io/reactivex/Observable.java, +    static final Object OBJECT = new Object();, +        return new ObservableAmb<T>(null, sources);, +        return new ObservableAmb<T>(sources, null);, +        return new ObservableCombineLatest<T, R>(null, sources, combiner, s, delayError);, +        return new ObservableCombineLatest<T, R>(sources, null, combiner, s, delayError);, +        return new ObservableDefer<T>(supplier);, +        return new ObservableError<T>(errorSupplier);, +        return new ObservableFromArray<T>(values);, +        return new ObservableFromCallable<T>(supplier);, +        return new ObservableFromFuture<T>(future, 0L, null);, +        return new ObservableFromFuture<T>(future, timeout, unit);, +        return new ObservableFromIterable<T>(source);, +        return new ObservableGenerate<T, S>(initialState, generator, disposeState);, +        return new ObservableInterval(initialDelay, period, unit, scheduler);, +        return new ObservableIntervalRange(start, end, initialDelay, period, unit, scheduler);, +        return new ObservableSequenceEqual<T>(p1, p2, isEqual, bufferSize);, +        return new ObservableTimer(delay, unit, scheduler);, +        return new ObservableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager);, +        return new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false);]