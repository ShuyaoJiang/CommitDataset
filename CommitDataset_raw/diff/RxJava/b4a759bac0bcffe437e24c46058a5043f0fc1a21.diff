[+++ b/src/main/java/rx/Observable.java, +import rx.subjects.*;, +        return CachedObservable.from(this);, +        return CachedObservable.from(this, capacityHint);, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return new OperatorMulticast<T, T>(this, new Func0<Subject<? super T, ? extends T>>() {, +, +            @Override, +            public Subject<? super T, ? extends T> call() {, +                return ReplaySubject.<T> create();, +            }, +            , +        });, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return ReplaySubject.create();, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return ReplaySubject.<T>createWithSize(bufferSize);, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +    public final <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) {, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +    public final <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler) {, +        return create(new OnSubscribeMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, +            public final Subject<T, T> call() {, +                return OperatorReplay.createScheduledSubject(ReplaySubject.<T> create(), scheduler);, +        }, selector));, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return new OperatorMulticast<T, T>(this, new Func0<Subject<? super T, ? extends T>>() {, +, +            @Override, +            public Subject<? super T, ? extends T> call() {, +                return ReplaySubject.<T>createWithSize(bufferSize);, +            }, +            , +        });, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return new OperatorMulticast<T, T>(this, new Func0<Subject<? super T, ? extends T>>() {, +, +            @Override, +            public Subject<? super T, ? extends T> call() {, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +            }, +            , +        });, +     *  <dd>This operator does not support backpressure because multicasting means the stream is "hot" with, +     *      multiple subscribers. Each child will need to manage backpressure independently using operators such, +     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.</dd>, +        return new OperatorMulticast<T, T>(this, new Func0<Subject<? super T, ? extends T>>() {, +, +            @Override, +            public Subject<? super T, ? extends T> call() {, +                return OperatorReplay.createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +            }, +            ]