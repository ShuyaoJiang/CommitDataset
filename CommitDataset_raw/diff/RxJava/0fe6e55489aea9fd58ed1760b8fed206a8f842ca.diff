[+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java, +import io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber;, +import io.reactivex.internal.util.ErrorMode;, +, +    @Test(timeout = 10000), +    public void cancelNoConcurrentClean() {, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +        ConcatMapMaybeSubscriber<Integer, Integer> operator =, +                new ConcatMapMaybeSubscriber<Integer, Integer>(, +                        ts, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);, +, +        operator.onSubscribe(new BooleanSubscription());, +, +        operator.queue.offer(1);, +, +        operator.getAndIncrement();, +, +        ts.cancel();, +, +        assertFalse(operator.queue.isEmpty());, +, +        operator.addAndGet(-2);, +, +        operator.cancel();, +, +        assertTrue(operator.queue.isEmpty());, +    }, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, +            if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +            if (getAndIncrement() == 0) {, +++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java, +import io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber;, +import io.reactivex.internal.util.ErrorMode;, +, +    @Test(timeout = 10000), +    public void cancelNoConcurrentClean() {, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +        ConcatMapMaybeSubscriber<Integer, Integer> operator =, +                new ConcatMapMaybeSubscriber<Integer, Integer>(, +                        ts, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);, +, +        operator.onSubscribe(new BooleanSubscription());, +, +        operator.queue.offer(1);, +, +        operator.getAndIncrement();, +, +        ts.cancel();, +, +        assertFalse(operator.queue.isEmpty());, +, +        operator.addAndGet(-2);, +, +        operator.cancel();, +, +        assertTrue(operator.queue.isEmpty());, +    }, +++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java, +import io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber;, +import io.reactivex.internal.util.ErrorMode;, +, +    @Test(timeout = 10000), +    public void cancelNoConcurrentClean() {, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +        ConcatMapSingleSubscriber<Integer, Integer> operator =, +                new ConcatMapSingleSubscriber<Integer, Integer>(, +                        ts, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);]