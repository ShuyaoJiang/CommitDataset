[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  , +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(new rx.Notification[T](value)), +      Notification(new rx.Notification[T](error)), +      Notification(new rx.Notification()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(new rx.Notification[T](value)), +      Notification(new rx.Notification[T](error)), +      Notification(new rx.Notification()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * @param duration, +  def interval(duration: Duration, scheduler: Scheduler): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.interval(duration.length, duration.unit, scheduler)).map(_.longValue()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(new rx.Notification[T](value)), +      Notification(new rx.Notification[T](error)), +      Notification(new rx.Notification()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * @param duration, +  def interval(duration: Duration, scheduler: Scheduler): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.interval(duration.length, duration.unit, scheduler)).map(_.longValue()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +import java.util.Date, +import rx.util.functions.{Action0, Action1, Func2}, +  import rx.lang.scala.ImplicitFunctionConversions._, +  def schedule(action: Scheduler => Subscription): Subscription = {, +    this.schedule[Integer](0, (s: Scheduler, x: Integer) => action(s): Subscription): Subscription, +  }, +, +  /**, +   * Schedules a cancelable action to be executed., +   *, +   * @param state State to pass into the action., +   * @param action Action to schedule., +   * @return a subscription to be able to unsubscribe from action., +   */, +  private [scala] def schedule[T](state: T, action: (Scheduler, T) => Subscription): Subscription = {, +    Subscription(asJavaScheduler.schedule(state, new Func2[rx.Scheduler, T, rx.Subscription] {, +      def call(t1: rx.Scheduler, t2: T): rx.Subscription = {, +        action(Scheduler(t1), t2).asJavaSubscription, +      }, +    })), +  }, +, +  /**, +   * Schedules a cancelable action to be executed in delayTime., +   *, +   * @param action Action to schedule., +   * @param delayTime  Time the action is to be delayed before executing., +   * @return a subscription to be able to unsubscribe from action., +   */, +  def schedule(delayTime: Duration, action: Scheduler => Subscription): Subscription = {, +    this.schedule[Integer](0, (s: Scheduler, x: Integer) => action(s), delayTime: Duration): Subscription, +  }, +, +  /**, +   * Schedules a cancelable action to be executed in delayTime., +   *, +   * @param state, +   *            State to pass into the action., +   * @param action, +   *            Action to schedule., +   * @param delayTime, +   *            Time the action is to be delayed before executing., +   * @return a subscription to be able to unsubscribe from action., +   */, +  private [scala] def schedule[T](state: T, action: (Scheduler, T) => Subscription, delayTime: Duration): Subscription = {, +    Subscription(asJavaScheduler.schedule(state, schedulerActionToFunc2(action), delayTime.length, delayTime.unit)), +  }, +   * @param action The action to execute periodically., +   * @param initialDelay Time to wait before executing the action for the first time., +   * @param period The time interval to wait each time in between executing the action., +   * @return A subscription to be able to unsubscribe from action., +   */, +  def schedule(initialDelay: Duration, period: Duration, action: Scheduler => Subscription): Subscription = {, +    this.schedulePeriodically[Integer](0, (s: Scheduler, x:Integer) => action(s): Subscription, initialDelay: Duration, period: Duration): Subscription, +  }, +]