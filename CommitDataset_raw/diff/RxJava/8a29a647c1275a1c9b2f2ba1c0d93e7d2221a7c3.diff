[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Create an Observable that emits non-overlapping buffered items once the boundary observable emits an item., +     * <p>, +     * Completion of either this or the boundary observable causes the returned observable, +     * to emit the latest buffer and complete., +     * @param <B> the boundary value type (ignored), +     * @param boundary the boundary observable, +     * @return an Observable that emits buffered items once the boundary observable emits an item., +     * @see #buffer(rx.Observable, int) , +     */, +    public <B> Observable<List<T>> buffer(Observable<B> boundary) {, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary));, +    }, +    , +    /**, +     * Create an Observable that emits non-overlapping buffered items once the boundary observable emits an item., +     * <p>, +     * Completion of either this or the boundary observable causes the returned observable, +     * to emit the latest buffer and complete., +     * @param <B> the boundary value type (ignored), +     * @param boundary the boundary observable, +     * @param initialCapacity the initial capacity of each buffer chunk, +     * @return an Observable that emits buffered items once the boundary observable emits an item., +     * @see #buffer(rx.Observable, int) , +     */, +    public <B> Observable<List<T>> buffer(Observable<B> boundary, int initialCapacity) {, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary, initialCapacity));, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Create an Observable that emits non-overlapping buffered items once the boundary observable emits an item., +     * <p>, +     * Completion of either this or the boundary observable causes the returned observable, +     * to emit the latest buffer and complete., +     * @param <B> the boundary value type (ignored), +     * @param boundary the boundary observable, +     * @return an Observable that emits buffered items once the boundary observable emits an item., +     * @see #buffer(rx.Observable, int) , +     */, +    public <B> Observable<List<T>> buffer(Observable<B> boundary) {, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary));, +    }, +    , +    /**, +     * Create an Observable that emits non-overlapping buffered items once the boundary observable emits an item., +     * <p>, +     * Completion of either this or the boundary observable causes the returned observable, +     * to emit the latest buffer and complete., +     * @param <B> the boundary value type (ignored), +     * @param boundary the boundary observable, +     * @param initialCapacity the initial capacity of each buffer chunk, +     * @return an Observable that emits buffered items once the boundary observable emits an item., +     * @see #buffer(rx.Observable, int) , +     */, +    public <B> Observable<List<T>> buffer(Observable<B> boundary, int initialCapacity) {, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary, initialCapacity));, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java, +import java.util.ArrayList;, +    , +    /**, +     * Create a buffer operator with the given observable sequence as the buffer boundary., +     */, +    public static <T, B> OnSubscribeFunc<List<T>> bufferWithBoundaryObservable(Observable<? extends T> source, Observable<B> boundary) {, +        return new BufferWithObservableBoundary<T, B>(source, boundary, 16);, +    }, +    /**, +     * Create a buffer operator with the given observable sequence as the buffer boundary and, +     * with the given initial capacity for buffers., +     */, +    public static <T, B> OnSubscribeFunc<List<T>> bufferWithBoundaryObservable(Observable<? extends T> source, Observable<B> boundary, int initialCapacity) {, +        if (initialCapacity <= 0) {, +            throw new IllegalArgumentException("initialCapacity > 0 required");, +        }, +        return new BufferWithObservableBoundary<T, B>(source, boundary, initialCapacity);, +    }, +    , +    /**, +     * Buffer until an element is emitted from a helper observable., +     * @param <T> the buffered value type, +     */, +    private static final class BufferWithObservableBoundary<T, B> implements OnSubscribeFunc<List<T>> {, +        final Observable<? extends T> source;, +        final Observable<B> boundary;, +        final int initialCapacity;, +, +        public BufferWithObservableBoundary(Observable<? extends T> source, Observable<B> boundary, int initialCapacity) {, +            this.source = source;, +            this.boundary = boundary;, +            this.initialCapacity = initialCapacity;, +        }, +, +        @Override, +        public Subscription onSubscribe(Observer<? super List<T>> t1) {, +            CompositeSubscription csub = new CompositeSubscription();, +            , +            SourceObserver<T> so = new SourceObserver<T>(t1, initialCapacity, csub);]