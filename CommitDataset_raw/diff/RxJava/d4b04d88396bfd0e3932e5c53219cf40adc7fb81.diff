[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.subjects.AsyncSubject;, +     * Returns a {@link ConnectableObservable} that shares a single subscription that contains the last notification only., +     * @return a {@link ConnectableObservable}, +     */, +    public ConnectableObservable<T> publishLast() {, +        return OperationMulticast.multicast(this, AsyncSubject.<T> create());, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.subjects.AsyncSubject;, +     * Returns a {@link ConnectableObservable} that shares a single subscription that contains the last notification only., +     * @return a {@link ConnectableObservable}, +     */, +    public ConnectableObservable<T> publishLast() {, +        return OperationMulticast.multicast(this, AsyncSubject.<T> create());, +    }, +, +    /**, +++ b/rxjava-core/src/test/java/rx/ObservableTests.java, +    public void testPublishLast() throws InterruptedException {, +        final AtomicInteger count = new AtomicInteger();, +        ConnectableObservable<String> connectable = Observable.create(new OnSubscribeFunc<String>() {, +            @Override, +            public Subscription onSubscribe(final Observer<? super String> observer) {, +                count.incrementAndGet();, +                final BooleanSubscription subscription = new BooleanSubscription();, +                new Thread(new Runnable() {, +                    @Override, +                    public void run() {, +                        observer.onNext("first");, +                        observer.onNext("last");, +                        observer.onCompleted();, +                    }, +                }).start();, +                return subscription;, +            }, +        }).publishLast();, +, +        // subscribe once, +        final CountDownLatch latch = new CountDownLatch(1);, +        connectable.subscribe(new Action1<String>() {, +            @Override, +            public void call(String value) {, +                assertEquals("last", value);, +                latch.countDown();, +            }, +        });, +, +        // subscribe twice, +        connectable.subscribe(new Action1<String>() {, +            @Override, +            public void call(String _) {}, +        });, +, +        Subscription subscription = connectable.connect();, +        assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));, +        assertEquals(1, count.get());, +        subscription.unsubscribe();, +    }, +, +    @Test]