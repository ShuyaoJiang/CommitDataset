[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +(defn ^Observable mapcat*, +  "Same as multi-arg mapcat, but input is an Observable of Observables., +, +  See:, +    mapcat, +    clojure.core/mapcat, +  ", +  [f ^Observable xs], +  (->> xs, +       (map* f), +       (concat*))), +, +  If multiple Observables are given, the arguments to f are the first item from, +  each observable, then the second item, etc., +, +  [f & xs], +  (if (clojure.core/next xs), +    (mapcat* f (seq->o xs)), +    ; use built-in flatMap for single-arg case, +    (.flatMap ^Observable (clojure.core/first xs) (iop/fn* f)))), +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +(defn ^Observable mapcat*, +  "Same as multi-arg mapcat, but input is an Observable of Observables., +, +  See:, +    mapcat, +    clojure.core/mapcat, +  ", +  [f ^Observable xs], +  (->> xs, +       (map* f), +       (concat*))), +, +  If multiple Observables are given, the arguments to f are the first item from, +  each observable, then the second item, etc., +, +  [f & xs], +  (if (clojure.core/next xs), +    (mapcat* f (seq->o xs)), +    ; use built-in flatMap for single-arg case, +    (.flatMap ^Observable (clojure.core/first xs) (iop/fn* f)))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +(deftest test-mapcat*, +  (let [f (fn [a b c d e], +            [(+ a b) (+ c d) e])], +    (is (= (->> (range 5), +                (map (fn [_] (range 5))), +                (apply mapcat f)), +           (->> (range 5), +                (map (fn [_] (rx/seq->o (range 5)))), +                (rx/seq->o), +                (rx/mapcat* (fn [& args] (rx/seq->o (apply f args)))), +                (b/into [])))))), +, +           (b/into [] (rx/mapcat (comp rx/seq->o f) (rx/seq->o xs)))))), +, +  (let [f  (fn [a b] [a b (* a b)]), +        as (range 10), +        bs (range 15)], +    (is (= (mapcat f as bs), +           (b/into [] (rx/mapcat (comp rx/seq->o f), +                                 (rx/seq->o as), +                                 (rx/seq->o bs)))))))]