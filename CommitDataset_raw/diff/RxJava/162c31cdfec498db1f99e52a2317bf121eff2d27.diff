[+++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()) {, +        }, +                    int emitted = s.drainQueue();, +                long emitted = 0;, +                // request upstream what we just emitted, +                if(emitted > 0) {, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()) {, +        }, +                    int emitted = s.drainQueue();, +                long emitted = 0;, +                // request upstream what we just emitted, +                if(emitted > 0) {, +++ b/src/test/java/rx/internal/operators/OperatorMergeTest.java, +import java.util.concurrent.ConcurrentLinkedQueue;, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Subscriber;, +import rx.Subscription;, +    , +    @Test, +    public void testMergeKeepsRequesting() throws InterruptedException {, +        //for (int i = 0; i < 5000; i++) {, +            //System.out.println(i + ".......................................................................");, +            final CountDownLatch latch = new CountDownLatch(1);, +            final ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<String>();, +, +            Observable.range(1, 2), +                    // produce many integers per second, +                    .flatMap(new Func1<Integer, Observable<Integer>>() {, +                        @Override, +                        public Observable<Integer> call(final Integer number) {, +                            return Observable.range(1, Integer.MAX_VALUE), +                                    .doOnRequest(new Action1<Long>() {, +, +                                        @Override, +                                        public void call(Long n) {, +                                            messages.add(">>>>>>>> A requested[" + number + "]: " + n);, +                                        }, +, +                                    }), +                                    // pause a bit, +                                    .doOnNext(pauseForMs(3)), +                                    // buffer on backpressure, +                                    .onBackpressureBuffer(), +                                    // do in parallel, +                                    .subscribeOn(Schedulers.computation()), +                                    .doOnRequest(new Action1<Long>() {, +, +                                        @Override, +                                        public void call(Long n) {, +                                            messages.add(">>>>>>>> B requested[" + number + "]: " + n);, +                                        }, +, +                                    });, +                        }, +, +                    }), +                    // take a number bigger than 2* RxRingBuffer.SIZE (used by OperatorMerge), +                    .take(RxRingBuffer.SIZE * 2 + 1), +                    // log count, +                    .doOnNext(printCount()), +                    // release latch, +                    .doOnCompleted(new Action0() {, +                        @Override, +                        public void call() {, +                            latch.countDown();, +                        }, +                    }).subscribe();, +            boolean a = latch.await(2, TimeUnit.SECONDS);, +            if (!a) {, +                for (String s : messages) {, +                    System.out.println("DEBUG => " + s);, +                }, +            }, +            assertTrue(a);, +        //}, +    }, +, +    private static Action1<Integer> printCount() {, +        return new Action1<Integer>() {, +            long count;, +, +            @Override, +            public void call(Integer t1) {, +                count++;, +                System.out.println("count=" + count);, +            }, +        };, +    }, +, +    private static Action1<Integer> pauseForMs(final long time) {, +        return new Action1<Integer>() {, +            @Override, +            public void call(Integer s) {, +                try {, +                    Thread.sleep(time);]