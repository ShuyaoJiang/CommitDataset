[+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +import io.reactivex.annotations.*;, + * Note that due to concurrency requirements, a size- and time-bounded {@code ReplaySubject} may hold strong references to more, + * source emissions than specified while it isn't terminated yet. Use the {@link #cleanupBuffer()} to allow, + * such inaccessible items to be cleaned up by GC once no consumer references it anymore., +    /**, +     * Makes sure the item cached by the head node in a bounded, +     * ReplaySubject is released (as it is never part of a replay)., +     * <p>, +     * By default, live bounded buffers will remember one item before, +     * the currently receivable one to ensure subscribers can always, +     * receive a continuous sequence of items. A terminated ReplaySubject, +     * automatically releases this inaccessible item., +     * <p>, +     * The method must be called sequentially, similar to the standard, +     * {@code onXXX} methods., +     * @since 2.1.11 - experimental, +     */, +    @Experimental, +    public void cleanupBuffer() {, +        buffer.trimHead();, +    }, +, +, +        /**, +         * Make sure an old inaccessible head value is released, +         * in a bounded buffer., +         */, +        void trimHead();, +            trimHead();, +        public void trimHead() {, +            // no-op in this type of buffer, +        }, +, +        @Override, +            trimHead();, +        /**, +         * Replace a non-empty head node with an empty one to, +         * allow the GC of the inaccessible old value., +         */, +        @Override, +        public void trimHead() {, +            Node<Object> h = head;, +            if (h.value != null) {, +                Node<Object> n = new Node<Object>(null);, +                n.lazySet(h.get());, +                head = n;, +            }, +        }, +, +                    if (h.value != null) {, +                        TimedNode<Object> lasth = new TimedNode<Object>(null, 0L);, +                        lasth.lazySet(h.get());, +                        head = lasth;, +                    } else {, +                    }, +                    if (h.value != null) {, +                        TimedNode<Object> lasth = new TimedNode<Object>(null, 0L);, +                        lasth.lazySet(h.get());, +                        head = lasth;, +                    } else {, +                    }, +        /**, +         * Replace a non-empty head node with an empty one to, +         * allow the GC of the inaccessible old value., +         */, +        @Override, +        public void trimHead() {, +            TimedNode<Object> h = head;, +            if (h.value != null) {, +                TimedNode<Object> n = new TimedNode<Object>(null, 0);, +                n.lazySet(h.get());, +                head = n;, +            }, +        }, +, +++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +import io.reactivex.annotations.*;, + * Note that due to concurrency requirements, a size- and time-bounded {@code ReplaySubject} may hold strong references to more, + * source emissions than specified while it isn't terminated yet. Use the {@link #cleanupBuffer()} to allow, + * such inaccessible items to be cleaned up by GC once no consumer references it anymore., +    /**, +     * Makes sure the item cached by the head node in a bounded, +     * ReplaySubject is released (as it is never part of a replay)., +     * <p>, +     * By default, live bounded buffers will remember one item before, +     * the currently receivable one to ensure subscribers can always, +     * receive a continuous sequence of items. A terminated ReplaySubject, +     * automatically releases this inaccessible item., +     * <p>, +     * The method must be called sequentially, similar to the standard, +     * {@code onXXX} methods., +     * @since 2.1.11 - experimental, +     */, +    @Experimental, +    public void cleanupBuffer() {, +        buffer.trimHead();, +    }, +, +]