[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}., +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}., +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +        Iterator<? extends T> it = this.toIterable().iterator();, +, +        if (!it.hasNext()) {, +            return defaultValue;, +        }, +, +        T result = it.next();, +        if (it.hasNext()) {, +            throw new IllegalArgumentException("Sequence contains too many elements");, +        }, +        return result;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}., +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +        Iterator<? extends T> it = this.toIterable().iterator();, +, +        if (!it.hasNext()) {, +            return defaultValue;, +        }, +, +        T result = it.next();, +        if (it.hasNext()) {, +            throw new IllegalArgumentException("Sequence contains too many elements");, +        }, +        return result;, +++ b/rxjava-core/src/main/java/rx/operators/BlockingOperatorLatest.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +        volatile Notification<? extends T> value;, +        /** Updater for the value field. */, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<LatestObserverIterator, Notification> REFERENCE_UPDATER, +                = AtomicReferenceFieldUpdater.newUpdater(LatestObserverIterator.class, Notification.class, "value");, +            boolean wasntAvailable = REFERENCE_UPDATER.getAndSet(this, args) == null;, +                    @SuppressWarnings("unchecked"), +                    Notification<? extends T> n = (Notification<? extends T>)REFERENCE_UPDATER.getAndSet(this, null);, +                    iNotif = n;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}., +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +        Iterator<? extends T> it = this.toIterable().iterator();, +, +        if (!it.hasNext()) {, +            return defaultValue;, +        }, +, +        T result = it.next();, +        if (it.hasNext()) {, +            throw new IllegalArgumentException("Sequence contains too many elements");, +        }, +        return result;, +++ b/rxjava-core/src/main/java/rx/operators/BlockingOperatorLatest.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +        volatile Notification<? extends T> value;, +        /** Updater for the value field. */, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<LatestObserverIterator, Notification> REFERENCE_UPDATER, +                = AtomicReferenceFieldUpdater.newUpdater(LatestObserverIterator.class, Notification.class, "value");, +            boolean wasntAvailable = REFERENCE_UPDATER.getAndSet(this, args) == null;, +                    @SuppressWarnings("unchecked"), +                    Notification<? extends T> n = (Notification<? extends T>)REFERENCE_UPDATER.getAndSet(this, null);, +                    iNotif = n;, +++ b/rxjava-core/src/main/java/rx/operators/BlockingOperatorMostRecent.java, +        static final NotificationLite<Object> nl = NotificationLite.instance();, +        volatile Object value;, +            this.value = nl.next(value);, +            value = nl.completed();, +            value = nl.error(e);, +            value = nl.next(args);, +            return nl.isCompleted(value);, +            Object v = value;, +            return nl.isError(v) ? nl.getError(v) : null;, +        @SuppressWarnings("unchecked"), +            return (T)value;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}., +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +        Iterator<? extends T> it = this.toIterable().iterator();, +, +        if (!it.hasNext()) {, +            return defaultValue;, +        }, +, +        T result = it.next();, +        if (it.hasNext()) {, +            throw new IllegalArgumentException("Sequence contains too many elements");, +        }, +        return result;, +++ b/rxjava-core/src/main/java/rx/operators/BlockingOperatorLatest.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +        volatile Notification<? extends T> value;, +        /** Updater for the value field. */, +        @SuppressWarnings("rawtypes"), +        static final AtomicReferenceFieldUpdater<LatestObserverIterator, Notification> REFERENCE_UPDATER, +                = AtomicReferenceFieldUpdater.newUpdater(LatestObserverIterator.class, Notification.class, "value");, +            boolean wasntAvailable = REFERENCE_UPDATER.getAndSet(this, args) == null;]