[+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +import java.util.concurrent.atomic.AtomicLong;, +import rx.*;, +    private static final class IterableProducer<T> extends AtomicLong implements Producer {, +        /** */, +        private static final long serialVersionUID = -8730475647105475802L;, +            if (get() == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && compareAndSet(0, Long.MAX_VALUE)) {, +                fastpath();, +            } else , +            if (n > 0 && BackpressureUtils.getAndAddRequest(this, n) == 0L) {, +                slowpath(n);, +            }, +, +        void slowpath(long n) {, +            final Subscriber<? super T> o = this.o;, +            final Iterator<? extends T> it = this.it;, +, +            long r = n;, +                r = addAndGet(-r);, +                if (r == 0L) {, +        void fastpath() {, +            // fast-path without backpressure, +            final Subscriber<? super T> o = this.o;, +            final Iterator<? extends T> it = this.it;, +, +            while (true) {, +                if (o.isUnsubscribed()) {, +                    return;, +                } else if (it.hasNext()) {, +                    o.onNext(it.next());, +                } else if (!o.isUnsubscribed()) {, +                    o.onCompleted();, +                    return;, +                } else {, +                    // is unsubscribed, +                    return;, +                }, +            }, +++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +import java.util.concurrent.atomic.AtomicLong;, +import rx.*;, +    private static final class IterableProducer<T> extends AtomicLong implements Producer {, +        /** */, +        private static final long serialVersionUID = -8730475647105475802L;, +            if (get() == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && compareAndSet(0, Long.MAX_VALUE)) {, +                fastpath();, +            } else , +            if (n > 0 && BackpressureUtils.getAndAddRequest(this, n) == 0L) {, +                slowpath(n);, +            }, +, +        void slowpath(long n) {, +            final Subscriber<? super T> o = this.o;, +            final Iterator<? extends T> it = this.it;, +, +            long r = n;, +                r = addAndGet(-r);, +                if (r == 0L) {, +        void fastpath() {, +            // fast-path without backpressure, +            final Subscriber<? super T> o = this.o;, +            final Iterator<? extends T> it = this.it;, +, +            while (true) {, +                if (o.isUnsubscribed()) {, +                    return;, +                } else if (it.hasNext()) {, +                    o.onNext(it.next());, +                } else if (!o.isUnsubscribed()) {, +                    o.onCompleted();, +                    return;, +                } else {, +                    // is unsubscribed, +                    return;, +                }, +            }, +++ b/src/perf/java/rx/operators/FromIterablePerf.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package rx.operators;, +, +import java.util.Arrays;, +import java.util.concurrent.TimeUnit;, +]