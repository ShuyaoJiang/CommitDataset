[+++ b/src/main/java/rx/Observable.java, +import rx.annotations.Experimental;, +    @SuppressWarnings("unchecked"), +     * Instructs an Observable that is emitting items faster than its observer can consume them is to, +     * block the producer thread., +     * <p>, +     * The producer side can emit up to {@code maxQueueLength} onNext elements without blocking, but the, +     * consumer side considers the amount its downstream requested through {@code Producer.request(n)}, +     * and doesn't emit more than requested even if more is available. For example, using , +     * {@code onBackpressureBlock(384).observeOn(Schedulers.io())} will not throw a MissingBackpressureException., +     * <p>, +     * Note that if the upstream Observable does support backpressure, this operator ignores that capability, +     * and doesn't propagate any backpressure requests from downstream., +     *  , +     * @param maxQueueLength the maximum number of items the producer can emit without blocking, +     * @return the source Observable modified to block {@code onNext} notifications on overflow, +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>, +     * @Experimental The behavior of this can change at any time. , +     */, +    @Experimental, +    public final Observable<T> onBackpressureBlock(int maxQueueLength) {, +        return lift(new OperatorOnBackpressureBlock<T>(maxQueueLength));, +    }, +    /**, +     * Instructs an Observable that is emitting items faster than its observer can consume them is to, +     * block the producer thread if the number of undelivered onNext events reaches the system-wide ring buffer size., +     * <p>, +     * The producer side can emit up to the system-wide ring buffer size onNext elements without blocking, but the, +     * consumer side considers the amount its downstream requested through {@code Producer.request(n)}, +     * and doesn't emit more than requested even if available., +     * <p>, +     * Note that if the upstream Observable does support backpressure, this operator ignores that capability, +     * and doesn't propagate any backpressure requests from downstream., +     * , +     * @return the source Observable modified to block {@code onNext} notifications on overflow, +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>, +     * @Experimental The behavior of this can change at any time. , +     */, +    @Experimental, +    public final Observable<T> onBackpressureBlock() {, +        return onBackpressureBlock(rx.internal.util.RxRingBuffer.SIZE);, +    }, +    , +    /**, +++ b/src/main/java/rx/Observable.java, +import rx.annotations.Experimental;, +    @SuppressWarnings("unchecked"), +     * Instructs an Observable that is emitting items faster than its observer can consume them is to, +     * block the producer thread., +     * <p>, +     * The producer side can emit up to {@code maxQueueLength} onNext elements without blocking, but the, +     * consumer side considers the amount its downstream requested through {@code Producer.request(n)}, +     * and doesn't emit more than requested even if more is available. For example, using , +     * {@code onBackpressureBlock(384).observeOn(Schedulers.io())} will not throw a MissingBackpressureException., +     * <p>, +     * Note that if the upstream Observable does support backpressure, this operator ignores that capability, +     * and doesn't propagate any backpressure requests from downstream., +     *  , +     * @param maxQueueLength the maximum number of items the producer can emit without blocking, +     * @return the source Observable modified to block {@code onNext} notifications on overflow, +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>, +     * @Experimental The behavior of this can change at any time. , +     */, +    @Experimental, +    public final Observable<T> onBackpressureBlock(int maxQueueLength) {, +        return lift(new OperatorOnBackpressureBlock<T>(maxQueueLength));, +    }, +    /**, +     * Instructs an Observable that is emitting items faster than its observer can consume them is to, +     * block the producer thread if the number of undelivered onNext events reaches the system-wide ring buffer size., +     * <p>, +     * The producer side can emit up to the system-wide ring buffer size onNext elements without blocking, but the, +     * consumer side considers the amount its downstream requested through {@code Producer.request(n)}, +     * and doesn't emit more than requested even if available., +     * <p>, +     * Note that if the upstream Observable does support backpressure, this operator ignores that capability, +     * and doesn't propagate any backpressure requests from downstream., +     * , +     * @return the source Observable modified to block {@code onNext} notifications on overflow, +     * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>, +     * @Experimental The behavior of this can change at any time. , +     */, +    @Experimental, +    public final Observable<T> onBackpressureBlock() {, +        return onBackpressureBlock(rx.internal.util.RxRingBuffer.SIZE);, +    }, +    , +    /**, +++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,]