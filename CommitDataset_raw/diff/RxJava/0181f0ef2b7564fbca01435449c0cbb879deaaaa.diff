[+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.junit.Before;, +import org.mockito.InOrder;, +import rx.Observable;, +import rx.concurrency.TestScheduler;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action0;, +        private final AtomicBoolean complete = new AtomicBoolean();, +            scheduler.schedule(new IntervalAction(observer), interval, unit);, +            return Subscriptions.create(new Action0() {, +              public void call() {, +                complete.set(true);, +              }, +            });, +        }, +        , +        private class IntervalAction implements Action0 {, +            private final Observer<Long> observer;, +            , +            private IntervalAction(Observer<Long> observer) {, +                this.observer = observer;, +            }, +            , +            @Override, +            public void call() {, +                if (complete.get()) {, +                    observer.onCompleted();, +                } else {, +                    scheduler.schedule(this, interval, unit);, +            }, +        private TestScheduler scheduler;, +        private Observer<Long> observer;, +        , +        @Before, +        @SuppressWarnings("unchecked") // due to mocking, +        public void before() {, +            scheduler = new TestScheduler();, +            observer = mock(Observer.class);, +        }, +        , +        @Test, +        public void testInterval() {, +            Observable<Long> w = Observable.create(OperationInterval.interval(1, TimeUnit.SECONDS, scheduler));, +            Subscription sub = w.subscribe(observer);, +            , +            verify(observer, never()).onNext(0L);, +            verify(observer, never()).onCompleted();, +            verify(observer, never()).onError(any(Exception.class));, +            , +            scheduler.advanceTimeTo(2, TimeUnit.SECONDS);, +, +            InOrder inOrder = inOrder(observer);, +            inOrder.verify(observer, times(1)).onNext(0L);, +            inOrder.verify(observer, times(1)).onNext(1L);, +            inOrder.verify(observer, never()).onNext(2L);, +            verify(observer, never()).onCompleted();, +            verify(observer, never()).onError(any(Exception.class));, +            , +            sub.unsubscribe();, +            scheduler.advanceTimeTo(4, TimeUnit.SECONDS);, +            verify(observer, never()).onNext(2L);, +            verify(observer, times(1)).onCompleted();, +            verify(observer, never()).onError(any(Exception.class));, +        }, +++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.junit.Before;, +import org.mockito.InOrder;, +import rx.Observable;, +import rx.concurrency.TestScheduler;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action0;, +        private final AtomicBoolean complete = new AtomicBoolean();, +            scheduler.schedule(new IntervalAction(observer), interval, unit);, +            return Subscriptions.create(new Action0() {, +              public void call() {, +                complete.set(true);, +              }, +            });, +        }, +        , +        private class IntervalAction implements Action0 {, +            private final Observer<Long> observer;, +            , +            private IntervalAction(Observer<Long> observer) {, +                this.observer = observer;, +            }, +            , +            @Override, +            public void call() {, +                if (complete.get()) {, +                    observer.onCompleted();, +                } else {, +                    scheduler.schedule(this, interval, unit);, +            }, +        private TestScheduler scheduler;, +        private Observer<Long> observer;, +        , +        @Before]