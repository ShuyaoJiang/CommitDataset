[+++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +                if (wip == 0 && (scalarValueQueue == null || scalarValueQueue.isEmpty())) {, +                if (ms.drainQueuesIfNeeded()) {, +                    if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {, +                        ms.drainAndComplete();, +                    }, +                }, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +                if (wip == 0 && (scalarValueQueue == null || scalarValueQueue.isEmpty())) {, +                if (ms.drainQueuesIfNeeded()) {, +                    if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {, +                        ms.drainAndComplete();, +                    }, +                }, +++ b/src/test/java/rx/internal/operators/OperatorMergeTest.java, +import static java.util.Arrays.asList;, +import rx.*;, +    @Test, +    public void shouldCompleteAfterApplyingBackpressure_NormalPath() {, +        Observable<Integer> source = Observable.mergeDelayError(Observable.just(Observable.range(1, 2)));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(0);, +        source.subscribe(subscriber);, +        subscriber.requestMore(3); // 1, 2, <complete> - with requestMore(2) we get the 1 and 2 but not the <complete>, +        subscriber.assertReceivedOnNext(asList(1, 2));, +        subscriber.assertTerminalEvent();, +    }, +, +    @Test, +    public void shouldCompleteAfterApplyingBackpressure_FastPath() {, +        Observable<Integer> source = Observable.mergeDelayError(Observable.just(Observable.just(1)));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(0);, +        source.subscribe(subscriber);, +        subscriber.requestMore(2); // 1, <complete> - should work as per .._NormalPath above, +        subscriber.assertReceivedOnNext(asList(1));, +        subscriber.assertTerminalEvent();, +    }, +, +    @Test, +    public void shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes() {, +        TestScheduler scheduler = Schedulers.test();, +        Observable<Long> source = Observable.mergeDelayError(Observable.just(1L), Observable.timer(1, TimeUnit.SECONDS, scheduler).skip(1));, +        TestSubscriber<Long> subscriber = new TestSubscriber<Long>();, +        subscriber.requestMore(0);, +        source.subscribe(subscriber);, +        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);, +        subscriber.assertReceivedOnNext(Collections.<Long>emptyList());, +        assertEquals(Collections.<Notification<Long>>emptyList(), subscriber.getOnCompletedEvents());, +        subscriber.requestMore(1);, +        subscriber.assertReceivedOnNext(asList(1L));, +        assertEquals(Collections.<Notification<Long>>emptyList(), subscriber.getOnCompletedEvents());, +        subscriber.requestMore(1);, +        subscriber.assertTerminalEvent();, +    }, +, +    @Test, +    public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_NormalPath() {, +        Throwable exception = new Throwable();, +        Observable<Integer> source = Observable.mergeDelayError(Observable.range(1, 2), Observable.<Integer>error(exception));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(0);, +        source.subscribe(subscriber);, +        subscriber.requestMore(3); // 1, 2, <error>, +        subscriber.assertReceivedOnNext(asList(1, 2));, +        subscriber.assertTerminalEvent();, +        assertEquals(asList(exception), subscriber.getOnErrorEvents());, +    }, +, +    @Test, +    public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_FastPath() {, +        Throwable exception = new Throwable();, +        Observable<Integer> source = Observable.mergeDelayError(Observable.just(1), Observable.<Integer>error(exception));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(0);, +        source.subscribe(subscriber);, +        subscriber.requestMore(2); // 1, <error>, +        subscriber.assertReceivedOnNext(asList(1));, +        subscriber.assertTerminalEvent();, +        assertEquals(asList(exception), subscriber.getOnErrorEvents());, +    }, +, +    @Test, +    public void shouldNotCompleteWhileThereAreStillScalarSynchronousEmissionsInTheQueue() {, +        Observable<Integer> source = Observable.merge(Observable.just(1), Observable.just(2));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(1);, +        source.subscribe(subscriber);, +        subscriber.assertReceivedOnNext(asList(1));, +        subscriber.requestMore(1);, +        subscriber.assertReceivedOnNext(asList(1, 2));, +    }, +, +    @Test, +    public void shouldNotReceivedDelayedErrorWhileThereAreStillScalarSynchronousEmissionsInTheQueue() {, +        Throwable exception = new Throwable();, +        Observable<Integer> source = Observable.mergeDelayError(Observable.just(1), Observable.just(2), Observable.<Integer>error(exception));, +        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();, +        subscriber.requestMore(1);, +        source.subscribe(subscriber);]