[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def tumblingBufferExample() {, +    o.tumblingBuffer(boundary).toBlocking.foreach((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  }, +, +  @Test def slidingBufferExample() {, +    val open = Observable.interval(300 millis), +    val closing = Observable.interval(600 millis), +    val o = Observable.interval(100 millis).take(20).slidingBuffer(open)(_ => closing), +    o.zipWithIndex.toBlocking.foreach {, +      case (seq, i) => println(s"Observable#$i emits $seq"), +    }, +  @Test def tumblingExample() {, +    (for ((o, i) <- o.tumbling(windowObservable).zipWithIndex; n <- o), +      yield s"Observable#$i emits $n", +    ).toBlocking.foreach(println), +  }, +, +  @Test def slidingExample() {, +    val open = Observable.interval(300 millis), +    val closing = Observable.interval(600 millis), +    val o = Observable.interval(100 millis).take(20).sliding(open)(_ => closing), +    (for ((o, i) <- o.zipWithIndex;, +          n <- o), +    val grouped = numbers.groupByUntil(x => x % 2){ case (key, obs) => obs.filter(x => x == 7) }, +    val grouped = numbers.groupByUntil(x => x % 2, x => x * 10){ case (key, obs) => Observable.interval(2 seconds) }, +    val combinedCounter = firstCounter.combineLatestWith(secondCounter)(List(_, _)) take 10, +    val combinedCounter = Observable.combineLatest(sources)(_.toList).take(10), +  @Test def zipWithExample() {, +    val xs = Observable.items(1, 3, 5, 7), +    val ys = Observable.items(2, 4, 6, 8), +    xs.zipWith(ys)(_ * _).subscribe(println(_)), +  }, +, +    val shared = unshared.multicast(Subject[Int]()), +    val shared = unshared.multicast(() => Subject[Int]())(o => o.map("No. " + _)), +    o.flatMapWith(_ => Observable.interval(200 millis).take(5))(_ * _).toBlocking.foreach(println), +    o.flatMapIterableWith(_=> (1 to 5))(_ * _).toBlocking.foreach(println), +    val o = o1.join(o2)(_ => Observable.timer(300 millis), _ => Observable.timer(200 millis), (_, _)), +    val o = o1.groupJoin(o2)(_ => Observable.timer(300 millis), _ => Observable.timer(200 millis), (t1, t2) => (t1, t2.toSeq.toBlocking.single)), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def tumblingBufferExample() {, +    o.tumblingBuffer(boundary).toBlocking.foreach((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  }, +, +  @Test def slidingBufferExample() {, +    val open = Observable.interval(300 millis), +    val closing = Observable.interval(600 millis), +    val o = Observable.interval(100 millis).take(20).slidingBuffer(open)(_ => closing), +    o.zipWithIndex.toBlocking.foreach {, +      case (seq, i) => println(s"Observable#$i emits $seq"), +    }, +  @Test def tumblingExample() {, +    (for ((o, i) <- o.tumbling(windowObservable).zipWithIndex; n <- o), +      yield s"Observable#$i emits $n", +    ).toBlocking.foreach(println), +  }, +, +  @Test def slidingExample() {, +    val open = Observable.interval(300 millis), +    val closing = Observable.interval(600 millis), +    val o = Observable.interval(100 millis).take(20).sliding(open)(_ => closing), +    (for ((o, i) <- o.zipWithIndex;, +          n <- o), +    val grouped = numbers.groupByUntil(x => x % 2){ case (key, obs) => obs.filter(x => x == 7) }, +    val grouped = numbers.groupByUntil(x => x % 2, x => x * 10){ case (key, obs) => Observable.interval(2 seconds) }, +    val combinedCounter = firstCounter.combineLatestWith(secondCounter)(List(_, _)) take 10, +    val combinedCounter = Observable.combineLatest(sources)(_.toList).take(10), +  @Test def zipWithExample() {, +    val xs = Observable.items(1, 3, 5, 7), +    val ys = Observable.items(2, 4, 6, 8), +    xs.zipWith(ys)(_ * _).subscribe(println(_)), +  }, +, +    val shared = unshared.multicast(Subject[Int]()), +    val shared = unshared.multicast(() => Subject[Int]())(o => o.map("No. " + _)), +    o.flatMapWith(_ => Observable.interval(200 millis).take(5))(_ * _).toBlocking.foreach(println), +    o.flatMapIterableWith(_=> (1 to 5))(_ * _).toBlocking.foreach(println), +    val o = o1.join(o2)(_ => Observable.timer(300 millis), _ => Observable.timer(200 millis), (_, _)), +    val o = o1.groupJoin(o2)(_ => Observable.timer(300 millis), _ => Observable.timer(200 millis), (t1, t2) => (t1, t2.toSeq.toBlocking.single)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T, U](subjectFactory: () => rx.lang.scala.Subject[R])(selector: Observable[R] => Observable[U]): Observable[U] = {, +    zipWith(that)((_, _)), +   * @param that the Iterable sequence, +  def zip[U](that: Iterable[U]): Observable[(T, U)] = {, +    zipWith(that)((_, _)), +   * @param that the Iterable sequence, +  def zipWith[U, R](that: Iterable[U])(selector: (T, U) => R): Observable[R] = {, +    toScalaObservable[R](thisJava.zip(that.asJava, selector)), +  def zipWith[U, R](that: Observable[U])(selector: (T, U) => R): Observable[R] = {, +  def slidingBuffer[Opening](openings: Observable[Opening])(closings: Opening => Observable[Any]): Observable[Seq[T]] = {, +  def tumblingBuffer(boundary: => Observable[Any]): Observable[Seq[T]] = {, +  def tumblingBuffer(boundary: Observable[Any], initialCapacity: Int): Observable[Seq[T]] = {, +  def tumbling(boundary: => Observable[Any]): Observable[Observable[T]] = {, +  def sliding[Opening](openings: Observable[Opening])(closings: Opening => Observable[Any]) = {, +  def flatMapWith[U, R](collectionSelector: T => Observable[U])(resultSelector: (T, U) => R): Observable[R] = {, +  def flatMapIterableWith[U, R](collectionSelector: T => Iterable[U])(resultSelector: (T, U) => R): Observable[R] = {, +  def groupByUntil[K](f: T => K)(closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = {, +  def groupByUntil[K, V](keySelector: T => K, valueSelector: T => V)(closings: (K, Observable[V]) => Observable[Any]): Observable[(K, Observable[V])] = {, +  def join[S, R] (other: Observable[S])(leftDurationSelector:  T => Observable[Any], rightDurationSelector: S => Observable[Any], resultSelector: (T, S) => R): Observable[R] = {]