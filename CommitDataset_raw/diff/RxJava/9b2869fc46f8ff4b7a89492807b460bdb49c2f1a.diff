[+++ b/src/main/java/io/reactivex/Observable.java, +        return (new ObservableAmb<T>(null, sources));, +        return (new ObservableAmb<T>(sources, null));, +        return (new ObservableCombineLatest<T, R>(null, sources, combiner, s, delayError));, +        return (new ObservableCombineLatest<T, R>(sources, null, combiner, s, delayError));, +        return new ObservableLift<T, ObservableConsumable<? extends T>>(sources, new NbpOperatorConcatMap(Functions.identity(), bufferSize));, +        return (new ObservableDefer<T>(supplier));, +        return (new ObservableError<T>(errorSupplier));, +        return (new ObservableFromArray<T>(values));, +        return (new ObservableFromCallable<T>(supplier));, +        return (new ObservableFromFuture<T>(future, 0L, null));, +        Observable<T> o = create(new ObservableFromFuture<T>(future, timeout, unit));, +        return (new ObservableFromIterable<T>(source));, +        return (new ObservableGenerate<T, S>(initialState, generator, disposeState));, +        return (new ObservableInterval(initialDelay, period, unit, scheduler));, +        return (new ObservableIntervalRange(start, end, initialDelay, period, unit, scheduler));, +        return new ObservableJust<T>(value);, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), false, Integer.MAX_VALUE, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), false, maxConcurrency, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), true, Integer.MAX_VALUE, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), true, maxConcurrency, bufferSize()));, +        return (new ObservableSequenceEqual<T>(p1, p2, isEqual, bufferSize));, +        return new ObservableLift(sources, new NbpOperatorSwitchMap(Functions.identity(), bufferSize));, +        return (new ObservableTimer(delay, unit, scheduler));, +        return (new ObservableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager));, +        return (new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false));, +        return new ObservableLift(sources, NbpOperatorToList.<T>defaultInstance()), +        return (new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));, +        return (new ObservableZip<T, R>(null, sources, zipper, bufferSize, delayError));, +        return ObservableCache.from(this);, +        return ObservableCache.from(this, capacityHint);, +        return wrap(to(convert));, +        return (new ObservableDelaySubscriptionOther<T, U>(this, other));, +        if (this instanceof ObservableJust) {, +            ObservableJust<T> scalar = (ObservableJust<T>) this;, +            return (scalar.scalarFlatMap(mapper));, +        return (new ObservableLift<R, T>(this, onLift));, +        return (new ObservableRepeat<T>(this, times));, +        return (new ObservableRepeatUntil<T>(this, stop));, +        return (new ObservableRedo<T>(this, f));, +        return (new ObservableRetryBiPredicate<T>(this, predicate));, +        return (new ObservableRetryPredicate<T>(this, times, predicate));, +        return (new ObservableRedo<T>(this, f));, +        return (new ObservableSubscribeOn<T>(this, scheduler));, +        return (new ObservableZipIterable<T, U, R>(this, other, zipper));, +++ b/src/main/java/io/reactivex/Observable.java, +        return (new ObservableAmb<T>(null, sources));, +        return (new ObservableAmb<T>(sources, null));, +        return (new ObservableCombineLatest<T, R>(null, sources, combiner, s, delayError));, +        return (new ObservableCombineLatest<T, R>(sources, null, combiner, s, delayError));, +        return new ObservableLift<T, ObservableConsumable<? extends T>>(sources, new NbpOperatorConcatMap(Functions.identity(), bufferSize));, +        return (new ObservableDefer<T>(supplier));, +        return (new ObservableError<T>(errorSupplier));, +        return (new ObservableFromArray<T>(values));, +        return (new ObservableFromCallable<T>(supplier));, +        return (new ObservableFromFuture<T>(future, 0L, null));, +        Observable<T> o = create(new ObservableFromFuture<T>(future, timeout, unit));, +        return (new ObservableFromIterable<T>(source));, +        return (new ObservableGenerate<T, S>(initialState, generator, disposeState));, +        return (new ObservableInterval(initialDelay, period, unit, scheduler));, +        return (new ObservableIntervalRange(start, end, initialDelay, period, unit, scheduler));, +        return new ObservableJust<T>(value);, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), false, Integer.MAX_VALUE, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), false, maxConcurrency, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), true, Integer.MAX_VALUE, bufferSize()));, +        return new ObservableLift(sources, new NbpOperatorFlatMap(Functions.identity(), true, maxConcurrency, bufferSize()));, +        return (new ObservableSequenceEqual<T>(p1, p2, isEqual, bufferSize));, +        return new ObservableLift(sources, new NbpOperatorSwitchMap(Functions.identity(), bufferSize));, +        return (new ObservableTimer(delay, unit, scheduler));, +        return (new ObservableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager));, +        return (new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false));, +        return new ObservableLift(sources, NbpOperatorToList.<T>defaultInstance()), +        return (new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));, +        return (new ObservableZip<T, R>(null, sources, zipper, bufferSize, delayError));, +        return ObservableCache.from(this);, +        return ObservableCache.from(this, capacityHint);, +        return wrap(to(convert));, +        return (new ObservableDelaySubscriptionOther<T, U>(this, other));, +        if (this instanceof ObservableJust) {, +            ObservableJust<T> scalar = (ObservableJust<T>) this;, +            return (scalar.scalarFlatMap(mapper));, +        return (new ObservableLift<R, T>(this, onLift));, +        return (new ObservableRepeat<T>(this, times));, +        return (new ObservableRepeatUntil<T>(this, stop));, +        return (new ObservableRedo<T>(this, f));, +        return (new ObservableRetryBiPredicate<T>(this, predicate));, +        return (new ObservableRetryPredicate<T>(this, times, predicate));, +        return (new ObservableRedo<T>(this, f));, +        return (new ObservableSubscribeOn<T>(this, scheduler));, +        return (new ObservableZipIterable<T, U, R>(this, other, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is]