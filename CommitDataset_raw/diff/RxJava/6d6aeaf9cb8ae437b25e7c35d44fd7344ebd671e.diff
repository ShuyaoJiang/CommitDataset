[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * `onError`. An `onError` notification from the source will result in the emission of a, +   * [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `retry` will call, +   * `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   * <pre>, +   * </pre>, +   * <pre>, +   * </pre>, +   *  <dd>`retryWhen` operates by default on the `trampoline` [[Scheduler]].</dd>, +   * Returns an Observable that emits the same values as the source observable with the exception of an `onError`., +   * An onError will emit a [[Notification]] to the observable provided as an argument to the notificationHandler, +   * func. If the observable returned `onCompletes` or `onErrors` then retry will call `onCompleted`, +   * or `onError` on the child subscription. Otherwise, this observable will resubscribe to the source observable, on a particular Scheduler., +   *  <dd>you specify which [[Scheduler]] this operator will use</dd>, +   * `onCompleted`. An `onCompleted` notification from the source will result in the emission of, +   * a [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `repeatWhen` will, +   * call `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   *  <dd>you specify which [[Scheduler]] this operator will use</dd>, +   * `onCompleted`. An `onCompleted` notification from the source will result in the emission of, +   * a [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `repeatWhen` will, +   * call `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   *  <dd>`repeatWhen` operates by default on the `trampoline` [[Scheduler]].</dd>, +   * source Observable, mapped by the keys returned by a specified `keySelector` function., +   * Return an Observable that emits a single Map, returned by a specified `mapFactory` function, that, +   * Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass, +   * the values of the current Observable through the Operator function., +   * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +   * If the operator you are creating is designed to act on the individual items emitted by a source, +   * Observable, use `lift`. If your operator is designed to transform the source Observable as a whole, +   * (for instance, by applying a particular set of existing RxJava operators to it) use `#compose`., +   * <dl>, +   * <dt><b>Scheduler:</b></dt>, +   * <dd>`lift` does not operate by default on a particular [[Scheduler]].</dd>, +   * </dl>, +   * @param operator the Operator that implements the Observable-operating function to be applied to the source, +   *             Observable, +   * @return an Observable that is the result of applying the lifted Operator to the source Observable, +   * @see <a href="https://github.com/Netflix/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>, +   * @since 0.17, +   * Return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   * numbers after each `period` of time thereafter, on a specified Scheduler., +   * @return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   *         numbers after each `period` of time thereafter, while running on the given `scheduler`, +   * Return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   * numbers after each `period` of time thereafter, on a specified Scheduler., +   * @return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   * numbers after each `period` of time thereafter, while running on the given `scheduler`, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * `onError`. An `onError` notification from the source will result in the emission of a, +   * [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `retry` will call, +   * `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   * <pre>, +   * </pre>, +   * <pre>, +   * </pre>, +   *  <dd>`retryWhen` operates by default on the `trampoline` [[Scheduler]].</dd>, +   * Returns an Observable that emits the same values as the source observable with the exception of an `onError`., +   * An onError will emit a [[Notification]] to the observable provided as an argument to the notificationHandler, +   * func. If the observable returned `onCompletes` or `onErrors` then retry will call `onCompleted`, +   * or `onError` on the child subscription. Otherwise, this observable will resubscribe to the source observable, on a particular Scheduler., +   *  <dd>you specify which [[Scheduler]] this operator will use</dd>, +   * `onCompleted`. An `onCompleted` notification from the source will result in the emission of, +   * a [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `repeatWhen` will, +   * call `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   *  <dd>you specify which [[Scheduler]] this operator will use</dd>, +   * `onCompleted`. An `onCompleted` notification from the source will result in the emission of, +   * a [[Notification]] to the Observable provided as an argument to the `notificationHandler`, +   * function. If the Observable returned `onCompletes` or `onErrors` then `repeatWhen` will, +   * call `onCompleted` or `onError` on the child subscription. Otherwise, this Observable will, +   *  <dd>`repeatWhen` operates by default on the `trampoline` [[Scheduler]].</dd>, +   * source Observable, mapped by the keys returned by a specified `keySelector` function., +   * Return an Observable that emits a single Map, returned by a specified `mapFactory` function, that, +   * Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass, +   * the values of the current Observable through the Operator function., +   * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +   * If the operator you are creating is designed to act on the individual items emitted by a source, +   * Observable, use `lift`. If your operator is designed to transform the source Observable as a whole, +   * (for instance, by applying a particular set of existing RxJava operators to it) use `#compose`., +   * <dl>, +   * <dt><b>Scheduler:</b></dt>, +   * <dd>`lift` does not operate by default on a particular [[Scheduler]].</dd>, +   * </dl>, +   * @param operator the Operator that implements the Observable-operating function to be applied to the source, +   *             Observable, +   * @return an Observable that is the result of applying the lifted Operator to the source Observable, +   * @see <a href="https://github.com/Netflix/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>, +   * @since 0.17, +   * Return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   * numbers after each `period` of time thereafter, on a specified Scheduler., +   * @return an Observable that emits a 0L after the `initialDelay` and ever increasing, +   *         numbers after each `period` of time thereafter, while running on the given `scheduler`, +   * Return an Observable that emits a 0L after the `initialDelay` and ever increasing]