[+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +    private static final class IterableProducer<T> implements Producer {, +        private volatile long requested = 0;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<IterableProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(IterableProducer.class, "requested");, +, +            if (requested == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {, +                // fast-path without backpressure, +                while (true) {, +                    if (o.isUnsubscribed()) {, +                        return;, +                    } else if (it.hasNext()) {, +                        o.onNext(it.next());, +                    } else if (!o.isUnsubscribed()) {, +                        o.onCompleted();, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                }, +            } else if (n > 0) {, +                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +                if (_c == 0) {, +                        long r = requested;, +                        if (REQUESTED_UPDATER.addAndGet(this, -r) == 0) {, +, +++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +    private static final class IterableProducer<T> implements Producer {, +        private volatile long requested = 0;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<IterableProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(IterableProducer.class, "requested");, +, +            if (requested == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {, +                // fast-path without backpressure, +                while (true) {, +                    if (o.isUnsubscribed()) {, +                        return;, +                    } else if (it.hasNext()) {, +                        o.onNext(it.next());, +                    } else if (!o.isUnsubscribed()) {, +                        o.onCompleted();, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                }, +            } else if (n > 0) {, +                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +                if (_c == 0) {, +                        long r = requested;, +                        if (REQUESTED_UPDATER.addAndGet(this, -r) == 0) {, +, +++ /dev/null, +++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +    private static final class IterableProducer<T> implements Producer {, +        private volatile long requested = 0;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<IterableProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(IterableProducer.class, "requested");, +, +            if (requested == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {, +                // fast-path without backpressure, +                while (true) {, +                    if (o.isUnsubscribed()) {, +                        return;, +                    } else if (it.hasNext()) {, +                        o.onNext(it.next());, +                    } else if (!o.isUnsubscribed()) {, +                        o.onCompleted();, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                }, +            } else if (n > 0) {, +                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +                if (_c == 0) {, +                        long r = requested;, +                        if (REQUESTED_UPDATER.addAndGet(this, -r) == 0) {, +, +++ /dev/null, +++ b/src/test/java/rx/schedulers/CachedThreadSchedulerTest.java, +import static org.junit.Assert.assertTrue;, +import rx.*;, +import rx.Scheduler.Worker;, +        Worker w = Schedulers.io().createWorker();, +        try {, +            ExecutorSchedulerTest.testCancelledRetention(w, false);, +        } finally {]