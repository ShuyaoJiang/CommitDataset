[+++ b/rxjava-core/src/test/java/rx/operators/OnSubscribeToObservableFutureTest.java, +import static org.junit.Assert.assertEquals;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.Subscriber;, +import rx.observers.TestSubscriber;, +import rx.schedulers.Schedulers;, +, +    @Test, +    public void testCancelledBeforeSubscribe() throws Exception {, +        Future<Object> future = mock(Future.class);, +        CancellationException e = new CancellationException("unit test synthetic cancellation");, +        when(future.get()).thenThrow(e);, +        Observer<Object> o = mock(Observer.class);, +, +        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>(o);, +        testSubscriber.unsubscribe();, +        Subscription sub = Observable.from(future).subscribe(testSubscriber);, +        assertEquals(0, testSubscriber.getOnErrorEvents().size());, +        assertEquals(0, testSubscriber.getOnCompletedEvents().size());, +    }, +, +    @Test, +    public void testCancellationDuringFutureGet() throws Exception {, +        Future<Object> future = new Future<Object>() {, +            private AtomicBoolean isCancelled = new AtomicBoolean(false);, +            private AtomicBoolean isDone = new AtomicBoolean(false);, +, +            @Override, +            public boolean cancel(boolean mayInterruptIfRunning) {, +                isCancelled.compareAndSet(false, true);, +                return true;, +            }, +, +            @Override, +            public boolean isCancelled() {, +                return isCancelled.get();, +            }, +, +            @Override, +            public boolean isDone() {, +                return isCancelled() || isDone.get();, +            }, +, +            @Override, +            public Object get() throws InterruptedException, ExecutionException {, +                Thread.sleep(500);, +                isDone.compareAndSet(false, true);, +                return "foo";, +            }, +, +            @Override, +            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {, +                return get();, +            }, +        };, +, +        Observer<Object> o = mock(Observer.class);, +, +        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>(o);, +        Observable<Object> futureObservable = Observable.from(future);, +        Subscription sub = futureObservable.subscribeOn(Schedulers.computation()).subscribe(testSubscriber);, +        sub.unsubscribe();, +        assertEquals(0, testSubscriber.getOnErrorEvents().size());, +        assertEquals(0, testSubscriber.getOnCompletedEvents().size());, +        assertEquals(0, testSubscriber.getOnNextEvents().size());, +    }]