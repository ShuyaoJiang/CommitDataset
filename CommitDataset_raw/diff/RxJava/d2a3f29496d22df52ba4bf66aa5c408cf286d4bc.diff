[+++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import java.util.Date;, + * <li>If only an interface were used Scheduler implementations would then need to extend from an AbstractScheduler pair that gives all of the functionality unless they intend on copy/pasting the, + * functionality.</li>, +     * Schedules a cancelable action to be executed at dueTime., +     * , +     * @param state, +     *            State to pass into the action., +     * @param action, +     *            Action to schedule., +     * @param dueTime, +     *            Time the action is to be executed. If in the past it will be executed immediately., +     * @return a subscription to be able to unsubscribe from action., +     */, +    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, Date dueTime) {, +        long scheduledTime = dueTime.getTime();, +        long timeInFuture = scheduledTime - now();, +        if (timeInFuture <= 0) {, +            return schedule(state, action);, +        } else {, +            return schedule(state, action, timeInFuture, TimeUnit.MILLISECONDS);, +        }, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import java.util.Date;, + * <li>If only an interface were used Scheduler implementations would then need to extend from an AbstractScheduler pair that gives all of the functionality unless they intend on copy/pasting the, + * functionality.</li>, +     * Schedules a cancelable action to be executed at dueTime., +     * , +     * @param state, +     *            State to pass into the action., +     * @param action, +     *            Action to schedule., +     * @param dueTime, +     *            Time the action is to be executed. If in the past it will be executed immediately., +     * @return a subscription to be able to unsubscribe from action., +     */, +    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, Date dueTime) {, +        long scheduledTime = dueTime.getTime();, +        long timeInFuture = scheduledTime - now();, +        if (timeInFuture <= 0) {, +            return schedule(state, action);, +        } else {, +            return schedule(state, action, timeInFuture, TimeUnit.MILLISECONDS);, +        }, +    }, +, +    /**, +++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java, +import java.util.Date;, +    @Test, +    public void testSchedulingWithDueTime() throws InterruptedException {, +, +        final CountDownLatch latch = new CountDownLatch(5);, +        final AtomicInteger counter = new AtomicInteger();, +, +        long start = System.currentTimeMillis();, +, +        Schedulers.threadPoolForComputation().schedule(null, new Func2<Scheduler, String, Subscription>() {, +, +            @Override, +            public Subscription call(Scheduler scheduler, String state) {, +                System.out.println("doing work");, +                latch.countDown();, +                counter.incrementAndGet();, +                if (latch.getCount() == 0) {, +                    return Subscriptions.empty();, +                } else {, +                    return scheduler.schedule(state, this, new Date(System.currentTimeMillis() + 50));, +                }, +            }, +        }, new Date(System.currentTimeMillis() + 100));, +, +        if (!latch.await(3000, TimeUnit.MILLISECONDS)) {, +            fail("didn't execute ... timed out");, +        }, +, +        long end = System.currentTimeMillis();, +, +        assertEquals(5, counter.get());, +        if ((end - start) < 250) {, +            fail("it should have taken over 250ms since each step was scheduled 50ms in the future");, +        }, +    }, +]