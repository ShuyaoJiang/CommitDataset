[+++ b/src/main/java/rx/observers/SerializedObserver.java, +import rx.exceptions.*;, +import rx.internal.operators.NotificationLite;, +    private boolean emitting;, +    /** Set to true if a terminal event was received. */, +    private volatile boolean terminated;, +    /** If not null, it indicates more work. */, +    private final NotificationLite<T> nl = NotificationLite.instance();, +    /** Number of iterations without additional safepoint poll in the drain loop. */, +    private static final int MAX_DRAIN_ITERATION = 1024;, +    public void onNext(T t) {, +        if (terminated) {, +            return;, +        }, +        synchronized (this) {, +            if (terminated) {, +                return;, +            }, +            if (emitting) {, +                FastList list = queue;, +                if (list == null) {, +                    list = new FastList();, +                    queue = list;, +                }, +                list.add(nl.next(t));, +                return;, +            }, +            emitting = true;, +        }, +        try {, +            actual.onNext(t);, +        } catch (Throwable e) {, +            terminated = true;, +            Exceptions.throwIfFatal(e);, +            actual.onError(OnErrorThrowable.addValueAsLastCause(e, t));, +            return;, +        }, +        for (;;) {, +            for (int i = 0; i < MAX_DRAIN_ITERATION; i++) {, +                    list = queue;, +                    if (list == null) {, +                        emitting = false;, +                        return;, +                    }, +                    queue = null;, +                }, +                for (Object o : list.array) {, +                    if (o == null) {, +                        break;, +                    }, +                    try {, +                        if (nl.accept(actual, o)) {, +                            terminated = true;, +                            return;, +                        }, +                    } catch (Throwable e) {, +                        terminated = true;, +                        Exceptions.throwIfFatal(e);, +                        actual.onError(OnErrorThrowable.addValueAsLastCause(e, t));, +                        return;, +                    }, +                }, +            }, +        }, +    }, +    , +    @Override, +    public void onError(final Throwable e) {, +        Exceptions.throwIfFatal(e);, +        if (terminated) {, +            return;, +        }, +        synchronized (this) {, +                /* , +                 * FIXME: generally, errors jump the queue but this wasn't true , +                 * for SerializedObserver and may break existing expectations. , +                 */, +                FastList list = queue;, +                    list = new FastList();, +                    queue = list;, +                }, +                list.add(nl.error(e));, +            emitting = true;, +        actual.onError(e);, +, +    @Override, +    public void onCompleted() {, +        if (terminated) {, +            return;, +        }, +            terminated = true;, +            if (emitting) {, +                FastList list = queue;, +                if (list == null) {, +                    list = new FastList();, +                    queue = list;, +                list.add(nl.completed());, +                return;, +            }, +            emitting = true;]