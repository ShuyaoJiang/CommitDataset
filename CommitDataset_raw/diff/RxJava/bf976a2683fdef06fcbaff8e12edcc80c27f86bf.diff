[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFlatMap;, +import rx.operators.OperatorToObservableFuture;, +        return create(OperatorToObservableFuture.toObservableFuture(future));, +        return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, +        return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +        return create(OperationFlatMap.flatMap(this, onNext, onError, onCompleted));, +        return create(OperationFlatMap.flatMap(this, collectionSelector, resultSelector));, +        return merge(map(OperationFlatMap.flatMapIterableFunc(collectionSelector)));, +        return mergeMap(OperationFlatMap.flatMapIterableFunc(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFlatMap;, +import rx.operators.OperatorToObservableFuture;, +        return create(OperatorToObservableFuture.toObservableFuture(future));, +        return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, +        return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +        return create(OperationFlatMap.flatMap(this, onNext, onError, onCompleted));, +        return create(OperationFlatMap.flatMap(this, collectionSelector, resultSelector));, +        return merge(map(OperationFlatMap.flatMapIterableFunc(collectionSelector)));, +        return mergeMap(OperationFlatMap.flatMapIterableFunc(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/operators/OperationFlatMap.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.concurrent.atomic.AtomicInteger;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.functions.Func0;, +import rx.functions.Func1;, +import rx.functions.Func2;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.SerialSubscription;, +, +/**, + * Additional flatMap operators., + */, +public final class OperationFlatMap {, +    /** Utility class. */, +    private OperationFlatMap() {, +        throw new IllegalStateException("No instances!");, +    }, +, +    /**, +     * Observable that pairs up the source values and all the derived collection, +     * values and projects them via the selector., +     */, +    public static <T, U, R> OnSubscribeFunc<R> flatMap(Observable<? extends T> source,, +            Func1<? super T, ? extends Observable<? extends U>> collectionSelector,, +            Func2<? super T, ? super U, ? extends R> resultSelector, +            ) {, +        return new FlatMapPairSelector<T, U, R>(source, collectionSelector, resultSelector);, +    }, +, +    /**, +     * Converts the result Iterable of a function into an Observable., +     */, +    public static <T, U> Func1<T, Observable<U>> flatMapIterableFunc(, +            Func1<? super T, ? extends Iterable<? extends U>> collectionSelector) {, +        return new IterableToObservableFunc<T, U>(collectionSelector);, +    }, +, +    /**, +     * Converts the result Iterable of a function into an Observable., +     * , +     * @param <T>, +     *            the parameter type, +     * @param <R>, +     *            the result type, +     */, +    private static final class IterableToObservableFunc<T, R> implements Func1<T, Observable<R>> {, +        final Func1<? super T, ? extends Iterable<? extends R>> func;, +, +        public IterableToObservableFunc(Func1<? super T, ? extends Iterable<? extends R>> func) {, +            this.func = func;, +        }, +, +        @Override, +        public Observable<R> call(T t1) {, +            return Observable.from(func.call(t1));, +        }, +    }, +]