[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperationWhere;, +    private final boolean isTrusted;, +        this(null, false);, +        this(onSubscribe, false);, +    }, +, +    /**, +     * @param onSubscribe, +     *            {@link Func1} to be executed when {@link #subscribe(Observer)} is called., +     * @param isTrusted, +     *            boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., +     */, +    private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +        this.isTrusted = isTrusted;, +        if (onSubscribe == null) {, +            if (isTrusted) {, +                Subscription s = onSubscribe.call(observer);, +                    return Subscriptions.empty();, +                    return s;, +                return subscription.wrap(onSubscribe.call(new AtomicObserver<T>(subscription, observer)));, +                observer.onError(e);, +                throw new RuntimeException("Error occurred attempting to subscribe [" + e.getMessage() + "] and then again while trying to pass to onError.", e2);, +        return subscribe(new Observer() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        subscribe(new Observer<T>() {, +            }, true);, +            }, true);, +    /*, +     * Private version that creates a 'trusted' Observable to allow performance optimizations., +     */, +    private static <T> Observable<T> _create(Func1<Observer<T>, Subscription> func) {, +        return new Observable<T>(func, true);, +    }, +, +        return _create(OperationFilter.filter(that, predicate));, +        return _create(OperationWhere.where(that, predicate));, +        return _create(OperationDefer.defer(observableFactory));, +        return _create(OperationDefer.defer(new Func0<Observable<T>>() {, +        return _create(OperationMap.map(sequence, func));, +        return _create(OperationMap.mapMany(sequence, func));, +        return _create(OperationMaterialize.materialize(sequence));, +        return _create(OperationDematerialize.dematerialize(sequence));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationConcat.concat(source));, +        return _create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, +        return _create(OperatorGroupBy.groupBy(source, keySelector));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(that, resumeFunction));, +        return _create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(that, resumeSequence));, +        return _create(OperationOnErrorReturn.onErrorReturn(that, resumeFunction));, +        return takeLast(_create(OperationScan.scan(sequence, accumulator)), 1);, +        return takeLast(_create(OperationScan.scan(sequence, initialValue, accumulator)), 1);, +        return _create(OperationScan.scan(sequence, accumulator));, +        return _create(OperationScan.scan(sequence, initialValue, accumulator));, +     * @param sequence an observable sequence whose elements to apply the predicate to., +     * @param predicate a function to test each element for a condition., +     * @param <T> the type of observable., +        return _create(OperationAll.all(sequence, predicate));, +     * @param sequence an observable sequence whose elements to apply the predicate to., +     * @param predicate a function to test each element for a condition., +     * @param <T> the type of observable., +        return _create(OperationSkip.skip(items, num));, +        return _create(OperationSynchronize.synchronize(observable));, +        return _create(OperationTake.take(items, num));, +        return _create(OperationTakeLast.takeLast(items, count));, +        return _create(OperationToObservableList.toObservableList(that));, +        return _create(OperationToObservableIterable.toObservableIterable(iterable));, +        return _create(OperationToObservableFuture.toObservableFuture(future));, +     * @param time, +    public static <T> Observable<T> toObservable(Future<T> future, long time, TimeUnit unit) {, +        return _create(OperationToObservableFuture.toObservableFuture(future, time, unit));, +        return _create(OperationToObservableSortedList.toSortedList(sequence));, +        return _create(OperationToObservableSortedList.toSortedList(sequence, sortFunction));, +        return _create(OperationToObservableSortedList.toSortedList(sequence, new Func2<T, T, Integer>() {, +        return _create(OperationZip.zip(w0, w1, reduceFunction));, +        return _create(OperationZip.zip(w0, w1, w2, function));, +        return _create(OperationZip.zip(w0, w1, w2, w3, reduceFunction));, +     * @param predicate a function to test each element for a condition., +     * @param predicate a function to test each element for a condition., +++ b/CHANGES.md, +++ b/gradle.properties]