[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +class UnitTestSuite extends JUnitSuite {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +class UnitTestSuite extends JUnitSuite {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleWithTimeout;, +     * Throttles the {@link Observable} by dropping values which are followed by newer values before the timer has expired., +     * , +     * @param timeout, +     *            The time each value has to be 'the most recent' of the {@link Observable} to ensure that it's not dropped., +     * , +     * @param unit, +     *            The {@link TimeUnit} for the timeout., +     * , +     * @return An {@link Observable} which filters out values which are too quickly followed up with newer values., +     */, +    public Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {, +        return create(OperationThrottleWithTimeout.throttleWithTimeout(this, timeout, unit));, +    }, +, +    /**, +     * Throttles the {@link Observable} by dropping values which are followed by newer values before the timer has expired., +     * , +     * @param timeout, +     *            The time each value has to be 'the most recent' of the {@link Observable} to ensure that it's not dropped., +     * @param unit, +     *            The {@link TimeUnit} for the timeout., +     * @param scheduler, +     *            The {@link Scheduler} to use when timing incoming values., +     * @return An {@link Observable} which filters out values which are too quickly followed up with newer values., +     */, +    public Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {, +        return create(OperationThrottleWithTimeout.throttleWithTimeout(this, timeout, unit, scheduler));, +    }, +, +    /**, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +class UnitTestSuite extends JUnitSuite {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleWithTimeout;, +     * Throttles the {@link Observable} by dropping values which are followed by newer values before the timer has expired., +     * , +     * @param timeout, +     *            The time each value has to be 'the most recent' of the {@link Observable} to ensure that it's not dropped., +     * , +     * @param unit, +     *            The {@link TimeUnit} for the timeout., +     * , +     * @return An {@link Observable} which filters out values which are too quickly followed up with newer values., +     */, +    public Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {, +        return create(OperationThrottleWithTimeout.throttleWithTimeout(this, timeout, unit));, +    }, +, +    /**, +     * Throttles the {@link Observable} by dropping values which are followed by newer values before the timer has expired., +     * , +     * @param timeout, +     *            The time each value has to be 'the most recent' of the {@link Observable} to ensure that it's not dropped., +     * @param unit, +     *            The {@link TimeUnit} for the timeout., +     * @param scheduler, +     *            The {@link Scheduler} to use when timing incoming values., +     * @return An {@link Observable} which filters out values which are too quickly followed up with newer values., +     */, +    public Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {, +        return create(OperationThrottleWithTimeout.throttleWithTimeout(this, timeout, unit, scheduler));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +        private final AtomicBoolean isCancelled = new AtomicBoolean(false);, +        public void cancel() {, +            isCancelled.set(true);, +        }, +, +, +            // Only execute if the TimedAction has not yet been cancelled, +            if (!current.isCancelled.get()) {, +        }, +        final TimedAction<T> timedAction = new TimedAction<T>(this, time + unit.toNanos(delayTime), action, state);, +        queue.add(timedAction);, +]