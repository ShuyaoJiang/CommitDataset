[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleCache.java, +public final class SingleCache<T> extends Single<T> implements SingleObserver<T> {, +, +    @SuppressWarnings("rawtypes"), +    static final CacheDisposable[] EMPTY = new CacheDisposable[0];, +    @SuppressWarnings("rawtypes"), +    static final CacheDisposable[] TERMINATED = new CacheDisposable[0];, +    final AtomicReference<CacheDisposable<T>[]> observers;, +    , +    T value;, +    , +    Throwable error;, +    , +    @SuppressWarnings("unchecked"), +        this.observers = new AtomicReference<CacheDisposable<T>[]>(EMPTY);, +    protected void subscribeActual(final SingleObserver<? super T> s) {, +        CacheDisposable<T> d = new CacheDisposable<T>(s, this);, +        s.onSubscribe(d);, +        if (add(d)) {, +            if (d.isDisposed()) {, +                remove(d);, +            }, +            Throwable ex = error;, +            if (ex != null) {, +                s.onError(ex);, +                s.onSuccess(value);, +        if (wip.getAndIncrement() == 0) {, +            source.subscribe(this);, +        }, +    }, +, +    boolean add(CacheDisposable<T> observer) {, +        for (;;) {, +            CacheDisposable<T>[] a = observers.get();, +            if (a == TERMINATED) {, +                return false;, +            }, +            int n = a.length;, +            @SuppressWarnings("unchecked"), +            CacheDisposable<T>[] b = new CacheDisposable[n + 1];, +            System.arraycopy(a, 0, b, 0, n);, +            b[n] = observer;, +            if (observers.compareAndSet(a, b)) {, +                return true;, +            }, +        }, +    }, +    , +    @SuppressWarnings("unchecked"), +    void remove(CacheDisposable<T> observer) {, +        for (;;) {, +            CacheDisposable<T>[] a = observers.get();, +            int n = a.length;, +            if (n == 0) {, +            int j = -1;, +            for (int i = 0; i < n; i++) {, +                if (a[i] == observer) {, +                    j = i;, +                    break;, +                }, +            }, +            , +            if (j < 0) {, +                return;, +            }, +            , +            CacheDisposable<T>[] b;, +            , +            if (n == 1) {, +                b = EMPTY;, +            } else {, +                b = new CacheDisposable[n - 1];, +                System.arraycopy(a, 0, b, 0, j);, +                System.arraycopy(a, j + 1, b, j, n - j - 1);, +            }, +            if (observers.compareAndSet(a, b)) {, +                return;, +            }, +        }, +    }, +        // not supported by this operator, +    @SuppressWarnings("unchecked"), +        this.value = value;, +        , +        for (CacheDisposable<T> d : observers.getAndSet(TERMINATED)) {, +            if (!d.isDisposed()) {, +                d.actual.onSuccess(value);, +    @SuppressWarnings("unchecked"), +    @Override, +    public void onError(Throwable e) {, +        this.error = e;, +        , +        for (CacheDisposable<T> d : observers.getAndSet(TERMINATED)) {, +            if (!d.isDisposed()) {, +                d.actual.onError(e);, +            }, +        }, +    }, +    , +    static final class CacheDisposable<T> ]