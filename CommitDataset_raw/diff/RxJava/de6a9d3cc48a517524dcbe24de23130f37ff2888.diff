[+++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/test/java/rx/BackpressureTests.java, +        assertTrue(c1.get() < RxRingBuffer.SIZE * 5);, +        assertTrue(c2.get() < RxRingBuffer.SIZE * 5);, +    @Test(timeout = 2000), +        firehose(c).onBackpressureDrop().observeOn(Schedulers.computation()).map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +        System.out.println("testOnBackpressureDrop => Received: " + ts.getOnNextEvents().size() + "  Emitted: " + c.get() + " Last value: " + ts.getOnNextEvents().get(NUM - 1));, +        assertEquals(NUM, ts.getOnNextEvents().size());, +        assertTrue(NUM < ts.getOnNextEvents().get(NUM - 1).intValue());, +, +            for (int i = 0; i < 10000; i++) {, +                t = String.valueOf(i);, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/test/java/rx/BackpressureTests.java, +        assertTrue(c1.get() < RxRingBuffer.SIZE * 5);, +        assertTrue(c2.get() < RxRingBuffer.SIZE * 5);, +    @Test(timeout = 2000), +        firehose(c).onBackpressureDrop().observeOn(Schedulers.computation()).map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +        System.out.println("testOnBackpressureDrop => Received: " + ts.getOnNextEvents().size() + "  Emitted: " + c.get() + " Last value: " + ts.getOnNextEvents().get(NUM - 1));, +        assertEquals(NUM, ts.getOnNextEvents().size());, +        assertTrue(NUM < ts.getOnNextEvents().get(NUM - 1).intValue());, +, +            for (int i = 0; i < 10000; i++) {, +                t = String.valueOf(i);, +++ b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java, +        Observable<Long> r = Observable.timer(0, 5, TimeUnit.MILLISECONDS), +            Thread.sleep(52);, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/test/java/rx/BackpressureTests.java, +        assertTrue(c1.get() < RxRingBuffer.SIZE * 5);, +        assertTrue(c2.get() < RxRingBuffer.SIZE * 5);, +    @Test(timeout = 2000), +        firehose(c).onBackpressureDrop().observeOn(Schedulers.computation()).map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +        System.out.println("testOnBackpressureDrop => Received: " + ts.getOnNextEvents().size() + "  Emitted: " + c.get() + " Last value: " + ts.getOnNextEvents().get(NUM - 1));, +        assertEquals(NUM, ts.getOnNextEvents().size());, +        assertTrue(NUM < ts.getOnNextEvents().get(NUM - 1).intValue());, +, +            for (int i = 0; i < 10000; i++) {, +                t = String.valueOf(i);, +++ b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java, +        Observable<Long> r = Observable.timer(0, 5, TimeUnit.MILLISECONDS), +            Thread.sleep(52);, +++ b/src/test/java/rx/internal/operators/OperatorWindowWithTimeTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, +import java.util.ArrayList;, +import java.util.List;, +import org.junit.Before;, +import org.junit.Test;, +import rx.Scheduler;, +import rx.Subscriber;, +import rx.functions.Action0;, +import rx.functions.Action1;, +    private Action1<Observable<String>> observeWindow(final List<String> list, final List<List<String>> lists) {, +        return new Action1<Observable<String>>() {, +            public void call(Observable<String> stringObservable) {, +                stringObservable.subscribe(new Observer<String>() {, +                        lists.add(new ArrayList<String>(list));, +                    public void onNext(String args) {]