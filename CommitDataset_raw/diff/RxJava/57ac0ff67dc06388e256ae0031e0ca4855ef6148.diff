[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.functions.ObjectHelper;, +import java.util.concurrent.atomic.AtomicReference;, +    protected void subscribeActual(SingleObserver<? super R> actual) {, +        source.subscribe(new SingleFlatMapCallback<T, R>(actual, mapper));, +    static final class SingleFlatMapCallback<T, R>, +    extends AtomicReference<Disposable>, +    implements SingleObserver<T>, Disposable {, +        }, +, +        @Override, +        public void dispose() {, +            DisposableHelper.dispose(this);, +        }, +, +        @Override, +        public boolean isDisposed() {, +            return DisposableHelper.isDisposed(get());, +            if (DisposableHelper.setOnce(this, d)) {, +                actual.onSubscribe(this);, +            }, +                o = ObjectHelper.requireNonNull(mapper.apply(value), "The single returned by the mapper is null");, +            o.subscribe(new FlatMapSingleObserver<R>(this, actual));, +        public void onError(Throwable e) {, +            actual.onError(e);, +        }, +, +        static final class FlatMapSingleObserver<R> implements SingleObserver<R> {, +, +            final AtomicReference<Disposable> parent;, +, +            final SingleObserver<? super R> actual;, +, +            FlatMapSingleObserver(AtomicReference<Disposable> parent, SingleObserver<? super R> actual) {, +                this.parent = parent;, +                this.actual = actual;, +            }, +, +            @Override, +            public void onSubscribe(final Disposable d) {, +                DisposableHelper.replace(parent, d);, +            }, +, +            @Override, +            public void onSuccess(final R value) {, +            public void onError(final Throwable e) {, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.functions.ObjectHelper;, +import java.util.concurrent.atomic.AtomicReference;, +    protected void subscribeActual(SingleObserver<? super R> actual) {, +        source.subscribe(new SingleFlatMapCallback<T, R>(actual, mapper));, +    static final class SingleFlatMapCallback<T, R>, +    extends AtomicReference<Disposable>, +    implements SingleObserver<T>, Disposable {, +        }, +, +        @Override, +        public void dispose() {, +            DisposableHelper.dispose(this);, +        }, +, +        @Override, +        public boolean isDisposed() {, +            return DisposableHelper.isDisposed(get());, +            if (DisposableHelper.setOnce(this, d)) {, +                actual.onSubscribe(this);, +            }, +                o = ObjectHelper.requireNonNull(mapper.apply(value), "The single returned by the mapper is null");, +            o.subscribe(new FlatMapSingleObserver<R>(this, actual));, +        public void onError(Throwable e) {, +            actual.onError(e);, +        }, +, +        static final class FlatMapSingleObserver<R> implements SingleObserver<R> {, +, +            final AtomicReference<Disposable> parent;, +, +            final SingleObserver<? super R> actual;, +, +            FlatMapSingleObserver(AtomicReference<Disposable> parent, SingleObserver<? super R> actual) {, +                this.parent = parent;, +                this.actual = actual;, +            }, +, +            @Override, +            public void onSubscribe(final Disposable d) {, +                DisposableHelper.replace(parent, d);, +            }, +, +            @Override, +            public void onSuccess(final R value) {, +            public void onError(final Throwable e) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java, +, +    @Test(expected = NullPointerException.class), +    public void flatMapNull() {, +        Single.just(1), +            .flatMap(null);]