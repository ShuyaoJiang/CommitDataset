[+++ b/src/main/java/rx/internal/operators/OperatorBufferWithSize.java, +                        if (n == 0) {, +                            return;, +                        }, +                        if (n < 0) {, +                            throw new IllegalArgumentException("request a negative number: " + n);, +                        }, +++ b/src/main/java/rx/internal/operators/OperatorBufferWithSize.java, +                        if (n == 0) {, +                            return;, +                        }, +                        if (n < 0) {, +                            throw new IllegalArgumentException("request a negative number: " + n);, +                        }, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()), +                    int emitted = 0;, +                    emitted += s.drainQueue();, +                        /*, +                         * `s.emitted` is not volatile (because of performance impact of making it so shown by JMH tests), +                         * but `emitted` can ONLY be touched by the thread holding the `emitLock` which we're currently inside., +                         * , +                         * Entering and leaving the emitLock flushes all values so this is visible to us., +                         */, +                        emitted += s.emitted;, +                        // TODO we may want to store this in s.emitted and only request if above batch, +                        // reset this since we have requested them all, +                        s.emitted = 0;, +        /* protected by emitLock */, +        int emitted = 0;, +        final int THRESHOLD = (int) (q.capacity() * 0.7);, +                if (emitted > THRESHOLD) {, +                    // this is for batching requests when we're in a use case that isn't queueing, always fast-pathing the onNext, +                    /**, +                     * <pre> {@code, +                     * Without this batching:, +                     * , +                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5060743.715   100445.513    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    36606.582     1610.582    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       38.476        0.973    ops/s, +                     * , +                     * With this batching:, +                     * , +                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5367945.738   262740.137    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    62703.930     8496.036    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       72.711        3.746    ops/s, +                     *} </pre>, +                     */, +                    // we are modifying this outside of the emit lock ... but this can be considered a "lazySet", +                    // and it will be flushed before anything else touches it because the emitLock will be obtained, +                    // before any other usage of it, +                    emitted = 0;, +++ b/src/main/java/rx/internal/operators/OperatorBufferWithSize.java, +                        if (n == 0) {, +                            return;, +                        }, +                        if (n < 0) {, +                            throw new IllegalArgumentException("request a negative number: " + n);, +                        }, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()), +                    int emitted = 0;, +                    emitted += s.drainQueue();, +                        /*, +                         * `s.emitted` is not volatile (because of performance impact of making it so shown by JMH tests), +                         * but `emitted` can ONLY be touched by the thread holding the `emitLock` which we're currently inside., +                         * , +                         * Entering and leaving the emitLock flushes all values so this is visible to us., +                         */, +                        emitted += s.emitted;, +                        // TODO we may want to store this in s.emitted and only request if above batch, +                        // reset this since we have requested them all, +                        s.emitted = 0;, +        /* protected by emitLock */, +        int emitted = 0;, +        final int THRESHOLD = (int) (q.capacity() * 0.7);, +                if (emitted > THRESHOLD) {, +                    // this is for batching requests when we're in a use case that isn't queueing, always fast-pathing the onNext, +                    /**, +                     * <pre> {@code, +                     * Without this batching:, +                     * , +                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5060743.715   100445.513    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    36606.582     1610.582    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       38.476        0.973    ops/s, +                     * , +                     * With this batching:, +                     * , +                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5367945.738   262740.137    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    62703.930     8496.036    ops/s, +                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       72.711        3.746    ops/s, +                     *} </pre>, +                     */, +                    // we are modifying this outside of the emit lock ... but this can be considered a "lazySet", +                    // and it will be flushed before anything else touches it because the emitLock will be obtained, +                    // before any other usage of it]