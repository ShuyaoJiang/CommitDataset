[+++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.functions.Action0, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.functions Action0 Action1 Func0 Func1 Func2])), +    http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1), +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.functions Action0 Action1 Func0 Func1 Func2])), +    http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1), +++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/BlockingObservable.java, +import co.paralleluniverse.fibers.SuspendExecution;, +import co.paralleluniverse.fibers.Suspendable;, +import co.paralleluniverse.strands.AbstractFuture;, +import co.paralleluniverse.strands.ConditionSynchronizer;, +import co.paralleluniverse.strands.SimpleConditionSynchronizer;, +import co.paralleluniverse.strands.Strand;, +import co.paralleluniverse.strands.channels.Channels;, +import co.paralleluniverse.strands.channels.DelegatingReceivePort;, +import co.paralleluniverse.strands.channels.ProducerException;, +import co.paralleluniverse.strands.channels.ReceivePort;, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.functions Action0 Action1 Func0 Func1 Func2])), +    http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1), +++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/BlockingObservable.java, +import co.paralleluniverse.fibers.SuspendExecution;, +import co.paralleluniverse.fibers.Suspendable;, +import co.paralleluniverse.strands.AbstractFuture;, +import co.paralleluniverse.strands.ConditionSynchronizer;, +import co.paralleluniverse.strands.SimpleConditionSynchronizer;, +import co.paralleluniverse.strands.Strand;, +import co.paralleluniverse.strands.channels.Channels;, +import co.paralleluniverse.strands.channels.DelegatingReceivePort;, +import co.paralleluniverse.strands.channels.ProducerException;, +import co.paralleluniverse.strands.channels.ReceivePort;, +++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.functions Action0 Action1 Func0 Func1 Func2])), +    http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1), +++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/BlockingObservable.java, +import co.paralleluniverse.fibers.SuspendExecution;, +import co.paralleluniverse.fibers.Suspendable;, +import co.paralleluniverse.strands.AbstractFuture;, +import co.paralleluniverse.strands.ConditionSynchronizer;, +import co.paralleluniverse.strands.SimpleConditionSynchronizer;, +import co.paralleluniverse.strands.Strand;, +import co.paralleluniverse.strands.channels.Channels;, +import co.paralleluniverse.strands.channels.DelegatingReceivePort;, +import co.paralleluniverse.strands.channels.ProducerException;, +import co.paralleluniverse.strands.channels.ReceivePort;, +++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +, +import rx.Observable;, +import rx.Observer;]