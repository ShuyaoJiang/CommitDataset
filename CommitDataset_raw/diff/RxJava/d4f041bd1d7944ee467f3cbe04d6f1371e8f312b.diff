[+++ b/src/main/java/io/reactivex/Observable.java, +        return new ObservableConcatMap(sources, Functions.identity(), bufferSize);, +        return new ObservableFlatMap(sources, Functions.identity(), false, Integer.MAX_VALUE, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), false, maxConcurrency, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), true, Integer.MAX_VALUE, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), true, maxConcurrency, bufferSize());, +        return new ObservableSwitchMap(sources, Functions.identity(), bufferSize);, +        return new ObservableToList(sources, 16), +        return new ObservableCollect<T, U>(this, initialValueSupplier, collector);, +        return new ObservableConcatMap<T, R>(this, mapper, prefetch);, +        return new ObservableCount<T>(this);, +        return new ObservableDebounce<T, U>(this, debounceSelector);, +        return new ObservableDebounceTimed<T>(this, timeout, unit, scheduler);, +                return new ObservableTake<U>(itemDelay.apply(v), 1).map(new Function<U, T>() {, +        return new ObservableDelay<T>(this, delay, unit, scheduler, delayError);, +        return new ObservableDematerialize<T2>(m);, +        return ObservableDistinct.withCollection(this, keySelector, collectionSupplier);, +        return ObservableDistinct.<T>untilChanged(this);, +        return ObservableDistinct.untilChanged(this, keySelector);, +        return new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate);, +        return new ObservableElementAt<T>(this, index, null);, +        return new ObservableElementAt<T>(this, index, defaultValue);, +        return new ObservableFilter<T>(this, predicate);, +        return new ObservableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize);, +        return merge(new ObservableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, +        return merge(new ObservableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, +        return new ObservableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError);, +        return new ObservableIgnoreElements<T>(this);, +        return new ObservableMap<T, R>(this, mapper);, +        return new ObservableMaterialize<T>(this);, +        return new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize);, +        return new ObservableOnErrorNext<T>(this, resumeFunction, false);, +        return new ObservableOnErrorReturn<T>(this, valueSupplier);, +        return new ObservableOnErrorNext<T>(this, new Function<Throwable, ObservableConsumable<? extends T>>() {, +        }, true);, +        return ObservablePublish.create(this, selector, bufferSize);, +        return ObservablePublish.create(this, bufferSize);, +        return ObservableReplay.createFrom(this);, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +                return new ObservableObserveOn<R>(selector.apply(t), scheduler, false, bufferSize());, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +        return ObservableReplay.multicastSelector(new Supplier<ConnectableObservable<T>>() {, +                return new ObservableObserveOn<R>(selector.apply(t), scheduler, false, bufferSize());, +        return ObservableReplay.create(this, bufferSize);, +        return ObservableReplay.create(this, time, unit, scheduler, bufferSize);, +        return ObservableReplay.observeOn(replay(bufferSize), scheduler);, +        return ObservableReplay.create(this, time, unit, scheduler);, +        return ObservableReplay.observeOn(replay(), scheduler);, +        return new ObservableSampleTimed<T>(this, period, unit, scheduler);, +        return new ObservableSampleWithObservable<T>(this, sampler);, +        return new ObservableScan<T>(this, accumulator);, +        return new ObservableScanSeed<T, R>(this, seedSupplier, accumulator);, +        return new ObservableSingle<T>(this, null);, +        return new ObservableSingle<T>(this, defaultValue);, +        return new ObservableSkip<T>(this, n);, +        return new ObservableSkipLast<T>(this, n);, +        return new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError);, +        return new ObservableSkipUntil<T, U>(this, other);, +        return new ObservableSkipWhile<T>(this, predicate);, +        return new ObservableSwitchIfEmpty<T>(this, other);, +        return new ObservableSwitchMap<T, R>(this, mapper, bufferSize);, +        return new ObservableTake<T>(this, n);, +            return new ObservableTakeLastOne<T>(this);, +        return new ObservableTakeLast<T>(this, n);, +        return new ObservableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError);, +        return new ObservableTakeUntil<T, U>(this, other);, +        return new ObservableTakeUntilPredicate<T>(this, predicate);, +        return new ObservableTakeWhile<T>(this, predicate);, +        return new ObservableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler);, +        return new ObservableTimeInterval<T>(this, unit, scheduler);, +        return new ObservableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other);, +        return new ObservableTimeout<T, U, V>(this, firstTimeoutSelector, timeoutSelector, other);, +        return toList(16);, +        return new ObservableToList<T, List<T>>(this, capacityHint);, +        return new ObservableToList<T, U>(this, collectionSupplier);, +        return new ObservableUnsubscribeOn<T>(this, scheduler);, +        return new ObservableWindow<T>(this, count, skip, bufferSize);, +        return new ObservableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false);, +        return new ObservableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart);, +        return new ObservableWindowBoundary<T, B>(this, boundary, bufferSize);, +        return new ObservableWindowBoundarySelector<T, U, V>(this, windowOpen, windowClose, bufferSize);, +        return new ObservableWindowBoundarySupplier<T, B>(this, boundary, bufferSize);, +        return new ObservableWithLatestFrom<T, U, R>(this, combiner, other);, +++ b/src/main/java/io/reactivex/Observable.java, +        return new ObservableConcatMap(sources, Functions.identity(), bufferSize);, +        return new ObservableFlatMap(sources, Functions.identity(), false, Integer.MAX_VALUE, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), false, maxConcurrency, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), true, Integer.MAX_VALUE, bufferSize());, +        return new ObservableFlatMap(sources, Functions.identity(), true, maxConcurrency, bufferSize());, +        return new ObservableSwitchMap(sources, Functions.identity(), bufferSize);, +        return new ObservableToList(sources, 16), +        return new ObservableCollect<T, U>(this, initialValueSupplier, collector);, +        return new ObservableConcatMap<T, R>(this, mapper, prefetch);, +        return new ObservableCount<T>(this);, +        return new ObservableDebounce<T, U>(this, debounceSelector);, +        return new ObservableDebounceTimed<T>(this, timeout, unit, scheduler);, +                return new ObservableTake<U>(itemDelay.apply(v), 1).map(new Function<U, T>() {]