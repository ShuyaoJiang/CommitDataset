[+++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * @param <T> the type of the item emitted by the Observable, +    private final static ConcurrentHashMap<Class, Boolean> internalClassMap = new ConcurrentHashMap<Class, Boolean>();, +    /**, +     * Function interface for work to be performed when an {@link Observable}, +     * is subscribed to via {@link Observable#subscribe(Observer)}, +     * , +     * @param <T>, +     */, +    public static interface OnSubscribeFunc<T> extends Function {, +, +        public Subscription onSubscribe(Observer<? super T> t1);, +, +    }, +     * @param onSubscribe {@link OnSubscribeFunc} to be executed when, +     *                    {@link #subscribe(Observer)} is called, +    private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, +     * An {@link Observer} must call an Observable's {@code subscribe} method in, +     * order to receive items and notifications from the Observable., +     * A typical implementation of {@code subscribe} does the following:, +     * <ol>, +     * <li>It stores a reference to the Observer in a collection object, such as, +     *     a {@code List<T>} object.</li>, +     * <li>It returns a reference to the {@link Subscription} interface. This, +     *     enables Observers to unsubscribe, that is, to stop receiving items, +     *     and notifications before the Observable stops sending them, which, +     *     also invokes the Observer's {@link Observer#onCompleted onCompleted}, +     *     method.</li>, +     * </ol><p>, +     * An <code>Observable&lt;T&gt;</code> instance is responsible for accepting, +     * all subscriptions and notifying all Observers. Unless the documentation, +     * for a particular <code>Observable&lt;T&gt;</code> implementation, +     * indicates otherwise, Observers should make no assumptions about the order, +     * in which multiple Observers will receive their notifications., +     * For more information see the, +     * <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * @param observer the Observer, +     * @return a {@link Subscription} reference with which the {@link Observer}, +     *         can stop receiving items before the Observable has finished, +     *         sending them, +     * @throws IllegalArgumentException if the {@link Observer} provided as the, +     *                                  argument to {@code subscribe()} is, +     *                                  {@code null}, +    public Subscription subscribe(Observer<? super T> observer) {, +        // allow the hook to intercept and/or decorate, +        OnSubscribeFunc<T> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);, +        // validate and proceed, +        if (observer == null) {, +            throw new IllegalArgumentException("observer can not be null");, +        if (onSubscribeFunction == null) {, +            throw new IllegalStateException("onSubscribe function can not be null.");, +            // the subscribe function can also be overridden but generally that's not the appropriate approach so I won't mention that in the exception, +        try {, +             * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +            if (isInternalImplementation(observer)) {, +                Subscription s = onSubscribeFunction.onSubscribe(observer);, +                if (s == null) {, +                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens, +                    // we want to gracefully handle it the same as AtomicObservableSubscription does, +                    return hook.onSubscribeReturn(this, Subscriptions.empty());, +                } else {, +                    return hook.onSubscribeReturn(this, s);, +            } else {, +                SafeObservableSubscription subscription = new SafeObservableSubscription();, +                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));, +                return hook.onSubscribeReturn(this, subscription);, +        } catch (OnErrorNotImplementedException e) {, +            // special handling when onError is not implemented ... we just rethrow, +            throw e;, +        } catch (Throwable e) {, +            // if an unhandled error occurs executing the onSubscribe we will propagate it, +            try {, +                observer.onError(hook.onSubscribeError(this, e));, +            } catch (OnErrorNotImplementedException e2) {, +                // special handling when onError is not implemented ... we just rethrow, +                throw e2;, +            } catch (Throwable e2) {, +                // if this happens it means the onError itself failed (perhaps an invalid function implementation), +                // so we are unable to propagate the error correctly and will just throw, +                RuntimeException r = new RuntimeException("Error occurred attempting to subscribe [" + e.getMessage() + "] and then again while trying to pass to onError.", e2);, +                hook.onSubscribeError(this, r);, +                throw r;, +            return Subscriptions.empty();, +     * An {@link Observer} must call an Observable's {@code subscribe} method in, +     * order to receive items and notifications from the Observable., +     * A typical implementation of {@code subscribe} does the following:, +     * <ol>, +     * <li>It stores a reference to the Observer in a collection object, such as, +     *     a {@code List<T>} object.</li>, +     * <li>It returns a reference to the {@link Subscription} interface. This, +     *     enables Observers to unsubscribe, that is, to stop receiving items, +     *     and notifications before the Observable stops sending them, which, +     *     also invokes the Observer's {@link Observer#onCompleted onCompleted}, +     *     method.</li>, +     * </ol><p>, +     * An {@code Observable<T>} instance is responsible for accepting all]