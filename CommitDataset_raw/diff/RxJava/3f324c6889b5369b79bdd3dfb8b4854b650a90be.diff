[+++ b/src/main/java/io/reactivex/Flowable.java, +    @Deprecated // prefetch is unnecessary when the sources is synchronously available, +        return concatArray(sources);, +     * @return the new Observable instance, +        return new FlowableConcatArray<T>(sources, false);, +    }, +, +    /**, +     * Concatenates a variable number of Observable sources and delays errors from any of them, +     * till all terminate., +     * @param sources the array of sources, +     * @param <T> the common base value type, +     * @return the new Flowable instance, +     * @throws NullPointerException if sources is null, +     */, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {, +        if (sources.length == 0) {, +            return empty();, +        } else, +        if (sources.length == 1) {, +            return fromPublisher(sources[0]);, +        }, +        return new FlowableConcatArray<T>(sources, true);, +++ b/src/main/java/io/reactivex/Flowable.java, +    @Deprecated // prefetch is unnecessary when the sources is synchronously available, +        return concatArray(sources);, +     * @return the new Observable instance, +        return new FlowableConcatArray<T>(sources, false);, +    }, +, +    /**, +     * Concatenates a variable number of Observable sources and delays errors from any of them, +     * till all terminate., +     * @param sources the array of sources, +     * @param <T> the common base value type, +     * @return the new Flowable instance, +     * @throws NullPointerException if sources is null, +     */, +    @BackpressureSupport(BackpressureKind.FULL), +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {, +        if (sources.length == 0) {, +            return empty();, +        } else, +        if (sources.length == 1) {, +            return fromPublisher(sources[0]);, +        }, +        return new FlowableConcatArray<T>(sources, true);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +package io.reactivex.internal.operators.flowable;, +, +import java.util.*;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.reactivestreams.*;, +, +import io.reactivex.Flowable;, +import io.reactivex.exceptions.CompositeException;, +import io.reactivex.internal.subscriptions.SubscriptionArbiter;, +, +public final class FlowableConcatArray<T> extends Flowable<T> {, +, +    final Publisher<? extends T>[] sources;, +    , +    final boolean delayError;, +    , +    public FlowableConcatArray(Publisher<? extends T>[] sources, boolean delayError) {, +        this.sources = sources;, +        this.delayError = delayError;, +    }, +, +    @Override, +    protected void subscribeActual(Subscriber<? super T> s) {, +        ConcatArraySubscriber<T> parent = new ConcatArraySubscriber<T>(sources, delayError, s);, +        s.onSubscribe(parent);, +        , +        parent.onComplete();, +    }, +    , +    static final class ConcatArraySubscriber<T> extends SubscriptionArbiter implements Subscriber<T> {, +        /** */, +        private static final long serialVersionUID = -8158322871608889516L;, +, +        final Subscriber<? super T> actual;, +        , +        final Publisher<? extends T>[] sources;]