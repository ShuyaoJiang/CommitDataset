[+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java, +++ b/src/test/java/rx/internal/operators/OperatorSampleTest.java, +import rx.*;, +import rx.subscriptions.Subscriptions;, +, +    @Test, +    public void testSampleUnsubscribe() {, +        final Subscription s = mock(Subscription.class);, +        Observable<Integer> o = Observable.create(, +                new OnSubscribe<Integer>() {, +                    @Override, +                    public void call(Subscriber<? super Integer> subscriber) {, +                        subscriber.add(s);, +                    }, +                }, +        );, +        o.throttleLast(1, TimeUnit.MILLISECONDS).subscribe().unsubscribe();, +        verify(s).unsubscribe();, +    }, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java, +++ b/src/test/java/rx/internal/operators/OperatorSampleTest.java]