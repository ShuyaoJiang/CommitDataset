[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  type Notification[T] = rx.Notification[_ <: T], +  type Timestamped[T] = rx.util.Timestamped[_ <: T], +, +  object util {, +    type Closing = rx.util.Closing, +    type Opening = rx.util.Opening, +  }, +  import All.util._, +  /**, +   * TODO doc, +   */, +  def zip[U](that: Observable[U]): Observable[(T, U)] = {, +    new Observable[(T, U)](JObservable.zip(this.asJava, that.asJava, (t: T, u: U) => (t, u))), +  }  , +  , +  // There is no method corresponding to, +  // public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second), +  // because the Scala-idiomatic way of doing this is, +  // (first zip second) map (p => p._1 == p._2), +  , +  // There is no method corresponding to  , +  // public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality), +  // because the Scala-idiomatic way of doing this is, +  // (first zip second) map (p => equality(p._1, p._2)), +  , +  /**, +   * Creates an Observable which produces buffers of collected values., +   * , +   * <p>This Observable produces connected non-overlapping buffers. The current buffer is, +   * emitted and replaced with a new buffer when the Observable produced by the specified {@link Func0} produces a {@link rx.util.Closing} object. The * {@link Func0} will then, +   * be used to create a new Observable to listen for the end of the next buffer., +   * , +   * @param bufferClosingSelector, +   *            The {@link Func0} which is used to produce an {@link Observable} for every buffer created., +   *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +   *            is emitted and replaced with a new one., +   * @return, +   *         An {@link Observable} which produces connected non-overlapping buffers, which are emitted, +   *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link rx.util.Closing} object., +   */, +  // TODO 1: buffer does not work because Java returns a mutable java.util.List[T] which is invariant in T, +  // But in Scala, we would like to have an immutable List[T] which is covariant in T, +  // TODO 2: But even if we try to get a java.util.List[T], there is a problem, +  // -> core should respect covariance, but that's not the only problem, +  def buffer(bufferClosingSelector: () => Observable[Closing]) : Observable[List[T]] = {, +    val f: rx.util.functions.Func0[_ <: rx.Observable[_ <: Closing]] = bufferClosingSelector().asJava, +    // type mismatch; found : rx.Observable[java.util.List[_$3]] required: rx.Observable[_ <: java.util.List[T]], +    // val o: rx.Observable[_ <: java.util.List[T]] = asJava.buffer(f), +    val o: rx.Observable[_ <: java.util.List[T]] = ???, +    // type mismatch; found : rx.Observable[java.util.List[_$3]] required: rx.Observable[java.util.List[T]], +    // val o2: rx.Observable[java.util.List[T]] = asJava.buffer(f), +    val r = new Observable[java.util.List[T]](o), +    ???, +  }, +  , +  // public Observable<List<T>> buffer(Func0<? extends Observable<? extends Closing>> bufferClosingSelector) , +, +  /**, +   * Creates an Observable which produces buffers of collected values., +   * , +   * <p>This Observable produces buffers. Buffers are created when the specified "bufferOpenings", +   * Observable produces a {@link rx.util.Opening} object. Additionally the {@link Func0} argument, +   * is used to create an Observable which produces {@link rx.util.Closing} objects. When this, +   * Observable produces such an object, the associated buffer is emitted., +   * , +   * @param bufferOpenings, +   *            The {@link Observable} which, when it produces a {@link rx.util.Opening} object, will cause, +   *            another buffer to be created., +   * @param bufferClosingSelector, +   *            The {@link Func0} which is used to produce an {@link Observable} for every buffer created., +   *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +   *            is emitted., +   * @return, +   *         An {@link Observable} which produces buffers which are created and emitted when the specified {@link Observable}s publish certain objects., +   */, +  // public Observable<List<T>> buffer(Observable<? extends Opening> bufferOpenings, Func1<Opening, ? extends Observable<? extends Closing>> bufferClosingSelector) , +, +  /**, +   * Creates an Observable which produces buffers of collected values., +   * , +   * <p>This Observable produces connected non-overlapping buffers, each containing "count", +   * elements. When the source Observable completes or encounters an error, the current, +   * buffer is emitted, and the event is propagated., +   * , +   * @param count, +   *            The maximum size of each buffer before it should be emitted., +   * @return, +   *         An {@link Observable} which produces connected non-overlapping buffers containing at most, +   *         "count" produced values., +   */, +  // public Observable<List<T>> buffer(int count) , +, +  /**, +   * Creates an Observable which produces buffers of collected values., +   * , +   * <p>This Observable produces buffers every "skip" values, each containing "count", +   * elements. When the source Observable completes or encounters an error, the current, +   * buffer is emitted, and the event is propagated., +   * ]