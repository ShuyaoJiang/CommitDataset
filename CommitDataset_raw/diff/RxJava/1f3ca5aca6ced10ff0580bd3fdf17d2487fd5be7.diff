[+++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +import java.util.Queue;, +import rx.exceptions.MissingBackpressureException;, +import rx.internal.util.*;, +import rx.internal.util.unsafe.*;, +/**, + * A connectable observable which shares an underlying source and dispatches source values to subscribers in a backpressure-aware, + * manner. , + * @param <T> the value type, + */, +public final class OperatorPublish<T> extends ConnectableObservable<T> {, +    /** The source observable. */, +    /** Holds the current subscriber that is, will be or just was subscribed to the source observable. */, +    final AtomicReference<PublishSubscriber<T>> current;, +    /**, +     * Creates a OperatorPublish instance to publish values of the given source observable., +     * @param source the source observable, +     * @return the connectable observable, +     */, +        // the current connection to source needs to be shared between the operator and its onSubscribe call, +        final AtomicReference<PublishSubscriber<T>> curr = new AtomicReference<PublishSubscriber<T>>();, +        OnSubscribe<T> onSubscribe = new OnSubscribe<T>() {, +            @Override, +            public void call(Subscriber<? super T> child) {, +                // concurrent connection/disconnection may change the state, , +                // we loop to be atomic while the child subscribes, +                for (;;) {, +                    // get the current subscriber-to-source, +                    PublishSubscriber<T> r = curr.get();, +                    // if there isn't one or it is unsubscribed, +                    if (r == null || r.isUnsubscribed()) {, +                        // create a new subscriber to source, +                        PublishSubscriber<T> u = new PublishSubscriber<T>(curr);, +                        // perform extra initialization to avoid 'this' to escape during construction, +                        u.init();, +                        // let's try setting it as the current subscriber-to-source, +                        if (!curr.compareAndSet(r, u)) {, +                            // didn't work, maybe someone else did it or the current subscriber , +                            // to source has just finished, +                            continue;, +                        }, +                        // we won, let's use it going onwards, +                        r = u;, +                    // create the backpressure-managing producer for this child, +                    InnerProducer<T> inner = new InnerProducer<T>(r, child);, +                    /*, +                     * Try adding it to the current subscriber-to-source, add is atomic in respect , +                     * to other adds and the termination of the subscriber-to-source., +                     */, +                    if (!r.add(inner)) {, +                        /*, +                         * The current PublishSubscriber has been terminated, try with a newer one., +                         */, +                        continue;, +                        /*, +                         * Note: although technically corrent, concurrent disconnects can cause , +                         * unexpected behavior such as child subscribers never receiving anything , +                         * (unless connected again). An alternative approach, similar to , +                         * PublishSubject would be to immediately terminate such child , +                         * subscribers as well:, +                         * , +                         * Object term = r.terminalEvent;, +                         * if (r.nl.isCompleted(term)) {, +                         *     child.onCompleted();, +                         * } else {, +                         *     child.onError(r.nl.getError(term));, +                         * }, +                         * return;, +                         * , +                         * The original concurrent behavior was non-deterministic in this regard as well., +                         * Allowing this behavior, however, may introduce another unexpected behavior:, +                         * after disconnecting a previous connection, one might not be able to prepare, +                         * a new connection right after a previous termination by subscribing new child , +                         * subscribers asynchronously before a connect call., +                         */, +                    }, +                    // the producer has been registered with the current subscriber-to-source so , +                    // at least it will receive the next terminal event, +                    child.add(inner);, +                    // setting the producer will trigger the first request to be considered by , +                    // the subscriber-to-source., +                    child.setProducer(inner);, +                    break;, +                }, +            }, +        };, +        return new OperatorPublish<T>(onSubscribe, source, curr);, +    }, +    public static <T, R> Observable<R> create(final Observable<? extends T> source, , +            final Func1<? super Observable<T>, ? extends Observable<R>> selector) {, +        return create(new OnSubscribe<R>() {, +                ConnectableObservable<T> op = create(source);, +                , +                , +                    public void call(Subscription t1) {, +                        child.add(t1);, +                });, +            }, +    private OperatorPublish(OnSubscribe<T> onSubscribe, Observable<? extends T> source, , +            final AtomicReference<PublishSubscriber<T>> current) {]