[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */, +  override val asJavaSubscription: rx.subscriptions.SerialSubscription = new rx.subscriptions.SerialSubscription() {, +    override def unsubscribe(): Unit = {, +      if(unsubscribed.compareAndSet(false, true)) { serial.unsubscribe() }, +    override def setSubscription(subscription: rx.Subscription): Unit = serial.setSubscription(subscription), +    override def getSubscription(): rx.Subscription = serial.getSubscription(), +  }, +, +  def subscription_=(value: Subscription): this.type = { asJavaSubscription.setSubscription(value.asJavaSubscription); this }, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */, +  override val asJavaSubscription: rx.subscriptions.SerialSubscription = new rx.subscriptions.SerialSubscription() {, +    override def unsubscribe(): Unit = {, +      if(unsubscribed.compareAndSet(false, true)) { serial.unsubscribe() }, +    override def setSubscription(subscription: rx.Subscription): Unit = serial.setSubscription(subscription), +    override def getSubscription(): rx.Subscription = serial.getSubscription(), +  }, +, +  def subscription_=(value: Subscription): this.type = { asJavaSubscription.setSubscription(value.asJavaSubscription); this }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFirstOrDefault;, +import rx.operators.OperationLast;, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +        return from(iterable).observeOn(scheduler);, +     * @param items the source sequence, +        return create(OperationToObservableIterable.toObservableIterable(Arrays.asList(items)));, +     * Note: the items will be immediately emitted each time an {@link Observer}, +     * subscribes. Since this occurs before the {@link Subscription} is, +     * returned, it is not possible to unsubscribe from the sequence before it, +     * completes., +     * , +     * Note: the entire range is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     * , +        return range(start, count).observeOn(scheduler);, +        List<T> list = new ArrayList<T>();, +        list.add(value);, +, +        return from(list);, +        return just(value).observeOn(scheduler);, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal">RxJava Wiki: sequenceEqual()</a>, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal">RxJava Wiki: sequenceEqual()</a>, +        return ws.toList().mapMany(new Func1<List<? extends Observable<?>>, Observable<? extends R>>() {, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#exists-and-isempty">RxJava Wiki: exists()</a>, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#contains">RxJava Wiki: contains()</a>, +        return mapMany(func);, +        return create(OperationMap.mapMany(this, func));, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#all">RxJava Wiki: all()</a>, +     * source Observable., +     * @return an Observable that emits only the very first item emitted by the, +     *         source Observable, or nothing if the source Observable completes, +     *         without emitting a single item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return take(1);, +     * source Observable that satisfies a given condition., +     *         given condition from the source, or nothing if the source, +     *         Observable completes without emitting a single matching item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return skipWhile(not(predicate)).take(1);, +        return create(OperationFirstOrDefault.firstOrDefault(this, defaultValue));, +    public Observable<T> firstOrDefault(Func1<? super T, Boolean> predicate, T defaultValue) {, +        return create(OperationFirstOrDefault.firstOrDefault(this, predicate, defaultValue));, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#defaultifempty">RxJava Wiki: defaultIfEmpty()</a>, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#takewhile-and-takewhilewithindex">RxJava Wiki: takeWhile()</a>, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#takewhile-and-takewhilewithindex">RxJava Wiki: takeWhileWithIndex()</a>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">, +     *         source, or none if the source Observable completes without, +     *         emitting a single item, +     * @see #first(), +        return first();, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstN.png">, +     *         given condition from the source, or none if the source Observable, +     *         completes without emitting a single matching item, +     * @see #first(Func1), +        return first(predicate);]