[+++ b/src/main/java/rx/Observable.java, +import rx.internal.producers.SingleProducer;, +    /**, +     * Returns a Single that emits the single item emitted by the source Observable, if that Observable, +     * emits only a single item. If the source Observable emits more than one item or no items, notify of an, +     * {@code IllegalArgumentException} or {@code NoSuchElementException} respectively., +     * <p>, +     * <img width="640" height="295" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSingle.png" alt="">, +     * <dl>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code toSingle} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @return a Single that emits the single item emitted by the source Observable, +     * @throws IllegalArgumentException, +     *             if the source observable emits more than one item, +     * @throws NoSuchElementException, +     *             if the source observable emits no items, +     * @see <a href="http://reactivex.io/documentation/single.html">ReactiveX documentation: Single</a>, +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +     */, +    @Experimental, +    public Single<T> toSingle() {, +        return new Single<T>(OnSubscribeSingle.create(this));, +    }, +    /** Lazy initialized Holder for an empty observable which just emits onCompleted to any subscriber. */, +    private static final class EmptyHolder {, +        final static Observable<Object> INSTANCE = create(new OnSubscribe<Object>() {, +            public void call(Subscriber<? super Object> subscriber) {, +                subscriber.onCompleted();, +    }, +        return (Observable<T>) EmptyHolder.INSTANCE;, +     * @param capacityHint hint for number of items to cache (for optimizing underlying data structure), +    public final Observable<T> cache(int capacityHint) {, +        return CachedObservable.from(this, capacityHint);, +    public final Observable<T> defaultIfEmpty(final T defaultValue) {, +        //if empty switch to an observable that emits defaultValue and supports backpressure, +        return switchIfEmpty(Observable.create(new OnSubscribe<T>() {, +, +            @Override, +            public void call(Subscriber<? super T> subscriber) {, +                subscriber.setProducer(new SingleProducer<T>(subscriber, defaultValue));, +            }}));, +     * Returns an Observable that emits only the first {@code count} items emitted by the source Observable., +     * {@link Observer#onNext onNext} function a maximum of {@code count} times before invoking, +     * @param count, +     * @return an Observable that emits only the first {@code count} items emitted by the source Observable, or, +     *         all of the items from the source Observable if that Observable emits fewer than {@code count} items, +    public final Observable<T> limit(int count) {, +        return take(count);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay();, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize);, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize, time, unit, scheduler);, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +    public final <R> Observable<R> replay(final Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize);, +        }, new Func1<Observable<T>, Observable<R>>() {, +            @Override, +            public Observable<R> call(Observable<T> t) {, +                return selector.call(t).observeOn(scheduler);, +            }, +        });, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(time, unit, scheduler);]