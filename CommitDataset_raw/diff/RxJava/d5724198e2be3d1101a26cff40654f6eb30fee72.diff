[+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, +     * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, +     * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, +     * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java, +    @Override, +     * Rethrows the throwable if it is a fatal exception or calls {@link #onError(Throwable)}., +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, +     * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java, +    @Override, +     * Rethrows the throwable if it is a fatal exception or calls {@link #onError(Throwable)}., +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java, +    @Override, +     * Rethrows the throwable if it is a fatal exception or calls {@link #onError(Throwable)}., +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, +     * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, +    @Override, +    @Override, +    @Override, +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java, +    @Override, +     * Rethrows the throwable if it is a fatal exception or calls {@link #onError(Throwable)}., +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java, +    @Override, +     * Rethrows the throwable if it is a fatal exception or calls {@link #onError(Throwable)}., +++ b/src/test/java/io/reactivex/internal/operators/observable/BlockingObservableLatestTest.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators.observable;, +, +import java.util.*;, +import java.util.concurrent.TimeUnit;, +, +import org.junit.*;, +, +import io.reactivex.Observable;, +import io.reactivex.observables.BlockingObservable;, +import io.reactivex.schedulers.TestScheduler;, +import io.reactivex.subjects.PublishSubject;, +, +public class BlockingObservableLatestTest {, +    @Test(timeout = 1000), +    public void testSimple() {, +        TestScheduler scheduler = new TestScheduler();, +, +        BlockingObservable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10).toBlocking();, +, +        Iterable<Long> iter = source.latest();, +]