[+++ b/src/main/java/rx/Observable.java, +        return create(new OnSubscribeCache<T>(this));, +        return create(new OnSubscribeCache<T>(this, capacityHint));, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay();, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize);, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize, time, unit, scheduler);, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +    public final <R> Observable<R> replay(final Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(bufferSize);, +        }, new Func1<Observable<T>, Observable<R>>() {, +            @Override, +            public Observable<R> call(Observable<T> t) {, +                return selector.call(t).observeOn(scheduler);, +            }, +        });, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay(time, unit, scheduler);, +        }, selector);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +    public final <R> Observable<R> replay(final Func1<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(new Func0<ConnectableObservable<T>>() {, +            public ConnectableObservable<T> call() {, +                return Observable.this.replay();, +        }, new Func1<Observable<T>, Observable<R>>() {, +            @Override, +            public Observable<R> call(Observable<T> t) {, +                return selector.call(t).observeOn(scheduler);, +            }, +        });, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this, bufferSize);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this, time, unit, scheduler, bufferSize);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.observeOn(replay(bufferSize), scheduler);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this, time, unit, scheduler);, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.observeOn(replay(), scheduler);, +++ b/src/main/java/rx/Observable.java, +        return create(new OnSubscribeCache<T>(this));, +        return create(new OnSubscribeCache<T>(this, capacityHint));, +     *  <dd>This operator supports backpressure. Note that the upstream requests are determined by the child, +     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will, +     *  request 100 elements from the underlying Observable sequence.</dd>, +        return OperatorReplay.create(this);]