[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def retryWhenExample(): Unit = {, +    Observable[String]({ subscriber =>, +      println("subscribing"), +      subscriber.onError(new RuntimeException("always fails")), +    }).retryWhen(attempts => {, +      attempts.zipWith(Observable.from(1 to 3))((n, i) => i).flatMap(i => {, +        println("delay retry by " + i + " second(s)"), +        Observable.timer(Duration(i, TimeUnit.SECONDS)), +      }), +    }).toBlocking.foreach(s => println(s)), +  }, +, +  @Test def repeatWhenExample(): Unit = {, +    Observable[String]({ subscriber =>, +      println("subscribing"), +      subscriber.onCompleted(), +    }).repeatWhen(attempts => {, +      attempts.zipWith(Observable.from(1 to 3))((n, i) => i).flatMap(i => {, +        println("delay repeat by " + i + " second(s)"), +        Observable.timer(Duration(i, TimeUnit.SECONDS)).materialize, +      }), +    }, NewThreadScheduler()).toBlocking.foreach(s => println(s)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def retryWhenExample(): Unit = {, +    Observable[String]({ subscriber =>, +      println("subscribing"), +      subscriber.onError(new RuntimeException("always fails")), +    }).retryWhen(attempts => {, +      attempts.zipWith(Observable.from(1 to 3))((n, i) => i).flatMap(i => {, +        println("delay retry by " + i + " second(s)"), +        Observable.timer(Duration(i, TimeUnit.SECONDS)), +      }), +    }).toBlocking.foreach(s => println(s)), +  }, +, +  @Test def repeatWhenExample(): Unit = {, +    Observable[String]({ subscriber =>, +      println("subscribing"), +      subscriber.onCompleted(), +    }).repeatWhen(attempts => {, +      attempts.zipWith(Observable.from(1 to 3))((n, i) => i).flatMap(i => {, +        println("delay repeat by " + i + " second(s)"), +        Observable.timer(Duration(i, TimeUnit.SECONDS)).materialize, +      }), +    }, NewThreadScheduler()).toBlocking.foreach(s => println(s)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits the same values as the source observable with the exception of an, +   * {@code onError}. An {@code onError} notification from the source will result in the emission of a, +   * {@link Notification} to the Observable provided as an argument to the {@code notificationHandler}, +   * function. If the Observable returned {@code onCompletes} or {@code onErrors} then {@code retry} will call, +   * {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will, +   * resubscribe to the source Observable., +   * <p>, +   * <img width="640" height="430" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retryWhen.f.png" alt="">, +   *, +   * Example:, +   *, +   * This retries 3 times, each time incrementing the number of seconds it waits., +   *, +   * <pre> {@code, +   * Observable[String]({ subscriber =>, +   *   println("subscribing"), +   *   subscriber.onError(new RuntimeException("always fails")), +   * }).retryWhen(attempts => {, +   *   attempts.zipWith(Observable.from(1 to 3))((n, i) => i).flatMap(i => {, +   *     println("delay retry by " + i + " second(s)"), +   *     Observable.timer(Duration(i, TimeUnit.SECONDS)), +   *   }), +   * }).toBlocking.foreach(s => println(s)), +   * } </pre>, +   *, +   * Output is:, +   *, +   * <pre> {@code, +   * subscribing, +   * delay retry by 1 second(s), +   * subscribing, +   * delay retry by 2 second(s), +   * subscribing, +   * delay retry by 3 second(s), +   * subscribing, +   * } </pre>, +   * <dl>, +   *  <dt><b>Scheduler:</b></dt>, +   *  <dd>{@code retryWhen} operates by default on the {@code trampoline} {@link Scheduler}.</dd>, +   * </dl>, +   *, +   * @param notificationHandler receives an Observable of notifications with which a user can complete or error, aborting the, +   *            retry, +   * @return the source Observable modified with retry logic, +   * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retrywhen">RxJava Wiki: retryWhen()</a>, +   * @since 0.20, +   */, +  def retryWhen(notificationHandler: Observable[Notification[Any]] => Observable[Any]): Observable[T] = {, +    val f: Func1[_ >: rx.Observable[_ <: rx.Notification[_ <: Any]], _ <: rx.Observable[_ <: Any]] =]