[+++ b/build.gradle, +def jacocoVersion = "0.8.0", +    toolVersion = jacocoVersion // See http://www.eclemma.org/jacoco/., +++ b/build.gradle, +def jacocoVersion = "0.8.0", +    toolVersion = jacocoVersion // See http://www.eclemma.org/jacoco/., +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java, +import io.reactivex.*;, +import io.reactivex.internal.util.*;, +import io.reactivex.subscribers.DisposableSubscriber;, +    final int capacityHint;, +    public FlowableWindowBoundary(Flowable<T> source, Publisher<B> other, int capacityHint) {, +        this.capacityHint = capacityHint;, +    protected void subscribeActual(Subscriber<? super Flowable<T>> subscriber) {, +        WindowBoundaryMainSubscriber<T, B> parent = new WindowBoundaryMainSubscriber<T, B>(subscriber, capacityHint);, +, +        subscriber.onSubscribe(parent);, +, +        parent.innerNext();, +, +        other.subscribe(parent.boundarySubscriber);, +, +        source.subscribe(parent);, +    extends AtomicInteger, +    implements FlowableSubscriber<T>, Subscription, Runnable {, +        private static final long serialVersionUID = 2233020065421370272L;, +        final Subscriber<? super Flowable<T>> downstream;, +        final int capacityHint;, +, +        final WindowBoundaryInnerSubscriber<T, B> boundarySubscriber;, +, +        final AtomicReference<Subscription> upstream;, +, +        final AtomicInteger windows;, +, +        final MpscLinkedQueue<Object> queue;, +, +        final AtomicThrowable errors;, +, +        final AtomicBoolean stopWindows;, +, +        final AtomicLong requested;, +, +        static final Object NEXT_WINDOW = new Object();, +, +        volatile boolean done;, +        long emitted;, +        WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> downstream, int capacityHint) {, +            this.downstream = downstream;, +            this.capacityHint = capacityHint;, +            this.boundarySubscriber = new WindowBoundaryInnerSubscriber<T, B>(this);, +            this.upstream = new AtomicReference<Subscription>();, +            this.windows = new AtomicInteger(1);, +            this.queue = new MpscLinkedQueue<Object>();, +            this.errors = new AtomicThrowable();, +            this.stopWindows = new AtomicBoolean();, +            this.requested = new AtomicLong();, +        public void onSubscribe(Subscription d) {, +            if (SubscriptionHelper.setOnce(upstream, d)) {, +                d.request(Long.MAX_VALUE);, +            queue.offer(t);, +            drain();, +        public void onError(Throwable e) {, +            boundarySubscriber.dispose();, +            if (errors.addThrowable(e)) {, +                drain();, +            } else {, +                RxJavaPlugins.onError(e);, +            boundarySubscriber.dispose();, +            drain();, +            if (stopWindows.compareAndSet(false, true)) {, +                boundarySubscriber.dispose();, +                if (windows.decrementAndGet() == 0) {, +                    SubscriptionHelper.cancel(upstream);, +                }, +            }, +        @Override, +        public void request(long n) {, +            BackpressureHelper.add(requested, n);, +        }, +, +        @Override, +        public void run() {, +            if (windows.decrementAndGet() == 0) {, +                SubscriptionHelper.cancel(upstream);, +            }, +        }, +, +        void innerNext() {, +            queue.offer(NEXT_WINDOW);, +            drain();, +        }, +, +        void innerError(Throwable e) {, +            SubscriptionHelper.cancel(upstream);, +            if (errors.addThrowable(e)) {, +                done = true;, +                drain();, +            } else {, +                RxJavaPlugins.onError(e);]