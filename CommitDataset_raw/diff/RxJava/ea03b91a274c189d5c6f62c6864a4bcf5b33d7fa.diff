[+++ b/src/main/java/io/reactivex/Flowable.java, +        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));, +++ b/src/main/java/io/reactivex/Flowable.java, +        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +/**, + * Subscribes to the source Flowable on the specified Scheduler and makes, + * sure downstream requests are scheduled there as well., + *, + * @param <T> the value type emitted, + */, +, +    final boolean nonScheduledRequests;, +, +    public FlowableSubscribeOn(Publisher<T> source, Scheduler scheduler, boolean nonScheduledRequests) {, +        this.nonScheduledRequests = nonScheduledRequests;, +        final SubscribeOnSubscriber<T> sos = new SubscribeOnSubscriber<T>(s, w, source, nonScheduledRequests);, +, +, +        final boolean nonScheduledRequests;, +, +        SubscribeOnSubscriber(Subscriber<? super T> actual, Scheduler.Worker worker, Publisher<T> source, boolean nonScheduledRequests) {, +            this.nonScheduledRequests = nonScheduledRequests;, +            if (nonScheduledRequests || Thread.currentThread() == get()) {, +++ b/src/main/java/io/reactivex/Flowable.java, +        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +/**, + * Subscribes to the source Flowable on the specified Scheduler and makes, + * sure downstream requests are scheduled there as well., + *, + * @param <T> the value type emitted, + */, +, +    final boolean nonScheduledRequests;, +, +    public FlowableSubscribeOn(Publisher<T> source, Scheduler scheduler, boolean nonScheduledRequests) {, +        this.nonScheduledRequests = nonScheduledRequests;, +        final SubscribeOnSubscriber<T> sos = new SubscribeOnSubscriber<T>(s, w, source, nonScheduledRequests);, +, +, +        final boolean nonScheduledRequests;, +, +        SubscribeOnSubscriber(Subscriber<? super T> actual, Scheduler.Worker worker, Publisher<T> source, boolean nonScheduledRequests) {, +            this.nonScheduledRequests = nonScheduledRequests;, +            if (nonScheduledRequests || Thread.currentThread() == get()) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java, +import io.reactivex.internal.functions.Functions;, +            final SubscribeOnSubscriber<Integer> so = new SubscribeOnSubscriber<Integer>(ts, w, Flowable.<Integer>never(), true);, +, +    @Test, +    public void nonScheduledRequests() {, +        TestSubscriber<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {, +            @Override, +            public void subscribe(FlowableEmitter<Object> s) throws Exception {, +                for (int i = 1; i < 1001; i++) {, +                    s.onNext(i);, +                    Thread.sleep(1);, +                }, +                s.onComplete();, +            }, +        }, BackpressureStrategy.DROP), +        .subscribeOn(Schedulers.single()), +        .observeOn(Schedulers.computation()), +        .test(), +        .awaitDone(5, TimeUnit.SECONDS), +        .assertNoErrors(), +        .assertComplete();, +, +        int c = ts.valueCount();, +, +        assertTrue("" + c, c > Flowable.bufferSize());, +    }, +, +    @Test, +    public void scheduledRequests() {, +        Flowable.create(new FlowableOnSubscribe<Object>() {, +            @Override, +            public void subscribe(FlowableEmitter<Object> s) throws Exception {, +                for (int i = 1; i < 1001; i++) {, +                    s.onNext(i);, +                    Thread.sleep(1);, +                }, +                s.onComplete();, +            }, +        }, BackpressureStrategy.DROP), +        .map(Functions.identity()), +        .subscribeOn(Schedulers.single()), +        .observeOn(Schedulers.computation()), +        .test(), +        .awaitDone(5, TimeUnit.SECONDS), +        .assertValueCount(Flowable.bufferSize()), +        .assertNoErrors(), +        .assertComplete();, +    }]