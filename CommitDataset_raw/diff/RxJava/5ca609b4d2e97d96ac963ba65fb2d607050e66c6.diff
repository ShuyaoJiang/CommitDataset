[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCache;, +        return create(OperationCache.cache(this));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCache;, +        return create(OperationCache.cache(this));, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import javax.management.NotificationListener;, +, +import rx.Notification;, +import rx.operators.NotificationLite;, +    private NotificationLite<T> on = NotificationLite.instance();, +                queue.add(on.completed());, +                queue.add(on.error(e));, +                queue.add(on.next(t));, +            on.accept(actual, v);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCache;, +        return create(OperationCache.cache(this));, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import javax.management.NotificationListener;, +, +import rx.Notification;, +import rx.operators.NotificationLite;, +    private NotificationLite<T> on = NotificationLite.instance();, +                queue.add(on.completed());, +                queue.add(on.error(e));, +                queue.add(on.next(t));, +            on.accept(actual, v);, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +, +    private final NotificationLite<T> on = NotificationLite.instance();, +                            on.accept(actual, o);, +                        queue.offer(on.next(t));, +                        queue.offer(on.error(e));, +                        queue.offer(on.completed());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCache;, +        return create(OperationCache.cache(this));, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import javax.management.NotificationListener;, +, +import rx.Notification;, +import rx.operators.NotificationLite;, +    private NotificationLite<T> on = NotificationLite.instance();, +                queue.add(on.completed());, +                queue.add(on.error(e));, +                queue.add(on.next(t));, +            on.accept(actual, v);, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +, +    private final NotificationLite<T> on = NotificationLite.instance();, +                            on.accept(actual, o);, +                        queue.offer(on.next(t));, +                        queue.offer(on.error(e));, +                        queue.offer(on.completed());, +++ b/rxjava-core/src/main/java/rx/operators/NotificationLite.java, +package rx.operators;, +, +import java.io.ObjectStreamException;, +import java.io.Serializable;, +, +import rx.Notification;, +import rx.Notification.Kind;, +import rx.Observer;, +, +/**, + * For use in internal operators that need something like materialize and dematerialize wholly, + * within the implementation of the operator but don't want to incur the allocation cost of actually, + * creating {@link rx.Notification} objects for every onNext and onComplete., + * , + * An object is allocated inside {@link #error(Throwable)} to wrap the {@link Throwable} but this, + * shouldn't effect performance because exceptions should be exceptionally rare., + * , + * It's implemented as a singleton to maintain some semblance of type safety that is completely, + * non-existent., + * , + * @author gscampbell, + * , + * @param <T>, + */, +public final class NotificationLite<T> {, +    private NotificationLite() {, +    }, +, +    private static final NotificationLite INSTANCE = new NotificationLite();, +, +    @SuppressWarnings("unchecked"), +    public static <T> NotificationLite<T> instance() {, +        return INSTANCE;, +    }, +, +    private static final Object ON_COMPLETED_SENTINEL = new Serializable() {, +        private static final long serialVersionUID = 1;, +    };, +, +    private static final Object ON_NEXT_NULL_SENTINEL = new Serializable() {, +        private static final long serialVersionUID = 2;, +    };, +]