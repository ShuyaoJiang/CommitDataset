[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import static org.junit.Assert.assertEquals;, +import java.util.*;, +import java.util.concurrent.*;, +import rx.util.Exceptions;, +    public Iterable<T> toIterable() {, +        final BlockingQueue<Notification<T>> notifications = new LinkedBlockingQueue<Notification<T>>();, +, +        materialize().subscribe(new Observer<Notification<T>>() {, +            @Override, +            public void onCompleted() {, +                // ignore, +            }, +, +            @Override, +            public void onError(Exception e) {, +                // ignore, +            }, +, +            @Override, +            public void onNext(Notification<T> args) {, +                notifications.offer(args);, +            }, +        });, +, +        final Iterator<T> it = new Iterator<T>() {, +            private Notification<T> buf;, +, +            @Override, +            public boolean hasNext() {, +                if (buf == null) {, +                    buf = take();, +                }, +                return !buf.isOnCompleted();, +            }, +, +            @Override, +            public T next() {, +                if (buf == null) {, +                    buf = take();, +                }, +                if (buf.isOnError()) {, +                    throw Exceptions.propagate(buf.getException());, +                }, +, +                T result = buf.getValue();, +                buf = null;, +                return result;, +            }, +, +            private Notification<T> take() {, +                try {, +                    return notifications.take();, +                } catch (InterruptedException e) {, +                    throw Exceptions.propagate(e);, +                }, +            }, +, +            @Override, +            public void remove() {, +                throw new UnsupportedOperationException("Read-only iterator");, +            }, +        };, +, +        return new Iterable<T>() {, +            @Override, +            public Iterator<T> iterator() {, +                return it;, +            }, +        };, +    }, +, +, +        @Test, +        public void testToIterable() {, +            Observable<String> obs = toObservable("one", "two", "three");, +, +            Iterator<String> it = obs.toIterable().iterator();, +, +            assertEquals(true, it.hasNext());, +            assertEquals("one", it.next());, +, +            assertEquals(true, it.hasNext());, +            assertEquals("two", it.next());, +, +            assertEquals(true, it.hasNext());, +            assertEquals("three", it.next());, +, +            assertEquals(false, it.hasNext());, +, +        }, +, +        @Test(expected = TestException.class), +        public void testToIterableWithException() {, +            Observable<String> obs = create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(Observer<String> observer) {, +                    observer.onNext("one");, +                    observer.onError(new TestException());]