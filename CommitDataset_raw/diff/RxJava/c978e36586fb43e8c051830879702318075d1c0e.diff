[+++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java, +++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java, +import java.util.Arrays;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +import org.mockito.InOrder;, +, +import rx.subscriptions.BooleanSubscription;, +import rx.util.Exceptions;, +     * Combine the observable sequences from the list of Observables into one, +     * observable sequence without any transformation.  If either the outer, +     * observable or an inner observable calls onError, we will call onError., +     * <p/>, +     *, +     * The outer observable might run on a separate thread from (one of) the, +     * inner observables; in this case care must be taken to avoid a deadlock., +     * The Concat operation may block the outer thread while servicing an inner, +     * thread in order to ensure a well-defined ordering of elements; therefore, +     * none of the inner threads must be implemented in a way that might wait on, +     * the outer thread., +     *, +     * <p/>, +     *, +     * Beware that concat(o1,o2).subscribe() is a blocking call from, +     * which it is impossible to unsubscribe if observables are running on same thread., +     *, +     * @param sequences An observable sequence of elements to project., +        return concat(Observable.toObservable(sequences));, +    }, +, +    public static <T> Func1<Observer<T>, Subscription> concat(final List<Observable<T>> sequences) {, +        return concat(Observable.toObservable(sequences));, +    }, +, +    public static <T> Func1<Observer<T>, Subscription> concat(final Observable<Observable<T>> sequences) {, +                return new ConcatSubscription<T>(sequences, observer);, +    private static class ConcatSubscription<T> extends BooleanSubscription {, +        // Might be updated by an inner thread's onError during the outer, +        // thread's onNext, then read in the outer thread's onComplete., +        final AtomicBoolean innerError = new AtomicBoolean(false);, +        public ConcatSubscription(Observable<Observable<T>> sequences, final Observer<T> observer) {, +            final AtomicObservableSubscription outerSubscription = new AtomicObservableSubscription();, +            outerSubscription.wrap(sequences.subscribe(new Observer<Observable<T>>() {, +                public void onNext(Observable<T> nextSequence) {, +                    // We will not return from onNext until the inner observer completes., +                    // NB: while we are in onNext, the well-behaved outer observable will not call onError or onCompleted., +                    final CountDownLatch latch = new CountDownLatch(1);, +                    final AtomicObservableSubscription innerSubscription = new AtomicObservableSubscription();, +                    innerSubscription.wrap(nextSequence.subscribe(new Observer<T>() {, +                        public void onNext(T item) {, +                            // Make our best-effort to release resources in the face of unsubscribe., +                            if (isUnsubscribed()) {, +                                innerSubscription.unsubscribe();, +                                outerSubscription.unsubscribe();, +                            } else {, +                                observer.onNext(item);, +                            outerSubscription.unsubscribe();, +                            innerError.set(true);, +                            latch.countDown();, +                        public void onCompleted() {, +                            // Continue on to the next sequence, +                            latch.countDown();, +                    }));, +                    try {, +                        latch.await();, +                    } catch (InterruptedException e) {, +                        Thread.currentThread().interrupt();, +                        throw Exceptions.propagate(e);, +                    }, +                }, +                @Override, +                public void onError(Exception e) {, +                    // NB: a well-behaved observable will not interleave on{Next,Error,Completed} calls., +                    observer.onError(e);, +                }, +                @Override, +                public void onCompleted() {, +                    // NB: a well-behaved observable will not interleave on{Next,Error,Completed} calls., +                    if (!innerError.get()) {, +                        observer.onCompleted();, +                    }, +                }, +            }));, +            @SuppressWarnings("unchecked"), +            Observer<String> observer = mock(Observer.class);, +, +            verify(observer, times(7)).onNext(anyString());, +            @SuppressWarnings("unchecked"), +            Observer<String> observer = mock(Observer.class);, +, +            verify(observer, times(7)).onNext(anyString());, +        public void testConcatObservableOfObservables() {, +            Observer<String> observer = mock(Observer.class);, +            , +  , +            verify(observer, times(7)).onNext(anyString());, +        /**, +         * Simple concat of 2 asynchronous observables ensuring it emits in correct order., +         */]