[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.subjects;, +, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Matchers.anyString;, +, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Test;, +import org.mockito.Mockito;, +, +import rx.Observer;, +import rx.Subscription;, +import rx.util.AtomicObservableSubscription;, +import rx.util.SynchronizedObserver;, +import rx.util.functions.Action1;, +import rx.util.functions.Func0;, +import rx.util.functions.Func1;, +, +/**, + * Subject that publishes only the last event to each {@link Observer} that has subscribed when the completes. , + * <p>, + * Example usage:, + * <p>, + * <pre> {@code, + , +  // observer will receive no onNext events., +  AsyncSubject<Object> subject = AsyncSubject.create();, +  subject.subscribe(observer);, +  subject.onNext("one");, +  subject.onNext("two");, +  subject.onNext("three");, + , +  // observer will receive "three" as the only onNext event., +  AsyncSubject<Object> subject = AsyncSubject.create();, +  subject.subscribe(observer);, +  subject.onNext("one");, +  subject.onNext("two");, +  subject.onNext("three");, +  subject.onCompleted();, + , +  } </pre>, + * , + * @param <T>, + */, +public class AsyncSubject<T> extends Subject<T, T> {, +	, +    public static <T> AsyncSubject<T> create() {, +        final ConcurrentHashMap<Subscription, Observer<T>> observers = new ConcurrentHashMap<Subscription, Observer<T>>();, +, +        Func1<Observer<T>, Subscription> onSubscribe = new Func1<Observer<T>, Subscription>() {, +            @Override, +            public Subscription call(Observer<T> observer) {, +                final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +, +                subscription.wrap(new Subscription() {, +                    @Override, +                    public void unsubscribe() {, +                        // on unsubscribe remove it from the map of outbound observers to notify, +                        observers.remove(subscription);, +                    }, +                });, +, +                // on subscribe add it to the map of outbound observers to notify, +                observers.put(subscription, new SynchronizedObserver<T>(observer, subscription));, +                return subscription;, +            }, +        };, +, +        return new AsyncSubject<T>(onSubscribe, observers);, +    }, +, +    private final ConcurrentHashMap<Subscription, Observer<T>> observers;, +    private final AtomicReference<T> currentValue;, +, +    protected AsyncSubject(Func1<Observer<T>, Subscription> onSubscribe, ConcurrentHashMap<Subscription, Observer<T>> observers) {, +        super(onSubscribe);, +        this.observers = observers;, +        this.currentValue = new AtomicReference<T>();]