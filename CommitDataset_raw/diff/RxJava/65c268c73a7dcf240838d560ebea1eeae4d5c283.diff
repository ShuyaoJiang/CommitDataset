[+++ b/CHANGES.md, +### Version 0.18.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.18.4%22)) ###, +, +This is a fix for `CompositeSubscription` object allocation problems. Details can be found in issue [#1204](https://github.com/Netflix/RxJava/issues/1204)., +, +* [Pull 1283](https://github.com/Netflix/RxJava/pull/1283) Subscription object allocation fix, +, +++ b/CHANGES.md, +### Version 0.18.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.18.4%22)) ###, +, +This is a fix for `CompositeSubscription` object allocation problems. Details can be found in issue [#1204](https://github.com/Netflix/RxJava/issues/1204)., +, +* [Pull 1283](https://github.com/Netflix/RxJava/pull/1283) Subscription object allocation fix, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def windowExample2() {, +    val windowObservable = Observable.interval(500 millis), +    val o = Observable.from(1 to 20).zip(Observable.interval(100 millis)).map(_._1), +    (for ((o, i) <- o.window(windowObservable).zipWithIndex; n <- o), +      yield s"Observable#$i emits $n", +    ).toBlocking.foreach(println), +  }, +, +  @Test def ambWithVarargsExample(): Unit = {, +    val o1 = List(100L, 200L, 300L).toObservable.delay(4 seconds), +    val o2 = List(1000L, 2000L, 3000L).toObservable.delay(2 seconds), +    val o3 = List(10000L, 20000L, 30000L).toObservable.delay(4 seconds), +    val result = Observable.amb(o1, o2, o3).toBlocking.toList, +    println(result), +  }, +, +  @Test def ambWithSeqExample(): Unit = {, +    val o1 = List(100L, 200L, 300L).toObservable.delay(4 seconds), +    val o2 = List(1000L, 2000L, 3000L).toObservable.delay(2 seconds), +    val o3 = List(10000L, 20000L, 30000L).toObservable.delay(4 seconds), +    val o = Seq(o1, o2, o3), +    val result = Observable.amb(o: _*).toBlocking.toList, +    println(result), +  }, +, +  def createAHotObservable: Observable[String] = {, +    var first = true, +    Observable[String] {, +      subscriber =>, +        if (first) {, +          subscriber.onNext("1st: First"), +          subscriber.onNext("1st: Last"), +          first = false, +        }, +        else {, +          subscriber.onNext("2nd: First"), +          subscriber.onNext("2nd: Last"), +        }, +        subscriber.onCompleted(), +    }, +  }, +, +  @Test def withoutPublishLastExample() {, +    val hot = createAHotObservable, +    hot.takeRight(1).subscribe(n => println(s"subscriber 1 gets $n")), +    hot.takeRight(1).subscribe(n => println(s"subscriber 2 gets $n")), +  }, +, +  @Test def publishLastExample() {, +    val hot = createAHotObservable, +    val o = hot.publishLast, +    o.subscribe(n => println(s"subscriber 1 gets $n")), +    o.subscribe(n => println(s"subscriber 2 gets $n")), +    o.connect, +  }, +, +  @Test def publishLastExample2() {, +    val hot = createAHotObservable, +    val o = hot.publishLast(co => co ++ co) // "++" subscribes "co" twice, +    o.subscribe(n => println(s"subscriber gets $n")), +  }, +, +  @Test def unsubscribeOnExample() {, +    val o = Observable[String] {, +      subscriber =>, +        subscriber.add(Subscription {, +          println("unsubscribe on " + Thread.currentThread().getName()), +        }), +        subscriber.onNext("RxScala"), +        subscriber.onCompleted(), +    }, +    o.unsubscribeOn(NewThreadScheduler()).subscribe(println(_)), +  }, +, +  @Test def parallelMergeExample() {, +    val o: Observable[Observable[Int]] = (1 to 100).toObservable.map(_ => (1 to 10).toObservable), +    assertEquals(100, o.size.toBlockingObservable.single), +    assertEquals(1000, o.flatten.size.toBlockingObservable.single), +, +    val o2: Observable[Observable[Int]] = o.parallelMerge(10, ComputationScheduler()), +    assertEquals(10, o2.size.toBlockingObservable.single), +    assertEquals(1000, o2.flatten.size.toBlockingObservable.single), +  }, +, +  @Test def debounceExample() {]