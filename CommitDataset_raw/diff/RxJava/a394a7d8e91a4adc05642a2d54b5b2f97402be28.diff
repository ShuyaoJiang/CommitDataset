[+++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java, + * Subscribes and unsubscribes Observers on the specified Scheduler., + * Will occur asynchronously except when subscribing to `GroupedObservable`, `PublishSubject` and possibly other "hot" Observables, + * in which case it will subscribe synchronously and buffer/block onNext calls until the subscribe has occurred., + * <p>, + * See https://github.com/Netflix/RxJava/issues/844 for more information on the "time gap" issue that the synchronous, + * subscribe is solving., + * , +, +, +     * , +     * @param scheduler, +     *            the target scheduler, +     * @param dontLoseEvents, +     *            indicate that events should be buffered until the actual subscription happens, +     * @param bufferSize, +     *            if dontLoseEvents == true, this indicates the buffer size. Filling the buffer will, +, +                /*, +                 * Included are some Observable types known to be "hot" and thus needing, +                 * buffering when subscribing across thread boundaries otherwise, +                 * we can lose data., +                 * , +                 * See https://github.com/Netflix/RxJava/issues/844 for more information., +                 */, +                return dontLoseEvents, +                        || ((o instanceof GroupedObservable<?, ?>), +, +                    // use buffering (possibly blocking) for a possibly synchronous subscribe, +                    final BufferUntilSubscriber<T> bus = new BufferUntilSubscriber<T>(bufferSize, subscriber);, +                    subscriber.add(scheduler.schedule(new Action1<Inner>() {, +                    }));, +                } else {, +                    // no buffering (async subscribe), +                            o.subscribe(new Subscriber<T>(subscriber) {, +            }, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java, + * Subscribes and unsubscribes Observers on the specified Scheduler., + * Will occur asynchronously except when subscribing to `GroupedObservable`, `PublishSubject` and possibly other "hot" Observables, + * in which case it will subscribe synchronously and buffer/block onNext calls until the subscribe has occurred., + * <p>, + * See https://github.com/Netflix/RxJava/issues/844 for more information on the "time gap" issue that the synchronous, + * subscribe is solving., + * , +, +, +     * , +     * @param scheduler, +     *            the target scheduler, +     * @param dontLoseEvents, +     *            indicate that events should be buffered until the actual subscription happens, +     * @param bufferSize, +     *            if dontLoseEvents == true, this indicates the buffer size. Filling the buffer will, +, +                /*, +                 * Included are some Observable types known to be "hot" and thus needing, +                 * buffering when subscribing across thread boundaries otherwise, +                 * we can lose data., +                 * , +                 * See https://github.com/Netflix/RxJava/issues/844 for more information., +                 */, +                return dontLoseEvents, +                        || ((o instanceof GroupedObservable<?, ?>), +, +                    // use buffering (possibly blocking) for a possibly synchronous subscribe, +                    final BufferUntilSubscriber<T> bus = new BufferUntilSubscriber<T>(bufferSize, subscriber);, +                    subscriber.add(scheduler.schedule(new Action1<Inner>() {, +                    }));, +                } else {, +                    // no buffering (async subscribe), +                            o.subscribe(new Subscriber<T>(subscriber) {, +            }, +++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java, +                    return group.subscribeOn(Schedulers.newThread(), 1).delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {, +                return group.subscribeOn(Schedulers.newThread(), 0).map(new Func1<Integer, String>() {, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java, + * Subscribes and unsubscribes Observers on the specified Scheduler., + * Will occur asynchronously except when subscribing to `GroupedObservable`, `PublishSubject` and possibly other "hot" Observables, + * in which case it will subscribe synchronously and buffer/block onNext calls until the subscribe has occurred., + * <p>, + * See https://github.com/Netflix/RxJava/issues/844 for more information on the "time gap" issue that the synchronous, + * subscribe is solving., + * , +, +, +     * , +     * @param scheduler, +     *            the target scheduler, +     * @param dontLoseEvents, +     *            indicate that events should be buffered until the actual subscription happens, +     * @param bufferSize, +     *            if dontLoseEvents == true, this indicates the buffer size. Filling the buffer will, +, +                /*, +                 * Included are some Observable types known to be "hot" and thus needing, +                 * buffering when subscribing across thread boundaries otherwise, +                 * we can lose data., +                 * , +                 * See https://github.com/Netflix/RxJava/issues/844 for more information., +                 */]