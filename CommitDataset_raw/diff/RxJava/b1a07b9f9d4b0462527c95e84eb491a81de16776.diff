[+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, +                f = executor.submit(sr);, +                f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, +                f = executor.submit(sr);, +                f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +        Object o = state.get();, +        return state.subscribers() == State.TERMINATED && !NotificationLite.isError(o);, +            return NotificationLite.getError(o);, +        if (o != null && !NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {, +        } else {, +            if (array.length != 0) {, +                array[0] = null;, +            }, +                    if (value != null) {, +                    }, +                        if (v != null) {, +                        }, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, +                f = executor.submit(sr);, +                f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +        Object o = state.get();, +        return state.subscribers() == State.TERMINATED && !NotificationLite.isError(o);, +            return NotificationLite.getError(o);, +        if (o != null && !NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {, +        } else {, +            if (array.length != 0) {, +                array[0] = null;, +            }, +                    if (value != null) {, +                    }, +                        if (v != null) {, +                        }, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import java.lang.reflect.Array;, +    , +    /* test support*/ int subscriberCount() {, +        return state.subscribers.length;, +    }, +, +        if (NotificationLite.isError(o)) {, +    @SuppressWarnings("unchecked"), +        if (o == null || NotificationLite.isComplete(o) || NotificationLite.isError(o)) {, +        } else {, +            array = (T[])Array.newInstance(array.getClass().getComponentType(), 1);, +            array[0] = v;, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, +                f = executor.submit(sr);, +                f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +        Object o = state.get();, +        return state.subscribers() == State.TERMINATED && !NotificationLite.isError(o);, +            return NotificationLite.getError(o);, +        if (o != null && !NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {, +        } else {, +            if (array.length != 0) {, +                array[0] = null;, +            }, +                    if (value != null) {, +                    }, +                        if (v != null) {, +                        }, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import java.lang.reflect.Array;, +    , +    /* test support*/ int subscriberCount() {, +        return state.subscribers.length;, +    }, +, +        if (NotificationLite.isError(o)) {, +    @SuppressWarnings("unchecked"), +        if (o == null || NotificationLite.isComplete(o) || NotificationLite.isError(o)) {, +        } else {, +            array = (T[])Array.newInstance(array.getClass().getComponentType(), 1);, +            array[0] = v;, +++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +    /* test */ static <T> ReplaySubject<T> createUnbounded() {, +        SizeBoundReplayBuffer<T> buffer = new SizeBoundReplayBuffer<>(Integer.MAX_VALUE);, +        return createWithBuffer(buffer);, +    }, +, +    /* test */ int subscriberCount() {, +        return state.subscribers.length;, +    }, +, +    /* test*/ int size() {, +        return state.buffer.size();, +    }, +    , +                        return;, +                buffer.replay(rs);, +                size--;, +            /*, +             *  FIXME not sure why lazySet doesn't work here, +             *  (testReplaySubjectEmissionSubscriptionRace hangs) , +             *  must be the lack of StoreLoad barrier?, +             */, +            t.set(n); // releases both the tail and size]