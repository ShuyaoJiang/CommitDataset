[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def rangeAndBufferExample() {, +    o.buffer(5).subscribe((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  @Test def bufferExample() {, +    o.buffer(boundary).toBlocking.foreach((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  @Test def windowExample() {, +    (for ((o, i) <- Observable.from(1 to 18).window(5).zipWithIndex; n <- o), +  @Test def windowExample2() {, +    (for ((o, i) <- o.window(windowObservable).zipWithIndex; n <- o), +    val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x == 7)}), +    val grouped = numbers.groupByUntil[Long, Long](x => x % 2, x => x * 10, {case (key, obs) => Observable.interval(2 seconds)}), +    val combinedCounter = firstCounter.combineLatest(secondCounter,, +      (x: Long, y: Long) => List(x,y)) take 10, +    val combinedCounter = Observable.combineLatest(sources, (items: Seq[Long]) => items.toList).take(10), +    val shared = unshared.multicast(Subject()), +    val shared = unshared.multicast[Int, String](() => Subject(), o => o.map("No. " + _)), +    o.flatMap(, +      (n: Int) => Observable.interval(200 millis).take(5),, +      (n: Int, m: Long) => n * m, +    ).toBlocking.foreach(println), +    o.flatMapIterable(, +      (n: Int) => (1 to 5),, +      (n: Int, m: Int) => n * m, +    ).toBlocking.foreach(println), +    val o = o1.join(o2,, +      (_: String) => Observable.timer(300 millis),, +      (_: String) => Observable.timer(200 millis),, +      (t1: String, t2: String) => (t1, t2)), +    val o = o1.groupJoin(o2,, +      (_: String) => Observable.timer(300 millis),, +      (_: String) => Observable.timer(200 millis),, +      (t1: String, t2: Observable[String]) => (t1, t2.toSeq.toBlocking.single)), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def rangeAndBufferExample() {, +    o.buffer(5).subscribe((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  @Test def bufferExample() {, +    o.buffer(boundary).toBlocking.foreach((l: Seq[Int]) => println(l.mkString("[", ", ", "]"))), +  @Test def windowExample() {, +    (for ((o, i) <- Observable.from(1 to 18).window(5).zipWithIndex; n <- o), +  @Test def windowExample2() {, +    (for ((o, i) <- o.window(windowObservable).zipWithIndex; n <- o), +    val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x == 7)}), +    val grouped = numbers.groupByUntil[Long, Long](x => x % 2, x => x * 10, {case (key, obs) => Observable.interval(2 seconds)}), +    val combinedCounter = firstCounter.combineLatest(secondCounter,, +      (x: Long, y: Long) => List(x,y)) take 10, +    val combinedCounter = Observable.combineLatest(sources, (items: Seq[Long]) => items.toList).take(10), +    val shared = unshared.multicast(Subject()), +    val shared = unshared.multicast[Int, String](() => Subject(), o => o.map("No. " + _)), +    o.flatMap(, +      (n: Int) => Observable.interval(200 millis).take(5),, +      (n: Int, m: Long) => n * m, +    ).toBlocking.foreach(println), +    o.flatMapIterable(, +      (n: Int) => (1 to 5),, +      (n: Int, m: Int) => n * m, +    ).toBlocking.foreach(println), +    val o = o1.join(o2,, +      (_: String) => Observable.timer(300 millis),, +      (_: String) => Observable.timer(200 millis),, +      (t1: String, t2: String) => (t1, t2)), +    val o = o1.groupJoin(o2,, +      (_: String) => Observable.timer(300 millis),, +      (_: String) => Observable.timer(200 millis),, +      (t1: String, t2: Observable[String]) => (t1, t2.toSeq.toBlocking.single)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T, U](subjectFactory: () => rx.lang.scala.Subject[R], selector: Observable[R] => Observable[U]): Observable[U] = {, +    zipWith(that, (t: T, u: U) => (t, u)), +   * @param other the Iterable sequence, +  def zip[U](other: Iterable[U]): Observable[(T, U)] = {, +    zipWith(other, (t: T, u: U) => (t, u)), +   * @param other the Iterable sequence, +  def zipWith[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  def zipWith[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {, +  def buffer[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]): Observable[Seq[T]] = {, +  def buffer(count: Int): Observable[Seq[T]] = {, +  def buffer(count: Int, skip: Int): Observable[Seq[T]] = {, +  def buffer(timespan: Duration): Observable[Seq[T]] = {, +  def buffer(timespan: Duration, scheduler: Scheduler): Observable[Seq[T]] = {, +  def buffer(timespan: Duration, count: Int): Observable[Seq[T]] = {, +  def buffer(timespan: Duration, count: Int, scheduler: Scheduler): Observable[Seq[T]] = {, +  def buffer(timespan: Duration, timeshift: Duration): Observable[Seq[T]] = {, +  def buffer(timespan: Duration, timeshift: Duration, scheduler: Scheduler): Observable[Seq[T]] = {, +  def buffer(boundary: => Observable[Any]): Observable[Seq[T]] = {, +  def buffer(boundary: Observable[Any], initialCapacity: Int): Observable[Seq[T]] = {, +  def window(boundary: => Observable[Any]): Observable[Observable[T]] = {, +  def window[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]) = {, +  def window(count: Int): Observable[Observable[T]] = {, +  def window(count: Int, skip: Int): Observable[Observable[T]] = {, +  def window(timespan: Duration): Observable[Observable[T]] = {, +  def window(timespan: Duration, scheduler: Scheduler): Observable[Observable[T]] = {, +  def window(timespan: Duration, count: Int): Observable[Observable[T]] = {, +  def window(timespan: Duration, count: Int, scheduler: Scheduler): Observable[Observable[T]] = {, +  def window(timespan: Duration, timeshift: Duration): Observable[Observable[T]] = {, +  def window(timespan: Duration, timeshift: Duration, scheduler: Scheduler): Observable[Observable[T]] = {, +  def flatMap[U, R](collectionSelector: T => Observable[U], resultSelector: (T, U) => R): Observable[R] = {, +  def flatMapIterable[U, R](collectionSelector: T => Iterable[U], resultSelector: (T, U) => R): Observable[R] = {, +  def groupByUntil[K](f: T => K, closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = {, +  def groupByUntil[K, V](keySelector: T => K, valueSelector: T => V, closings: (K, Observable[V]) => Observable[Any]): Observable[(K, Observable[V])] = {, +  def join[S, R] (]