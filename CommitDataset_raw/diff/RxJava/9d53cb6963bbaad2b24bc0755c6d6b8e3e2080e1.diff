[+++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7, t8));, +    @SuppressWarnings("unchecked"), +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7));, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7, t8));, +    @SuppressWarnings("unchecked"), +        return create(OperationMerge.merge(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java, +import java.util.Arrays;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicBoolean;, +        // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe., +                return new MergeObservable<T>(o).onSubscribe(observer);, +    public static <T> OnSubscribeFunc<T> merge(final Observable<? extends T>... sequences) {, +        return merge(Arrays.asList(sequences));, +    }, +, +    public static <T> OnSubscribeFunc<T> merge(final Iterable<? extends Observable<? extends T>> sequences) {, +        return merge(Observable.create(new OnSubscribeFunc<Observable<? extends T>>() {, +, +            private volatile boolean unsubscribed = false;, +, +            @Override, +            public Subscription onSubscribe(Observer<? super Observable<? extends T>> observer) {, +                for (Observable<? extends T> o : sequences) {, +                    if (!unsubscribed) {, +                        observer.onNext(o);, +                    } else {, +                        // break out of the loop if we are unsubscribed, +                        break;, +                    }, +                }, +                if (!unsubscribed) {, +                    observer.onCompleted();, +                }, +, +                return new Subscription() {, +, +                    @Override, +                    public void unsubscribe() {, +                        unsubscribed = true;, +                    }, +, +                };, +            }, +        }));, +    }, +, +        private final MergeSubscription ourSubscription = new MergeSubscription();, +        private AtomicBoolean stopped = new AtomicBoolean(false);, +        private final ConcurrentHashMap<ChildObserver, ChildObserver> childObservers = new ConcurrentHashMap<ChildObserver, ChildObserver>();, +        private final ConcurrentHashMap<ChildObserver, Subscription> childSubscriptions = new ConcurrentHashMap<ChildObserver, Subscription>();, +        private MergeObservable(Observable<? extends Observable<? extends T>> sequences) {]