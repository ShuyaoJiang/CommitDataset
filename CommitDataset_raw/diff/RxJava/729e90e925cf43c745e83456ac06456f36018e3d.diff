[+++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +import java.util.*;, +import rx.Observable;, +import rx.exceptions.*;, +import rx.internal.util.RxRingBuffer;, +public class OperatorPublish<T> extends ConnectableObservable<T> {, +    private final RequestHandler<T> requestHandler;, +        return new OperatorPublish<T>(source);, +    public static <T, R> Observable<R> create(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector) {, +        return Observable.create(new OnSubscribe<R>() {, +                OperatorPublish<T> op = new OperatorPublish<T>(source);, +, +                    public void call(Subscription sub) {, +                        child.add(sub);, +, +        });, +    }, +, +    private OperatorPublish(Observable<? extends T> source) {, +        this(source, new Object(), new RequestHandler<T>());, +    }, +, +    private OperatorPublish(Observable<? extends T> source, final Object guard, final RequestHandler<T> requestHandler) {, +        super(new OnSubscribe<T>() {, +            @Override, +            public void call(final Subscriber<? super T> subscriber) {, +                subscriber.setProducer(new Producer() {, +, +                    @Override, +                    public void request(long n) {, +                        requestHandler.requestFromChildSubscriber(subscriber, n);, +                    }, +, +                });, +                subscriber.add(Subscriptions.create(new Action0() {, +, +                    @Override, +                    public void call() {, +                        requestHandler.state.removeSubscriber(subscriber);, +                    }, +, +                }));, +            }, +        });, +        this.requestHandler = requestHandler;, +        // each time we connect we create a new Subscription, +        boolean shouldSubscribe = false;, +        , +        // subscription is the state of whether we are connected or not, +        OriginSubscriber<T> origin = requestHandler.state.getOrigin();, +        if (origin == null) {, +            shouldSubscribe = true;, +            requestHandler.state.setOrigin(new OriginSubscriber<T>(requestHandler));, +        // in the lock above we determined we should subscribe, do it now outside the lock, +        if (shouldSubscribe) {, +            // register a subscription that will shut this down, +            connection.call(Subscriptions.create(new Action0() {, +                    OriginSubscriber<T> s = requestHandler.state.getOrigin();, +                    requestHandler.state.setOrigin(null);, +                    if (s != null) {, +                        s.unsubscribe();, +                    }, +, +            // now that everything is hooked up let's subscribe, +            // as long as the subscription is not null (which can happen if already unsubscribed), +            OriginSubscriber<T> os = requestHandler.state.getOrigin();, +            if (os != null) {, +                source.unsafeSubscribe(os);, +            }, +        }, +    }, +, +    private static class OriginSubscriber<T> extends Subscriber<T> {, +, +        private final RequestHandler<T> requestHandler;, +        private final AtomicLong originOutstanding = new AtomicLong();, +        private final long THRESHOLD = RxRingBuffer.SIZE / 4;, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +, +        OriginSubscriber(RequestHandler<T> requestHandler) {, +            this.requestHandler = requestHandler;, +            add(buffer);, +            requestMore(RxRingBuffer.SIZE);, +, +        private void requestMore(long r) {, +            originOutstanding.addAndGet(r);, +            request(r);, +, +                requestHandler.emit(requestHandler.notifier.completed());, +            } catch (MissingBackpressureException e) {, +                onError(e);, +        public void onError(Throwable e) {, +            List<Throwable> errors = null;, +            for (Subscriber<? super T> subscriber : requestHandler.state.getSubscribers()) {, +                try {, +                    subscriber.onError(e);, +                } catch (Throwable e2) {, +                    if (errors == null) {, +                        errors = new ArrayList<Throwable>();, +                    errors.add(e2);]