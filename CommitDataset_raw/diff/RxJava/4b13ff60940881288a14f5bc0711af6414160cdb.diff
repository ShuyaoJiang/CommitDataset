[+++ b/rxjava-core/src/main/java/rx/operators/OperatorRetry.java, +import java.util.concurrent.atomic.AtomicReference;, +import rx.Scheduler;, +import rx.Subscription;, +, +                final AtomicReference<Subscription> retrySub=new AtomicReference<Subscription>();, +, +                        retrySub.set(o.unsafeSubscribe(new Subscriber<T>(s) {, +                                    inner.schedule(new Action1<Inner>() {, +                                        @Override, +                                        public void call(Inner inner), +                                        {, +                                            // Remove the failed subscription first, +                                            retrySub.get().unsubscribe();, +                                            _self.call(inner);, +                                        }, +                                    });, +                        }));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorRetry.java, +import java.util.concurrent.atomic.AtomicReference;, +import rx.Scheduler;, +import rx.Subscription;, +, +                final AtomicReference<Subscription> retrySub=new AtomicReference<Subscription>();, +, +                        retrySub.set(o.unsafeSubscribe(new Subscriber<T>(s) {, +                                    inner.schedule(new Action1<Inner>() {, +                                        @Override, +                                        public void call(Inner inner), +                                        {, +                                            // Remove the failed subscription first, +                                            retrySub.get().unsubscribe();, +                                            _self.call(inner);, +                                        }, +                                    });, +                        }));, +++ b/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import rx.Subscriber;, +    public static class SlowFuncAlwaysFails implements Observable.OnSubscribe<String> {, +, +        final AtomicInteger nextSeq=new AtomicInteger();, +        final AtomicInteger activeSubs=new AtomicInteger();, +        final AtomicInteger concurrentSubs=new AtomicInteger();, +, +        public void call(final Subscriber<? super String> s), +        {, +            final int seq=nextSeq.incrementAndGet();, +, +            int cur=activeSubs.incrementAndGet();, +            // Track concurrent subscriptions, +            concurrentSubs.set(Math.max(cur,concurrentSubs.get()));, +, +            // Use async error, +            new Thread(new Runnable() {, +                @Override, +                public void run() {, +                    try {, +                        Thread.sleep(100);, +                    } catch (InterruptedException e) {, +                        // ignore, +                    }, +                    s.onError(new RuntimeException("Subscriber #"+seq+" fails"));, +                }, +            }).start();, +, +            // Track unsubscribes, +            s.add(new Subscription(), +            {, +                private boolean active=true;, +, +                public void unsubscribe(), +                {, +                    if (active) {, +                        activeSubs.decrementAndGet();, +                        active=false;, +                    }, +                }, +, +                public boolean isUnsubscribed(), +                {, +                    return !active;, +                }, +            });, +        }, +    }, +, +    @Test, +    public void testUnsubscribeAfterError() {, +, +        final CountDownLatch check=new CountDownLatch(1);, +        final SlowFuncAlwaysFails sf=new SlowFuncAlwaysFails();, +, +        Observable, +            .create(sf), +            .retry(4), +            .subscribe(, +                new Action1<String>(), +                {]