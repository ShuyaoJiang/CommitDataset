[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +        Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> a.received(result)});, +            Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> throw new RuntimeException('err')});, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +        Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> a.received(result)});, +            Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> throw new RuntimeException('err')});, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +        Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> a.received(result)});, +            Observable.create(new AsyncObservable()).toBlockingObservable().forEach({ result -> throw new RuntimeException('err')});, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.operators.AtomicObservableSubscription;, +import rx.operators.AtomicObserver;, +import rx.subscriptions.BooleanSubscription;, +import rx.util.functions.Action1;, +     * Used for protecting against errors being thrown from Observer implementations and ensuring onNext/onError/onCompleted contract compliance., +     * <p>, +     * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +     */, +    private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {, +        AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +        return subscription.wrap(subscribe(new AtomicObserver<T>(subscription, o)));, +    }, +    , +    /**, +     * Invokes an action for each element in the observable sequence, and blocks until the sequence is terminated., +     * <p>, +     * NOTE: This will block even if the Observable is asynchronous., +     * <p>, +     * This is similar to {@link #subscribe(Observer)} but blocks. Because it blocks it does not need the {@link Observer#onCompleted()} or {@link Observer#onError(Exception)} methods., +     * , +     * @param onNext, +     *            {@link Action1}, +     * @throws RuntimeException, +     *             if error occurs, +     */, +    public void forEach(final Action1<T> onNext) {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Exception> exceptionFromOnError = new AtomicReference<Exception>();, +, +        /**, +         * Wrapping since raw functions provided by the user are being invoked., +         * , +         * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +         */, +        protectivelyWrapAndSubscribe(new Observer<T>() {, +            @Override, +            public void onCompleted() {, +                latch.countDown();, +            }, +, +            @Override, +            public void onError(Exception e) {, +                /*, +                 * If we receive an onError event we set the reference on the outer thread, +                 * so we can git it and throw after the latch.await()., +                 * , +                 * We do this instead of throwing directly since this may be on a different thread and the latch is still waiting., +                 */, +                exceptionFromOnError.set(e);, +                latch.countDown();, +            }, +, +            @Override, +            public void onNext(T args) {, +                onNext.call(args);, +            }, +        });, +        // block until the subscription completes and then return, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            // set the interrupted flag again so callers can still get it, +            // for more information see https://github.com/Netflix/RxJava/pull/147#issuecomment-13624780, +            Thread.currentThread().interrupt();, +            // using Runtime so it is not checked, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +, +        if (exceptionFromOnError.get() != null) {, +            if (exceptionFromOnError.get() instanceof RuntimeException) {, +                throw (RuntimeException) exceptionFromOnError.get();, +            } else {, +                throw new RuntimeException(exceptionFromOnError.get());, +            }, +        }, +    }, +, +    /**, +     * Invokes an action for each element in the observable sequence, and blocks until the sequence is terminated., +     * <p>, +     * NOTE: This will block even if the Observable is asynchronous., +     * <p>, +     * This is similar to {@link #subscribe(Observer)} but blocks. Because it blocks it does not need the {@link Observer#onCompleted()} or {@link Observer#onError(Exception)} methods., +     * , +     * @param o, +     *            onNext {@link Action1 action}]