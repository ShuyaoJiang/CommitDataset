[+++ b/README.md, +#### Version 1.x, +, +Looking for version 1.x? Jump [to the 1.x branch](https://github.com/ReactiveX/RxJava/tree/1.x)., +, +Timeline plans for the 1.x line:, +, +  - **June 1, 2017** - feature freeze (no new operators), only bugfixes, +  - **March 31, 2018** - end of life, no further development, +, +## Getting started, +, +The first step is to include RxJava 2 into your project, for example, as a Gradle compile dependency:, +, +```groovy, +compile "io.reactivex.rxjava2:rxjava:2.x.y", +```, +, +The second is to write the **Hello World** program:, +, +```java, +package rxjava.examples;, +, +import io.reactivex.*;, +, +public class HelloWorld {, +    public static void main(String[] args) {, +        Flowable.just("Hello world").subscribe(System.out::println);, +    }, +}, +```, +, +If your platform doesn't support Java 8 lambdas (yet), you have to create an inner class of `Consumer` manually:, +, +```java, +        Flowable.just("Hello world"), +        .subscribe(new Consumer<String>() {, +            @Override public void accept(String s) {, +                System.out.println(s);, +            }, +        );, +```, +, +RxJava 2 features several base classes you can discover operators on:, +, +  - `io.reactivex.Flowable` : 0..N flows, supporting Reactive-Streams and backpressure, +  - `io.reactivex.Observable`: 0..N flows, no backpressure, +  - `io.reactivex.Single`: a flow of exactly 1 item or an error, +  - `io.reactivex.Completable`: a flow without items but only a completion or error signal, +  - `io.reactivex.Maybe`: a flow with no items, exactly one item or an error, +, +One of the common use cases for RxJava is to run some computation, network request on a background thread and show the results (or error) on the UI thread:, +, +```java, +Flowable.fromCallable(() -> {, +    Thread.sleep(1000); //  imitate expensive computation, +    return "Done";, +}), +.subscribeOn(Schedulers.io()), +.observeOn(Schedulers.single()), +.subscribe(System.out::println, Throwable::printStackTrace);, +, +Thread.sleep(2000); // <--- wait for the flow to finish, +```, +, +This style of chaining methods is called a **fluent API** which resembles the **builder pattern**. However, RxJava's reactive types are immutable; each of the method calls returns a new `Flowable` with added behavior. To illustrate, the example can be rewritten as follows:, +, +```java, +Flowable<String> source = Flowable.fromCallable(() -> {, +    Thread.sleep(1000); //  imitate expensive computation, +    return "Done";, +});, +, +Flowabe<String> runBackground = source.subscribeOn(Schedulers.io());, +, +Flowable<String> showForeground = runBackground.observeOn(Schedulers.single());, +, +showForeground.subscribe(System.out::println, Throwable::printStackTrace);, +, +Thread.sleep(2000);, +```, +, +Typically, you can move computations or blocking IO to some other thread via `subscribeOn`. Once the data is ready, you can make sure they get processed on the foreground or GUI thread via `observeOn`. , +, +RxJava operators don't work `Thread`s or `ExecutorService`s directly but with so called `Scheduler`s that abstract away sources of concurrency behind an uniform API. RxJava 2 features several standard schedulers accessible via `Schedulers` utility class. These are available on all JVM platforms but some specific platforms, such as Android, have their own typical `Scheduler`s defined: `AndroidSchedulers.mainThread()`, `SwingScheduler.instance()` or `JavaFXSchedulers.gui()`., +, +The `Thread.sleep(2000);` at the end is no accident. In RxJava the default `Scheduler`s run on daemon threads, which means once the Java main thread exits, they all get stopped and background computations may never happen. Sleeping for some time in this example situations let's you see the output of the flow on the console with time to spare., +, +Flows in RxJava are sequential in nature split into processing stages that may run **concurrently** with each other:, +, +```java, +Flowable.range(1, 10), +.observeOn(Schedulers.computation()), +.map(v -> v * v), +.blockingSubscribe(System.out::println);, +```, +, +This example flow squares the numbers from 1 to 10 on the **computation** `Scheduler` and consumes the results on the "main" thread (more precisely, the caller thread of `blockingSubscribe`). However, the lambda `v -> v * v` doesn't run in parallel for this flow; it receives the values 1 to 10 on the same computation thread one after the other., +, +Processing the numbers 1 to 10 in parallel is a bit more involved:]