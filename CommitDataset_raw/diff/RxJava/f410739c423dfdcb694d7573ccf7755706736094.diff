[+++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/test/java/rx/BackpressureTests.java, +import java.util.List;, +        // akarnokd => run this in a loop over 10k times and never saw values get as high as 7*SIZE, but since observeOn delays the unsubscription non-deterministically, the test will remain unreliable, +        assertTrue(c1.get() < RxRingBuffer.SIZE * 7);, +        assertTrue(c2.get() < RxRingBuffer.SIZE * 7);, +    @Test(timeout = 10000), +        for (int i = 0; i < 100; i++) {, +            firehose(c).onBackpressureDrop(), +            .observeOn(Schedulers.computation()), +            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +            , +            , +            List<Integer> onNextEvents = ts.getOnNextEvents();, +            assertEquals(NUM, onNextEvents.size());, +, +            Integer lastEvent = onNextEvents.get(NUM - 1);, +            , +            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + "  Emitted: " + c.get() + " Last value: " + lastEvent);, +            assertTrue(NUM - 1 <= lastEvent.intValue());, +        }, +    }, +    @Test(timeout = 10000), +    public void testOnBackpressureDropSynchronous() {, +        for (int i = 0; i < 100; i++) {, +            int NUM = (int) (RxRingBuffer.SIZE * 1.1); // > 1 so that take doesn't prevent buffer overflow, +            AtomicInteger c = new AtomicInteger();, +            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +            firehose(c).onBackpressureDrop(), +            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +            ts.awaitTerminalEvent();, +            ts.assertNoErrors();, +            , +            List<Integer> onNextEvents = ts.getOnNextEvents();, +            assertEquals(NUM, onNextEvents.size());, +, +            Integer lastEvent = onNextEvents.get(NUM - 1);, +            , +            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + "  Emitted: " + c.get() + " Last value: " + lastEvent);, +            // it drop, so we should get some number far higher than what would have sequentially incremented, +            assertTrue(NUM - 1 <= lastEvent.intValue());, +        }, +            for (int i = 1000; i >= 0; i--) {, +                t = String.valueOf(i + t.hashCode());, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java, + * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already, + * emitted. If more items arrive after the window has reached its size bound, those items are dropped., +            , +            if (s.consumer != null) {, +                if (s.count == size) {, +            }, +            , +++ b/src/test/java/rx/BackpressureTests.java, +import java.util.List;, +        // akarnokd => run this in a loop over 10k times and never saw values get as high as 7*SIZE, but since observeOn delays the unsubscription non-deterministically, the test will remain unreliable, +        assertTrue(c1.get() < RxRingBuffer.SIZE * 7);, +        assertTrue(c2.get() < RxRingBuffer.SIZE * 7);, +    @Test(timeout = 10000), +        for (int i = 0; i < 100; i++) {, +            firehose(c).onBackpressureDrop(), +            .observeOn(Schedulers.computation()), +            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +            , +            , +            List<Integer> onNextEvents = ts.getOnNextEvents();, +            assertEquals(NUM, onNextEvents.size());, +, +            Integer lastEvent = onNextEvents.get(NUM - 1);, +            , +            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + "  Emitted: " + c.get() + " Last value: " + lastEvent);, +            assertTrue(NUM - 1 <= lastEvent.intValue());, +        }, +    }, +    @Test(timeout = 10000), +    public void testOnBackpressureDropSynchronous() {, +        for (int i = 0; i < 100; i++) {, +            int NUM = (int) (RxRingBuffer.SIZE * 1.1); // > 1 so that take doesn't prevent buffer overflow, +            AtomicInteger c = new AtomicInteger();, +            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +            firehose(c).onBackpressureDrop(), +            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);, +            ts.awaitTerminalEvent();, +            ts.assertNoErrors();, +            , +            List<Integer> onNextEvents = ts.getOnNextEvents();]