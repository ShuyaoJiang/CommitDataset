[+++ b/src/main/java/io/reactivex/NbpObservable.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.stream.Stream;, +import io.reactivex.annotations.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.subscribers.nbp.*;, +import io.reactivex.observables.nbp.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.*;, +import io.reactivex.subscribers.nbp.*;, +    public interface NbpOperator<Downstream, Upstream> extends Function<NbpSubscriber<? super Downstream>, NbpSubscriber<? super Upstream>> {, +        , +    }, +    , +    /** An empty observable instance as there is no need to instantiate this more than once. */, +    static final NbpObservable<Object> EMPTY = create(s -> {, +        s.onSubscribe(EmptyDisposable.INSTANCE);, +        s.onComplete();, +    });, +    /** A never NbpObservable instance as there is no need to instantiate this more than once. */, +    static final NbpObservable<Object> NEVER = create(s -> s.onSubscribe(EmptyDisposable.INSTANCE));, +    , +    static final Object OBJECT = new Object();, +    , +    public static <T> NbpObservable<T> amb(Iterable<? extends NbpObservable<? extends T>> sources) {, +        Objects.requireNonNull(sources);, +        return create(new NbpOnSubscribeAmb<>(null, sources));, +    }, +    , +    @SuppressWarnings("unchecked"), +    @SchedulerSupport(SchedulerKind.NONE), +    @SafeVarargs, +    public static <T> NbpObservable<T> amb(NbpObservable<? extends T>... sources) {, +        Objects.requireNonNull(sources);, +        int len = sources.length;, +        if (len == 0) {, +            return empty();, +        } else, +        if (len == 1) {, +            return (NbpObservable<T>)sources[0];, +        }, +        return create(new NbpOnSubscribeAmb<>(sources, null));, +    }, +    , +    /**, +     * Returns the default 'island' size or capacity-increment hint for unbounded buffers., +     * @return, +     */, +    static int bufferSize() {, +        return Observable.bufferSize();, +    }, +    , +    @SchedulerSupport(SchedulerKind.NONE), +    @SafeVarargs, +    public static <T, R> NbpObservable<R> combineLatest(Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize, NbpObservable<? extends T>... sources) {, +        return combineLatest(sources, combiner, delayError, bufferSize);, +    }, +, +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(Iterable<? extends NbpObservable<? extends T>> sources, Function<? super Object[], ? extends R> combiner) {, +        return combineLatest(sources, combiner, false, bufferSize());, +    }, +    , +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(Iterable<? extends NbpObservable<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, +        return combineLatest(sources, combiner, delayError, bufferSize());, +    }, +    , +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(Iterable<? extends NbpObservable<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {, +        Objects.requireNonNull(sources);, +        Objects.requireNonNull(combiner);, +        validateBufferSize(bufferSize);, +        , +        // the queue holds a pair of values so we need to double the capacity, +        int s = bufferSize << 1;, +        return create(new NbpOnSubscribeCombineLatest<>(null, sources, combiner, s, delayError));, +    }, +, +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(NbpObservable<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, +        return combineLatest(sources, combiner, false, bufferSize());, +    }, +    , +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(NbpObservable<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, +        return combineLatest(sources, combiner, delayError, bufferSize());, +    }, +    , +    @SchedulerSupport(SchedulerKind.NONE), +    public static <T, R> NbpObservable<R> combineLatest(NbpObservable<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {, +        validateBufferSize(bufferSize);, +        Objects.requireNonNull(combiner);, +        if (sources.length == 0) {, +            return empty();, +        }, +        // the queue holds a pair of values so we need to double the capacity, +        int s = bufferSize << 1;, +        return create(new NbpOnSubscribeCombineLatest<>(sources, null, combiner, s, delayError));]