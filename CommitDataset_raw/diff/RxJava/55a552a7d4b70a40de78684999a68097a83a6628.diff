[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Schedulers#threadPoolForComputation()} {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f, +   *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +   * @return an Observable with the output of the function executed on a {@link Scheduler}, +   */, +  def parallel[R](f: Observable[T] => Observable[R]): Observable[R] = {, +    val fJava: Func1[rx.Observable[T], rx.Observable[R]] =, +      (jo: rx.Observable[T]) => f(Observable[T](jo)).asJava.asInstanceOf[rx.Observable[R]], +    Observable[R](asJava.asInstanceOf[rx.Observable[T]].parallel[R](fJava)), +  }, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f, +   *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +   * @param s, +   *            a {@link Scheduler} to perform the work on., +   * @return an Observable with the output of the {@link Func1} executed on a {@link Scheduler}, +   */, +  def parallel[R](f: Observable[T] => Observable[R], scheduler: Scheduler): Observable[R] = {, +    val fJava: Func1[rx.Observable[T], rx.Observable[R]] =, +      (jo: rx.Observable[T]) => f(Observable[T](jo)).asJava.asInstanceOf[rx.Observable[R]], +    Observable[R](asJava.asInstanceOf[rx.Observable[T]].parallel[R](fJava, scheduler)), +  }  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Schedulers#threadPoolForComputation()} {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f, +   *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +   * @return an Observable with the output of the function executed on a {@link Scheduler}, +   */, +  def parallel[R](f: Observable[T] => Observable[R]): Observable[R] = {, +    val fJava: Func1[rx.Observable[T], rx.Observable[R]] =, +      (jo: rx.Observable[T]) => f(Observable[T](jo)).asJava.asInstanceOf[rx.Observable[R]], +    Observable[R](asJava.asInstanceOf[rx.Observable[T]].parallel[R](fJava)), +  }, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f, +   *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +   * @param s, +   *            a {@link Scheduler} to perform the work on., +   * @return an Observable with the output of the {@link Func1} executed on a {@link Scheduler}, +   */, +  def parallel[R](f: Observable[T] => Observable[R], scheduler: Scheduler): Observable[R] = {, +    val fJava: Func1[rx.Observable[T], rx.Observable[R]] =, +      (jo: rx.Observable[T]) => f(Observable[T](jo)).asJava.asInstanceOf[rx.Observable[R]], +    Observable[R](asJava.asInstanceOf[rx.Observable[T]].parallel[R](fJava, scheduler)), +  }  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  def square(x: Int): Int = {, +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId()}"), +    Thread.sleep(100) // calculating a square is heavy work :), +    x*x, +  }, +  , +  def work(o1: Observable[Int]): Observable[String] = {, +    println(s"map() is being called on thread ${Thread.currentThread().getId()}"), +    o1.map(i => s"The square of $i is ${square(i)}"), +  }, +  , +  @Test def parallelExample() {  , +    val t0 = System.currentTimeMillis(), +    Observable(1 to 10).parallel(work(_)).toBlockingObservable.foreach(println(_)), +    println(s"Work took ${System.currentTimeMillis()-t0} ms"), +  }, +  , +  @Test def exampleWithoutParallel() {, +    val t0 = System.currentTimeMillis(), +    work(Observable(1 to 10)).toBlockingObservable.foreach(println(_)), +    println(s"Work took ${System.currentTimeMillis()-t0} ms"), +  }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Schedulers#threadPoolForComputation()} {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f, +   *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +   * @return an Observable with the output of the function executed on a {@link Scheduler}, +   */, +  def parallel[R](f: Observable[T] => Observable[R]): Observable[R] = {, +    val fJava: Func1[rx.Observable[T], rx.Observable[R]] =, +      (jo: rx.Observable[T]) => f(Observable[T](jo)).asJava.asInstanceOf[rx.Observable[R]], +    Observable[R](asJava.asInstanceOf[rx.Observable[T]].parallel[R](fJava)), +  }, +, +  /**, +   * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Scheduler} and return an {@code Observable<R>} with the output., +   *, +   * @param f]