[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java, +import io.reactivex.internal.util.AtomicThrowable;, +import io.reactivex.observers.DisposableObserver;, +    final int capacityHint;, +    public ObservableWindowBoundary(ObservableSource<T> source, ObservableSource<B> other, int capacityHint) {, +        this.capacityHint = capacityHint;, +    public void subscribeActual(Observer<? super Observable<T>> observer) {, +        WindowBoundaryMainObserver<T, B> parent = new WindowBoundaryMainObserver<T, B>(observer, capacityHint);, +, +        observer.onSubscribe(parent);, +        other.subscribe(parent.boundaryObserver);, +, +        source.subscribe(parent);, +    extends AtomicInteger, +    implements Observer<T>, Disposable, Runnable {, +        private static final long serialVersionUID = 2233020065421370272L;, +        final Observer<? super Observable<T>> downstream;, +        final int capacityHint;, +, +        final WindowBoundaryInnerObserver<T, B> boundaryObserver;, +, +        final AtomicReference<Disposable> upstream;, +, +        final AtomicInteger windows;, +, +        final MpscLinkedQueue<Object> queue;, +, +        final AtomicThrowable errors;, +, +        final AtomicBoolean stopWindows;, +, +        static final Object NEXT_WINDOW = new Object();, +, +        volatile boolean done;, +        WindowBoundaryMainObserver(Observer<? super Observable<T>> downstream, int capacityHint) {, +            this.downstream = downstream;, +            this.capacityHint = capacityHint;, +            this.boundaryObserver = new WindowBoundaryInnerObserver<T, B>(this);, +            this.upstream = new AtomicReference<Disposable>();, +            this.windows = new AtomicInteger(1);, +            this.queue = new MpscLinkedQueue<Object>();, +            this.errors = new AtomicThrowable();, +            this.stopWindows = new AtomicBoolean();, +        public void onSubscribe(Disposable d) {, +            if (DisposableHelper.setOnce(upstream, d)) {, +                innerNext();, +            queue.offer(t);, +            drain();, +        public void onError(Throwable e) {, +            boundaryObserver.dispose();, +            if (errors.addThrowable(e)) {, +                drain();, +            } else {, +                RxJavaPlugins.onError(e);, +            boundaryObserver.dispose();, +            drain();, +            if (stopWindows.compareAndSet(false, true)) {, +                boundaryObserver.dispose();, +                if (windows.decrementAndGet() == 0) {, +                    DisposableHelper.dispose(upstream);, +                }, +            }, +            return stopWindows.get();, +        @Override, +        public void run() {, +            if (windows.decrementAndGet() == 0) {, +                DisposableHelper.dispose(upstream);, +            }, +        }, +, +        void innerNext() {, +            queue.offer(NEXT_WINDOW);, +            drain();, +        }, +, +        void innerError(Throwable e) {, +            DisposableHelper.dispose(upstream);, +            if (errors.addThrowable(e)) {, +                done = true;, +                drain();, +            } else {, +                RxJavaPlugins.onError(e);, +            }, +        }, +, +        void innerComplete() {, +            DisposableHelper.dispose(upstream);, +            done = true;, +            drain();, +        }, +, +        @SuppressWarnings("unchecked"), +        void drain() {, +            if (getAndIncrement() != 0) {, +                return;, +            }, +, +            Observer<? super Observable<T>> downstream = this.downstream;, +            MpscLinkedQueue<Object> queue = this.queue;, +            AtomicThrowable errors = this.errors;]