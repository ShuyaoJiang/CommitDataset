[+++ b/src/main/java/rx/internal/operators/OperatorZip.java, +            final Object[] observers = this.observers;, +                final int length = observers.length;, +                final Observer<? super R> child = this.child;, +                final AtomicLong requested = this.requested;, +                    while (true) {, +                        // peek for a potential onCompleted event, +                        final Object[] vs = new Object[length];, +                        for (int i = 0; i < length; i++) {, +                        // we only emit if requested > 0 and have all values available, +                        if (requested.get() > 0 && allHaveValues) {, +++ b/src/main/java/rx/internal/operators/OperatorZip.java, +            final Object[] observers = this.observers;, +                final int length = observers.length;, +                final Observer<? super R> child = this.child;, +                final AtomicLong requested = this.requested;, +                    while (true) {, +                        // peek for a potential onCompleted event, +                        final Object[] vs = new Object[length];, +                        for (int i = 0; i < length; i++) {, +                        // we only emit if requested > 0 and have all values available, +                        if (requested.get() > 0 && allHaveValues) {, +++ b/src/test/java/rx/internal/operators/OperatorZipTest.java, +import junit.framework.Assert;, +, +    @Test(timeout = 10000), +    public void testZipRace() {, +        Observable<Integer> src = Observable.just(1).subscribeOn(Schedulers.computation());, +        for (int i = 0; i < 100000; i++) {, +            int value = Observable.zip(src, src, new Func2<Integer, Integer, Integer>() {, +                @Override, +                public Integer call(Integer t1, Integer t2) {, +                    return t1 + t2 * 10;, +                }, +            }).toBlocking().singleOrDefault(0);, +            , +            Assert.assertEquals(11, value);, +        }, +    }, +    /** , +     * Request only a single value and don't wait for another request just, +     * to emit an onCompleted., +     */, +    @Test, +    public void testZipRequest1() {, +        Observable<Integer> src = Observable.just(1).subscribeOn(Schedulers.computation());, +        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {, +            @Override, +            public void onStart() {, +                requestMore(1);, +            }, +        };, +        , +        Observable.zip(src, src, new Func2<Integer, Integer, Integer>() {, +            @Override, +            public Integer call(Integer t1, Integer t2) {, +                return t1 + t2 * 10;, +            }, +        }).subscribe(ts);, +        , +        ts.awaitTerminalEvent(1, TimeUnit.SECONDS);, +        ts.assertNoErrors();, +        ts.assertReceivedOnNext(Arrays.asList(11));, +    }]