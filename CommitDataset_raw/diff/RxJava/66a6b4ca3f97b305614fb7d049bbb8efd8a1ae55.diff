[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), +    o.observeOn(Schedulers.newThread).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), +    o.observeOn(Schedulers.newThread).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId()}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId()}"), +  @Test def observableLikeFuture1() {, +    implicit val scheduler = Schedulers.threadPoolForIO, +    val o1 = observable {, +      Thread.sleep(1000), +      5, +    }, +    val o2 = observable {, +      Thread.sleep(500), +      4, +    }, +    Thread.sleep(500), +    val t1 = System.currentTimeMillis, +    println((o1 merge o2).first.toBlockingObservable.single), +    println(System.currentTimeMillis - t1), +  }, +, +  @Test def observableLikeFuture2() {, +    class Friend {}, +    val session = new Object {, +      def getFriends: List[Friend] = List(new Friend, new Friend), +    }, +, +    implicit val scheduler = Schedulers.threadPoolForIO, +    val o: Observable[List[Friend]] = observable {, +      session.getFriends, +    }, +    o.subscribe(, +      friendList => println(friendList),, +      err => println(err.getMessage), +    ), +, +    Thread.sleep(1500) // or convert to BlockingObservable, +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), +    o.observeOn(Schedulers.newThread).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), +    o.observeOn(Schedulers.newThread).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId()}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId()}"), +  @Test def observableLikeFuture1() {, +    implicit val scheduler = Schedulers.threadPoolForIO, +    val o1 = observable {, +      Thread.sleep(1000), +      5, +    }, +    val o2 = observable {, +      Thread.sleep(500), +      4, +    }, +    Thread.sleep(500), +    val t1 = System.currentTimeMillis, +    println((o1 merge o2).first.toBlockingObservable.single), +    println(System.currentTimeMillis - t1), +  }, +, +  @Test def observableLikeFuture2() {, +    class Friend {}, +    val session = new Object {, +      def getFriends: List[Friend] = List(new Friend, new Friend), +    }, +, +    implicit val scheduler = Schedulers.threadPoolForIO, +    val o: Observable[List[Friend]] = observable {, +      session.getFriends, +    }, +    o.subscribe(, +      friendList => println(friendList),, +      err => println(err.getMessage), +    ), +, +    Thread.sleep(1500) // or convert to BlockingObservable, +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +    val inOrdr = inOrder(observer);, +    sub.unsubscribe();, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), +    o.observeOn(Schedulers.newThread).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId()})")]