[+++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatchableSubscription.java, +import org.rx.reactive.Subscription;, + * Thread-safe wrapper around ObservableSubscription that ensures unsubscribe can be called only once., +/* package */class AtomicObservableSubscription implements Subscription {, +    private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();, +    public AtomicObservableSubscription() {, +    public AtomicObservableSubscription(Subscription actualSubscription) {, +    public AtomicObservableSubscription setActual(Subscription actualSubscription) {, +        Subscription actual = actualSubscription.getAndSet(null);, +++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatchableSubscription.java, +import org.rx.reactive.Subscription;, + * Thread-safe wrapper around ObservableSubscription that ensures unsubscribe can be called only once., +/* package */class AtomicObservableSubscription implements Subscription {, +    private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();, +    public AtomicObservableSubscription() {, +    public AtomicObservableSubscription(Subscription actualSubscription) {, +    public AtomicObservableSubscription setActual(Subscription actualSubscription) {, +        Subscription actual = actualSubscription.getAndSet(null);, +++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatcher.java, +import org.rx.reactive.Observer;, + * A thread-safe Observer for transitioning states in operators., + * <li>reactive.Observer.multithreaded.enabled [Default: false]</li>, +/* package */class AtomicObserver<T> implements Observer<T> {, +    private final Observer<T> Observer;, +    public AtomicObserver(Observer<T> Observer, AtomicObservableSubscription subscription) {, +            this.Observer = new AtomicObserverMultiThreaded<T>(Observer, subscription);, +            this.Observer = new AtomicObserverSingleThreaded<T>(Observer, subscription);, +        Observer.onCompleted();, +        Observer.onError(e);, +        Observer.onNext(args);, +++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatchableSubscription.java, +import org.rx.reactive.Subscription;, + * Thread-safe wrapper around ObservableSubscription that ensures unsubscribe can be called only once., +/* package */class AtomicObservableSubscription implements Subscription {, +    private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();, +    public AtomicObservableSubscription() {, +    public AtomicObservableSubscription(Subscription actualSubscription) {, +    public AtomicObservableSubscription setActual(Subscription actualSubscription) {, +        Subscription actual = actualSubscription.getAndSet(null);, +++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatcher.java, +import org.rx.reactive.Observer;, + * A thread-safe Observer for transitioning states in operators., + * <li>reactive.Observer.multithreaded.enabled [Default: false]</li>, +/* package */class AtomicObserver<T> implements Observer<T> {, +    private final Observer<T> Observer;, +    public AtomicObserver(Observer<T> Observer, AtomicObservableSubscription subscription) {, +            this.Observer = new AtomicObserverMultiThreaded<T>(Observer, subscription);, +            this.Observer = new AtomicObserverSingleThreaded<T>(Observer, subscription);, +        Observer.onCompleted();, +        Observer.onError(e);, +        Observer.onNext(args);, +++ b/rxjava-core/src/main/java/org/rx/operations/AtomicWatcherMultiThreaded.java, +import org.rx.reactive.Observable;, +import org.rx.reactive.Observer;, +import org.rx.reactive.Subscription;, + * A thread-safe Observer for transitioning states in operators., +/* package */class AtomicObserverMultiThreaded<T> implements Observer<T> {, +    private final Observer<T> Observer;, +    private final AtomicObservableSubscription subscription;, +    public AtomicObserverMultiThreaded(Observer<T> Observer, AtomicObservableSubscription subscription) {, +        this.Observer = Observer;, +                Observer.onNext(arg);, +                Observer.onError(e);, +                Observer.onCompleted();, +        Observer<String> aObserver;, +            Subscription s = mock(Subscription.class);, +            TestSingleThreadedObservable w = new TestSingleThreadedObservable(s, "one", "two", "three");, +            AtomicObservableSubscription as = new AtomicObservableSubscription(s);, +            AtomicObserverMultiThreaded<String> aw = new AtomicObserverMultiThreaded<String>(aObserver, as);, +            verify(aObserver, times(1)).onNext("one");, +            verify(aObserver, times(1)).onNext("two");, +            verify(aObserver, times(1)).onNext("three");, +            verify(aObserver, never()).onError(any(Exception.class));, +            verify(aObserver, times(1)).onCompleted();, +            Subscription s = mock(Subscription.class);, +            TestMultiThreadedObservable w = new TestMultiThreadedObservable(s, "one", "two", "three");, +            AtomicObservableSubscription as = new AtomicObservableSubscription(s);, +            BusyObserver busyObserver = new BusyObserver();, +            AtomicObserverMultiThreaded<String> aw = new AtomicObserverMultiThreaded<String>(busyObserver, as);, +            assertEquals(3, busyObserver.onNextCount.get());, +            assertFalse(busyObserver.onError);, +            assertTrue(busyObserver.onCompleted);, +            assertTrue(busyObserver.maxConcurrentThreads.get() > 1);, +            Subscription s = mock(Subscription.class);, +            TestMultiThreadedObservable w = new TestMultiThreadedObservable(s, "one", "two", "three", null);, +            AtomicObservableSubscription as = new AtomicObservableSubscription(s);, +            BusyObserver busyObserver = new BusyObserver();, +            AtomicObserverMultiThreaded<String> aw = new AtomicObserverMultiThreaded<String>(busyObserver, as);, +            assertTrue(busyObserver.onNextCount.get() >= 0 && busyObserver.onNextCount.get() <= 3);, +            assertTrue(busyObserver.onError);, +            assertFalse(busyObserver.onCompleted);, +            assertTrue(busyObserver.maxConcurrentThreads.get() > 1);, +            Subscription s = mock(Subscription.class);, +            TestMultiThreadedObservable w = new TestMultiThreadedObservable(s, "one", "two", "three", null, "four", "five", "six", "seven", "eight", "nine");, +            AtomicObservableSubscription as = new AtomicObservableSubscription(s);, +            BusyObserver busyObserver = new BusyObserver();, +            AtomicObserverMultiThreaded<String> aw = new AtomicObserverMultiThreaded<String>(busyObserver, as);, +            System.out.println("onNext count: " + busyObserver.onNextCount.get());, +            assertTrue(busyObserver.onNextCount.get() < 9);, +            assertTrue(busyObserver.onError);]