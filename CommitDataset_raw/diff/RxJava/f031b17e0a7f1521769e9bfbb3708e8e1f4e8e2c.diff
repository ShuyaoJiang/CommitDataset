[+++ b/src/main/java/rx/observables/AbstractOnSubscribe.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package rx.observables;, +, +import java.util.Arrays;, +import java.util.concurrent.atomic.*;, +, +import rx.*;, +import rx.Observable.OnSubscribe;, +import rx.annotations.Experimental;, +import rx.exceptions.CompositeException;, +import rx.functions.*;, +, +/**, + * Abstract base class for the OnSubscribe interface that helps building, + * observable sources one onNext at a time and automatically supports, + * unsubscription and backpressure., + * <p>, + * <h1>Usage rules</h1>, + * Implementors of the {@code next()} method, + * <ul>, + * <li>should either, + *   <ul>, + *   <li>create the next value and signal it via {@code state.onNext()},</li>, + *   <li>signal a terminal condition via {@code state.onError()} or {@code state.onCompleted()} or</li>, + *   <li>signal a stop condition via {@code state.stop()} indicating no further values will be sent.</li>, + *   </ul>, + * </li>, + * <li>may, + *   <ul>, + *   <li>call {@code state.onNext()} and either {@code state.onError()} or {@code state.onCompleted()} together and, + *   <li>block or sleep., + *   </ul>, + * </li>, + * <li>should not, + *   <ul>, + *   <li>do nothing or do async work and not produce any event or request stopping. If neither of , + *   the methods are called, an {@code IllegalStateException} is forwarded to the {@code Subscriber} and, + *   the Observable is terminated;</li>, + *   <li>call the {@code state.onXYZ} methods more than once (yields {@code IllegalStateException}).</li>, + *   </ul>, + * </li>, + * </ul>, + * , + * The {@code SubscriptionState} object features counters that may help implement a state machine:, + * <ul>, + * <li>A call counter, accessible via {@code state.calls()} that tells how many times , + * the {@code next()} was run (zero based)., + * <li>A phase counter, accessible via {@code state.phase()} that helps track the current emission , + * phase and may be used in a {@code switch ()} statement to implement the state machine. , + * (It was named phase to avoid confusion with the per-subscriber state.)</li>, + * <li>The current phase can be arbitrarily changed via {@code state.advancePhase()}, , + * {@code state.advancePhaseBy(int)} and {@code state.phase(int)}.</li>, + * , + * </ul>, + * <p>, + * The implementors of the {@code AbstractOnSubscribe} may override the {@code onSubscribe} to perform, + * special actions (such as registering {@code Subscription}s with {@code Subscriber.add()}) and return additional state for each subscriber subscribing. This custom state is, + * accessible through the {@code state.state()} method. If the custom state requires some form of cleanup,, + * the {@code onTerminated} method can be overridden., + * <p>, + * For convenience, lambda-accepting static factory methods, named {@code create()}, are available. Another, + * convenience is the {@code toObservable} which turns an {@code AbstractOnSubscribe} instance into an {@code Observable} fluently., + * , + * <h1>Examples</h1>, + * Note: the examples use the lambda-helper factories to avoid boilerplane., + * , + * <h3>Implement: just</h3>, + * <pre><code>, + * AbstractOnSubscribe.create(s -> {, + *   s.onNext(1);, + *   s.onCompleted();, + * }).toObservable().subscribe(System.out::println);, + * </code></pre>, +, + * <h3>Implement: from Iterable</h3>, + * <pre><code>, + * Iterable<T> iterable = ...;, + * AbstractOnSubscribe.create(s -> {, + *   Iterator<T> it = s.state();, + *   if (it.hasNext()) {, + *     s.onNext(it.next());, + *   }, + *   if (!it.hasNext()) {, + *     s.onCompleted();]