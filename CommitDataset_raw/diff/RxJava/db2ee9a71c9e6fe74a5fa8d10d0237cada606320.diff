[+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Observer;, +import rx.Producer;, +		private static final int MAX_QUEUE_SIZE = 1024;, +, +		private final ConcurrentHashMap<K, BufferUntilSubscriber<T>> groups = new ConcurrentHashMap<K, BufferUntilSubscriber<T>>();, +		private final ConcurrentHashMap<K, AtomicLong> requestedPerGroup = new ConcurrentHashMap<K, AtomicLong>();, +		private final ConcurrentHashMap<K, AtomicLong> countPerGroup = new ConcurrentHashMap<K, AtomicLong>();, +		private final ConcurrentHashMap<K, Queue<Object>> buffer = new ConcurrentHashMap<K, Queue<Object>>(MAX_QUEUE_SIZE);, +		, +		private static final NotificationLite<Object> nl = NotificationLite.instance();, +, +		static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_COUNTER_UPDATER, +		static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_EMITTED_UPDATER, +		volatile long requested;, +		@SuppressWarnings("rawtypes"), +		static final AtomicLongFieldUpdater<GroupBySubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "requested");, +, +		volatile long bufferedCount;, +		@SuppressWarnings("rawtypes"), +		static final AtomicLongFieldUpdater<GroupBySubscriber> BUFFERED_COUNT = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "bufferedCount");, +, +, +			REQUESTED.set(this, MAX_QUEUE_SIZE);, +			request(MAX_QUEUE_SIZE);, +				// for each group check if it is ready to accept more events if so pass the oncomplete through else buffer it., +				for(K key : groups.keySet()) {, +					emitItem(key, nl.completed());, +					if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {, +		// The grouped observable propagates the 'producer.request' call from it's subscriber to this method, +		// Here we keep track of the requested count for each group, +		// If we already have items queued when a request comes in we vend those and decrement the outstanding request count, +, +, +		void requestFromGroupedObservable(long n, K key) {, +			requestedPerGroup.get(key).getAndAdd(n);, +			if (countPerGroup.get(key).getAndIncrement() == 0) {, +				pollQueue(key);, +			}, +		}, +, +							COMPLETION_COUNTER_UPDATER.incrementAndGet(GroupBySubscriber.this);, +, +							o.setProducer(new Producer() {, +, +								@Override, +								public void request(long n) {, +, +									requestFromGroupedObservable(n, key);, +								}, +, +							});, +, +								}, +, +					requestedPerGroup.put(key, new AtomicLong());, +					countPerGroup.put(key, new AtomicLong());, +, +				emitItem(key, nl.next(t));, +		private void emitItem(K key, Object item) {, +			Queue<Object> q = buffer.get(key);, +			// short circuit buffering, +			if(requestedPerGroup.get(key).get() > 0 && (q == null || q.isEmpty()) ) {, +, +				BufferUntilSubscriber<T> group = groups.get(key);, +				nl.accept((Observer)group, item);, +, +				requestedPerGroup.get(key).decrementAndGet();, +				REQUESTED.decrementAndGet(this);, +			} else { , +				if(q == null) {, +					q = new ConcurrentLinkedQueue<Object>();, +					buffer.putIfAbsent(key, q);, +, +				} , +, +				q.add(item);, +				BUFFERED_COUNT.incrementAndGet(this);, +				REQUESTED.decrementAndGet(this);, +, +				if (countPerGroup.get(key).getAndIncrement() == 0) {, +					pollQueue(key);, +				}, +			}, +			requestMoreIfNecessary();, +		}, +, +, +		private void pollQueue(K key) {, +			do  {, +				drainIfPossible(key);, +				long c = countPerGroup.get(key).decrementAndGet();, +				if (c > 1) {, +, +					/*]