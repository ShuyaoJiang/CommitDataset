[+++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, +/* package */abstract class AbstractScheduler implements Scheduler {, +++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, +/* package */abstract class AbstractScheduler implements Scheduler {, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import static org.mockito.Mockito.*;, +import org.junit.Test;, +import org.mockito.InOrder;, +import rx.Subscription;, +import rx.util.functions.Action0;, +import rx.util.functions.Func0;, +, +/**, + * Schedules work on the current thread but does not execute immediately. Work is put in a queue and executed after the current unit of work is completed., + */, +++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, +/* package */abstract class AbstractScheduler implements Scheduler {, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import static org.mockito.Mockito.*;, +import org.junit.Test;, +import org.mockito.InOrder;, +import rx.Subscription;, +import rx.util.functions.Action0;, +import rx.util.functions.Func0;, +, +/**, + * Schedules work on the current thread but does not execute immediately. Work is put in a queue and executed after the current unit of work is completed., + */, +++ b/rxjava-core/src/main/java/rx/concurrency/DiscardableAction.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +/**, + * Combines standard {@link Subscription#unsubscribe()} functionality with ability to skip execution if an unsubscribe occurs before the {@link #call()} method is invoked., + */, +/* package */class DiscardableAction implements Func0<Subscription>, Subscription {, +++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, +/* package */abstract class AbstractScheduler implements Scheduler {, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import static org.mockito.Mockito.*;, +import org.junit.Test;, +import org.mockito.InOrder;, +import rx.Subscription;, +import rx.util.functions.Action0;, +import rx.util.functions.Func0;, +, +/**, + * Schedules work on the current thread but does not execute immediately. Work is put in a queue and executed after the current unit of work is completed., + */, +++ b/rxjava-core/src/main/java/rx/concurrency/DiscardableAction.java, +import java.util.concurrent.atomic.AtomicBoolean;, +, +/**, + * Combines standard {@link Subscription#unsubscribe()} functionality with ability to skip execution if an unsubscribe occurs before the {@link #call()} method is invoked., + */, +/* package */class DiscardableAction implements Func0<Subscription>, Subscription {, +++ b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java, +import java.util.concurrent.Executors;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.atomic.AtomicInteger;, + * Note that if an {@link Executor} implementation is used instead of {@link ScheduledExecutorService} then a system-wide Timer will be used to handle delayed events., +    /**, +     * Setup a ScheduledExecutorService that we can use if someone provides an Executor instead of ScheduledExecutorService., +     */, +    private final static ScheduledExecutorService SYSTEM_SCHEDULED_EXECUTOR;, +    static {, +        int count = Runtime.getRuntime().availableProcessors();, +        if (count > 8) {, +            count = count / 2;, +        }, +        // we don't need more than 8 to handle just scheduling and doing no work, +        if (count > 8) {, +            count = 8;, +        }, +        SYSTEM_SCHEDULED_EXECUTOR = Executors.newScheduledThreadPool(count, new ThreadFactory() {, +, +            final AtomicInteger counter = new AtomicInteger();, +, +            @Override, +            public Thread newThread(Runnable r) {, +                return new Thread(r, "RxScheduledExecutorPool-" + counter.incrementAndGet());, +            }, +, +        });, +, +    }, +, +, +        if (executor instanceof ScheduledExecutorService) {, +            if (dueTime == 0) {, +                // no delay so put on the thread-pool right now, +                return (schedule(action));, +            } else {, +                // there is a delay and this isn't a ScheduledExecutorService so we'll use a system-wide ScheduledExecutorService, +                // to handle the scheduling and once it's ready then execute on this Executor, +                SYSTEM_SCHEDULED_EXECUTOR.schedule(new Runnable() {, +, +                    @Override, +                    public void run() {, +                        // now execute on the real Executor, +                        executor.execute(new Runnable() {]