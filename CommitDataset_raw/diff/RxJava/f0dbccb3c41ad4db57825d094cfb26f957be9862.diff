[+++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            innerError(e);, +        private void innerError(Throwable e) {, +                parentSubscriber.innerError(e);, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            innerError(e);, +        private void innerError(Throwable e) {, +                parentSubscriber.innerError(e);, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +        run.add(f);, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            innerError(e);, +        private void innerError(Throwable e) {, +                parentSubscriber.innerError(e);, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +        run.add(f);, +++ b/src/main/java/rx/internal/schedulers/ScheduledAction.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.Future;, +import rx.exceptions.CompositeException;, +    final Subscription[] cancel;, +    volatile int count;, +    /** Set by the run() method to avoid self interrupting at the end of the run method. */, +    Thread runner;, +        this.cancel = new Subscription[4];, +        Thread thread = Thread.currentThread();, +            runner = thread;, +        return count < 0;, +        Subscription[] subs = cancel;, +        if (count >= 0) {, +            synchronized (this) {, +                if (count < 0) {, +                    return;, +                }, +                count = -1;, +            }, +        }, +        unsubscribeFromAll(subs);, +    }, +, +    , +    /**, +     * Adds a general Subscription to this {@code ScheduledAction} that will be unsubscribed, +     * if the underlying {@code action} completes or the this scheduled action is cancelled., +     *, +     * @param s the Subscription to add, +     */, +    public void add(Subscription s) {, +        if (count >= 0) {, +            synchronized (this) {, +                int c = count;, +                if (c >= 0) {, +                    cancel[c] = s;, +                    count = c + 1;, +                    return;, +                }, +            }, +        }, +        s.unsubscribe();, +    }, +, +    private static void unsubscribeFromAll(Subscription... subscriptions) {, +        if (subscriptions == null) {, +            return;, +        }, +        List<Throwable> es = null;, +        for (Subscription s : subscriptions) {, +            if (s == null) {, +                break;, +            }, +            try {, +                s.unsubscribe();, +            } catch (Throwable e) {, +                if (es == null) {, +                    es = new ArrayList<Throwable>();, +                }, +                es.add(e);, +            }, +        }, +        if (es != null) {, +            if (es.size() == 1) {, +                Throwable t = es.get(0);, +                if (t instanceof RuntimeException) {, +                    throw (RuntimeException) t;, +                } else {, +                    throw new CompositeException(, +                            "Failed to unsubscribe to 1 or more subscriptions.", es);, +                }, +            } else {, +                throw new CompositeException(, +                        "Failed to unsubscribe to 2 or more subscriptions.", es);, +            }, +     * Adds the given Future to the unsubscription composite in order to support, +     * cancelling the underlying task in the executor framework., +     * @param f the future to add, +    public void add(final Future<?> f) {, +        add(new FutureCompleter(f));, +        add(new Remover(this, parent));, +    }]