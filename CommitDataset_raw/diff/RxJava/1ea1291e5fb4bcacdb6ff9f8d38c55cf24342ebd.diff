[+++ b/src/main/java/io/reactivex/parallel/ParallelFlowable.java, +        return RxJavaPlugins.onAssembly(new ParallelFromPublisher<T>(source, parallelism, prefetch));, +        return RxJavaPlugins.onAssembly(new ParallelMap<T, R>(this, mapper));, +        return RxJavaPlugins.onAssembly(new ParallelFilter<T>(this, predicate));, +        return RxJavaPlugins.onAssembly(new ParallelRunOn<T>(this, scheduler, prefetch));, +        return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));, +        ObjectHelper.requireNonNull(comparator, "comparator is null");, +        ObjectHelper.verifyPositive(capacityHint, "capacityHint");, +        ObjectHelper.requireNonNull(comparator, "comparator is null");, +        ObjectHelper.verifyPositive(capacityHint, "capacityHint");, +, +        ObjectHelper.requireNonNull(onNext, "onNext is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onError, "onError is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onComplete, "onComplete is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onRequest, "onRequest is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onCancel, "onCancel is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");, +        ObjectHelper.requireNonNull(collector, "collector is null");, +        return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));, +        return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));, +        return RxJavaPlugins.onAssembly(to(composer));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");, +        return RxJavaPlugins.onAssembly(new ParallelFlatMap<T, R>(this, mapper, delayError, maxConcurrency, prefetch));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");, +        return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");, +        return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(, +                this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));, +++ b/src/main/java/io/reactivex/parallel/ParallelFlowable.java, +        return RxJavaPlugins.onAssembly(new ParallelFromPublisher<T>(source, parallelism, prefetch));, +        return RxJavaPlugins.onAssembly(new ParallelMap<T, R>(this, mapper));, +        return RxJavaPlugins.onAssembly(new ParallelFilter<T>(this, predicate));, +        return RxJavaPlugins.onAssembly(new ParallelRunOn<T>(this, scheduler, prefetch));, +        return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));, +        ObjectHelper.requireNonNull(comparator, "comparator is null");, +        ObjectHelper.verifyPositive(capacityHint, "capacityHint");, +        ObjectHelper.requireNonNull(comparator, "comparator is null");, +        ObjectHelper.verifyPositive(capacityHint, "capacityHint");, +, +        ObjectHelper.requireNonNull(onNext, "onNext is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onError, "onError is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onComplete, "onComplete is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onRequest, "onRequest is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(onCancel, "onCancel is null");, +        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, +                ));, +        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");, +        ObjectHelper.requireNonNull(collector, "collector is null");, +        return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));, +        return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));, +        return RxJavaPlugins.onAssembly(to(composer));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");, +        return RxJavaPlugins.onAssembly(new ParallelFlatMap<T, R>(this, mapper, delayError, maxConcurrency, prefetch));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");, +        return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));, +        ObjectHelper.requireNonNull(mapper, "mapper is null");, +        ObjectHelper.verifyPositive(prefetch, "prefetch");]