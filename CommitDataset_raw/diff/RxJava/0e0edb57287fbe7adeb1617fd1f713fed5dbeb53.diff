[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, +        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, +        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, +        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, +        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, +        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, +        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, +        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, +        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, +        Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, +        Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, +        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.<V, K>asFunction());, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +        this.collectionSupplier = (Callable<U>)ArrayListSupplier.asCallable();, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.HashMapSupplier;, +        return buffer(count, skip, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, +        return buffer(boundary, ArrayListSupplier.<T>asCallable());, +        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, +        return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, +        return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, +        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();]