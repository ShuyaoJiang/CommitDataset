[+++ b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java, +            // Fixed issue 428., +            // As unsubscribe will cancel the Future, and the currrent thread's interrupt status, +            // will be set. So we need to emit the chunk before unsubscribe., +            subscription.unsubscribe();, +++ b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java, +            // Fixed issue 428., +            // As unsubscribe will cancel the Future, and the currrent thread's interrupt status, +            // will be set. So we need to emit the chunk before unsubscribe., +            subscription.unsubscribe();, +++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java, +import static org.junit.Assert.assertFalse;, +, +import java.util.concurrent.CountDownLatch;, +import rx.util.functions.Action1;, +        @Test, +        public void testLongTimeAction() throws InterruptedException {, +            final CountDownLatch latch = new CountDownLatch(1);, +            LongTimeAction action = new LongTimeAction(latch);, +            Observable.from(1).buffer(10, TimeUnit.MILLISECONDS, 10), +                    .subscribe(action);, +            latch.await();, +            assertFalse(action.fail);, +        }, +, +        private static class LongTimeAction implements Action1<List<Integer>> {, +, +            CountDownLatch latch;, +            boolean fail = false;, +, +            public LongTimeAction(CountDownLatch latch) {, +                this.latch = latch;, +            }, +, +            @Override, +            public void call(List<Integer> t1) {, +                try {, +                    if (fail) {, +                        return;, +                    }, +                    Thread.sleep(200);, +                } catch (InterruptedException e) {, +                    fail = true;, +                } finally {, +                    latch.countDown();, +                }, +            }, +        }, +]