[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * @param default, +   * Returns an Observable that emits only the very first item emitted by the source Observable, or, +   * a default value if the source Observable is empty., +   *, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">, +   *, +   * @param default, +   *            The default value to emit if the source Observable doesn't emit anything., +   *            This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything., +   * @return an Observable that emits only the very first item from the source, or a default value, +   *         if the source Observable completes without emitting any item., +   */, +  def headOrElse[U >: T](default: => U): Observable[U] = firstOrElse(default), +, +  /**, +  def first: Observable[T] = take(1), +, +  def head: Observable[T] = {, +    this.take(1).fold[Option[T]](None)((v: Option[T], e: T) => Some(e)).map({, +      case Some(element) => element, +      case None => throw new NoSuchElementException("head of empty Observable"), +    }), +  // TODO def tail, +  , +   * Given 3 observables, returns an observable that emits Tuples of 3 elements each., +   * The first emitted Tuple will contain the first element of each source observable,, +   * the second Tuple the second element of each source observable, and so on., +   * @return an Observable that emits the zipped Observables, +  def zip[A, B, C](obA: Observable[A], obB: Observable[B], obC: Observable[C]): Observable[(A, B, C)] = {, +    Observable[(A, B, C)](rx.Observable.zip[A, B, C, (A, B, C)](obA.asJava, obB.asJava, obC.asJava, (a: A, b: B, c: C) => (a, b, c))), +   * Given 4 observables, returns an observable that emits Tuples of 4 elements each., +   * The first emitted Tuple will contain the first element of each source observable,, +   * the second Tuple the second element of each source observable, and so on., +   * , +   * @return an Observable that emits the zipped Observables, +   */, +  def zip[A, B, C, D](obA: Observable[A], obB: Observable[B], obC: Observable[C], obD: Observable[D]): Observable[(A, B, C, D)] = {, +    Observable[(A, B, C, D)](rx.Observable.zip[A, B, C, D, (A, B, C, D)](obA.asJava, obB.asJava, obC.asJava, obD.asJava, (a: A, b: B, c: C, d: D) => (a, b, c, d))), +  }, +, +  /**, +   * Given an Observable emitting `N` source observables, returns an observable that , +   * emits Seqs of `N` elements each., +   * Note that the returned Observable will only start emitting items once the given , +   * `Observable[Observable[T]]` has completed, because otherwise it cannot know `N`., +   * , +   * Emits 0, 1, 2, ... with a delay of `duration` between consecutive numbers., +   * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/interval.png">, +   *, +   * @param duration, +   *            duration between two consecutive numbers, +   * @return An Observable that emits a number each time interval., +  def interval(duration: Duration): Observable[Long] = {, +    (new Observable[java.lang.Long](JObservable.interval(duration.length, duration.unit))).map(_.longValue()), +  }, +, +  /**, +   * Emits 0, 1, 2, ... with a delay of `duration` between consecutive numbers., +   * , +   * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/interval.png">, +   *, +   * @param duration, +   *            duration between two consecutive numbers, +   * @param scheduler, +   *            the scheduler to use, +   * @return An Observable that emits a number each time interval., +   */, +  def interval(duration: Duration, scheduler: Scheduler): Observable[Long] = {, +  import org.mockito.Matchers._, +  @Test def testHead() {, +    val observer = mock(classOf[Observer[Int]]), +    val o = Observable().head, +    val sub = o.subscribe(observer), +, +    verify(observer, never).onNext(any(classOf[Int])), +    verify(observer, never).onCompleted(), +    verify(observer, times(1)).onError(any(classOf[NoSuchElementException])), +  }, +  ]