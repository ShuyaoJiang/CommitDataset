[+++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object that takes an `rx.Observer` private to the Scala bindings package., + `onError` or `onCompleted` methods. The advantage of this is that you get type inference as in `Observer(println(_))`., +The scheduler package has been renamed from `rx.lang.scala.concurrency` to `rx.lang.scala.schedulers`., +In the future we expect that this list will grow further with new schedulers as they are imported from .NET, +(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx)., +into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.concurrency`., +  def unsubscribe(): Unit = { ... }, +  def isUnsubscribed: Boolean = ..., + In case you do feel tempted to call `new Subscription{ ...}` directly make sure you wire up `isUnsubscribed`, + and with the `unsubscribed` field properly, but for all practical purposes you should just use one of the factory methods., +All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion, +`Notification` now has both constructor and destructor functions:, +, +  private [scala] def asJavaNotification: rx.Notification[_ <: T], +object Notification {, +   object OnNext { def apply(...){}; def unapply(..){...} }, +   object OnError { def apply(...){}; def unapply(..){...} }, +   object OnCompleted { def apply(...){}; def unapply(..){...} }, +To construct a `Notification`, you use `Notification.OnNext("hello")`, or `Notification.OnError`(new Exception("Oops!"))`., +To pattern match on a notification you can create a partial function like so: `case OnNext(v) => { ... v ... }`., +, +There are no breaking changes for notifications., +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object that takes an `rx.Observer` private to the Scala bindings package., + `onError` or `onCompleted` methods. The advantage of this is that you get type inference as in `Observer(println(_))`., +The scheduler package has been renamed from `rx.lang.scala.concurrency` to `rx.lang.scala.schedulers`., +In the future we expect that this list will grow further with new schedulers as they are imported from .NET, +(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx)., +into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.concurrency`., +  def unsubscribe(): Unit = { ... }, +  def isUnsubscribed: Boolean = ..., + In case you do feel tempted to call `new Subscription{ ...}` directly make sure you wire up `isUnsubscribed`, + and with the `unsubscribed` field properly, but for all practical purposes you should just use one of the factory methods., +All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion, +`Notification` now has both constructor and destructor functions:, +, +  private [scala] def asJavaNotification: rx.Notification[_ <: T], +object Notification {, +   object OnNext { def apply(...){}; def unapply(..){...} }, +   object OnError { def apply(...){}; def unapply(..){...} }, +   object OnCompleted { def apply(...){}; def unapply(..){...} }, +To construct a `Notification`, you use `Notification.OnNext("hello")`, or `Notification.OnError`(new Exception("Oops!"))`., +To pattern match on a notification you can create a partial function like so: `case OnNext(v) => { ... v ... }`., +, +There are no breaking changes for notifications., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +  private [scala] def asJava: rx.Notification[_ <: T], +  private [scala] def apply[T](n: rx.Notification[_ <: T]): Notification[T] = n.getKind match {, +, +      case n2: OnNext[U] => Some(n.getValue), +  class OnNext[+T] private[scala] (val asJava: rx.Notification[_ <: T]) extends Notification[T] {, +    def value: T = asJava.getValue, +      case n2: OnError[U] => Some(n2.error), +  class OnError[+T] private[scala] (val asJava: rx.Notification[_ <: T]) extends Notification[T] {, +    def error: Throwable = asJava.getThrowable, +  }, +  class OnCompleted[T] private[scala](val asJava: rx.Notification[_ <: T]) extends Notification[T] {}, +, +]