[+++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {, +++ b/src/main/java/rx/observables/GroupedObservable.java, + * An {@link Observable} that has been grouped by key, the value of which can be obtained with, + * {@link #getKey()}., + * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, + * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may, +    public GroupedObservable(K key, OnSubscribe<T> onSubscribe) {, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {, +++ b/src/main/java/rx/observables/GroupedObservable.java, + * An {@link Observable} that has been grouped by key, the value of which can be obtained with, + * {@link #getKey()}., + * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, + * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may, +    public GroupedObservable(K key, OnSubscribe<T> onSubscribe) {, +++ b/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java, +    private static final Func1<Integer, Boolean> INDEX_LESS_THAN_THREE = new Func1<Integer, Boolean>() {, +        int index = 0;, +        public Boolean call(Integer value) {, +            return index++ < 3;, +        src.skipWhile(INDEX_LESS_THAN_THREE).subscribe(w);, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {, +++ b/src/main/java/rx/observables/GroupedObservable.java, + * An {@link Observable} that has been grouped by key, the value of which can be obtained with, + * {@link #getKey()}., + * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, + * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may, +    public GroupedObservable(K key, OnSubscribe<T> onSubscribe) {, +++ b/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java, +    private static final Func1<Integer, Boolean> INDEX_LESS_THAN_THREE = new Func1<Integer, Boolean>() {, +        int index = 0;, +        public Boolean call(Integer value) {, +            return index++ < 3;, +        src.skipWhile(INDEX_LESS_THAN_THREE).subscribe(w);, +++ b/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java, +        Observable<String> take = w.takeWhile(new Func1<String, Boolean>() {, +            int index = 0;, +, +            public Boolean call(String input) {, +                return index++ < 2;, +        Observable<String> take = Observable.create(w).takeWhile(new Func1<String, Boolean>() {, +            int index = 0;, +, +            public Boolean call(String s) {, +                return index++ < 1;]