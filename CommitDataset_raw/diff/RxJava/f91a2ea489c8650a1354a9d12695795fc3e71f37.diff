[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.concurrency.Schedulers;, +import rx.operators.OperationOnExceptionResumeNextViaObservable;, +import rx.operators.SafeObservableSubscription;, +import rx.operators.SafeObserver;, +     * It stores a reference to the Observer in a collection object, such as a {@code List<T>} object., +     * sending them, which also invokes the Observer's {@link Observer#onCompleted onCompleted} method., +     * @param observer, +     *            the observer, +     *             if the {@link Observer} provided as the argument to {@code subscribe()} is {@code null}, +     * It stores a reference to the Observer in a collection object, such as a {@code List<T>} object., +     * sending them, which also invokes the Observer's {@link Observer#onCompleted onCompleted} method., +     * and notifying all Observers. Unless the documentation for a particular {@code Observable<T>} implementation indicates otherwise, Observers should make no, +     * @param observer, +     *            the observer, +        return OperationMulticast.multicast(this, subject);, +     * an Observable that invokes {@link Observer#onError onError} when the {@link Observer} subscribes to it., +     * Creates an Observable that will execute the given function when an {@link Observer} subscribes to it., +     * should invoke the Observer's {@link Observer#onNext onNext}, {@link Observer#onError onError}, and {@link Observer#onCompleted onCompleted} methods, +     *            a function that accepts an {@code Observer<T>}, invokes its {@code onNext}, {@code onError}, and {@code onCompleted} methods, +        return from(new ArrayList<T>());, +     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it, +     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it, +     * <p>Implementation note: the entire iterable sequence will be immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned,, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +     * <p>Implementation note: the entire array will be immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned,, +        return create(OperationToObservableIterable.toObservableIterable(Arrays.asList(items)));, +     * <p>Implementation note: the entire range will be immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned,, +        return from(list);, +     * @return an Observable that emits items that are the result of flattening the {@code source} list of Observables, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Given an Observable that emits Observables, creates a single Observable that, +     * emits the items emitted by the most recently published of those Observables., +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">, +     * @param sequenceOfSequences, +     *            the source Observable that emits Observables, +     * @return an Observable that emits only the items emitted by the most recently published, +     *         Observable, +    public static <T> Observable<T> switchDo(Observable<Observable<T>> sequenceOfSequences) {, +        // TODO should this static remain? I have left it because it is an Observable<Observable>, +        return create(OperationSwitch.switchDo(sequenceOfSequences));, +     * @throws ClassCastException, +     *             if sequence not of type {@code Observable<Observable<T>}, +    @SuppressWarnings("unchecked"), +    public Observable<T> switchDo() {, +        // TODO can we come up with a better name than this? It should be 'switch' but that is reserved., +        // Perhaps 'switchOnNext'?, +        return create(OperationSwitch.switchDo((Observable<Observable<T>>) this));, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     * Converts a {@link Future} into an Observable., +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/from.Future.png">, +     * <p>, +     * You can convert any object that supports the {@link Future} interface into an Observable that, +     * emits the return value of the {@link Future#get} method of that object, by passing the, +     * object into the {@code from} method., +     * <p>, +     * @param scheduler, +     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as {@link Schedulers#threadPoolForIO()} that can block and wait on the future., +     * @return an Observable that emits the item from the source Future, +    public static <T> Observable<T> from(Future<T> future, Scheduler scheduler) {, +        return create(OperationToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0} and the first item emitted by {@code w1}; the second item emitted by, +     * the new Observable will be the result of the function applied to the second item emitted by {@code w0} and the second item emitted by {@code w1}; and so forth., +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0}, the first item emitted by {@code w1}, and the first item emitted by {@code w2}; the second, +     * item emitted by the new Observable will be the result of the, +     * function applied to the second item emitted by {@code w0}, the second item emitted by {@code w1}, and the second item emitted by {@code w2}; and so forth., +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * new Observable will be the result of the function applied to the first item emitted by {@code w0}, the first item emitted by {@code w1}, the first item emitted by {@code w2}, and the first item, +     * emitted by {@code w3}; the second item emitted by, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations, +     * emitted and replaced with a new buffer when the Observable produced by the specified {@link Func0} produces a {@link BufferClosing} object. The * {@link Func0} will then, +     *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link BufferClosing} object., +        return create(OperationBuffer.buffer(this, bufferClosingSelector));, +     *         An {@link Observable} which produces buffers which are created and emitted when the specified {@link Observable}s publish certain objects., +        return create(OperationBuffer.buffer(this, bufferOpenings, bufferClosingSelector));, +        return create(OperationBuffer.buffer(this, count));, +        return create(OperationBuffer.buffer(this, count, skip));, +        return create(OperationBuffer.buffer(this, timespan, unit));, +        return create(OperationBuffer.buffer(this, timespan, unit, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, unit, count));, +        return create(OperationBuffer.buffer(this, timespan, unit, count, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit, scheduler));, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@code onNext} as many times as the number of {@code onNext} invokations of the, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@code onNext} as many times as the number of {@code onNext} invokations of the, +     *            a function that evaluates the items emitted by the source Observable, returning {@code true} if they pass the filter, +        return create(OperationFilter.filter(this, predicate));, +     * Registers an {@link Action0} to be called when this Observable invokes {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}., +     * @return an Observable that emits the same items as the source Observable, then invokes the {@link Action0}, +     *            a function that evaluates an item emitted by the source Observable, returning {@code true} if it passes the filter]