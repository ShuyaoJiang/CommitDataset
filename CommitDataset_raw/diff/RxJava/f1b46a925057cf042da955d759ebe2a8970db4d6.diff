[+++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.subjects.Subject;, +            private final Map<K, Subject<T, T>> groups = new HashMap<K, Subject<T, T>>();, +            private final AtomicBoolean completed = new AtomicBoolean(false);, +                completed.set(true);, +                for (Subject<T, T> ps : groups.values()) {, +                // special case for empty (no groups emitted), +                    Subject<T, T> gps = groups.get(key);, +                        final Subject<T, T> _gps = gps;, +                if (completionCounter.decrementAndGet() == 0 && (completed.get() || childObserver.isUnsubscribed())) {, +                    System.out.println("groupBy INNER completed");, +                    if (childObserver.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                    }, +                    for (Subject<T, T> ps : groups.values()) {, +++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.subjects.Subject;, +            private final Map<K, Subject<T, T>> groups = new HashMap<K, Subject<T, T>>();, +            private final AtomicBoolean completed = new AtomicBoolean(false);, +                completed.set(true);, +                for (Subject<T, T> ps : groups.values()) {, +                // special case for empty (no groups emitted), +                    Subject<T, T> gps = groups.get(key);, +                        final Subject<T, T> _gps = gps;, +                if (completionCounter.decrementAndGet() == 0 && (completed.get() || childObserver.isUnsubscribed())) {, +                    System.out.println("groupBy INNER completed");, +                    if (childObserver.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                    }, +                    for (Subject<T, T> ps : groups.values()) {, +++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java, +import java.util.ArrayList;, +import rx.util.functions.Action0;, +        Thread.sleep(500);, +        assertEquals(39, sentEventCounter.get());, +        Thread.sleep(500);, +        assertEquals(39, sentEventCounter.get());, +                        System.out.println("testUnsubscribe => GroupedObservable Key: " + eventGroupedObservable.getKey());, +    @Test(timeout = 1000), +    @Test(timeout = 500), +    public void testFilterGroupsUnsubscribesThem() {, +        final AtomicInteger subscribeCounter = new AtomicInteger();, +        final AtomicInteger sentEventCounter = new AtomicInteger();, +        final AtomicInteger eventCounter = new AtomicInteger();, +, +        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter), +                .groupBy(new Func1<Event, Integer>() {, +, +                    @Override, +                    public Integer call(Event e) {, +                        return e.source;, +                    }, +                }), +                // take 2 of the 4 groups, +                .filter(new Func1<GroupedObservable<Integer, Event>, Boolean>() {, +, +                    @Override, +                    public Boolean call(GroupedObservable<Integer, Event> g) {, +                        return g.getKey() < 2;, +                    }, +, +                }), +                .flatMap(new Func1<GroupedObservable<Integer, Event>, Observable<String>>() {, +, +                    @Override, +                    public Observable<String> call(GroupedObservable<Integer, Event> eventGroupedObservable) {, +                        return eventGroupedObservable, +                                .map(new Func1<Event, String>() {, +, +                                    @Override, +                                    public String call(Event event) {, +                                        return "testUnsubscribe => Source: " + event.source + "  Message: " + event.message;, +                                    }, +                                });, +, +                    }, +                }), +                .take(30).subscribe(new Action1<String>() {, +, +                    @Override, +                    public void call(String s) {, +                        eventCounter.incrementAndGet();, +                        System.out.println("=> " + s);, +                    }, +, +                });, +, +        assertEquals(30, eventCounter.get());, +        // we should send 30 additional events that are filtered out as they are in the groups we skip, +        assertEquals(60, sentEventCounter.get());, +    }, +, +    @Test, +    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() throws InterruptedException {, +        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete, +        final ArrayList<String> results = new ArrayList<String>();, +        Observable.create(new OnSubscribe<Integer>() {, +]