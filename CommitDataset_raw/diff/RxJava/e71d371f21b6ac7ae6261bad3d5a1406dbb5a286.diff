[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.queue.*;, +        sources.subscribe(new CompletableConcatSubscriber(s, prefetch));, +        private static final long serialVersionUID = 9032184911934499404L;, +        final CompletableObserver actual;, +, +        final int prefetch;, +, +        final int limit;, +, +        final ConcatInnerObserver inner;, +, +        final AtomicBoolean once;, +, +        int sourceFused;, +, +        int consumed;, +, +        SimpleQueue<CompletableSource> queue;, +        volatile boolean active;, +            this.inner = new ConcatInnerObserver(this);, +            this.once = new AtomicBoolean();, +            this.limit = prefetch - (prefetch >> 2);, +, +                long r = prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : prefetch;, +, +                if (s instanceof QueueSubscription) {, +                    @SuppressWarnings("unchecked"), +                    QueueSubscription<CompletableSource> qs = (QueueSubscription<CompletableSource>) s;, +, +                    int m = qs.requestFusion(QueueSubscription.ANY);, +, +                    if (m == QueueSubscription.SYNC) {, +                        sourceFused = m;, +                        queue = qs;, +                        done = true;, +                        drain();, +                        return;, +                    }, +                    if (m == QueueSubscription.ASYNC) {, +                        sourceFused = m;, +                        queue = qs;, +                        actual.onSubscribe(this);, +                        s.request(r);, +                        return;, +                    }, +                }, +, +                if (prefetch == Integer.MAX_VALUE) {, +                    queue = new SpscLinkedArrayQueue<CompletableSource>(Flowable.bufferSize());, +                } else {, +                    queue = new SpscArrayQueue<CompletableSource>(prefetch);, +                }, +, +                actual.onSubscribe(this);, +, +                s.request(r);, +            if (sourceFused == QueueSubscription.NONE) {, +            drain();, +                DisposableHelper.dispose(inner);, +            } else {, +        }, +            drain();, +            DisposableHelper.dispose(inner);, +            return DisposableHelper.isDisposed(inner.get());, +        void drain() {, +            if (getAndIncrement() != 0) {, +                return;, +            }, +, +            for (;;) {, +                if (isDisposed()) {, +                    return;, +                }, +, +                if (!active) {, +, +, +                    CompletableSource cs;, +, +                    try {, +                        cs = queue.poll();, +                    } catch (Throwable ex) {, +                        Exceptions.throwIfFatal(ex);, +                        innerError(ex);, +                        return;, +                    }, +, +                    boolean empty = cs == null;, +, +                    if (d && empty) {, +, +                    if (!empty) {, +                        active = true;, +                        cs.subscribe(inner);]