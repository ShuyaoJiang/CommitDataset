[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala, +        def unsubscribe() { u; unsubscribed.set(true) }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala, +        def unsubscribe() { u; unsubscribed.set(true) }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/BooleanSubscription.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala, +        def unsubscribe() { u; unsubscribed.set(true) }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/BooleanSubscription.scala, +++ b/rxjava-core/src/main/java/rx/subjects/AbstractSubject.java, +package rx.subjects;, +, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.concurrent.locks.ReentrantLock;, +, +import rx.Notification;, +import rx.Observer;, +import rx.Subscription;, +import rx.operators.SafeObservableSubscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action2;, +, +public abstract class AbstractSubject<T> extends Subject<T, T> {, +, +    protected AbstractSubject(rx.Observable.OnSubscribeFunc<T> onSubscribe) {, +        super(onSubscribe);, +    }, +, +    protected static class SubjectState<T> {, +        protected final ConcurrentHashMap<Subscription, Observer<? super T>> observers = new ConcurrentHashMap<Subscription, Observer<? super T>>();, +        protected final AtomicReference<Notification<T>> currentValue = new AtomicReference<Notification<T>>();, +        protected final AtomicBoolean completed = new AtomicBoolean();, +        protected final ReentrantLock SUBSCRIPTION_LOCK = new ReentrantLock();, +    }, +, +    protected static <T> OnSubscribeFunc<T> getOnSubscribeFunc(final SubjectState<T> state, final Action2<SubjectState<T>, Observer<? super T>> onEach) {, +        return new OnSubscribeFunc<T>() {, +            @Override, +            public Subscription onSubscribe(Observer<? super T> observer) {, +                /*, +                 * Subscription needs to be synchronized with terminal states to ensure, +                 * race conditions are handled. When subscribing we must make sure, +                 * onComplete/onError is correctly emitted to all observers, even if it, +                 * comes in while the onComplete/onError is being propagated., +                 */, +                state.SUBSCRIPTION_LOCK.lock();, +                try {, +                    if (state.completed.get()) {, +                        emitNotification(state.currentValue.get(), observer);, +                        if (onEach != null) {, +                            onEach.call(state, observer);, +                        }, +                        return Subscriptions.empty();, +                    } else {, +                        // the subject is not completed so we subscribe, +                        final SafeObservableSubscription subscription = new SafeObservableSubscription();, +, +                        subscription.wrap(new Subscription() {, +                            @Override, +                            public void unsubscribe() {, +                                // on unsubscribe remove it from the map of outbound observers to notify, +                                state.observers.remove(subscription);, +                            }, +                        });, +, +                        // on subscribe add it to the map of outbound observers to notify, +                        state.observers.put(subscription, observer);, +, +                        // invoke onSubscribe logic, +                        if (onEach != null) {, +                            onEach.call(state, observer);, +                        }, +, +                        return subscription;, +                    }, +                } finally {, +                    state.SUBSCRIPTION_LOCK.unlock();, +                }, +, +            }, +, +        };, +    }, +, +    protected static <T> void emitNotification(Notification<T> value, Observer<? super T> observer) {, +        // if null that means onNext was never invoked (no Notification set), +        if (value != null) {, +            if (value.isOnNext()) {, +                observer.onNext(value.getValue());, +            } else if (value.isOnError()) {, +                observer.onError(value.getThrowable());, +            } else if (value.isOnCompleted()) {, +                observer.onCompleted();, +            }, +        }, +    }, +]