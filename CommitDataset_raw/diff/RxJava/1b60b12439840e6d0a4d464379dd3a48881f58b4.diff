[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelDoOnNextTry.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators.parallel;, +, +import org.reactivestreams.*;, +, +import io.reactivex.exceptions.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.parallel.*;, +import io.reactivex.plugins.RxJavaPlugins;, +, +/**, + * Calls a Consumer for each upstream value passing by, + * and handles any failure with a handler function., + *, + * @param <T> the input value type, + * @since 2.0.8 - experimental, + */, +public final class ParallelDoOnNextTry<T> extends ParallelFlowable<T> {, +, +    final ParallelFlowable<T> source;, +, +    final Consumer<? super T> onNext;, +, +    final BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler;, +, +    public ParallelDoOnNextTry(ParallelFlowable<T> source, Consumer<? super T> onNext,, +            BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler) {, +        this.source = source;, +        this.onNext = onNext;, +        this.errorHandler = errorHandler;, +    }, +, +    @Override, +    public void subscribe(Subscriber<? super T>[] subscribers) {, +        if (!validate(subscribers)) {, +            return;, +        }, +, +        int n = subscribers.length;, +        @SuppressWarnings("unchecked"), +        Subscriber<? super T>[] parents = new Subscriber[n];, +, +        for (int i = 0; i < n; i++) {, +            Subscriber<? super T> a = subscribers[i];, +            if (a instanceof ConditionalSubscriber) {, +                parents[i] = new ParallelDoOnNextConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, onNext, errorHandler);, +            } else {, +                parents[i] = new ParallelDoOnNextSubscriber<T>(a, onNext, errorHandler);, +            }, +        }, +, +        source.subscribe(parents);, +    }, +, +    @Override, +    public int parallelism() {, +        return source.parallelism();, +    }, +, +    static final class ParallelDoOnNextSubscriber<T> implements ConditionalSubscriber<T>, Subscription {, +, +        final Subscriber<? super T> actual;, +, +        final Consumer<? super T> onNext;, +, +        final BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler;, +, +        Subscription s;, +, +        boolean done;, +, +        ParallelDoOnNextSubscriber(Subscriber<? super T> actual, Consumer<? super T> onNext,, +                BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler) {, +            this.actual = actual;, +            this.onNext = onNext;, +            this.errorHandler = errorHandler;, +        }, +, +        @Override, +        public void request(long n) {, +            s.request(n);, +        }, +, +        @Override]