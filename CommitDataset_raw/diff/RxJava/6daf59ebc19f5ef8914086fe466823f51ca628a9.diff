[+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatIterable.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatIterable.java, +            Disposable cancelled = disposables;, +                if (cancelled.isDisposed()) {, +                    if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, +, +    @SuppressWarnings("unchecked"), +    @Test, +    public void noSubsequentSubscription() {, +        final int[] calls = { 0 };, +, +        Flowable<Integer> source = Flowable.create(new FlowableOnSubscribe<Integer>() {, +            @Override, +            public void subscribe(FlowableEmitter<Integer> s) throws Exception {, +                calls[0]++;, +                s.onNext(1);, +                s.onComplete();, +            }, +        }, BackpressureStrategy.MISSING);, +, +        Flowable.concatArray(source, source).firstElement(), +        .test(), +        .assertResult(1);, +, +        assertEquals(1, calls[0]);, +    }, +, +    @SuppressWarnings("unchecked"), +    @Test, +    public void noSubsequentSubscriptionDelayError() {, +        final int[] calls = { 0 };, +, +        Flowable<Integer> source = Flowable.create(new FlowableOnSubscribe<Integer>() {, +            @Override, +            public void subscribe(FlowableEmitter<Integer> s) throws Exception {, +                calls[0]++;, +                s.onNext(1);, +                s.onComplete();, +            }, +        }, BackpressureStrategy.MISSING);, +, +        Flowable.concatArrayDelayError(source, source).firstElement(), +        .test(), +        .assertResult(1);, +, +        assertEquals(1, calls[0]);, +    }, +, +    @SuppressWarnings("unchecked"), +    @Test, +    public void noSubsequentSubscriptionIterable() {, +        final int[] calls = { 0 };, +, +        Flowable<Integer> source = Flowable.create(new FlowableOnSubscribe<Integer>() {, +            @Override, +            public void subscribe(FlowableEmitter<Integer> s) throws Exception {, +                calls[0]++;, +                s.onNext(1);, +                s.onComplete();, +            }, +        }, BackpressureStrategy.MISSING);, +, +        Flowable.concat(Arrays.asList(source, source)).firstElement(), +        .test(), +        .assertResult(1);, +, +        assertEquals(1, calls[0]);, +    }]