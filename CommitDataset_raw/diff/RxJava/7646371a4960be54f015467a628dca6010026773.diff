[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +        boolean doReplay = true;, +        if (state.addChild(rp)) {, +            if (rp.requested.get() == ReplaySubscription.CANCELLED) {, +                state.removeChild(rp);, +                doReplay = false;, +            }, +        }, +, +        if (doReplay) {, +            rp.replay();, +        }, +         * @return true if the ReplaySubscription was added or false if the cache is already terminated, +        public boolean addChild(ReplaySubscription<T> p) {, +                    return false;, +                    return true;, +        private static final long CANCELLED = Long.MIN_VALUE;, +        /**, +         * Number of items requested and also the cancelled indicator if, +         * it contains {@link #CANCELLED}., +         */, +        /** Number of items emitted so far. */, +        long emitted;, +, +                BackpressureHelper.addCancel(requested, n);, +            long e = emitted;, +                if (r == CANCELLED) {, +                    while (j < s && e != r) {, +                        e++;, +                    if (r == e) {, +                emitted = e;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +        boolean doReplay = true;, +        if (state.addChild(rp)) {, +            if (rp.requested.get() == ReplaySubscription.CANCELLED) {, +                state.removeChild(rp);, +                doReplay = false;, +            }, +        }, +, +        if (doReplay) {, +            rp.replay();, +        }, +         * @return true if the ReplaySubscription was added or false if the cache is already terminated, +        public boolean addChild(ReplaySubscription<T> p) {, +                    return false;, +                    return true;, +        private static final long CANCELLED = Long.MIN_VALUE;, +        /**, +         * Number of items requested and also the cancelled indicator if, +         * it contains {@link #CANCELLED}., +         */, +        /** Number of items emitted so far. */, +        long emitted;, +, +                BackpressureHelper.addCancel(requested, n);, +            long e = emitted;, +                if (r == CANCELLED) {, +                    while (j < s && e != r) {, +                        e++;, +                    if (r == e) {, +                emitted = e;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +            return current == null && queue.isEmpty();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +        boolean doReplay = true;, +        if (state.addChild(rp)) {, +            if (rp.requested.get() == ReplaySubscription.CANCELLED) {, +                state.removeChild(rp);, +                doReplay = false;, +            }, +        }, +, +        if (doReplay) {, +            rp.replay();, +        }, +         * @return true if the ReplaySubscription was added or false if the cache is already terminated, +        public boolean addChild(ReplaySubscription<T> p) {, +                    return false;, +                    return true;, +        private static final long CANCELLED = Long.MIN_VALUE;, +        /**, +         * Number of items requested and also the cancelled indicator if, +         * it contains {@link #CANCELLED}., +         */, +        /** Number of items emitted so far. */, +        long emitted;, +, +                BackpressureHelper.addCancel(requested, n);, +            long e = emitted;, +                if (r == CANCELLED) {, +                    while (j < s && e != r) {, +                        e++;, +                    if (r == e) {, +                emitted = e;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +            return current == null && queue.isEmpty();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +                        EmptySubscription.error(ex, child);, +                        return;]