[+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final ScheduledExecutorService COMPUTATION_EXECUTOR = createComputationExecutor();, +    private static final ScheduledExecutorService IO_EXECUTOR = createIOExecutor();, +    private static final int DEFAULT_MAX_IO_THREADS = 10;, +    private static final int DEFAULT_KEEP_ALIVE_TIME = 10 * 1000; // 10 seconds, +, +    public static Scheduler threadPoolForComputation() {, +        return fromScheduledExecutorService(COMPUTATION_EXECUTOR);, +    }, +, +    public static Scheduler threadPoolForIO() {, +        return fromScheduledExecutorService(IO_EXECUTOR);, +    }, +, +, +    private static ScheduledExecutorService createComputationExecutor() {, +        int cores = Runtime.getRuntime().availableProcessors();, +        return Executors.newScheduledThreadPool(cores, new ThreadFactory() {, +            final AtomicInteger counter = new AtomicInteger();, +, +            @Override, +            public Thread newThread(Runnable r) {, +                return new Thread(r, "RxComputationThreadPool-" + counter.incrementAndGet());, +            }, +        });, +    }, +, +    private static ScheduledExecutorService createIOExecutor() {, +        ScheduledThreadPoolExecutor result = new ScheduledThreadPoolExecutor(DEFAULT_MAX_IO_THREADS, new ThreadFactory() {, +            final AtomicInteger counter = new AtomicInteger();, +, +            @Override, +            public Thread newThread(Runnable r) {, +                return new Thread(r, "RxIOThreadPool-" + counter.incrementAndGet());, +            }, +        });, +, +        result.setKeepAliveTime(DEFAULT_KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS);, +        result.allowCoreThreadTimeOut(true);, +, +        return result;, +    }]