[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.observables.ConnectableObservable;, +import io.reactivex.schedulers.Schedulers;, +    , +    public final Observable<T> observeOn(Scheduler scheduler) {, +        return observeOn(scheduler, false, bufferSize());, +    }, +    , +    public final Observable<T> observeOn(Scheduler scheduler, boolean delayError) {, +        return observeOn(scheduler, delayError, bufferSize());, +    }, +    , +    public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {, +        // TODO implement, +        throw new UnsupportedOperationException();, +    }, +    , +    public final Observable<T> subscribeOn(Scheduler scheduler) {, +        // TODO implement, +        throw new UnsupportedOperationException();, +    }, +    , +    public final Observable<T> unsubscribeOn(Scheduler scheduler) {, +        // TODO implement, +        throw new UnsupportedOperationException();, +    }, +    , +    public final Observable<T> cache() {, +        return CachedObservable.from(this);, +    }, +, +    public final Observable<T> cache(int capacityHint) {, +        return CachedObservable.from(this, capacityHint);, +    }, +, +    public final ConnectableObservable<T> publish() {, +        return publish(bufferSize());, +    }, +, +    public final ConnectableObservable<T> publish(int bufferSize) {, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return OperatorPublish.create(this, bufferSize);, +    }, +, +    public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends Observable<R>> selector) {, +        return publish(selector, bufferSize());, +    }, +, +    public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends Observable<R>> selector, int bufferSize) {, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return OperatorPublish.create(this, selector, bufferSize);, +    }, +, +    public final ConnectableObservable<T> replay() {, +        return OperatorReplay.create(this);, +    }, +, +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector) {, +        return OperatorReplay.multicastSelector(this::replay, selector);, +    }, +    , +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize) {, +        return OperatorReplay.multicastSelector(() -> replay(bufferSize), selector);, +    }, +    , +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector, int bufferSize, long time, TimeUnit unit) {, +        return replay(selector, bufferSize, time, unit, Schedulers.computation());, +    }, +, +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {, +        if (bufferSize < 0) {, +            throw new IllegalArgumentException("bufferSize < 0");, +        }, +        return OperatorReplay.multicastSelector(() -> replay(bufferSize, time, unit, scheduler), selector);, +    }, +, +    public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(() -> replay(bufferSize), , +                t -> selector.apply(t).observeOn(scheduler));, +    }, +, +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector, long time, TimeUnit unit) {, +        return replay(selector, time, unit, Schedulers.computation());, +    }, +, +    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(() -> replay(time, unit, scheduler), selector);, +    }, +, +    public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler) {, +        return OperatorReplay.multicastSelector(() -> replay(), , +                t -> selector.apply(t).observeOn(scheduler));, +    }, +, +    public final ConnectableObservable<T> replay(final int bufferSize) {, +        return OperatorReplay.create(this, bufferSize);]