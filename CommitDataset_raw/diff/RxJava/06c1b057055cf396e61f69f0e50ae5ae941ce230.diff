[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import java.util.concurrent.atomic.AtomicReference;, +, +import rx.subjects.Subject;, +    public Subscriber<? super T> call(final Subscriber<? super R> child) {, +        @SuppressWarnings("unchecked"), +        final UnicastPassThruSubject<T>[] subjects = new UnicastPassThruSubject[degreeOfParallelism];, +        @SuppressWarnings("unchecked"), +        final Observable<R>[] os = new Observable[degreeOfParallelism];, +        for (int i = 0; i < subjects.length; i++) {, +            subjects[i] = UnicastPassThruSubject.<T> create();, +            os[i] = f.call(subjects[i].observeOn(scheduler));, +        }, +        // subscribe BEFORE receiving data so everything is hooked up, +        Observable.merge(os).unsafeSubscribe(child);, +, +        return new Subscriber<T>(child) {, +, +            int index = 0; // trust that we receive data synchronously, +            public void onCompleted() {, +                for (UnicastPassThruSubject<T> s : subjects) {, +                    s.onCompleted();, +                }, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                // bypass the subjects and immediately terminate, +                child.onError(e);, +            }, +, +            @Override, +            public void onNext(T t) {, +                // round-robin subjects, +                subjects[index++].onNext(t);, +                if (index >= degreeOfParallelism) {, +                    index = 0;, +                }, +            }, +, +        };, +, +    }, +, +    private static class UnicastPassThruSubject<T> extends Subject<T, T> {, +, +        private static <T> UnicastPassThruSubject<T> create() {, +            final AtomicReference<Subscriber<? super T>> subscriber = new AtomicReference<Subscriber<? super T>>();, +            return new UnicastPassThruSubject<T>(subscriber, new OnSubscribe<T>() {, +, +                @Override, +                public void call(Subscriber<? super T> s) {, +                    subscriber.set(s);, +        }, +, +        private final AtomicReference<Subscriber<? super T>> subscriber;, +, +        protected UnicastPassThruSubject(AtomicReference<Subscriber<? super T>> subscriber, OnSubscribe<T> onSubscribe) {, +            super(onSubscribe);, +            this.subscriber = subscriber;, +        }, +        public void onCompleted() {, +            subscriber.get().onCompleted();, +        @Override, +        public void onError(Throwable e) {, +            subscriber.get().onError(e);, +        }, +, +        @Override, +        public void onNext(T t) {, +            subscriber.get().onNext(t);, +        }, +, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import java.util.concurrent.atomic.AtomicReference;, +, +import rx.subjects.Subject;, +    public Subscriber<? super T> call(final Subscriber<? super R> child) {, +        @SuppressWarnings("unchecked"), +        final UnicastPassThruSubject<T>[] subjects = new UnicastPassThruSubject[degreeOfParallelism];, +        @SuppressWarnings("unchecked"), +        final Observable<R>[] os = new Observable[degreeOfParallelism];, +        for (int i = 0; i < subjects.length; i++) {, +            subjects[i] = UnicastPassThruSubject.<T> create();, +            os[i] = f.call(subjects[i].observeOn(scheduler));, +        }, +        // subscribe BEFORE receiving data so everything is hooked up, +        Observable.merge(os).unsafeSubscribe(child);, +, +        return new Subscriber<T>(child) {, +, +            int index = 0; // trust that we receive data synchronously, +            public void onCompleted() {, +                for (UnicastPassThruSubject<T> s : subjects) {, +                    s.onCompleted();, +                }, +            }, +, +            @Override, +            public void onError(Throwable e) {]