[+++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            if (done) {, +                return;, +            }, +            drain(false);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            if (done) {, +                return;, +            }, +            drain(false);, +++ b/src/main/java/io/reactivex/internal/operators/PublisherSequenceEqual.java, +import java.util.Queue;, +        EqualCoordinator<T> ec = new EqualCoordinator<>(s, bufferSize, first, second, comparer);, +        ec.subscribe();, +        void subscribe() {, +            EqualSubscriber<T>[] as = subscribers;, +            first.subscribe(as[0]);, +            second.subscribe(as[1]);, +        }, +, +            final EqualSubscriber<T> s2 = as[1];, +                    if ((d1 && d2) && (e1 != e2)) {, +                this.s = s;, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            if (done) {, +                return;, +            }, +            drain(false);, +++ b/src/main/java/io/reactivex/internal/operators/PublisherSequenceEqual.java, +import java.util.Queue;, +        EqualCoordinator<T> ec = new EqualCoordinator<>(s, bufferSize, first, second, comparer);, +        ec.subscribe();, +        void subscribe() {, +            EqualSubscriber<T>[] as = subscribers;, +            first.subscribe(as[0]);, +            second.subscribe(as[1]);, +        }, +, +            final EqualSubscriber<T> s2 = as[1];, +                    if ((d1 && d2) && (e1 != e2)) {, +                this.s = s;, +++ b/src/test/java/io/reactivex/internal/operators/OperatorSampleTest.java, +package io.reactivex.internal.operators;, +, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.TimeUnit;, +, +import org.junit.*;, +import org.mockito.InOrder;, +import org.reactivestreams.*;, +, +import io.reactivex.*;, +import io.reactivex.internal.subscriptions.EmptySubscription;, +import io.reactivex.schedulers.TestScheduler;, +import io.reactivex.subjects.PublishSubject;, +, +public class OperatorSampleTest {, +    private TestScheduler scheduler;, +    private Scheduler.Worker innerScheduler;, +    private Subscriber<Long> observer;, +    private Subscriber<Object> observer2;, +, +    @Before, +    // due to mocking, +    public void before() {, +        scheduler = new TestScheduler();, +        innerScheduler = scheduler.createWorker();, +        observer = TestHelper.mockSubscriber();, +        observer2 = TestHelper.mockSubscriber();, +    }, +, +    @Test, +    public void testSample() {, +        Observable<Long> source = Observable.create(new Publisher<Long>() {, +            @Override, +            public void subscribe(final Subscriber<? super Long> observer1) {, +                observer1.onSubscribe(EmptySubscription.INSTANCE);, +                innerScheduler.schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                        observer1.onNext(1L);, +                    }, +                }, 1, TimeUnit.SECONDS);]