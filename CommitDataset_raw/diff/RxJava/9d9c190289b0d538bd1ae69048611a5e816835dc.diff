[+++ b/src/main/java/io/reactivex/Observable.java, +        Objects.requireNonNull(onSubscribe);, +        Objects.requireNonNull(s);, +        Objects.requireNonNull(s);, +        Objects.requireNonNull(s);, +        Objects.requireNonNull(lifter);, +        Objects.requireNonNull(e);, +        Objects.requireNonNull(errorSupplier);, +    public final Observable<T> asObservable() {, +        Objects.requireNonNull(source);, +        Objects.requireNonNull(stream);, +        Objects.requireNonNull(future);, +    , +    public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {, +        return lift(new OperatorMap<>(mapper));, +    }, +    , +    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {, +        return flatMap(mapper, false, bufferSize(), bufferSize());, +    }, +    , +    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {, +        return flatMap(mapper, false, maxConcurrency, bufferSize());, +    }, +, +    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {, +        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());, +    }, +    , +    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {, +        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());, +    }, +    , +    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, , +            boolean delayErrors, int maxConcurrency, int bufferSize) {, +        Objects.requireNonNull(mapper);, +        if (maxConcurrency <= 0) {, +            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);, +        }, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        , +        return lift(new OperatorFlatMap<>(mapper, delayErrors, maxConcurrency, bufferSize));, +    }, +    , +    @SafeVarargs, +    public static <T> Observable<T> merge(Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, sources.length);, +    }, +    , +    public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v);, +    }, +    , +    @SafeVarargs, +    public static <T> Observable<T> merge(int maxConcurrency, Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, maxConcurrency);, +    }, +    , +    public static <T> Observable<T> merge(int maxConcurrency, Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v, maxConcurrency);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> merge(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, false, maxConcurrency, bufferSize);, +    }, +    , +    public static <T> Observable<T> merge(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v, false, maxConcurrency, bufferSize);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> mergeDelayError(Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, true, sources.length);, +    }, +    , +    public static <T> Observable<T> mergeDelayError(boolean delayErrors, Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v, true);, +    }, +    , +    @SafeVarargs, +    public static <T> Observable<T> mergeDelayError(int maxConcurrency, Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, true, maxConcurrency);, +    }, +    , +    public static <T> Observable<T> mergeDelayError(int maxConcurrency, Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v, true, maxConcurrency);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> mergeDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, +        return fromArray(sources).flatMap(v -> v, true, maxConcurrency, bufferSize);, +    }, +    , +    public static <T> Observable<T> mergeDelayError(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {, +        return fromIterable(sources).flatMap(v -> v, true, maxConcurrency, bufferSize);, +    }, +]