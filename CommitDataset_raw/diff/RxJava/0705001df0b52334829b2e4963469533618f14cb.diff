[+++ b/src/main/java/io/reactivex/Completable.java, +            return RxJavaPlugins.onAssembly(new CompletableWrapper(onSubscribe));, +    @SchedulerSupport(SchedulerSupport.NONE), +    public static Completable fromFuture(final Future<?> future) {, +        Objects.requireNonNull(future, "future is null");, +        return fromCallable(new Callable<Object>() {, +            @Override, +            public Object call() throws Exception {, +                future.get();, +                return null;, +            }, +        });, +    }, +    , +     * Returns an Observable which will subscribe to this Completable and once that is completed then , +     * will subscribe to the {@code next} Observable. An error event from this Completable will be , +     * propagated to the downstream subscriber and will result in skipping the subscription of the , +     * Observable.  , +     * , +     * @param <T> the value type of the next Observable, +     * @param next the Observable to subscribe after this Completable is completed, not null, +     * @return Observable that composes this Completable and next, +     * @throws NullPointerException if next is null, +     */, +    public final <T> Observable<T> andThen(Observable<T> next) {, +        Objects.requireNonNull(next, "next is null");, +        return next.delaySubscription(toObservable());, +    }, +, +    /**, +     * Returns an Flowable which will subscribe to this Completable and once that is completed then , +     * will subscribe to the {@code next} Flowable. An error event from this Completable will be , +     * propagated to the downstream subscriber and will result in skipping the subscription of the , +     * Observable.  , +     * , +     * @param <T> the value type of the next Flowable, +     * @param next the Observable to subscribe after this Completable is completed, not null, +     * @return Flowable that composes this Completable and next, +     * @throws NullPointerException if next is null, +     */, +    public final <T> Flowable<T> andThen(Flowable<T> next) {, +        Objects.requireNonNull(next, "next is null");, +        return next.delaySubscription(toFlowable());, +    }, +, +    /**, +     * Returns a Single which will subscribe to this Completable and once that is completed then, +     * will subscribe to the {@code next} Single. An error event from this Completable will be, +     * propagated to the downstream subscriber and will result in skipping the subscription of the, +     * Single., +     * <dl>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code andThen} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @param <T> the value type of the next Single, +     * @param next the Single to subscribe after this Completable is completed, not null, +     * @return Single that composes this Completable and next, +     */, +    public final <T> Single<T> andThen(Single<T> next) {, +        Objects.requireNonNull(next, "next is null");, +        return next.delaySubscription(toObservable());, +    }, +, +    /**, +     * Returns a Completable that first runs this Completable, +     * and then the other completable., +     * <p>, +     * This is an alias for {@link #concatWith(CompletableConsumable)}., +     * @param next the other Completable, not null, +     * @return the new Completable instance, +     * @throws NullPointerException if other is null, +     */, +    public final Completable andThen(Completable next) {, +        return concatWith(next);, +    }, +    , +, +    /**, +        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(), , +                onComplete, Functions.emptyRunnable(), Functions.emptyRunnable(),, +                Functions.emptyRunnable());, +        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(), , +                Functions.emptyRunnable(), Functions.emptyRunnable(),, +                Functions.emptyRunnable(), onDispose);, +        return doOnLifecycle(Functions.emptyConsumer(), onError, , +                Functions.emptyRunnable(), Functions.emptyRunnable(),, +                Functions.emptyRunnable(), Functions.emptyRunnable());, +     * @param onAfterTerminate the runnable called after this Completable completes normally, +            final Runnable onTerminate,, +            final Runnable onAfterTerminate,, +        Objects.requireNonNull(onTerminate, "onTerminate is null");, +        Objects.requireNonNull(onAfterTerminate, "onAfterTerminate is null");, +        return new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate, onDisposed);, +        return doOnLifecycle(onSubscribe, Functions.emptyConsumer(), , +                Functions.emptyRunnable(), Functions.emptyRunnable(),, +                Functions.emptyRunnable(), Functions.emptyRunnable());, +        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(), , +                Functions.emptyRunnable(), onTerminate, , +                Functions.emptyRunnable(), Functions.emptyRunnable());]