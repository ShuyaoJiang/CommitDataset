[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +        volatile boolean finished;, +        boolean done;, +            completeEvictions();, +            done = true;, +            finished = true;, +                finished = true;, +                completeEvictions();, +        private void completeEvictions() {, +            if (evictedGroups != null) {, +                int count = 0;, +                GroupedUnicast<K, V> evictedGroup;, +                while ((evictedGroup = evictedGroups.poll()) != null) {, +                    evictedGroup.onComplete();, +                    count++;, +                }, +                if (count != 0) {, +                    groupCount.addAndGet(-count);, +                }, +            }, +        }, +, +                boolean d = finished;, +                    boolean d = finished;, +                if (e == r && checkTerminated(finished, q.isEmpty(), a, q)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +        volatile boolean finished;, +        boolean done;, +            completeEvictions();, +            done = true;, +            finished = true;, +                finished = true;, +                completeEvictions();, +        private void completeEvictions() {, +            if (evictedGroups != null) {, +                int count = 0;, +                GroupedUnicast<K, V> evictedGroup;, +                while ((evictedGroup = evictedGroups.poll()) != null) {, +                    evictedGroup.onComplete();, +                    count++;, +                }, +                if (count != 0) {, +                    groupCount.addAndGet(-count);, +                }, +            }, +        }, +, +                boolean d = finished;, +                    boolean d = finished;, +                if (e == r && checkTerminated(finished, q.isEmpty(), a, q)) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java, +import com.google.common.base.Ticker;, +    private static final class TestTicker extends Ticker {, +        long tick = 0;, +, +        @Override, +        public long read() {, +            return tick;, +        }, +    }, +    , +    @Test, +    public void testGroupByEvictionCancellationOfSource5933() {, +        PublishProcessor<Integer> source = PublishProcessor.create();, +        final TestTicker testTicker = new TestTicker();, +, +        Function<Consumer<Object>, Map<Integer, Object>> mapFactory = new Function<Consumer<Object>, Map<Integer, Object>>() {, +            @Override, +            public Map<Integer, Object> apply(final Consumer<Object> action) throws Exception {, +                return CacheBuilder.newBuilder() //, +                        .expireAfterAccess(5, TimeUnit.SECONDS).removalListener(new RemovalListener<Object, Object>() {, +                            @Override, +                            public void onRemoval(RemovalNotification<Object, Object> notification) {, +                                try {, +                                    action.accept(notification.getValue());, +                                } catch (Exception ex) {, +                                    throw new RuntimeException(ex);, +                                }, +                            }, +                        }).ticker(testTicker) //, +                        .<Integer, Object>build().asMap();, +            }, +        };, +, +        final List<String> list = new CopyOnWriteArrayList<String>();, +        Flowable<Integer> stream = source //, +                .doOnCancel(new Action() {, +                    @Override, +                    public void run() throws Exception {, +                        list.add("Source canceled");, +                    }, +                }), +                .<Integer, Integer>groupBy(Functions.<Integer>identity(), Functions.<Integer>identity(), false,, +                        Flowable.bufferSize(), mapFactory) //, +                .flatMap(new Function<GroupedFlowable<Integer, Integer>, Publisher<? extends Integer>>() {, +                    @Override, +                    public Publisher<? extends Integer> apply(GroupedFlowable<Integer, Integer> group), +                            throws Exception {, +                        return group //, +                                .doOnComplete(new Action() {]