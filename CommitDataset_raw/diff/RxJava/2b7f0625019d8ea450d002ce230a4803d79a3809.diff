[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Flattens the sequence of Observables emitted by {@code this} into one Observable, without any, +   * transformation., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">, +   * <p>, +   * You can combine the items emitted by multiple Observables so that they act like a single, +   * Observable, by using the {@code merge} method., +   *, +   * @return an Observable that emits items that are the result of flattening the items emitted, +   *         by the Observables emitted by {@code this}, +   */, +  def merge[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.merge[U](o4), +    Observable[U](o5), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Flattens the sequence of Observables emitted by {@code this} into one Observable, without any, +   * transformation., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">, +   * <p>, +   * You can combine the items emitted by multiple Observables so that they act like a single, +   * Observable, by using the {@code merge} method., +   *, +   * @return an Observable that emits items that are the result of flattening the items emitted, +   *         by the Observables emitted by {@code this}, +   */, +  def merge[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.merge[U](o4), +    Observable[U](o5), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/Olympics.scala, +    // And this https://github.com/Netflix/RxJava/pull/289#issuecomment-24738668 also causes problems, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Flattens the sequence of Observables emitted by {@code this} into one Observable, without any, +   * transformation., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">, +   * <p>, +   * You can combine the items emitted by multiple Observables so that they act like a single, +   * Observable, by using the {@code merge} method., +   *, +   * @return an Observable that emits items that are the result of flattening the items emitted, +   *         by the Observables emitted by {@code this}, +   */, +  def merge[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.merge[U](o4), +    Observable[U](o5), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/Olympics.scala, +    // And this https://github.com/Netflix/RxJava/pull/289#issuecomment-24738668 also causes problems, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def mergeTwoExample() {, +  def myInterval(period: Long): Observable[String] = {, +    Observable.interval(period.millis).map(n => s"Obs-$period emits $n"), +  }, +  , +  @Test def mergeManyExample() {, +    val o = Observable.interval(500 millis).map(n => myInterval((n+1)*100)), +    val stopper = Observable.interval(5 seconds), +    o.merge.takeUntil(stopper).toBlockingObservable.foreach(println(_)), +  }, +  , +  @Test def mergeSomeExample() {, +    // To merge some observables which are all known already:, +    Observable(, +        Observable.interval(200 millis), , +        Observable.interval(400 millis), , +        Observable.interval(800 millis), +    ).merge.take(12).toBlockingObservable.foreach(println(_)), +  }    , +  , +  @Test def timingTest() {, +    val firstOnly = false, +    val numbersByModulo3 = Observable.interval(1000 millis).take(9).groupBy(_ % 3), +    , +    (for ((modulo, numbers) <- numbersByModulo3) yield {, +      println("Observable for modulo" + modulo + " started"), +      , +      if (firstOnly) numbers.take(1) else numbers, +    }).merge.toBlockingObservable.foreach(println(_)) , +  }, +  , +  @Test def timingTest1() {]