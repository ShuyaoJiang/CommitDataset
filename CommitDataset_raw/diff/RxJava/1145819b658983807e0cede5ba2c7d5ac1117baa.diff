[+++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +    public boolean offer(final T e) {, +        if (null == e) {, +            throw new NullPointerException("Null is not a valid element");, +        }, +        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +    public boolean offer(final T e) {, +        if (null == e) {, +            throw new NullPointerException("Null is not a valid element");, +        }, +        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +import java.util.concurrent.atomic.*;, +, +import io.reactivex.internal.fuseable.SimpleQueue;, +import io.reactivex.internal.util.Pow2;, +public final class SpscArrayQueue<E> extends AtomicReferenceArray<E> implements SimpleQueue<E> {, +    final int mask;, +, +        super(Pow2.roundToPowerOfTwo(capacity));, +        this.mask = length() - 1;, +    void soProducerIndex(long newIndex) {, +    void soConsumerIndex(long newIndex) {, +, +    @Override, +    public void clear() {, +        // we have to test isEmpty because of the weaker poll() guarantee, +        while (poll() != null || !isEmpty()) ; // NOPMD, +    }, +, +    int calcElementOffset(long index, int mask) {, +        return (int)index & mask;, +    }, +, +    int calcElementOffset(long index) {, +        return (int)index & mask;, +    }, +, +    void soElement(int offset, E value) {, +        lazySet(offset, value);, +    }, +, +    E lvElement(int offset) {, +        return get(offset);, +    }, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +            return;, +        lazySet(DisposableHelper.DISPOSED);, +        lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +    public boolean offer(final T e) {, +        if (null == e) {, +            throw new NullPointerException("Null is not a valid element");, +        }, +        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +import java.util.concurrent.atomic.*;, +, +import io.reactivex.internal.fuseable.SimpleQueue;, +import io.reactivex.internal.util.Pow2;, +public final class SpscArrayQueue<E> extends AtomicReferenceArray<E> implements SimpleQueue<E> {, +    final int mask;, +]