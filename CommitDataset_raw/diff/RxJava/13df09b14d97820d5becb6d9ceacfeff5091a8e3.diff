[+++ b/src/main/java/io/reactivex/Flowable.java, +    static final Flowable<Object> NEVER = new Flowable<Object>() { // FIXME factor out, +        public void subscribeActual(Subscriber<? super Object> s) {, +    };, +    /**, +     * Hides the identity of this Flowable and its Subscription., +     * <p>Allows hiding extra features such as {@link Processor}'s, +     * {@link Subscriber} methods or preventing certain identity-based , +     * optimizations (fusion)., +     * @return the new Flowable instance, +     * , +     * @since 2.0, +     */, +    @BackpressureSupport(BackpressureKind.PASS_THROUGH), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> hide() {, +        return new FlowableHide<T>(this);, +    }, +, +    , +++ b/src/main/java/io/reactivex/Flowable.java, +    static final Flowable<Object> NEVER = new Flowable<Object>() { // FIXME factor out, +        public void subscribeActual(Subscriber<? super Object> s) {, +    };, +    /**, +     * Hides the identity of this Flowable and its Subscription., +     * <p>Allows hiding extra features such as {@link Processor}'s, +     * {@link Subscriber} methods or preventing certain identity-based , +     * optimizations (fusion)., +     * @return the new Flowable instance, +     * , +     * @since 2.0, +     */, +    @BackpressureSupport(BackpressureKind.PASS_THROUGH), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Flowable<T> hide() {, +        return new FlowableHide<T>(this);, +    }, +, +    , +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.subscribers.flowable.*;, +public final class FlowableFilter<T> extends FlowableSource<T, T> {, +        super(source);, +        if (s instanceof ConditionalSubscriber) {, +            source.subscribe(new FilterConditionalSubscriber<T>(, +                    (ConditionalSubscriber<? super T>)s, predicate));, +        } else {, +    }, +    static final class FilterSubscriber<T> extends BasicFuseableSubscriber<T, T> , +    implements ConditionalSubscriber<T> {, +            super(actual);, +                s.request(1);, +                fail(e);, +        public int requestFusion(int mode) {, +            return transitiveBoundaryFusion(mode);, +, +        public T poll() {, +            QueueSubscription<T> qs = this.qs;, +            Predicate<? super T> f = filter;, +            , +            for (;;) {, +                T t = qs.poll();, +                if (t == null) {, +                    return null;, +                }, +                , +                if (f.test(t)) {, +                    return t;, +                }, +                , +                if (sourceMode == ASYNC) {, +                    qs.request(1);, +                }, +            }, +        }, +        , +        , +    }, +    , +    static final class FilterConditionalSubscriber<T> extends BasicFuseableConditionalSubscriber<T, T> {, +        final Predicate<? super T> filter;, +        , +        public FilterConditionalSubscriber(ConditionalSubscriber<? super T> actual, Predicate<? super T> filter) {, +            super(actual);, +            this.filter = filter;, +        }, +        , +        @Override, +        public void onNext(T t) {, +            if (!tryOnNext(t)) {, +                s.request(1);, +            }, +        }, +        , +        @Override, +        public boolean tryOnNext(T t) {, +            if (done) {, +                return false;]