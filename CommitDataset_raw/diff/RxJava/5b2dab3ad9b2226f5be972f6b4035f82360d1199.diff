[+++ b/rxjava-core/src/main/java/rx/schedulers/ExecutorScheduler.java, +import rx.subscriptions.MultipleAssignmentSubscription;, +        final InnerExecutorScheduler _scheduler = new InnerExecutorScheduler(executor);, +, +        final CompositeSubscription subscription = new CompositeSubscription(discardableAction, _scheduler);, +                    discardableAction.call(_scheduler);, +                return schedule(state, action);, +                        _scheduler.schedule(state, action);, +        CompositeSubscription s = new CompositeSubscription();, +        s.add(discardableAction);, +        final InnerExecutorScheduler _scheduler = new InnerExecutorScheduler(executor);, +        s.add(_scheduler);, +, +        s.add(execute(executor, new Runnable() {, +                discardableAction.call(_scheduler);, +        }));, +        return s;, +    }, +, +    /**, +     * Execute on the given Executor and retrieve a Subscription, +     * , +     * @param executor, +     * @param r, +     * @return, +     */, +    private static Subscription execute(Executor executor, Runnable r) {, +            return Subscriptions.from(f);, +            return Subscriptions.empty();, +        }, +    private static class InnerExecutorScheduler extends Scheduler implements Subscription {, +, +        private final MultipleAssignmentSubscription childSubscription = new MultipleAssignmentSubscription();, +        private final Executor executor;, +, +        InnerExecutorScheduler(Executor executor) {, +            this.executor = executor;, +        }, +, +        @Override, +        public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +            if(childSubscription.isUnsubscribed()) {, +                return childSubscription;, +            }, +            , +            CompositeSubscription s = new CompositeSubscription();, +            final DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);, +            s.add(discardableAction);, +, +            final Scheduler _scheduler = this;, +, +            s.add(execute(executor, new Runnable() {, +, +                @Override, +                public void run() {, +                    discardableAction.call(_scheduler);, +                }, +            }));, +, +            // replace the InnerExecutorScheduler child subscription with this one, +            childSubscription.set(s);, +            /*, +             * TODO: Consider what will happen if `schedule` is run concurrently instead of recursively, +             * and we lose subscriptions as the `childSubscription` only remembers the last one scheduled., +             * , +             * Not obvious that this should ever happen. Can it?, +             * , +             * benjchristensen => Haven't been able to come up with a valid test case to prove this as an issue, +             * so it may not be., +             */, +, +            return childSubscription;, +        }, +, +        @Override, +        public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {, +            if(childSubscription.isUnsubscribed()) {, +                return childSubscription;, +            }, +            , +            CompositeSubscription s = new CompositeSubscription();, +            final DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);, +            s.add(discardableAction);, +, +            final Scheduler _scheduler = this;, +, +            if (executor instanceof ScheduledExecutorService) {, +                // we are a ScheduledExecutorService so can do proper scheduling, +                ScheduledFuture<?> f = ((ScheduledExecutorService) executor).schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                        // when the delay has passed we now do the work on the actual scheduler, +                        discardableAction.call(_scheduler);, +                    }, +                }, delayTime, unit);, +                // replace the InnerExecutorScheduler child subscription with this one, +                childSubscription.set(Subscriptions.from(f));, +            } else {, +                // we are not a ScheduledExecutorService so can't directly schedule, +                if (delayTime == 0) {]