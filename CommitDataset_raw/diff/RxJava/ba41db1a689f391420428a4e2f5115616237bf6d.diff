[+++ b/language-adaptors/README.md, +++ b/language-adaptors/README.md, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCombineLatest;, +     * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineLatestFunction , +     *          The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +     */, +    public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));, +    }, +    , +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));, +    }, +, +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));, +    }, +    , +    /**, +++ b/language-adaptors/README.md, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCombineLatest;, +     * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineLatestFunction , +     *          The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +     */, +    public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));, +    }, +    , +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));, +    }, +, +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +import org.mockito.Matchers;, +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineLatestFunction , +     *          The aggregation function used to combine the source observable values., +        private void startWatching() {, +        // Stores how many observers have already completed, +        private final AtomicInteger numCompleted = new AtomicInteger(0);, +         * The latest value from each observer., +         */, +        private final Map<CombineObserver<R, ?>, Object> latestValue = new ConcurrentHashMap<CombineObserver<R, ?>, Object>();, +            int completed = numCompleted.incrementAndGet();, +            if (completed == observers.size()) {, +            if (latestValue.size() < observers.size()) {, +            , +            Object[] argsToCombineLatest = new Object[observers.size()];, +            , +            try {, +                R combinedValue = combineLatestFunction.call(argsToCombineLatest);, +                observer.onNext(combinedValue);, +            } catch(Exception ex) {, +                observer.onError(ex);, +        @Test, +        public void testCombineLatestWithFunctionThatThrowsAnException() {, +            @SuppressWarnings("unchecked") // mock calls don't do generics, +            Observer<String> w = mock(Observer.class);, +            , +            TestObservable w1 = new TestObservable();, +            TestObservable w2 = new TestObservable();, +            ]