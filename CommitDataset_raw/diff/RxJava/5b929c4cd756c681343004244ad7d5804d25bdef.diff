[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java, +import java.util.concurrent.TimeUnit;, +import io.reactivex.*;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.Schedulers;, +public final class FlowableRefCount<T> extends Flowable<T> {, +, +    final int n;, +    final long timeout;, +    final TimeUnit unit;, +    final Scheduler scheduler;, +    RefConnection connection;, +, +    public FlowableRefCount(ConnectableFlowable<T> source) {, +        this(source, 1, 0L, TimeUnit.NANOSECONDS, Schedulers.trampoline());, +    }, +, +    public FlowableRefCount(ConnectableFlowable<T> source, int n, long timeout, TimeUnit unit,, +            Scheduler scheduler) {, +        this.source = source;, +        this.n = n;, +        this.timeout = timeout;, +        this.unit = unit;, +        this.scheduler = scheduler;, +    protected void subscribeActual(Subscriber<? super T> s) {, +, +        RefConnection conn;, +, +        boolean connect = false;, +        synchronized (this) {, +            conn = connection;, +            if (conn == null) {, +                conn = new RefConnection(this);, +                connection = conn;, +            long c = conn.subscriberCount;, +            if (c == 0L && conn.timer != null) {, +                conn.timer.dispose();, +            }, +            conn.subscriberCount = c + 1;, +            if (!conn.connected && c + 1 == n) {, +                connect = true;, +                conn.connected = true;, +            }, +        source.subscribe(new RefCountSubscriber<T>(s, this, conn));, +, +        if (connect) {, +            source.connect(conn);, +        }, +    void cancel(RefConnection rc) {, +        SequentialDisposable sd;, +        synchronized (this) {, +            if (connection == null) {, +                return;, +            }, +            long c = rc.subscriberCount - 1;, +            rc.subscriberCount = c;, +            if (c != 0L || !rc.connected) {, +                return;, +            }, +            if (timeout == 0L) {, +                timeout(rc);, +                return;, +            }, +            sd = new SequentialDisposable();, +            rc.timer = sd;, +        sd.replace(scheduler.scheduleDirect(rc, timeout, unit));, +    void terminated(RefConnection rc) {, +        synchronized (this) {, +            if (connection != null) {, +                connection = null;, +                if (rc.timer != null) {, +                    rc.timer.dispose();, +                }, +    void timeout(RefConnection rc) {, +        synchronized (this) {, +            if (rc.subscriberCount == 0 && rc == connection) {, +                connection = null;, +                DisposableHelper.dispose(rc);, +                if (source instanceof Disposable) {, +                    ((Disposable)source).dispose();, +    static final class RefConnection extends AtomicReference<Disposable>, +    implements Runnable, Consumer<Disposable> {, +        private static final long serialVersionUID = -4552101107598366241L;, +, +        final FlowableRefCount<?> parent;, +, +        Disposable timer;, +, +        long subscriberCount;, +, +        boolean connected;, +, +        RefConnection(FlowableRefCount<?> parent) {, +            this.parent = parent;, +            parent.timeout(this);, +        @Override, +        public void accept(Disposable t) throws Exception {, +            DisposableHelper.replace(this, t);]