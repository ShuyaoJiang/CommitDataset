[+++ b/src/main/java/io/reactivex/Completable.java, +     * <p>, +     * Note that the inner {@code Publisher} returned by the handler function should signal, +     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received, +     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to, +     * the operator is asynchronous, signalling onNext followed by onComplete immediately may, +     * result in the sequence to be completed immediately. Similarly, if this inner, +     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is, +     * active, the sequence is terminated with the same signal immediately., +     * <p>, +     * The following example demonstrates how to retry an asynchronous source with a delay:, +     * <pre><code>, +     * Completable.timer(1, TimeUnit.SECONDS), +     *     .doOnSubscribe(s -&gt; System.out.println("subscribing")), +     *     .doOnComplete(() -&gt; { throw new RuntimeException(); }), +     *     .retryWhen(errors -&gt; {, +     *         AtomicInteger counter = new AtomicInteger();, +     *         return errors, +     *                   .takeWhile(e -&gt; counter.getAndIncrement() != 3), +     *                   .flatMap(e -&gt; {, +     *                       System.out.println("delay retry by " + counter.get() + " second(s)");, +     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);, +     *                   });, +     *     }), +     *     .blockingAwait();, +     * </code></pre>, +++ b/src/main/java/io/reactivex/Completable.java, +     * <p>, +     * Note that the inner {@code Publisher} returned by the handler function should signal, +     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received, +     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to, +     * the operator is asynchronous, signalling onNext followed by onComplete immediately may, +     * result in the sequence to be completed immediately. Similarly, if this inner, +     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is, +     * active, the sequence is terminated with the same signal immediately., +     * <p>, +     * The following example demonstrates how to retry an asynchronous source with a delay:, +     * <pre><code>, +     * Completable.timer(1, TimeUnit.SECONDS), +     *     .doOnSubscribe(s -&gt; System.out.println("subscribing")), +     *     .doOnComplete(() -&gt; { throw new RuntimeException(); }), +     *     .retryWhen(errors -&gt; {, +     *         AtomicInteger counter = new AtomicInteger();, +     *         return errors, +     *                   .takeWhile(e -&gt; counter.getAndIncrement() != 3), +     *                   .flatMap(e -&gt; {, +     *                       System.out.println("delay retry by " + counter.get() + " second(s)");, +     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);, +     *                   });, +     *     }), +     *     .blockingAwait();, +     * </code></pre>, +++ b/src/main/java/io/reactivex/Flowable.java, +     * <p>, +     *  Flowable.create((FlowableEmitter&lt;? super String&gt; s) -&gt; {, +     *  }, BackpressureStrategy.BUFFER).retryWhen(attempts -&gt; {, +     *          return Flowable.timer(i, TimeUnit.SECONDS);, +     * <p>, +     * Note that the inner {@code Publisher} returned by the handler function should signal, +     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received, +     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to, +     * the operator is asynchronous, signalling onNext followed by onComplete immediately may, +     * result in the sequence to be completed immediately. Similarly, if this inner, +     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is, +     * active, the sequence is terminated with the same signal immediately., +     * <p>, +     * The following example demonstrates how to retry an asynchronous source with a delay:, +     * <pre><code>, +     * Flowable.timer(1, TimeUnit.SECONDS), +     *     .doOnSubscribe(s -&gt; System.out.println("subscribing")), +     *     .map(v -&gt; { throw new RuntimeException(); }), +     *     .retryWhen(errors -&gt; {, +     *         AtomicInteger counter = new AtomicInteger();, +     *         return errors, +     *                   .takeWhile(e -&gt; counter.getAndIncrement() != 3), +     *                   .flatMap(e -&gt; {, +     *                       System.out.println("delay retry by " + counter.get() + " second(s)");, +     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);, +     *                   });, +     *     }), +     *     .blockingSubscribe(System.out::println, System.out::println);, +     * </code></pre>, +     *  <dd>The operator honors downstream backpressure and expects both the source, +     *  and inner {@code Publisher}s to honor backpressure as well., +++ b/src/main/java/io/reactivex/Completable.java, +     * <p>, +     * Note that the inner {@code Publisher} returned by the handler function should signal, +     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received, +     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to, +     * the operator is asynchronous, signalling onNext followed by onComplete immediately may, +     * result in the sequence to be completed immediately. Similarly, if this inner, +     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is, +     * active, the sequence is terminated with the same signal immediately., +     * <p>, +     * The following example demonstrates how to retry an asynchronous source with a delay:, +     * <pre><code>, +     * Completable.timer(1, TimeUnit.SECONDS), +     *     .doOnSubscribe(s -&gt; System.out.println("subscribing")), +     *     .doOnComplete(() -&gt; { throw new RuntimeException(); }), +     *     .retryWhen(errors -&gt; {]