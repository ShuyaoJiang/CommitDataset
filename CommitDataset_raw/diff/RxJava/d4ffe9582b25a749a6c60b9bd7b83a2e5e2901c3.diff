[+++ b/src/main/java/rx/internal/operators/OnSubscribeRefCount.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.locks.ReentrantLock;, +, +import rx.functions.Action1;, +import rx.subscriptions.CompositeSubscription;, + * Returns an observable sequence that stays connected to the source as long as, + * there is at least one subscription to the observable sequence., + * , + * @param <T>, + *            the value type, +, +    private final ConnectableObservable<? extends T> source;, +    private volatile CompositeSubscription baseSubscription = new CompositeSubscription();, +    private final AtomicInteger subscriptionCount = new AtomicInteger(0);, +, +    /**, +     * Use this lock for every subscription and disconnect action., +     */, +    private final ReentrantLock lock = new ReentrantLock();, +, +    /**, +     * Constructor., +     * , +     * @param source, +     *            observable to apply ref count to, +     */, +    public void call(final Subscriber<? super T> subscriber) {, +, +        lock.lock();, +        if (subscriptionCount.incrementAndGet() == 1) {, +, +            final AtomicBoolean writeLocked = new AtomicBoolean(true);, +, +            try {, +                // need to use this overload of connect to ensure that, +                // baseSubscription is set in the case that source is a, +                // synchronous Observable, +                source.connect(onSubscribe(subscriber, writeLocked));, +            } finally {, +                // need to cover the case where the source is subscribed to, +                // outside of this class thus preventing the above Action1, +                // being called, +                if (writeLocked.get()) {, +                    // Action1 was not called, +                    lock.unlock();, +            }, +        } else {, +            try {, +                // handle unsubscribing from the base subscription, +                subscriber.add(disconnect());, +, +                // ready to subscribe to source so do it, +                source.unsafeSubscribe(subscriber);, +            } finally {, +                // release the read lock, +                lock.unlock();, +            }, +        }, +, +    }, +, +    private Action1<Subscription> onSubscribe(final Subscriber<? super T> subscriber,, +            final AtomicBoolean writeLocked) {, +        return new Action1<Subscription>() {, +            @Override, +            public void call(Subscription subscription) {, +, +                try {, +                    baseSubscription.add(subscription);, +, +                    // handle unsubscribing from the base subscription, +                    subscriber.add(disconnect());, +, +                    // ready to subscribe to source so do it, +                    source.unsafeSubscribe(subscriber);, +                } finally {, +                    // release the write lock, +                    lock.unlock();, +                    writeLocked.set(false);, +                }, +            }, +        };, +    }, +, +    private Subscription disconnect() {, +        return Subscriptions.create(new Action0() {, +                lock.lock();, +                try {, +                    if (subscriptionCount.decrementAndGet() == 0) {, +                        baseSubscription.unsubscribe();, +                        // need a new baseSubscription because once, +                        // unsubscribed stays that way, +                        baseSubscription = new CompositeSubscription();, +                } finally {, +                    lock.unlock();, +        });, +++ b/src/main/java/rx/internal/operators/OnSubscribeRefCount.java, +import java.util.concurrent.atomic.AtomicBoolean;]