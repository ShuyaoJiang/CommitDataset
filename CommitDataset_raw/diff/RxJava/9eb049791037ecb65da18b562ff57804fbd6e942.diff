[+++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java, +    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java, +    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationFilter.java, +import rx.util.AtomicObservableSubscription;, +    private static class Filter<T> implements OperatorSubscribeFunction<T> {, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +            return subscription.wrap(that.subscribe(new Observer<T>() {, +                        // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable, +                        subscription.unsubscribe();, +            }));, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java, +    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationFilter.java, +import rx.util.AtomicObservableSubscription;, +    private static class Filter<T> implements OperatorSubscribeFunction<T> {, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +            return subscription.wrap(that.subscribe(new Observer<T>() {, +                        // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable, +                        subscription.unsubscribe();, +            }));, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationLast.java, +    private static class Last<T> implements OperatorSubscribeFunction<T> {, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java, +    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationFilter.java, +import rx.util.AtomicObservableSubscription;, +    private static class Filter<T> implements OperatorSubscribeFunction<T> {, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +            return subscription.wrap(that.subscribe(new Observer<T>() {, +                        // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable, +                        subscription.unsubscribe();, +            }));, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationLast.java, +    private static class Last<T> implements OperatorSubscribeFunction<T> {, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationMap.java, +    private static class MapObservable<T, R> implements OperatorSubscribeFunction<R> {, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import rx.observables.operations.OperatorSubscribeFunction;, +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        if (onSubscribe instanceof OperatorSubscribeFunction) {, +            /*, +             * This means it's a 'trusted' operator so we won't wrap it., +             */, +            return onSubscribe.call(observer);, +        } else {, +        }, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java, +    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {]