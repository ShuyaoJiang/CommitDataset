[+++ b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java, +            subscriptions.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +                subscription.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +++ b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java, +            subscriptions.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +                subscription.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +++ b/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java, +        public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +            final DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);, +            // all subscriptions that may need to be unsubscribed, +            final CompositeSubscription subscription = new CompositeSubscription(discardableAction);, +            , +            subscription.add(Subscriptions.from(executor.submit(new Runnable() {, +                    Subscription s = discardableAction.call(_scheduler);, +                    subscription.add(s);, +            })));, +            , +            return subscription;, +            subscription.add(Subscriptions.from(f));, +    public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +        subscription.add(Subscriptions.from(f));, +++ b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java, +            subscriptions.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +                subscription.add(Subscriptions.from(f));, +            subscription.add(Subscriptions.from(f));, +++ b/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java, +        public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +            final DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);, +            // all subscriptions that may need to be unsubscribed, +            final CompositeSubscription subscription = new CompositeSubscription(discardableAction);, +            , +            subscription.add(Subscriptions.from(executor.submit(new Runnable() {, +                    Subscription s = discardableAction.call(_scheduler);, +                    subscription.add(s);, +            })));, +            , +            return subscription;, +            subscription.add(Subscriptions.from(f));, +    public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +        subscription.add(Subscriptions.from(f));, +++ b/rxjava-core/src/test/java/rx/concurrency/SchedulerUnsubscribeTest.java, +package rx.concurrency;, +, +import static org.junit.Assert.*;, +, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.junit.Test;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +import rx.operators.SafeObservableSubscription;, +import rx.util.functions.Func1;, +, +public class SchedulerUnsubscribeTest {, +, +    /**, +     * Bug report: https://github.com/Netflix/RxJava/issues/431, +     */, +    @Test, +    public void testUnsubscribeOfNewThread() throws InterruptedException {, +        testUnSubscribeForScheduler(Schedulers.newThread());, +    }, +, +    @Test, +    public void testUnsubscribeOfThreadPoolForIO() throws InterruptedException {, +        testUnSubscribeForScheduler(Schedulers.threadPoolForIO());, +    }, +    , +    @Test, +    public void testUnsubscribeOfThreadPoolForComputation() throws InterruptedException {, +        testUnSubscribeForScheduler(Schedulers.threadPoolForComputation());, +    }, +    , +    @Test, +    public void testUnsubscribeOfCurrentThread() throws InterruptedException {, +        testUnSubscribeForScheduler(Schedulers.currentThread());, +    }, +, +    public void testUnSubscribeForScheduler(Scheduler scheduler) throws InterruptedException {, +, +        final AtomicInteger countReceived = new AtomicInteger();, +        final AtomicInteger countGenerated = new AtomicInteger();, +        final SafeObservableSubscription s = new SafeObservableSubscription();, +        final CountDownLatch latch = new CountDownLatch(1);, +, +        s.wrap(Observable.interval(50, TimeUnit.MILLISECONDS), +                .map(new Func1<Long, Long>() {, +                    @Override, +                    public Long call(Long aLong) {, +                        System.out.println("generated " + aLong);, +                        countGenerated.incrementAndGet();]