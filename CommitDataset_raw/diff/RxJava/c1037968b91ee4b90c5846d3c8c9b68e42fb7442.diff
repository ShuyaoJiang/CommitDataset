[+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndLock.java, +package rx.observers;, +, +import java.util.ArrayList;, +, +import rx.Observer;, +, +public class SerializedObserverViaQueueAndLock<T> implements Observer<T> {, +    private final Observer<? super T> actual;, +, +    private boolean emitting = false;, +    private boolean terminated = false;, +    private ArrayList<Object> queue = new ArrayList<Object>();, +, +    private static Sentinel NULL_SENTINEL = new Sentinel();, +    private static Sentinel COMPLETE_SENTINEL = new Sentinel();, +, +    private static class Sentinel {, +, +    }, +, +    private static class ErrorSentinel extends Sentinel {, +        final Throwable e;, +, +        ErrorSentinel(Throwable e) {, +            this.e = e;, +        }, +    }, +, +    public SerializedObserverViaQueueAndLock(Observer<? super T> s) {, +        this.actual = s;, +    }, +, +    @Override, +    public void onCompleted() {, +        boolean canEmit = false;, +        ArrayList<Object> list = null;, +        synchronized (this) {, +            if (terminated) {, +                return;, +            }, +            terminated = true;, +            if (!emitting) {, +                // emit immediately, +                emitting = true;, +                canEmit = true;, +                if (queue.size() > 0) {, +                    list = queue; // copy reference, +                    queue = new ArrayList<Object>(); // new version;, +                }, +            } else {, +                // someone else is already emitting so just queue it, +                queue.add(COMPLETE_SENTINEL);, +            }, +        }, +        if (canEmit) {, +            // we won the right to emit, +            try {, +                drainQueue(list);, +                actual.onCompleted();, +            } finally {, +                synchronized (this) {, +                    emitting = false;, +                }, +            }, +        }, +    }, +, +    @Override, +    public void onError(final Throwable e) {, +        boolean canEmit = false;, +        ArrayList<Object> list = null;, +        synchronized (this) {, +            if (terminated) {, +                return;, +            }, +            terminated = true;, +            if (!emitting) {, +                // emit immediately, +                emitting = true;, +                canEmit = true;, +                if (queue.size() > 0) {, +                    list = queue; // copy reference, +                    queue = new ArrayList<Object>(); // new version;, +                }, +            } else {, +                // someone else is already emitting so just queue it ... after eliminating the queue to shortcut, +                queue.clear();, +                queue.add(new ErrorSentinel(e));, +            }, +        }, +        if (canEmit) {, +            // we won the right to emit, +            try {, +                drainQueue(list);, +                actual.onError(e);, +            } finally {, +                synchronized (this) {, +                    emitting = false;, +                }]