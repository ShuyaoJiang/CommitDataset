[+++ b/build.gradle, +	/**, +	 * By default: Run without arguments this will execute all benchmarks that are found (can take a long time)., +	 *, +	 * Optionally pass arguments for custom execution. Example:, +	 *, +	 *  ../gradlew benchmarks '-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*OperatorSerializePerf.*', +	 *, +	 * To see all options:, +	 *, +	 *  ../gradlew benchmarks '-Pjmh=-h', +	 */ , +		, +		if (project.hasProperty('jmh')) {, +		      args(jmh.split(' ')), +		} else {, +	 		args '5', +	 		args '.*OperatorSerializePerf.*' // for running only a specific test, +		}, +++ b/build.gradle, +	/**, +	 * By default: Run without arguments this will execute all benchmarks that are found (can take a long time)., +	 *, +	 * Optionally pass arguments for custom execution. Example:, +	 *, +	 *  ../gradlew benchmarks '-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*OperatorSerializePerf.*', +	 *, +	 * To see all options:, +	 *, +	 *  ../gradlew benchmarks '-Pjmh=-h', +	 */ , +		, +		if (project.hasProperty('jmh')) {, +		      args(jmh.split(' ')), +		} else {, +	 		args '5', +	 		args '.*OperatorSerializePerf.*' // for running only a specific test, +		}, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import java.util.ArrayList;, +, +import rx.operators.NotificationLite;, +    private ArrayList<Object> queue = new ArrayList<Object>();, +    private NotificationLite<T> on = NotificationLite.instance();, +        boolean canEmit = false;, +        ArrayList<Object> list = null;, +            if (!emitting) {, +                // emit immediately, +                canEmit = true;, +                if (queue.size() > 0) {, +                    list = queue; // copy reference, +                    queue = new ArrayList<Object>(); // new version;, +            } else {, +                // someone else is already emitting so just queue it, +                queue.add(on.completed());, +            }, +        }, +, +        if (canEmit) {, +            // we won the right to emit, +            try {, +            } finally {, +                synchronized (this) {, +                    emitting = false;, +                }, +            }, +        }, +        boolean canEmit = false;, +        ArrayList<Object> list = null;, +            if (!emitting) {, +                // emit immediately, +                canEmit = true;, +                if (queue.size() > 0) {, +                    list = queue; // copy reference, +                    queue = new ArrayList<Object>(); // new version;, +            } else {, +                // someone else is already emitting so just queue it ... after eliminating the queue to shortcut, +                queue.clear();, +                queue.add(on.error(e));, +            }, +        }, +        if (canEmit) {, +            // we won the right to emit, +            try {, +            } finally {, +                synchronized (this) {, +                    emitting = false;, +                }, +            }, +        }, +        boolean canEmit = false;, +        ArrayList<Object> list = null;, +            if (!emitting) {, +                // emit immediately, +                canEmit = true;, +                if (queue.size() > 0) {, +                    list = queue; // copy reference, +                    queue = new ArrayList<Object>(); // new version;, +            } else {, +                // someone else is already emitting so just queue it]