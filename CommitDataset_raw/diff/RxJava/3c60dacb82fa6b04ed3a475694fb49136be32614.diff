[+++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        /**, +         * @return boolean true if propagated value, +         */, +        public boolean onNext(int index, T t) {, +                    return false;, +                } else {, +            }, +            return true;, +            boolean emitted = producer.onNext(index, t);, +            if (!emitted) {, +                request(1);, +            }, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        /**, +         * @return boolean true if propagated value, +         */, +        public boolean onNext(int index, T t) {, +                    return false;, +                } else {, +            }, +            return true;, +            boolean emitted = producer.onNext(index, t);, +            if (!emitted) {, +                request(1);, +            }, +++ b/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.Notification;, +import rx.functions.Action1;, +, +    @Test, +    public void testWithCombineLatestIssue1717() throws InterruptedException {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicInteger count = new AtomicInteger();, +        final int SIZE = 2000;, +        Observable<Long> timer = Observable.timer(0, 1, TimeUnit.MILLISECONDS), +                .observeOn(Schedulers.newThread()), +                .doOnEach(new Action1<Notification<? super Long>>() {, +, +                    @Override, +                    public void call(Notification<? super Long> n) {, +                        //                        System.out.println(n);, +                        if (count.incrementAndGet() >= SIZE) {, +                            latch.countDown();, +                        }, +                    }, +, +                }).take(SIZE);, +, +        TestSubscriber<Long> ts = new TestSubscriber<Long>();, +, +        Observable.combineLatest(timer, Observable.<Integer> never(), new Func2<Long, Integer, Long>() {, +, +            @Override, +            public Long call(Long t1, Integer t2) {, +                return t1;, +            }, +, +        }).subscribe(ts);, +, +        if (!latch.await(SIZE + 1000, TimeUnit.MILLISECONDS)) {, +            fail("timed out");, +        }, +, +        assertEquals(SIZE, count.get());, +    }, +]