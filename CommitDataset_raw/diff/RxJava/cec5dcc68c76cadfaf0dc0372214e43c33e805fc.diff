[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.annotations.SchedulerSupport;, +import io.reactivex.internal.util.Exceptions;, +    public static Completable defer(final Callable<? extends CompletableConsumable> completableSupplier) {, +    public static Completable error(final Callable<? extends Throwable> errorSupplier) {, +    public static <R> Completable using(Callable<R> resourceSupplier, , +            final Callable<R> resourceSupplier, , +        try {, +        } catch (Throwable ex) {, +            throw Exceptions.propagate(ex);, +        }, +    public final <T> Single<T> toSingle(final Callable<? extends T> completionValueSupplier) {, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.annotations.SchedulerSupport;, +import io.reactivex.internal.util.Exceptions;, +    public static Completable defer(final Callable<? extends CompletableConsumable> completableSupplier) {, +    public static Completable error(final Callable<? extends Throwable> errorSupplier) {, +    public static <R> Completable using(Callable<R> resourceSupplier, , +            final Callable<R> resourceSupplier, , +        try {, +        } catch (Throwable ex) {, +            throw Exceptions.propagate(ex);, +        }, +    public final <T> Single<T> toSingle(final Callable<? extends T> completionValueSupplier) {, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.*;, +    public static <T> Flowable<T> defer(Callable<? extends Publisher<? extends T>> supplier) {, +    public static <T> Flowable<T> error(Callable<? extends Throwable> errorSupplier) {, +        return error(new Callable<Throwable>() {, +            public Throwable call() {, +            public Object apply(Object s, Subscriber<T> o) throws Exception {, +    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Subscriber<T>> generator) {, +            public S apply(S s, Subscriber<T> o) throws Exception {, +    public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Subscriber<T>> generator, Consumer<? super S> disposeState) {, +            public S apply(S s, Subscriber<T> o) throws Exception {, +    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Subscriber<T>, S> generator) {, +    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Subscriber<T>, S> generator, Consumer<? super S> disposeState) {, +    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer) {, +    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {, +        return buffer(count, skip, ArrayListSupplier.<T>instance());, +    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {, +    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {, +        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>instance());, +        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>instance());, +    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier) {, +        return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>instance(), false);, +            Callable<U> bufferSupplier, , +        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>instance(), false);, +        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>instance());, +            Callable<U> bufferSupplier) {, +        return buffer(boundary, ArrayListSupplier.<T>instance());, +        return buffer(boundary, new Callable<List<T>>() {, +            public List<T> call() {, +    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundary, Callable<U> bufferSupplier) {, +    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundarySupplier) {, +        return buffer(boundarySupplier, ArrayListSupplier.<T>instance());, +    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundarySupplier, Callable<U> bufferSupplier) {, +    public final <U> Flowable<U> collect(Callable<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {, +        return collect(new Callable<U>() {, +            public U call() {, +            public Publisher<T> apply(final T v) throws Exception {, +    public final <U, V> Flowable<T> delay(Callable<? extends Publisher<U>> delaySupplier,, +    public final <U> Flowable<T> delaySubscription(final Callable<? extends Publisher<U>> delaySupplier) {, +        return fromCallable(delaySupplier)  , +        return distinct((Function)Functions.identity(), new Callable<Collection<T>>() {, +            public Collection<T> call() {, +        return distinct(keySelector, new Callable<Collection<K>>() {, +            public Collection<K> call() {, +    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector, Callable<? extends Collection<? super K>> collectionSupplier) {, +                    public void accept(T v) throws Exception {, +                    public void accept(Throwable e) throws Exception {, +                        // TODO introduce throwing Runnable?, +                        try {, +                        } catch (Throwable ex) {, +                            throw Exceptions.propagate(ex);, +                        }, +            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {, +            Callable<? extends Publisher<? extends R>> onCompleteSupplier, , +            public Publisher<R> apply(final T t) throws Exception {, +                    public R apply(U w) throws Exception {, +            public Publisher<U> apply(T t) throws Exception {, +            public Publisher<U> apply(T t) throws Exception {, +            public void accept(T v) throws Exception {, +    public final <R> Flowable<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {, +            public Publisher<?> apply(Flowable<Try<Optional<Object>>> no) throws Exception {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +            public Publisher<R> apply(Flowable<T> t) throws Exception {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +        return FlowableReplay.multicastSelector(new Callable<ConnectableFlowable<T>>() {, +            public ConnectableFlowable<T> call() {, +            public Publisher<R> apply(Flowable<T> t)  throws Exception {, +            public boolean test(Throwable e) throws Exception {]