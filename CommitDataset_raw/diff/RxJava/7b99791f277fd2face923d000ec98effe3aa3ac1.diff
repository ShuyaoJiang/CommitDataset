[+++ b/src/main/java/rx/internal/operators/OperatorScan.java, +++ b/src/main/java/rx/internal/operators/OperatorScan.java, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +        run.add(f);, +++ b/src/main/java/rx/internal/operators/OperatorScan.java, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +        run.add(f);, +++ b/src/main/java/rx/internal/schedulers/ScheduledAction.java, +import java.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +public final class ScheduledAction extends AtomicReference<Thread> implements Runnable, Subscription {, +    /** */, +    private static final long serialVersionUID = -3962399486978279857L;, +            lazySet(Thread.currentThread());, +        if (!cancel.isUnsubscribed()) {, +     * Adds a general Subscription to this {@code ScheduledAction} that will be unsubscribed, +     * if the underlying {@code action} completes or the this scheduled action is cancelled., +     * @param s the Subscription to add, +     * Adds the given Future to the unsubscription composite in order to support, +     * cancelling the underlying task in the executor framework., +     * @param f the future to add, +     */, +    public void add(final Future<?> f) {, +        cancel.add(new FutureCompleter(f));, +    }, +    , +    /**, +    /**, +     * Cancels the captured future if the caller of the call method, +     * is not the same as the runner of the outer ScheduledAction to, +     * prevent unnecessary self-interrupting if the unsubscription, +     * happens from the same thread., +     */, +    private final class FutureCompleter implements Subscription {, +        private final Future<?> f;, +, +        private FutureCompleter(Future<?> f) {, +            this.f = f;, +        }, +, +        @Override, +        public void unsubscribe() {, +            if (ScheduledAction.this.get() != Thread.currentThread()) {, +                f.cancel(true);, +            } else {, +                f.cancel(false);, +            }, +        }, +        @Override, +        public boolean isUnsubscribed() {, +            return f.isCancelled();, +        }, +    }, +, +    private static final class Remover extends AtomicBoolean implements Subscription {, +        /** */, +        private static final long serialVersionUID = 247232374289553518L;, +            if (compareAndSet(false, true)) {, +++ b/src/main/java/rx/internal/operators/OperatorScan.java, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +        run.add(f);, +++ b/src/main/java/rx/internal/schedulers/ScheduledAction.java, +import java.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +public final class ScheduledAction extends AtomicReference<Thread> implements Runnable, Subscription {, +    /** */, +    private static final long serialVersionUID = -3962399486978279857L;, +            lazySet(Thread.currentThread());, +        if (!cancel.isUnsubscribed()) {, +     * Adds a general Subscription to this {@code ScheduledAction} that will be unsubscribed, +     * if the underlying {@code action} completes or the this scheduled action is cancelled., +     * @param s the Subscription to add, +     * Adds the given Future to the unsubscription composite in order to support, +     * cancelling the underlying task in the executor framework., +     * @param f the future to add, +     */, +    public void add(final Future<?> f) {, +        cancel.add(new FutureCompleter(f));, +    }, +    , +    /**, +    /**, +     * Cancels the captured future if the caller of the call method, +     * is not the same as the runner of the outer ScheduledAction to, +     * prevent unnecessary self-interrupting if the unsubscription, +     * happens from the same thread., +     */, +    private final class FutureCompleter implements Subscription {, +        private final Future<?> f;, +, +        private FutureCompleter(Future<?> f) {, +            this.f = f;, +        }, +, +        @Override, +        public void unsubscribe() {, +            if (ScheduledAction.this.get() != Thread.currentThread()) {, +                f.cancel(true);]