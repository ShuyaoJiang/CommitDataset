[+++ b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.Reader;, +import rx.Observable.OnSubscribe;, +import rx.Subscriber;, +import rx.operators.Operator;, +    public static Observable<byte[]> from(final InputStream i) {, +        return from(i, 8 * 1024);, +    }, +, +    public static Observable<byte[]> from(final InputStream i, final int size) {, +        return Observable.create(new OnSubscribe<byte[]>() {, +            @Override, +            public void call(Subscriber<? super byte[]> o) {, +                byte[] buffer = new byte[size];, +                try {, +                    if (o.isUnsubscribed()), +                        return;, +                    int n = 0;, +                    n = i.read(buffer);, +                    while (n != -1 && !o.isUnsubscribed()) {, +                        o.onNext(Arrays.copyOf(buffer, n));, +                        n = i.read(buffer);, +                    }, +                } catch (IOException e) {, +                    o.onError(e);, +                }, +                if (o.isUnsubscribed()), +                    return;, +                o.onCompleted();, +            }, +        });, +    }, +, +    public static Observable<String> from(final Reader i) {, +        return from(i, 8 * 1024);, +    }, +, +    public static Observable<String> from(final Reader i, final int size) {, +        return Observable.create(new OnSubscribe<String>() {, +            @Override, +            public void call(Subscriber<? super String> o) {, +                char[] buffer = new char[size];, +                try {, +                    if (o.isUnsubscribed()), +                        return;, +                    int n = 0;, +                    n = i.read(buffer);, +                    while (n != -1 && !o.isUnsubscribed()) {, +                        o.onNext(new String(buffer));, +                        n = i.read(buffer);, +                    }, +                } catch (IOException e) {, +                    o.onError(e);, +                }, +                if (o.isUnsubscribed()), +                    return;, +                o.onCompleted();, +            }, +        });, +    }, +, +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams, +     * and where handles when a multibyte character spans two chunks., +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams, +     * and where handles when a multibyte character spans two chunks., +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams, +     * and where handles when a multibyte character spans two chunks., +        return src.lift(new Operator<String, byte[]>() {, +            public Subscriber<? super byte[]> call(final Subscriber<? super String> o) {, +                return new Subscriber<byte[]>(o) {, +                            o.onCompleted();, +                            o.onError(e);, +                                o.onError(e);, +                            o.onNext(string);, +                };, +     * Gather up all of the strings in to one string to be able to use it as one message. Don't use, +     * this on infinite streams., +        return src.reduce(new Func2<String, String, String>() {, +, +        return src.lift(new Operator<String, String>() {, +            public Subscriber<? super String> call(final Subscriber<? super String> o) {, +                return new Subscriber<String>(o) {, +                        if (!o.isUnsubscribed()), +                            o.onCompleted();, +                        if (!o.isUnsubscribed()), +                            o.onError(e);, +, +                     * , +                                if (!o.isUnsubscribed()), +                                    o.onNext("");, +                            if (!o.isUnsubscribed()), +                                o.onNext(part);, +                };, +            }, +, +     * , +     * Observable&lt;Object&gt; source = Observable.from(&quot;a&quot;, 1, &quot;c&quot;);, +     * Observable&lt;String&gt; result = join(source, &quot;, &quot;);]