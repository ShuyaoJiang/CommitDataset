[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis).take(14), +    val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x == 7)}), +    val sequenced = (grouped.map({ case (key, obs) => obs.toSeq })).flatten, +    sequenced.subscribe(x => println(s"Emitted group: $x")), +    println(doubleAverage(Observable.empty).toBlockingObservable.single), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis).take(14), +    val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x == 7)}), +    val sequenced = (grouped.map({ case (key, obs) => obs.toSeq })).flatten, +    sequenced.subscribe(x => println(s"Emitted group: $x")), +    println(doubleAverage(Observable.empty).toBlockingObservable.single), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]): Observable[Seq[T]] = {, +    val closing: Func1[_ >: Opening, _ <: rx.Observable[_ <: Any]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Opening, Any](opening, closing), +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Any](func), +  def window[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]) = {, +      asJavaObservable.window[Opening, Any](openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +  def groupByUntil[K](f: T => K, closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Any]] =, +    val o1 = asJavaObservable.groupByUntil[K, Any](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +   * Correlates the items emitted by two Observables based on overlapping durations., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/join_.png">, +   *, +   * @param other, +   *          the second Observable to join items from, +   * @param leftDurationSelector, +   *          a function to select a duration for each item emitted by the source Observable,, +   *          used to determine overlap, +   * @param rightDurationSelector, +   *         a function to select a duration for each item emitted by the inner Observable,, +   *         used to determine overlap, +   * @param resultSelector, +   *         a function that computes an item to be emitted by the resulting Observable for any, +   *         two overlapping items emitted by the two Observables, +   * @return, +   *         an Observable that emits items correlating to items emitted by the source Observables, +   *         that have overlapping durations, +   * @see <a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#join">RxJava Wiki: join()</a>, +   * @see <a href="http://msdn.microsoft.com/en-us/library/hh229750.aspx">MSDN: Observable.Join</a>, +   */, +  def join[S, R] (, +      other: Observable[S],, +      leftDurationSelector:  T => Observable[Any],, +      rightDurationSelector: S => Observable[Any],, +      resultSelector: (T,S) => R, +  ): Observable[R] = {, +, +    val outer : rx.Observable[_ <: T] = this.asJavaObservable, +    val inner : rx.Observable[_ <: S] = other.asJavaObservable, +    val left:  Func1[_ >: T, _<: rx.Observable[_ <: Any]] =   (t: T) => leftDurationSelector(t).asJavaObservable, +    val right: Func1[_ >: S, _<: rx.Observable[_ <: Any]] =  (s: S) => rightDurationSelector(s).asJavaObservable, +    val f: Func2[_>: T, _ >: S, _ <: R] = resultSelector, +, +    toScalaObservable[R](, +      outer.asInstanceOf[rx.Observable[T]].join[S, Any, Any, R](, +        inner.asInstanceOf[rx.Observable[S]],, +        left. asInstanceOf[Func1[T, rx.Observable[Any]]],, +        right.asInstanceOf[Func1[S, rx.Observable[Any]]],, +        f.asInstanceOf[Func2[T,S,R]]), +    ), +  }, +, +  /**, +  def empty: Observable[Nothing] = {, +    toScalaObservable(rx.Observable.empty[Nothing]()), +  def empty(scheduler: Scheduler): Observable[Nothing] = {, +    toScalaObservable(rx.Observable.empty[Nothing](scalaSchedulerToJavaScheduler(scheduler))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +    Observable.empty, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val numbers = Observable.interval(250 millis).take(14), +    val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x == 7)}), +    val sequenced = (grouped.map({ case (key, obs) => obs.toSeq })).flatten, +    sequenced.subscribe(x => println(s"Emitted group: $x")), +    println(doubleAverage(Observable.empty).toBlockingObservable.single), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]): Observable[Seq[T]] = {, +    val closing: Func1[_ >: Opening, _ <: rx.Observable[_ <: Any]] = (o: Opening) => closings(o).asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Opening, Any](opening, closing), +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Any](func), +  def window[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]) = {, +      asJavaObservable.window[Opening, Any](openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable)), +  def groupByUntil[K](f: T => K, closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Any]] =, +    val o1 = asJavaObservable.groupByUntil[K, Any](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +   * Correlates the items emitted by two Observables based on overlapping durations., +   * <p>]