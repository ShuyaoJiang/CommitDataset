[+++ b/rxjava-core/src/main/java/rx/Observable.java, +    , +    /**, +     * Compose Observables together with a function., +     * , +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +     */, +    public <R> Observable<R> compose(Transformer<T, R> transformer) {, +        return transformer.call(this);, +    }, +    , +    /**, +     * Transformer function for `compose`, +     */, +    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<R>> {, +        // cover for generics insanity, +    }, +    , +    , +, +     * Operators Below Here, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    , +    /**, +     * Compose Observables together with a function., +     * , +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +     */, +    public <R> Observable<R> compose(Transformer<T, R> transformer) {, +        return transformer.call(this);, +    }, +    , +    /**, +     * Transformer function for `compose`, +     */, +    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<R>> {, +        // cover for generics insanity, +    }, +    , +    , +, +     * Operators Below Here, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +public final class OperatorGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {, +    public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> child) {, +        return new GroupBySubscriber<K, T>(keySelector, child);, +    static final class GroupBySubscriber<K, T> extends Subscriber<T> {, +        final Subscriber<? super GroupedObservable<K, T>> child;, +        public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> child) {, +                    GroupedObservable<K, T> go = new GroupedObservable<K, T>(key, new OnSubscribe<T>() {, +                        public void call(final Subscriber<? super T> o) {, +                                    o.onNext(t);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    , +    /**, +     * Compose Observables together with a function., +     * , +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +     */, +    public <R> Observable<R> compose(Transformer<T, R> transformer) {, +        return transformer.call(this);, +    }, +    , +    /**, +     * Transformer function for `compose`, +     */, +    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<R>> {, +        // cover for generics insanity, +    }, +    , +    , +, +     * Operators Below Here, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +public final class OperatorGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {, +    public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> child) {, +        return new GroupBySubscriber<K, T>(keySelector, child);, +    static final class GroupBySubscriber<K, T> extends Subscriber<T> {, +        final Subscriber<? super GroupedObservable<K, T>> child;]