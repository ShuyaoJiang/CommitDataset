[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, +  implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, +  implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(rx.Notification.createOnNext[T](value)), +      Notification(rx.Notification.createOnError[T](error)), +      Notification(rx.Notification.createOnCompleted[T]()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, +  implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(rx.Notification.createOnNext[T](value)), +      Notification(rx.Notification.createOnError[T](error)), +      Notification(rx.Notification.createOnCompleted[T]()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import scala.concurrent.duration, +   * @param period, +  def interval(period: Duration, scheduler: Scheduler): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.interval(period.length, period.unit, scheduler)).map(_.longValue()), +  }, +, +  /**, +   * Return an Observable that emits a 0L after the {@code initialDelay} and ever increasing, +   * numbers after each {@code period} of time thereafter, on a specified Scheduler., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.ps.png">, +   *, +   * @param initialDelay, +   * the initial delay time to wait before emitting the first value of 0L, +   * @param period, +   * the period of time between emissions of the subsequent numbers, +   * @return an Observable that emits a 0L after the { @code initialDelay} and ever increasing, +   *                                                         numbers after each { @code period} of time thereafter, while running on the given { @code scheduler}, +   */, +  def timer(initialDelay: Duration, period: Duration): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.timer(initialDelay.toNanos, period.toNanos, duration.NANOSECONDS)).map(_.longValue()), +  /**, +   * Return an Observable that emits a 0L after the {@code initialDelay} and ever increasing, +   * numbers after each {@code period} of time thereafter, on a specified Scheduler., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.ps.png">, +   *, +   * @param initialDelay, +   * the initial delay time to wait before emitting the first value of 0L, +   * @param period, +   * the period of time between emissions of the subsequent numbers, +   * @param scheduler, +     * the scheduler on which the waiting happens and items are emitted, +   * @return an Observable that emits a 0L after the { @code initialDelay} and ever increasing, +   *                                                         numbers after each { @code period} of time thereafter, while running on the given { @code scheduler}, +   */, +  def timer(initialDelay: Duration, period: Duration, scheduler: Scheduler): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.timer(initialDelay.toNanos, period.toNanos, duration.NANOSECONDS, scheduler)).map(_.longValue()), +  }, +, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, +  implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +      Notification(rx.Notification.createOnNext[T](value)), +      Notification(rx.Notification.createOnError[T](error)), +      Notification(rx.Notification.createOnCompleted[T]()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import scala.concurrent.duration, +   * @param period, +  def interval(period: Duration, scheduler: Scheduler): Observable[Long] = {, +    toScalaObservable[java.lang.Long](rx.Observable.interval(period.length, period.unit, scheduler)).map(_.longValue()), +  }, +, +  /**, +   * Return an Observable that emits a 0L after the {@code initialDelay} and ever increasing, +   * numbers after each {@code period} of time thereafter, on a specified Scheduler., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.ps.png">]