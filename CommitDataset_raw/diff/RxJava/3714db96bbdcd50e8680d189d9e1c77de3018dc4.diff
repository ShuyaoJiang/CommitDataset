[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            interleave interpose into, +(declare concat* concat map* map map-indexed reduce take take-while), +(defn interleave*, +  "Returns an Observable of the first item in each Observable emitted by observables, then, +  the second etc., +, +  observables is an Observable of Observables, +, +  See:, +    interleave, +    clojure.core/interleave, +  ", +  [observables], +  (->> (map* #(seq->o %&) observables), +       (concat*))), +, +(defn interleave, +  "Returns an Observable of the first item in each Observable, then the second etc., +, +  Each argument is an individual Observable, +, +  See:, +    observable*, +    clojure.core/interleave, +  ", +  [o1 & observables], +  (->> (apply map #(seq->o %&) o1 observables), +       (concat*))), +, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            interleave interpose into, +(declare concat* concat map* map map-indexed reduce take take-while), +(defn interleave*, +  "Returns an Observable of the first item in each Observable emitted by observables, then, +  the second etc., +, +  observables is an Observable of Observables, +, +  See:, +    interleave, +    clojure.core/interleave, +  ", +  [observables], +  (->> (map* #(seq->o %&) observables), +       (concat*))), +, +(defn interleave, +  "Returns an Observable of the first item in each Observable, then the second etc., +, +  Each argument is an individual Observable, +, +  See:, +    observable*, +    clojure.core/interleave, +  ", +  [o1 & observables], +  (->> (apply map #(seq->o %&) o1 observables), +       (concat*))), +, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +                  (b/into []))))))), +, +(deftest test-interleave, +  (are [inputs] (= (apply interleave inputs), +                   (->> (apply rx/interleave (map rx/seq->o inputs)), +                        (b/into []))), +       [[] []], +       [[] [1]], +       [(range 5) (range 10) (range 10) (range 3)], +       [(range 50) (range 10)], +       [(range 5) (range 10 60) (range 10) (range 50)]), +, +  ; one-arg case, not supported by clojure.core/interleave, +  (is (= (range 10), +         (->> (rx/interleave (rx/seq->o (range 10))), +, +(deftest test-interleave*, +  (are [inputs] (= (apply interleave inputs), +                   (->> (rx/interleave* (->> inputs, +                                             (map rx/seq->o), +                                             (rx/seq->o))), +                        (b/into []))), +       [[] []], +       [[] [1]], +       [(range 5) (range 10) (range 10) (range 3)], +       [(range 50) (range 10)], +       [(range 5) (range 10 60) (range 10) (range 50)])), +]