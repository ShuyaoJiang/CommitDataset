[+++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, +        ConnectConsumer cc = new ConnectConsumer();, +        connect(cc);, +        return cc.disposable;, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, +        ConnectConsumer cc = new ConnectConsumer();, +        connect(cc);, +        return cc.disposable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java, +            if (timer.compareAndSet(d, de)) {, +        }, +, +                if (de != null) {, +                    de.run();, +                }, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, +        ConnectConsumer cc = new ConnectConsumer();, +        connect(cc);, +        return cc.disposable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java, +            if (timer.compareAndSet(d, de)) {, +        }, +, +                if (de != null) {, +                    de.run();, +                }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java, +            if (!cancelled) {, +        }, +                    } else {, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, +        ConnectConsumer cc = new ConnectConsumer();, +        connect(cc);, +        return cc.disposable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java, +            if (timer.compareAndSet(d, de)) {, +        }, +, +                if (de != null) {, +                    de.run();, +                }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java, +            if (!cancelled) {, +        }, +                    } else {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.observers.BasicIntQueueDisposable;, +    static final class ObserveOnObserver<T> extends BasicIntQueueDisposable<T>, +    implements Observer<T>, Runnable {, +        final int bufferSize;, +, +        SimpleQueue<T> queue;, +        int sourceMode;, +, +        boolean outputFused;, +, +            this.bufferSize = bufferSize;, +                if (s instanceof QueueDisposable) {, +                    @SuppressWarnings("unchecked"), +                    QueueDisposable<T> qd = (QueueDisposable<T>) s;, +, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +, +                    if (m == QueueDisposable.SYNC) {, +                        sourceMode = m;, +                        queue = qd;, +                        done = true;, +                        actual.onSubscribe(this);, +                        schedule();, +                        return;, +                    }, +                    if (m == QueueDisposable.ASYNC) {, +                        sourceMode = m;, +                        queue = qd;, +                        actual.onSubscribe(this);, +                        return;, +                    }, +                }, +, +                queue = new SpscLinkedArrayQueue<T>(bufferSize);, +, +            if (sourceMode != QueueDisposable.ASYNC) {, +                queue.offer(t);, +                if (getAndIncrement() == 0) {, +                    queue.clear();, +                }, +        void drainNormal() {, +            final SimpleQueue<T> q = queue;, +                    T v;]