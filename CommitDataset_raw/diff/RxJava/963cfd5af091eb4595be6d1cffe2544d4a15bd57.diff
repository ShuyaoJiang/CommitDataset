[+++ b/language-adaptors/rxjava-clojure/README.md, +* `group-by` val-fn variant isn't implemented in RxJava, +++ b/language-adaptors/rxjava-clojure/README.md, +* `group-by` val-fn variant isn't implemented in RxJava, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            group-by, +           [rx.observables, +            BlockingObservable, +            GroupedObservable], +(defn ^Observable group-by, +  "Returns an Observable of clojure.lang.MapEntry where the key is the result of, +  (key-fn x) and the val is an Observable of (val-fn x) for each key. If val-fn is, +  omitted, it defaults to identity., +, +  This returns a clojure.lang.MapEntry rather than rx.observables.GroupedObservable, +  for some vague consistency with clojure.core/group-by and so that clojure.core/key,, +  clojure.core/val and destructuring will work as expected., +, +  See:, +    clojure.core/group-by, +    rx.Observable/groupBy, +    rx.observables.GroupedObservable, +  ", +  ([key-fn ^Observable xs], +   (->> (.groupBy xs (iop/fn* key-fn)), +        (map (fn [^GroupedObservable go], +               (clojure.lang.MapEntry. (.getKey go) go))))), +  ([key-fn val-fn ^Observable xs], +   ; TODO reinstate once this is implemented, +   ; see https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a, +   (throw (UnsupportedOperationException. "groupBy with val-fn is currently unimplemented in RxJava")), +   (->> (.groupBy xs, +                  (iop/fn* key-fn), +                  (iop/fn* val-fn)), +        (map (fn [^GroupedObservable go], +               (clojure.lang.MapEntry. (.getKey go) go)))))), +++ b/language-adaptors/rxjava-clojure/README.md, +* `group-by` val-fn variant isn't implemented in RxJava, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            group-by, +           [rx.observables, +            BlockingObservable, +            GroupedObservable], +(defn ^Observable group-by, +  "Returns an Observable of clojure.lang.MapEntry where the key is the result of, +  (key-fn x) and the val is an Observable of (val-fn x) for each key. If val-fn is, +  omitted, it defaults to identity., +, +  This returns a clojure.lang.MapEntry rather than rx.observables.GroupedObservable, +  for some vague consistency with clojure.core/group-by and so that clojure.core/key,, +  clojure.core/val and destructuring will work as expected., +, +  See:, +    clojure.core/group-by, +    rx.Observable/groupBy, +    rx.observables.GroupedObservable, +  ", +  ([key-fn ^Observable xs], +   (->> (.groupBy xs (iop/fn* key-fn)), +        (map (fn [^GroupedObservable go], +               (clojure.lang.MapEntry. (.getKey go) go))))), +  ([key-fn val-fn ^Observable xs], +   ; TODO reinstate once this is implemented, +   ; see https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a, +   (throw (UnsupportedOperationException. "groupBy with val-fn is currently unimplemented in RxJava")), +   (->> (.groupBy xs, +                  (iop/fn* key-fn), +                  (iop/fn* val-fn)), +        (map (fn [^GroupedObservable go], +               (clojure.lang.MapEntry. (.getKey go) go)))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +(deftest test-group-by, +  (let [xs [{:k :a :v 1} {:k :b :v 2} {:k :a :v 3} {:k :c :v 4}]], +    (testing "with just a key-fn", +      (is (= [[:a {:k :a :v 1}], +              [:b {:k :b :v 2}], +              [:a {:k :a :v 3}], +              [:c {:k :c :v 4}]], +             (->> xs, +                  (rx/seq->o), +                  (rx/group-by :k), +                  (rx/mapcat (fn [[k vo :as me]], +                               (is (instance? clojure.lang.MapEntry me)), +                               (rx/map #(vector k %) vo))), +                  (b/into []))))), +, +    ; TODO reinstate once this is implemented, +    ; see https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a, +    #_(testing "with a val-fn", +      (is (= [[:a 1], +              [:b 2], +              [:a 3], +              [:c 4]], +             (->> xs, +                  (rx/seq->o), +                  (rx/group-by :k :v), +                  (rx/mapcat (fn [[k vo :as me]], +                               (is (instance? clojure.lang.MapEntry me)), +                               (rx/map #(vector k %) vo))), +                  (b/into [])))))]