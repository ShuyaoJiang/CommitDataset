[+++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +     * Returns an Observable that first emits items emitted by the source Observable, , +     * checks the specified condition after each item, and, +     * then completes as soon as this condition is not satisfied., +     * <p>, +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is evaluated <b>after</b>, +     * the item was emitted., +     * , +     * @param predicate , +     *            a function that evaluates an item emitted by the source Observable and returns a Boolean, +     * @return an Observable that first emits items emitted by the source Observable, , +     *         checks the specified condition after each item, and, +     *         then completes as soon as this condition is not satisfied., +     * @see Observable#takeWhile(Func1), +     */, +    @Experimental, +    public final Observable<T> doTakeWhile(final Func1<? super T, Boolean> predicate) {, +        return lift(new OperatorDoTakeWhile<T>(predicate));, +    }, +    , +    /**, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +     * Returns an Observable that first emits items emitted by the source Observable, , +     * checks the specified condition after each item, and, +     * then completes as soon as this condition is not satisfied., +     * <p>, +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is evaluated <b>after</b>, +     * the item was emitted., +     * , +     * @param predicate , +     *            a function that evaluates an item emitted by the source Observable and returns a Boolean, +     * @return an Observable that first emits items emitted by the source Observable, , +     *         checks the specified condition after each item, and, +     *         then completes as soon as this condition is not satisfied., +     * @see Observable#takeWhile(Func1), +     */, +    @Experimental, +    public final Observable<T> doTakeWhile(final Func1<? super T, Boolean> predicate) {, +        return lift(new OperatorDoTakeWhile<T>(predicate));, +    }, +    , +    /**, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/internal/operators/BlockingOperatorLatest.java, +                        unsubscribe();, +++ b/src/main/java/rx/Observable.java, +        return observables.lift(OperatorConcat.<T>instance());, +        return source.lift(OperatorMerge.<T>instance(false));, +        return source.lift(OperatorMerge.<T>instance(true));, +        return sequenceOfSequences.lift(OperatorSwitch.<T>instance());, +        return lift(OperatorAsObservable.<T>instance());, +    @SuppressWarnings({"unchecked"}), +        return lift(OperatorDematerialize.instance());, +        return lift(OperatorMaterialize.<T>instance());, +        return lift(OperatorOnBackpressureDrop.<T>instance());, +        return lift(OperatorSerialize.<T>instance());, +     * Returns an Observable that first emits items emitted by the source Observable, , +     * checks the specified condition after each item, and, +     * then completes as soon as this condition is not satisfied., +     * <p>, +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is evaluated <b>after</b>, +     * the item was emitted., +     * , +     * @param predicate , +     *            a function that evaluates an item emitted by the source Observable and returns a Boolean, +     * @return an Observable that first emits items emitted by the source Observable, , +     *         checks the specified condition after each item, and, +     *         then completes as soon as this condition is not satisfied., +     * @see Observable#takeWhile(Func1), +     */, +    @Experimental, +    public final Observable<T> doTakeWhile(final Func1<? super T, Boolean> predicate) {, +        return lift(new OperatorDoTakeWhile<T>(predicate));, +    }, +    , +    /**, +        return lift(OperatorToObservableList.<T>instance());, +++ b/src/main/java/rx/internal/operators/BlockingOperatorLatest.java, +                        unsubscribe();]