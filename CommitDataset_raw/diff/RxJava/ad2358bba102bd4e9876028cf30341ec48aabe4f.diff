[+++ b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java, +import java.util.Collection;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action1;, +, +        private final ConcurrentHashMap<K, GroupedSubject<K, V>> groupedObservables = new ConcurrentHashMap<K, GroupedSubject<K, V>>();, +            return source.subscribe(new Observer<KeyValue<K, V>>() {, +                    // we need to propagate to all children I imagine ... we can't just leave all of those Observable/Observers hanging, +                    for (GroupedSubject<K, V> o : groupedObservables.values()) {, +                        o.onCompleted();, +                    }, +                    // now the parent, +                    observer.onCompleted();, +                    // we need to propagate to all children I imagine ... we can't just leave all of those Observable/Observers hanging , +                    for (GroupedSubject<K, V> o : groupedObservables.values()) {, +                        o.onError(e);, +                    }, +                    // now the parent, +                    observer.onError(e);, +                public void onNext(KeyValue<K, V> value) {, +                    GroupedSubject<K, V> gs = groupedObservables.get(value.key);, +                    if (gs == null) {, +                        /*, +                         * Technically the source should be single-threaded so we shouldn't need to do this but I am, +                         * programming defensively as most operators are so this can work with a concurrent sequence, +                         * if it ends up receiving one., +                         */, +                        GroupedSubject<K, V> newGs = GroupedSubject.<K, V> create(value.key);, +                        GroupedSubject<K, V> existing = groupedObservables.putIfAbsent(value.key, newGs);, +                        if (existing == null) {, +                            // we won so use the one we created, +                            gs = newGs;, +                            // since we won the creation we emit this new GroupedObservable, +                            observer.onNext(gs);, +                        } else {, +                            // another thread beat us so use the existing one, +                            gs = existing;, +                    gs.onNext(value.value);, +        }, +    }, +, +    private static class GroupedSubject<K, T> extends GroupedObservable<K, T> implements Observer<T> {, +, +        static <K, T> GroupedSubject<K, T> create(K key) {, +            @SuppressWarnings("unchecked"), +            final AtomicReference<Observer<T>> subscribedObserver = new AtomicReference<Observer<T>>(EMPTY_OBSERVER);, +, +            return new GroupedSubject<K, T>(key, new Func1<Observer<T>, Subscription>() {, +                public Subscription call(Observer<T> observer) {, +                    // register Observer, +                    subscribedObserver.set(observer);, +, +                    return new Subscription() {, +, +                        @SuppressWarnings("unchecked"), +                        @Override, +                        public void unsubscribe() {, +                            // we remove the Observer so we stop emitting further events (they will be ignored if parent continues to send), +                            subscribedObserver.set(EMPTY_OBSERVER);, +                            // I don't believe we need to worry about the parent here as it's a separate sequence that would, +                            // be unsubscribed to directly if that needs to happen., +                        }, +                    };, +                }, +            }, subscribedObserver);, +        private final AtomicReference<Observer<T>> subscribedObserver;, +, +        public GroupedSubject(K key, Func1<Observer<T>, Subscription> onSubscribe, AtomicReference<Observer<T>> subscribedObserver) {, +            super(key, onSubscribe);, +            this.subscribedObserver = subscribedObserver;, +        @Override, +        public void onCompleted() {, +            subscribedObserver.get().onCompleted();, +        }, +, +        @Override, +        public void onError(Exception e) {, +            subscribedObserver.get().onError(e);, +        }, +, +        @Override, +        public void onNext(T v) {, +            subscribedObserver.get().onNext(v);, +        }, +, +    }, +, +    @SuppressWarnings("rawtypes"), +    private static Observer EMPTY_OBSERVER = new Observer() {, +, +        @Override, +        public void onCompleted() {, +            // do nothing            , +        }, +]