[+++ b/src/main/java/rx/observables/AbstractOnSubscribe.java, + * Abstract base class for the {@link OnSubscribe} interface that helps you build Observable sources one, + * {@code onNext} at a time, and automatically supports unsubscription and backpressure., + * When you implement the {@code next()} method, you, + *   <li>create the next value and signal it via {@link SubscriptionState#onNext state.onNext()},</li>, + *   <li>signal a terminal condition via {@link SubscriptionState#onError state.onError()}, or, + *       {@link SubscriptionState#onCompleted state.onCompleted()}, or</li>, + *   <li>signal a stop condition via {@link SubscriptionState#stop state.stop()} indicating no further values, + *       will be sent.</li>, + *   <li>call {@link SubscriptionState#onNext state.onNext()} and either, + *       {@link SubscriptionState#onError state.onError()} or, + *       {@link SubscriptionState#onCompleted state.onCompleted()} together, and, + *       the methods are called, an {@link IllegalStateException} is forwarded to the {@code Subscriber} and, + *   <li>call the {@code state.on}<i>foo</i>() methods more than once (yields, + *       {@link IllegalStateException}).</li>, + * The {@link SubscriptionState} object features counters that may help implement a state machine:, + * <li>A call counter, accessible via {@link SubscriptionState#calls state.calls()} tells how many times the, + *     {@code next()} was run (zero based).</li>, + * <li>You can use a phase counter, accessible via {@link SubscriptionState#phase state.phase}, that helps track, + *     the current emission phase, in a {@code switch()} statement to implement the state machine. (It is named, + *     {@code phase} to avoid confusion with the per-subscriber state.)</li>, + * <li>You can arbitrarily change the current phase with, + *     {@link SubscriptionState#advancePhase state.advancePhase()}, , + *     {@link SubscriptionState#advancePhaseBy(int) state.advancedPhaseBy(int)} and, + *     {@link SubscriptionState#phase(int) state.phase(int)}.</li>, + * When you implement {@code AbstractOnSubscribe}, you may override {@link AbstractOnSubscribe#onSubscribe} to, + * perform special actions (such as registering {@code Subscription}s with {@code Subscriber.add()}) and return, + * additional state for each subscriber subscribing. You can access this custom state with the, + * {@link SubscriptionState#state state.state()} method. If you need to do some cleanup, you can override the, + * {@link #onTerminated} method., + * For convenience, a lambda-accepting static factory method, {@link #create}, is available., + * Another convenience is {@link #toObservable} which turns an {@code AbstractOnSubscribe}, + * instance into an {@code Observable} fluently., + * Note: these examples use the lambda-helper factories to avoid boilerplane., + *, + *, + * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), + * @Experimental, +     * Called when a Subscriber subscribes and lets the implementor create a per-subscriber custom state., +     * Override this method to have custom state per-subscriber. The default implementation returns, +     * {@code null}., +     *, +, +     * This is called only once and no {@code onNext} call will run concurrently with it. The default, +     * implementation does nothing., +     *, +, +     * Override this method to create an emission state-machine., +     *, +     * @param state the per-subscriber subscription state, +     * Convenience method to create an Observable from this implemented instance., +     *, +     * Creates an {@code AbstractOnSubscribe} instance which calls the provided {@code next} action., +     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of, +     * lambdas., +     *, +     * @return an {@code AbstractOnSubscribe} instance, +, +     * Creates an {@code AbstractOnSubscribe} instance which creates a custom state with the {@code onSubscribe}, +     * function and calls the provided {@code next} action., +     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of, +     * lambdas., +     *, +     * @param onSubscribe the function that returns a per-subscriber state to be used by {@code next}, +     * @return an {@code AbstractOnSubscribe} instance, +, +     * Creates an {@code AbstractOnSubscribe} instance which creates a custom state with the {@code onSubscribe}, +     * function, calls the provided {@code next} action and calls the {@code onTerminated} action to release the, +     * state when its no longer needed., +     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of, +     * lambdas., +     *, +     * @param onSubscribe the function that returns a per-subscriber state to be used by {@code next}, +     * @param onTerminated the action to call to release the state created by the {@code onSubscribe} function, +     * @return an {@code AbstractOnSubscribe} instance, +, +     * An implementation that forwards the three main methods ({@code next}, {@code onSubscribe}, and, +     * {@code onTermianted}) to functional callbacks., +     *, +, +     *, +     *, +, +         *, +, +     * Represents a per-subscription state for the {@code AbstractOnSubscribe} operation. It supports phasing, +     * and counts the number of times a value was requested by the downstream., +     *, +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +     * @Experimental, +, +         * @return the per-subscriber specific user-defined state created via, +         *         {@link AbstractOnSubscribe#onSubscribe}, +, +, +         *, +, +, +         *, +]