[+++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.PriorityQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>();, +    private final AtomicInteger counter = new AtomicInteger(0);, +, +        enqueue(discardableAction, now());, +        long execTime = now() + unit.toMillis(dueTime);, +, +        DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime));, +        enqueue(discardableAction, execTime);, +        return discardableAction;, +    private void enqueue(DiscardableAction<?> action, long execTime) {, +        PriorityQueue<TimedAction> queue = QUEUE.get();, +            queue = new PriorityQueue<TimedAction>();, +        queue.add(new TimedAction(action, execTime, counter.incrementAndGet()));, +                queue.poll().action.call(this);, +    private static class TimedAction implements Comparable<TimedAction> {, +        final DiscardableAction<?> action;, +        final Long execTime;, +        final Integer count; // In case if time between enqueueing took less than 1ms, +, +        private TimedAction(DiscardableAction<?> action, Long execTime, Integer count) {, +            this.action = action;, +            this.execTime = execTime;, +            this.count = count;, +        }, +, +        @Override, +        public int compareTo(TimedAction that) {, +            int result = execTime.compareTo(that.execTime);, +            if (result == 0) {, +                return count.compareTo(that.count);, +            }, +            return result;, +        }, +    }, +, +        @Test, +        public void testSequenceOfDelayedActions() {, +            final CurrentThreadScheduler scheduler = new CurrentThreadScheduler();, +, +            final Action0 first = mock(Action0.class);, +            final Action0 second = mock(Action0.class);, +, +            scheduler.schedule(new Action0() {, +                @Override, +                public void call() {, +                    scheduler.schedule(first, 30, TimeUnit.MILLISECONDS);, +                    scheduler.schedule(second, 10, TimeUnit.MILLISECONDS);, +                }, +            });, +, +            InOrder inOrder = inOrder(first, second);, +, +            inOrder.verify(second, times(1)).call();, +            inOrder.verify(first, times(1)).call();, +, +, +        }, +, +        @Test, +        public void testMixOfDelayedAndNonDelayedActions() {, +            final CurrentThreadScheduler scheduler = new CurrentThreadScheduler();, +, +            final Action0 first = mock(Action0.class);, +            final Action0 second = mock(Action0.class);, +            final Action0 third = mock(Action0.class);, +            final Action0 fourth = mock(Action0.class);, +, +            scheduler.schedule(new Action0() {, +                @Override, +                public void call() {, +                    scheduler.schedule(first);, +                    scheduler.schedule(second, 300, TimeUnit.MILLISECONDS);, +                    scheduler.schedule(third, 100, TimeUnit.MILLISECONDS);, +                    scheduler.schedule(fourth);, +                }, +            });, +, +            InOrder inOrder = inOrder(first, second, third, fourth);, +, +            inOrder.verify(first, times(1)).call();, +            inOrder.verify(fourth, times(1)).call();, +            inOrder.verify(third, times(1)).call();, +            inOrder.verify(second, times(1)).call();, +, +, +        }, +, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.PriorityQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>();, +    private final AtomicInteger counter = new AtomicInteger(0);, +, +        enqueue(discardableAction, now());, +        long execTime = now() + unit.toMillis(dueTime);, +, +        DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime));]