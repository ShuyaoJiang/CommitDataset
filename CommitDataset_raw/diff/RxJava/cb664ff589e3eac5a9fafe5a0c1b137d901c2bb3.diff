[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +  def apply(): IOScheduler = {, +    new IOScheduler(rx.schedulers.Schedulers.computation()), +/**, + * Created by netflix on 2/5/14., + */, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +  def apply(): IOScheduler = {, +    new IOScheduler(rx.schedulers.Schedulers.computation()), +/**, + * Created by netflix on 2/5/14., + */, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorRepeat;, +     * Convert the current Observable<T> into an Observable<Observable<T>>., +     * , +     * @return, +     */, +    private final Observable<Observable<T>> nest() {, +        return from(this);, +    }, +    , +    /**, +        return nest().lift(new OperatorRepeat<T>());, +        return nest().lift(new OperatorRepeat<T>(scheduler));, +    }, +, +    /**, +     * Returns an Observable that repeats the sequence of items emitted by the source, +     * Observable at most count times., +     * , +     * @param count, +     *            the number of times the source Observable items are repeated,, +     *            a count of 0 will yield an empty sequence., +     * @return an Observable that repeats the sequence of items emitted by the source, +     *         Observable at most count times., +     */, +    public final Observable<T> repeat(long count) {, +        if (count < 0) {, +            throw new IllegalArgumentException("count >= 0 expected");, +        }, +        return nest().lift(new OperatorRepeat<T>(count));, +    }, +, +    /**, +     * Returns an Observable that repeats the sequence of items emitted by the source, +     * Observable at most count times on a particular scheduler., +     * , +     * @param count, +     *            the number of times the source Observable items are repeated,, +     *            a count of 0 will yield an empty sequence., +     * @param scheduler, +     *            the scheduler to emit the items on, +     * @return an Observable that repeats the sequence of items emitted by the source, +     *         Observable at most count times on a particular scheduler., +     */, +    public final Observable<T> repeat(long count, Scheduler scheduler) {, +        return nest().lift(new OperatorRepeat<T>(count, scheduler));, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, +  def apply(): IOScheduler = {, +    new IOScheduler(rx.schedulers.Schedulers.computation()), +/**, + * Created by netflix on 2/5/14., + */, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorRepeat;, +     * Convert the current Observable<T> into an Observable<Observable<T>>., +     * , +     * @return, +     */, +    private final Observable<Observable<T>> nest() {, +        return from(this);, +    }, +    , +    /**, +        return nest().lift(new OperatorRepeat<T>());, +        return nest().lift(new OperatorRepeat<T>(scheduler));, +    }, +, +    /**, +     * Returns an Observable that repeats the sequence of items emitted by the source, +     * Observable at most count times., +     * , +     * @param count, +     *            the number of times the source Observable items are repeated,, +     *            a count of 0 will yield an empty sequence., +     * @return an Observable that repeats the sequence of items emitted by the source, +     *         Observable at most count times., +     */, +    public final Observable<T> repeat(long count) {, +        if (count < 0) {, +            throw new IllegalArgumentException("count >= 0 expected");, +        }, +        return nest().lift(new OperatorRepeat<T>(count));, +    }, +, +    /**, +     * Returns an Observable that repeats the sequence of items emitted by the source, +     * Observable at most count times on a particular scheduler., +     * ]