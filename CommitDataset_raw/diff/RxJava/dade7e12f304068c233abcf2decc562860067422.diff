[+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java, +        class OldAndRelative {, +            public final Point old;, +            public final Point relative;, +, +            private OldAndRelative(Point old, Point relative) {, +                this.old = old;, +                this.relative = relative;, +        }, +        , +        class Relativize implements Func2<OldAndRelative, MouseEvent, OldAndRelative> {, +            @Override, +            public OldAndRelative call(OldAndRelative last, MouseEvent event) {, +                Point current = new Point(event.getX(), event.getY());, +                Point relative = new Point(current.x - last.old.x, current.y - last.old.y);, +                return new OldAndRelative(current, relative);, +            }, +        }, +        , +        class OnlyRelative implements Func1<OldAndRelative, Point> {, +            @Override, +            public Point call(OldAndRelative oar) {, +                return oar.relative;, +            }, +        }, +        , +        return fromMouseMotionEventsOf(component), +                    .scan(new OldAndRelative(new Point(0, 0), new Point(0, 0)), new Relativize()), +                    .map(new OnlyRelative()), +                    .skip(2); // skip the useless initial value and the invalid first computation, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java, +        class OldAndRelative {, +            public final Point old;, +            public final Point relative;, +, +            private OldAndRelative(Point old, Point relative) {, +                this.old = old;, +                this.relative = relative;, +        }, +        , +        class Relativize implements Func2<OldAndRelative, MouseEvent, OldAndRelative> {, +            @Override, +            public OldAndRelative call(OldAndRelative last, MouseEvent event) {, +                Point current = new Point(event.getX(), event.getY());, +                Point relative = new Point(current.x - last.old.x, current.y - last.old.y);, +                return new OldAndRelative(current, relative);, +            }, +        }, +        , +        class OnlyRelative implements Func1<OldAndRelative, Point> {, +            @Override, +            public Point call(OldAndRelative oar) {, +                return oar.relative;, +            }, +        }, +        , +        return fromMouseMotionEventsOf(component), +                    .scan(new OldAndRelative(new Point(0, 0), new Point(0, 0)), new Relativize()), +                    .map(new OnlyRelative()), +                    .skip(2); // skip the useless initial value and the invalid first computation, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @see #subscribeOn(rx.Scheduler, int) , +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, false));, +    }, +    /**, +     * Asynchronously subscribes and unsubscribes Observers to this Observable on the specified {@link Scheduler}, +     * and allows buffering some events emitted from the source in the time gap between the original and, +     * actual subscription, and any excess events will block the source until the actual subscription happens., +     * <p>, +     * This overload should help mitigate issues when subscribing to a PublishSubject (and derivatives, +     * such as GroupedObservable in operator groupBy) and events fired between the original and actual subscriptions, +     * are lost. , +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/subscribeOn.png">, +     * , +     * @param scheduler, +     *            the {@link Scheduler} to perform subscription and unsubscription actions on, +     * @param bufferSize the number of events to buffer before blocking the source while in the time gap,, +     *                   negative value indicates an unlimited buffer, +     * @return the source Observable modified so that its subscriptions and unsubscriptions happen, +     *         on the specified {@link Scheduler}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-subscribeon">RxJava Wiki: subscribeOn()</a>, +     */, +    public final Observable<T> subscribeOn(Scheduler scheduler, int bufferSize) {, +        return nest().lift(new OperatorSubscribeOn<T>(scheduler, true, bufferSize));, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java, +        class OldAndRelative {, +            public final Point old;, +            public final Point relative;, +, +            private OldAndRelative(Point old, Point relative) {, +                this.old = old;, +                this.relative = relative;, +        }, +        , +        class Relativize implements Func2<OldAndRelative, MouseEvent, OldAndRelative> {, +            @Override, +            public OldAndRelative call(OldAndRelative last, MouseEvent event) {, +                Point current = new Point(event.getX(), event.getY());, +                Point relative = new Point(current.x - last.old.x, current.y - last.old.y);]