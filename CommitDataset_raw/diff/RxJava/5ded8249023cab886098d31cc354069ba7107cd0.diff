[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, +    configurations.add('sources'), +    configurations.add('javadoc'), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, +    configurations.add('sources'), +    configurations.add('javadoc'), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, +    configurations.add('sources'), +    configurations.add('javadoc'), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.util.BufferClosing;, +import rx.util.BufferOpening;, + * It provides overloaded methods for subscribing as well as delegate methods to the various operators., + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +    protected Observable() {, +        this(null);, +    }, +, +     * Construct an Observable with Function to execute when subscribed to., +     * NOTE: Generally you're better off using {@link #create(Func1)} to create an Observable instead of using inheritance., +     * an {@link Observer} must call an Observable's <code>subscribe</code> method in order to register itself, +     * to receive push-based notifications from the Observable. A typical implementation of the, +     * <code>subscribe</code> method does the following:, +     * It stores a reference to the Observer in a collection object, such as a <code>List<T></code>, +     * object., +     * It returns a reference to the {@link Subscription} interface. This enables, +     * Observers to unsubscribe (that is, to stop receiving notifications) before the Observable has, +     * finished sending them and has called the Observer's {@link Observer#onCompleted()} method., +     * At any given time, a particular instance of an <code>Observable<T></code> implementation is, +     * responsible for accepting all subscriptions and notifying all subscribers. Unless the, +     * documentation for a particular <code>Observable<T></code> implementation indicates otherwise,, +     * Observers should make no assumptions about the <code>Observable<T></code> implementation, such, +     * as the order of notifications that multiple Observers will receive., +     * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * , +     * @return a {@link Subscription} reference that allows observers, +     *         to stop receiving notifications before the provider has finished sending them, +     * an {@link Observer} must call an Observable's <code>subscribe</code> method in order to register itself, +     * to receive push-based notifications from the Observable. A typical implementation of the, +     * It stores a reference to the Observer in a collection object, such as a <code>List<T></code>, +     * object., +     * It returns a reference to the {@link Subscription} interface. This enables, +     * Observers to unsubscribe (that is, to stop receiving notifications) before the Observable has, +     * finished sending them and has called the Observer's {@link Observer#onCompleted()} method., +     * At any given time, a particular instance of an <code>Observable<T></code> implementation is, +     * responsible for accepting all subscriptions and notifying all subscribers. Unless the, +     * documentation for a particular <code>Observable<T></code> implementation indicates otherwise,, +     * Observers should make no assumptions about the <code>Observable<T></code> implementation, such, +     * as the order of notifications that multiple Observers will receive., +     * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * , +     *            The {@link Scheduler} that the sequence is subscribed to on., +     * @return a {@link Subscription} reference that allows observers, +     *         to stop receiving notifications before the provider has finished sending them, +        // lookup and memoize onNext, +            throw new RuntimeException("onNext must be implemented");, +        if (o == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                // no callback defined, +                // no callback defined, +                if (onNext == null) {, +                    throw new RuntimeException("onNext must be implemented");, +                }, +        if (onNext == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                if (onError != null) {, +            }, +                if (onError != null) {, +            }, +                if (onNext == null) {, +                    throw new RuntimeException("onNext must be implemented");, +                }, +        if (onNext == null) {, +            throw new RuntimeException("onNext must be implemented");, +        }, +                if (onComplete != null) {, +            }, +                if (onError != null) {, +            }, +                if (onError != null) {, +            }, +                if (onNext == null) {]