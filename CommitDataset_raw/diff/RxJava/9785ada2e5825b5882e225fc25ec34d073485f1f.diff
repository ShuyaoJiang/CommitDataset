[+++ b/rxjava-core/src/main/java/rx/observers/TestObserver.java, +                throw new AssertionError("Value at index: " + i + " expected to be [" + items.get(i) + "] (" + items.get(i).getClass().getSimpleName() + ") but was: [" + onNextEvents.get(i) + "] (" + onNextEvents.get(i).getClass().getSimpleName() + ")");, +, +++ b/rxjava-core/src/main/java/rx/observers/TestObserver.java, +                throw new AssertionError("Value at index: " + i + " expected to be [" + items.get(i) + "] (" + items.get(i).getClass().getSimpleName() + ") but was: [" + onNextEvents.get(i) + "] (" + onNextEvents.get(i).getClass().getSimpleName() + ")");, +, +++ b/rxjava-core/src/main/java/rx/schedulers/TestScheduler.java, +    public Inner createInnerScheduler() {, +        return new InnerTestScheduler();, +    }, +, +        Inner inner = createInnerScheduler();, +        Inner inner = createInnerScheduler();, +++ b/rxjava-core/src/main/java/rx/observers/TestObserver.java, +                throw new AssertionError("Value at index: " + i + " expected to be [" + items.get(i) + "] (" + items.get(i).getClass().getSimpleName() + ") but was: [" + onNextEvents.get(i) + "] (" + onNextEvents.get(i).getClass().getSimpleName() + ")");, +, +++ b/rxjava-core/src/main/java/rx/schedulers/TestScheduler.java, +    public Inner createInnerScheduler() {, +        return new InnerTestScheduler();, +    }, +, +        Inner inner = createInnerScheduler();, +        Inner inner = createInnerScheduler();, +++ b/rxjava-core/src/main/java/rx/subjects/TestSubject.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.subjects;, +, +import java.util.Collection;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +, +import rx.Notification;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Scheduler.Inner;, +import rx.functions.Action1;, +import rx.schedulers.TestScheduler;, +import rx.subjects.SubjectSubscriptionManager.SubjectObserver;, +, +/**, + * Subject that, once and {@link Observer} has subscribed, publishes all subsequent events to the subscriber., + * <p>, + * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png">, + * <p>, + * Example usage:, + * <p>, + * <pre> {@code, +, + * PublishSubject<Object> subject = PublishSubject.create();, +  // observer1 will receive all onNext and onCompleted events, +  subject.subscribe(observer1);, +  subject.onNext("one");, +  subject.onNext("two");, +  // observer2 will only receive "three" and onCompleted, +  subject.subscribe(observer2);, +  subject.onNext("three");, +  subject.onCompleted();, +, +  } </pre>, + * , + * @param <T>, + */, +public final class TestSubject<T> extends Subject<T, T> {, +, +    public static <T> TestSubject<T> create(TestScheduler scheduler) {, +        final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();, +        // set a default value so subscriptions will immediately receive this until a new notification is received, +        final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>();, +, +        OnSubscribe<T> onSubscribe = subscriptionManager.getOnSubscribeFunc(, +                /**, +                 * This function executes at beginning of subscription., +                 * , +                 * This will always run, even if Subject is in terminal state., +                 */, +                new Action1<SubjectObserver<? super T>>() {, +, +                    @Override, +                    public void call(SubjectObserver<? super T> o) {, +                        // nothing onSubscribe unless in terminal state which is the next function, +                    }, +                },, +                /**, +                 * This function executes if the Subject is terminated before subscription occurs., +                 */, +                new Action1<SubjectObserver<? super T>>() {]