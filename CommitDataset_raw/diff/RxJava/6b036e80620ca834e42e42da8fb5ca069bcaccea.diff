[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFirstOrDefault;, +import rx.operators.OperationLast;, +     * source Observable., +     * @return an Observable that emits only the very first item emitted by the, +     *         source Observable, or nothing if the source Observable completes, +     *         without emitting a single item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return take(1);, +     * source Observable that satisfies a given condition., +     *         given condition from the source, or nothing if the source, +     *         Observable completes without emitting a single matching item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return skipWhile(not(predicate)).take(1);, +        return create(OperationFirstOrDefault.firstOrDefault(this, defaultValue));, +    public Observable<T> firstOrDefault(Func1<? super T, Boolean> predicate, T defaultValue) {, +        return create(OperationFirstOrDefault.firstOrDefault(this, predicate, defaultValue));, +     *         source, or none if the source Observable completes without, +     * @see #first(), +        return first();, +     *         given condition from the source, or none if the source Observable, +     * @see #first(Func1), +        return first(predicate);, +        return create(OperationLast.last(this));, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +    @Test(expected = IllegalStateException.class), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +    [Test(expected = javaClass<IllegalStateException>())], +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFirstOrDefault;, +import rx.operators.OperationLast;, +     * source Observable., +     * @return an Observable that emits only the very first item emitted by the, +     *         source Observable, or nothing if the source Observable completes, +     *         without emitting a single item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return take(1);, +     * source Observable that satisfies a given condition., +     *         given condition from the source, or nothing if the source, +     *         Observable completes without emitting a single matching item, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229177.aspx">MSDN: Observable.First</a>, +        return skipWhile(not(predicate)).take(1);, +        return create(OperationFirstOrDefault.firstOrDefault(this, defaultValue));, +    public Observable<T> firstOrDefault(Func1<? super T, Boolean> predicate, T defaultValue) {, +        return create(OperationFirstOrDefault.firstOrDefault(this, predicate, defaultValue));, +     *         source, or none if the source Observable completes without, +     * @see #first(), +        return first();, +     *         given condition from the source, or none if the source Observable, +     * @see #first(Func1), +        return first(predicate);, +        return create(OperationLast.last(this));, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +    private static <T> T _singleOrDefault(BlockingObservable<? extends T> source, boolean hasDefault, T defaultValue) {, +        Iterator<? extends T> it = source.toIterable().iterator();, +, +        if (!it.hasNext()) {, +            if (hasDefault) {, +                return defaultValue;, +            }, +            throw new IllegalStateException("Expected single entry. Actually empty stream.");, +        }, +, +        T result = it.next();, +, +        if (it.hasNext()) {, +            throw new IllegalStateException("Expected single entry. Actually more than one entry.");, +        }, +, +        return result;, +    }, +, +     * Returns the last item emitted by a specified {@link Observable}., +        return new BlockingObservable<T>(o.last()).single();, +     * Returns the last item emitted by a specified {@link Observable} that matches a predicate., +        return from(o.filter(predicate)).last();, +        boolean found = false;, +        T result = null;, +, +        for (T value : toIterable()) {, +            found = true;, +            result = value;, +        }, +, +        if (!found) {, +            return defaultValue;, +        }, +, +        return result;, +     * otherwise throw an exception.]