[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    // Issue: https://github.com/Netflix/RxJava/pull/1527, +                    // Because we cache a value and don't emit now, we need to request another one., +                    request(1);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    // Issue: https://github.com/Netflix/RxJava/pull/1527, +                    // Because we cache a value and don't emit now, we need to request another one., +                    request(1);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +            if (requested == Long.MAX_VALUE) {, +                return;, +            }, +            long _c;, +                _c = REQUESTED_UPDATER.getAndSet(this, Long.MAX_VALUE);, +            if (requested == Long.MAX_VALUE) {, +                if (previousRequested == 0) {, +                    // backpressure path will handle Long.MAX_VALUE and emit the rest events., +                }, +            } else {, +                        for (;;) {, +                            long oldRequested = requested;, +                            long newRequested = oldRequested - emitted;, +                            if (oldRequested == Long.MAX_VALUE) {, +                                // became unbounded during the loop, +                                // continue the outer loop to emit the rest events., +                                break;, +                            }, +                            if (REQUESTED_UPDATER.compareAndSet(this, oldRequested, newRequested)) {, +                                if (newRequested == 0) {, +                                break;, +                            }, +                        }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    // Issue: https://github.com/Netflix/RxJava/pull/1527, +                    // Because we cache a value and don't emit now, we need to request another one., +                    request(1);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +            if (requested == Long.MAX_VALUE) {, +                return;, +            }, +            long _c;, +                _c = REQUESTED_UPDATER.getAndSet(this, Long.MAX_VALUE);, +            if (requested == Long.MAX_VALUE) {, +                if (previousRequested == 0) {, +                    // backpressure path will handle Long.MAX_VALUE and emit the rest events., +                }, +            } else {, +                        for (;;) {, +                            long oldRequested = requested;, +                            long newRequested = oldRequested - emitted;, +                            if (oldRequested == Long.MAX_VALUE) {, +                                // became unbounded during the loop, +                                // continue the outer loop to emit the rest events., +                                break;, +                            }, +                            if (REQUESTED_UPDATER.compareAndSet(this, oldRequested, newRequested)) {, +                                if (newRequested == 0) {, +                                break;, +                            }, +                        }, +++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.*;, +import rx.Subscriber;, +import rx.functions.Func2;, +, +    @Test, +    public void testSingleWithBackpressure() {, +        Observable<Integer> observable = Observable.from(1, 2).single();, +, +        Subscriber<Integer> subscriber = spy(new Subscriber<Integer>() {, +, +            @Override, +            public void onStart() {, +                request(1);, +            }, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +, +            }, +, +            @Override, +            public void onNext(Integer integer) {, +                request(1);, +            }, +        });, +        observable.subscribe(subscriber);, +, +        InOrder inOrder = inOrder(subscriber);, +        inOrder.verify(subscriber, times(1)).onError(isA(IllegalArgumentException.class));, +        inOrder.verifyNoMoreInteractions();, +    }, +, +    @Test(timeout = 30000)]