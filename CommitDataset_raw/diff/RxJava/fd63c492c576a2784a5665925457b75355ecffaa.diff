[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +        final AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();, +                    SubscriptionHelper.cancel(upstream);, +            if (SubscriptionHelper.setOnce(this.upstream, s)) {, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +                            upstream.get().cancel();, +                            upstream.get().request(1);, +                            upstream.get().cancel();, +                            upstream.get().request(d);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +        final AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();, +                    SubscriptionHelper.cancel(upstream);, +            if (SubscriptionHelper.setOnce(this.upstream, s)) {, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +                            upstream.get().cancel();, +                            upstream.get().request(1);, +                            upstream.get().cancel();, +                            upstream.get().request(d);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java, +import java.util.concurrent.TimeUnit;, +import org.junit.Test;, +import org.reactivestreams.Publisher;, +, +import io.reactivex.*;, +import io.reactivex.exceptions.TestException;, +import io.reactivex.functions.Function;, +import io.reactivex.schedulers.Schedulers;, +    @Test, +    public void boundaryFusion() {, +        Flowable.range(1, 10000), +        .observeOn(Schedulers.single()), +        .map(new Function<Integer, String>() {, +            @Override, +            public String apply(Integer t) throws Exception {, +                String name = Thread.currentThread().getName();, +                if (name.contains("RxSingleScheduler")) {, +                    return "RxSingleScheduler";, +                }, +                return name;, +            }, +        }), +        .concatMap(new Function<String, Publisher<? extends Object>>() {, +            @Override, +            public Publisher<? extends Object> apply(String v), +                    throws Exception {, +                return Flowable.just(v);, +            }, +        }), +        .observeOn(Schedulers.computation()), +        .distinct(), +        .test(), +        .awaitDone(5, TimeUnit.SECONDS), +        .assertResult("RxSingleScheduler");, +    }, +, +    @Test, +    public void boundaryFusionDelayError() {, +        Flowable.range(1, 10000), +        .observeOn(Schedulers.single()), +        .map(new Function<Integer, String>() {, +            @Override, +            public String apply(Integer t) throws Exception {, +                String name = Thread.currentThread().getName();, +                if (name.contains("RxSingleScheduler")) {, +                    return "RxSingleScheduler";, +                }, +                return name;, +            }, +        }), +        .concatMapDelayError(new Function<String, Publisher<? extends Object>>() {, +            @Override, +            public Publisher<? extends Object> apply(String v), +                    throws Exception {, +                return Flowable.just(v);, +            }, +        }), +        .observeOn(Schedulers.computation()), +        .distinct(), +        .test(), +        .awaitDone(5, TimeUnit.SECONDS), +        .assertResult("RxSingleScheduler");, +    }, +, +    @Test, +    public void pollThrows() {, +        Flowable.just(1), +        .map(new Function<Integer, Integer>() {, +            @Override, +            public Integer apply(Integer v) throws Exception {, +                throw new TestException();, +            }, +        }), +        .compose(TestHelper.<Integer>flowableStripBoundary()), +        .concatMap(new Function<Integer, Publisher<Integer>>() {]