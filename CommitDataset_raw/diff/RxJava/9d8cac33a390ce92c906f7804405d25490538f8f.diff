[+++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java, +            // using SynchronizedQueue until issues are solved with SpscArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpscArrayQueue , +            //            return new RxRingBuffer(SPSC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpscArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +            // using SynchronizedQueue until issues are solved with SpmcArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpmcArrayQueue/MpmcArrayQueue, +            //            return new RxRingBuffer(SPMC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpmcArrayQueue<Object>(SIZE), SIZE);, +            //            return new RxRingBuffer(new MpmcArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +     * With SynchronizedQueue (synchronized LinkedList ... no object pooling), +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 27630345.474   769219.142    ops/s, +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    80052.046     4059.541    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 44449524.222   563068.793    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    65231.253     1805.732    ops/s, +     * When UnsafeAccess.isUnsafeAvailable() == true we can use the Spmc/SpscArrayQueue implementations., +    @SuppressWarnings("unused"), +    /* package accessible for unit tests */RxRingBuffer() {, +++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java, +            // using SynchronizedQueue until issues are solved with SpscArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpscArrayQueue , +            //            return new RxRingBuffer(SPSC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpscArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +            // using SynchronizedQueue until issues are solved with SpmcArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpmcArrayQueue/MpmcArrayQueue, +            //            return new RxRingBuffer(SPMC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpmcArrayQueue<Object>(SIZE), SIZE);, +            //            return new RxRingBuffer(new MpmcArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +     * With SynchronizedQueue (synchronized LinkedList ... no object pooling), +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 27630345.474   769219.142    ops/s, +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    80052.046     4059.541    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 44449524.222   563068.793    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    65231.253     1805.732    ops/s, +     * When UnsafeAccess.isUnsafeAvailable() == true we can use the Spmc/SpscArrayQueue implementations., +    @SuppressWarnings("unused"), +    /* package accessible for unit tests */RxRingBuffer() {, +++ b/rxjava-core/src/main/java/rx/internal/util/unsafe/README.md, +Once JCTools publishes artifacts (https://github.com/JCTools/JCTools/issues/17) RxJava may add JCTools as a "shadow" dependency. , +RxJava has a "zero dependency" policy for the core library, so if we do add it as a dependency, it won't be an externally visible dependency that results in a separate jar., +The license for the JCTools code is https://github.com/JCTools/JCTools/blob/master/LICENSE, +++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java, +            // using SynchronizedQueue until issues are solved with SpscArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpscArrayQueue , +            //            return new RxRingBuffer(SPSC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpscArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +            // using SynchronizedQueue until issues are solved with SpmcArrayQueue offer rejection, +            //      RxRingBufferSpmcTest.testConcurrency occasionally fails with a , +            //      BackpressureException when using SpmcArrayQueue/MpmcArrayQueue, +            //            return new RxRingBuffer(SPMC_POOL, SIZE); // this is the one we were trying to use, +            //            return new RxRingBuffer(new SpmcArrayQueue<Object>(SIZE), SIZE);, +            //            return new RxRingBuffer(new MpmcArrayQueue<Object>(SIZE), SIZE);, +            // the performance of this is sufficient (actually faster in some cases), +            return new RxRingBuffer(new SynchronizedQueue<Object>(SIZE), SIZE);, +     * With SynchronizedQueue (synchronized LinkedList ... no object pooling), +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 27630345.474   769219.142    ops/s, +     * r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    80052.046     4059.541    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 44449524.222   563068.793    ops/s, +     * r.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    65231.253     1805.732    ops/s, +     * When UnsafeAccess.isUnsafeAvailable() == true we can use the Spmc/SpscArrayQueue implementations., +    @SuppressWarnings("unused"), +    /* package accessible for unit tests */RxRingBuffer() {, +++ b/rxjava-core/src/main/java/rx/internal/util/unsafe/README.md, +Once JCTools publishes artifacts (https://github.com/JCTools/JCTools/issues/17) RxJava may add JCTools as a "shadow" dependency. , +RxJava has a "zero dependency" policy for the core library, so if we do add it as a dependency, it won't be an externally visible dependency that results in a separate jar., +The license for the JCTools code is https://github.com/JCTools/JCTools/blob/master/LICENSE, +++ b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferSpmcTest.java, +    @Test, +        final CountDownLatch emitLatch = new CountDownLatch(255);, +        final CountDownLatch drainLatch = new CountDownLatch(2);, +                //                System.out.println("request[" + c.incrementAndGet() + "]: " + n + "  Thread: " + Thread.currentThread());, +                        if (emitLatch.getCount() == 0) {, +                                emit.incrementAndGet();, +                        emitLatch.countDown();, +        Action0 drainer = new Action0() {, +                int shutdownCount = 0;, +                            if (emitLatch.getCount() == 0) {, +                                shutdownCount++;, +                                // hack to handle the non-blocking queues, +                                // which can have a race condition between offer and poll, +                                // so poll can return null and then have a value the next loop around, +                                // ... even after emitLatch.getCount() == 0 ... no idea why., +                                if (shutdownCount > 5) {, +                                    drainLatch.countDown();, +                                    return;, +                                }]