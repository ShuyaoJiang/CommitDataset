[+++ b/build.gradle, +apply plugin: "eclipse", +def guavaVersion = "24.0-jre", +    testImplementation "com.google.guava:guava:$guavaVersion", +++ b/build.gradle, +apply plugin: "eclipse", +def guavaVersion = "24.0-jre", +    testImplementation "com.google.guava:guava:$guavaVersion", +++ b/src/main/java/io/reactivex/Flowable.java, +        return RxJavaPlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError, null));, +    }, +, +    /**, +     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these, +     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedFlowable} allows only a single, +     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the, +     * source terminates, the next emission by the source having the same key will trigger a new, +     * {@code GroupedPublisher} emission. The {@code evictingMapFactory} is used to create a map that will, +     * be used to hold the {@link GroupedFlowable}s by key. The evicting map created by this factory must , +     * notify the provided {@code Consumer<Object>} with the entry value (not the key!) when an entry in this, +     * map has been evicted. The next source emission will bring about the  completion of the evicted, +     * {@link GroupedFlowable}s and the arrival of an item with the same key as a completed {@link GroupedFlowable}, +     * will prompt the creation and emission of a new {@link GroupedFlowable} with that key., +     * , +     * <p>A use case for specifying an {@code evictingMapFactory} is where the source is infinite and fast and, +     * over time the number of keys grows enough to be a concern in terms of the memory footprint of the , +     * internal hash map containing the {@link GroupedFlowable}s., +     * , +     * <p>The map created by an {@code evictingMapFactory} must be thread-safe., +     * , +     * <p>An example of an {@code evictingMapFactory} using <a href="https://google.github.io/guava/releases/24.0-jre/api/docs/com/google/common/cache/CacheBuilder.html">CacheBuilder</a> from the Guava library is below:, +     * , +     * <pre>, +     * Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory = , +     *   notify -&gt;, +     *       CacheBuilder, +     *         .newBuilder() , +     *         .maximumSize(3), +     *         .removalListener(entry -&gt; {, +     *              try {, +     *                  // emit the value not the key!, +     *                  notify.accept(entry.getValue());, +     *              } catch (Exception e) {, +     *                  throw new RuntimeException(e);, +     *              }, +     *            }), +     *         .&lt;Integer, Object&gt; build(), +     *         .asMap();, +     *, +     * // Emit 1000 items but ensure that the, +     * // internal map never has more than 3 items in it           , +     * Flowable, +     *   .range(1, 1000), +     *   // note that number of keys is 10, +     *   .groupBy(x -&gt; x % 10, x -&gt; x, true, 16, evictingMapFactory), +     *   .flatMap(g -&gt; g), +     *   .forEach(System.out::println);, +     * </pre>, +     * , +     * <p>, +     * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png" alt="">, +     * <p>, +     * <em>Note:</em> A {@link GroupedFlowable} will cache the items it is to emit until such time as it, +     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, +     * {@code GroupedFlowable}s that do not concern you. Instead, you can signal to them that they may, +     * discard their buffers by applying an operator like {@link #ignoreElements} to them., +     * <dl>, +     *  <dt><b>Backpressure:</b></dt>, +     *  <dd>Both the returned and its inner {@code GroupedFlowable}s honor backpressure and the source {@code Publisher}, +     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on, +     *  downstream consumption). Note that both the returned and its inner {@code GroupedFlowable}s use, +     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that <em>may</em>, +     *  lead to {@code OutOfMemoryError}.</dd>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @param keySelector, +     *            a function that extracts the key for each item, +     * @param valueSelector, +     *            a function that extracts the return element for each item, +     * @param delayError, +     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted, +     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately., +     * @param bufferSize, +     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered, +     * @param evictingMapFactory, +     *            The factory used to create a map that will be used by the implementation to hold the , +     *            {@link GroupedFlowable}s. The evicting map created by this factory must, +     *            notify the provided {@code Consumer<Object>} with the entry value (not the key!) when, +     *            an entry in this map has been evicted. The next source emission will bring about the, +     *            completion of the evicted {@link GroupedFlowable}s. See example above., +     * @param <K>, +     *            the key type, +     * @param <V>, +     *            the element type, +     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a, +     *         unique key value and each of which emits those items from the source Publisher that share that, +     *         key value, +     * @see <a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX operators documentation: GroupBy</a>]