[+++ b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java, +import rx.subscriptions.MultipleAssignmentSubscription;, +import rx.util.functions.Action0;, +        private final MultipleAssignmentSubscription childSubscription = new MultipleAssignmentSubscription();, +            CompositeSubscription s = new CompositeSubscription();, +            s.add(discardableAction);, +            s.add(Subscriptions.from(executor.submit(new Runnable() {, +                    discardableAction.call(_scheduler);, +            // replace the EventLoopScheduler child subscription with this one, +            childSubscription.set(s);, +            /*, +             * If `schedule` is run concurrently instead of recursively then we'd lose subscriptions as the `childSubscription`, +             * only remembers the last one scheduled. However, the parent subscription will shutdown the entire EventLoopScheduler, +             * and the ExecutorService which will terminate all outstanding tasks so this childSubscription is actually somewhat, +             * superfluous for stopping and cleanup ... though childSubscription does ensure exactness as can be seen by, +             * the `testUnSubscribeForScheduler()` unit test which fails if the `childSubscription` does not exist., +             */, +, +            return childSubscription;, +        private void shutdownNow() {, +            executor.shutdownNow();, +        }, +, +        final EventLoopScheduler s = new EventLoopScheduler();, +        CompositeSubscription cs = new CompositeSubscription();, +        cs.add(s.schedule(state, action));, +        cs.add(Subscriptions.create(new Action0() {, +, +            @Override, +            public void call() {, +                // shutdown the executor, all tasks queued to run and clean up resources, +                s.shutdownNow();, +            }, +        }));, +        return cs;]