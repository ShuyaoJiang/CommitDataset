[+++ b/src/main/java/io/reactivex/Flowable.java, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +            throw new IllegalArgumentException("count >= 0 required but it was " + count);, +        validateBufferSize(bufferSize, "bufferSize");, +    private static void validateBufferSize(int bufferSize, String paramName) {, +            throw new IllegalArgumentException(paramName + " > 0 required but it was " + bufferSize);, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        if (maxConcurrency <= 0) {, +            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);, +        }, +        validateBufferSize(prefetch, "prefetch");, +    public final Flowable<T> doAfterTerminate(Runnable onFinally) {, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +++ b/src/main/java/io/reactivex/Flowable.java, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +            throw new IllegalArgumentException("count >= 0 required but it was " + count);, +        validateBufferSize(bufferSize, "bufferSize");, +    private static void validateBufferSize(int bufferSize, String paramName) {, +            throw new IllegalArgumentException(paramName + " > 0 required but it was " + bufferSize);, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        if (maxConcurrency <= 0) {, +            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);, +        }, +        validateBufferSize(prefetch, "prefetch");, +    public final Flowable<T> doAfterTerminate(Runnable onFinally) {, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +        validateBufferSize(bufferSize, "bufferSize");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.functions.Objects;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableSource<T, C> {, +    final int size;, +, +    final Supplier<C> bufferSupplier;, +, +    public FlowableBuffer(Publisher<T> source, int size, Supplier<C> bufferSupplier) {, +        this(source, size, size, bufferSupplier);, +    }, +, +    public FlowableBuffer(Publisher<T> source, int size, int skip, Supplier<C> bufferSupplier) {, +        super(source);, +        if (size <= 0) {, +            throw new IllegalArgumentException("size > 0 required but it was " + size);, +        }, +, +        if (skip <= 0) {, +            throw new IllegalArgumentException("skip > 0 required but it was " + size);, +        }, +, +        this.size = size;, +        this.bufferSupplier = Objects.requireNonNull(bufferSupplier, "bufferSupplier");, +    public void subscribeActual(Subscriber<? super C> s) {, +        if (size == skip) {, +            source.subscribe(new PublisherBufferExactSubscriber<T, C>(s, size, bufferSupplier));, +        } else if (skip > size) {, +            source.subscribe(new PublisherBufferSkipSubscriber<T, C>(s, size, skip, bufferSupplier));, +            source.subscribe(new PublisherBufferOverlappingSubscriber<T, C>(s, size, skip, bufferSupplier));, +    static final class PublisherBufferExactSubscriber<T, C extends Collection<? super T>>, +      implements Subscriber<T>, Subscription {, +        final Subscriber<? super C> actual;, +, +        final Supplier<C> bufferSupplier;, +, +        final int size;, +, +        C buffer;, +        boolean done;]