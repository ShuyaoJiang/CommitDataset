[+++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java, +                    // forward the successful calls unless resumed, +                    if (subscriptionRef.get()==subscription), +                    // check that we have not been unsubscribed and not already resumed before we can process the error, +                    if (currentSubscription == subscription) {, +                    // forward the successful calls unless resumed, +                    if (subscriptionRef.get()==subscription), +            // Trigger failure on second element, +            TestObservable w = new TestObservable(s, "one", "fail", "two", "three");, +        }, +        @Test, +        public void testMapResumeAsyncNext() {, +            Subscription sr = mock(Subscription.class);, +            // Trigger multiple failures, +            Observable<String> w = Observable.from("one", "fail", "two", "three", "fail");, +            // Resume Observable is async, +            TestObservable resume = new TestObservable(sr, "twoResume", "threeResume");, +, +            // Introduce map function that fails intermittently (Map does not prevent this when the observer is a, +            //  rx.operator incl onErrorResumeNextViaObservable), +            w = w.map(new Func1<String, String>() {, +                public String call(String s) {, +                    if ("fail".equals(s)), +                        throw new RuntimeException("Forced Failure");, +                    System.out.println("BadMapper:" + s);, +                    return s;, +                }, +            });, +, +            Observable<String> observable = Observable.create(onErrorResumeNextViaObservable(w, resume));, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            observable.subscribe(aObserver);, +, +            try {, +                resume.t.join();, +            } catch (InterruptedException e) {, +                fail(e.getMessage());, +            }, +, +            verify(aObserver, Mockito.never()).onError(any(Exception.class));, +            verify(aObserver, times(1)).onCompleted();, +            verify(aObserver, times(1)).onNext("one");, +            verify(aObserver, Mockito.never()).onNext("two");, +            verify(aObserver, Mockito.never()).onNext("three");, +            verify(aObserver, times(1)).onNext("twoResume");, +            verify(aObserver, times(1)).onNext("threeResume");, +                                if ("fail".equals(s)), +                                    throw new RuntimeException("Forced Failure");, +                            System.out.println("TestObservable onCompleted");, +                            observer.onCompleted();, +                            System.out.println("TestObservable onError: " + e);]