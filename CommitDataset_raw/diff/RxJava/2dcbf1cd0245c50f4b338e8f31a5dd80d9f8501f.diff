[+++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.txt, +(ns rx.lang.clojure.examples.rx-examples, +  (:import rx.Observable rx.subscriptions.Subscriptions), +  (:require [clj-http.client :as http])), +, +; NOTE on naming conventions. I'm using camelCase names (against clojure convention), +; in this file as I'm purposefully keeping functions and methods across, +; different language implementations in-sync for easy comparison., +, +; --------------------------------------------------, +; Hello World!, +; --------------------------------------------------, +, +(defn hello, +  [& args], +  (-> (Observable/toObservable args), +    (.subscribe #(println (str "Hello " % "!"))))), +, +; To see output, +(comment, +  (hello "Ben" "George")), +, +; --------------------------------------------------, +; Create Observable from Existing Data, +; --------------------------------------------------, +, +(defn existingDataFromNumbers [], +  (Observable/toObservable [1 2 3 4 5 6])), +, +(defn existingDataFromNumbersUsingFrom [], +  (Observable/from [1 2 3 4 5 6])), +, +(defn existingDataFromObjects [], +  (Observable/toObservable ["a" "b" "c"])), +, +(defn existingDataFromObjectsUsingFrom [], +  (Observable/from ["a" "b" "c"])), +, +(defn existingDataFromList [], +  (let [list [5, 6, 7, 8]], +    (Observable/toObservable list))), +, +(defn existingDataFromListUsingFrom [], +  (let [list [5, 6, 7, 8]], +    (Observable/from list))), +, +(defn existingDataWithJust [], +  (Observable/just "one object")), +, +; --------------------------------------------------, +; Custom Observable, +; --------------------------------------------------, +, +(defn customObservableBlocking [], +  "This example shows a custom Observable that blocks, +   when subscribed to (does not spawn an extra thread)., +, +  returns Observable<String>", +  (Observable/create, +    (fn [observer], +      (doseq [x (range 50)] (-> observer (.onNext (str "value_" x)))), +      ; after sending all values we complete the sequence, +      (-> observer .onCompleted), +      ; return a NoOpSubsription since this blocks and thus, +      ; can't be unsubscribed from, +      (Subscriptions/empty)))), +, +; To see output, +(comment, +  (.subscribe (customObservableBlocking) println)), +, +(defn customObservableNonBlocking [], +  "This example shows a custom Observable that does not block, +  when subscribed to as it spawns a separate thread., +, +  returns Observable<String>", +  (Observable/create, +    (fn [observer], +      (let [f (future, +                (doseq [x (range 50)], +                  (-> observer (.onNext (str "anotherValue_" x)))), +                ; after sending all values we complete the sequence, +                (-> observer .onCompleted))], +        ; return a subscription that cancels the future, +        (Subscriptions/create #(future-cancel f)))))), +, +; To see output, +(comment, +  (.subscribe (customObservableNonBlocking) println)), +, +, +(defn fetchWikipediaArticleAsynchronously [wikipediaArticleNames], +  "Fetch a list of Wikipedia articles asynchronously., +, +   return Observable<String> of HTML", +  (Observable/create, +    (fn [observer], +      (let [f (future]