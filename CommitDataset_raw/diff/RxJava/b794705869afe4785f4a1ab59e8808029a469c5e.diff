[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.functions.Action0;, +import rx.observers.Subscribers;, +import rx.subscriptions.Subscriptions;, +        State<T> state = new State<T>();, +        return new BufferUntilSubscriber<T>(state);, +    /** The common state. */, +    static final class State<T> {, +        /** Lite notifications of type T. */, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /** The first observer or the one which buffers until the first arrives. */, +        final AtomicReference<Observer<? super T>> observerRef = new AtomicReference<Observer<? super T>>(new BufferedObserver<T>());, +        /** Allow a single subscriber only. */, +        final AtomicBoolean first = new AtomicBoolean();, +    }, +    static final class OnSubscribeAction<T> implements OnSubscribe<T> {, +        final State<T> state;, +, +        public OnSubscribeAction(State<T> state) {, +            this.state = state;, +        }, +        public void call(final Subscriber<? super T> s) {, +            if (state.first.compareAndSet(false, true)) {, +                BufferedObserver<? super T> buffered = (BufferedObserver<? super T>)state.observerRef.get();, +                Object o;, +                    state.nl.accept(s, o);, +                state.observerRef.set(new PassThruObserver<T>(s, buffered.buffer, state.observerRef));, +                s.add(Subscriptions.create(new Action0() {, +                    @Override, +                    public void call() {, +                        state.observerRef.set(Subscribers.empty());, +                    }, +                }));, +            } else {, +                s.onError(new IllegalStateException("Only one subscriber allowed!"));, +            }, +    }, +    final State<T> state;, +    , +    private BufferUntilSubscriber(State<T> state) {, +        super(new OnSubscribeAction<T>(state));, +        this.state = state;, +        state.observerRef.get().onCompleted();, +        state.observerRef.get().onError(e);, +    @SuppressWarnings({ "unchecked", "rawtypes" }), +        state.observerRef.get().onNext(t);, +        private final NotificationLite<T> nl = NotificationLite.instance();, +            Object o;, +                nl.accept(this, o);, +            // but only if not unsubscribed, +            observerRef.compareAndSet(this, actual);, +        private final NotificationLite<T> nl = NotificationLite.instance();, +            buffer.add(nl.completed());, +            buffer.add(nl.error(e));, +            buffer.add(nl.next(t));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, +        return lift(new OperatorWindowWithSize<T>(count, count));, +        return lift(new OperatorWindowWithSize<T>(count, skip));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, +        return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.functions.Action0;, +import rx.observers.Subscribers;, +import rx.subscriptions.Subscriptions;, +        State<T> state = new State<T>();, +        return new BufferUntilSubscriber<T>(state);, +    /** The common state. */]