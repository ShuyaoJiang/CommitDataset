[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        Subscription upstream;, +            if (SubscriptionHelper.validate(this.upstream, s)) {, +                this.upstream = s;, +                upstream.cancel();, +                        upstream.request(scalarLimit);, +                        upstream.request(scalarLimit);, +                upstream.cancel();, +                                    if (!delayErrors) {, +                                        upstream.cancel();, +                                    }, +                    upstream.request(replenishMain);, +                    upstream.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        Subscription upstream;, +            if (SubscriptionHelper.validate(this.upstream, s)) {, +                this.upstream = s;, +                upstream.cancel();, +                        upstream.request(scalarLimit);, +                        upstream.request(scalarLimit);, +                upstream.cancel();, +                                    if (!delayErrors) {, +                                        upstream.cancel();, +                                    }, +                    upstream.request(replenishMain);, +                    upstream.cancel();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +, +    @Test, +    public void failingFusedInnerCancelsSource() {, +        final AtomicInteger counter = new AtomicInteger();, +        Flowable.range(1, 5), +        .doOnNext(new Consumer<Integer>() {, +            @Override, +            public void accept(Integer v) throws Exception {, +                counter.getAndIncrement();, +            }, +        }), +        .flatMap(new Function<Integer, Publisher<Integer>>() {, +            @Override, +            public Publisher<Integer> apply(Integer v), +                    throws Exception {, +                return Flowable.<Integer>fromIterable(new Iterable<Integer>() {, +                    @Override, +                    public Iterator<Integer> iterator() {, +                        return new Iterator<Integer>() {, +                            @Override, +                            public boolean hasNext() {, +                                return true;, +                            }, +, +                            @Override, +                            public Integer next() {, +                                throw new TestException();, +                            }, +, +                            @Override, +                            public void remove() {, +                                throw new UnsupportedOperationException();, +                            }, +                        };, +                    }, +                });, +            }, +        }), +        .test(), +        .assertFailure(TestException.class);, +, +        assertEquals(1, counter.get());, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +        Subscription upstream;, +            if (SubscriptionHelper.validate(this.upstream, s)) {, +                this.upstream = s;, +                upstream.cancel();, +                        upstream.request(scalarLimit);, +                        upstream.request(scalarLimit);, +                upstream.cancel();, +                                    if (!delayErrors) {, +                                        upstream.cancel();, +                                    }, +                    upstream.request(replenishMain);, +                    upstream.cancel();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +, +    @Test, +    public void failingFusedInnerCancelsSource() {, +        final AtomicInteger counter = new AtomicInteger();, +        Flowable.range(1, 5), +        .doOnNext(new Consumer<Integer>() {, +            @Override, +            public void accept(Integer v) throws Exception {, +                counter.getAndIncrement();, +            }, +        }), +        .flatMap(new Function<Integer, Publisher<Integer>>() {, +            @Override, +            public Publisher<Integer> apply(Integer v), +                    throws Exception {, +                return Flowable.<Integer>fromIterable(new Iterable<Integer>() {]