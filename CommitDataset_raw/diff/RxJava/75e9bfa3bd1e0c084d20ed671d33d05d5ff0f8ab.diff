[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +        boolean done;, +, +            if (done) {, +                return;, +            }, +            , +            if (done) {, +                return;, +            }, +            done = true;, +            if (done) {, +                return;, +            }, +            done = true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +        boolean done;, +, +            if (done) {, +                return;, +            }, +            , +            if (done) {, +                return;, +            }, +            done = true;, +            if (done) {, +                return;, +            }, +            done = true;, +++ b/src/test/java/io/reactivex/flowable/FlowableScanTests.java, +import static org.junit.Assert.assertEquals;, +import java.util.HashMap;, +import java.util.concurrent.Callable;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.junit.Assert;, +import io.reactivex.Flowable;, +    , +    @Test, +    public void testFlowableScanSeedDoesNotEmitErrorTwiceIfScanFunctionThrows() {, +        final RuntimeException e = new RuntimeException();, +        Burst.item(1).error(e).scan(0, new BiFunction<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer apply(Integer n1, Integer n2) throws Exception {, +                throw e;, +            }}), +          .test(), +          .assertNoValues(), +          .assertError(e);, +    }, +    , +    @Test, +    public void testFlowableScanSeedDoesNotEmitTerminalEventTwiceIfScanFunctionThrows() {, +        final RuntimeException e = new RuntimeException();, +        Burst.item(1).create().scan(0, new BiFunction<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer apply(Integer n1, Integer n2) throws Exception {, +                throw e;, +            }}), +          .test(), +          .assertNoValues(), +          .assertError(e);, +    }, +    , +    @Test, +    public void testFlowableScanSeedDoesNotProcessOnNextAfterTerminalEventIfScanFunctionThrows() {, +        final RuntimeException e = new RuntimeException();, +        final AtomicInteger count = new AtomicInteger();, +        Burst.items(1, 2).create().scan(0, new BiFunction<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer apply(Integer n1, Integer n2) throws Exception {, +                count.incrementAndGet();, +                throw e;, +            }}), +          .test(), +          .assertNoValues(), +          .assertError(e);, +        assertEquals(1, count.get());, +    }, +    , +    @Test, +    public void testFlowableScanSeedCompletesNormally() {, +        Flowable.just(1,2,3).scan(0, new BiFunction<Integer, Integer, Integer>() {, +, +            @Override, +            public Integer apply(Integer t1, Integer t2) throws Exception {, +                return t1 + t2;, +            }}), +          .test(), +          .assertValues(0, 1, 3, 6), +          .assertComplete();, +    }, +    , +    @Test, +    public void testFlowableScanSeedWhenScanSeedProviderThrows() {, +        final RuntimeException e = new RuntimeException();]