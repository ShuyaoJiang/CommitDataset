[+++ b/src/main/java/io/reactivex/Scheduler.java, + * units of work provided in the form of {@link Runnable}s to be, + * executed without delay (effectively as soon as possible), after a specified time delay or periodically, + * and represents an abstraction over an asynchronous boundary that ensures, + * these units of work get executed by some underlying task-execution scheme, + * (such as custom Threads, event loop, {@link java.util.concurrent.Executor Executor} or Actor system), + * with some uniform properties and guarantees regardless of the particular underlying, + * scheme., + * <p>, + * You can get various standard, RxJava-specific instances of this class via, + * the static methods of the {@link io.reactivex.schedulers.Schedulers} utility class., + * <p>, + * The so-called {@link Worker}s of a {@code Scheduler} can be created via the {@link #createWorker()} method which allow the scheduling, + * of multiple {@link Runnable} tasks in an isolated manner. {@code Runnable} tasks scheduled on a {@code Worker} are guaranteed to be, + * executed sequentially and in a non-overlapping fashion. Non-delayed {@code Runnable} tasks are guaranteed to execute in a, + * First-In-First-Out order but their execution may be interleaved with delayed tasks., + * In addition, outstanding or running tasks can be cancelled together via, + * {@link Worker#dispose()} without affecting any other {@code Worker} instances of the same {@code Scheduler}., + * <p>, + * Implementations of the {@link #scheduleDirect} and {@link Worker#schedule} methods are encouraged to call the {@link io.reactivex.plugins.RxJavaPlugins#onSchedule(Runnable)}, + * method to allow a scheduler hook to manipulate (wrap or replace) the original {@code Runnable} task before it is submitted to the, + * underlying task-execution scheme., + * <p>, + * The default implementations of the {@code scheduleDirect} methods provided by this abstract class, + * delegate to the respective {@code schedule} methods in the {@link Worker} instance created via {@link #createWorker()}, + * for each individual {@link Runnable} task submitted. Implementors of this class are encouraged to provide, + * a more efficient direct scheduling implementation to avoid the time and memory overhead of creating such {@code Worker}s, + * for every task., + * This delegation is done via special wrapper instances around the original {@code Runnable} before calling the respective, + * {@code Worker.schedule} method. Note that this can lead to multiple {@code RxJavaPlugins.onSchedule} calls and potentially, + * multiple hooks applied. Therefore, the default implementations of {@code scheduleDirect} (and the {@link Worker#schedulePeriodically(Runnable, long, long, TimeUnit)}), + * wrap the incoming {@code Runnable} into a class that implements the {@link io.reactivex.schedulers.SchedulerRunnableIntrospection}, + * interface which can grant access to the original or hooked {@code Runnable}, thus, a repeated {@code RxJavaPlugins.onSchedule}, + * can detect the earlier hook and not apply a new one over again., + * <p>, + * The default implementation of {@link #now(TimeUnit)} and {@link Worker#now(TimeUnit)} methods to return current, + * {@link System#currentTimeMillis()} value in the desired time unit. Custom {@code Scheduler} implementations can override this, + * to provide specialized time accounting (such as virtual time to be advanced programmatically)., + * Note that operators requiring a {@code Scheduler} may rely on either of the {@code now()} calls provided by, + * {@code Scheduler} or {@code Worker} respectively, therefore, it is recommended they represent a logically, + * consistent source of the current time., + * <p>, + * The default implementation of the {@link Worker#schedulePeriodically(Runnable, long, long, TimeUnit)} method uses, + * the {@link Worker#schedule(Runnable, long, TimeUnit)} for scheduling the {@code Runnable} task periodically., + * The algorithm calculates the next absolute time when the task should run again and schedules this execution, + * based on the relative time between it and {@link Worker#now(TimeUnit)}. However, drifts or changes in the, + * system clock could affect this calculation either by scheduling subsequent runs too frequently or too far apart., + * Therefore, the default implementation uses the {@link #clockDriftTolerance()} value (set via, + * {@code rx2.scheduler.drift-tolerance} in minutes) to detect a drift in {@link Worker#now(TimeUnit)} and, + * re-adjust the absolute/relative time calculation accordingly., + * <p>, + * The default implementations of {@link #start()} and {@link #shutdown()} do nothing and should be overridden if the, + * underlying task-execution scheme supports stopping and restarting itself., + * <p>, + * If the {@code Scheduler} is shut down or a {@code Worker} is disposed, the {@code schedule} methods, + * should return the {@link io.reactivex.disposables.Disposables#disposed()} singleton instance indicating the shut down/disposed, + * state to the caller. Since the shutdown or dispose can happen from any thread, the {@code schedule} implementations, + * should make best effort to cancel tasks immediately after those tasks have been submitted to the, + * underlying task-execution scheme if the shutdown/dispose was detected after this submission., + * <p>, + * All methods on the {@code Scheduler} and {@code Worker} classes should be thread safe., +     * The associated system parameter, {@code rx2.scheduler.drift-tolerance}, expects its value in minutes., +     * <p>Related system property: {@code rx2.scheduler.drift-tolerance} in minutes., +     * Retrieves or creates a new {@link Scheduler.Worker} that represents sequential execution of actions., +     * When work is completed, the {@code Worker} instance should be released, +     * by calling {@link Scheduler.Worker#dispose()} to avoid potential resource leaks in the, +     * underlying task-execution scheme., +     * Work on a {@link Scheduler.Worker} is guaranteed to be sequential and non-overlapping., +     * <p>, +     * Implementations should make sure the call is idempotent, thread-safe and, +     * should not throw any {@code RuntimeException} if it doesn't support this, +     * functionality., +     *, +     * Instructs the Scheduler instance to stop threads,, +     * stop accepting tasks on any outstanding {@link Worker} instances, +     * and clean up any associated resources with this Scheduler., +     * <p>, +     * Implementations should make sure the call is idempotent, thread-safe and, +     * should not throw any {@code RuntimeException} if it doesn't support this, +     * functionality., +     * Schedules the given task on this Scheduler without any time delay., +     * ordering or non-overlapping guarantees between tasks., +     * Schedules the execution of the given task with the given time delay., +     * Schedules a periodic execution of the given task with the given initial time delay and repeat period., +     * The periodic execution is at a fixed rate, that is, the first execution will be after the, +     * {@code initialDelay}, the second after {@code initialDelay + period}, the third after, +     * {@code initialDelay + 2 * period}, and so on., +     * Represents an isolated, sequential worker of a parent Scheduler for executing {@code Runnable} tasks on, +     * an underlying task-execution scheme (such as custom Threads, event loop, {@link java.util.concurrent.Executor Executor} or Actor system)., +     * Disposing the {@link Worker} should cancel all outstanding work and allows resource cleanup., +     * <p>, +     * The default implementations of {@link #schedule(Runnable)} and {@link #schedulePeriodically(Runnable, long, long, TimeUnit)}, +     * delegate to the abstract {@link #schedule(Runnable, long, TimeUnit)} method. Its implementation is encouraged to, +     * track the individual {@code Runnable} tasks while they are waiting to be executed (with or without delay) so that, +     * {@link #dispose()} can prevent their execution or potentially interrupt them if they are currently running., +     * <p>, +     * The default implementation of the {@link #now(TimeUnit)} method returns current, +     * {@link System#currentTimeMillis()} value in the desired time unit. Custom {@code Worker} implementations can override this, +     * to provide specialized time accounting (such as virtual time to be advanced programmatically)., +     * Note that operators requiring a scheduler may rely on either of the {@code now()} calls provided by]