[+++ b/src/main/java/io/reactivex/Observable.java, +    public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {, +        return merge(sources, bufferSize());, +    }, +, +    public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return fromPublisher(sources).flatMap(v -> v, maxConcurrency);, +    }, +, +    public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {, +        return mergeDelayError(sources, bufferSize());, +    }, +, +    public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return fromPublisher(sources).flatMap(v -> v, true, maxConcurrency);, +    }, +, +    , +        return lift(new OperatorConcatMap<>(mapper, prefetch));, +    public final Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {, +        return concat(sources, bufferSize());, +    }, +    , +    public final Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {, +        return fromPublisher(sources).concatMap(v -> v);, +    }, +    , +        if (sources.length == 0) {, +            return empty();, +        } else, +        if (sources.length == 1) {, +            return fromPublisher(sources[0]);, +        }, +, +    public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {, +        return switchMap(mapper, bufferSize());, +    }, +    , +    public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {, +        Objects.requireNonNull(mapper);, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return lift(new OperatorSwitchMap<>(mapper, bufferSize));, +    }, +    , +    public static <T> Observable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {, +        return fromPublisher(sources).switchMap(v -> v);, +    }, +, +    public static <T> Observable<T> switchOnNext(int bufferSize, Publisher<? extends Publisher<? extends T>> sources) {, +        return fromPublisher(sources).switchMap(v -> v, bufferSize);, +    }, +++ b/src/main/java/io/reactivex/Observable.java, +    public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {, +        return merge(sources, bufferSize());, +    }, +, +    public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return fromPublisher(sources).flatMap(v -> v, maxConcurrency);, +    }, +, +    public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {, +        return mergeDelayError(sources, bufferSize());, +    }, +, +    public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, +        return fromPublisher(sources).flatMap(v -> v, true, maxConcurrency);, +    }, +, +    , +        return lift(new OperatorConcatMap<>(mapper, prefetch));, +    public final Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {, +        return concat(sources, bufferSize());, +    }, +    , +    public final Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {, +        return fromPublisher(sources).concatMap(v -> v);, +    }, +    , +        if (sources.length == 0) {, +            return empty();, +        } else, +        if (sources.length == 1) {, +            return fromPublisher(sources[0]);, +        }, +, +    public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {, +        return switchMap(mapper, bufferSize());, +    }, +    , +    public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {, +        Objects.requireNonNull(mapper);, +        if (bufferSize <= 0) {, +            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, +        }, +        return lift(new OperatorSwitchMap<>(mapper, bufferSize));, +    }, +    , +    public static <T> Observable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {]