[+++ b/build.gradle, +    apply plugin: 'eclipse', +    apply plugin: 'idea', +++ b/build.gradle, +    apply plugin: 'eclipse', +    apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/build.gradle, +    apply plugin: 'eclipse', +    apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/build.gradle, +    apply plugin: 'eclipse', +    apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +    /*, +    * ThreadSafe, +    */, +    /* package accessible for unit tests */static class ZipObserver<R, T> implements Observer<T> {, +        final Observable<? extends T> w;, +        final Aggregator<R> a;, +        private final SafeObservableSubscription subscription = new SafeObservableSubscription();, +        private final AtomicBoolean subscribed = new AtomicBoolean(false);, +        , +        public ZipObserver(Aggregator<R> a, Observable<? extends T> w) {, +            this.a = a;, +            this.w = w;, +        }, +        , +        public void startWatching() {, +            if (subscribed.compareAndSet(false, true)) {, +                // only subscribe once even if called more than once, +                subscription.wrap(w.subscribe(this));, +            }, +        }, +        , +        @Override, +        public void onCompleted() {, +            a.complete(this);, +        }, +        , +        @Override, +        public void onError(Throwable e) {, +            a.error(this, e);, +        }, +        , +        @Override, +        public void onNext(T args) {, +            try {, +                a.next(this, args);, +            } catch (Throwable e) {, +                onError(e);, +            }, +        }, +    }, +    , +    /**, +     * Receive notifications from each of the Observables we are reducing and execute the zipFunction whenever we have received events from all Observables., +     *, +     * This class is thread-safe., +     *, +     * @param <T>, +     */, +    /* package accessible for unit tests */static class Aggregator<T> implements OnSubscribeFunc<T> {, +        , +        private volatile SynchronizedObserver<T> observer;, +        private final FuncN<? extends T> zipFunction;, +        private final AtomicBoolean started = new AtomicBoolean(false);, +        private final AtomicBoolean running = new AtomicBoolean(true);, +        private final ConcurrentHashMap<ZipObserver<T, ?>, Boolean> completed = new ConcurrentHashMap<ZipObserver<T, ?>, Boolean>();, +        , +        /* we use ConcurrentHashMap despite synchronization of methods because stop() does NOT use synchronization and this map is used by it and can be called by other threads */, +        private ConcurrentHashMap<ZipObserver<T, ?>, ConcurrentLinkedQueue<Object>> receivedValuesPerObserver = new ConcurrentHashMap<ZipObserver<T, ?>, ConcurrentLinkedQueue<Object>>();, +        /* we use a ConcurrentLinkedQueue to retain ordering (I'd like to just use a ConcurrentLinkedHashMap for 'receivedValuesPerObserver' but that doesn't exist in standard java */, +        private ConcurrentLinkedQueue<ZipObserver<T, ?>> observers = new ConcurrentLinkedQueue<ZipObserver<T, ?>>();, +        , +        public Aggregator(FuncN<? extends T> zipFunction) {, +            this.zipFunction = zipFunction;, +        }, +        , +        /**, +         * Receive notification of a Observer starting (meaning we should require it for aggregation), +         *, +         * Thread Safety => Invoke ONLY from the static factory methods at top of this class which are always an atomic execution by a single thread., +         *, +         * @param w, +         */, +        void addObserver(ZipObserver<T, ?> w) {, +            // initialize this ZipObserver, +            observers.add(w);, +            receivedValuesPerObserver.put(w, new ConcurrentLinkedQueue<Object>());]