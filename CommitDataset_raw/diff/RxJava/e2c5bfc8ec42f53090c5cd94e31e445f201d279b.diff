[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Observer;, +import rx.observers.SerializedObserver;, +                Outer<K1, K2, T> newOuter = Outer.<K1, K2, T> create(key2);, +        private final Observer<T> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<T>(subscriber);, +        private final Observer<GroupedObservable<K1, T>> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<GroupedObservable<K1, T>>(subscriber);, +        public static <K1, K2, T> Outer<K1, K2, T> create(final K2 key2) {, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Observer;, +import rx.observers.SerializedObserver;, +                Outer<K1, K2, T> newOuter = Outer.<K1, K2, T> create(key2);, +        private final Observer<T> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<T>(subscriber);, +        private final Observer<GroupedObservable<K1, T>> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<GroupedObservable<K1, T>>(subscriber);, +        public static <K1, K2, T> Outer<K1, K2, T> create(final K2 key2) {, +++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorPivotTest.java, +, +import java.util.concurrent.Executors;, +import org.junit.Ignore;, +import rx.Scheduler;, +    @Test(timeout=10000), +        for(int i=0; i<1000; i++) {, +            System.out.println("------------------------------------------ testPivotEvenAndOdd -------------------------------------------");, +        Observable<GroupedObservable<Boolean, Integer>> o1 = Observable.range(1, 10).groupBy(modKeySelector).subscribeOn(Schedulers.computation());, +        Observable<GroupedObservable<Boolean, Integer>> o2 = Observable.range(11, 10).groupBy(modKeySelector).subscribeOn(Schedulers.computation());, +                System.out.println("Outer Group: " + outerGroup.getKey());, +                        System.out.println("Inner Group: " + innerGroup.getKey());, +        if (!latch.await(20000000, TimeUnit.MILLISECONDS)) {, +        // TODO sometimes this test fails and gets 15 instead of 20 so there is a bug somewhere, +    }, +    @Test(timeout=10000), +    @Test(timeout=10000)]