[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.LinkedList;, +import java.util.List;, +import java.util.Queue;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.SerialSubscription;, +    public static <T1, T2, R> OnSubscribeFunc<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, final Func2<? super T1, ? super T2, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2), Functions.fromFunc(zipFunction));, +    public static <T1, T2, T3, R> OnSubscribeFunc<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, final Func3<? super T1, ? super T2, ? super T3, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3), Functions.fromFunc(zipFunction));, +    public static <T1, T2, T3, T4, R> OnSubscribeFunc<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, Observable<? extends T4> o4, final Func4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4), Functions.fromFunc(zipFunction));, +    public static <T1, T2, T3, T4, T5, R> OnSubscribeFunc<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, Observable<? extends T4> o4, Observable<? extends T5> o5, final Func5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4, o5), Functions.fromFunc(zipFunction));, +            final Func6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4, o5, o6), Functions.fromFunc(zipFunction));, +            final Func7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4, o5, o6, o7), Functions.fromFunc(zipFunction));, +            final Func8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8), Functions.fromFunc(zipFunction));, +            Observable<? extends T9> o9, final Func9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipFunction) {, +        return zip(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8, o9), Functions.fromFunc(zipFunction));, +    public static <R> OnSubscribeFunc<R> zip(Iterable<? extends Observable<?>> ws, final FuncN<? extends R> zipFunction) {, +        ManyObservables<?, R> a = new ManyObservables<Object, R>(ws, zipFunction);, +    /**, +     * Merges the values across multiple sources and applies the selector, +     * function., +     * <p>The resulting sequence terminates if no more pairs can be, +     * established, i.e., streams of length 1 and 2 zipped will produce, +     * only 1 item.</p>, +     * <p>Exception semantics: errors from the source observable are, +     * propagated as-is.</p>, +     * @param <T> the common element type, +     * @param <U> the result element type, +     */, +    public static class ManyObservables<T, U> implements OnSubscribeFunc<U> {, +        /** */, +        protected final Iterable<? extends Observable<? extends T>> sources;, +        /** */, +        protected final FuncN<? extends U> selector;, +        /**, +         * Constructor., +         * @param sources the sources, +         * @param selector the result selector, +         */, +        public ManyObservables(, +                Iterable<? extends Observable<? extends T>> sources,, +                FuncN<? extends U> selector) {, +            this.sources = sources;, +            this.selector = selector;, +        }, +        , +        @Override, +        public Subscription onSubscribe(final Observer<? super U> observer) {, +            , +            final CompositeSubscription composite = new CompositeSubscription();, +            , +            final ReadWriteLock rwLock = new ReentrantReadWriteLock(true);, +            , +            final List<ItemObserver<T>> all = new ArrayList<ItemObserver<T>>();, +            , +            Observer<List<T>> o2 = new Observer<List<T>>() {, +                @Override, +                public void onCompleted() {, +                    observer.onCompleted();, +                }, +                @Override, +                public void onError(Throwable t) {, +                    observer.onError(t);, +                }, +                @Override, +                public void onNext(List<T> value) {, +                    observer.onNext(selector.call(value.toArray(new Object[value.size()])));, +                }, +            };, +            , +            for (Observable<? extends T> o : sources) {, +                , +                ItemObserver<T> io = new ItemObserver<T>(, +                        rwLock, all, o, o2, composite);, +                composite.add(io);, +                all.add(io);, +            }, +            , +            for (ItemObserver<T> io : all) {, +                io.connect();, +            }, +            , +            return composite;, +        }, +        /**, +         * The individual line's observer., +         * @author akarnokd, 2013.01.14., +         * @param <T> the element type]