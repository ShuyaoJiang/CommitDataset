[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, +                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, +                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/test/java/io/reactivex/TestHelper.java, +, +    static final class FlowableStripBoundary<T> extends Flowable<T> implements FlowableTransformer<T, T> {, +, +        final Flowable<T> source;, +, +        FlowableStripBoundary(Flowable<T> source) {, +            this.source = source;, +        }, +, +        @Override, +        public Flowable<T> apply(Flowable<T> upstream) {, +            return new FlowableStripBoundary<T>(upstream);, +        }, +, +        @Override, +        protected void subscribeActual(Subscriber<? super T> s) {, +            source.subscribe(new StripBoundarySubscriber<T>(s));, +        }, +, +        static final class StripBoundarySubscriber<T> implements FlowableSubscriber<T>, QueueSubscription<T> {, +, +            final Subscriber<? super T> actual;, +, +            Subscription upstream;, +, +            QueueSubscription<T> qs;, +, +            StripBoundarySubscriber(Subscriber<? super T> actual) {, +                this.actual = actual;, +            }, +, +            @SuppressWarnings("unchecked"), +            @Override, +            public void onSubscribe(Subscription subscription) {, +                this.upstream = subscription;, +                if (subscription instanceof QueueSubscription) {, +                    qs = (QueueSubscription<T>)subscription;, +                }, +                actual.onSubscribe(this);, +            }, +, +            @Override, +            public void onNext(T t) {, +                actual.onNext(t);, +            }, +, +            @Override, +            public void onError(Throwable throwable) {, +                actual.onError(throwable);, +            }, +, +            @Override, +            public void onComplete() {, +                actual.onComplete();, +            }, +, +            @Override, +            public int requestFusion(int mode) {, +                QueueSubscription<T> fs = qs;, +                if (fs != null) {, +                    return fs.requestFusion(mode & ~BOUNDARY);, +                }, +                return NONE;, +            }, +, +            @Override, +            public boolean offer(T value) {, +                throw new UnsupportedOperationException("Should not be called");, +            }, +, +            @Override, +            public boolean offer(T v1, T v2) {, +                throw new UnsupportedOperationException("Should not be called");, +            }, +, +            @Override, +            public T poll() throws Exception {, +                return qs.poll();, +            }, +, +            @Override, +            public void clear() {, +                qs.clear();, +            }, +, +            @Override, +            public boolean isEmpty() {, +                return qs.isEmpty();, +            }]