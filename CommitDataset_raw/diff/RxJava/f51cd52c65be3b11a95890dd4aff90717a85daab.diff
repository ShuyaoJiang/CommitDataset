[+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +    private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {, +        int nextOffset = calcDirectOffset(nextIndex);, +        AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);, +        soElement(curr, nextOffset, null); // Avoid GC nepotism, +        return nextBuffer;, +            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +            return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +    private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {, +        int nextOffset = calcDirectOffset(nextIndex);, +        AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);, +        soElement(curr, nextOffset, null); // Avoid GC nepotism, +        return nextBuffer;, +            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +            return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java, +        Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS), +            Thread.sleep(10);, +        for (;;) {, +            int a = nextCount.get();, +            int b = receivedCount.get();, +            if (a > 10 && a < 20 && a == b) {, +                break;, +            }, +            if (a >= 20) {, +                break;, +            }, +            try {, +                Thread.sleep(20);, +            } catch (InterruptedException e) {, +            }, +        }, +        // give time to emit, +, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +    private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {, +        int nextOffset = calcDirectOffset(nextIndex);, +        AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);, +        soElement(curr, nextOffset, null); // Avoid GC nepotism, +        return nextBuffer;, +            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +            return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java, +        Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS), +            Thread.sleep(10);, +        for (;;) {, +            int a = nextCount.get();, +            int b = receivedCount.get();, +            if (a > 10 && a < 20 && a == b) {, +                break;, +            }, +            if (a >= 20) {, +                break;, +            }, +            try {, +                Thread.sleep(20);, +            } catch (InterruptedException e) {, +            }, +        }, +        // give time to emit, +, +++ b/src/test/java/io/reactivex/internal/queue/SimpleQueueTest.java, +import java.util.concurrent.atomic.*;, +, +    @Test, +    public void spscLinkedArrayQueueNoNepotism() {, +        SpscLinkedArrayQueue<Integer> q = new SpscLinkedArrayQueue<Integer>(16);, +, +        AtomicReferenceArray<Object> ara = q.producerBuffer;, +, +        for (int i = 0; i < 20; i++) {, +            q.offer(i);, +        }, +, +        assertNotNull(ara.get(16));, +, +        for (int i = 0; i < 20; i++) {, +            assertEquals(i, q.poll().intValue());, +        }, +, +        assertNull(ara.get(16));, +    }]