[+++ b/src/main/java/rx/internal/operators/OperatorMergeMaxConcurrent.java, +import java.util.*;, +import java.util.concurrent.atomic.*;, +, +import rx.*;, +import rx.Observable;, +import rx.exceptions.MissingBackpressureException;, +import rx.internal.util.RxRingBuffer;, +        SourceSubscriber<T> ssub = new SourceSubscriber<T>(maxConcurrency, s, csub);, +        child.setProducer(new MergeMaxConcurrentProducer<T>(ssub));, +        , +        return ssub;, +    }, +    /** Routes the requests from downstream to the sourcesubscriber. */, +    static final class MergeMaxConcurrentProducer<T> implements Producer {, +        final SourceSubscriber<T> ssub;, +        public MergeMaxConcurrentProducer(SourceSubscriber<T> ssub) {, +            this.ssub = ssub;, +        }, +        @Override, +        public void request(long n) {, +            ssub.downstreamRequest(n);, +        }, +        final NotificationLite<T> nl = NotificationLite.instance();, +        static final AtomicIntegerFieldUpdater<SourceSubscriber> WIP, +        volatile int sourceIndex;, +        @SuppressWarnings("rawtypes"), +        static final AtomicIntegerFieldUpdater<SourceSubscriber> SOURCE_INDEX, +                = AtomicIntegerFieldUpdater.newUpdater(SourceSubscriber.class, "sourceIndex");, +        /** Indicates the emitting phase. Guarded by this. */, +        boolean emitting;, +        /** Counts the missed emitting calls. Guarded by this. */, +        int missedEmitting;, +        /** The last buffer index in the round-robin drain scheme. Accessed while emitting == true. */, +        int lastIndex;, +        , +        /** Guarded by itself. */, +        final List<MergeItemSubscriber> subscribers;, +        , +        volatile long requested;, +        @SuppressWarnings("rawtypes"), +        static final AtomicLongFieldUpdater<SourceSubscriber> REQUESTED, +                = AtomicLongFieldUpdater.newUpdater(SourceSubscriber.class, "requested");, +        , +        , +            this.queue = new ArrayDeque<Observable<? extends T>>(maxConcurrency);, +            this.subscribers = Collections.synchronizedList(new ArrayList<MergeItemSubscriber>());, +        public void onStart() {, +            request(maxConcurrency);, +        }, +        , +        @Override, +            MergeItemSubscriber itemSub = new MergeItemSubscriber(SOURCE_INDEX.getAndIncrement(this));, +            subscribers.add(itemSub);, +, +            csub.add(itemSub);, +            , +            WIP.incrementAndGet(this);, +            , +            t.unsafeSubscribe(itemSub);, +            , +            request(1);, +        }, +        , +        @Override, +        public void onError(Throwable e) {, +            Object[] active;, +            synchronized (subscribers) {, +                active = subscribers.toArray();, +                subscribers.clear();, +            }, +            , +            try {, +                s.onError(e);, +                , +                unsubscribe();, +            } finally {, +                for (Object o : active) {, +                    @SuppressWarnings("unchecked"), +                    MergeItemSubscriber a = (MergeItemSubscriber)o;, +                    a.release();, +                }, +            }, +            , +        }, +        , +        @Override, +        public void onCompleted() {, +            WIP.decrementAndGet(this);, +            drain();, +        }, +        , +        protected void downstreamRequest(long n) {, +            for (;;) {, +                long r = requested;, +                long u;, +                if (r != Long.MAX_VALUE && n == Long.MAX_VALUE) {, +                    u = Long.MAX_VALUE;, +                } else, +                if (r + n < 0) {]