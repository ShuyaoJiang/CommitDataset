[+++ b/src/main/java/io/reactivex/NbpObservable.java, +                    s.onError(e);, +                        s.onError(new NoSuchElementException());, +++ b/src/main/java/io/reactivex/NbpObservable.java, +                    s.onError(e);, +                        s.onError(new NoSuchElementException());, +++ b/src/main/java/io/reactivex/Single.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.disposables.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.Schedulers;, +    public interface SingleOnSubscribe<T> extends Consumer<SingleSubscriber<? super T>> {, +        , +    }, +    , +    public interface SingleOperator<Downstream, Upstream> extends Function<SingleSubscriber<? super Downstream>, SingleSubscriber<? super Upstream>> {, +        , +    }, +    , +    public interface SingleSubscriber<T> {, +        , +        void onError(Throwable e);, +    public static <T> Single<T> amb(Iterable<? extends Single<? extends T>> sources) {, +        return create(s -> {, +            AtomicBoolean once = new AtomicBoolean();, +            CompositeDisposable set = new CompositeDisposable();, +            s.onSubscribe(set);, +            int c = 0;, +            for (Single<? extends T> s1 : sources) {, +                if (once.get()) {, +                    return;, +                }, +                , +                s1.subscribe(new SingleSubscriber<T>() {, +, +                    @Override, +                    public void onSubscribe(Disposable d) {, +                        set.add(d);, +                    }, +, +                    @Override, +                    public void onSuccess(T value) {, +                        if (once.compareAndSet(false, true)) {, +                            s.onSuccess(value);, +                        }, +                    }, +, +                    @Override, +                    public void onError(Throwable e) {, +                        if (once.compareAndSet(false, true)) {, +                            s.onError(e);, +                        } else {, +                            RxJavaPlugins.onError(e);, +                        }, +                    }, +                    , +                });, +                c++;, +            }, +            , +            if (c == 0 && !set.isDisposed()) {, +                s.onError(new NoSuchElementException());, +            }, +        });, +    }, +    , +    @SafeVarargs, +    @SuppressWarnings("unchecked"), +    public static <T> Single<T> amb(Single<? extends T>... sources) {, +        if (sources.length == 0) {, +            return error(() -> new NoSuchElementException());, +        }, +        if (sources.length == 1) {, +            return (Single<T>)sources[0];, +        }, +        return create(s -> {, +            AtomicBoolean once = new AtomicBoolean();, +            CompositeDisposable set = new CompositeDisposable();, +            s.onSubscribe(set);, +            , +            for (Single<? extends T> s1 : sources) {, +                if (once.get()) {, +                    return;, +                }, +                , +                s1.subscribe(new SingleSubscriber<T>() {, +, +                    @Override, +                    public void onSubscribe(Disposable d) {, +                        set.add(d);, +                    }, +, +                    @Override, +                    public void onSuccess(T value) {, +                        if (once.compareAndSet(false, true)) {, +                            s.onSuccess(value);, +                        }, +                    }]