[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, +        Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, +        if (d == EmptyDisposable.INSTANCE) {, +            return d;, +        }, +            Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, +                    periodInNanoseconds), initialDelay, unit);, +, +            if (d == EmptyDisposable.INSTANCE) {, +                return d;, +            }, +            first.replace(d);, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, +        Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, +        if (d == EmptyDisposable.INSTANCE) {, +            return d;, +        }, +            Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, +                    periodInNanoseconds), initialDelay, unit);, +, +            if (d == EmptyDisposable.INSTANCE) {, +                return d;, +            }, +            first.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java, +                actual.onError(new CompositeException(t, e));, +            done = true;, +                actual.onError(new CompositeException(t, e));, +            done = true;, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, +        Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, +        if (d == EmptyDisposable.INSTANCE) {, +            return d;, +        }, +            Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, +                    periodInNanoseconds), initialDelay, unit);, +, +            if (d == EmptyDisposable.INSTANCE) {, +                return d;, +            }, +            first.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java, +                actual.onError(new CompositeException(t, e));, +            done = true;, +                actual.onError(new CompositeException(t, e));, +            done = true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java, +        Worker worker = scheduler.createWorker();, +            source.subscribe(new PublisherObserveOnConditionalSubscriber<T>(, +                    (ConditionalSubscriber<? super T>) s, worker, delayError, prefetch));, +        } else {, +    }, +                clear();, +                        clear();, +                        s.request(prefetch);, +                s.request(prefetch);, +                    if (q.isEmpty()) {, +                if (e == r && checkTerminated(done, q.isEmpty(), a)) {, +                        s.request(prefetch);, +                s.request(prefetch);, +                    if (q.isEmpty()) {, +                if (emitted == r && checkTerminated(done, q.isEmpty(), a)) {, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, +        Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, +        if (d == EmptyDisposable.INSTANCE) {, +            return d;, +        }, +            Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, +                    periodInNanoseconds), initialDelay, unit);, +, +            if (d == EmptyDisposable.INSTANCE) {, +                return d;, +            }, +            first.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java, +                actual.onError(new CompositeException(t, e));, +            done = true;, +                actual.onError(new CompositeException(t, e));, +            done = true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java, +        Worker worker = scheduler.createWorker();, +            source.subscribe(new PublisherObserveOnConditionalSubscriber<T>(, +                    (ConditionalSubscriber<? super T>) s, worker, delayError, prefetch));, +        } else {, +    }, +                clear();, +                        clear();, +                        s.request(prefetch);, +                s.request(prefetch);, +                    if (q.isEmpty()) {, +                if (e == r && checkTerminated(done, q.isEmpty(), a)) {, +                        s.request(prefetch);, +                s.request(prefetch);, +                    if (q.isEmpty()) {, +                if (emitted == r && checkTerminated(done, q.isEmpty(), a)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java]