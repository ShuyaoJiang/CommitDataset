[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, +        final Scheduler.Worker worker;, +            if (restartTimerOnMaxSize) {, +                worker = scheduler.createWorker();, +            } else {, +                worker = null;, +            }, +                    d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, +            Worker w = worker;, +            if (w != null) {, +                w.dispose();, +            }, +                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, +                            count = 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, +        final Scheduler.Worker worker;, +            if (restartTimerOnMaxSize) {, +                worker = scheduler.createWorker();, +            } else {, +                worker = null;, +            }, +                    d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, +            Worker w = worker;, +            if (w != null) {, +                w.dispose();, +            }, +                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, +                            count = 0;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java, +        final Scheduler.Worker worker;, +, +            if (restartTimerOnMaxSize) {, +                worker = scheduler.createWorker();, +            } else {, +                worker = null;, +            }, +                    d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, +            Worker w = worker;, +            if (w != null) {, +                w.dispose();, +            }, +                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, +                            count = 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, +        final Scheduler.Worker worker;, +            if (restartTimerOnMaxSize) {, +                worker = scheduler.createWorker();, +            } else {, +                worker = null;, +            }, +                    d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, +            Worker w = worker;, +            if (w != null) {, +                w.dispose();, +            }, +                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, +                            count = 0;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java, +        final Scheduler.Worker worker;, +, +            if (restartTimerOnMaxSize) {, +                worker = scheduler.createWorker();, +            } else {, +                worker = null;, +            }, +                    d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, +            Worker w = worker;, +            if (w != null) {, +                w.dispose();, +            }, +                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, +                            count = 0;, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java, +, +    @Test, +    public void periodicWindowCompletion() {, +        TestScheduler scheduler = new TestScheduler();, +        FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();, +, +        TestSubscriber<Flowable<Integer>> ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, Long.MAX_VALUE, false), +        .test();, +, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +, +        ts.assertValueCount(21), +        .assertNoErrors(), +        .assertNotComplete();, +, +    @Test, +    public void periodicWindowCompletionRestartTimer() {, +        TestScheduler scheduler = new TestScheduler();, +        FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();, +, +        TestSubscriber<Flowable<Integer>> ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, Long.MAX_VALUE, true), +        .test();, +, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +, +        ts.assertValueCount(21), +        .assertNoErrors()]