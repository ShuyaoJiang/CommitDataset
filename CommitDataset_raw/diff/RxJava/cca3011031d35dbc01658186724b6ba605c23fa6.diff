[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.exceptions.MissingBackpressureException;, +import rx.internal.util.RxRingBuffer;, + * @param <T>, + *            the common basetype of the source values, + * @param <R>, + *            the result type of the combinator function, +        if (sources.size() > 128) {, +            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , +            // the design of how RxRingBuffer is used in the implementation below., +            throw new IllegalArgumentException("More than 128 sources to combineLatest is not supported.");, +        }, +        }, +            child.setProducer(new SingleSourceProducer<T, R>(child, sources.get(0), combinator));, +        } else {, +            child.setProducer(new MultiSourceProducer<T, R>(child, sources, combinator));, +        }, +, +    }, +, +    /*, +     * benjchristensen => This implementation uses a buffer enqueue/drain pattern. It could be optimized to have a fast-path to, +     * skip the buffer and emit directly when no conflict, but that is quite complicated and I don't have the time to attempt it right now., +     */, +    final static class MultiSourceProducer<T, R> implements Producer {, +        private final AtomicBoolean started = new AtomicBoolean();, +        private final AtomicLong requested = new AtomicLong();, +        private final List<? extends Observable<? extends T>> sources;, +        private final Subscriber<? super R> child;, +        private final FuncN<? extends R> combinator;, +        private final MultiSourceRequestableSubscriber<T, R>[] subscribers;, +, +        /* following are guarded by WIP */, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +        private final Object[] collectedValues;, +        private final BitSet haveValues;, +        private volatile int haveValuesCount; // does this need to be volatile or is WIP sufficient?, +        private final BitSet completion;, +        private volatile int completionCount; // does this need to be volatile or is WIP sufficient?, +, +        @SuppressWarnings("unused"), +        private volatile long counter;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<MultiSourceProducer> WIP = AtomicLongFieldUpdater.newUpdater(MultiSourceProducer.class, "counter");, +, +        @SuppressWarnings("unchecked"), +        public MultiSourceProducer(final Subscriber<? super R> child, final List<? extends Observable<? extends T>> sources, FuncN<? extends R> combinator) {, +            this.sources = sources;, +            this.child = child;, +            this.combinator = combinator;, +, +            int n = sources.size();, +            this.subscribers = new MultiSourceRequestableSubscriber[n];, +            this.collectedValues = new Object[n];, +            this.haveValues = new BitSet(n);, +            this.completion = new BitSet(n);, +        }, +, +        @Override, +        public void request(long n) {, +            requested.getAndAdd(n);, +            if (!started.get() && started.compareAndSet(false, true)) {, +                /*, +                 * NOTE: this logic will ONLY work if we don't have more sources than the size of the buffer., +                 * , +                 * We would likely need to make an RxRingBuffer that can be sized to [numSources * n] instead, +                 * of the current global default size it has., +                 */, +                int sizePerSubscriber = RxRingBuffer.SIZE / sources.size();, +                int leftOver = RxRingBuffer.SIZE % sources.size();, +                for (int i = 0; i < sources.size(); i++) {, +                    Observable<? extends T> o = sources.get(i);, +                    int toRequest = sizePerSubscriber;, +                    if (i == sources.size() - 1) {, +                        toRequest += leftOver;, +                    }, +                    MultiSourceRequestableSubscriber<T, R> s = new MultiSourceRequestableSubscriber<T, R>(i, toRequest, child, this);, +                    subscribers[i] = s;, +                    o.unsafeSubscribe(s);, +                }, +            }, +            tick();, +        }, +, +        /**, +         * This will only allow one thread at a time to do the work, but ensures via `counter` increment/decrement, +         * that there is always once who acts on each `tick`. Same concept as used in OperationObserveOn., +         */, +        @SuppressWarnings("unchecked")]