[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.subjects.Subject, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to push results into the specified {@link Subject}, +  def multicast[R](subject: Subject[T, R]): (() => Subscription, Observable[R]) = {, +    val javaCO = asJava.multicast[R](subject), +    (() => javaCO.connect(), Observable[R](javaCO)), +  }, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def replay(): (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.replay(), +    (() => javaCO.connect(), Observable[T](javaCO)), +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def publish: (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.publish(), +    (() => javaCO.connect(), Observable[T](javaCO)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.subjects.Subject, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to push results into the specified {@link Subject}, +  def multicast[R](subject: Subject[T, R]): (() => Subscription, Observable[R]) = {, +    val javaCO = asJava.multicast[R](subject), +    (() => javaCO.connect(), Observable[R](javaCO)), +  }, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def replay(): (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.replay(), +    (() => javaCO.connect(), Observable[T](javaCO)), +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def publish: (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.publish(), +    (() => javaCO.connect(), Observable[T](javaCO)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def exampleWithoutPublish() {, +    val unshared = Observable(1 to 4), +    unshared.subscribe(n => println(s"subscriber 1 gets $n")), +    unshared.subscribe(n => println(s"subscriber 2 gets $n")), +  }, +  , +  @Test def exampleWithPublish() {, +    val unshared = Observable(1 to 4), +    val (startFunc, shared) = unshared.publish, +    shared.subscribe(n => println(s"subscriber 1 gets $n")), +    shared.subscribe(n => println(s"subscriber 2 gets $n")), +    startFunc(), +  }, +  , +  def doLater(waitTime: Duration, action: () => Unit): Unit = {, +    Observable.interval(waitTime).take(1).subscribe(_ => action()), +  }, +  , +  @Test def exampleWithoutReplay() {, +    val numbers = Observable.interval(1000 millis).take(6), +    val (startFunc, sharedNumbers) = numbers.publish, +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    startFunc(), +    // subscriber 2 misses 0, 1, 2!, +    doLater(3500 millis, () => { sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")) }), +    waitFor(sharedNumbers), +  }, +  , +  @Test def exampleWithReplay() {, +    val numbers = Observable.interval(1000 millis).take(6), +    val (startFunc, sharedNumbers) = numbers.replay, +    sharedNumbers.subscribe(n => println(s"subscriber 1 gets $n")), +    startFunc(), +    // subscriber 2 subscribes later but still gets all numbers, +    doLater(3500 millis, () => { sharedNumbers.subscribe(n => println(s"subscriber 2 gets $n")) }), +    waitFor(sharedNumbers), +  }, +  , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import rx.lang.scala.subjects.Subject, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to push results into the specified {@link Subject}, +  def multicast[R](subject: Subject[T, R]): (() => Subscription, Observable[R]) = {, +    val javaCO = asJava.multicast[R](subject), +    (() => javaCO.connect(), Observable[R](javaCO)), +  }, +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def replay(): (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.replay(), +    (() => javaCO.connect(), Observable[T](javaCO)), +   * @return a pair of a start function and an {@link Observable} such that when the start function, +   *         is called, the Observable starts to emit items to its {@link Observer}s, +  def publish: (() => Subscription, Observable[T]) = {, +    val javaCO = asJava.publish(), +    (() => javaCO.connect(), Observable[T](javaCO)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def exampleWithoutPublish() {, +    val unshared = Observable(1 to 4), +    unshared.subscribe(n => println(s"subscriber 1 gets $n")), +    unshared.subscribe(n => println(s"subscriber 2 gets $n")), +  }, +  ]