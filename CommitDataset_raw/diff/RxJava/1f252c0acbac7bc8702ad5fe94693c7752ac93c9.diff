[+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java, +import java.util.NoSuchElementException;, +                return mostRecentObserver.getIterable();, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /**, +         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one, +         * thread expect {@link Iterator#next()} called from a different thread to work., +         * @return, +         */, +        public Iterator<T> getIterable() {, +            return new Iterator<T>() {, +                /**, +                 * buffer to make sure that the state of the iterator doesn't change between calling hasNext() and next()., +                 */, +                private Object buf = null;, +, +                @Override, +                public boolean hasNext() {, +                    buf = value;, +                    return !nl.isCompleted(buf);, +                @Override, +                public T next() {, +                    try {, +                        // if hasNext wasn't called before calling next., +                        if (buf == null), +                            buf = value;, +                        if (nl.isCompleted(buf)), +                            throw new NoSuchElementException();, +                        if (nl.isError(buf)) {, +                            throw Exceptions.propagate(nl.getError(buf));, +                        }, +                        return nl.getValue(buf);, +                    }, +                    finally {, +                        buf = null;, +                    }, +                @Override, +                public void remove() {, +                    throw new UnsupportedOperationException("Read only iterator");, +            };, +        }, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java, +import java.util.NoSuchElementException;, +                return mostRecentObserver.getIterable();, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /**, +         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one, +         * thread expect {@link Iterator#next()} called from a different thread to work., +         * @return, +         */, +        public Iterator<T> getIterable() {, +            return new Iterator<T>() {, +                /**, +                 * buffer to make sure that the state of the iterator doesn't change between calling hasNext() and next()., +                 */, +                private Object buf = null;, +, +                @Override, +                public boolean hasNext() {, +                    buf = value;, +                    return !nl.isCompleted(buf);, +                @Override, +                public T next() {, +                    try {, +                        // if hasNext wasn't called before calling next., +                        if (buf == null), +                            buf = value;, +                        if (nl.isCompleted(buf)), +                            throw new NoSuchElementException();, +                        if (nl.isError(buf)) {, +                            throw Exceptions.propagate(nl.getError(buf));, +                        }, +                        return nl.getValue(buf);, +                    }, +                    finally {, +                        buf = null;, +                    }, +                @Override, +                public void remove() {, +                    throw new UnsupportedOperationException("Read only iterator");, +            };, +        }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +    private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> f;, +        this.f = f;, +, +        final Observable<?> restarts = f.call(, +        // lifting in a custom operator to kind of do a merge/map/filter thing., +                            // if (!child.isUnsubscribed()) {, +        if (!child.isUnsubscribed()) {, +            child.add(inner.schedule(subscribeToSource));, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java, +import java.util.NoSuchElementException;, +                return mostRecentObserver.getIterable();, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /**, +         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one, +         * thread expect {@link Iterator#next()} called from a different thread to work., +         * @return, +         */]