[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.Pair;, +     * Returns the values from the source observable sequence until the other observable sequence produces a value., +     *, +     * @param source the source sequence to propagate elements for., +     * @param other  the observable sequence that terminates propagation of elements of the source sequence., +     * @param <T>    the type of source., +     * @param <E>    the other type., +     * @return An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation., +     */, +    public static <T, E> Observable<T> takeUntil(final Observable<T> source, final Observable<E> other) {, +        Observable<Pair<Integer, T>> s = source.map(new Func1<T, Pair<Integer, T>>() {, +            @Override, +            public Pair<Integer, T> call(T arg) {, +                return Pair.create(1, arg);, +            }, +        });, +        Observable<Pair<Integer, T>> o = other.map(new Func1<E, Pair<Integer, T>>() {, +            @Override, +            public Pair<Integer, T> call(E arg) {, +                return Pair.create(2, null);, +            }, +        });, +, +        return Observable.merge(s, o).takeWhile(new Func1<Pair<Integer, T>, Boolean>() {, +            @Override, +            public Boolean call(Pair<Integer, T> pair) {, +                return pair.getFirst() == 1;, +            }, +        }).map(new Func1<Pair<Integer, T>, T>() {, +            @Override, +            public T call(Pair<Integer, T> pair) {, +                return pair.getSecond();, +            }, +        });, +    }, +, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.Pair;, +     * Returns the values from the source observable sequence until the other observable sequence produces a value., +     *, +     * @param source the source sequence to propagate elements for., +     * @param other  the observable sequence that terminates propagation of elements of the source sequence., +     * @param <T>    the type of source., +     * @param <E>    the other type., +     * @return An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation., +     */, +    public static <T, E> Observable<T> takeUntil(final Observable<T> source, final Observable<E> other) {, +        Observable<Pair<Integer, T>> s = source.map(new Func1<T, Pair<Integer, T>>() {, +            @Override, +            public Pair<Integer, T> call(T arg) {, +                return Pair.create(1, arg);, +            }, +        });, +        Observable<Pair<Integer, T>> o = other.map(new Func1<E, Pair<Integer, T>>() {, +            @Override, +            public Pair<Integer, T> call(E arg) {, +                return Pair.create(2, null);, +            }, +        });, +, +        return Observable.merge(s, o).takeWhile(new Func1<Pair<Integer, T>, Boolean>() {, +            @Override, +            public Boolean call(Pair<Integer, T> pair) {, +                return pair.getFirst() == 1;, +            }, +        }).map(new Func1<Pair<Integer, T>, T>() {, +            @Override, +            public T call(Pair<Integer, T> pair) {, +                return pair.getSecond();, +            }, +        });, +    }, +, +, +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java, +        return merge(Observable.create(new Func1<Observer<Observable<T>>, Subscription>() {, +            private volatile boolean unsubscribed = false;, +, +            @Override, +            public Subscription call(Observer<Observable<T>> observer) {, +                for (Observable<T> o : sequences) {, +                    if (!unsubscribed) {, +                        observer.onNext(o);, +                    } else {, +                        // break out of the loop if we are unsubscribed, +                        break;, +                    }, +                }, +                if (!unsubscribed) {, +                    observer.onCompleted();, +                }, +                return new Subscription() {, +, +                    @Override, +                    public void unsubscribe() {, +                        unsubscribed = true;]