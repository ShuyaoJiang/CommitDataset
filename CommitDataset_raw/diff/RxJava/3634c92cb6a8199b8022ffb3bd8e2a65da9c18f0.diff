[+++ b/src/main/java/io/reactivex/Flowable.java, +                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);, +++ b/src/main/java/io/reactivex/Flowable.java, +                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, +        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, +import java.util.*;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.concurrent.locks.*;, +import org.reactivestreams.*;, +, +import io.reactivex.disposables.Disposable;, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.internal.queue.SpscArrayQueue;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.ExceptionHelper;, +, +    static final class BlockingFlowableIterator<T>, +    extends AtomicReference<Subscription>, +    implements Subscriber<T>, Iterator<T>, Runnable, Disposable {, +, +        private static final long serialVersionUID = 6695226475494099826L;, +, +        final SpscArrayQueue<T> queue;, +, +        final long batchSize;, +, +        final long limit;, +, +        final Lock lock;, +, +        final Condition condition;, +, +        long produced;, +, +        volatile boolean done;, +        Throwable error;, +, +        BlockingFlowableIterator(int batchSize) {, +            this.queue = new SpscArrayQueue<T>(batchSize);, +            this.batchSize = batchSize;, +            this.limit = batchSize - (batchSize >> 2);, +            this.lock = new ReentrantLock();, +            this.condition = lock.newCondition();, +        }, +, +        @Override, +        public boolean hasNext() {, +            for (;;) {, +                boolean d = done;, +                boolean empty = queue.isEmpty();, +                if (d) {, +                    Throwable e = error;, +                    if (e != null) {, +                        throw ExceptionHelper.wrapOrThrow(e);, +                    } else, +                    if (empty) {, +                        return false;, +                    }, +                }, +                if (empty) {, +                    lock.lock();, +                    try {, +                        while (!done && queue.isEmpty()) {, +                            condition.await();, +                        }, +                    } catch (InterruptedException ex) {, +                        run();, +                        throw ExceptionHelper.wrapOrThrow(ex);, +                    } finally {, +                        lock.unlock();, +                    }, +                } else {, +                    return true;, +                }, +            }, +        }, +, +        @Override, +        public T next() {, +            if (hasNext()) {, +                T v = queue.poll();, +, +                long p = produced + 1;, +                if (p == limit) {, +                    produced = 0;, +                    get().request(p);, +                } else {, +                    produced = p;, +                }, +, +                return v;, +            }, +            throw new NoSuchElementException();, +        }]