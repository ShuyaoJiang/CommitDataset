[+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import java.util.concurrent.atomic.AtomicReference;, +import rx.subjects.PublishSubject;, +    static final Func1<Observable<? extends Notification<?>>, Observable<?>> REDO_INIFINITE = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {, +        return retry(source, REDO_INIFINITE);, +        return repeat(source, REDO_INIFINITE, scheduler);, +    private Observable<T> source;, +    private boolean stopOnComplete;, +    private boolean stopOnError;, +        final AtomicBoolean isLocked = new AtomicBoolean(true);, +        final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        final PublishSubject<Notification<?>> terminals = PublishSubject.create();, +                            currentProducer.set(null);, +                            currentProducer.set(null);, +                            if (consumerCapacity.get() != Long.MAX_VALUE) {, +                                consumerCapacity.decrementAndGet();, +                            }, +                        currentProducer.set(producer);, +                        long c = consumerCapacity.get();, +                        if (c > 0) {, +                            producer.request(c);, +                        }, +                                if (t.isOnCompleted() && stopOnComplete), +                                    child.onCompleted();, +                                else if (t.isOnError() && stopOnError), +                                    child.onError(t.getThrowable());, +                                else {, +                                    isLocked.set(false);, +                        if (!isLocked.get() && !child.isUnsubscribed()) {, +                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import java.util.concurrent.atomic.AtomicReference;, +import rx.subjects.PublishSubject;, +    static final Func1<Observable<? extends Notification<?>>, Observable<?>> REDO_INIFINITE = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {, +        return retry(source, REDO_INIFINITE);, +        return repeat(source, REDO_INIFINITE, scheduler);, +    private Observable<T> source;, +    private boolean stopOnComplete;, +    private boolean stopOnError;, +        final AtomicBoolean isLocked = new AtomicBoolean(true);, +        final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        final PublishSubject<Notification<?>> terminals = PublishSubject.create();, +                            currentProducer.set(null);, +                            currentProducer.set(null);, +                            if (consumerCapacity.get() != Long.MAX_VALUE) {, +                                consumerCapacity.decrementAndGet();, +                            }, +                        currentProducer.set(producer);, +                        long c = consumerCapacity.get();, +                        if (c > 0) {, +                            producer.request(c);, +                        }, +                                if (t.isOnCompleted() && stopOnComplete), +                                    child.onCompleted();, +                                else if (t.isOnError() && stopOnError), +                                    child.onError(t.getThrowable());, +                                else {, +                                    isLocked.set(false);, +                        if (!isLocked.get() && !child.isUnsubscribed()) {, +                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java, +import rx.internal.producers.ProducerArbiter;, +        ProducerArbiter arbiter = new ProducerArbiter();, +        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child, ssub, arbiter, alternate);, +        child.setProducer(arbiter);, +    private static final class ParentSubscriber<T> extends Subscriber<T> {, +        private boolean empty = true;, +        private final SerialSubscription ssub;, +        private final ProducerArbiter arbiter;, +        private final Observable<? extends T> alternate;, +        ParentSubscriber(Subscriber<? super T> child, final SerialSubscription ssub, ProducerArbiter arbiter, Observable<? extends T> alternate) {, +            this.arbiter = arbiter;, +            this.alternate = alternate;, +            arbiter.setProducer(producer);, +            AlternateSubscriber<T> as = new AlternateSubscriber<T>(child, arbiter);, +            ssub.set(as);, +            alternate.unsafeSubscribe(as);, +        }, +, +        @Override, +        public void onError(Throwable e) {, +            child.onError(e);, +        }, +, +        @Override, +        public void onNext(T t) {, +            empty = false;, +            child.onNext(t);, +            arbiter.produced(1);, +        }]