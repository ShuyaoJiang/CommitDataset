[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * Schedules an Action for recursively repeated execution., +   *, +   * @param action the Action to schedule recursively, +   * @return a subscription to be able to unsubscribe the action, +   */, +  def scheduleRec(action: => Unit): Subscription = {, +    def work: Unit = {, +      action, +      if (!this.isUnsubscribed) {, +        this.schedule(work), +      }, +    }, +    this.schedule(work), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * Schedules an Action for recursively repeated execution., +   *, +   * @param action the Action to schedule recursively, +   * @return a subscription to be able to unsubscribe the action, +   */, +  def scheduleRec(action: => Unit): Subscription = {, +    def work: Unit = {, +      action, +      if (!this.isUnsubscribed) {, +        this.schedule(work), +      }, +    }, +    this.schedule(work), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "aggregate(Func2[T, T, T])" -> "reduce((U, U) => U)",, +      "aggregate(R, Func2[R, _ >: T, R])" -> "foldLeft(R)((R, T) => R)",, +      "groupBy(Func1[_ >: T, _ <: K], Func1[_ >: T, _ <: R])" -> "[use `groupBy` and `map`]",, +      "mapWithIndex(Func2[_ >: T, Integer, _ <: R])" -> "[combine `zipWithIndex` with `map` or with a for comprehension]",, +      "publish(T)" -> "publish(U)",, +      "publish(Func1[_ >: Observable[T], _ <: Observable[R]])" -> "publish(Observable[U] => Observable[R])",, +      "publish(Func1[_ >: Observable[T], _ <: Observable[R]], T)" -> "publish(Observable[U] => Observable[R], U)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]])" -> "replay(Observable[U] => Observable[R])",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int)" -> "replay(Observable[U] => Observable[R], Int)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Long, TimeUnit)" -> "replay(Observable[U] => Observable[R], Int, Duration)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Long, TimeUnit, Scheduler)" -> "replay(Observable[U] => Observable[R], Int, Duration, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Scheduler)" -> "replay(Observable[U] => Observable[R], Int, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Long, TimeUnit)" -> "replay(Observable[U] => Observable[R], Duration)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Long, TimeUnit, Scheduler)" -> "replay(Observable[U] => Observable[R], Duration, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Scheduler)" -> "replay(Observable[U] => Observable[R], Scheduler)",, +      "skipUntil(Observable[U])" -> "dropUntil(Observable[E])",, +      "startWith(Array[T])" -> "[use `Observable.items(items) ++ o`]",, +      "timeout(Func0[_ <: Observable[U]], Func1[_ >: T, _ <: Observable[V]], Observable[_ <: T])" -> "timeout(() => Observable[U], T => Observable[V], Observable[O])",, +      "timeout(Func1[_ >: T, _ <: Observable[V]], Observable[_ <: T])" -> "timeout(() => Observable[U], T => Observable[V])",, +      "average(Observable[Integer])" -> averageProblem,, +      "averageDoubles(Observable[Double])" -> averageProblem,, +      "averageFloats(Observable[Float])" -> averageProblem,, +      "averageLongs(Observable[Long])" -> averageProblem,, +      "from(Array[T])" -> "items(T*)",, +      "pivot(Observable[GroupedObservable[K1, GroupedObservable[K2, T]]])" -> "pivot(<:<[Observable[T], Observable[(K1, Observable[(K2, Observable[U])])]])",, +      "sum(Observable[Integer])" -> "sum(Numeric[U])",, +      "sumDoubles(Observable[Double])" -> "sum(Numeric[U])",, +      "sumFloats(Observable[Float])" -> "sum(Numeric[U])",, +      "sumLongs(Observable[Long])" -> "sum(Numeric[U])",, +      "switchDo(Observable[_ <: Observable[_ <: T]])" -> deprecated,, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * Schedules an Action for recursively repeated execution., +   *, +   * @param action the Action to schedule recursively, +   * @return a subscription to be able to unsubscribe the action, +   */, +  def scheduleRec(action: => Unit): Subscription = {, +    def work: Unit = {, +      action, +      if (!this.isUnsubscribed) {, +        this.schedule(work), +      }, +    }, +    this.schedule(work), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "aggregate(Func2[T, T, T])" -> "reduce((U, U) => U)",, +      "aggregate(R, Func2[R, _ >: T, R])" -> "foldLeft(R)((R, T) => R)",, +      "groupBy(Func1[_ >: T, _ <: K], Func1[_ >: T, _ <: R])" -> "[use `groupBy` and `map`]",, +      "mapWithIndex(Func2[_ >: T, Integer, _ <: R])" -> "[combine `zipWithIndex` with `map` or with a for comprehension]",, +      "publish(T)" -> "publish(U)",, +      "publish(Func1[_ >: Observable[T], _ <: Observable[R]])" -> "publish(Observable[U] => Observable[R])",, +      "publish(Func1[_ >: Observable[T], _ <: Observable[R]], T)" -> "publish(Observable[U] => Observable[R], U)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]])" -> "replay(Observable[U] => Observable[R])",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int)" -> "replay(Observable[U] => Observable[R], Int)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Long, TimeUnit)" -> "replay(Observable[U] => Observable[R], Int, Duration)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Long, TimeUnit, Scheduler)" -> "replay(Observable[U] => Observable[R], Int, Duration, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Int, Scheduler)" -> "replay(Observable[U] => Observable[R], Int, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Long, TimeUnit)" -> "replay(Observable[U] => Observable[R], Duration)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Long, TimeUnit, Scheduler)" -> "replay(Observable[U] => Observable[R], Duration, Scheduler)",, +      "replay(Func1[_ >: Observable[T], _ <: Observable[R]], Scheduler)" -> "replay(Observable[U] => Observable[R], Scheduler)",, +      "skipUntil(Observable[U])" -> "dropUntil(Observable[E])",, +      "startWith(Array[T])" -> "[use `Observable.items(items) ++ o`]",]