[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @param elementSelector, +     *            a function that extracts the return element for each item, +     * @param <K>, +     *            the key type, +     * @param <R>, +     *            the element type, +     * @return an {@code Observable} that emits {@link GroupedObservable}s, each of which corresponds to a, +     *         unique key value and each of which emits those items from the source Observable that share that, +     *         key value, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava wiki: groupBy</a>, +     * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.groupby.aspx">MSDN: Observable.GroupBy</a>, +     */, +    public final <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) {, +        return lift(new OperatorGroupBy<T, K, R>(keySelector, elementSelector));, +    }, +    , +    /**, +     * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these, +     * grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group., +     * <p>, +     * <img width="640" height="360" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png" alt="">, +     * <p>, +     * <em>Note:</em> A {@link GroupedObservable} will cache the items it is to emit until such time as it, +     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, +     * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may, +     * discard their buffers by applying an operator like {@link #take}{@code (0)} to them., +     * <dl>, +     *  <dt><b>Backpressure Support:</b></dt>, +     *  <dd>This operator does not support backpressure as splitting a stream effectively turns it into a "hot, +     *      observable" and blocking any one group would block the entire parent stream. If you need, +     *      backpressure on individual groups then you should use operators such as {@link #onBackpressureDrop}, +     *      or {@link #onBackpressureBuffer}.</dd>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     * , +     * @param keySelector, +     *            a function that extracts the key for each item, +        return lift(new OperatorGroupBy<T, K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @param elementSelector, +     *            a function that extracts the return element for each item, +     * @param <K>, +     *            the key type, +     * @param <R>, +     *            the element type, +     * @return an {@code Observable} that emits {@link GroupedObservable}s, each of which corresponds to a, +     *         unique key value and each of which emits those items from the source Observable that share that, +     *         key value, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava wiki: groupBy</a>, +     * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.groupby.aspx">MSDN: Observable.GroupBy</a>, +     */, +    public final <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) {, +        return lift(new OperatorGroupBy<T, K, R>(keySelector, elementSelector));, +    }, +    , +    /**, +     * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these, +     * grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group., +     * <p>, +     * <img width="640" height="360" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png" alt="">, +     * <p>, +     * <em>Note:</em> A {@link GroupedObservable} will cache the items it is to emit until such time as it, +     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those, +     * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may, +     * discard their buffers by applying an operator like {@link #take}{@code (0)} to them., +     * <dl>, +     *  <dt><b>Backpressure Support:</b></dt>, +     *  <dd>This operator does not support backpressure as splitting a stream effectively turns it into a "hot, +     *      observable" and blocking any one group would block the entire parent stream. If you need, +     *      backpressure on individual groups then you should use operators such as {@link #onBackpressureDrop}, +     *      or {@link #onBackpressureBuffer}.</dd>, +     *  <dt><b>Scheduler:</b></dt>, +     *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     * , +     * @param keySelector, +     *            a function that extracts the key for each item, +        return lift(new OperatorGroupBy<T, K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, +public final class OperatorGroupBy<T, K, R> implements Operator<GroupedObservable<K, R>, T> {, +    final Func1<? super T, ? extends R> elementSelector;, +    @SuppressWarnings("unchecked"), +        this(keySelector, (Func1<T, R>)IDENTITY);, +    }, +    , +    public OperatorGroupBy(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends R> elementSelector) {, +        this.elementSelector = elementSelector;, +    public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, R>> child) {, +        return new GroupBySubscriber<K, T, R>(keySelector, elementSelector, child);, +    static final class GroupBySubscriber<K, T, R> extends Subscriber<T> {, +        final Func1<? super T, ? extends R> elementSelector;, +        final Subscriber<? super GroupedObservable<K, R>> child;, +        public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends R> elementSelector, Subscriber<? super GroupedObservable<K, R>> child) {, +            this.elementSelector = elementSelector;, +                    GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {, +                        public void call(final Subscriber<? super R> o) {, +                                    o.onNext(elementSelector.call(t));, +    ]