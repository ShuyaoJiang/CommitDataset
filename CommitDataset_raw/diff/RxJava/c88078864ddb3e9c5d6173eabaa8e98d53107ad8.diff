[+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +import java.util.Collection;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.functions.Action0;, +import rx.subscriptions.Subscriptions;, +        private final Selection<T> selection;, +        private AmbSubscriber(long requested, Subscriber<? super T> subscriber, Selection<T> selection) {, +            this.selection = selection;, +            // initial request, +            request(requested);, +        private final void requestMore(long n) {, +            if (selection.choice.get() == this) {, +                // fast-path, +                return true;, +            } else {, +                if (selection.choice.compareAndSet(null, this)) {, +                    selection.unsubscribeOthers(this);, +                    return true;, +                } else {, +                    // we lost so unsubscribe ... and force cleanup again due to possible race conditions, +                    selection.unsubscribeLosers();, +                    return false;, +            }, +    private static class Selection<T> {, +        final AtomicReference<AmbSubscriber<T>> choice = new AtomicReference<AmbSubscriber<T>>();, +        final Collection<AmbSubscriber<T>> ambSubscribers = new ConcurrentLinkedQueue<AmbSubscriber<T>>();, +, +        public void unsubscribeLosers() {, +            AmbSubscriber<T> winner = choice.get();, +            if(winner != null) {, +                unsubscribeOthers(winner);, +            }, +        }, +        , +        public void unsubscribeOthers(AmbSubscriber<T> notThis) {, +            for (AmbSubscriber<T> other : ambSubscribers) {, +                if (other != notThis) {, +                    other.unsubscribe();, +                }, +            }, +            ambSubscribers.clear();, +        }, +, +    }, +, +    private final Selection<T> selection = new Selection<T>();, +    public void call(final Subscriber<? super T> subscriber) {, +        subscriber.add(Subscriptions.create(new Action0() {, +, +            @Override, +            public void call() {, +                if (selection.choice.get() != null) {, +                    // there is a single winner so we unsubscribe it, +                    selection.choice.get().unsubscribe();, +                } , +                // if we are racing with others still existing, we'll also unsubscribe them, +                if(!selection.ambSubscribers.isEmpty()) {, +                    for (AmbSubscriber<T> other : selection.ambSubscribers) {, +                        other.unsubscribe();, +                    }, +                    selection.ambSubscribers.clear();, +                }, +            }, +            , +        }));, +        subscriber.setProducer(new Producer() {, +, +            @Override, +            public void request(long n) {, +                if (selection.choice.get() != null) {, +                    // propagate the request to that single Subscriber that won, +                    selection.choice.get().requestMore(n);, +                } else {, +                        AmbSubscriber<T> ambSubscriber = new AmbSubscriber<T>(n, subscriber, selection);, +                        selection.ambSubscribers.add(ambSubscriber);, +                        // possible race condition in previous lines ... a choice may have been made so double check (instead of synchronizing), +                        if (selection.choice.get() != null) {, +                            // Already chose one, the rest can be skipped and we can clean up, +                            selection.unsubscribeOthers(selection.choice.get());, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +import java.util.Collection;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.functions.Action0;, +import rx.subscriptions.Subscriptions;, +        private final Selection<T> selection;, +        private AmbSubscriber(long requested, Subscriber<? super T> subscriber, Selection<T> selection) {, +            this.selection = selection;, +            // initial request, +            request(requested);, +        private final void requestMore(long n) {, +            if (selection.choice.get() == this) {, +                // fast-path, +                return true;, +            } else {, +                if (selection.choice.compareAndSet(null, this)) {, +                    selection.unsubscribeOthers(this);, +                    return true;, +                } else {]