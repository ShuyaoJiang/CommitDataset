[+++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +/*, + * To remove all method bodies from Observable.java and to comment out the signatures,, + * use this regex (works within Eclipse except for 1 long complex method), + * find: `^    public(.*)\{\s*?\n(.|\n)*?^    }`, + * replace with: `    // public$1`, + */, +, +import org.scalatest.junit.JUnitSuite, +, +  import scala.concurrent.duration.Duration, +  import rx.lang.scala.observables._, +  def onErrorResumeNext[U >: T](resumeFunction: Throwable => Observable[U]): Observable[U] = {, +    val f: rx.util.functions.Func1[Throwable, rx.Observable[_ <: U]] = (t: Throwable) => resumeFunction(t).asJava, +    val f2 = f.asInstanceOf[rx.util.functions.Func1[Throwable, rx.Observable[Nothing]]], +    new Observable[U](asJava.onErrorResumeNext(f2)), +  def onErrorResumeNext[U >: T](resumeSequence: Observable[U]): Observable[U] = {, +    val rSeq1: rx.Observable[_ <: U] = resumeSequence.asJava, +    val rSeq2: rx.Observable[Nothing] = rSeq1.asInstanceOf[rx.Observable[Nothing]], +    new Observable[U](asJava.onErrorResumeNext(rSeq2)), +  }, +  def onExceptionResumeNext[U >: T](resumeSequence: Observable[U]): Observable[U] = {, +    val rSeq1: rx.Observable[_ <: U] = resumeSequence.asJava, +    val rSeq2: rx.Observable[Nothing] = rSeq1.asInstanceOf[rx.Observable[Nothing]], +    new Observable[U](asJava.onExceptionResumeNext(rSeq2)), +  def onErrorReturn[U >: T](resumeFunction: Throwable => U): Observable[U] = {, +    val f1: rx.util.functions.Func1[Throwable, _ <: U] = resumeFunction, +    val f2 = f1.asInstanceOf[rx.util.functions.Func1[Throwable, Nothing]], +    new Observable[U](asJava.onErrorReturn(f2)), +    val func2 = func.asInstanceOf[rx.util.functions.Func2[Any, Any, Nothing]], +    new Observable[U](asJava.reduce(func2)), +  def sample(duration: Duration): Observable[T] = {, +    new Observable[T](asJava.sample(duration.length, duration.unit)), +  }, +  def sample(duration: Duration, scheduler: Scheduler): Observable[T] = {, +    new Observable[T](asJava.sample(duration.length, duration.unit, scheduler)), +  }, +   * TODO Java list or Scala list?, +  , +  // There is no method , +  // def startWith[U >: T](values: U*): Observable[U], +  // because we can just use ++ instead , +   * Given an Observable that emits Observables, creates a single Observable that, +   * emits the items emitted by the most recently published of those Observables., +   * <p>, +   * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">, +   * , +   * @param sequenceOfSequences, +   *            the source Observable that emits Observables, +   * @return an Observable that emits only the items emitted by the most recently published, +   *         Observable, +   */, +  def switch[U](implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJava), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJava, +    val o5 = rx.Observable.switchOnNext[U](o4), +    new Observable[U](o5), +  }, +  // TODO naming: follow C# (switch) or Java (switchOnNext)?, +  // public static <T> Observable<T> switchOnNext(Observable<? extends Observable<? extends T>> sequenceOfSequences) , +  , +  /**, +  def toBlockingObservable: BlockingObservable[T] = {, +    new BlockingObservable[T](asJava.toBlockingObservable()), +  // There's no , +  // here because that's an instance method., +  import org.junit.{Before, Test, Ignore}, +  @Ignore def testCovariance = {, +    println("hey, you shouldn't run this test"), +    , +    assertEquals(4, Observable(1, 2, 3, 4).toBlockingObservable.last), +  @Test def testStartWithUnnecessary() {, +    val before = Observable(-2, -1, 0), +    val source = Observable(1, 2, 3), +    before ++ source, +  }, +  , +    assertEquals(demat.toBlockingObservable.toIterable.toList, List(1, 2, 3)), +  @Test def testSwitchNoTiming() {, +    val o = Observable(Observable(1, 2), Observable(3, 4)), +    println(o.switch.toBlockingObservable.toIterable.toList), +  }, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +/*, + * To remove all method bodies from Observable.java and to comment out the signatures,, + * use this regex (works within Eclipse except for 1 long complex method), + * find: `^    public(.*)\{\s*?\n(.|\n)*?^    }`, + * replace with: `    // public$1`, + */, +, +import org.scalatest.junit.JUnitSuite, +, +  import scala.concurrent.duration.Duration, +  import rx.lang.scala.observables._, +  def onErrorResumeNext[U >: T](resumeFunction: Throwable => Observable[U]): Observable[U] = {, +    val f: rx.util.functions.Func1[Throwable, rx.Observable[_ <: U]] = (t: Throwable) => resumeFunction(t).asJava]