[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, +    private final boolean isTrusted;, +        this(null, false);, +        this(onSubscribe, false);, +    }, +, +    /**, +     * @param onSubscribe, +     *            {@link Func1} to be executed when {@link #subscribe(Observer)} is called., +     * @param isTrusted, +     *            boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., +     */, +    private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +        this.isTrusted = isTrusted;, +            if (isTrusted) {, +        return subscribe(new Observer() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        subscribe(new Observer<T>() {, +            }, true);, +            }, true);, +    /*, +     * Private version that creates a 'trusted' Observable to allow performance optimizations., +     */, +    private static <T> Observable<T> _create(Func1<Observer<T>, Subscription> func) {, +        return new Observable<T>(func, true);, +    }, +, +        return _create(OperationFilter.filter(that, predicate));, +     * Asynchronously subscribes and unsubscribes observers on the specified scheduler., +     *, +     * @param source    the source observable., +     * @param scheduler the scheduler to perform subscription and unsubscription actions on., +     * @param <T> the type of observable., +     * @return the source sequence whose subscriptions and unsubscriptions happen on the specified scheduler., +     */, +    public static <T> Observable<T> subscribeOn(Observable<T> source, Scheduler scheduler) {, +        return _create(OperationSubscribeOn.subscribeOn(source, scheduler));, +    }, +, +    /**, +     * Asynchronously notify observers on the specified scheduler., +     *, +     * @param source    the source observable., +     * @param scheduler the scheduler to notify observers on., +     * @param <T>       the type of observable., +     * @return the source sequence whose observations happen on the specified scheduler., +     */, +    public static <T> Observable<T> observeOn(Observable<T> source, Scheduler scheduler) {, +        return _create(OperationObserveOn.observeOn(source, scheduler));, +    }, +, +    /**, +        return _create(OperationDefer.defer(observableFactory));, +        return _create(OperationDefer.defer(new Func0<Observable<T>>() {, +        return _create(OperationMap.map(sequence, func));, +        return _create(OperationMap.mapMany(sequence, func));, +        return _create(OperationMaterialize.materialize(sequence));, +        return _create(OperationDematerialize.dematerialize(sequence));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationConcat.concat(source));, +        return _create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, +        return _create(OperatorGroupBy.groupBy(source, keySelector));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(that, resumeFunction));, +        return _create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(that, resumeSequence));, +        return _create(OperationOnErrorReturn.onErrorReturn(that, resumeFunction));, +        return takeLast(_create(OperationScan.scan(sequence, accumulator)), 1);, +        return takeLast(_create(OperationScan.scan(sequence, initialValue, accumulator)), 1);, +        return _create(OperationScan.scan(sequence, accumulator));, +        return _create(OperationScan.scan(sequence, initialValue, accumulator));, +        return _create(OperationSkip.skip(items, num));, +        return _create(OperationSynchronize.synchronize(observable));, +        return _create(OperationTake.take(items, num));, +        return _create(OperationTakeLast.takeLast(items, count));]