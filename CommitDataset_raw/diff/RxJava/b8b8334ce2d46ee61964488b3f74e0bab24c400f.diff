[+++ b/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java, +import static org.mockito.Matchers.*;, +import rx.util.functions.Action1;, +, +    @Test, +    @SuppressWarnings("unchecked"), +    public void testThreadName() throws InterruptedException {, +        Observable<String> obs = Observable.from("one", null, "two", "three", "four");, +, +        Observer<String> observer = mock(Observer.class);, +, +        InOrder inOrder = inOrder(observer);, +, +        final CountDownLatch completedLatch = new CountDownLatch(1);, +        doAnswer(new Answer<Void>() {, +, +            @Override, +            public Void answer(InvocationOnMock invocation) throws Throwable {, +                completedLatch.countDown();, +, +                return null;, +            }, +        }).when(observer).onCompleted();, +, +        doAnswer(new Answer<Void>() {, +, +            @Override, +            public Void answer(InvocationOnMock invocation) throws Throwable {, +                completedLatch.countDown();, +, +                return null;, +            }, +        }).when(observer).onError(any(Exception.class));, +, +        obs.observeOn(Schedulers.newThread()).doOnEach(new Action1<String>() {, +, +            @Override, +            public void call(String t1) {, +                String threadName = Thread.currentThread().getName();, +                boolean correctThreadName = threadName.startsWith("RxNewThreadScheduler");, +                System.out.println("ThreadName: " + threadName + "  Correct => " + correctThreadName);, +                assertTrue(correctThreadName);, +            }, +, +        }).subscribe(observer);, +, +        if (!completedLatch.await(1000, TimeUnit.MILLISECONDS)) {, +            fail("timed out waiting");, +        }, +, +        inOrder.verify(observer, times(1)).onCompleted();, +    }]