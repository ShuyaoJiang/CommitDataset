[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (deferred.isCancelled()) {, +                RxJavaPlugins.onError(ex);, +            } else {, +            }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (deferred.isCancelled()) {, +                RxJavaPlugins.onError(ex);, +            } else {, +            }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java, +import static org.junit.Assert.assertEquals;, +import static org.mockito.ArgumentMatchers.any;, +import java.util.List;, +import io.reactivex.exceptions.TestException;, +import io.reactivex.plugins.RxJavaPlugins;, +, +    @Test(timeout = 5000), +    public void undeliverableUponCancellation() throws Exception {, +        List<Throwable> errors = TestHelper.trackPluginErrors();, +        try {, +            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +, +            Flowable.fromCallable(new Callable<Integer>() {, +                @Override, +                public Integer call() throws Exception {, +                    ts.cancel();, +                    throw new TestException();, +                }, +            }), +            .subscribe(ts);, +, +            ts.assertEmpty();, +, +            TestHelper.assertUndeliverable(errors, 0, TestException.class);, +        } finally {, +            RxJavaPlugins.reset();, +        }, +    }]