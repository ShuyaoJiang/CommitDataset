[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCache;, +import rx.subjects.PublishSubject;, +import rx.subjects.ReplaySubject;, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications., +     * , +     * @param that, +     *            the source Observable, +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public static <T> ConnectableObservable<T> replay(final Observable<T> that) {, +        return OperationMulticast.multicast(that, ReplaySubject.<T> create());, +    }, +, +    /**, +     * Similar to {@link #replay()} except that this auto-subscribes to the source sequence., +     * <p>, +     * This is useful when returning an Observable that you wish to cache responses but can't control the, +     * subscribe/unsubscribe behavior of all the Observers., +     * <p>, +     * NOTE: You sacrifice the ability to unsubscribe from the origin with this operator so be careful to not, +     * use this on infinite or very large sequences that will use up memory. This is similar to, +     * the {@link Observable#toList()} operator in this caution., +     * , +     * @return an observable sequence that upon first subscription caches all events for subsequent subscriptions., +     */, +    public static <T> Observable<T> cache(final Observable<T> that) {, +        return create(OperationCache.cache(that));, +    }, +, +    /**, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence., +     * , +     * @param that, +     *            the source Observable, +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public static <T> ConnectableObservable<T> publish(final Observable<T> that) {, +        return OperationMulticast.multicast(that, PublishSubject.<T> create());, +    }, +, +    /**, +     * , +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications., +     * , +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public ConnectableObservable<T> replay() {, +        return replay(this);, +    }, +, +    /**, +     * Similar to {@link #replay()} except that this auto-subscribes to the source sequence., +     * <p>, +     * This is useful when returning an Observable that you wish to cache responses but can't control the, +     * subscribe/unsubscribe behavior of all the Observers., +     * <p>, +     * NOTE: You sacrifice the ability to unsubscribe from the origin with this operator so be careful to not, +     * use this on infinite or very large sequences that will use up memory. This is similar to, +     * the {@link Observable#toList()} operator in this caution., +     * , +     * @return an observable sequence that upon first subscription caches all events for subsequent subscriptions., +     */, +    public Observable<T> cache() {, +        return cache(this);, +    }, +, +    /**, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence., +     * , +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public ConnectableObservable<T> publish() {, +        return publish(this);, +    }, +, +    /**, +        @Test, +        public void testPublish() throws InterruptedException {, +            final AtomicInteger counter = new AtomicInteger();, +            ConnectableObservable<String> o = Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(final Observer<String> observer) {, +                    final BooleanSubscription subscription = new BooleanSubscription();, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +                            counter.incrementAndGet();, +                            observer.onNext("one");, +                            observer.onCompleted();, +                        }, +                    }).start();, +                    return subscription;, +                }, +            }).publish();, +, +            final CountDownLatch latch = new CountDownLatch(2);, +]