[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.subjects.PublishSubject;, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence., +     * , +     * @param that, +     *            the source Observable, +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public static <T> ConnectableObservable<T> publish(final Observable<T> that) {, +        return OperationMulticast.multicast(that, PublishSubject.<T> create());, +    }, +, +    /**, +     * , +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence., +     * , +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public ConnectableObservable<T> publish() {, +        return OperationMulticast.multicast(this, PublishSubject.<T> create());, +    }, +, +    /**, +        @Test, +        public void testPublish() throws InterruptedException {, +            final AtomicInteger counter = new AtomicInteger();, +            ConnectableObservable<String> o = Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(final Observer<String> observer) {, +                    final BooleanSubscription subscription = new BooleanSubscription();, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +                            System.out.println("published observable being executed");, +                            observer.onNext("one");, +                            observer.onCompleted();, +                            counter.incrementAndGet();, +                        }, +                    }).start();, +                    return subscription;, +                }, +            }).publish();, +, +            final CountDownLatch latch = new CountDownLatch(2);, +, +            // subscribe once, +            o.subscribe(new Action1<String>() {, +, +                @Override, +                public void call(String v) {, +                    assertEquals("one", v);, +                    System.out.println("v: " + v);, +                    latch.countDown();, +                }, +            });, +, +            // subscribe again, +            o.subscribe(new Action1<String>() {, +, +                @Override, +                public void call(String v) {, +                    assertEquals("one", v);, +                    System.out.println("v: " + v);, +                    latch.countDown();, +                }, +            });, +, +            Subscription s = o.connect();, +            try {, +                if (!latch.await(1000, TimeUnit.MILLISECONDS)) {, +                    fail("subscriptions did not receive values");, +                }, +                assertEquals(1, counter.get());, +            } finally {, +                s.unsubscribe();, +            }, +        }, +]