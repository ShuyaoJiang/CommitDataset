[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.SequentialDisposable;, +    protected void subscribeActual(SingleObserver<? super R> subscriber) {, +        SingleFlatMapCallback<T, R> parent = new SingleFlatMapCallback<T, R>(subscriber, mapper);, +        subscriber.onSubscribe(parent.sd);, +        source.subscribe(parent);, +    static final class SingleFlatMapCallback<T, R> implements SingleObserver<T> {, +        final SequentialDisposable sd;, +, +            this.sd = new SequentialDisposable();, +            sd.replace(d);, +                o = mapper.apply(value);, +            if (o == null) {, +                actual.onError(new NullPointerException("The single returned by the mapper is null"));, +                return;, +            }, +, +            if (sd.isDisposed()) {, +                return;, +            }, +, +            o.subscribe(new SingleObserver<R>() {, +                @Override, +                public void onSubscribe(Disposable d) {, +                    sd.replace(d);, +                }, +, +                @Override, +                public void onSuccess(R value) {, +                    actual.onSuccess(value);, +            });, +        public void onError(Throwable e) {, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.SequentialDisposable;, +    protected void subscribeActual(SingleObserver<? super R> subscriber) {, +        SingleFlatMapCallback<T, R> parent = new SingleFlatMapCallback<T, R>(subscriber, mapper);, +        subscriber.onSubscribe(parent.sd);, +        source.subscribe(parent);, +    static final class SingleFlatMapCallback<T, R> implements SingleObserver<T> {, +        final SequentialDisposable sd;, +, +            this.sd = new SequentialDisposable();, +            sd.replace(d);, +                o = mapper.apply(value);, +            if (o == null) {, +                actual.onError(new NullPointerException("The single returned by the mapper is null"));, +                return;, +            }, +, +            if (sd.isDisposed()) {, +                return;, +            }, +, +            o.subscribe(new SingleObserver<R>() {, +                @Override, +                public void onSubscribe(Disposable d) {, +                    sd.replace(d);, +                }, +, +                @Override, +                public void onSuccess(R value) {, +                    actual.onSuccess(value);, +            });, +        public void onError(Throwable e) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.SequentialDisposable;, +    protected void subscribeActual(SingleObserver<? super R> subscriber) {, +        SingleFlatMapCallback<T, R> parent = new SingleFlatMapCallback<T, R>(subscriber, mapper);, +        subscriber.onSubscribe(parent.sd);, +        source.subscribe(parent);, +    static final class SingleFlatMapCallback<T, R> implements SingleObserver<T> {, +        final SequentialDisposable sd;, +, +            this.sd = new SequentialDisposable();, +            sd.replace(d);, +                o = mapper.apply(value);, +            if (o == null) {, +                actual.onError(new NullPointerException("The single returned by the mapper is null"));, +                return;, +            }, +, +            if (sd.isDisposed()) {, +                return;, +            }, +, +            o.subscribe(new SingleObserver<R>() {, +                @Override, +                public void onSubscribe(Disposable d) {, +                    sd.replace(d);, +                }, +, +                @Override, +                public void onSuccess(R value) {, +                    actual.onSuccess(value);, +            });, +        public void onError(Throwable e) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java, +++ b/src/test/java/io/reactivex/maybe/MaybeTest.java, +        if (before * 1.3 < after) {]