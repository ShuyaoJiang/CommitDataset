[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +        final int limit;, +, +        int consumed;, +, +            this.limit = prefetch - (prefetch >> 2); // request after 75% consumption, +            int upstreamConsumed = consumed;, +            int localLimit = limit;, +            boolean canRequest = sourceMode != QueueSubscription.SYNC;, +            , +, +                        if (canRequest && ++upstreamConsumed == localLimit) {, +                            upstreamConsumed = 0;, +                            s.get().request(localLimit);, +                        }, +                consumed = upstreamConsumed;, +            if (getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {, +                parent.drain(); // unblock the others, +            }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +        final int limit;, +, +        int consumed;, +, +            this.limit = prefetch - (prefetch >> 2); // request after 75% consumption, +            int upstreamConsumed = consumed;, +            int localLimit = limit;, +            boolean canRequest = sourceMode != QueueSubscription.SYNC;, +            , +, +                        if (canRequest && ++upstreamConsumed == localLimit) {, +                            upstreamConsumed = 0;, +                            s.get().request(localLimit);, +                        }, +                consumed = upstreamConsumed;, +            if (getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {, +                parent.drain(); // unblock the others, +            }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java, +import io.reactivex.functions.*;, +            .awaitDone(5, TimeUnit.SECONDS), +            .awaitDone(5, TimeUnit.SECONDS), +, +    @Test, +    public void longFlow() {, +        Flowable.range(1, 1000000), +        .publish(new Function<Flowable<Integer>, Publisher<Integer>>() {, +            @SuppressWarnings("unchecked"), +            @Override, +            public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {, +                return Flowable.mergeArray(, +                        v.filter(new Predicate<Integer>() {, +                            @Override, +                            public boolean test(Integer w) throws Exception {, +                                return w % 2 == 0;, +                            }, +                        }), , +                        v.filter(new Predicate<Integer>() {, +                            @Override, +                            public boolean test(Integer w) throws Exception {, +                                return w % 2 != 0;, +                            }, +                        }));, +            }, +        }), +        .takeLast(1), +        .test(), +        .assertResult(1000000);, +    }, +, +    @Test, +    public void longFlow2() {, +        Flowable.range(1, 100000), +        .publish(new Function<Flowable<Integer>, Publisher<Integer>>() {, +            @SuppressWarnings("unchecked"), +            @Override, +            public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {, +                return Flowable.mergeArray(, +                        v.filter(new Predicate<Integer>() {, +                            @Override, +                            public boolean test(Integer w) throws Exception {, +                                return w % 2 == 0;, +                            }, +                        }), , +                        v.filter(new Predicate<Integer>() {, +                            @Override, +                            public boolean test(Integer w) throws Exception {, +                                return w % 2 != 0;, +                            }, +                        }));, +            }, +        }), +        .test(), +        .assertValueCount(100000), +        .assertNoErrors(), +        .assertComplete();, +    }, +, +    @Test, +    public void longFlowHidden() {]