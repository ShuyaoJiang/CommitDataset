[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits items that are the result of applying a specified function to pairs of, +   * values, one each from the source Observable and a specified Iterable sequence., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @param selector a function that combines the pairs of items from the Observable and the Iterable to generate, +   *                 the items to be emitted by the resulting Observable, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable, +   *         sequence and emits the results of `selector` applied to these pairs, +   */, +  def zip[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    val thisJava = asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  }, +, +  /**, +    zip((0 until Int.MaxValue), (t: T, index: Int) => (t, index)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits items that are the result of applying a specified function to pairs of, +   * values, one each from the source Observable and a specified Iterable sequence., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @param selector a function that combines the pairs of items from the Observable and the Iterable to generate, +   *                 the items to be emitted by the resulting Observable, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable, +   *         sequence and emits the results of `selector` applied to these pairs, +   */, +  def zip[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    val thisJava = asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  }, +, +  /**, +    zip((0 until Int.MaxValue), (t: T, index: Int) => (t, index)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "ignoreElements()" -> "[use `filter(_ => false)`]",, +      "limit(Int)" -> "take(Int)",, +      "single(Func1[_ >: T, Boolean])" -> "[use `filter(predicate).single`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U], (T, U) => R)",, +      "zip(Iterable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zip(Iterable[U], (T, U) => R)",, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits items that are the result of applying a specified function to pairs of, +   * values, one each from the source Observable and a specified Iterable sequence., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @param selector a function that combines the pairs of items from the Observable and the Iterable to generate, +   *                 the items to be emitted by the resulting Observable, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable, +   *         sequence and emits the results of `selector` applied to these pairs, +   */, +  def zip[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    val thisJava = asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  }, +, +  /**, +    zip((0 until Int.MaxValue), (t: T, index: Int) => (t, index)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "ignoreElements()" -> "[use `filter(_ => false)`]",, +      "limit(Int)" -> "take(Int)",, +      "single(Func1[_ >: T, Boolean])" -> "[use `filter(predicate).single`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U], (T, U) => R)",, +      "zip(Iterable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zip(Iterable[U], (T, U) => R)",, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * This is an alias for {@link #publish().refCount()}., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits items that are the result of applying a specified function to pairs of, +   * values, one each from the source Observable and a specified Iterable sequence., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @param selector a function that combines the pairs of items from the Observable and the Iterable to generate, +   *                 the items to be emitted by the resulting Observable, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable, +   *         sequence and emits the results of `selector` applied to these pairs, +   */, +  def zip[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    val thisJava = asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  }, +]