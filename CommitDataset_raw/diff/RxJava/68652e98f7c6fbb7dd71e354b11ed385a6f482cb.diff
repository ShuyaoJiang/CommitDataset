[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]], Func1[_ >: Throwable, _ <: Observable[_ <: R]], Func0[_ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R], Throwable => Observable[R], () => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: R]])" -> "flatMapIterable(T => Iterable[R])",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])",, +      "onErrorFlatMap(Func1[OnErrorThrowable, _ <: Observable[_ <: T]])" -> "onErrorFlatMap((Throwable, Option[Any]) => Observable[U])",, +      "create(OnSubscribeFunc[T])" -> "create(Observer[T] => Subscription)",, +      "defer(Func0[_ <: Observable[_ <: T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter(m => m.isMethod && m.isPublic)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]], Func1[_ >: Throwable, _ <: Observable[_ <: R]], Func0[_ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R], Throwable => Observable[R], () => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: R]])" -> "flatMapIterable(T => Iterable[R])",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])",, +      "onErrorFlatMap(Func1[OnErrorThrowable, _ <: Observable[_ <: T]])" -> "onErrorFlatMap((Throwable, Option[Any]) => Observable[U])",, +      "create(OnSubscribeFunc[T])" -> "create(Observer[T] => Subscription)",, +      "defer(Func0[_ <: Observable[_ <: T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter(m => m.isMethod && m.isPublic)), +++ b/rxjava-core/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import rx.plugins.RxJavaPlugins;, +import rx.plugins.RxJavaSchedulersHook;, +    private final RxJavaSchedulersHook schedulersHook;, +        schedulersHook = RxJavaPlugins.getInstance().getSchedulersHook();, +        Action0 decoratedAction = schedulersHook.onSchedule(action);, +        ScheduledAction run = new ScheduledAction(decoratedAction);, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]], Func1[_ >: Throwable, _ <: Observable[_ <: R]], Func0[_ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R], Throwable => Observable[R], () => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: R]])" -> "flatMapIterable(T => Iterable[R])",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])",, +      "onErrorFlatMap(Func1[OnErrorThrowable, _ <: Observable[_ <: T]])" -> "onErrorFlatMap((Throwable, Option[Any]) => Observable[U])",, +      "create(OnSubscribeFunc[T])" -> "create(Observer[T] => Subscription)",, +      "defer(Func0[_ <: Observable[_ <: T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter(m => m.isMethod && m.isPublic)), +++ b/rxjava-core/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import rx.plugins.RxJavaPlugins;, +import rx.plugins.RxJavaSchedulersHook;, +    private final RxJavaSchedulersHook schedulersHook;, +        schedulersHook = RxJavaPlugins.getInstance().getSchedulersHook();, +        Action0 decoratedAction = schedulersHook.onSchedule(action);, +        ScheduledAction run = new ScheduledAction(decoratedAction);, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaDefaultSchedulers.java, +@Deprecated, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable)), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: R]], Func1[_ >: Throwable, _ <: Observable[_ <: R]], Func0[_ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R], Throwable => Observable[R], () => Observable[R])",, +      "mergeMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: R]])" -> "flatMapIterable(T => Iterable[R])",, +      "mergeMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])",, +      "onErrorFlatMap(Func1[OnErrorThrowable, _ <: Observable[_ <: T]])" -> "onErrorFlatMap((Throwable, Option[Any]) => Observable[U])",, +      "create(OnSubscribeFunc[T])" -> "create(Observer[T] => Subscription)",, +      "defer(Func0[_ <: Observable[_ <: T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter(m => m.isMethod && m.isPublic)), +++ b/rxjava-core/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import rx.plugins.RxJavaPlugins;, +import rx.plugins.RxJavaSchedulersHook;, +    private final RxJavaSchedulersHook schedulersHook;, +        schedulersHook = RxJavaPlugins.getInstance().getSchedulersHook();, +        Action0 decoratedAction = schedulersHook.onSchedule(action);, +        ScheduledAction run = new ScheduledAction(decoratedAction);, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaDefaultSchedulers.java, +@Deprecated, +++ b/rxjava-core/src/main/java/rx/plugins/RxJavaDefaultSchedulersDefault.java, +@Deprecated, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Int): Observable[T] = {]