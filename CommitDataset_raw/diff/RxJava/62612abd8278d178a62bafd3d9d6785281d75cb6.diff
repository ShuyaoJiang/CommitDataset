[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +import java.util.concurrent.Callable;, +import io.reactivex.internal.functions.ObjectHelper;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitComputationHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitSingleHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitIoHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitNewThreadHandler;, +    public static Function<Callable<Scheduler>, Scheduler> getInitComputationSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitIoSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitNewThreadSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitSingleSchedulerHandler() {, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null, +    public static Scheduler initComputationScheduler(Callable<Scheduler> defaultScheduler) {, +        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");, +        Function<Callable<Scheduler>, Scheduler> f = onInitComputationHandler;, +            return callRequireNonNull(defaultScheduler);, +        return applyRequireNonNull(f, defaultScheduler); // JIT will skip this, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null, +    public static Scheduler initIoScheduler(Callable<Scheduler> defaultScheduler) {, +        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");, +        Function<Callable<Scheduler>, Scheduler> f = onInitIoHandler;, +            return callRequireNonNull(defaultScheduler);, +        return applyRequireNonNull(f, defaultScheduler);, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null, +    public static Scheduler initNewThreadScheduler(Callable<Scheduler> defaultScheduler) {, +        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");, +        Function<Callable<Scheduler>, Scheduler> f = onInitNewThreadHandler;, +            return callRequireNonNull(defaultScheduler);, +        return applyRequireNonNull(f, defaultScheduler);, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null, +    public static Scheduler initSingleScheduler(Callable<Scheduler> defaultScheduler) {, +        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");, +        Function<Callable<Scheduler>, Scheduler> f = onInitSingleHandler;, +            return callRequireNonNull(defaultScheduler);, +        return applyRequireNonNull(f, defaultScheduler);, +     * @param handler the hook function to set, null allowed, but the function may not return null, +    public static void setInitComputationSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {, +     * @param handler the hook function to set, null allowed, but the function may not return null, +    public static void setInitIoSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {, +     * @param handler the hook function to set, null allowed, but the function may not return null, +    public static void setInitNewThreadSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {, +     * @param handler the hook function to set, null allowed, but the function may not return null, +    public static void setInitSingleSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {, +    /**, +     * Wraps the call to the Scheduler creation callable in try-catch and propagates thrown, +     * checked exceptions as RuntimeException and enforces that result is not null., +     * @param s the {@link Callable} which returns a {@link Scheduler}, not null (not verified). Cannot return null, +     * @return the result of the callable call, not null, +     * @throws NullPointerException if the callable parameter returns null, +     */, +    static Scheduler callRequireNonNull(Callable<Scheduler> s) {, +        try {, +            return ObjectHelper.requireNonNull(s.call(), "Scheduler Callable result can't be null");, +        } catch (Throwable ex) {, +            throw ExceptionHelper.wrapOrThrow(ex);, +        }, +    }, +, +    /**, +     * Wraps the call to the Scheduler creation function in try-catch and propagates thrown, +     * checked exceptions as RuntimeException and enforces that result is not null., +     * @param f the function to call, not null (not verified). Cannot return null, +     * @param s the parameter value to the function, +     * @return the result of the function call, not null, +     * @throws NullPointerException if the function parameter returns null, +     */, +    static Scheduler applyRequireNonNull(Function<Callable<Scheduler>, Scheduler> f, Callable<Scheduler> s) {, +        return ObjectHelper.requireNonNull(apply(f, s), "Scheduler Callable result can't be null");, +    }, +, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +import java.util.concurrent.Callable;, +import io.reactivex.internal.functions.ObjectHelper;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitComputationHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitSingleHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitIoHandler;, +    static volatile Function<Callable<Scheduler>, Scheduler> onInitNewThreadHandler;, +    public static Function<Callable<Scheduler>, Scheduler> getInitComputationSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitIoSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitNewThreadSchedulerHandler() {, +    public static Function<Callable<Scheduler>, Scheduler> getInitSingleSchedulerHandler() {, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null, +    public static Scheduler initComputationScheduler(Callable<Scheduler> defaultScheduler) {, +        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");, +        Function<Callable<Scheduler>, Scheduler> f = onInitComputationHandler;, +            return callRequireNonNull(defaultScheduler);, +        return applyRequireNonNull(f, defaultScheduler); // JIT will skip this, +     * @param defaultScheduler a {@link Callable} which returns the hook's input value, +     * @return the value returned by the hook, not null, +     * @throws NullPointerException if the callable parameter or its result are null]