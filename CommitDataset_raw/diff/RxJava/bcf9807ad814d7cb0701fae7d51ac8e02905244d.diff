[+++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java, +                    // special case if no children are running (such as an empty sequence, or just getting the groups and not subscribing), +                                // number of children we have running, +                                completionCounter.incrementAndGet();, +++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java, +                    // special case if no children are running (such as an empty sequence, or just getting the groups and not subscribing), +                                // number of children we have running, +                                completionCounter.incrementAndGet();, +++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java, +                            return group.observeOn(Schedulers.newThread()).map(new Func1<Integer, Integer>() {, +, +                                @Override, +                                public Integer call(Integer t) {, +                                    try {, +                                        Thread.sleep(2);, +                                    } catch (InterruptedException e) {, +                                        e.printStackTrace();, +                                    }, +                                    return t * 10;, +                                }, +, +                            });, +                        System.out.println("=> onCompleted");, +    @Test, +    public void testCompletionIfInnerNotSubscribed() throws InterruptedException {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicInteger eventCounter = new AtomicInteger();, +        Observable.range(0, 100), +                .groupBy(new Func1<Integer, Integer>() {, +, +                    @Override, +                    public Integer call(Integer i) {, +                        return i % 2;, +                    }, +                }), +                .subscribe(new Observer<GroupedObservable<Integer, Integer>>() {, +, +                    @Override, +                    public void onCompleted() {, +                        latch.countDown();, +                    }, +, +                    @Override, +                    public void onError(Throwable e) {, +                        e.printStackTrace();, +                        latch.countDown();, +                    }, +, +                    @Override, +                    public void onNext(GroupedObservable<Integer, Integer> s) {, +                        eventCounter.incrementAndGet();, +                        System.out.println("=> " + s);, +                    }, +                });, +        if (!latch.await(500, TimeUnit.MILLISECONDS)) {, +            fail("timed out - never got completion");, +        }, +        assertEquals(2, eventCounter.get());, +    }, +]