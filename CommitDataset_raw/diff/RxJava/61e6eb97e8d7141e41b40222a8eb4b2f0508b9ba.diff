[+++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java, +     * which it is impossible to unsubscribe if observables are running on same thread., +        public void testConcatObservableOfObservables() {, +            , +  , +        @Test, +		public void testConcatConcurrentWithInfinity() {, +            final TestObservable<String> w1 = new TestObservable<String>("one", "two", "three");, +            //This observable will send "hello" MAX_VALUE time., +            final TestObservable<String> w2 = new TestObservable<String>("hello", Integer.MAX_VALUE);, +, +            @SuppressWarnings("unchecked"), +            Observer<String> aObserver = mock(Observer.class);, +            @SuppressWarnings("unchecked"), + 			TestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(w1, w2);, +            Func1<Observer<String>, Subscription> concatF = concat(observableOfObservables);, +            , +            Observable<String> concat = Observable.create(concatF);, +            , +            concat.take(50).subscribe(aObserver);, +, +            //Wait for the thread to start up., +            try {, +				Thread.sleep(25);, +				w1.t.join();, +				w2.t.join();, +			} catch (InterruptedException e) {, +				// TODO Auto-generated catch block, +				e.printStackTrace();, +			}, +            , +            InOrder inOrder = inOrder(aObserver);, +            inOrder.verify(aObserver, times(1)).onNext("one");   , +            inOrder.verify(aObserver, times(1)).onNext("two");, +            inOrder.verify(aObserver, times(1)).onNext("three");, +            inOrder.verify(aObserver, times(47)).onNext("hello");, +            verify(aObserver, times(1)).onCompleted();, +            verify(aObserver, never()).onError(any(Exception.class));, +            , + 		}, +        , +        , +        /**, +         * The outer observable is running on the same thread and subscribe() in this case is a blocking call. Calling unsubscribe() is no-op because the sequence is complete. , +         */, +        @Test, +        public void testConcatUnsubscribe() {, +            final CountDownLatch callOnce = new CountDownLatch(1);, +            final CountDownLatch okToContinue = new CountDownLatch(1);, +            final TestObservable<String> w1 = new TestObservable<String>("one", "two", "three");, +            final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, "four", "five", "six");, +, +            @SuppressWarnings("unchecked"), +            final Observer<String> aObserver = mock(Observer.class);, +            @SuppressWarnings("unchecked"), +            final Observable<String> concat = Observable.create(concat(w1, w2));, +            final AtomicObservableSubscription s1 = new AtomicObservableSubscription();, +            Thread t = new Thread() {, +                    @Override, +                    public void run() {, +                        // NB: this statement does not complete until after "six" has been delivered., +                        s1.wrap(concat.subscribe(aObserver));, +                    }, +                };, +            t.start();, +            try {, +                //Block main thread to allow observable "w1" to complete and observable "w2" to call onNext once., +                callOnce.await();, +                // NB: This statement has no effect, since s1 cannot possibly, +                // wrap anything until "six" has been delivered, which cannot, +                // happen until we okToContinue.countDown(), +                s1.unsubscribe();, +                //Unblock the observable to continue., +                okToContinue.countDown();, +                w1.t.join();, +                w2.t.join();, +            } catch (Exception e) {, +                e.printStackTrace();, +                fail(e.getMessage());, +            }, +, +            InOrder inOrder = inOrder(aObserver);, +            inOrder.verify(aObserver, times(1)).onNext("one");, +            inOrder.verify(aObserver, times(1)).onNext("two");, +            inOrder.verify(aObserver, times(1)).onNext("three");, +            inOrder.verify(aObserver, times(1)).onNext("four");, +            // NB: you might hope that five and six are not delivered, but see above., +            inOrder.verify(aObserver, times(1)).onNext("five");, +            inOrder.verify(aObserver, times(1)).onNext("six");, +            inOrder.verify(aObserver, times(1)).onCompleted();, +, +        }, +       , +        /**, +         * All observables will be running in different threads so subscribe() is unblocked.  CountDownLatch is only used in order to call unsubscribe() in a predictable manner.  , +         */, +        @Test, +		public void testConcatUnsubscribeConcurrent() {, +            final CountDownLatch callOnce = new CountDownLatch(1);, +            final CountDownLatch okToContinue = new CountDownLatch(1);]