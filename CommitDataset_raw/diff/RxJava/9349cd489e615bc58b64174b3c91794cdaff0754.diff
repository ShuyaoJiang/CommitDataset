[+++ b/language-adaptors/rxjava-scala/README.md, +Observable(1, 2, 3, 4).reduce(_ + _), +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +++ b/language-adaptors/rxjava-scala/README.md, +Observable(1, 2, 3, 4).reduce(_ + _), +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  /**, +   * This is a bad way of using `zip` with an `Iterable`: even if the consumer unsubscribes,, +   * some elements may still be pulled from `Iterable`., +   */, +  @Test def zipWithIterableBadExample() {, +    val o1 = Observable.interval(100 millis, IOScheduler()).map(_ * 100).take(3), +    val o2 = Observable.from(0 until Int.MaxValue).doOnEach(i => println(i + " from o2")), +    o1.zip(o2).toBlockingObservable.foreach(println(_)), +  }, +, +  /**, +   * This is a good way of using `zip` with an `Iterable`: if the consumer unsubscribes,, +   * no more elements will be pulled from `Iterable`., +   */, +  @Test def zipWithIterableGoodExample() {, +    val o1 = Observable.interval(100 millis, IOScheduler()).map(_ * 100).take(3), +    val iter = (0 until Int.MaxValue).view.map {, +      i => {, +        println(i + " from iter"), +        i, +      }, +    }, +    o1.zip(iter).toBlockingObservable.foreach(println(_)), +  }, +, +++ b/language-adaptors/rxjava-scala/README.md, +Observable(1, 2, 3, 4).reduce(_ + _), +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  /**, +   * This is a bad way of using `zip` with an `Iterable`: even if the consumer unsubscribes,, +   * some elements may still be pulled from `Iterable`., +   */, +  @Test def zipWithIterableBadExample() {, +    val o1 = Observable.interval(100 millis, IOScheduler()).map(_ * 100).take(3), +    val o2 = Observable.from(0 until Int.MaxValue).doOnEach(i => println(i + " from o2")), +    o1.zip(o2).toBlockingObservable.foreach(println(_)), +  }, +, +  /**, +   * This is a good way of using `zip` with an `Iterable`: if the consumer unsubscribes,, +   * no more elements will be pulled from `Iterable`., +   */, +  @Test def zipWithIterableGoodExample() {, +    val o1 = Observable.interval(100 millis, IOScheduler()).map(_ * 100).take(3), +    val iter = (0 until Int.MaxValue).view.map {, +      i => {, +        println(i + " from iter"), +        i, +      }, +    }, +    o1.zip(iter).toBlockingObservable.foreach(println(_)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable formed from `this` Observable and `other` Iterable by combining, +   * corresponding elements in pairs., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable., +   */, +  def zip[U](other: Iterable[U]): Observable[(T, U)] = {, +    zipWith(other, (t: T, u: U) => (t, u)), +  }, +, +  /**, +   * Returns an Observable that emits items that are the result of applying a specified function to pairs of, +   * values, one each from the source Observable and a specified Iterable sequence., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">, +   * <p>, +   * Note that the `other` Iterable is evaluated as items are observed from the source Observable; it is, +   * not pre-consumed. This allows you to zip infinite streams on either side., +   *, +   * @param other the Iterable sequence, +   * @param selector a function that combines the pairs of items from the Observable and the Iterable to generate, +   *                 the items to be emitted by the resulting Observable, +   * @return an Observable that pairs up values from the source Observable and the `other` Iterable, +   *         sequence and emits the results of `selector` applied to these pairs, +   */, +  def zipWith[U, R](other: Iterable[U], selector: (T, U) => R): Observable[R] = {, +    val thisJava = asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable[R](thisJava.zip(other.asJava, selector)), +  }, +]