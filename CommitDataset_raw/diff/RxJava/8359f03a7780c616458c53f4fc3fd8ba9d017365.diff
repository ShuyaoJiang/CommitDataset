[+++ b/build.gradle, +  dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/build.gradle, +  dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +  dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/build.gradle, +  dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()) {, +        }, +                    int emitted = s.drainQueue();, +                long emitted = 0;, +                // request upstream what we just emitted, +                if(emitted > 0) {, +++ b/build.gradle, +  dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, +            if (!isUnsubscribed()) {, +        }, +                    int emitted = s.drainQueue();, +                long emitted = 0;, +                // request upstream what we just emitted, +                if(emitted > 0) {, +++ b/src/test/java/rx/internal/operators/OperatorMergeTest.java, +import java.util.concurrent.ConcurrentLinkedQueue;, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Subscriber;, +import rx.Subscription;, +    , +    @Test, +    public void testMergeKeepsRequesting() throws InterruptedException {, +        //for (int i = 0; i < 5000; i++) {, +            //System.out.println(i + ".......................................................................");, +            final CountDownLatch latch = new CountDownLatch(1);, +            final ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<String>();, +, +            Observable.range(1, 2), +                    // produce many integers per second, +                    .flatMap(new Func1<Integer, Observable<Integer>>() {, +                        @Override, +                        public Observable<Integer> call(final Integer number) {, +                            return Observable.range(1, Integer.MAX_VALUE), +                                    .doOnRequest(new Action1<Long>() {, +, +                                        @Override, +                                        public void call(Long n) {, +                                            messages.add(">>>>>>>> A requested[" + number + "]: " + n);, +                                        }, +, +                                    }), +                                    // pause a bit, +                                    .doOnNext(pauseForMs(3)), +                                    // buffer on backpressure, +                                    .onBackpressureBuffer(), +                                    // do in parallel, +                                    .subscribeOn(Schedulers.computation()), +                                    .doOnRequest(new Action1<Long>() {, +, +                                        @Override, +                                        public void call(Long n) {, +                                            messages.add(">>>>>>>> B requested[" + number + "]: " + n);, +                                        }, +, +                                    });, +                        }, +, +                    }), +                    // take a number bigger than 2* RxRingBuffer.SIZE (used by OperatorMerge), +                    .take(RxRingBuffer.SIZE * 2 + 1), +                    // log count, +                    .doOnNext(printCount()), +                    // release latch, +                    .doOnCompleted(new Action0() {, +                        @Override, +                        public void call() {, +                            latch.countDown();, +                        }, +                    }).subscribe();, +            boolean a = latch.await(2, TimeUnit.SECONDS);, +            if (!a) {, +                for (String s : messages) {, +                    System.out.println("DEBUG => " + s);, +                }]