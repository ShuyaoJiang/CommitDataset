[+++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import java.util.concurrent.Future;, +import rx.observables.operations.OperationToObservableFuture;, +     * Converts an Future to a Observable sequence., +     * , +     * Any object that supports the {@link Future} interface can be converted into a Observable that emits, +     * the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method., +     * , +     * @param future, +     *            the source {@link Future}, +     * @param <T>, +     *            the type of of object that the future's returns and the type emitted by the resulting, +     *            Observable, +     * @return a Observable that emits the item from the source Future, +     */, +    public static <T> Observable<T> toObservable(Future<T> future) {, +        return create(OperationToObservableFuture.toObservableFuture(future));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import java.util.concurrent.Future;, +import rx.observables.operations.OperationToObservableFuture;, +     * Converts an Future to a Observable sequence., +     * , +     * Any object that supports the {@link Future} interface can be converted into a Observable that emits, +     * the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method., +     * , +     * @param future, +     *            the source {@link Future}, +     * @param <T>, +     *            the type of of object that the future's returns and the type emitted by the resulting, +     *            Observable, +     * @return a Observable that emits the item from the source Future, +     */, +    public static <T> Observable<T> toObservable(Future<T> future) {, +        return create(OperationToObservableFuture.toObservableFuture(future));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/observables/operations/OperationToObservableFuture.java, +package rx.observables.operations;, +, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +import java.util.concurrent.Future;, +, +import org.junit.Test;, +, +import rx.observables.Observable;, +import rx.observables.Observer;, +import rx.observables.Subscription;, +import rx.util.functions.Func1;, +, +public class OperationToObservableFuture {, +    private static class ToObservableFuture<T> implements OperatorSubscribeFunction<T> {, +        private final Future<T> that;, +, +        public ToObservableFuture(Future<T> that) {, +            this.that = that;, +        }, +, +        @Override, +        public Subscription call(Observer<T> observer) {, +            try {, +                T value = that.get();, +                if (!that.isCancelled()) {, +                    observer.onNext(value);, +                }, +                observer.onCompleted();, +            } catch (Exception e) {, +                observer.onError(e);, +            }, +, +            // the get() has already completed so there is no point in, +            // giving the user a way to cancel., +            return Observable.noOpSubscription();, +        }, +    }, +, +    public static <T> Func1<Observer<T>, Subscription> toObservableFuture(final Future<T> that) {, +        return new ToObservableFuture<T>(that);, +    }, +, +    @SuppressWarnings("unchecked"), +    public static class UnitTest {, +        @Test, +        public void testSuccess() throws Exception {, +            Future<Object> future = mock(Future.class);, +            Object value = new Object();, +            when(future.get()).thenReturn(value);, +            ToObservableFuture ob = new ToObservableFuture(future);, +            Observer<Object> o = mock(Observer.class);, +, +            Subscription sub = ob.call(o);, +            sub.unsubscribe();]