[+++ b/src/main/java/io/reactivex/Flowable.java, +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +++ b/src/main/java/io/reactivex/Flowable.java, +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +++ b/src/main/java/io/reactivex/Observable.java, +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`., +     * <p>, +     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, +     * item may yield unexpected results if the items are mutated externally. Common cases are mutable, +     * {@code CharSequence}s or {@code List}s where the objects will actually have the same, +     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., +     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, +     * for example using `map(CharSequence::toString)` or `map(Collections::unmodifiableList)`.]