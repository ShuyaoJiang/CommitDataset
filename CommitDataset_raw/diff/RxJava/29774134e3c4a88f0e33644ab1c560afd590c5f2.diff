[+++ b/src/main/java/io/reactivex/Observable.java, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observable.java, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observer.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +        if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/Observable.java, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observer.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +        if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.subjects;, +, +import java.util.Objects;, +import java.util.concurrent.ForkJoinPool;, +import java.util.concurrent.atomic.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +, +public final class BehaviorSubject<T> extends Subject<T, T> {, +, +    public static <T> BehaviorSubject<T> create() {, +        State<T> state = new State<>();, +        return new BehaviorSubject<>(state);, +    }, +    , +    // TODO a plain create() would create a method ambiguity with Observable.create with javac, +    public static <T> BehaviorSubject<T> createDefault(T defaultValue) {, +        Objects.requireNonNull(defaultValue);, +        State<T> state = new State<>();, +        state.lazySet(defaultValue);, +        return new BehaviorSubject<>(state);, +    }, +    , +    final State<T> state;, +    protected BehaviorSubject(State<T> state) {, +        super(state);, +        this.state = state;, +    }, +    , +    @Override, +    public void onSubscribe(Subscription s) {, +        state.onSubscribe(s);, +    }, +, +    @Override, +    public void onNext(T t) {, +        state.onNext(t);, +    }, +, +    @Override, +    public void onError(Throwable t) {, +        state.onError(t);, +    }, +, +    @Override, +    public void onComplete() {, +        state.onComplete();, +    }, +, +    @Override, +    public boolean hasSubscribers() {, +        return state.subscribers.length != 0;, +    }, +, +    @Override, +    public Throwable getThrowable() {, +        Object o = state.get();, +        if (NotificationLite.isComplete(o)) {, +            return NotificationLite.getError(o);, +        }, +        return null;, +    }, +    , +    @Override, +    public T getValue() {, +        Object o = state.get();, +        if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {, +            return null;, +        }, +        return NotificationLite.getValue(o);]