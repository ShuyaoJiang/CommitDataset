[+++ b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java, +import rx.Observable;, +import rx.Observable.OnSubscribe;, +import rx.Observable.Operator;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.functions.Func0;, +import rx.functions.Func1;, +import rx.functions.Func2;, +, +import java.io.Closeable;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private static class CloseableResource<S extends AutoCloseable> implements Subscription {, +        private final AtomicBoolean unsubscribed = new AtomicBoolean();, +        private S closable;, +, +        public CloseableResource(S closeable) {, +            this.closable = closeable;, +        }, +, +        @Override, +        public void unsubscribe() {, +            if (unsubscribed.compareAndSet(false, true)) {, +                try {, +                    closable.close();, +                } catch (Exception e) {, +                    throw new RuntimeException(e);, +                }, +            }, +        }, +, +        @Override, +        public boolean isUnsubscribed() {, +            return unsubscribed.get();, +        }, +    }, +    , +    /**, +     * Func0 that allows throwing an {@link IOException}s commonly thrown during IO operations., +     * @see StringObservable#from(UnsafeFunc0, UnsafeFunc1), +     *, +     * @param <R>, +     */, +    public static interface UnsafeFunc0<R> {, +        public R call() throws Throwable;, +    }, +, +    /**, +     * Helps in creating an Observable that automatically calls {@link Closeable#close()} on completion, error or unsubscribe., +     * , +     * <pre>, +     * StringObservable.using(() -> new FileReader(file), (reader) -> StringObservable.from(reader)), +     * </pre>, +     * , +     * @param resourceFactory, +     *            Generates a new {@link Closeable} resource for each new subscription to the returned Observable, +     * @param observableFactory, +     *            Converts the {@link Closeable} resource into a {@link Observable} with {@link #from(InputStream)} or {@link #from(Reader)}, +     * @return, +     */, +    public static <R, S extends AutoCloseable> Observable<R> using(final UnsafeFunc0<S> resourceFactory,, +            final Func1<S, Observable<R>> observableFactory) {, +        return Observable.using(new Func0<CloseableResource<S>>() {, +            @Override, +            public CloseableResource<S> call() {, +                try {, +                    return new CloseableResource<S>(resourceFactory.call());, +                } catch (Throwable e) {, +                    throw new RuntimeException(e);, +                }, +            }, +        }, new Func1<CloseableResource<S>, Observable<R>>() {, +            @Override, +            public Observable<R> call(CloseableResource<S> t1) {, +                return observableFactory.call(t1.closable);, +            }, +        });, +    }, +, +        return toString(src.reduce(new StringBuilder(), new Func2<StringBuilder, String, StringBuilder>() {, +            public StringBuilder call(StringBuilder a, String b) {, +                return a.append(b);, +            }, +        }));, +    }, +, +    /**, +     * Maps {@link Observable}&lt;{@link Object}&gt; to {@link Observable}&lt;{@link String}&gt; by using {@link String#valueOf(Object)} , +     * @param src, +     * @return, +     */, +    public static Observable<String> toString(Observable<?> src) {, +        return src.map(new Func1<Object, String>() {, +            @Override, +            public String call(Object obj) {, +                return String.valueOf(obj);, +    public static Observable<String> join(final Observable<String> source, final CharSequence separator) {, +        return source.lift(new Operator<String, String>() {, +            public Subscriber<String> call(final Subscriber<? super String> o) {, +                return new Subscriber<String>(o) {]