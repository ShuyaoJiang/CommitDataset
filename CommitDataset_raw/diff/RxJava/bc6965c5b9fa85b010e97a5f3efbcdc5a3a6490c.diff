[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Merges an <code>Observable<Observable<T>></code> to <code>Observable<Observable<T>></code>, +     * with number of inner Observables as defined by <code>parallelObservables</code> and runs each Observable on the defined Scheduler., +     * <p>, +     * For example, if the original <code>Observable<Observable<T>></code> has 100 Observables to be emitted and <code>parallelObservables</code>, +     * is defined as 8, the 100 will be grouped onto 8 output Observables., +     * <p>, +     * This is a mechanism for efficiently processing N number of Observables on a smaller N number of resources (typically CPU cores)., +     * , +     * @param parallelObservables, +     *            the number of Observables to merge into., +     * @return an Observable of Observables constrained to number defined by <code>parallelObservables</code>., +     */, +    public static <T> Observable<Observable<T>> parallelMerge(Observable<Observable<T>> source, int parallelObservables, Scheduler scheduler) {, +        return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Merges an <code>Observable<Observable<T>></code> to <code>Observable<Observable<T>></code>, +     * with number of inner Observables as defined by <code>parallelObservables</code> and runs each Observable on the defined Scheduler., +     * <p>, +     * For example, if the original <code>Observable<Observable<T>></code> has 100 Observables to be emitted and <code>parallelObservables</code>, +     * is defined as 8, the 100 will be grouped onto 8 output Observables., +     * <p>, +     * This is a mechanism for efficiently processing N number of Observables on a smaller N number of resources (typically CPU cores)., +     * , +     * @param parallelObservables, +     *            the number of Observables to merge into., +     * @return an Observable of Observables constrained to number defined by <code>parallelObservables</code>., +     */, +    public static <T> Observable<Observable<T>> parallelMerge(Observable<Observable<T>> source, int parallelObservables, Scheduler scheduler) {, +        return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Func2;, +        private volatile Scheduler recursiveScheduler;, +        public Subscription observeOn(final Observer<? super T> observer, final Scheduler scheduler) {, +                        if (recursiveScheduler == null) {, +                            s.add(scheduler.schedule(null, new Func2<Scheduler, T, Subscription>() {, +, +                                @Override, +                                public Subscription call(Scheduler innerScheduler, T state) {, +                                    // record innerScheduler so 'processQueue' can use it for all subsequent executions, +                                    recursiveScheduler = innerScheduler;, +, +, +                                    return Subscriptions.empty();, +                                }, +                            }));, +                        } else {, +                            processQueue(s, observer);, +                        }, +        /**, +         * This uses 'recursiveScheduler' NOT 'scheduler' as it should reuse the same scheduler each time it processes., +         * This means it must first get the recursiveScheduler when it first executes., +         */, +        private void processQueue(final CompositeSubscription s, final Observer<? super T> observer) {, +, +            s.add(recursiveScheduler.schedule(new Action1<Action0>() {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Merges an <code>Observable<Observable<T>></code> to <code>Observable<Observable<T>></code>, +     * with number of inner Observables as defined by <code>parallelObservables</code> and runs each Observable on the defined Scheduler., +     * <p>, +     * For example, if the original <code>Observable<Observable<T>></code> has 100 Observables to be emitted and <code>parallelObservables</code>, +     * is defined as 8, the 100 will be grouped onto 8 output Observables., +     * <p>, +     * This is a mechanism for efficiently processing N number of Observables on a smaller N number of resources (typically CPU cores)., +     * , +     * @param parallelObservables, +     *            the number of Observables to merge into., +     * @return an Observable of Observables constrained to number defined by <code>parallelObservables</code>., +     */, +    public static <T> Observable<Observable<T>> parallelMerge(Observable<Observable<T>> source, int parallelObservables, Scheduler scheduler) {, +        return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +    }, +    , +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Func2;, +        private volatile Scheduler recursiveScheduler;, +        public Subscription observeOn(final Observer<? super T> observer, final Scheduler scheduler) {, +                        if (recursiveScheduler == null) {, +                            s.add(scheduler.schedule(null, new Func2<Scheduler, T, Subscription>() {, +, +                                @Override, +                                public Subscription call(Scheduler innerScheduler, T state) {, +                                    // record innerScheduler so 'processQueue' can use it for all subsequent executions, +                                    recursiveScheduler = innerScheduler;, +, +, +                                    return Subscriptions.empty();, +                                }, +                            }));, +                        } else {, +                            processQueue(s, observer);]