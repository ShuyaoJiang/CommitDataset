[+++ b/src/main/java/io/reactivex/Observable.java, +        return ObservablePublish.create(this);, +        return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/Observable.java, +        return ObservablePublish.create(this);, +        return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, +            if (b != null) {, +        }, +                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/Observable.java, +        return ObservablePublish.create(this);, +        return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, +            if (b != null) {, +        }, +                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +, +++ b/src/main/java/io/reactivex/Observable.java, +        return ObservablePublish.create(this);, +        return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, +            if (b != null) {, +        }, +                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java, +import io.reactivex.functions.Consumer;, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.util.ExceptionHelper;, +    public static <T> ConnectableObservable<T> create(ObservableSource<T> source) {, +                // create the backpressure-managing producer for this child, +                InnerDisposable<T> inner = new InnerDisposable<T>(child);, +                child.onSubscribe(inner);, +                        PublishObserver<T> u = new PublishObserver<T>(curr);, +                        inner.setParent(r);, +        return RxJavaPlugins.onAssembly(new ObservablePublish<T>(onSubscribe, source, curr));, +                              final AtomicReference<PublishObserver<T>> current) {, +                PublishObserver<T> u = new PublishObserver<T>(current);, +    static final class PublishObserver<T>, +    implements Observer<T>, Disposable {, +        final AtomicReference<InnerDisposable<T>[]> observers;, +        @SuppressWarnings("unchecked"), +        PublishObserver(AtomicReference<PublishObserver<T>> current) {, +            this.observers = new AtomicReference<InnerDisposable<T>[]>(EMPTY);, +        @SuppressWarnings("unchecked"), +            for (InnerDisposable<T> inner : observers.get()) {, +                inner.child.onNext(t);, +        @SuppressWarnings("unchecked"), +            current.compareAndSet(this, null);, +            InnerDisposable<T>[] a = observers.getAndSet(TERMINATED);, +            if (a.length != 0) {, +                for (InnerDisposable<T> inner : a) {, +                    inner.child.onError(e);, +                }, +            } else {, +                RxJavaPlugins.onError(e);, +        @SuppressWarnings("unchecked"), +            current.compareAndSet(this, null);, +            for (InnerDisposable<T> inner : observers.getAndSet(TERMINATED)) {, +                inner.child.onComplete();, +                InnerDisposable<T>[] c = observers.get();, +                @SuppressWarnings("unchecked"), +                InnerDisposable<T>[] u = new InnerDisposable[len + 1];, +        @SuppressWarnings("unchecked"), +                InnerDisposable<T>[] c = observers.get();, +                int len = c.length;, +                if (len == 0) {, +                InnerDisposable<T>[] u;, +     * {@code this} holds the parent PublishObserver or itself if disposed, +    static final class InnerDisposable<T>, +    extends AtomicReference<Object>, +    implements Disposable {, +        private static final long serialVersionUID = -1100270633763673112L;, +        InnerDisposable(Observer<? super T> child) {, +            return get() == this;, +        @SuppressWarnings("unchecked"), +            Object o = getAndSet(this);, +            if (o != null && o != this) {, +                ((PublishObserver<T>)o).remove(this);, +            }, +        }, +, +        void setParent(PublishObserver<T> p) {, +            if (!compareAndSet(null, p)) {, +                p.remove(this);, +++ b/src/main/java/io/reactivex/Observable.java, +        return ObservablePublish.create(this);, +        return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, +            if (b != null) {, +        }, +                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java, +import io.reactivex.functions.Consumer;, +import io.reactivex.internal.disposables.DisposableHelper;]