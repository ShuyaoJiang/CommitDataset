[+++ b/src/main/java/rx/Single.java, + * The Single class implements the Reactive Pattern for a single value response. See {@link Observable} for the, + * implementation of the Reactive Pattern for a stream or vector of values., + * {@code Single} behaves the same as {@link Observable} except that it can only emit either a single successful, + * value, or an error (there is no "onComplete" notification as there is for {@link Observable}), + * Like an {@link Observable}, a {@code Single} is lazy, can be either "hot" or "cold", synchronous or, + * asynchronous., + * For more information see the <a href="http://reactivex.io/documentation/observable.html">ReactiveX, + * documentation</a>., + * @since (If this class graduates from "Experimental" replace this parenthetical with the release number), +     *            {@link OnExecute} to be executed when {@link #execute(SingleSubscriber)} or, +     *            {@link #subscribe(Subscriber)} is called, +     * Returns a Single that will execute the specified function when a {@link SingleSubscriber} executes it or, +     * a {@link Subscriber} subscribes to it., +     * SingleSubscriber {@link SingleSubscriber#onSuccess onSuccess} and/or, +     * {@link SingleSubscriber#onError onError} methods appropriately., +     *            a function that accepts an {@code SingleSubscriber<T>}, and invokes its {@code onSuccess} or, +     *            {@code onError} methods as appropriate, +     * Lifts a function to the current Single and returns a new Single that when subscribed to will pass the, +     * values of the current Single through the Operator function., +     * <p>, +     * {@code task.map(...).filter(...).lift(new OperatorA()).lift(new OperatorB(...)).subscribe() }, +     * <p>, +     * If the operator you are creating is designed to act on the item emitted by a source Single, use, +     * {@code lift}. If your operator is designed to transform the source Single as a whole (for instance, by, +     * applying a particular set of existing RxJava operators to it) use {@link #compose}., +     * Transform a Single by applying a particular Transformer function to it., +     * This method operates on the Single itself whereas {@link #lift} operates on the Single's Subscribers or, +     * Observers., +     * If the operator you are creating is designed to act on the individual item emitted by a Single, use, +     * {@link #lift}. If your operator is designed to transform the source Single as a whole (for instance, by, +     * applying a particular set of existing RxJava operators to it) use {@code compose}., +     *            implements the function that transforms the source Single, +     * @return the source Single, transformed by the transformer function, +     *, +     * @warn more complete description needed, +     * Converts the source {@code Single<T>} into an {@code Single<Observable<T>>} that emits an Observable, +     * that emits the same emission as the source Single., +     * @return a Single that emits an Observable that emits the same item as the source Single, +     * Returns an Observable that emits the items emitted by two Singles, one after the other., +     * @return an Observable that emits items emitted by the two source Singles, one after the other., +     * Returns an Observable that emits the items emitted by three Singles, one after the other., +     * @return an Observable that emits items emitted by the three source Singles, one after the other., +     * Returns an Observable that emits the items emitted by four Singles, one after the other., +     * @return an Observable that emits items emitted by the four source Singles, one after the other., +     * Returns an Observable that emits the items emitted by five Singles, one after the other., +     * @return an Observable that emits items emitted by the five source Singles, one after the other., +     * Returns an Observable that emits the items emitted by six Singles, one after the other., +     * @return an Observable that emits items emitted by the six source Singles, one after the other., +     * Returns an Observable that emits the items emitted by seven Singles, one after the other., +     * @return an Observable that emits items emitted by the seven source Singles, one after the other., +     * Returns an Observable that emits the items emitted by eight Singles, one after the other., +     * @return an Observable that emits items emitted by the eight source Singles, one after the other., +     * Returns an Observable that emits the items emitted by nine Singles, one after the other., +     * @return an Observable that emits items emitted by the nine source Singles, one after the other., +     * Returns a Single that invokes a subscriber's {@link SingleSubscriber#onError onError} method when the, +     * subscriber subscribes to it., +     *            the particular Throwable to pass to {@link SingleSubscriber#onError onError}, +     *            the type of the item (ostensibly) emitted by the Single, +     * @return a Single that invokes the subscriber's {@link SingleSubscriber#onError onError} method when, +     *         the subscriber subscribes to it, +     * Converts a {@link Future} into a {@code Single}., +     * You can convert any object that supports the {@link Future} interface into a Single that emits the return, +     * value of the {@link Future#get} method of that object, by passing the object into the {@code from}, +     * method., +     * <em>Important note:</em> This Single is blocking; you cannot unsubscribe from it., +     *            the resulting {@code Single}, +     * @return a {@code Single} that emits the item from the source {@link Future}, +     * Converts a {@link Future} into a {@code Single}, with a timeout on the Future., +     * You can convert any object that supports the {@link Future} interface into a {@code Single} that emits, +     * the return value of the {@link Future#get} method of that object, by passing the object into the, +     * {@code from} method., +     * <em>Important note:</em> This {@code Single} is blocking; you cannot unsubscribe from it., +     *            the resulting {@code Single}, +     * @return a {@code Single} that emits the item from the source {@link Future}, +     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a {@code Single}., +     * You can convert any object that supports the {@link Future} interface into a {@code Single} that emits, +     * the return value of the {@link Future#get} method of that object, by passing the object into the, +     * {@code from} method., +     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as, +     *            {@link Schedulers#io()} that can block and wait on the Future, +     *            the resulting {@code Single}, +     * @return a {@code Single} that emits the item from the source {@link Future}, +     * Returns a {@code Single} that emits a specified item., +     * To convert any object into a {@code Single} that emits that object, pass that object into the, +     * {@code just} method., +     * @return a {@code Single} that emits {@code value}, +     * Flattens a {@code Single} that emits a {@code Single} into a single {@code Single} that emits the item, +     * emitted by the nested {@code Single}, without any transformation., +     *            a {@code Single} that emits a {@code Single}, +     * @return a {@code Single} that emits the item that is the result of flattening the {@code Single} emitted, +     *         by {@code source}, +     * Flattens two Singles into a single Observable, without any transformation., +     * You can combine items emitted by multiple Singles so that they appear as a single Observable, by, +     * @return an Observable that emits all of the items emitted by the source Singles, +     * Flattens three Singles into a single Observable, without any transformation., +     * You can combine items emitted by multiple Singles so that they appear as a single Observable, by using, +     * the {@code merge} method., +     * @return an Observable that emits all of the items emitted by the source Singles, +     * Flattens four Singles into a single Observable, without any transformation.]