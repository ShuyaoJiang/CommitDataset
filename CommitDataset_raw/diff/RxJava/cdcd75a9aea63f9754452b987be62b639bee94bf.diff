[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +import java.util.Collection;, +import java.util.Map;, +, +import rx.observables.GroupedObservable;, +    @Test, +    public void testGroupBy() {, +        int count=0;, +        , +        Observable.from("one", "two", "three", "four", "five", "six"), +        .groupBy({String s -> s.length()}), +        .mapMany({, +            groupObservable ->, +            , +            return groupObservable.map({, +                s ->, +                return "Value: " + s + " Group: " + groupObservable.getKey(); , +            });, +          }).toBlockingObservable().forEach({, +            s ->, +            println(s);, +            count++;, +          }), +          , +          assertEquals(6, count);, +    }, +    , +, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +import java.util.Collection;, +import java.util.Map;, +, +import rx.observables.GroupedObservable;, +    @Test, +    public void testGroupBy() {, +        int count=0;, +        , +        Observable.from("one", "two", "three", "four", "five", "six"), +        .groupBy({String s -> s.length()}), +        .mapMany({, +            groupObservable ->, +            , +            return groupObservable.map({, +                s ->, +                return "Value: " + s + " Group: " + groupObservable.getKey(); , +            });, +          }).toBlockingObservable().forEach({, +            s ->, +            println(s);, +            count++;, +          }), +          , +          assertEquals(6, count);, +    }, +    , +, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.OnErrorNotImplementedException;, + * This interface provides overloaded methods for subscribing as well as delegate methods to the, + * various operators., + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava, + * Wiki</a>, +//TODO use a consistent parameter naming scheme (for example: for all operators that modify a source Observable, the parameter representing that source Observable should have the same name, e.g. "source" -- currently such parameters are named any of "sequence", "that", "source", "items", or "observable"), +, +     * Observable with Function to execute when subscribed to., +     * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you, +     * specifically have a need for inheritance., +    protected Observable() {, +        this(null);, +        //TODO should this be made private to prevent it? It really serves no good purpose and only confuses things. Unit tests are incorrectly using it today, +    }, +, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * receive items and notifications from the Observable. A typical implementation of, +     * <code>subscribe</code> does the following:, +     * It stores a reference to the Observer in a collection object, such as a, +     * <code>List&lt;T&gt;</code> object., +     * It returns a reference to the {@link Subscription} interface. This enables Observers to, +     * unsubscribe, that is, to stop receiving items and notifications before the Observable stops, +     * sending them, which also invokes the Observer's {@link Observer#onCompleted onCompleted}, +     * method., +     * An <code>Observable&lt;T&gt;</code> instance is responsible for accepting all subscriptions, +     * and notifying all Observers. Unless the documentation for a particular, +     * <code>Observable&lt;T&gt;</code> implementation indicates otherwise, Observers should make no, +     * assumptions about the order in which multiple Observers will receive their notifications., +     * For more information see the, +     * <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, +     * @return a {@link Subscription} reference with which the Observer can stop receiving items, +     *         before the Observable has finished sending them, +     * @throws IllegalArgumentException, +     *             if the {@link Observer} provided as the argument to <code>subscribe()</code> is, +     *             <code>null</code>, +        if (observer == null) {, +            throw new IllegalArgumentException("observer can not be null");, +        }, +        } catch (OnErrorNotImplementedException e) {, +            // special handling when onError is not implemented ... we just rethrow, +            throw e;, +            } catch (OnErrorNotImplementedException e2) {, +                // special handling when onError is not implemented ... we just rethrow]