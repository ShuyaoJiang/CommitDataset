[+++ b/CHANGES.md, +### Version 1.0.5 â€“ Feburary 3rd 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.5%7C)) ###, +, +This release includes many bug fixes along with a few new operators and enhancements., +, +#### Experimental Operators, +, +This release adds a few experimental operators. , +, +Note that these APIs [may still change or be removed altogether](https://github.com/ReactiveX/RxJava#experimental) since they are marked as `@Experimental`. , +, +##### takeUntil(predicate), +, +This operator allows conditionally unsubscribing an `Observable` but inclusively emitting the final `onNext`. This differs from `takeWhile` which excludes the final `onNext`., +, +```java, +// takeUntil(predicate) example, +Observable.just(1, 2, 3, 4, 5, 6, 7), +        .doOnEach(System.out::println), +        .takeUntil(i -> i == 3), +        .forEach(System.out::println);, +, +// takeWhile(predicate) example, +Observable.just(1, 2, 3, 4, 5, 6, 7), +        .doOnEach(System.out::println), +        .takeWhile(i -> i <= 3), +        .forEach(System.out::println);, +```, +, +This outputs:, +, +```, +// takeUntil(predicate), +[rx.Notification@30e84925 OnNext 1], +1, +[rx.Notification@30e84926 OnNext 2], +2, +[rx.Notification@30e84927 OnNext 3], +3, +, +// takeWhile(predicate), +[rx.Notification@30e84925 OnNext 1], +1, +[rx.Notification@30e84926 OnNext 2], +2, +[rx.Notification@30e84927 OnNext 3], +3, +[rx.Notification@30e84928 OnNext 4], +```, +, +Note how `takeWhile` produces 4 values and `takeUntil` produces 3., +, +##### switchIfEmpty, +, +The new `switchIfEmpty` operator is a companion to `defaultIfEmpty` that switches to a different `Observable` if the primary `Observable` is empty., +, +```java, +Observable.empty(), +        .switchIfEmpty(Observable.just(1, 2, 3)), +        .forEach(System.out::println);, +```, +, +#### Enhancements, +, +##### merge(maxConcurrent) with backpressure, +, +This release adds backpressure to `merge(maxConcurrent)` so that horizontal buffer bloat can also be controll with the `maxConcurrent` parameter., +, +This allows parallel execution such as the following to work with backpressure:, +, +```java, +public class MergeMaxConcurrent {, +, +    public static void main(String[] args) {, +        // define 1,000,000 async tasks, +        Observable<Observable<Integer>> asyncWork = range(1, 1000000), +                      .doOnNext(i -> System.out.println("Value: " + i)), +                .doOnRequest(r -> System.out.println("request1 " + r)), +                .map(item -> {, +                    return just(item), +                            // simulate slow IO or computation, +                            .doOnNext(MergeMaxConcurrent::sleep), +                            .subscribeOn(Schedulers.io());, +                }), +                .doOnRequest(r -> System.out.println("request2 " + r));, +                , +        // allow 10 outstanding tasks at a time, +        merge(asyncWork, 10).toBlocking().forEach(System.out::println);, +    }, +, +    public static void sleep(int value) {, +        try {, +            Thread.sleep(1000);, +        } catch (InterruptedException e) {, +            e.printStackTrace();, +        }, +    }, +}, +```, +]