[+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            BackpressureUtils.getAndAddRequest(group.requested, n);, +            //don't need to check for requested being Long.MAX_VALUE because this, +            //field is capped at MAX_QUEUE_SIZE, +                if (keyRequested.get() != Long.MAX_VALUE) {, +                    // best endeavours check (no CAS loop here) because we mainly care about , +                    // the initial request being Long.MAX_VALUE and that value being conserved., +                }, +                    if (groupState.requested.get()!=Long.MAX_VALUE) {, +                        // best endeavours check (no CAS loop here) because we mainly care about , +                        // the initial request being Long.MAX_VALUE and that value being conserved., +                    }, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            BackpressureUtils.getAndAddRequest(group.requested, n);, +            //don't need to check for requested being Long.MAX_VALUE because this, +            //field is capped at MAX_QUEUE_SIZE, +                if (keyRequested.get() != Long.MAX_VALUE) {, +                    // best endeavours check (no CAS loop here) because we mainly care about , +                    // the initial request being Long.MAX_VALUE and that value being conserved., +                }, +                    if (groupState.requested.get()!=Long.MAX_VALUE) {, +                        // best endeavours check (no CAS loop here) because we mainly care about , +                        // the initial request being Long.MAX_VALUE and that value being conserved., +                    }, +++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    , +    @Test, +    public void testRequestOverflow() {, +        final AtomicBoolean completed = new AtomicBoolean(false);, +        Observable, +                .just(1, 2, 3), +                // group into one group, +                .groupBy(new Func1<Integer, Integer>() {, +                    @Override, +                    public Integer call(Integer t) {, +                        return 1;, +                    }, +                }), +                // flatten, +                .concatMap(new Func1<GroupedObservable<Integer, Integer>, Observable<Integer>>() {, +                    @Override, +                    public Observable<Integer> call(GroupedObservable<Integer, Integer> g) {, +                        return g;, +                    }, +                }), +                .subscribe(new Subscriber<Integer>() {, +                    , +                    @Override, +                    public void onStart() {, +                        request(2);, +                    }, +, +                    @Override, +                    public void onCompleted() {, +                        completed.set(true);, +                        , +                    }, +, +                    @Override, +                    public void onError(Throwable e) {, +                        , +                    }, +, +                    @Override, +                    public void onNext(Integer t) {, +                        System.out.println(t);, +                        //provoke possible request overflow, +                        request(Long.MAX_VALUE-1);, +                    }});, +        assertTrue(completed.get());, +    }]