[+++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java, +import java.util.concurrent.atomic.AtomicLong;, +import rx.*;, +    private static final class RangeProducer extends AtomicLong implements Producer {, +        /** */, +        private static final long serialVersionUID = 4114392207069098388L;, +        , +        private long index;, +            if (get() == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && compareAndSet(0L, Long.MAX_VALUE)) {, +                fastpath();, +            } else if (n > 0L) {, +                long c = BackpressureUtils.getAndAddRequest(this, n);, +                if (c == 0L) {, +                    // backpressure is requested, +                    slowpath(n);, +                }, +            }, +        }, +, +        /**, +         * , +         */, +        void slowpath(long r) {, +            long idx = index;, +            while (true) {, +                /*, +                 * This complicated logic is done to avoid touching the volatile `index` and `requested` values, +                 * during the loop itself. If they are touched during the loop the performance is impacted significantly., +                 */, +                long fs = end - idx + 1;, +                long e = Math.min(fs, r);, +                final boolean complete = fs <= r;, +, +                fs = e + idx;, +                final Subscriber<? super Integer> o = this.o;, +                , +                for (long i = idx; i != fs; i++) {, +                    if (o.isUnsubscribed()) {, +                        return;, +                    }, +                    o.onNext((int) i);, +                }, +                , +                if (complete) {, +                    if (o.isUnsubscribed()) {, +                        return;, +                    }, +                    o.onCompleted();, +                    return;, +                }, +                , +                idx = fs;, +                index = fs;, +                , +                r = addAndGet(-e);, +                if (r == 0L) {, +                    // we're done emitting the number requested so return, +                    return;, +                }, +            }, +        }, +, +        /**, +         * , +         */, +        void fastpath() {, +            final long end = this.end + 1L;, +            final Subscriber<? super Integer> o = this.o;, +            for (long i = index; i != end; i++) {, +++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java, +import java.util.concurrent.atomic.AtomicLong;, +import rx.*;, +    private static final class RangeProducer extends AtomicLong implements Producer {, +        /** */, +        private static final long serialVersionUID = 4114392207069098388L;, +        , +        private long index;, +            if (get() == Long.MAX_VALUE) {, +            if (n == Long.MAX_VALUE && compareAndSet(0L, Long.MAX_VALUE)) {, +                fastpath();, +            } else if (n > 0L) {, +                long c = BackpressureUtils.getAndAddRequest(this, n);, +                if (c == 0L) {, +                    // backpressure is requested, +                    slowpath(n);, +                }, +            }, +        }, +, +        /**, +         * , +         */, +        void slowpath(long r) {, +            long idx = index;, +            while (true) {, +                /*, +                 * This complicated logic is done to avoid touching the volatile `index` and `requested` values, +                 * during the loop itself. If they are touched during the loop the performance is impacted significantly., +                 */]