[+++ b/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +        private boolean chosen;, +        public void onNext(T t) {, +            subscriber.onNext(t);, +            if (chosen) {, +                return true;, +            }, +                chosen = true;, +                    chosen = true;, +    //give default access instead of private as a micro-optimization , +    //for access from anonymous classes below, +    final Iterable<? extends Observable<? extends T>> sources;, +    final Selection<T> selection = new Selection<T>();, +    final AtomicReference<AmbSubscriber<T>> choice = selection.choice;, +        , +        //setup unsubscription of all the subscribers to the sources, +                AmbSubscriber<T> c;, +                if ((c = choice.get()) != null) {, +                    c.unsubscribe();, +                // if subscriptions are occurring as this is happening then this call may not , +                // unsubscribe everything. We protect ourselves though by doing another unsubscribe check, +                // after the subscription loop below, +                unsubscribeAmbSubscribers(selection.ambSubscribers);, +        //need to subscribe to all the sources, +            AmbSubscriber<T> ambSubscriber = new AmbSubscriber<T>(0, subscriber, selection);, +            // check again if choice has been made so can stop subscribing, +            // if all sources were backpressure aware then this check , +            // would be pointless given that 0 was requested above from each ambSubscriber, +            AmbSubscriber<T> c;, +            if ((c = choice.get()) != null) {, +                selection.unsubscribeOthers(c);, +                return;, +        // while subscribing unsubscription may have occurred so we clean up after, +        if (subscriber.isUnsubscribed()) {, +            unsubscribeAmbSubscribers(selection.ambSubscribers);, +        }, +, +        subscriber.setProducer(new Producer() {, +, +            @Override, +            public void request(long n) {, +                final AmbSubscriber<T> c;, +                if ((c = choice.get()) != null) {, +                    // propagate the request to that single Subscriber that won, +                    c.requestMore(n);, +                } else {, +                    //propagate the request to all the amb subscribers, +                    for (AmbSubscriber<T> ambSubscriber: selection.ambSubscribers) {, +                        if (!ambSubscriber.isUnsubscribed()) {, +                            // make a best endeavours check to not waste requests , +                            // if first emission has already occurred, +                            if (choice.get() == ambSubscriber) {, +                                ambSubscriber.requestMore(n);, +                                // don't need to request from other subscribers because choice has been made, +                                // and request has gone to choice , +                                return;, +                            } else {, +                                ambSubscriber.requestMore(n);, +                            }, +                        }, +                    }, +    private static <T> void unsubscribeAmbSubscribers(Collection<AmbSubscriber<T>> ambSubscribers) {, +        if(!ambSubscribers.isEmpty()) {, +            for (AmbSubscriber<T> other : ambSubscribers) {, +                other.unsubscribe();, +            }, +            ambSubscribers.clear();, +        }, +    }, +++ b/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +        private boolean chosen;, +        public void onNext(T t) {, +            subscriber.onNext(t);, +            if (chosen) {, +                return true;, +            }, +                chosen = true;, +                    chosen = true;, +    //give default access instead of private as a micro-optimization , +    //for access from anonymous classes below, +    final Iterable<? extends Observable<? extends T>> sources;, +    final Selection<T> selection = new Selection<T>();, +    final AtomicReference<AmbSubscriber<T>> choice = selection.choice;, +        , +        //setup unsubscription of all the subscribers to the sources, +                AmbSubscriber<T> c;, +                if ((c = choice.get()) != null) {, +                    c.unsubscribe();, +                // if subscriptions are occurring as this is happening then this call may not , +                // unsubscribe everything. We protect ourselves though by doing another unsubscribe check, +                // after the subscription loop below, +                unsubscribeAmbSubscribers(selection.ambSubscribers);, +        //need to subscribe to all the sources, +            AmbSubscriber<T> ambSubscriber = new AmbSubscriber<T>(0, subscriber, selection);, +            // check again if choice has been made so can stop subscribing, +            // if all sources were backpressure aware then this check , +            // would be pointless given that 0 was requested above from each ambSubscriber, +            AmbSubscriber<T> c;, +            if ((c = choice.get()) != null) {, +                selection.unsubscribeOthers(c);]