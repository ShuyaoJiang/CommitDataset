[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def groupByUntilExample() {, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +  }, +, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def groupByUntilExample() {, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +  }, +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Groups the items emitted by this Observable according to a specified discriminator function and terminates these groups, +   * according to a function., +   *, +   * @param f, +   *            a function that extracts the key from an item, +   * @param closings, +   *            the function that accepts the key of a given group and an observable representing that group, and returns, +   *            an observable that emits a single Closing when the group should be closed., +   * @tparam K , +   *            the type of the keys returned by the discriminator function., +   * @tparam Closing, +   *            the type of the element emitted from the closings observable., +   * @return an Observable that emits `(key, observable)` pairs, where `observable`, +   *         contains all items for which `f` returned `key` before `closings` emits a value., +   */, +  def groupByUntil[K, Closing](f: T => K, closings: (K, Observable[T])=>Observable[Closing]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Closing]] =, +      (jGrObs: rx.observables.GroupedObservable[K, _ <: T]) => closings(jGrObs.getKey, toScalaObservable[T](jGrObs)).asJavaObservable, +    val o1 = asJavaObservable.groupByUntil[K, Closing](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +    val func = (o: rx.observables.GroupedObservable[K, _ <: T]) => (o.getKey, toScalaObservable[T](o)), +    toScalaObservable[(K, Observable[T])](o1.map[(K, Observable[T])](func)), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def groupByUntilExample() {, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +  }, +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Groups the items emitted by this Observable according to a specified discriminator function and terminates these groups, +   * according to a function., +   *, +   * @param f, +   *            a function that extracts the key from an item, +   * @param closings, +   *            the function that accepts the key of a given group and an observable representing that group, and returns, +   *            an observable that emits a single Closing when the group should be closed., +   * @tparam K , +   *            the type of the keys returned by the discriminator function., +   * @tparam Closing, +   *            the type of the element emitted from the closings observable., +   * @return an Observable that emits `(key, observable)` pairs, where `observable`, +   *         contains all items for which `f` returned `key` before `closings` emits a value., +   */, +  def groupByUntil[K, Closing](f: T => K, closings: (K, Observable[T])=>Observable[Closing]): Observable[(K, Observable[T])] = {, +    val fclosing: Func1[_ >: rx.observables.GroupedObservable[K, _ <: T], _ <: rx.Observable[_ <: Closing]] =, +      (jGrObs: rx.observables.GroupedObservable[K, _ <: T]) => closings(jGrObs.getKey, toScalaObservable[T](jGrObs)).asJavaObservable, +    val o1 = asJavaObservable.groupByUntil[K, Closing](f, fclosing) : rx.Observable[_ <: rx.observables.GroupedObservable[K, _ <: T]], +    val func = (o: rx.observables.GroupedObservable[K, _ <: T]) => (o.getKey, toScalaObservable[T](o)), +    toScalaObservable[(K, Observable[T])](o1.map[(K, Observable[T])](func)), +  }, +, +  /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +    public <TKey, TDuration> Observable<GroupedObservable<TKey, T>> groupByUntil(Func1<? super T, ? extends TKey> keySelector, Func1<? super GroupedObservable<TKey, T>, ? extends Observable<? extends TDuration>> durationSelector) {, +    public <TKey, TValue, TDuration> Observable<GroupedObservable<TKey, TValue>> groupByUntil(Func1<? super T, ? extends TKey> keySelector, Func1<? super T, ? extends TValue> valueSelector, Func1<? super GroupedObservable<TKey, TValue>, ? extends Observable<? extends TDuration>> durationSelector) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def groupByUntilExample() {, +    val numbers = Observable.interval(250 millis) take 14, +    val grouped = numbers.groupByUntil[Long, Long](, +      {case x => x % 2},, +      {case (key, obs) => obs filter {case x => x == 7}}, +    ), +    val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, +    sequenced subscribe {x => println(s"Emitted group: $x")}, +  }, +]