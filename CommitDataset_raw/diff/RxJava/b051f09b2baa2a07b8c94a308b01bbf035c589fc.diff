[+++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +  val correspondence = defaultMethodCorrespondence ++ Map(, +      // manually added entries for Java instance methods, +      "window(Long, Long, TimeUnit, Scheduler)" -> "window(Duration, Duration, Scheduler)",, +      , +      // manually added entries for Java static methods, +      "create(OnSubscribeFunc[T])" -> "apply(Observer[T] => Subscription)",, +      "defer(Func0[_ <: Observable[_ <: T]])" -> "defer(=> Observable[T])",, +      "empty()" -> "apply(T*)",, +      "error(Throwable)" -> "apply(Throwable)",, +      "from(Array[T])" -> "apply(T*)",, +      "from(Iterable[_ <: T])" -> "apply(T*)", , +      "merge(Observable[_ <: T], Observable[_ <: T])" -> "merge(Observable[T])",, +      "mergeDelayError(Observable[_ <: T], Observable[_ <: T])" -> "mergeDelayError(Observable[T])",, +      "range(Int, Int)" -> "apply(Range)",, +      "sequenceEqual(Observable[_ <: T], Observable[_ <: T])" -> "[use (first zip second) map (p => p._1 == p._2)]",, +      "sequenceEqual(Observable[_ <: T], Observable[_ <: T], Func2[_ >: T, _ >: T, Boolean])" -> "[use (first zip second) map (p => equality(p._1, p._2))]",, +      "switchDo(Observable[_ <: Observable[_ <: T]])" -> "switch",, +      "synchronize(Observable[_ <: T])" -> "synchronize",, +      "zip(Observable[_ <: T1], Observable[_ <: T2], Func2[_ >: T1, _ >: T2, _ <: R])" -> "[use instance method zip and map]", +  ).toMap ++ List.iterate("Observable[_ <: T]", 9)(s => s + ", Observable[_ <: T]").map(, +      // concat 2-9, +      "concat(" + _ + ")" -> "[unnecessary because we can use ++ instead]", +  ).drop(1).toMap ++ List.iterate("T", 10)(s => s + ", T").map(, +      // all 10 overloads of from:, +      "from(" + _ + ")" -> "apply(T*)", +  ).toMap ++ (3 to 9).map(i => {, +    // zip3-9:, +    val obsArgs = (1 to i).map(j => s"Observable[_ <: T$j], ").mkString(""), +    val funcParams = (1 to i).map(j => s"_ >: T$j, ").mkString(""), +    ("zip(" + obsArgs + "Func" + i + "[" + funcParams + "_ <: R])", unnecessary), +  }).toMap, +  // also applicable for Java types, +  def getPublicInstanceAndCompanionMethods(tp: Type): Iterable[String] = , +    getPublicInstanceMethods(tp) ++, +  , +  @Ignore // because spams output, +  @Ignore // because spams output, +  @Ignore // because spams output, +  @Ignore // because spams output, +  def defaultMethodCorrespondence: Map[String, String] = {, +    val allMethods = getPublicInstanceAndCompanionMethods(typeOf[rx.Observable[_]])      , +    val tuples = for (javaM <- allMethods) yield (javaM, javaMethodSignatureToScala(javaM)), +  @Ignore // because spams output, +  @Test def printDefaultMethodCorrespondence: Unit = {, +    println("\nDefault Method Correspondence"), +    println(  "-----------------------------\n"), +    val c = SortedMap(defaultMethodCorrespondence.toSeq : _*), +  @Ignore // because spams output, +  @Test def printCorrectedMethodCorrespondence: Unit = {, +    println("\nCorrected Method Correspondence"), +    println(  "-------------------------------\n"), +    val c = SortedMap(correspondence.toSeq : _*), +    for ((javaM, scalaM) <- c) {, +      println("%s -> %s,".format("\"" + javaM + "\"", "\"" + scalaM + "\"")) , +    }, +  }, +  , +    val actualMethods = getPublicInstanceAndCompanionMethods(tp).toSet, +    val actualMethods = getPublicInstanceAndCompanionMethods(typeOf[rx.lang.scala.Observable[_]]).toSet, +    println(s"\n$status: $bad out of ${bad+good} methods were not found in Scala Observable"), +  @Ignore // because we prefer the verbose version, +  @Test def checkScalaMethodPresence: Unit = {, +    checkMethodPresence(correspondence.values, typeOf[rx.lang.scala.Observable[_]]), +  }, +  ]