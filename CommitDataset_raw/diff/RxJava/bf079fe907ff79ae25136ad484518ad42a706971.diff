[+++ b/rxjava/src/main/java/rx/observables/BlockingObservable.java, +        return blockForSingle(o.first());, +        return blockForSingle(o.first(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).firstOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).firstOrDefault(defaultValue));, +        return blockForSingle(o.last());, +        return blockForSingle(o.last(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).lastOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).lastOrDefault(defaultValue));, +        return blockForSingle(o.single());, +        return blockForSingle(o.single(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).singleOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).singleOrDefault(defaultValue));, +, +    /**, +     * Helper method which handles the actual blocking for a single response., +     * <p>, +     * If the {@link Observable} errors, it will be thrown right away., +     *, +     * @return the actual item., +     */, +    private T blockForSingle(final Observable<? extends T> observable) {, +        final AtomicReference<T> returnItem = new AtomicReference<T>();, +        final AtomicReference<Throwable> returnException = new AtomicReference<Throwable>();, +        final CountDownLatch latch = new CountDownLatch(1);, +, +        observable.subscribe(new Subscriber<T>() {, +            @Override, +            public void onCompleted() {, +                latch.countDown();, +            }, +, +            @Override, +            public void onError(final Throwable e) {, +                returnException.set(e);, +                latch.countDown();, +            }, +, +            @Override, +            public void onNext(final T item) {, +                returnItem.set(item);, +            }, +        });, +, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);, +        }, +, +        if (returnException.get() != null) {, +            if (returnException.get() instanceof RuntimeException) {, +                throw (RuntimeException) returnException.get();, +            } else {, +                throw new RuntimeException(returnException.get());, +            }, +        }, +, +        return returnItem.get();, +    }, +++ b/rxjava/src/main/java/rx/observables/BlockingObservable.java, +        return blockForSingle(o.first());, +        return blockForSingle(o.first(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).firstOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).firstOrDefault(defaultValue));, +        return blockForSingle(o.last());, +        return blockForSingle(o.last(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).lastOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).lastOrDefault(defaultValue));, +        return blockForSingle(o.single());, +        return blockForSingle(o.single(predicate));, +        return blockForSingle(o.map(Functions.<T>identity()).singleOrDefault(defaultValue));, +        return blockForSingle(o.filter(predicate).map(Functions.<T>identity()).singleOrDefault(defaultValue));, +, +    /**, +     * Helper method which handles the actual blocking for a single response., +     * <p>, +     * If the {@link Observable} errors, it will be thrown right away., +     *, +     * @return the actual item., +     */, +    private T blockForSingle(final Observable<? extends T> observable) {, +        final AtomicReference<T> returnItem = new AtomicReference<T>();, +        final AtomicReference<Throwable> returnException = new AtomicReference<Throwable>();, +        final CountDownLatch latch = new CountDownLatch(1);, +, +        observable.subscribe(new Subscriber<T>() {, +            @Override, +            public void onCompleted() {, +                latch.countDown();, +            }, +, +            @Override, +            public void onError(final Throwable e) {, +                returnException.set(e);, +                latch.countDown();, +            }, +, +            @Override]