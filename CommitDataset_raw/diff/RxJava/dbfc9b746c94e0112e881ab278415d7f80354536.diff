[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCast;, +import rx.operators.OperationDefaultIfEmpty;, +     * Accepts an Observable and wraps it in another Observable that ensures that the resulting, +     * Observable is chronologically well-behaved. This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     * <p>, +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +     * <p>, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     *, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     *            the type of item emitted by the source Observable, +     * @return an Observable that is a chronologically well-behaved version of the source, +     *         Observable, and that synchronously notifies its {@link Observer}s, +     */, +    public Observable<T> synchronize(Object lock) {, +        return create(OperationSynchronize.synchronize(this, lock));, +    }, +, +    /**, +    /**, +     * Returns the elements of the specified sequence or the specified default, +     * value in a singleton sequence if the sequence is empty., +     *, +     * @param defaultValue, +     *            The value to return if the sequence is empty., +     * @return An observable sequence that contains the specified default value, +     *         if the source is empty; otherwise, the elements of the source, +     *         itself., +     *, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229624(v=vs.103).aspx">MSDN: Observable.DefaultIfEmpty</a>, +     */, +    public Observable<T> defaultIfEmpty(T defaultValue) {, +        return create(OperationDefaultIfEmpty.defaultIfEmpty(this, defaultValue));, +    }, +     * Converts the elements of an observable sequence to the specified type., +     *, +     * @param klass, +     *            The target class type which the elements will be converted to., +     *, +     * @return An observable sequence that contains each element of the source, +     *         sequence converted to the specified type., +     *, +     * @see <a, +     *      href="http://msdn.microsoft.com/en-us/library/hh211842(v=vs.103).aspx">MSDN:, +     *      Observable.Cast</a>, +     */, +    public <R> Observable<R> cast(final Class<R> klass) {, +        return create(OperationCast.cast(this, klass));, +    }, +, +    /**, +     * Filters the elements of an observable sequence based on the specified, +     * type., +     *, +     * @param klass, +     *            The class type to filter the elements in the source sequence, +     *            on., +     *, +     * @return An observable sequence that contains elements from the input, +     *         sequence of type klass., +     *, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229380(v=vs.103).aspx">MSDN: Observable.OfType</a>, +     */, +    public <R> Observable<R> ofType(final Class<R> klass) {, +        return filter(new Func1<T, Boolean>() {, +            public Boolean call(T t) {, +                return klass.isInstance(t);, +            }, +        }).cast(klass);, +    }, +, +    /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCast;, +import rx.operators.OperationDefaultIfEmpty;, +     * Accepts an Observable and wraps it in another Observable that ensures that the resulting, +     * Observable is chronologically well-behaved. This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     * <p>, +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +     * <p>, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     *, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     *            the type of item emitted by the source Observable, +     * @return an Observable that is a chronologically well-behaved version of the source]