[+++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +import rx.Subscription;, +        private final ScheduledUnsubscribe scheduledUnsubscribe;, +            this.scheduledUnsubscribe = new ScheduledUnsubscribe(recursiveScheduler);, +            subscriber.add(scheduledUnsubscribe);, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +    static final class ScheduledUnsubscribe implements Subscription {, +        final Scheduler.Worker worker;, +        volatile int once;, +        static final AtomicIntegerFieldUpdater<ScheduledUnsubscribe> ONCE_UPDATER, +                = AtomicIntegerFieldUpdater.newUpdater(ScheduledUnsubscribe.class, "once");, +, +        public ScheduledUnsubscribe(Scheduler.Worker worker) {, +            this.worker = worker;, +        }, +, +        @Override, +        public boolean isUnsubscribed() {, +            return once != 0;, +        }, +, +        @Override, +        public void unsubscribe() {, +            if (ONCE_UPDATER.getAndSet(this, 1) == 0) {, +                worker.schedule(new Action0() {, +                    @Override, +                    public void call() {, +                        worker.unsubscribe();, +                    }, +                });, +            }, +        }, +        , +    }, +++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +import rx.Subscription;, +        private final ScheduledUnsubscribe scheduledUnsubscribe;, +            this.scheduledUnsubscribe = new ScheduledUnsubscribe(recursiveScheduler);, +            subscriber.add(scheduledUnsubscribe);, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +            if (scheduledUnsubscribe.isUnsubscribed()) {, +                return;, +            }, +    static final class ScheduledUnsubscribe implements Subscription {, +        final Scheduler.Worker worker;, +        volatile int once;, +        static final AtomicIntegerFieldUpdater<ScheduledUnsubscribe> ONCE_UPDATER, +                = AtomicIntegerFieldUpdater.newUpdater(ScheduledUnsubscribe.class, "once");, +, +        public ScheduledUnsubscribe(Scheduler.Worker worker) {, +            this.worker = worker;, +        }, +, +        @Override, +        public boolean isUnsubscribed() {, +            return once != 0;, +        }, +, +        @Override, +        public void unsubscribe() {, +            if (ONCE_UPDATER.getAndSet(this, 1) == 0) {, +                worker.schedule(new Action0() {, +                    @Override, +                    public void call() {, +                        worker.unsubscribe();, +                    }, +                });, +            }, +        }, +        , +    }, +++ b/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java, +import static org.mockito.Matchers.anyInt;, +import rx.exceptions.TestException;, +    , +    @Test, +    public void testDelayedErrorDeliveryWhenSafeSubscriberUnsubscribes() {, +        TestScheduler testScheduler = new TestScheduler();, +        , +        Observable<Integer> source = Observable.concat(Observable.<Integer>error(new TestException()), Observable.just(1));, +        , +        , +        @SuppressWarnings("unchecked"), +        Observer<Integer> o = mock(Observer.class);, +        InOrder inOrder = inOrder(o);]