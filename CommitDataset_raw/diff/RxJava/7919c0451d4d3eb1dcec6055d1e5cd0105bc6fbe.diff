[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            merge next nth partition-all, +                            range reduce reductions, +(defn range, +  "Returns an Observable nums from start (inclusive) to end, +  (exclusive), by step, where start defaults to 0, step to 1, and end, +  to infinity., +, +  Note: this is not implemented on rx.Observable/range, +, +  See:, +    clojure.core/range, +  ", +  ([] (range 0 Double/POSITIVE_INFINITY 1)), +  ([end] (range 0 end 1)), +  ([start end] (range start end 1)), +  ([start end step], +   (observable* (fn [s], +                  (let [comp (if (pos? step) < >)], +                    (loop [i start], +                      (if-not (unsubscribed? s), +                        (if (comp i end), +                          (do, +                            (on-next s i), +                            (recur (+ i step))), +                          (on-completed s))))))))), +, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            merge next nth partition-all, +                            range reduce reductions, +(defn range, +  "Returns an Observable nums from start (inclusive) to end, +  (exclusive), by step, where start defaults to 0, step to 1, and end, +  to infinity., +, +  Note: this is not implemented on rx.Observable/range, +, +  See:, +    clojure.core/range, +  ", +  ([] (range 0 Double/POSITIVE_INFINITY 1)), +  ([end] (range 0 end 1)), +  ([start end] (range start end 1)), +  ([start end step], +   (observable* (fn [s], +                  (let [comp (if (pos? step) < >)], +                    (loop [i start], +                      (if-not (unsubscribed? s), +                        (if (comp i end), +                          (do, +                            (on-next s i), +                            (recur (+ i step))), +                          (on-completed s))))))))), +, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +(deftest test-range, +  (are [start end step] (= (range start end step), +                           (->> (rx/range start end step) (b/into []))), +       0   10  2, +       0 -100 -1, +       5 100   9), +, +  (are [start end] (= (range start end), +                      (->> (rx/range start end) (b/into []))), +       0   10, +       0 -100, +       5 100), +, +  (are [start] (= (->> (range start) (take 100)), +                  (->> (rx/range start) (rx/take 100) (b/into []))), +       50, +       0, +       5, +       -20), +  (is (= (->> (range) (take 500)), +         (->> (rx/range) (rx/take 500) (b/into []))))), +]