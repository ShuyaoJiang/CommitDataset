[+++ b/src/main/java/rx/schedulers/ExecutorScheduler.java, +import java.util.concurrent.*;, +, +import rx.*;, +import rx.internal.schedulers.ScheduledAction;, +import rx.subscriptions.*;, +        final ConcurrentLinkedQueue<ScheduledAction> queue; , +            this.queue = new ConcurrentLinkedQueue<ScheduledAction>();, +            ScheduledAction ea = new ScheduledAction(action, tasks);, +                    // note that since we schedule the emission of potentially multiple tasks, +                    // there is no clear way to cancel this schedule from individual tasks, +                    // so even if executor is an ExecutorService, we can't associate the future, +                    // returned by submit() with any particular ScheduledAction, +                ScheduledAction sa = queue.poll();, +                if (!sa.isUnsubscribed()) {, +                    sa.run();, +                }, +            final MultipleAssignmentSubscription first = new MultipleAssignmentSubscription();, +            mas.set(first);, +            tasks.add(mas);, +            final Subscription removeMas = Subscriptions.create(new Action0() {, +                public void call() {, +                    tasks.remove(mas);, +                }, +            });, +            , +            ScheduledAction ea = new ScheduledAction(new Action0() {, +                @Override, +                public void call() {, +                    // schedule the real action untimed, +                    Subscription s2 = schedule(action);, +                    mas.set(s2);, +                    // unless the worker is unsubscribed, we should get a new ScheduledAction, +                    if (s2.getClass() == ScheduledAction.class) {, +                        // when this ScheduledAction completes, we need to remove the, +                        // MAS referencing the whole setup to avoid leaks, +                        ((ScheduledAction)s2).add(removeMas);, +                }, +            });, +            // This will make sure if ea.call() gets executed before this line, +            // we don't override the current task in mas., +            first.set(ea);, +            // we don't need to add ea to tasks because it will be tracked through mas/first, +            , +            , +            try {, +                Future<?> f = service.schedule(ea, delayTime, unit);, +                ea.add(f);, +            /*, +             * This allows cancelling either the delayed schedule or the actual schedule referenced, +             * by mas and makes sure mas is removed from the tasks composite to avoid leaks., +             */, +            return removeMas;, +++ b/src/main/java/rx/schedulers/ExecutorScheduler.java, +import java.util.concurrent.*;, +, +import rx.*;, +import rx.internal.schedulers.ScheduledAction;, +import rx.subscriptions.*;, +        final ConcurrentLinkedQueue<ScheduledAction> queue; , +            this.queue = new ConcurrentLinkedQueue<ScheduledAction>();, +            ScheduledAction ea = new ScheduledAction(action, tasks);, +                    // note that since we schedule the emission of potentially multiple tasks, +                    // there is no clear way to cancel this schedule from individual tasks, +                    // so even if executor is an ExecutorService, we can't associate the future, +                    // returned by submit() with any particular ScheduledAction, +                ScheduledAction sa = queue.poll();, +                if (!sa.isUnsubscribed()) {, +                    sa.run();, +                }, +            final MultipleAssignmentSubscription first = new MultipleAssignmentSubscription();, +            mas.set(first);, +            tasks.add(mas);, +            final Subscription removeMas = Subscriptions.create(new Action0() {, +                public void call() {, +                    tasks.remove(mas);, +                }, +            });, +            , +            ScheduledAction ea = new ScheduledAction(new Action0() {, +                @Override, +                public void call() {, +                    // schedule the real action untimed, +                    Subscription s2 = schedule(action);, +                    mas.set(s2);, +                    // unless the worker is unsubscribed, we should get a new ScheduledAction, +                    if (s2.getClass() == ScheduledAction.class) {, +                        // when this ScheduledAction completes, we need to remove the, +                        // MAS referencing the whole setup to avoid leaks, +                        ((ScheduledAction)s2).add(removeMas);, +                }, +            });, +            // This will make sure if ea.call() gets executed before this line, +            // we don't override the current task in mas., +            first.set(ea);, +            // we don't need to add ea to tasks because it will be tracked through mas/first, +            , +            , +            try {, +                Future<?> f = service.schedule(ea, delayTime, unit);]