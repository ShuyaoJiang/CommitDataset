[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        return OperatorTakeUntil.takeUntil(source, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return OperatorTakeUntil.takeUntil(source, other);, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java, +    public static <T, E> Observable<T> takeUntil(final Observable<T> source, final Observable<E> other) {, +        Observable<Notification<T>> s = Observable.create(new SourceObservable<T>(source));, +        Observable<Notification<T>> o = Observable.create(new OtherObservable<T, E>(other));, +        Observable<Notification<T>> result = Observable.merge(s, o);, +, +        return result.takeWhile(new Func1<Notification<T>, Boolean>() {, +            @Override, +            public Boolean call(Notification<T> notification) {, +                return !notification.halt;, +            }, +        }).map(new Func1<Notification<T>, T>() {, +            @Override, +            public T call(Notification<T> notification) {, +                return notification.value;, +            }, +        });, +    private static class Notification<T> {, +        private final boolean halt;, +        private final T value;, +        public static <T> Notification<T> value(T value) {, +            return new Notification<T>(false, value);, +        }, +        public static <T> Notification<T> halt() {, +            return new Notification<T>(true, null);, +        }, +, +        private Notification(boolean halt, T value) {, +            this.halt = halt;, +            this.value = value;, +        }, +, +    }, +, +    private static class SourceObservable<T> implements Func1<Observer<Notification<T>>, Subscription> {, +        private final Observable<T> sequence;, +, +        private SourceObservable(Observable<T> sequence) {, +            this.sequence = sequence;, +        public Subscription call(final Observer<Notification<T>> notificationObserver) {, +            return sequence.subscribe(new Observer<T>() {, +                    notificationObserver.onNext(Notification.<T>halt());, +                    notificationObserver.onError(e);, +                public void onNext(T args) {, +                    notificationObserver.onNext(Notification.value(args));, +        }, +    }, +    private static class OtherObservable<T, E> implements Func1<Observer<Notification<T>>, Subscription> {, +        private final Observable<E> sequence;, +, +        private OtherObservable(Observable<E> sequence) {, +            this.sequence = sequence;, +        }, +, +        public Subscription call(final Observer<Notification<T>> notificationObserver) {, +            return sequence.subscribe(new Observer<E>() {, +                @Override, +                public void onCompleted() {, +                    // Ignore, +, +                @Override, +                public void onError(Exception e) {, +                    notificationObserver.onError(e);, +, +                @Override, +                public void onNext(E args) {, +                    notificationObserver.onNext(Notification.<T>halt());, +            Observable<String> stringObservable = takeUntil(source, other);, +            Observable<String> stringObservable = takeUntil(source, other);, +            Exception error = new Exception();, +            Observable<String> stringObservable = takeUntil(source, other);, +            source.sendOnError(error);, +            verify(result, times(1)).onError(error);, +            Exception error = new Exception();, +            Observable<String> stringObservable = takeUntil(source, other);, +            other.sendOnError(error);, +            verify(result, times(1)).onError(error);, +            Observable<String> stringObservable = takeUntil(source, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return OperatorTakeUntil.takeUntil(source, other);, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java, +    public static <T, E> Observable<T> takeUntil(final Observable<T> source, final Observable<E> other) {, +        Observable<Notification<T>> s = Observable.create(new SourceObservable<T>(source));, +        Observable<Notification<T>> o = Observable.create(new OtherObservable<T, E>(other));, +        Observable<Notification<T>> result = Observable.merge(s, o);, +, +        return result.takeWhile(new Func1<Notification<T>, Boolean>() {, +            @Override, +            public Boolean call(Notification<T> notification) {, +                return !notification.halt;, +            }, +        }).map(new Func1<Notification<T>, T>() {, +            @Override, +            public T call(Notification<T> notification) {, +                return notification.value;, +            }]