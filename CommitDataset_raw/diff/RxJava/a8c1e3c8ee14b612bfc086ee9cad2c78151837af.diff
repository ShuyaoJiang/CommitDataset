[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.operators.OperatorConcat;, +        return observables.lift(new OperatorConcat<T>());, +        return concat(from(t1, t2));, +        return concat(from(t1, t2, t3));, +        return concat(from(t1, t2, t3, t4));, +        return concat(from(t1, t2, t3, t4, t5));, +        return concat(from(t1, t2, t3, t4, t5, t6));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +        return create(OperationBuffer.buffer(this, bufferClosingSelector));, +        return create(OperationBuffer.buffer(this, count));, +        return create(OperationBuffer.buffer(this, count, skip));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, unit));, +        return create(OperationBuffer.buffer(this, timespan, unit, count));, +        return create(OperationBuffer.buffer(this, timespan, unit, count, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, unit, scheduler));, +        return create(OperationBuffer.buffer(this, bufferOpenings, bufferClosingSelector));, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary));, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary, initialCapacity));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.operators.OperatorConcat;, +        return observables.lift(new OperatorConcat<T>());, +        return concat(from(t1, t2));, +        return concat(from(t1, t2, t3));, +        return concat(from(t1, t2, t3, t4));, +        return concat(from(t1, t2, t3, t4, t5));, +        return concat(from(t1, t2, t3, t4, t5, t6));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return concat(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +        return create(OperationBuffer.buffer(this, bufferClosingSelector));, +        return create(OperationBuffer.buffer(this, count));, +        return create(OperationBuffer.buffer(this, count, skip));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit));, +        return create(OperationBuffer.buffer(this, timespan, timeshift, unit, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, unit));, +        return create(OperationBuffer.buffer(this, timespan, unit, count));, +        return create(OperationBuffer.buffer(this, timespan, unit, count, scheduler));, +        return create(OperationBuffer.buffer(this, timespan, unit, scheduler));, +        return create(OperationBuffer.buffer(this, bufferOpenings, bufferClosingSelector));, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary));, +        return create(OperationBuffer.bufferWithBoundaryObservable(this, boundary, initialCapacity));, +++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.functions.Func0;, +import rx.functions.Func1;, +import rx.schedulers.Schedulers;, +import rx.subscriptions.CompositeSubscription;, +, +public final class OperationBuffer extends ChunkedOperation {, +, +    private static <T> Func0<Buffer<T>> bufferMaker() {, +        return new Func0<Buffer<T>>() {, +            @Override, +            public Buffer<T> call() {, +                return new Buffer<T>();, +            }, +        };, +    }, +, +    /**, +     * This method creates a {@link Func1} object which represents the buffer operation. This operation takes, +     * values from the specified {@link Observable} source and stores them in a buffer until the, +     * {@link Observable} constructed using the {@link Func0} argument, produces a value. The buffer is then, +     * emitted, and a new buffer is created to replace it. A new {@link Observable} will be constructed using, +     * the provided {@link Func0} object, which will determine when this new buffer is emitted. When the source, +     * {@link Observable} completes or produces an error, the current buffer is emitted, and the event is]