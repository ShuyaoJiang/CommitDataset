[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.fuseable.SimplePlainQueue;, +import io.reactivex.internal.queue.SpscArrayQueue;, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.internal.util.BackpressureHelper;, +        source.subscribe(new ScanSeedSubscriber<T, R>(s, accumulator, r, bufferSize()));, +    static final class ScanSeedSubscriber<T, R>, +    extends AtomicInteger, +    implements Subscriber<T>, Subscription {, +        final Subscriber<? super R> actual;, +, +        final SimplePlainQueue<R> queue;, +        final AtomicLong requested;, +, +        final int prefetch;, +, +        final int limit;, +, +        volatile boolean cancelled;, +, +        volatile boolean done;, +        Throwable error;, +, +        Subscription s;, +, +        R value;, +, +        int consumed;, +, +        ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T, R> accumulator, R value, int prefetch) {, +            this.actual = actual;, +            this.prefetch = prefetch;, +            this.limit = prefetch - (prefetch >> 2);, +            this.queue = new SpscArrayQueue<R>(prefetch);, +            this.queue.offer(value);, +            this.requested = new AtomicLong();, +        }, +, +        @Override, +        public void onSubscribe(Subscription s) {, +            if (SubscriptionHelper.validate(this.s, s)) {, +                this.s = s;, +, +                actual.onSubscribe(this);, +, +                s.request(prefetch - 1);, +            }, +                v = ObjectHelper.requireNonNull(accumulator.apply(v, t), "The accumulator returned a null value");, +            } catch (Throwable ex) {, +                Exceptions.throwIfFatal(ex);, +                onError(ex);, +            value = v;, +            queue.offer(v);, +            drain();, +            error = t;, +            drain();, +            drain();, +        }, +, +        @Override, +        public void cancel() {, +            cancelled = true;, +            s.cancel();, +            if (getAndIncrement() == 0) {, +                queue.clear();, +            }, +        }, +, +        @Override, +        public void request(long n) {, +            if (SubscriptionHelper.validate(n)) {, +                BackpressureHelper.add(requested, n);, +                drain();, +            }, +        }, +, +        void drain() {, +            if (getAndIncrement() != 0) {, +                return;, +            }, +, +            int missed = 1;, +            Subscriber<? super R> a = actual;, +            SimplePlainQueue<R> q = queue;, +            int lim = limit;, +            int c = consumed;, +, +            for (;;) {, +, +                long r = requested.get();, +                long e = 0L;, +, +                while (e != r) {, +                    if (cancelled) {, +                        q.clear();, +                        return;, +                    }, +                    boolean d = done;, +]