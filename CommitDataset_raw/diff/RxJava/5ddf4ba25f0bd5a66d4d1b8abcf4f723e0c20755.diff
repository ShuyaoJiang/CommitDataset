[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future flatmap, +  WARNING: This operator, like clojure.core/mapcat, preserves ordering of the, +  generated Observables. In an asynchronous context, this may cause unintended, +  blocking. Try flatmap instead., +, +    flatmap, +    rx.Observable/concatMap, +    (.concatMap ^Observable (clojure.core/first xs) (iop/fn* f)))), +, +(defn ^Observable flatmap*, +  "Same as multi-arg flatmap, but input is an Observable of Observables., +, +  See:, +    flatmap, +  ", +  [f ^Observable xs], +  (->> xs, +       (map* f), +       (merge*))), +, +(defn ^Observable flatmap, +  "Like mapcat, but the Observables produced by f are merged rather than concatenated., +  This behavior is preferable in asynchronous contexts where order is not important., +, +  See:, +    mapcat, +    rx.Observable/flatMap, +  ", +  [f & xs], +  (if (clojure.core/next xs), +    (flatmap* f (seq->o xs)), +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future flatmap, +  WARNING: This operator, like clojure.core/mapcat, preserves ordering of the, +  generated Observables. In an asynchronous context, this may cause unintended, +  blocking. Try flatmap instead., +, +    flatmap, +    rx.Observable/concatMap, +    (.concatMap ^Observable (clojure.core/first xs) (iop/fn* f)))), +, +(defn ^Observable flatmap*, +  "Same as multi-arg flatmap, but input is an Observable of Observables., +, +  See:, +    flatmap, +  ", +  [f ^Observable xs], +  (->> xs, +       (map* f), +       (merge*))), +, +(defn ^Observable flatmap, +  "Like mapcat, but the Observables produced by f are merged rather than concatenated., +  This behavior is preferable in asynchronous contexts where order is not important., +, +  See:, +    mapcat, +    rx.Observable/flatMap, +  ", +  [f & xs], +  (if (clojure.core/next xs), +    (flatmap* f (seq->o xs)), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +              [:b {:k :b :v 2}], +(deftest test-flatmap, +  (let [f  (fn [v] [v (* v v)]), +        xs (range 10)], +    (is (= (mapcat f xs), +           (b/into [] (rx/flatmap (comp rx/seq->o f) (rx/seq->o xs)))))), +, +  ; group-by is a good way to test merge behavior without truly async code, +  ; here the :a and :b observables are interleaved when merged, +  (let [xs [{:k :a :v 1} {:k :b :v 2} {:k :a :v 3} {:k :c :v 4}]], +    (is (= [[:a {:k :a :v 1}], +            [:b {:k :b :v 2}], +            [:a {:k :a :v 3}], +            [:c {:k :c :v 4}]], +           (->> xs, +                (rx/seq->o), +                (rx/group-by :k), +                (rx/flatmap (fn [[k vo :as me]], +                              (is (instance? clojure.lang.MapEntry me)), +                              (rx/map #(vector k %) vo))), +                (b/into []))))), +, +  ; still looking for a simple demo of merging for the multi-arg case, +  ; Here, because ys is "inline", the interleaving is removed. sigh., +  (let [xs [{:k :a :v 1} {:k :b :v 2} {:k :a :v 3} {:k :c :v 4}], +        ys [:ay :by :cy]], +    (is (= [[:a {:k :a :v 1} :ay], +            [:a {:k :a :v 3} :ay], +            [:b {:k :b :v 2} :by], +            [:c {:k :c :v 4} :cy]], +           (->> (rx/flatmap (fn [[k vo :as me] y], +                              (is (instance? clojure.lang.MapEntry me)), +                              (rx/map #(vector k % y) vo)), +                            (->> xs, +                                 rx/seq->o]