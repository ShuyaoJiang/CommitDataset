[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +        final TakeLastQueueProducer<T> producer = new TakeLastQueueProducer<T>(notification, deque, subscriber);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +        final TakeLastQueueProducer<T> producer = new TakeLastQueueProducer<T>(notification, deque, subscriber);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java, +        final Deque<Object> buffer = new ArrayDeque<Object>();, +        final Deque<Long> timestampBuffer = new ArrayDeque<Long>();, +        final NotificationLite<T> notification = NotificationLite.instance();, +        final TakeLastQueueProducer<T> producer = new TakeLastQueueProducer<T>(notification, buffer, subscriber);, +        subscriber.setProducer(producer);, +                    timestampBuffer.pollFirst();, +                    long v = timestampBuffer.peekFirst();, +                    if (v < now - ageMillis) {, +                        timestampBuffer.pollFirst();, +                timestampBuffer.add(t);, +                buffer.add(notification.next(args));, +                timestampBuffer.clear();, +                timestampBuffer.clear();, +                buffer.offer(notification.completed());, +                producer.startEmitting();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java, +        final TakeLastQueueProducer<T> producer = new TakeLastQueueProducer<T>(notification, deque, subscriber);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java, +        final Deque<Object> buffer = new ArrayDeque<Object>();, +        final Deque<Long> timestampBuffer = new ArrayDeque<Long>();, +        final NotificationLite<T> notification = NotificationLite.instance();, +        final TakeLastQueueProducer<T> producer = new TakeLastQueueProducer<T>(notification, buffer, subscriber);, +        subscriber.setProducer(producer);, +                    timestampBuffer.pollFirst();, +                    long v = timestampBuffer.peekFirst();, +                    if (v < now - ageMillis) {, +                        timestampBuffer.pollFirst();, +                timestampBuffer.add(t);, +                buffer.add(notification.next(args));, +                timestampBuffer.clear();, +                timestampBuffer.clear();, +                buffer.offer(notification.completed());, +                producer.startEmitting();, +++ b/rxjava-core/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +package rx.internal.operators;, +, +, +import rx.Producer;, +import rx.Subscriber;, +, +import java.util.Deque;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +final class TakeLastQueueProducer<T> implements Producer {, +, +    private final NotificationLite<T> notification;, +    private final Deque<Object> deque;, +    private final Subscriber<? super T> subscriber;, +    private volatile boolean emittingStarted = false;, +, +    public TakeLastQueueProducer(NotificationLite<T> n, Deque<Object> q, Subscriber<? super T> subscriber) {, +        this.notification = n;, +        this.deque = q;, +        this.subscriber = subscriber;, +    }, +, +    private volatile long requested = 0;, +    @SuppressWarnings("rawtypes"), +    private static final AtomicLongFieldUpdater<TakeLastQueueProducer> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(TakeLastQueueProducer.class, "requested");, +, +    void startEmitting() {, +        if (!emittingStarted) {, +            emittingStarted = true;, +            emit(0); // start emitting, +        }, +    }, +, +    @Override, +    public void request(long n) {, +        if (requested == Long.MAX_VALUE) {, +            return;, +        }, +        long _c;, +        if (n == Long.MAX_VALUE) {, +            _c = REQUESTED_UPDATER.getAndSet(this, Long.MAX_VALUE);, +        } else {, +            _c = REQUESTED_UPDATER.getAndAdd(this, n);, +        }, +        if (!emittingStarted) {, +            // we haven't started yet, so record what was requested and return, +            return;, +        }, +        emit(_c);, +    }, +, +    void emit(long previousRequested) {, +        if (requested == Long.MAX_VALUE) {, +            // fast-path without backpressure, +            if (previousRequested == 0) {, +                try {, +                    for (Object value : deque) {, +                        notification.accept(subscriber, value);, +                    }, +                } catch (Throwable e) {, +                    subscriber.onError(e);]