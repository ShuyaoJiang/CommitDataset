[+++ b/src/main/java/io/reactivex/Flowable.java, +        return cacheWithInitialCapacity(16);, +        return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));, +        return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));, +     * @return the source {@code Flowable} modified to buffer items up to the given capacity, +    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {, +++ b/src/main/java/io/reactivex/Flowable.java, +        return cacheWithInitialCapacity(16);, +        return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));, +        return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));, +     * @return the source {@code Flowable} modified to buffer items up to the given capacity, +    public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +     * @param capacityHint the capacity hint, +    public FlowableCache(Flowable<T> source, int capacityHint) {, +        this.state = new CacheState<T>(source, capacityHint);, +        return state.subscribers.get().length != 0;, +        final AtomicReference<ReplaySubscription<T>[]> subscribers;, +        @SuppressWarnings("rawtypes"), +        static final ReplaySubscription[] EMPTY = new ReplaySubscription[0];, +        /** The default empty array of subscribers. */, +        @SuppressWarnings("rawtypes"), +        static final ReplaySubscription[] TERMINATED = new ReplaySubscription[0];, +        @SuppressWarnings("unchecked"), +            this.subscribers = new AtomicReference<ReplaySubscription<T>[]>(EMPTY);, +            for (;;) {, +                ReplaySubscription<T>[] a = subscribers.get();, +                if (a == TERMINATED) {, +                    return;, +                }, +                @SuppressWarnings("unchecked"), +                ReplaySubscription<T>[] b = new ReplaySubscription[n + 1];, +                if (subscribers.compareAndSet(a, b)) {, +                    return;, +                }, +        @SuppressWarnings("unchecked"), +            for (;;) {, +                ReplaySubscription<T>[] a = subscribers.get();, +                if (n == 0) {, +                    return;, +                }, +, +                ReplaySubscription<T>[] b;, +                    b = EMPTY;, +                } else {, +                    b = new ReplaySubscription[n - 1];, +                }, +                if (subscribers.compareAndSet(a, b)) {, +                    return;, +                }, +                for (ReplaySubscription<?> rp : subscribers.get()) {, +                    rp.replay();, +        }, +        @SuppressWarnings("unchecked"), +                for (ReplaySubscription<?> rp : subscribers.getAndSet(TERMINATED)) {, +                    rp.replay();, +                }, +            } else {, +                RxJavaPlugins.onError(e);, +        @SuppressWarnings("unchecked"), +                for (ReplaySubscription<?> rp : subscribers.getAndSet(TERMINATED)) {, +    }, +    static final class ReplaySubscription<T>, +    extends AtomicInteger implements Subscription {, +        final AtomicLong requested;, +, +            this.requested = new AtomicLong();, +            if (SubscriptionHelper.validate(n)) {, +                    long r = requested.get();, +                    if (requested.compareAndSet(r, u)) {, +            if (requested.getAndSet(CANCELLED) != CANCELLED) {, +                state.removeChild(this);, +            }, +            if (getAndIncrement() != 0) {, +, +            int missed = 1;, +            AtomicLong rq = requested;, +                long r = rq.get();, +                        if (rq.get() == CANCELLED) {, +                    if (rq.get() == CANCELLED) {, +                    if (r == 0) {, +                        Object o = b[k];, +                        if (NotificationLite.isComplete(o)) {, +                            child.onComplete();, +                            return;, +                        } else, +                        if (NotificationLite.isError(o)) {, +                            child.onError(NotificationLite.getError(o));, +                            return;, +                        }, +                    }, +, +                    if (valuesProduced != 0) {, +                        BackpressureHelper.producedCancel(rq, valuesProduced);, +                    }, +, +                missed = addAndGet(-missed);, +                if (missed == 0) {, +                    break;, +++ b/src/main/java/io/reactivex/Flowable.java]