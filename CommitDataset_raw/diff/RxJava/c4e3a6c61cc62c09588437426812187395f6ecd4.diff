[+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import rx.concurrency.Schedulers;, +        private T next;, +        private boolean hasNext = true;, +            // Since an iterator should not be used in different thread,, +            // so we do not need any synchronization., +            if(hasNext == false) {, +                return false;, +                Notification<? extends T> nextNotification = observer.takeNext();, +                if(nextNotification.isOnNext()) {, +                    next = nextNotification.getValue();, +                    return true;, +                }, +                // If an observable is completed or fails,, +                // next always return null and hasNext always return false., +                next = null;, +                hasNext = false;, +                if(nextNotification.isOnCompleted()) {, +                    return false;, +                }, +                // onError, +                throw Exceptions.propagate(nextNotification.getThrowable());, +        }, +        @Override, +        public T next() {, +            return next;, +                    if (concurrentItem != null && !concurrentItem.isOnNext()) {, +        public Notification<? extends T> takeNext() throws InterruptedException {, +            return buf.take();, +, +        private void fireOnNextInNewThread(final Subject<String, String> o, final String value) {, +            new Thread() {, +                @Override, +                public void run() {, +                    try {, +                        Thread.sleep(500);, +                    } catch (InterruptedException e) {, +                        // ignore, +                    }, +                    o.onNext(value);, +                }, +            }.start();, +        }, +, +        private void fireOnErrorInNewThread(final Subject<String, String> o) {, +            new Thread() {, +                @Override, +                public void run() {, +                    try {, +                        Thread.sleep(500);, +                    } catch (InterruptedException e) {, +                        // ignore, +                    }, +                    o.onError(new TestException());, +                }, +            }.start();, +        }, +, +        public void testNext() {, +            fireOnNextInNewThread(obs, "one");, +            assertEquals("one", it.next());, +            fireOnNextInNewThread(obs, "two");, +            assertEquals("two", it.next());, +            assertNull(it.next());, +            // If the observable is completed, hasNext always returns false and next always returns null., +            assertFalse(it.hasNext());, +            assertNull(it.next());, +        public void testNextWithError() {, +            Iterator<String> it = next(obs).iterator();, +            fireOnNextInNewThread(obs, "one");, +            assertTrue(it.hasNext());, +            assertEquals("one", it.next());, +            fireOnErrorInNewThread(obs);, +            try {, +                it.hasNext();, +                fail("Expected an TestException");, +            }, +            catch(TestException e) {, +                // successful, +            }, +, +            // After the observable fails, hasNext always returns false and next always returns null., +            assertFalse(it.hasNext());, +            assertNull(it.next());, +        }, +, +        @Test, +        public void testNextWithEmpty() {, +           Observable<String> obs = Observable.<String>empty().observeOn(Schedulers.newThread());, +           assertNull(it.next());, +, +           // If the observable is completed, hasNext always returns false and next always returns null., +           assertFalse(it.hasNext());, +           assertNull(it.next());, +        @Test]