[+++ b/src/main/java/io/reactivex/Flowable.java, +     * Note that the {@code seed} is shared among all subscribers to the resulting Publisher, +     * Single.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     *     Flowable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)).toFlowable()), +     * ).firstOrError();, +     *, +     * // or, by using reduceWith instead of reduce, +     *, +     * source.reduceWith(() -> new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     * @see #reduceWith(Callable, BiFunction), +     * Publisher and a seed value derived from calling a specified seedSupplier, then feeds the result, +     * of that function along with the second item emitted by a Publisher into the same function, and so on until, +     * all items have been emitted by the source Publisher, emitting the final result from the final call to your, +     * function as its sole item., +++ b/src/main/java/io/reactivex/Flowable.java, +     * Note that the {@code seed} is shared among all subscribers to the resulting Publisher, +     * Single.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     *     Flowable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)).toFlowable()), +     * ).firstOrError();, +     *, +     * // or, by using reduceWith instead of reduce, +     *, +     * source.reduceWith(() -> new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     * @see #reduceWith(Callable, BiFunction), +     * Publisher and a seed value derived from calling a specified seedSupplier, then feeds the result, +     * of that function along with the second item emitted by a Publisher into the same function, and so on until, +     * all items have been emitted by the source Publisher, emitting the final result from the final call to your, +     * function as its sole item., +++ b/src/main/java/io/reactivex/Observable.java, +     * Note that the {@code seed} is shared among all subscribers to the resulting ObservableSource, +     * Single.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     *     Observable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)).toObservable()), +     * ).firstOrError();, +     *, +     * // or, by using reduceWith instead of reduce, +     *, +     * source.reduceWith(() -> new ArrayList&lt;>(), (list, item) -> list.add(item)));, +     * @see #reduceWith(Callable, BiFunction), +     * ObservableSource and a seed value derived from calling a specified seedSupplier, then feeds the result, +     * of that function along with the second item emitted by an ObservableSource into the same function,, +     * and so on until all items have been emitted by the source ObservableSource, emitting the final result, +     * from the final call to your function as its sole item.]