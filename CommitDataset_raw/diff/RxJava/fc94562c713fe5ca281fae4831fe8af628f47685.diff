[+++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        public void onNext(int index, T t) {, +                    return;, +                }, +            producer.onNext(index, t);, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        public void onNext(int index, T t) {, +                    return;, +                }, +            producer.onNext(index, t);, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // only execute this from schedule(), +            do {, +                /*, +                 * Set to 1 otherwise it could have grown very large while in the last poll loop, +                 * and then we can end up looping all those times again here before exiting even once we've drained, +                 */, +                COUNTER_UPDATER.set(this, 1);, +, +                                    // TODO this could hit the requested limit again ... and is skipping values, +                                    // so the request count is broken ... it needs to purge the queue, +                                    // or modify the requested amount so it will loop through everything, +, +            } while (COUNTER_UPDATER.decrementAndGet(this) > 0);, +, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        public void onNext(int index, T t) {, +                    return;, +                }, +            producer.onNext(index, t);, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // only execute this from schedule(), +            do {, +                /*, +                 * Set to 1 otherwise it could have grown very large while in the last poll loop, +                 * and then we can end up looping all those times again here before exiting even once we've drained, +                 */, +                COUNTER_UPDATER.set(this, 1);, +, +                                    // TODO this could hit the requested limit again ... and is skipping values, +                                    // so the request count is broken ... it needs to purge the queue, +                                    // or modify the requested amount so it will loop through everything, +, +            } while (COUNTER_UPDATER.decrementAndGet(this) > 0);, +, +++ b/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java, +++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +        public void onNext(int index, T t) {, +                    return;, +                }, +            producer.onNext(index, t);, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // only execute this from schedule(), +            do {, +                /*, +                 * Set to 1 otherwise it could have grown very large while in the last poll loop, +                 * and then we can end up looping all those times again here before exiting even once we've drained, +                 */, +                COUNTER_UPDATER.set(this, 1);, +, +                                    // TODO this could hit the requested limit again ... and is skipping values, +                                    // so the request count is broken ... it needs to purge the queue, +                                    // or modify the requested amount so it will loop through everything, +, +            } while (COUNTER_UPDATER.decrementAndGet(this) > 0);, +, +++ b/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java, +++ b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java, +, +    /**, +     * Make sure we get a MissingBackpressureException propagated through when we have a fast temporal (hot) producer., +     */, +    @Test, +    public void testHotOperatorBackpressure() {, +        TestSubscriber<String> ts = new TestSubscriber<String>();, +        Observable.timer(0, 1, TimeUnit.MILLISECONDS), +                .observeOn(Schedulers.computation()), +                .map(new Func1<Long, String>() {, +, +                    @Override, +                    public String call(Long t1) {, +                        System.out.println(t1);, +                        try {, +                            Thread.sleep(100);, +                        } catch (InterruptedException e) {, +                        }, +                        return t1 + " slow value";, +                    }, +, +                }).subscribe(ts);, +, +        ts.awaitTerminalEvent();, +        System.out.println("Errors: " + ts.getOnErrorEvents());, +        assertEquals(MissingBackpressureException.class, ts.getOnErrorEvents().get(0).getClass());, +    }, +]