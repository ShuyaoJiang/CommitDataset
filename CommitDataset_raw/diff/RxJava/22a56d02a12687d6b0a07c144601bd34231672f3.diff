[+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +import rx.Producer;, +        public void requestMore(long n) {, +            request(n);, +        }, +, +        final AtomicInteger choice = new AtomicInteger(AmbSubscriber.NONE);, +        final List<AmbSubscriber<T>> ambSubscribers = new ArrayList<AmbSubscriber<T>>();, +            ambSubscribers.add(ambSubscriber);, +        // setProducer at the end so that `ambSubscribers` can be finalized before `subscriber` calls `request`, +        subscriber.setProducer(new Producer() {, +, +            private volatile AmbSubscriber<T> selectedAmbSubscriber;, +, +            @Override, +            public void request(long n) {, +                if (choice.get() == AmbSubscriber.NONE) {, +                    for (AmbSubscriber<T> ambSubscriber : ambSubscribers) {, +                        // Once one Observable emits a message, `unsubscribe` of other Observables will be called, +                        // and further messages will be dropped. Therefore, requesting all sources won't cause, +                        // the backpressure issue., +                        ambSubscriber.requestMore(n);, +                    }, +                }, +                else {, +                    if (selectedAmbSubscriber == null) {, +                        selectedAmbSubscriber = ambSubscribers.get(choice.get());, +                    }, +                    selectedAmbSubscriber.requestMore(n);, +                }, +            }, +        });, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +import rx.Producer;, +        public void requestMore(long n) {, +            request(n);, +        }, +, +        final AtomicInteger choice = new AtomicInteger(AmbSubscriber.NONE);, +        final List<AmbSubscriber<T>> ambSubscribers = new ArrayList<AmbSubscriber<T>>();, +            ambSubscribers.add(ambSubscriber);, +        // setProducer at the end so that `ambSubscribers` can be finalized before `subscriber` calls `request`, +        subscriber.setProducer(new Producer() {, +, +            private volatile AmbSubscriber<T> selectedAmbSubscriber;, +, +            @Override, +            public void request(long n) {, +                if (choice.get() == AmbSubscriber.NONE) {, +                    for (AmbSubscriber<T> ambSubscriber : ambSubscribers) {, +                        // Once one Observable emits a message, `unsubscribe` of other Observables will be called, +                        // and further messages will be dropped. Therefore, requesting all sources won't cause, +                        // the backpressure issue., +                        ambSubscriber.requestMore(n);, +                    }, +                }, +                else {, +                    if (selectedAmbSubscriber == null) {, +                        selectedAmbSubscriber = ambSubscribers.get(choice.get());, +                    }, +                    selectedAmbSubscriber.requestMore(n);, +                }, +            }, +        });, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorConcat.java, + * @param <T> the source and result value type, +        return new ConcatSubscriber<T>(s, current);, +        private final Subscriber<T> s;, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER, +                = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +            this.s = s;, +            s.onError(e);, +                s.onCompleted();, +                Subscriber<T> sourceSub = new Subscriber<T>() {, +                        // TODO need to support backpressure here https://github.com/Netflix/RxJava/issues/1480, +                        s.onNext(t);, +                        ConcatSubscriber.this.onError(e);, +                        completeInner();, +                current.set(sourceSub);, +                obs.unsafeSubscribe(sourceSub);, +            }, +        }, +    }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeAmb.java, +import rx.Producer;, +        public void requestMore(long n) {, +            request(n);, +        }, +, +        final AtomicInteger choice = new AtomicInteger(AmbSubscriber.NONE);, +        final List<AmbSubscriber<T>> ambSubscribers = new ArrayList<AmbSubscriber<T>>();, +            ambSubscribers.add(ambSubscriber);, +        // setProducer at the end so that `ambSubscribers` can be finalized before `subscriber` calls `request`, +        subscriber.setProducer(new Producer() {, +, +            private volatile AmbSubscriber<T> selectedAmbSubscriber;, +, +            @Override, +            public void request(long n) {, +                if (choice.get() == AmbSubscriber.NONE) {]