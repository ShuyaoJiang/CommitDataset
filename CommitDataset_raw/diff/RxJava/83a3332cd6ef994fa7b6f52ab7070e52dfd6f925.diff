[+++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, +                    if (!cancelled) {, +                    } else {, +                        next.dispose();, +                    }, +++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, +                    if (!cancelled) {, +                    } else {, +                        next.dispose();, +                    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscribers.observable.BasicFuseableObserver;, +        source.subscribe(new MapObserver<T, U>(t, function));, +    static final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {, +        final Function<? super T, ? extends U> mapper;, +        public MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {, +            super(actual);, +            this.mapper = mapper;, +        }, +            , +            if (sourceMode != NONE) {, +                actual.onNext(null);, +                return;, +            }, +            , +            U v;, +            , +                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");, +            } catch (Throwable ex) {, +                fail(ex);, +            actual.onNext(v);, +        public int requestFusion(int mode) {, +            return transitiveBoundaryFusion(mode);, +        public U poll() throws Exception {, +            T t = qs.poll();, +            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;, +++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, +                    if (!cancelled) {, +                    } else {, +                        next.dispose();, +                    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscribers.observable.BasicFuseableObserver;, +        source.subscribe(new MapObserver<T, U>(t, function));, +    static final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {, +        final Function<? super T, ? extends U> mapper;, +        public MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {, +            super(actual);, +            this.mapper = mapper;, +        }, +            , +            if (sourceMode != NONE) {, +                actual.onNext(null);, +                return;, +            }, +            , +            U v;, +            , +                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");, +            } catch (Throwable ex) {, +                fail(ex);, +            actual.onNext(v);, +        public int requestFusion(int mode) {, +            return transitiveBoundaryFusion(mode);, +        public U poll() throws Exception {, +            T t = qs.poll();, +            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java, +        boolean fused;, +        , +            if (fused) {, +                return;, +            }, +            if ((mode & SYNC) != 0) {, +                fused = true;, +                return SYNC;, +            }, +            return NONE;, +++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, +                    if (!cancelled) {, +                    } else {, +                        next.dispose();, +                    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscribers.observable.BasicFuseableObserver;, +        source.subscribe(new MapObserver<T, U>(t, function));, +    static final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {, +        final Function<? super T, ? extends U> mapper;, +        public MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {, +            super(actual);, +            this.mapper = mapper;, +        }, +            , +            if (sourceMode != NONE) {, +                actual.onNext(null);, +                return;, +            }]