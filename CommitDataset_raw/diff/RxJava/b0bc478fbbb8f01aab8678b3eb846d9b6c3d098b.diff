[+++ b/src/test/java/io/reactivex/TestHelper.java, +     * @param <R> the output value type, +     * @param transform the transform to drive an operator, +     */, +    public static <T, R> void checkDoubleOnSubscribeSingleToFlowable(Function<Single<T>, ? extends Publisher<R>> transform) {, +        List<Throwable> errors = trackPluginErrors();, +        try {, +            final Boolean[] b = { null, null };, +            final CountDownLatch cdl = new CountDownLatch(1);, +, +            Single<T> source = new Single<T>() {, +                @Override, +                protected void subscribeActual(SingleObserver<? super T> observer) {, +                    try {, +                        Disposable d1 = Disposables.empty();, +, +                        observer.onSubscribe(d1);, +, +                        Disposable d2 = Disposables.empty();, +, +                        observer.onSubscribe(d2);, +, +                        b[0] = d1.isDisposed();, +                        b[1] = d2.isDisposed();, +                    } finally {, +                        cdl.countDown();, +                    }, +                }, +            };, +, +            Publisher<R> out = transform.apply(source);, +, +            out.subscribe(NoOpConsumer.INSTANCE);, +, +            try {, +                assertTrue("Timed out", cdl.await(5, TimeUnit.SECONDS));, +            } catch (InterruptedException ex) {, +                throw ExceptionHelper.wrapOrThrow(ex);, +            }, +, +            assertEquals("First disposed?", false, b[0]);, +            assertEquals("Second not disposed?", true, b[1]);, +, +            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");, +        } catch (Throwable ex) {, +            throw ExceptionHelper.wrapOrThrow(ex);, +        } finally {, +            RxJavaPlugins.reset();, +        }, +    }, +, +    /**, +     * Check if the given transformed reactive type reports multiple onSubscribe calls to, +     * RxJavaPlugins., +     * @param <T> the input value type, +++ b/src/test/java/io/reactivex/TestHelper.java, +     * @param <R> the output value type, +     * @param transform the transform to drive an operator, +     */, +    public static <T, R> void checkDoubleOnSubscribeSingleToFlowable(Function<Single<T>, ? extends Publisher<R>> transform) {, +        List<Throwable> errors = trackPluginErrors();, +        try {, +            final Boolean[] b = { null, null };, +            final CountDownLatch cdl = new CountDownLatch(1);, +, +            Single<T> source = new Single<T>() {, +                @Override, +                protected void subscribeActual(SingleObserver<? super T> observer) {, +                    try {, +                        Disposable d1 = Disposables.empty();, +, +                        observer.onSubscribe(d1);, +, +                        Disposable d2 = Disposables.empty();, +, +                        observer.onSubscribe(d2);, +, +                        b[0] = d1.isDisposed();, +                        b[1] = d2.isDisposed();, +                    } finally {, +                        cdl.countDown();, +                    }, +                }, +            };, +, +            Publisher<R> out = transform.apply(source);, +, +            out.subscribe(NoOpConsumer.INSTANCE);, +, +            try {, +                assertTrue("Timed out", cdl.await(5, TimeUnit.SECONDS));, +            } catch (InterruptedException ex) {, +                throw ExceptionHelper.wrapOrThrow(ex);, +            }, +, +            assertEquals("First disposed?", false, b[0]);, +            assertEquals("Second not disposed?", true, b[1]);, +, +            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");, +        } catch (Throwable ex) {]