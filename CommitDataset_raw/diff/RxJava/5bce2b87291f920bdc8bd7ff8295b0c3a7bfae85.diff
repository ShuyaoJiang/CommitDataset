[+++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +            // safeguard against misbehaving sources, +            if (done) {, +                return;, +            }, +++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, +     * @see #awaitTerminalEvent(), +     * @return true if the TestSubscriber terminated, false if timeout happened, +     * @see #awaitTerminalEvent(long, TimeUnit), +        errors.forEach(e -> {, +            if (e == null) {, +                ae.addSuppressed(new NullPointerException("Throwable was null!"));, +            } else {, +                ae.addSuppressed(e);, +            }, +        });, +    , +    /**, +     * Waits until the any terminal event has been received by this TestSubscriber, +     * or returns false if the wait has been interrupted., +     * @return true if the TestSubscriber terminated, false if the wait has been interrupted, +     */, +    public boolean awaitTerminalEvent() {, +        try {, +            await();, +            return true;, +        } catch (InterruptedException ex) {, +            Thread.currentThread().interrupt();, +            return false;, +        }, +    }, +    , +    /**, +     * Awaits the specified amount of time or until this TestSubscriber , +     * receives an onError or onComplete events, whichever happens first., +     * @param time the waiting time, +     * @param unit the time unit of the waiting time, +     * @return true if the TestSubscriber terminated, false if timeout or interrupt happened, +     */, +    public boolean awaitTerminalEvent(long duration, TimeUnit unit) {, +        try {, +            return await(duration, unit);, +        } catch (InterruptedException ex) {, +            Thread.currentThread().interrupt();, +            return false;, +        }, +    }, +    , +    public void assertErrorMessage(String message) {, +        String prefix = "";, +        if (done.getCount() != 0) {, +            prefix = "Subscriber still running! ";, +        }, +        int s = errors.size();, +        if (s == 0) {, +            fail(prefix, "No errors", Collections.emptyList());, +        } else, +        if (s == 1) {, +            Throwable e = errors.get(0);, +            if (e == null) {, +                fail(prefix, "Error is null", Collections.emptyList());, +            }, +            String errorMessage = e.getMessage();, +            if (!Objects.equals(message, errorMessage)) {, +                fail(prefix, "Error message differs; Expected: " + message + ", Actual: " + errorMessage, Collections.singletonList(e));, +            }, +        } else {, +            fail(prefix, "Multiple errors", errors);, +        }, +    }]