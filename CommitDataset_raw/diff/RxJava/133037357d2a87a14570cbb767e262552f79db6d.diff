[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java, +            public void onError(final Throwable e) {, +                sd.replace(scheduler.scheduleDirect(new Runnable() {, +                    @Override, +                    public void run() {, +                }, 0, unit));, +            }, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java, +            public void onError(final Throwable e) {, +                sd.replace(scheduler.scheduleDirect(new Runnable() {, +                    @Override, +                    public void run() {, +                }, 0, unit));, +            }, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, +        final TestScheduler scheduler = new TestScheduler();, +        final Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS, scheduler);, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java, +            public void onError(final Throwable e) {, +                sd.replace(scheduler.scheduleDirect(new Runnable() {, +                    @Override, +                    public void run() {, +                }, 0, unit));, +            }, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, +        final TestScheduler scheduler = new TestScheduler();, +        final Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS, scheduler);, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +, +        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.functions.Consumer;, +import static org.junit.Assert.assertNotEquals;, +, +, +    @Test, +    public void testOnErrorCalledOnScheduler() throws Exception {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Thread> thread = new AtomicReference<Thread>();, +, +        Completable.<String>error(new Exception()), +                .delay(0, TimeUnit.MILLISECONDS, Schedulers.newThread()), +                .doOnError(new Consumer<Throwable>() {, +                    @Override, +                    public void accept(Throwable throwable) throws Exception {, +                        thread.set(Thread.currentThread());, +                        latch.countDown();, +                    }, +                }), +                .onErrorComplete(), +                .subscribe();, +, +        latch.await();, +, +        assertNotEquals(Thread.currentThread(), thread.get());, +    }, +, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +                }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, +            }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java, +            public void onError(final Throwable e) {]