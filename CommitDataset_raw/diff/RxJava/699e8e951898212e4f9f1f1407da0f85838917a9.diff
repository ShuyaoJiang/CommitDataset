[+++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.observable.*;, +     * Wraps a specific ObservableSource into a Single and signals its single element or error., +     * <p>If the ObservableSource is empty, a NoSuchElementException is signalled., +     * If the source has more than one element, an IndexOutOfBoundsException is signalled., +     * <p>, +     * <dl>, +     *   <dt><b>Scheduler:</b></dt>, +     *   <dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @param observableSource the source Observable, not null, +     * @param <T>, +     *         the type of the item emitted by the {@link Single}., +     * @return the new Single instance, +     */, +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Single<T> fromObservable(ObservableSource<? extends T> observableSource) {, +        ObjectHelper.requireNonNull(observableSource, "observableSource is null");, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(observableSource, null));, +    }, +, +    /**, +++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.observable.*;, +     * Wraps a specific ObservableSource into a Single and signals its single element or error., +     * <p>If the ObservableSource is empty, a NoSuchElementException is signalled., +     * If the source has more than one element, an IndexOutOfBoundsException is signalled., +     * <p>, +     * <dl>, +     *   <dt><b>Scheduler:</b></dt>, +     *   <dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @param observableSource the source Observable, not null, +     * @param <T>, +     *         the type of the item emitted by the {@link Single}., +     * @return the new Single instance, +     */, +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Single<T> fromObservable(ObservableSource<? extends T> observableSource) {, +        ObjectHelper.requireNonNull(observableSource, "observableSource is null");, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(observableSource, null));, +    }, +, +    /**, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java, +    final ObservableSource<? extends T> source;, +    public ObservableSingleSingle(ObservableSource<? extends T> source, T defaultValue) {, +++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.observable.*;, +     * Wraps a specific ObservableSource into a Single and signals its single element or error., +     * <p>If the ObservableSource is empty, a NoSuchElementException is signalled., +     * If the source has more than one element, an IndexOutOfBoundsException is signalled., +     * <p>, +     * <dl>, +     *   <dt><b>Scheduler:</b></dt>, +     *   <dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>, +     * </dl>, +     *, +     * @param observableSource the source Observable, not null, +     * @param <T>, +     *         the type of the item emitted by the {@link Single}., +     * @return the new Single instance, +     */, +    @SchedulerSupport(SchedulerSupport.NONE), +    public static <T> Single<T> fromObservable(ObservableSource<? extends T> observableSource) {, +        ObjectHelper.requireNonNull(observableSource, "observableSource is null");, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(observableSource, null));, +    }, +, +    /**, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java, +    final ObservableSource<? extends T> source;, +    public ObservableSingleSingle(ObservableSource<? extends T> source, T defaultValue) {, +++ b/src/test/java/io/reactivex/single/SingleTest.java, +import io.reactivex.Observable;, +, +    @Test(expected = NullPointerException.class), +    public void fromObservableNull() {, +        Single.fromObservable(null);, +    }, +, +    @Test, +    public void fromObservableEmpty() {, +        Single.fromObservable(Observable.empty()), +            .test(), +            .assertFailure(NoSuchElementException.class);, +    }, +, +    @Test, +    public void fromObservableMoreThan1Elements() {, +        Single.fromObservable(Observable.just(1, 2)), +            .test(), +            .assertFailure(IllegalArgumentException.class), +            .assertErrorMessage("Sequence contains more than one element!");, +    }, +, +    @Test, +    public void fromObservableOneElement() {]