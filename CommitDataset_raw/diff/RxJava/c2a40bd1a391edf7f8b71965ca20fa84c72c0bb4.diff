[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.plugins.RxJavaObservableExecutionHook;, +    private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, +, +        // allow the hook to intercept and/or decorate, +        Func1<Observer<T>, Subscription> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);, +        // validate and proceed, +        if (onSubscribeFunction == null) {, +                Subscription s = onSubscribeFunction.call(observer);, +                    return hook.onSubscribeReturn(this, Subscriptions.empty());, +                    return hook.onSubscribeReturn(this, s);, +                subscription.wrap(onSubscribeFunction.call(new AtomicObserver<T>(subscription, observer)));, +                return hook.onSubscribeReturn(this, subscription);, +                observer.onError(hook.onSubscribeError(this, e));, +                RuntimeException r = new RuntimeException("Error occurred attempting to subscribe [" + e.getMessage() + "] and then again while trying to pass to onError.", e2);, +                hook.onSubscribeError(this, r);, +                throw r;, +     * , +     * @param source, +     *            an observable, +     * @param action, +     *            an action to be called when the source completes or errors., +     * , +     * @param action, +     *            an action to be called when this observable completes or errors., +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.plugins.RxJavaObservableExecutionHook;, +    private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, +, +        // allow the hook to intercept and/or decorate, +        Func1<Observer<T>, Subscription> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);, +        // validate and proceed, +        if (onSubscribeFunction == null) {, +                Subscription s = onSubscribeFunction.call(observer);, +                    return hook.onSubscribeReturn(this, Subscriptions.empty());, +                    return hook.onSubscribeReturn(this, s);, +                subscription.wrap(onSubscribeFunction.call(new AtomicObserver<T>(subscription, observer)));, +                return hook.onSubscribeReturn(this, subscription);, +                observer.onError(hook.onSubscribeError(this, e));, +                RuntimeException r = new RuntimeException("Error occurred attempting to subscribe [" + e.getMessage() + "] and then again while trying to pass to onError.", e2);, +                hook.onSubscribeError(this, r);, +                throw r;, +     * , +     * @param source, +     *            an observable, +     * @param action, +     *            an action to be called when the source completes or errors., +     * , +     * @param action, +     *            an action to be called when this observable completes or errors., +++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java, +import java.lang.reflect.Array;, +import org.junit.Assert;, +import org.junit.Before;, +import rx.util.functions.Action1;, +     * Combine the observable sequences from the list of Observables into one observable sequence without any transformation., +     * @param sequences, +     *            An observable sequence of elements to project., +                return new Concat<T>(sequences).call(observer);, +    public static <T> Func1<Observer<T>, Subscription> concat(final List<Observable<T>> sequences) {, +        @SuppressWarnings("unchecked"), +        Observable<T>[] o = sequences.toArray((Observable<T>[]) Array.newInstance(Observable.class, sequences.size()));, +        return concat(o);, +    }, +    public static <T> Func1<Observer<T>, Subscription> concat(final Observable<Observable<T>> sequences) {, +        final List<Observable<T>> list = new ArrayList<Observable<T>>();, +        sequences.toList().subscribe(new Action1<List<Observable<T>>>() {, +            public void call(List<Observable<T>> t1) {, +                list.addAll(t1);, +            }, +, +        });, +, +        return concat(list);, +    }, +, +    private static class Concat<T> implements Func1<Observer<T>, Subscription> {, +        private final Observable<T>[] sequences;, +        private int num = 0;, +        private int count = 0;, +        private Subscription s;, +, +        Concat(final Observable<T>... sequences) {, +            this.sequences = sequences;, +            this.num = sequences.length - 1;, +        }, +, +        private final AtomicObservableSubscription Subscription = new AtomicObservableSubscription();, +, +        private final Subscription actualSubscription = new Subscription() {, +, +            public void unsubscribe() {, +                if (null != s), +                    s.unsubscribe();, +        };, +, +        public Subscription call(Observer<T> observer) {, +            s = sequences[count].subscribe(new ConcatObserver(observer));, +, +            return Subscription.wrap(actualSubscription);]