[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.internal.disposables.DisposableHelper;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.internal.disposables.DisposableHelper;, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.CheckReturnValue;, +        b.add(t);, +        Object o = NotificationLite.error(t);, +        ReplayBuffer<T> b = buffer;, +, +        b.addFinal(o);, +        Object o = NotificationLite.complete();, +, +        b.addFinal(o);, +        Object o = buffer.get();, +        if (NotificationLite.isError(o)) {, +            return NotificationLite.getError(o);, +        Object o = buffer.get();, +        return NotificationLite.isComplete(o);, +        Object o = buffer.get();, +        return NotificationLite.isError(o);, +        void add(T value);, +        void addFinal(Object notificationLite);, +        /**, +         * Returns the terminal NotificationLite object or null if not yet terminated., +         * @return the terminal NotificationLite object or null if not yet terminated, +         */, +        Object get();, +    extends AtomicReference<Object>, +        private static final long serialVersionUID = -4457200895834877300L;, +        final List<Object> buffer;, +, +            this.buffer = new ArrayList<Object>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));, +        public void add(T value) {, +        public void addFinal(Object notificationLite) {, +            lazySet(notificationLite);, +            buffer.add(notificationLite);, +            size++;, +        @SuppressWarnings("unchecked"), +            if (s != 0) {, +                List<Object> b = buffer;, +                Object o = b.get(s - 1);, +                if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {, +                    if (s == 1) {, +                    return (T)b.get(s - 2);, +                }, +                return (T)o;, +            }, +            return null;, +            List<Object> b = buffer;, +            Object o = b.get(s - 1);, +, +            if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {, +                s--;, +                if (s == 0) {, +                    if (array.length != 0) {, +                        array[0] = null;, +                    }, +                    return array;, +                }, +            }, +, +                array[i] = (T)b.get(i);, +        @SuppressWarnings("unchecked"), +            final List<Object> b = buffer;, +                long r = rs.requested.get();, +                long e = 0L;, +                while (s != index) {, +, +                    if (rs.cancelled) {, +                    Object o = b.get(index);, +, +                    if (done) {, +                        if (index + 1 == s) {, +                            s = size;, +                            if (index + 1 == s) {, +                                if (NotificationLite.isComplete(o)) {, +                                    a.onComplete();, +                                } else {, +                                    a.onError(NotificationLite.getError(o));, +                                }, +                                rs.index = null;, +                                rs.cancelled = true;, +                                return;, +                            }, +                        }, +                    }, +, +                    if (r == 0) {, +                        r = rs.requested.get() + e;, +                        if (r == 0) {, +                    }, +                    a.onNext((T)o);, +                    r--;, +                    e--;, +                if (e != 0L) {, +                    if (rs.requested.get() != Long.MAX_VALUE) {, +                        r = rs.requested.addAndGet(e);]