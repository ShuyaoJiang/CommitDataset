[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Ignores all values in an observable sequence and only calls onCompleted or onError method., +     *, +     * @return An empty observable sequence that only call onCompleted, or onError method., +     *, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229242(v=vs.103).aspx">MSDN: Observable.IgnoreElements</a>, +     */, +    public Observable<T> ignoreElements() {, +        return filter(alwaysFalse());, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Ignores all values in an observable sequence and only calls onCompleted or onError method., +     *, +     * @return An empty observable sequence that only call onCompleted, or onError method., +     *, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229242(v=vs.103).aspx">MSDN: Observable.IgnoreElements</a>, +     */, +    public Observable<T> ignoreElements() {, +        return filter(alwaysFalse());, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java, +  PublishSubject<Object> subject = PublishSubject.create();, +        final AtomicReference<Notification<? extends T>> terminalState = new AtomicReference<Notification<? extends T>>();, +                // shortcut check if terminal state exists already, +                Subscription s = checkTerminalState(observer);, +                if(s != null) return s;, +, +                /**, +                 * NOTE: We are synchronizing to avoid a race condition between terminalState being set and, +                 * a new observer being added to observers., +                 *, +                 * The synchronization only occurs on subscription and terminal states, it does not affect onNext calls, +                 * so a high-volume hot-observable will not pay this cost for emitting data., +                 *, +                 * Due to the restricted impact of blocking synchronization here I have not pursued more complicated, +                 * approaches to try and stay completely non-blocking., +                 */, +                synchronized (terminalState) {, +                    // check terminal state again, +                    s = checkTerminalState(observer);, +                    if (s != null), +                        return s;, +, +            }, +            private Subscription checkTerminalState(Observer<? super T> observer) {, +                Notification<? extends T> n = terminalState.get();, +                if (n != null) {, +                    // we are terminated to immediately emit and don't continue with subscription, +                    if (n.isOnCompleted()) {, +                        observer.onCompleted();, +                    } else {, +                        observer.onError(n.getThrowable());, +                    }, +                    return Subscriptions.empty();, +                } else {, +                    return null;, +                }, +            }, +        return new PublishSubject<T>(onSubscribe, observers, terminalState);, +    private final AtomicReference<Notification<? extends T>> terminalState;, +    protected PublishSubject(OnSubscribeFunc<T> onSubscribe, ConcurrentHashMap<Subscription, Observer<? super T>> observers, AtomicReference<Notification<? extends T>> terminalState) {, +        this.terminalState = terminalState;, +        /**, +         * Synchronizing despite terminalState being an AtomicReference because of multi-step logic in subscription., +         * Why use AtomicReference then? Convenient for passing around a mutable reference holder between the, +         * onSubscribe function and PublishSubject instance... and it's a "better volatile" for the shortcut codepath., +         */, +        synchronized (terminalState) {, +            terminalState.set(new Notification<T>());, +        }, +        /**, +         * Synchronizing despite terminalState being an AtomicReference because of multi-step logic in subscription., +         * Why use AtomicReference then? Convenient for passing around a mutable reference holder between the, +         * onSubscribe function and PublishSubject instance... and it's a "better volatile" for the shortcut codepath., +         */, +        synchronized (terminalState) {, +            terminalState.set(new Notification<T>(e));, +        }, +        /**, +         * Test that subscribing after onError/onCompleted immediately terminates instead of causing it to hang., +         *, +         * Nothing is mentioned in Rx Guidelines for what to do in this case so I'm doing what seems to make sense, +         * which is:, +         *, +         * - cache terminal state (onError/onCompleted), +         * - any subsequent subscriptions will immediately receive the terminal state rather than start a new subscription, +         *, +         */, +        @Test, +        public void testUnsubscribeAfterOnCompleted() {, +            PublishSubject<String> subject = PublishSubject.create();, +, +            @SuppressWarnings("unchecked"), +            Observer<String> anObserver = mock(Observer.class);, +            subject.subscribe(anObserver);, +]