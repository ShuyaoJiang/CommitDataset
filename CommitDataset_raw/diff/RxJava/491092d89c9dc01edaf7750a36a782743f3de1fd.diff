[+++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +            request(1);, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +            request(1);, +++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.*;, +import rx.*;, +import rx.functions.Func1;, +import rx.subjects.Subject;, +        public TestObservable(T... values) {, +        public TestObservable(CountDownLatch once, CountDownLatch okToContinue, T... values) {, +    @Test(timeout = 10000), +    public void testIssue2890NoStackoverflow() throws InterruptedException {, +        final ExecutorService executor = Executors.newFixedThreadPool(2);, +        final Scheduler sch = Schedulers.from(executor);, +, +        Func1<Integer, Observable<Integer>> func = new Func1<Integer, Observable<Integer>>() {, +            @Override, +            public Observable<Integer> call(Integer t) {, +                Observable<Integer> observable = Observable.just(t), +                        .subscribeOn(sch), +                ;, +                Subject<Integer, Integer> subject = BufferUntilSubscriber.create();, +                observable.subscribe(subject);, +                return subject;, +            }, +        };, +, +        int n = 5000;, +        final AtomicInteger counter = new AtomicInteger();, +, +        Observable.range(1, n).concatMap(func).subscribe(new Subscriber<Integer>() {, +            @Override, +            public void onNext(Integer t) {, +                // Consume after sleep for 1 ms, +                try {, +                    Thread.sleep(1);, +                } catch (InterruptedException e) {, +                    // ignored, +                }, +                if (counter.getAndIncrement() % 100 == 0) {, +                    System.out.print("testIssue2890NoStackoverflow -> ");, +                    System.out.println(counter.get());, +                };, +            }, +, +            @Override, +            public void onCompleted() {, +                executor.shutdown();, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                executor.shutdown();, +            }, +        });, +, +        executor.awaitTermination(12000, TimeUnit.MILLISECONDS);, +        , +        assertEquals(n, counter.get());, +    }]