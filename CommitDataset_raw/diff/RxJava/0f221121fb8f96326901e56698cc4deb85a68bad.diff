[+++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java, +import rx.Scheduler;, +import rx.util.functions.Func2;, +public class TestScheduler extends Scheduler {, +    private final Queue<TimedAction<?>> queue = new PriorityQueue<TimedAction<?>>(11, new CompareActionsByTime());, +    private static class TimedAction<T> {, +        private final Func2<Scheduler, T, Subscription> action;, +        private final T state;, +        private final TestScheduler scheduler;, +        private TimedAction(TestScheduler scheduler, long time, Func2<Scheduler, T, Subscription> action, T state) {, +            this.state = state;, +            this.scheduler = scheduler;, +    private static class CompareActionsByTime implements Comparator<TimedAction<?>> {, +        public int compare(TimedAction<?> action1, TimedAction<?> action2) {, +    public void advanceTimeBy(long delayTime, TimeUnit unit) {, +        advanceTimeTo(time + unit.toNanos(delayTime), TimeUnit.NANOSECONDS);, +    public void advanceTimeTo(long delayTime, TimeUnit unit) {, +        long targetTime = unit.toNanos(delayTime);, +    @SuppressWarnings("unchecked"), +            TimedAction<?> current = queue.peek();, +            // because the queue can have wildcards we have to ignore the type T for the state, +            ((Func2<Scheduler, Object, Subscription>) current.action).call(current.scheduler, current.state);, +, +    @Override, +    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action) {, +        return schedule(state, action, 0, TimeUnit.MILLISECONDS);, +    }, +, +    @Override, +    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {, +        queue.add(new TimedAction<T>(this, now() + unit.toNanos(delayTime), action, state));, +        return Subscriptions.empty();, +    }]