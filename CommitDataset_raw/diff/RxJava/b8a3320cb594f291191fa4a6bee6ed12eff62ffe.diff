[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.maybe.MaybeFromPublisher;, +    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Maybe<T> toMaybe() {, +        return new MaybeFromPublisher<T>(this);, +    }, +, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.maybe.MaybeFromPublisher;, +    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), +    @SchedulerSupport(SchedulerSupport.NONE), +    public final Maybe<T> toMaybe() {, +        return new MaybeFromPublisher<T>(this);, +    }, +, +++ b/src/main/java/io/reactivex/Maybe.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex;, +, +import java.util.concurrent.*;, +, +import org.reactivestreams.*;, +, +import io.reactivex.disposables.Disposable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.functions.*;, +import io.reactivex.internal.functions.*;, +import io.reactivex.internal.operators.maybe.*;, +import io.reactivex.internal.subscribers.maybe.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.Schedulers;, +, +/**, + * Represents a deferred computation and emission of a maybe value or exception., + * , + * @param <T> the value type, + */, +public abstract class Maybe<T> implements MaybeSource<T> {, +    static <T> Maybe<T> wrap(MaybeSource<T> source) {, +        ObjectHelper.requireNonNull(source, "source is null");, +        if (source instanceof Maybe) {, +            return (Maybe<T>)source;, +        }, +        return new MaybeFromUnsafeSource<T>(source);, +    }, +    , +    public static <T> Maybe<T> amb(final Iterable<? extends MaybeSource<? extends T>> sources) {, +        ObjectHelper.requireNonNull(sources, "sources is null");, +        return new MaybeAmbIterable<T>(sources);, +    }, +    , +    @SuppressWarnings("unchecked"), +    public static <T> Maybe<T> amb(final MaybeSource<? extends T>... sources) {, +        if (sources.length == 0) {, +            return Maybe.complete();, +        }, +        if (sources.length == 1) {, +            return wrap((MaybeSource<T>)sources[0]);, +        }, +        return new MaybeAmbArray<T>(sources);, +    }, +    , +    @SuppressWarnings("unchecked"), +    public static <T> Maybe<T> complete() {, +        return (Maybe<T>) MaybeComplete.INSTANCE;, +    }, +, +    public static <T> Flowable<T> concat(Iterable<? extends MaybeSource<? extends T>> sources) {, +        return concat(Flowable.fromIterable(sources));, +    }, +    , +    public static <T> Flowable<T> concat(Flowable<? extends MaybeSource<? extends T>> sources) { // FIXME Publisher, +        return sources.concatMap(new Function<MaybeSource<? extends T>, Publisher<? extends T>>() {, +            @Override , +            public Publisher<? extends T> apply(MaybeSource<? extends T> v){, +                return new MaybeToFlowable<T>(v);, +            }, +        });, +    }, +    , +    @SuppressWarnings("unchecked"), +    public static <T> Flowable<T> concat(, +            MaybeSource<? extends T> s1, MaybeSource<? extends T> s2, +     ) {, +        ObjectHelper.requireNonNull(s1, "s1 is null");, +        ObjectHelper.requireNonNull(s2, "s2 is null");, +        return concat(Flowable.fromArray(s1, s2));]