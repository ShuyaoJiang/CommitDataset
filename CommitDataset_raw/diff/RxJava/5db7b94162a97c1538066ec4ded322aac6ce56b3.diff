[+++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +import rx.internal.producers.ProducerArbiter;, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +        private final ProducerArbiter arbiter;, +            this.arbiter = new ProducerArbiter();, +            if (n <=0) return;, +            long previous = BackpressureUtils.getAndAddRequest(REQUESTED, this, n);, +            arbiter.request(n);, +            if (previous == 0) {, +                if (currentSubscriber == null && wip > 0) {, +            REQUESTED.decrementAndGet(this);, +            if (WIP.getAndIncrement(this) == 0) {, +            if (WIP.getAndIncrement(this) == 0) {, +, +            if (WIP.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, arbiter);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        private final ProducerArbiter arbiter;, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, ProducerArbiter arbiter) {, +            this.arbiter = arbiter;, +            parent.decrementRequested();, +            arbiter.produced(1);, +            if (ONCE.compareAndSet(this, 0, 1)) {, +            if (ONCE.compareAndSet(this, 0, 1)) {, +        @Override, +        public void setProducer(Producer producer) {, +            arbiter.setProducer(producer);, +        }, +, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +import rx.internal.producers.ProducerArbiter;, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +        private final ProducerArbiter arbiter;, +            this.arbiter = new ProducerArbiter();, +            if (n <=0) return;, +            long previous = BackpressureUtils.getAndAddRequest(REQUESTED, this, n);, +            arbiter.request(n);, +            if (previous == 0) {, +                if (currentSubscriber == null && wip > 0) {, +            REQUESTED.decrementAndGet(this);, +            if (WIP.getAndIncrement(this) == 0) {, +            if (WIP.getAndIncrement(this) == 0) {, +, +            if (WIP.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, arbiter);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        private final ProducerArbiter arbiter;, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, ProducerArbiter arbiter) {, +            this.arbiter = arbiter;, +            parent.decrementRequested();, +            arbiter.produced(1);, +            if (ONCE.compareAndSet(this, 0, 1)) {, +            if (ONCE.compareAndSet(this, 0, 1)) {, +        @Override, +        public void setProducer(Producer producer) {, +            arbiter.setProducer(producer);, +        }, +, +++ b/src/main/java/rx/internal/producers/ProducerArbiter.java, +                    throw new IllegalStateException("more items arrived than were requested");, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +import rx.internal.producers.ProducerArbiter;, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +        private final ProducerArbiter arbiter;, +            this.arbiter = new ProducerArbiter();, +            if (n <=0) return;, +            long previous = BackpressureUtils.getAndAddRequest(REQUESTED, this, n);, +            arbiter.request(n);, +            if (previous == 0) {, +                if (currentSubscriber == null && wip > 0) {, +            REQUESTED.decrementAndGet(this);, +            if (WIP.getAndIncrement(this) == 0) {, +            if (WIP.getAndIncrement(this) == 0) {, +, +            if (WIP.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, arbiter);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        private final ProducerArbiter arbiter;, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, ProducerArbiter arbiter) {, +            this.arbiter = arbiter;, +            parent.decrementRequested();, +            arbiter.produced(1);, +            if (ONCE.compareAndSet(this, 0, 1)) {, +            if (ONCE.compareAndSet(this, 0, 1)) {, +        @Override, +        public void setProducer(Producer producer) {, +            arbiter.setProducer(producer);, +        }, +, +++ b/src/main/java/rx/internal/producers/ProducerArbiter.java, +                    throw new IllegalStateException("more items arrived than were requested");, +++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java, +    @Test//(timeout = 100000), +    public void concatMapRangeAsyncLoopIssue2876() {]