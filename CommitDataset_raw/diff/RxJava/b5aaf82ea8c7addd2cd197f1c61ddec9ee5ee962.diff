[+++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import java.util.Iterator;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.exceptions.Exceptions;, +import rx.internal.util.RxThreadFactory;, +    /** The purge frequency in milliseconds. */, +    private static final String FREQUENCY_KEY = "io.reactivex.rxjava.scheduler.jdk6.purge-frequency-millis";, +    /** Force the use of purge (true/false). */, +    private static final String PURGE_FORCE_KEY = "io.reactivex.rxjava.scheduler.jdk6.purge-force";, +    private static final String PURGE_THREAD_PREFIX = "RxSchedulerPurge-";, +    /** Forces the use of purge even if setRemoveOnCancelPolicy is available. */, +    private static final boolean PURGE_FORCE;, +    /** The purge frequency in milliseconds. */, +    public static final int PURGE_FREQUENCY;, +    private static final ConcurrentHashMap<ScheduledThreadPoolExecutor, ScheduledThreadPoolExecutor> EXECUTORS;, +    private static final AtomicReference<ScheduledExecutorService> PURGE;, +    static {, +        EXECUTORS = new ConcurrentHashMap<ScheduledThreadPoolExecutor, ScheduledThreadPoolExecutor>();, +        PURGE = new AtomicReference<ScheduledExecutorService>();, +        PURGE_FORCE = Boolean.getBoolean(PURGE_FORCE_KEY);, +        PURGE_FREQUENCY = Integer.getInteger(FREQUENCY_KEY, 1000);, +    }, +    /** , +     * Registers the given executor service and starts the purge thread if not already started. , +     * <p>{@code public} visibility reason: called from other package(s) within RxJava, +     * @param service a scheduled thread pool executor instance , +     */, +    public static void registerExecutor(ScheduledThreadPoolExecutor service) {, +        do {, +            ScheduledExecutorService exec = PURGE.get();, +            if (exec != null) {, +                break;, +            }, +            exec = Executors.newScheduledThreadPool(1, new RxThreadFactory(PURGE_THREAD_PREFIX));, +            if (PURGE.compareAndSet(null, exec)) {, +                exec.scheduleAtFixedRate(new Runnable() {, +                    @Override, +                    public void run() {, +                        purgeExecutors();, +                    }, +                }, PURGE_FREQUENCY, PURGE_FREQUENCY, TimeUnit.MILLISECONDS);, +                break;, +            }, +        } while (true);, +        , +        EXECUTORS.putIfAbsent(service, service);, +    }, +    /** , +     * Deregisters the executor service. , +     * <p>{@code public} visibility reason: called from other package(s) within RxJava, +     * @param service a scheduled thread pool executor instance , +     */, +    public static void deregisterExecutor(ScheduledExecutorService service) {, +        EXECUTORS.remove(service);, +    }, +    /** Purges each registered executor and eagerly evicts shutdown executors. */, +    static void purgeExecutors() {, +        try {, +            Iterator<ScheduledThreadPoolExecutor> it = EXECUTORS.keySet().iterator();, +            while (it.hasNext()) {, +                ScheduledThreadPoolExecutor exec = it.next();, +                if (!exec.isShutdown()) {, +                    exec.purge();, +                } else {, +                    it.remove();, +                }, +            }, +        } catch (Throwable t) {, +            Exceptions.throwIfFatal(t);, +            RxJavaPlugins.getInstance().getErrorHandler().handleError(t);, +        }, +    }, +    , +    /** , +     * Tries to enable the Java 7+ setRemoveOnCancelPolicy., +     * <p>{@code public} visibility reason: called from other package(s) within RxJava., +     * If the method returns false, the {@link #registerExecutor(ScheduledThreadPoolExecutor)} may, +     * be called to enable the backup option of purging the executors., +     * @param exec the executor to call setRemoveOnCaneclPolicy if available., +     * @return true if the policy was successfully enabled , +     */, +    public static boolean tryEnableCancelPolicy(ScheduledExecutorService exec) {, +        if (!PURGE_FORCE) {, +            for (Method m : exec.getClass().getMethods()) {, +                        m.invoke(exec, true);, +                        return true;, +        }, +        return false;, +    }, +    , +    /* package */, +    public NewThreadWorker(ThreadFactory threadFactory) {, +        ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, threadFactory);, +        // Java 7+: cancelled future tasks can be removed from the executor thus avoiding memory leak, +        boolean cancelSupported = tryEnableCancelPolicy(exec);, +        if (!cancelSupported && exec instanceof ScheduledThreadPoolExecutor) {, +            registerExecutor((ScheduledThreadPoolExecutor)exec);, +        }, +        executor = exec;, +        deregisterExecutor(executor);]