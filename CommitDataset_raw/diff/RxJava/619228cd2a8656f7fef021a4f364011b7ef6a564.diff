[+++ b/rxjava-examples/src/main/clojure/rx/examples/clojure/rx_examples.clj, +(ns rx.examples.clojure.rx-examples, +  (import rx.observables.Observable), +  (:require [clj-http.client :as http])), +, +; NOTE on naming conventions. I'm using camelCase names (against clojure convention), +; in this file as I'm purposefully keeping functions and methods across, +; different language implementations in-sync for easy comparison., +;, +; See rx.examples.groovy.RxExamples, rx.examples.java.RxExamples, etc., +, +; --------------------------------------------------, +; Hello World!, +; --------------------------------------------------, +, +(defn hello, +  [&rest], +  (-> (Observable/toObservable &rest), +    (.subscribe #(println (str "Hello " % "!"))))), +, +; To see output, +#_(hello ["Ben" "George"]), +, +; --------------------------------------------------, +; Create Observable from Existing Data, +; --------------------------------------------------, + , +(defn existingDataFromNumbers [], +    (Observable/toObservable [1 2 3 4 5 6])), +, +(defn existingDataFromNumbersUsingFrom [], +    (Observable/from [1 2 3 4 5 6])), +, +(defn existingDataFromObjects [], +    (Observable/toObservable ["a" "b" "c"])), +    , +(defn existingDataFromObjectsUsingFrom [], +    (Observable/from ["a" "b" "c"])), +, +(defn existingDataFromList [], +    (let [list [5, 6, 7, 8]], +      (Observable/toObservable list))), +    , +(defn existingDataFromListUsingFrom [], +  (let [list [5, 6, 7, 8]], +    (Observable/from list))), +, +(defn existingDataWithJust [], +    (Observable/just "one object")), +, +; --------------------------------------------------, +; Custom Observable, +; --------------------------------------------------, +, +(defn customObservableBlocking [], +  "This example shows a custom Observable that blocks , +   when subscribed to (does not spawn an extra thread)., +   , +  returns Observable<String>", +  (Observable/create , +    (fn [observer], +      (doseq [x (range 50)] (-> observer (.onNext (str "value_" x)))), +      ; after sending all values we complete the sequence, +      (-> observer .onCompleted), +      ; return a NoOpSubsription since this blocks and thus, +      ; can't be unsubscribed from, +      (Observable/noOpSubscription)))), +, +; To see output, +#_(.subscribe (customObservableBlocking) #(println %)), +, +(defn customObservableNonBlocking [], +  "This example shows a custom Observable that does not block , +   when subscribed to as it spawns a separate thread., +   , +  returns Observable<String>", +  (Observable/create , +    (fn [observer], +      (let [f (future , +                (doseq [x (range 50)] (-> observer (.onNext (str "anotherValue_" x)))), +                ; after sending all values we complete the sequence, +                (-> observer .onCompleted)), +            ; a subscription that cancels the future if unsubscribed, +            subscription (Observable/createSubscription #(-> f (.cancel true)))], +        )), +      )), +, +; To see output, +#_(.subscribe (customObservableNonBlocking) #(println %)), +, +, +(defn fetchWikipediaArticleAsynchronously [wikipediaArticleNames], +  "Fetch a list of Wikipedia articles asynchronously., +  , +   return Observable<String> of HTML", +  (Observable/create , +    (fn [observer], +      (let [f (future, +                (doseq [articleName wikipediaArticleNames], +                  (-> observer (.onNext (http/get (str "http://en.wikipedia.org/wiki/" articleName)))))]