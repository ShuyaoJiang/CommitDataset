[+++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                int n = a.length;, +                if (n == 0) {, +++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                int n = a.length;, +                if (n == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (v != null) {, +        }, +            if (value != null) {, +            } else {, +                RxJavaPlugins.onError(e);, +            }, +            if (v != null) {, +        }, +++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                int n = a.length;, +                if (n == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (v != null) {, +        }, +            if (value != null) {, +            } else {, +                RxJavaPlugins.onError(e);, +            }, +            if (v != null) {, +        }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +        return new MulticastFlowable<R, U>(connectableFactory, selector);, +    static final class MulticastFlowable<R, U> extends Flowable<R> {, +        MulticastFlowable(Callable<? extends ConnectableFlowable<U>> connectableFactory, Function<? super Flowable<U>, ? extends Publisher<R>> selector) {, +        protected void subscribeActual(Subscriber<? super R> child) {, +++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                int n = a.length;, +                if (n == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (v != null) {, +        }, +            if (value != null) {, +            } else {, +                RxJavaPlugins.onError(e);, +            }, +            if (v != null) {, +        }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +        return new MulticastFlowable<R, U>(connectableFactory, selector);, +    static final class MulticastFlowable<R, U> extends Flowable<R> {, +        MulticastFlowable(Callable<? extends ConnectableFlowable<U>> connectableFactory, Function<? super Flowable<U>, ? extends Publisher<R>> selector) {, +        protected void subscribeActual(Subscriber<? super R> child) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java, +                    s.cancel();, +++ b/src/main/java/io/reactivex/Maybe.java, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, +        return mergeDelayError(sources, Integer.MAX_VALUE);, +        ObjectHelper.requireNonNull(sources, "source is null");, +        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                int n = a.length;, +                if (n == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java, +import io.reactivex.plugins.RxJavaPlugins;, +            if (v != null) {, +        }, +            if (value != null) {, +            } else {, +                RxJavaPlugins.onError(e);]