[+++ b/build.gradle, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +    @SuppressWarnings("unchecked"), +        // Casting to Observable<R> is type-safe because we know Observable is covariant., +        return (Observable<R>) ((Transformer<T, ? extends R>) transformer).call(this);, +    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<? extends R>> {, +        return OperatorPublish.create(this);, +        return OperatorPublish.create(this, selector);, +//        return multicast(new Func0<Subject<T, T>>() {, +//            @Override, +//            public final Subject<T, T> call() {, +//                return PublishSubject.create();, +//            }, +//        }, selector);, +++ b/build.gradle, +++ b/src/main/java/rx/Observable.java, +    @SuppressWarnings("unchecked"), +        // Casting to Observable<R> is type-safe because we know Observable is covariant., +        return (Observable<R>) ((Transformer<T, ? extends R>) transformer).call(this);, +    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<? extends R>> {, +        return OperatorPublish.create(this);, +        return OperatorPublish.create(this, selector);, +//        return multicast(new Func0<Subject<T, T>>() {, +//            @Override, +//            public final Subject<T, T> call() {, +//                return PublishSubject.create();, +//            }, +//        }, selector);, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +package rx.internal.operators;, +, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +import rx.Observable;, +import rx.Producer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.exceptions.CompositeException;, +import rx.exceptions.Exceptions;, +import rx.exceptions.MissingBackpressureException;, +import rx.functions.Action0;, +import rx.functions.Action1;, +import rx.functions.Func1;, +import rx.internal.util.RxRingBuffer;, +import rx.observables.ConnectableObservable;, +import rx.subscriptions.Subscriptions;, +, +public class OperatorPublish<T> extends ConnectableObservable<T> {, +    final Observable<? extends T> source;, +    private final RequestHandler<T> requestHandler;, +, +    public static <T> ConnectableObservable<T> create(Observable<? extends T> source) {, +        return new OperatorPublish<T>(source);, +    }, +, +    public static <T, R> Observable<R> create(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector) {, +        return Observable.create(new OnSubscribe<R>() {, +, +            @Override, +            public void call(final Subscriber<? super R> child) {, +                OperatorPublish<T> op = new OperatorPublish<T>(source);, +                selector.call(op).unsafeSubscribe(child);, +                op.connect(new Action1<Subscription>() {, +, +                    @Override, +                    public void call(Subscription sub) {, +                        child.add(sub);, +                    }, +, +                });, +            }, +, +        });, +    }, +, +    private OperatorPublish(Observable<? extends T> source) {, +        this(source, new Object(), new RequestHandler<T>());, +    }]