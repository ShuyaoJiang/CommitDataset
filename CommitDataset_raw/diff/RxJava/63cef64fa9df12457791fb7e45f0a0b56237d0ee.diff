[+++ b/rxjava-core/src/main/java/rx/operators/AbstractOperation.java, +package rx.operators;, +, +import static org.junit.Assert.*;, +, +import java.lang.Thread.UncaughtExceptionHandler;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Test;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Func1;, +, +/**, + * Common utility functions for operator implementations and tests., + */, +/* package */class AbstractOperation, +{, +    private AbstractOperation() {, +    }, +, +    public static class UnitTest {, +, +        public static <T> Func1<Observer<T>, Subscription> assertTrustedObservable(final Func1<Observer<T>, Subscription> source), +        {, +            return new Func1<Observer<T>, Subscription>(), +            {, +                @Override, +                public Subscription call(Observer<T> observer), +                {, +                    return source.call(new TestingObserver<T>(observer));, +                }, +            };, +        }, +, +        public static class TestingObserver<T> implements Observer<T> {, +, +            private final Observer<T> actual;, +            private final AtomicBoolean isFinished = new AtomicBoolean(false);, +            private final AtomicBoolean isInCallback = new AtomicBoolean(false);, +, +            public TestingObserver(Observer<T> actual) {, +                this.actual = actual;, +            }, +, +            @Override, +            public void onCompleted() {, +                assertFalse("previous call to onCompleted() or onError()", !isFinished.compareAndSet(false, true));, +                assertFalse("concurrent callback pending", !isInCallback.compareAndSet(false, true));, +                actual.onCompleted();, +                isInCallback.set(false);, +            }, +, +            @Override, +            public void onError(Exception e) {, +                assertFalse("previous call to onCompleted() or onError()", !isFinished.compareAndSet(false, true));, +                assertFalse("concurrent callback pending", !isInCallback.compareAndSet(false, true));, +                actual.onError(e);, +                isInCallback.set(false);, +            }, +, +            @Override, +            public void onNext(T args) {, +                assertFalse("previous call to onCompleted() or onError()", isFinished.get());, +                assertFalse("concurrent callback pending", !isInCallback.compareAndSet(false, true));, +                actual.onNext(args);, +                isInCallback.set(false);, +            }, +, +        }, +, +        @Test(expected = AssertionError.class), +        public void testDoubleCompleted() {, +            Observable.create(assertTrustedObservable(new Func1<Observer<String>, Subscription>(), +            {, +                @Override, +                public Subscription call(Observer<String> observer), +                {, +                    observer.onCompleted();, +                    observer.onCompleted();, +                    return Subscriptions.empty();, +                }, +            })).lastOrDefault("end");, +, +        }, +, +        @Test(expected = AssertionError.class), +        public void testCompletedError() {, +            Observable.create(assertTrustedObservable(new Func1<Observer<String>, Subscription>(), +            {, +                @Override, +                public Subscription call(Observer<String> observer), +                {, +                    observer.onCompleted();]