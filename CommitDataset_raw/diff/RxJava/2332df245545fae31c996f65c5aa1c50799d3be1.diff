[+++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, +        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, +        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, +        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/Observable.java, +        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, +        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators.observable;, +, +import java.util.concurrent.atomic.*;, +, +import io.reactivex.*;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.functions.Function;, +import io.reactivex.internal.disposables.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.util.*;, +import io.reactivex.subjects.*;, +, +/**, + * Repeatedly subscribe to a source if a handler ObservableSource signals an item., + *, + * @param <T> the value type, + */, +public final class ObservableRepeatWhen<T> extends AbstractObservableWithUpstream<T, T> {, +, +    final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler;, +, +    public ObservableRepeatWhen(ObservableSource<T> source, Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) {, +        super(source);, +        this.handler = handler;, +    }, +, +    @Override, +    protected void subscribeActual(Observer<? super T> observer) {, +        Subject<Object> signaller = PublishSubject.create().toSerialized();, +, +        ObservableSource<?> other;, +, +        try {, +            other = ObjectHelper.requireNonNull(handler.apply(signaller), "The handler returned a null ObservableSource");, +        } catch (Throwable ex) {, +            Exceptions.throwIfFatal(ex);, +            EmptyDisposable.error(ex, observer);, +            return;, +        }, +, +        RepeatWhenObserver<T> parent = new RepeatWhenObserver<T>(observer, signaller, source);, +        observer.onSubscribe(parent);, +, +        other.subscribe(parent.inner);, +, +        parent.subscribeNext();, +    }, +, +    static final class RepeatWhenObserver<T> extends AtomicInteger implements Observer<T>, Disposable {, +, +        private static final long serialVersionUID = 802743776666017014L;, +, +        final Observer<? super T> actual;, +, +        final AtomicInteger wip;, +, +        final AtomicThrowable error;, +, +        final Subject<Object> signaller;, +, +        final InnerRepeatObserver inner;, +, +        final AtomicReference<Disposable> d;, +, +        final ObservableSource<T> source;, +, +        volatile boolean active;, +]