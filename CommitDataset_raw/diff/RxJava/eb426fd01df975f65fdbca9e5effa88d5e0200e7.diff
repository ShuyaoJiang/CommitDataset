[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.*;, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, +import io.reactivex.internal.util.*;, +        BufferBoundarySubscriber<T, U, Open, Close> parent =, +            new BufferBoundarySubscriber<T, U, Open, Close>(, +                s, bufferOpen, bufferClose, bufferSupplier, +            );, +        s.onSubscribe(parent);, +        source.subscribe(parent);, +    static final class BufferBoundarySubscriber<T, C extends Collection<? super T>, Open, Close>, +    extends AtomicInteger implements FlowableSubscriber<T>, Subscription {, +, +        private static final long serialVersionUID = -8466418554264089604L;, +, +        final Subscriber<? super C> actual;, +, +        final Callable<C> bufferSupplier;, +, +, +        final CompositeDisposable subscribers;, +        final AtomicLong requested;, +        final AtomicReference<Subscription> upstream;, +        final AtomicThrowable errors;, +, +        volatile boolean done;, +, +        final SpscLinkedArrayQueue<C> queue;, +, +        volatile boolean cancelled;, +, +        long index;, +, +        Map<Long, C> buffers;, +, +        long emitted;, +, +        BufferBoundarySubscriber(Subscriber<? super C> actual,, +                Callable<C> bufferSupplier, +        ) {, +            this.actual = actual;, +            this.bufferSupplier = bufferSupplier;, +            this.queue = new SpscLinkedArrayQueue<C>(bufferSize());, +            this.subscribers = new CompositeDisposable();, +            this.requested = new AtomicLong();, +            this.upstream = new AtomicReference<Subscription>();, +            this.buffers = new LinkedHashMap<Long, C>();, +            this.errors = new AtomicThrowable();, +, +            if (SubscriptionHelper.setOnce(this.upstream, s)) {, +                BufferOpenSubscriber<Open> open = new BufferOpenSubscriber<Open>(this);, +                subscribers.add(open);, +                bufferOpen.subscribe(open);, +                Map<Long, C> bufs = buffers;, +                if (bufs == null) {, +                    return;, +                }, +                for (C b : bufs.values()) {, +            if (errors.addThrowable(t)) {, +                subscribers.dispose();, +                    buffers = null;, +                done = true;, +                drain();, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +            subscribers.dispose();, +                Map<Long, C> bufs = buffers;, +                if (bufs == null) {, +                    return;, +                for (C b : bufs.values()) {, +                    queue.offer(b);, +                }, +                buffers = null;, +            drain();, +            BackpressureHelper.add(requested, n);, +            drain();, +            if (SubscriptionHelper.cancel(upstream)) {, +                subscribers.dispose();, +                synchronized (this) {, +                    buffers = null;, +                }, +                if (getAndIncrement() != 0) {, +                    queue.clear();, +                }, +        void open(Open token) {, +            C buf;, +                buf = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null Collection");, +                p = ObjectHelper.requireNonNull(bufferClose.apply(token), "The bufferClose returned a null Publisher");, +            } catch (Throwable ex) {, +                Exceptions.throwIfFatal(ex);, +                SubscriptionHelper.cancel(upstream);, +                onError(ex);, +            long idx = index;, +            index = idx + 1;, +                Map<Long, C> bufs = buffers;, +                if (bufs == null) {, +                bufs.put(idx, buf);, +            BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx);]