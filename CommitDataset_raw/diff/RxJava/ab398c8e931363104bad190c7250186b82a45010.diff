[+++ b/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java, +import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;, +, +import rx.internal.util.MpscPaddedQueue.Node;, +, +abstract class MpscLinkedQueuePad0<E> {, +    long p00, p01, p02, p03, p04, p05, p06, p07;, +    long p30, p31, p32, p33, p34, p35, p36, p37;, +}, +, +abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> {, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, Node> UPDATER =, +        newUpdater(MpscLinkedQueueHeadRef.class, Node.class, "headRef");, +    private volatile Node<E> headRef;, +, +    protected final Node<E> headRef() {, +        return headRef;, +    }, +    protected final void headRef(Node<E> val) {, +        headRef = val;, +    }, +    protected final void lazySetHeadRef(Node<E> newVal) {, +        UPDATER.lazySet(this, newVal);, +    }, +}, +, +abstract class MpscLinkedQueuePad1<E> extends MpscLinkedQueueHeadRef<E> {, +    long p00, p01, p02, p03, p04, p05, p06, p07;, +    long p30, p31, p32, p33, p34, p35, p36, p37;, +}, +, +abstract class MpscLinkedQueueTailRef<E> extends MpscLinkedQueuePad1<E> {, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, Node> UPDATER =, +        newUpdater(MpscLinkedQueueTailRef.class, Node.class, "tailRef");, +    private volatile Node<E> tailRef;, +    protected final Node<E> tailRef() {, +        return tailRef;, +    }, +    protected final void tailRef(Node<E> val) {, +        tailRef = val;, +    }, +    @SuppressWarnings("unchecked"), +    protected final Node<E> getAndSetTailRef(Node<E> newVal) {, +        return (Node<E>) UPDATER.getAndSet(this, newVal);, +    }, +}, + * but using {@code AtomicReferenceFieldUpdater} instead of {@code Unsafe}.<br>, + * Original algorithm presented <a, + * href="http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue"> on 1024, + * Cores</a> by D. Vyukov.<br>, + * Data structure modified to avoid false sharing between head and tail references as per implementation of, + * MpscLinkedQueue on <a href="https://github.com/JCTools/JCTools">JCTools project</a>., +public final class MpscPaddedQueue<E> extends MpscLinkedQueueTailRef<E> {, +    long p00, p01, p02, p03, p04, p05, p06, p07;, +    long p30, p31, p32, p33, p34, p35, p36, p37;, +        Node<E> stub = new Node<E>(null);, +        headRef(stub);, +        tailRef(stub);, +        getAndSetTailRef(n).next(n);, +        lazySetHeadRef(n);, +            Node<E> t = headRef();, +            Node<E> n = t.next();, +            if (n != null || headRef() == t) {, +    static final class Node<E> {, +        private volatile Node<E> next;, +        Node(E value) {, +        void next(Node<E> newNext) {, +            TAIL_UPDATER.lazySet(this, newNext);, +        Node<E> next() {, +            return next;]