[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * receive items and notifications from the Observable. A typical implementation of, +     * <code>subscribe</code> does the following:, +     * <code>List&lt;T&gt;</code> object., +     * @param observer, +     * @return a {@link Subscription} reference with which the Observer can stop receiving items, +     *             if the {@link Observer} provided as the argument to <code>subscribe()</code> is, +     *             <code>null</code>, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * receive items and notifications from the Observable. A typical implementation of, +     * <code>subscribe</code> method does the following:, +     * <code>List&lt;T&gt;</code> object., +     * An <code>Observable&lt;T&gt;</code> instance is responsible for accepting all subscriptions, +     * <code>Observable&lt;T&gt;</code> implementation indicates otherwise, Observers should make no, +     * @param observer, +     *             if an argument to <code>subscribe()</code> is <code>null</code>, +     *            a function that accepts an <code>Observer&lt;T&gt;</code>, invokes its, +     *            <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods, +     *            a function that accepts an <code>Observer&lt;T&gt;</code>, invokes its, +     *            <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods, +     * Filters an Observable by discarding any items it emits that do not meet some test., +     *            <code>true</code> if they pass the filter, +     * @return an Observable that emits only those items emitted by the source Observable that the, +     *         filter evaluates as <code>true</code>, +     * Filters an Observable by discarding any items it emits that do not meet some test., +     *            returns <code>true</code> if it passes the filter, +     * @return an Observable that emits only those items emitted by the source Observable that the, +     *         filter evaluates as <code>true</code>, +     * Filters an Observable by discarding any items it emits that do not meet some test., +     *            returns <code>true</code> if it passes the filter, +     * @return an Observable that emits only those items emitted by the source Observable that the, +     *         filter evaluates as <code>true</code>, +     * new Observer that subscribes., +     * Applies a function of your choosing to every item emitted by an Observable, and emits the, +     * results of these transformations as its own Observable items., +     * Applies a function of your choosing to every item emitted by an Observable, and emits the, +     * results of these transformations as its own Observable items., +     * Note: <code>mapMany</code> and <code>flatMap</code> are equivalent., +     *            <code>func</code>, +     * Note: <code>mapMany</code> and <code>flatMap</code> are equivalent., +     *            <code>func</code>, +     *         <code>source</code> list of Observables, +     * Observable, by using the <code>merge</code> method., +     *         by the Observables emitted by the <code>source</code> Observable, +     * Observable, by using the <code>merge</code> method., +     *         by the <code>source</code> Observables, +     * Returns an Observable that emits the items from the <code>source</code> Observable until, +     * the <code>other</code> Observable emits an item., +     *            the Observable whose first emitted item will cause <code>takeUntil</code> to stop, +     *            emitting items from the <code>source</code> Observable, +     *            the type of items emitted by <code>source</code>, +     *            the type of items emitted by <code>other</code>, +     * @return an Observable that emits the items emitted by <code>source</code> until such time as, +     *         <code>other</code> emits its first item, +     *         the <code>source</code> Observables, one after the other, +     * Note: <code>mapMany</code> and <code>flatMap</code> are equivalent., +     *            <code>func</code>, +     * Note: <code>mapMany</code> and <code>flatMap</code> are equivalent., +     *            <code>func</code>, +     * notify of an error via {@link Observer#onError onError}, <code>mergeDelayError</code> will, +     * Even if multiple merged Observables send <code>onError</code> notifications,, +     * <code>mergeDelayError</code> will only invoke the <code>onError</code> method of its, +     *         the <code>source</code> list of Observables, +     * notify of an error via {@link Observer#onError onError}, <code>mergeDelayError</code> will, +     * Even if multiple merged Observables send <code>onError</code> notifications,, +     * <code>mergeDelayError</code> will only invoke the <code>onError</code> method of its, +     *         the Observables emitted by the <code>source</code> Observable, +     * notify of an error via {@link Observer#onError onError}, <code>mergeDelayError</code> will, +     * Even if multiple merged Observables send <code>onError</code> notifications,, +     * <code>mergeDelayError</code> will only invoke the <code>onError</code> method of its, +     *         the <code>source</code> Observables, +     * <code>onError</code> method, and then quits without invoking any more of its Observer's, +     * methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a, +     * function that returns an Observable (<code>resumeFunction</code>) to, +     * <code>onErrorResumeNext</code>, if the source Observable encounters an error, instead of, +     * invoking its Observer's <code>onError</code> function, it will instead relinquish control to, +     * <code>onError</code>, the Observer may never know that an error happened., +     * @return the source Observable, with its behavior modified as described, +     * methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a, +     * function that returns an Observable (<code>resumeFunction</code>) to, +     * <code>onErrorResumeNext</code>, if the source Observable encounters an error, instead of, +     * invoking its Observer's <code>onError</code> function, it will instead relinquish control to, +     * <code>onError</code>, the Observer may never know that an error happened., +     * @return the source Observable, with its behavior modified as described, +     * <code>onError</code> method, and then quits without invoking any more of its Observer's, +     * methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass an, +     * Observable (<code>resumeSequence</code>) to <code>onErrorResumeNext</code>, if the original, +     * because no Observable necessarily invokes <code>onError</code>, the Observer may never know, +     *            a function that returns an Observable that will take over if the source Observable, +     *            encounters an error, +     * @return the source Observable, with its behavior modified as described, +     * Instruct an Observable to emit a particular item to its Observer's <code>onNext</code>, +     * <code>onError</code> method, and then quits without invoking any more of its Observer's, +     * methods. The <code>onErrorReturn</code> method changes this behavior. If you pass a function, +     * (<code>resumeFunction</code>) to <code>onErrorReturn</code>, if the source Observable, +     * encounters an error, instead of invoking its Observer's <code>onError</code> method, it will, +     * instead pass the return value of <code>resumeFunction</code> to the Observer's, +     * @return the source Observable, with its behavior modified as described, +     * has an <code>inject</code> method that does a similar operation on lists.]