[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAmb;, +import rx.operators.OperatorSerialize;, +import rx.operators.OperatorSkipWhile;, +    public final Observable<T> serialize() {, +        return lift(new OperatorSerialize<T>());, +    }, +    , +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAmb;, +import rx.operators.OperatorSerialize;, +import rx.operators.OperatorSkipWhile;, +    public final Observable<T> serialize() {, +        return lift(new OperatorSerialize<T>());, +    }, +    , +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +package rx.observers;, +, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +import rx.Observer;, +, +public class SerializedObserver<T> implements Observer<T> {, +, +    private final AtomicReference<State> state = new AtomicReference<State>(State.createNew());, +    private final Observer<T> s;, +, +    public SerializedObserver(Observer<T> s) {, +        this.s = s;, +    }, +, +    @Override, +    public void onCompleted() {, +        State current = null;, +        State newState = null;, +        do {, +            current = state.get();, +            if (current.isTerminated()) {, +                // already received terminal state, +                return;, +            }, +            newState = current.complete();, +        } while (!state.compareAndSet(current, newState));, +        if (newState.count == 0) {, +            s.onCompleted();, +        }, +    }, +, +    @Override, +    public void onError(Throwable e) {, +        State current = null;, +        State newState = null;, +        do {, +            current = state.get();, +            if (current.isTerminated()) {, +                // already received terminal state, +                return;, +            }, +            newState = current.error(e);, +        } while (!state.compareAndSet(current, newState));, +        if (newState.count == 0) {, +            s.onError(e);, +        }, +    }, +, +    @SuppressWarnings("unchecked"), +    @Override, +    public void onNext(T t) {, +        State current = null;, +        State newState = null;, +        do {, +            current = state.get();, +            if (current.isTerminated()) {, +                // already received terminal state, +                return;, +            }, +            newState = current.increment(t);, +        } while (!state.compareAndSet(current, newState));, +, +        if (newState.count == 1) {, +            // this thread wins and will emit then drain queue if it concurrently gets added to, +            try {, +                s.onNext(t);, +            } finally {, +                // decrement after finishing, +                do {, +                    current = state.get();, +                    newState = current.decrement();, +                } while (!state.compareAndSet(current, newState));, +            }, +, +            // drain queue if exists, +            // we do "if" instead of "while" so we don't starve one thread, +            if (newState.queue.length > 0) {, +                Object[] items = newState.queue;, +                for (int i = 0; i < items.length; i++) {, +                    s.onNext((T) items[i]);, +                }]