[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.CheckReturnValue;, +        b.next(t);, +        b.error(t);, +        b.complete();, +        ReplayBuffer<T> b = buffer;, +        if (b.isDone()) {, +            return b.getError();, +        ReplayBuffer<T> b = buffer;, +        return b.isDone() && b.getError() == null;, +        ReplayBuffer<T> b = buffer;, +        return b.isDone() && b.getError() != null;, +        void next(T value);, +        void error(Throwable ex);, +, +        void complete();, +        boolean isDone();, +, +        Throwable getError();, +        long emitted;, +, +        final List<T> buffer;, +        Throwable error;, +            this.buffer = new ArrayList<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));, +        public void next(T value) {, +        public void error(Throwable ex) {, +            error = ex;, +        public void complete() {, +            done = true;, +        }, +, +        @Override, +            if (s == 0) {, +            return buffer.get(s - 1);, +            List<T> b = buffer;, +                array[i] = b.get(i);, +            final List<T> b = buffer;, +            long e = rs.emitted;, +                while (e != r) {, +                    boolean d = done;, +                    int s = size;, +                    if (d && index == s) {, +                        Throwable ex = error;, +                        if (ex == null) {, +                            a.onComplete();, +                        } else {, +                            a.onError(ex);, +                        }, +                    if (index == s) {, +                    a.onNext(b.get(index));, +, +                    e++;, +                if (e == r) {, +                    if (rs.cancelled) {, +                        rs.index = null;, +                        return;, +, +                    boolean d = done;, +                    int s = size;, +, +                    if (d && index == s) {, +                        rs.index = null;, +                        rs.cancelled = true;, +                        Throwable ex = error;, +                        if (ex == null) {, +                            a.onComplete();, +                        } else {, +                            a.onError(ex);, +                        return;, +                    }, +                rs.emitted = e;, +            return size;, +, +        @Override, +        public boolean isDone() {, +            return done;, +, +        @Override, +        public Throwable getError() {, +            return error;, +        volatile Node<T> head;, +        Node<T> tail;, +        Throwable error;, +            Node<T> h = new Node<T>(null);, +                Node<T> h = head;, +        public void next(T value) {, +            Node<T> n = new Node<T>(value);, +            Node<T> t = tail;, +        public void error(Throwable ex) {, +            error = ex;, +        public void complete() {, +            done = true;, +        }, +, +        @Override, +        public boolean isDone() {, +            return done;, +        }]