[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWindow;, +import rx.util.Closing;, +import rx.util.Opening;, + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava, + * Wiki</a>, +    //TODO use a consistent parameter naming scheme (for example: for all operators that modify a source Observable, the parameter representing that source Observable should have the same name, e.g. "source" -- currently such parameters are named any of "sequence", "that", "source", "items", or "observable"), +    private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, +    private final Func1<Observer<T>, Subscription> onSubscribe;, +     * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you, +     *            {@link Func1} to be executed when {@link #subscribe(Observer)} is called., +    protected Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +    protected Observable() {, +        this(null);, +        //TODO should this be made private to prevent it? It really serves no good purpose and only confuses things. Unit tests are incorrectly using it today, +    }, +    public Subscription subscribe(Observer<T> observer) {, +        Func1<Observer<T>, Subscription> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);, +                Subscription s = onSubscribeFunction.call(observer);, +                subscription.wrap(onSubscribeFunction.call(new SafeObserver<T>(subscription, observer)));, +    public Subscription subscribe(Observer<T> observer, Scheduler scheduler) {, +    private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {, +    public Subscription subscribe(final Action1<T> onNext) {, +    public Subscription subscribe(final Action1<T> onNext, Scheduler scheduler) {, +    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError) {, +    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, Scheduler scheduler) {, +    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onComplete) {, +    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onComplete, Scheduler scheduler) {, +            super(new Func1<Observer<T>, Subscription>() {, +                public Subscription call(Observer<T> t1) {, +            super(new Func1<Observer<T>, Subscription>() {, +                public Subscription call(Observer<T> observer) {, +    public static <T> Observable<T> create(Func1<Observer<T>, Subscription> func) {, +    public static <T> Observable<T> from(Iterable<T> iterable) {, +    public static <T> Observable<T> defer(Func0<Observable<T>> observableFactory) {, +    public static <T> Observable<T> merge(List<Observable<T>> source) {, +    public static <T> Observable<T> merge(Observable<Observable<T>> source) {, +    public static <T> Observable<T> merge(Observable<T>... source) {, +    public static <T> Observable<T> concat(Observable<T>... source) {, +    public static <T> Observable<T> mergeDelayError(List<Observable<T>> source) {, +    public static <T> Observable<T> mergeDelayError(Observable<Observable<T>> source) {, +    public static <T> Observable<T> mergeDelayError(Observable<T>... source) {, +    public static <T> Observable<T> switchDo(Observable<Observable<T>> sequenceOfSequences) {, +        // TODO should this static remain? I have left it because it is an Observable<Observable>, +     * On an Observable that emits Observables, creates a single Observable that, +     * @throws ClassCastException, +     *             if sequence not of type {@code Observable<Observable<T>}, +    @SuppressWarnings("unchecked"), +    public Observable<T> switchDo() {, +        // TODO can we come up with a better name than this? It should be 'switch' but that is reserved., +        // Perhaps 'switchOnNext'?, +        return create(OperationSwitch.switchDo((Observable<Observable<T>>) this));, +    public static <T> Observable<T> synchronize(Observable<T> observable) {, +    public static <T> Observable<T> from(Future<T> future) {, +    public static <T> Observable<T> from(Future<T> future, Scheduler scheduler) {, +    public static <T> Observable<T> from(Future<T> future, long timeout, TimeUnit unit) {, +     * @param w0, +     * @param w1, +     * @param reduceFunction, +     *            a function that, when applied to a pair of items, each emitted by one of the two, +     *            source Observables, results in an item that will be emitted by the resulting, +     *            Observable, +    public static <R, T0, T1> Observable<R> zip(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> reduceFunction) {, +        return create(OperationZip.zip(w0, w1, reduceFunction));, +    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second) {, +    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Func2<T, T, Boolean> equality) {, +     * @param w0, +     * @param w1, +     *            another source Observable, +     * @param w2, +     * @param function, +    public static <R, T0, T1, T2> Observable<R> zip(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> function) {, +        return create(OperationZip.zip(w0, w1, w2, function));, +     * @param w0, +     * @param w1, +     *            another source Observable, +     * @param w2, +     * @param w3, +     * @param reduceFunction, +    public static <R, T0, T1, T2, T3> Observable<R> zip(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> reduceFunction) {, +        return create(OperationZip.zip(w0, w1, w2, w3, reduceFunction));, +     * @param w0, +     * @param w1, +    public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));, +    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));, +    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));, +     * emitted and replaced with a new buffer when the Observable produced by the specified {@link Func0} produces a {@link rx.util.Closing} object. The * {@link Func0} will then, +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +     *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link rx.util.Closing} object., +    public Observable<List<T>> buffer(Func0<Observable<Closing>> bufferClosingSelector) {, +     * Observable produces a {@link rx.util.Opening} object. Additionally the {@link Func0} argument, +     * is used to create an Observable which produces {@link rx.util.Closing} objects. When this, +     *            The {@link Observable} which, when it produces a {@link rx.util.Opening} object, will cause, +     *            When this {@link Observable} produces a {@link rx.util.Closing} object, the associated buffer, +    public Observable<List<T>> buffer(Observable<Opening> bufferOpenings, Func1<Opening, Observable<Closing>> bufferClosingSelector) {, +     * Creates an Observable which produces windows of collected values. This Observable produces connected, +     * non-overlapping windows. The current window is emitted and replaced with a new window when the]