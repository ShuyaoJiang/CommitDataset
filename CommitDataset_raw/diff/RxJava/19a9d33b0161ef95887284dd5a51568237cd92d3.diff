[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Closing](closings: () => Observable[_ <: Closing]) : Observable[Seq[T]] = {, +    val f: Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Closing](f), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def buffer[Closing](closings: () => Observable[_ <: Closing]) : Observable[Seq[T]] = {, +    val f: Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Closing](f), +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * behavior. If you pass a function ({@code resumeFunction}) to an Observable's {@code onErrorReturn}, +     * method, if the original Observable encounters an error, instead of invoking its Observer's, +     * Allows inserting onNext events into a stream when onError events are received and continuing the original, +     * sequence instead of terminating. Thus it allows a sequence with multiple onError events., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorFlatMap.png">, +     *, +     * @param resumeFunction, +     *            a function that accepts an {@link OnErrorThrowable} representing the Throwable issued by the, +     *            source Observable, and returns an Observable that issues items that will be emitted in place, +     *            of the error, +     * @return the original Observable, with appropriately modified behavior, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onerrorflatmap">RxJava Wiki: onErrorFlatMap()</a>, +     * Instruct an Observable to pass control to another Observable rather than invoking, +     * {@link Observer#onError onError} if it encounters an {@link java.lang.Exception}., +     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}, +     * or {@link java.lang.Error} but lets those continue through., +     * this behavior. If you pass another Observable ({@code resumeSequence}) to an Observable's, +     * {@code onExceptionResumeNext} method, if the original Observable encounters an exception, instead of, +     * invoking its Observer's {@code onError} method, it will instead relinquish control to, +     * {@code resumeSequence} which will invoke the Observer's {@link Observer#onNext onNext} method if it is]