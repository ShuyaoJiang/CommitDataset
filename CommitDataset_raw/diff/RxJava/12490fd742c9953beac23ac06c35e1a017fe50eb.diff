[+++ b/DESIGN.md, +Unlike RxJava 1.x, 2.x base classes are to be abstract, stateless and generally no longer wrap an `OnSubscribe` callback - this saves allocation in assembly time without limiting the expressiveness. Operator methods and standard factories still live as final on the base classes., +, +Instead of the indirection of an `OnSubscribe` and `lift`, operators are to be implemented by extending the base classes. For example, the `map`, +operator will look like this:, +public final class FlowableMap<T, R> extends Flowable<R> {, +    final Flowable<? extends T> source;, +    final Function<? super T, ? extends R> mapper;, +    public FlowableMap(Flowable<? extends T> source, Function<? super T, ? extends R> mapper) {, +        this.source = source;, +        this.mapper = mapper;, +    }, +    @Override, +    protected void subscribeActual(Subscriber<? super R> subscriber) {, +        source.subscribe(new FlowableMapSubscriber<T, R>(subscriber, mapper));, +    }, +    , +    static final class FlowableMapSubscriber<T, R> implements Subscriber<T>, Subscription {, +        // ..., +    }, +}, +``` , +, +Since Java still doesn't have extension methods, "adding" more operators can only happen through helper methods such as `lift(C -> C)` and `compose(R -> P)` where `C` is the default consumer type (i.e., `rs.Subscriber`), `R` is the base type (i.e., `Flowable`) and `P` is the base interface (i.e., `rs.Publisher`). As before, the library itself may gain or lose standard operators and/or overloads through the same community process., +, +In concert, `create(OnSubscribe)` will not be available; standard operators extend the base types directly. The conversion of other RS-based libraries will happen through the `Flowable.wrap(Publisher<T>)` static method. , +, +(*The unfortunate effect of `create` in 1.x was the ignorance of the Observable contract and beginner's first choice as an entry point. We can't eliminate this path since `rs.Publisher` is a single method functional interface that can be implemented just as badly.*), +, +Therefore, new standard factory methods will try to address the common entry point requirements. , +, +The `Flowable` will contain the following `create` methods:, +, +   - `create(SyncGenerator<T, S>)`: safe, synchronous generation of signals, one-by-one, +   - `create(AsyncOnSubscribe<T, S>)`: batch-create signals based on request patterns, +   - `create(Consumer<? super FlowEmitter<T>>)`: relay multiple values or error from multi-valued reactive-sources (i.e., button-clicks) while also give flow control options right there (buffer, drop, error, etc.)., +   - `createSingle(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e., addListener callbacks), +   - `createEmpty(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources, +   , +The `Observable` will contain the following `create` methods:, +, +   - `create(SyncGenerator<T, S>)`: safe, synchronous generation of signals, one-by-one, +   - `create(Consumer<? super FlowEmitter<T>>)`: relay multiple values or error from multi-valued reactive-sources (i.e., button-clicks) while also give flow control options right there (buffer, drop, error, etc.)., +   - `createSingle(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e., addListener callbacks), +   - `createEmpty(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources, +, +The `Single` will contain the following `create` method:, +, +   - `create(Consumer<? super SingleEmitter<T>>)`: relay a single value or error from other reactive sources (i.e., addListener callbacks), +   , +The `Completable` will contain the following `create` method:, +, +   - `create(Consumer<? super CompletionEmitter>)`: signal a completion or error from valueless reactive sources, +, +, +The first two `create` methods take an implementation of an interface which provides state and the generator methods:, +, +```java, +interface SyncGenerator<T, S> {, +, +    S createState();, +    , +    S generate(S state, Observer<T> output);, +    , +    void disposeState(S state);, +}, +, +interface AsyncGenerator<T, S> {, +, +    S createState();, +    , +    S generate(S state, long requested, Observer<Observable<T>> output);, +    , +    void disposeState(S state);, +}, +```, +, +These latter three `create` methods will provide the following interaction interfaces to the `java.util.function.Consumer`:, +, +```java, +interface SingleEmitter<T> {, +, +    complete(T value);, +    , +    fail(Throwable error);, +    , +    stop();, +    , +    setDisposable(Disposable d);, +    , +}, +, +interface FlowEmitter<T> {, +, +    void next(T value);, +   , +    void fail(Throwable error);, +   , +    void complete();, +   ]