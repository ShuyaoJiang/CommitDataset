[+++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import java.util.concurrent.locks.StampedLock;, +        final StampedLock lock;, +        , +            this.lock = new StampedLock();, +            long stamp = lock.writeLock();, +            try {, +                lazySet(o);, +            } finally {, +                lock.unlockWrite(stamp);, +                bs.emitNext(o, index);, +                bs.emitNext(o, index);, +                , +                State<T> s = state;, +                StampedLock lock = s.lock;, +                , +                long stamp = lock.tryOptimisticRead();, +                index = s.index;, +                o = s.get();, +                if (!lock.validate(stamp)) {, +                    stamp = lock.readLock();, +                    try {, +                        index = s.index;, +                        o = s.get();, +                    } finally {, +                        lock.unlockRead(stamp);, +                }, +                , +                    if (index == stateIndex) {, +                        return;, +                    }, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import java.util.concurrent.locks.StampedLock;, +        final StampedLock lock;, +        , +            this.lock = new StampedLock();, +            long stamp = lock.writeLock();, +            try {, +                lazySet(o);, +            } finally {, +                lock.unlockWrite(stamp);, +                bs.emitNext(o, index);, +                bs.emitNext(o, index);, +                , +                State<T> s = state;, +                StampedLock lock = s.lock;, +                , +                long stamp = lock.tryOptimisticRead();, +                index = s.index;, +                o = s.get();, +                if (!lock.validate(stamp)) {, +                    stamp = lock.readLock();, +                    try {, +                        index = s.index;, +                        o = s.get();, +                    } finally {, +                        lock.unlockRead(stamp);, +                }, +                , +                    if (index == stateIndex) {, +                        return;, +                    }, +++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +    static final class TimedNode<T> extends AtomicReference<TimedNode<T>> {, +        /** */, +        private static final long serialVersionUID = 6404226426336033100L;, +        , +        final T value;, +        final long time;, +        , +        public TimedNode(T value, long time) {, +            this.value = value;, +            this.time = time;, +        }, +    }, +    , +    static final class SizeBoundReplayBuffer<T> implements ReplayBuffer<T> {, +        final int maxSize;, +        public SizeBoundReplayBuffer(int maxSize) {, +            this.maxSize = maxSize;, +, +        void trim() {, +            if (size > maxSize) {, +                Node<Object> h = head;, +                head = h.get();, +            }, +        }, +        , +            Object o = value;, +            Object o = notificationLite;, +                return (T)prev.value;, +                    array[i] = (T)next.value;, +                    Object o = n.value;, +    static final class SizeAndTimeBoundReplayBuffer<T> implements ReplayBuffer<T> {, +        int size;, +        , +        volatile TimedNode<Object> head;, +        , +        TimedNode<Object> tail;, +        ]