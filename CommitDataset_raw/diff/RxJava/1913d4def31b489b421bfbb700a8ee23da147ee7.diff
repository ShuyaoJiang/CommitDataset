[+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorNext.java, +                final NextIterator<T> nextIterator = new NextIterator<T>(nextObserver);, +, +                items.materialize().subscribe(nextObserver);, +, +                return nextIterator;, +        private final NextObserver<? extends T> observer;, +        private NextIterator(NextObserver<? extends T> observer) {, +        , +        // in tests, set the waiting flag without blocking for the next value to , +        // allow lockstepping instead of multi-threading, +        /**, +         * In tests, set the waiting flag without blocking for the next value to , +         * allow lockstepping instead of multi-threading, +         * @param value use 1 to enter into the waiting state, +         */, +        void setWaiting(int value) {, +            observer.setWaiting(value);, +        }, +        , +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorNext.java, +                final NextIterator<T> nextIterator = new NextIterator<T>(nextObserver);, +, +                items.materialize().subscribe(nextObserver);, +, +                return nextIterator;, +        private final NextObserver<? extends T> observer;, +        private NextIterator(NextObserver<? extends T> observer) {, +        , +        // in tests, set the waiting flag without blocking for the next value to , +        // allow lockstepping instead of multi-threading, +        /**, +         * In tests, set the waiting flag without blocking for the next value to , +         * allow lockstepping instead of multi-threading, +         * @param value use 1 to enter into the waiting state, +         */, +        void setWaiting(int value) {, +            observer.setWaiting(value);, +        }, +        , +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorToObservableList.java, +import java.util.Collections;, +            private boolean completed = false;, +                    completed = true;, +                    o.onNext(Collections.unmodifiableList(list));, +                if (!completed) {, +            }, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorNext.java, +                final NextIterator<T> nextIterator = new NextIterator<T>(nextObserver);, +, +                items.materialize().subscribe(nextObserver);, +, +                return nextIterator;, +        private final NextObserver<? extends T> observer;, +        private NextIterator(NextObserver<? extends T> observer) {, +        , +        // in tests, set the waiting flag without blocking for the next value to , +        // allow lockstepping instead of multi-threading, +        /**, +         * In tests, set the waiting flag without blocking for the next value to , +         * allow lockstepping instead of multi-threading, +         * @param value use 1 to enter into the waiting state, +         */, +        void setWaiting(int value) {, +            observer.setWaiting(value);, +        }, +        , +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorToObservableList.java, +import java.util.Collections;, +            private boolean completed = false;, +                    completed = true;, +                    o.onNext(Collections.unmodifiableList(list));, +                if (!completed) {, +            }, +++ b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorNextTest.java, +        PublishSubject<Long> ps = PublishSubject.create();, +        BlockingObservable<Long> source = ps.take(10).toBlocking();, +            for (long i = 0; i < 9; i++) {, +                // hasNext has to set the waiting to true, otherwise, all onNext will be skipped, +                it.setWaiting(1);, +                ps.onNext(i);, +                Assert.assertEquals(j + "th iteration", Long.valueOf(i), it.next());, +            it.setWaiting(1);, +            ps.onNext(9L);, +, +            Assert.assertEquals(j + "th iteration", false, it.hasNext());]