[+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java, +import rx.util.functions.Func1;, +import rx.util.functions.Functions;, +    public static <T, U> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {, +        return new DistinctUntilChanged<T, U>(source, keySelector);, +    /**, +     * Returns an Observable that emits all sequentially distinct items emitted by the source, +     * @param source, +     *            The source Observable to emit the sequentially distinct items for., +     * @return A subscription function for creating the target Observable., +     */, +    public static <T> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source) {, +        return new DistinctUntilChanged<T, T>(source, Functions.<T>identity());, +    }, +    private static class DistinctUntilChanged<T, U> implements OnSubscribeFunc<T> {, +        private final Observable<? extends T> source;, +        private final Func1<? super T, ? extends U> keySelector;, +        , +        private DistinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {, +            this.keySelector = keySelector;, +                private U lastEmittedKey;, +                private boolean hasEmitted;, +                    U lastKey = lastEmittedKey;, +                    try {, +                        U nextKey = keySelector.call(next);, +                        lastEmittedKey = nextKey;, +                        if (!hasEmitted) {, +                            hasEmitted = true;, +                        } else {, +                            if (lastKey == null) {, +                                if (nextKey != null) {, +                            } else {, +                                if (!lastKey.equals(nextKey)) {, +                        }, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +                    }, +                }, +        // nulls lead to exceptions, +        final Func1<String, String> TO_UPPER_WITH_EXCEPTION = new Func1<String, String>() {, +            @Override, +            public String call(String s) {, +                return s.toUpperCase();, +            }, +        };, +        , +        public void testDistinctUntilChangedOfNoneWithKeySelector() {, +            Observable<String> src = empty();, +            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);, +, +            verify(w, never()).onNext(anyString());, +            verify(w, never()).onError(any(Throwable.class));, +            verify(w, times(1)).onCompleted();, +        }, +, +        @Test, +        public void testDistinctUntilChangedOfNormalSourceWithKeySelector() {, +            Observable<String> src = from("a", "b", "c", "C", "c", "B", "b", "a", "e");, +            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);, +, +            InOrder inOrder = inOrder(w); , +            inOrder.verify(w, times(1)).onNext("a");, +            inOrder.verify(w, times(1)).onNext("b");, +            inOrder.verify(w, times(1)).onNext("c");, +            inOrder.verify(w, times(1)).onNext("B");, +            inOrder.verify(w, times(1)).onNext("a");, +            inOrder.verify(w, times(1)).onNext("e");, +            inOrder.verify(w, times(1)).onCompleted();, +            inOrder.verify(w, never()).onNext(anyString());, +            verify(w, never()).onError(any(Throwable.class));, +        }, +, +        @Test, +, +        @Test, +        public void testDistinctUntilChangedOfSourceWithExceptionsFromKeySelector() {, +            Observable<String> src = from("a", "b", null, "c");, +            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);, +, +            InOrder inOrder = inOrder(w); , +            inOrder.verify(w, times(1)).onNext("a");, +            inOrder.verify(w, times(1)).onNext("b");, +            verify(w, times(1)).onError(any(NullPointerException.class));, +            inOrder.verify(w, never()).onNext(anyString());, +            inOrder.verify(w, never()).onCompleted();, +        }]