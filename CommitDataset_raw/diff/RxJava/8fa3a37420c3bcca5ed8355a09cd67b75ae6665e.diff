[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def publish: ConnectableObservable[T] = {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def publish: ConnectableObservable[T] = {, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",, +      "startWith(" + _ + ")" -> "[unnecessary because we can just use `++` instead]", +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def publish: ConnectableObservable[T] = {, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",, +      "startWith(" + _ + ")" -> "[unnecessary because we can just use `++` instead]", +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.Remover;, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.ScheduledAction;, +    /** Manages a fixed number of workers. */, +    static final class FixedSchedulerPool {, +        final int cores;, +        final PoolWorker[] eventLoops;, +        long n;, +        FixedSchedulerPool() {, +            this.cores = Runtime.getRuntime().availableProcessors();, +            this.eventLoops = new PoolWorker[cores];, +                this.eventLoops[i] = new PoolWorker(factory);, +        public PoolWorker getEventLoop() {, +            // simple round robin, improvements to come, +    }, +    final FixedSchedulerPool pool;, +    , +    /**, +     * Create a scheduler with pool size equal to the available processor, +     * count and using least-recent worker selection policy., +     */, +    EventLoopsScheduler() {, +        pool = new FixedSchedulerPool();, +        return new EventLoopWorker(pool.getEventLoop());, +    private static class EventLoopWorker extends Scheduler.Worker {, +        private final PoolWorker poolWorker;, +        EventLoopWorker(PoolWorker poolWorker) {, +            this.poolWorker = poolWorker;, +            return schedule(action, 0, null);, +            ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);, +            innerSubscription.add(s);, +            s.addParent(innerSubscription);, +            return s;, +        }, +    private static final class PoolWorker extends NewThreadScheduler.NewThreadWorker {, +        PoolWorker(ThreadFactory threadFactory) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def publish: ConnectableObservable[T] = {, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",, +      "startWith(" + _ + ")" -> "[unnecessary because we can just use `++` instead]", +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.Remover;, +import rx.schedulers.NewThreadScheduler.NewThreadWorker.ScheduledAction;, +    /** Manages a fixed number of workers. */, +    static final class FixedSchedulerPool {, +        final int cores;, +        final PoolWorker[] eventLoops;, +        long n;, +        FixedSchedulerPool() {, +            this.cores = Runtime.getRuntime().availableProcessors();, +            this.eventLoops = new PoolWorker[cores];, +                this.eventLoops[i] = new PoolWorker(factory);, +        public PoolWorker getEventLoop() {, +            // simple round robin, improvements to come, +    }, +    final FixedSchedulerPool pool;, +    , +    /**, +     * Create a scheduler with pool size equal to the available processor, +     * count and using least-recent worker selection policy., +     */, +    EventLoopsScheduler() {, +        pool = new FixedSchedulerPool();, +        return new EventLoopWorker(pool.getEventLoop());, +    private static class EventLoopWorker extends Scheduler.Worker {, +        private final PoolWorker poolWorker;, +        EventLoopWorker(PoolWorker poolWorker) {, +            this.poolWorker = poolWorker;, +            return schedule(action, 0, null);, +            ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);, +            innerSubscription.add(s);, +            s.addParent(innerSubscription);, +            return s;, +        }, +    private static final class PoolWorker extends NewThreadScheduler.NewThreadWorker {, +        PoolWorker(ThreadFactory threadFactory) {, +++ b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java, +import java.util.concurrent.Future;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.atomic.AtomicBoolean;, +        return new NewThreadWorker(THREAD_FACTORY);, +    /* package */static class NewThreadWorker extends Scheduler.Worker implements Subscription {]