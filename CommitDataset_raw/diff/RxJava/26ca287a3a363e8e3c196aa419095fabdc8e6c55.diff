[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +    rx.Observable/flatMap, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +    rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +              [:a {:k :a :v 3}], +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +    rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +              [:a {:k :a :v 3}], +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Compose Observables together with a function., +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {, +     * Transformer function for `compose`, +    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +    rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +              [:a {:k :a :v 3}], +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Compose Observables together with a function., +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {, +     * Transformer function for `compose`, +    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    // TODO remove this timeout and logging before final release of 0.20, +                    Notification<? extends T> n = notifications.poll(10000, TimeUnit.MILLISECONDS);, +                    if(n == null) {, +                        System.err.println("Timed out waiting for value. File a bug at github.com/Netflix/RxJava");, +                        throw new RuntimeException("Timed out waiting for value. File a bug at github.com/Netflix/RxJava");, +                    } else {, +                        return n;, +                    }, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +                            filter first future, +    rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, +              [:a {:k :a :v 3}], +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Compose Observables together with a function., +     * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., +     * , +     * Lift should be used when creating an operator that acts on the underlying data. , +     * Compose should be used when acting on the observable itself, such as composing multiple operators., +     * , +     * @param transformer, +     * @return, +    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {, +     * Transformer function for `compose`, +    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {, +        return lift(new OperatorGroupBy<K, T>(keySelector));, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                    // TODO remove this timeout and logging before final release of 0.20, +                    Notification<? extends T> n = notifications.poll(10000, TimeUnit.MILLISECONDS);, +                    if(n == null) {, +                        System.err.println("Timed out waiting for value. File a bug at github.com/Netflix/RxJava");, +                        throw new RuntimeException("Timed out waiting for value. File a bug at github.com/Netflix/RxJava");, +                    } else {, +                        return n;, +                    }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java]