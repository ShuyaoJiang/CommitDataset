[+++ b/src/main/java/rx/Observable.java, +                    try {, +                        st.onError(e);, +                    }, +                } catch (Throwable e) {, +                    if (e instanceof OnErrorNotImplementedException) {, +                        throw (OnErrorNotImplementedException) e;, +                    }, +                    // if the lift function failed all we can do is pass the error to the final Subscriber, +                    // as we don't have the operator available to us, +++ b/src/main/java/rx/Observable.java, +                    try {, +                        st.onError(e);, +                    }, +                } catch (Throwable e) {, +                    if (e instanceof OnErrorNotImplementedException) {, +                        throw (OnErrorNotImplementedException) e;, +                    }, +                    // if the lift function failed all we can do is pass the error to the final Subscriber, +                    // as we don't have the operator available to us, +++ b/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java, +import rx.Observable.OnSubscribe;, +    @Test, +    public void testResumeNextWithFailedOnSubscribe() {, +        Subscription s = mock(Subscription.class);, +        Observable<String> testObservable = Observable.create(new OnSubscribe<String>() {, +, +            @Override, +            public void call(Subscriber<? super String> t1) {, +                throw new RuntimeException("force failure");, +            }, +            , +        });, +        Observable<String> resume = Observable.just("resume");, +        Observable<String> observable = testObservable.onErrorResumeNext(resume);, +, +        @SuppressWarnings("unchecked"), +        Observer<String> observer = mock(Observer.class);, +        observable.subscribe(observer);, +, +        verify(observer, Mockito.never()).onError(any(Throwable.class));, +        verify(observer, times(1)).onCompleted();, +        verify(observer, times(1)).onNext("resume");, +    }, +    , +    @Test, +    public void testResumeNextWithFailedOnSubscribeAsync() {, +        Subscription s = mock(Subscription.class);, +        Observable<String> testObservable = Observable.create(new OnSubscribe<String>() {, +, +            @Override, +            public void call(Subscriber<? super String> t1) {, +                throw new RuntimeException("force failure");, +            }, +            , +        });, +        Observable<String> resume = Observable.just("resume");, +        Observable<String> observable = testObservable.subscribeOn(Schedulers.io()).onErrorResumeNext(resume);, +, +        @SuppressWarnings("unchecked"), +        Observer<String> observer = mock(Observer.class);, +        TestSubscriber<String> ts = new TestSubscriber<String>(observer);, +        observable.subscribe(ts);, +, +        ts.awaitTerminalEvent();, +        , +        verify(observer, Mockito.never()).onError(any(Throwable.class));, +        verify(observer, times(1)).onCompleted();, +        verify(observer, times(1)).onNext("resume");, +    }, +]