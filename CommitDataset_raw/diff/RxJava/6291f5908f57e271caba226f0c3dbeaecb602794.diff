[+++ b/src/main/java/io/reactivex/Completable.java, +        return fromAction(Functions.futureAction(future));, +++ b/src/main/java/io/reactivex/Completable.java, +        return fromAction(Functions.futureAction(future));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.subscribers.flowable.*;, +        return error(Functions.justCallable(exception));, +        return new FlowableFromFuture<T>(future, 0L, null);, +        return fromFuture(future, timeout, unit).subscribeOn(scheduler);, +        return fromFuture(future).subscribeOn(scheduler);, +                FlowableInternalHelper.<T, Object>simpleGenerator(generator), , +                Functions.emptyConsumer());, +        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , +                Functions.emptyConsumer());, +        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , +                disposeState);, +        return fromPublisher(sources).toList().flatMap(FlowableInternalHelper.<T, R>zipIterable(zipper));, +        return buffer(boundary, Functions.<T>createArrayList(initialCapacity));, +        return map(Functions.castFunction(clazz));, +        return collect(Functions.justCallable(initialValue), collector);, +        return any(Functions.equalsWith(element));, +        return flatMap(FlowableInternalHelper.itemDelay(itemDelay));, +        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());, +        return distinct(keySelector, Functions.<K>createHashSet());, +                Functions.notificationOnNext(onNotification),, +                Functions.notificationOnError(onNotification),, +                Functions.notificationOnComplete(onNotification),, +        return doOnEach(, +                FlowableInternalHelper.subscriberOnNext(observer),, +                FlowableInternalHelper.subscriberOnError(observer),, +                FlowableInternalHelper.subscriberOnComplete(observer),, +                Functions.EMPTY_ACTION);, +        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate), , +                onTerminate, Functions.EMPTY_ACTION);, +        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);, +        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());, +        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);, +        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);, +        subscribe(s);, +        return s;, +            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {, +        return all(Functions.alwaysFalse());, +            BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {, +        return filter(Functions.isInstanceOf(clazz)).cast(clazz);, +        return onErrorResumeNext(Functions.justFunction(next));, +        return onErrorReturn(Functions.justFunction(value));, +        return new FlowableOnErrorNext<T>(this, Functions.justFunction(next), true);, +        return new FlowableRedo<T>(this, FlowableInternalHelper.repeatWhenHandler(handler));, +        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);, +        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);, +        return FlowableReplay.multicastSelector(, +                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);, +        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),, +                FlowableInternalHelper.replayFunction(selector, scheduler), +        );, +        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);, +        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),, +                FlowableInternalHelper.replayFunction(selector, scheduler));, +        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));, +        return new FlowableRedo<T>(this, FlowableInternalHelper.retryWhenHandler(handler));, +        return scanWith(Functions.justCallable(initialValue), accumulator);, +        if (count <= 0L) {, +        } , +        return subscribe(Functions.emptyConsumer(), RxJavaPlugins.errorConsumer(), , +                Functions.EMPTY_ACTION, FlowableInternalHelper.requestMax());, +        return subscribe(onNext, RxJavaPlugins.errorConsumer(), , +                Functions.EMPTY_ACTION, FlowableInternalHelper.requestMax());, +        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.requestMax());, +        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.requestMax());, +        return switchMap0(mapper, bufferSize, false);, +        return switchMap0(mapper, bufferSize, true);, +    }, +, +    <R> Flowable<R> switchMap0(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize, boolean delayError) {, +        return new FlowableSwitchMap<T, R>(this, mapper, bufferSize, delayError);, +        return map(Functions.<T>timestampWith(unit, scheduler));, +        return new FlowableToList<T, List<T>>(this, Functions.<T>createArrayList(capacityHint));, +        return collect(HashMapSupplier.<K, T>asCallable(), Functions.toMapKeySelector(keySelector));, +        return collect(HashMapSupplier.<K, V>asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));, +        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));, +        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));, +        return toSortedList(Functions.naturalComparator());, +        return toList().map(Functions.listSorter(comparator));, +        return toList(capacityHint).map(Functions.listSorter(comparator));, +        return toSortedList(Functions.naturalComparator(), capacityHint);, +++ b/src/main/java/io/reactivex/Completable.java, +        return fromAction(Functions.futureAction(future));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.subscribers.flowable.*;, +        return error(Functions.justCallable(exception));, +        return new FlowableFromFuture<T>(future, 0L, null);, +        return fromFuture(future, timeout, unit).subscribeOn(scheduler);, +        return fromFuture(future).subscribeOn(scheduler);, +                FlowableInternalHelper.<T, Object>simpleGenerator(generator), , +                Functions.emptyConsumer());, +        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , +                Functions.emptyConsumer());, +        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , +                disposeState);, +        return fromPublisher(sources).toList().flatMap(FlowableInternalHelper.<T, R>zipIterable(zipper));]