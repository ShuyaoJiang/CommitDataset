[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorBufferWithSingleObservable;, +import rx.operators.OperatorBufferWithSize;, +import rx.operators.OperatorBufferWithStartEndObservable;, +import rx.operators.OperatorBufferWithTime;, +        return lift(new OperatorBufferWithSingleObservable<T, TClosing>(bufferClosingSelector, 16));, +        return lift(new OperatorBufferWithSize<T>(count, count));, +        return lift(new OperatorBufferWithSize<T>(count, skip));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithStartEndObservable<T, TOpening, TClosing>(bufferOpenings, bufferClosingSelector));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, 16));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, initialCapacity));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorBufferWithSingleObservable;, +import rx.operators.OperatorBufferWithSize;, +import rx.operators.OperatorBufferWithStartEndObservable;, +import rx.operators.OperatorBufferWithTime;, +        return lift(new OperatorBufferWithSingleObservable<T, TClosing>(bufferClosingSelector, 16));, +        return lift(new OperatorBufferWithSize<T>(count, count));, +        return lift(new OperatorBufferWithSize<T>(count, skip));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithStartEndObservable<T, TOpening, TClosing>(bufferOpenings, bufferClosingSelector));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, 16));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, initialCapacity));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorBufferWithSingleObservable;, +import rx.operators.OperatorBufferWithSize;, +import rx.operators.OperatorBufferWithStartEndObservable;, +import rx.operators.OperatorBufferWithTime;, +        return lift(new OperatorBufferWithSingleObservable<T, TClosing>(bufferClosingSelector, 16));, +        return lift(new OperatorBufferWithSize<T>(count, count));, +        return lift(new OperatorBufferWithSize<T>(count, skip));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, count, scheduler));, +        return lift(new OperatorBufferWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, +        return lift(new OperatorBufferWithStartEndObservable<T, TOpening, TClosing>(bufferOpenings, bufferClosingSelector));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, 16));, +        return lift(new OperatorBufferWithSingleObservable<T, B>(boundary, initialCapacity));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorBufferWithSingleObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +package rx.operators;, +, +import java.util.ArrayList;, +import java.util.List;, +import rx.Observable;, +import rx.Observable.Operator;, +import rx.Observer;, +import rx.Subscriber;, +import rx.functions.Func0;, +import rx.observers.SerializedSubscriber;, +import rx.observers.Subscribers;, +, +/**, + * This operation takes, + * values from the specified {@link Observable} source and stores them in a buffer until the, + * {@link Observable} constructed using the {@link Func0} argument, produces a value. The buffer is then, + * emitted, and a new buffer is created to replace it. A new {@link Observable} will be constructed using, + * the provided {@link Func0} object, which will determine when this new buffer is emitted. When the source, + * {@link Observable} completes or produces an error, the current buffer is emitted, and the event is, + * propagated to all subscribed {@link Observer}s., + * <p>, + * Note that this operation only produces <strong>non-overlapping chunks</strong>. At all times there is, + * exactly one buffer actively storing values., + * </p>, + * , + * @param <T> the buffered value type, + */, +, +public final class OperatorBufferWithSingleObservable<T, TClosing> implements Operator<List<T>, T> {, +    final Func0<? extends Observable<? extends TClosing>> bufferClosingSelector;, +    final int initialCapacity;]