[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import java.util.concurrent.CountDownLatch, +import java.util.concurrent.TimeUnit, +  @Test def schedulerExample1(): Unit = {, +    val latch = new CountDownLatch(1), +    val worker = IOScheduler().createWorker, +    worker.schedule {, +      println("Hello from Scheduler"), +      latch.countDown(), +    }, +    latch.await(5, TimeUnit.SECONDS), +  }, +, +  @Test def schedulerExample2(): Unit = {, +    val latch = new CountDownLatch(1), +    val worker = IOScheduler().createWorker, +    worker.schedule(1 seconds) {, +      println("Hello from Scheduler after 1 second"), +      latch.countDown(), +    }, +    latch.await(5, TimeUnit.SECONDS), +  }, +, +  @Test def schedulerExample3(): Unit = {, +    val worker = IOScheduler().createWorker, +    var no = 1, +    val subscription = worker.schedulePeriodically(initialDelay = 1 seconds, period = 100 millis) {, +      println(s"Hello(${no}) from Scheduler"), +      no += 1, +    }, +    TimeUnit.SECONDS.sleep(2), +    subscription.unsubscribe(), +  }, +, +  @Test def schedulerExample4(): Unit = {, +    val worker = IOScheduler().createWorker, +    var no = 1, +    def hello: Unit = {, +      println(s"Hello(${no}) from Scheduler"), +      no += 1, +      worker.schedule(100 millis)(hello), +    }, +    val subscription = worker.schedule(1 seconds)(hello), +    TimeUnit.SECONDS.sleep(2), +    subscription.unsubscribe(), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import java.util.concurrent.CountDownLatch, +import java.util.concurrent.TimeUnit, +  @Test def schedulerExample1(): Unit = {, +    val latch = new CountDownLatch(1), +    val worker = IOScheduler().createWorker, +    worker.schedule {, +      println("Hello from Scheduler"), +      latch.countDown(), +    }, +    latch.await(5, TimeUnit.SECONDS), +  }, +, +  @Test def schedulerExample2(): Unit = {, +    val latch = new CountDownLatch(1), +    val worker = IOScheduler().createWorker, +    worker.schedule(1 seconds) {, +      println("Hello from Scheduler after 1 second"), +      latch.countDown(), +    }, +    latch.await(5, TimeUnit.SECONDS), +  }, +, +  @Test def schedulerExample3(): Unit = {, +    val worker = IOScheduler().createWorker, +    var no = 1, +    val subscription = worker.schedulePeriodically(initialDelay = 1 seconds, period = 100 millis) {, +      println(s"Hello(${no}) from Scheduler"), +      no += 1, +    }, +    TimeUnit.SECONDS.sleep(2), +    subscription.unsubscribe(), +  }, +, +  @Test def schedulerExample4(): Unit = {, +    val worker = IOScheduler().createWorker, +    var no = 1, +    def hello: Unit = {, +      println(s"Hello(${no}) from Scheduler"), +      no += 1, +      worker.schedule(100 millis)(hello), +    }, +    val subscription = worker.schedule(1 seconds)(hello), +    TimeUnit.SECONDS.sleep(2), +    subscription.unsubscribe(), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +   * This defaults to `Runtime.getRuntime().availableProcessors()` but can be overridden for use cases such as scheduling work on a computer cluster., +  def parallelism: Int =  asJavaScheduler.parallelism(), +  /**, +   * Retrieve or create a new [[rx.lang.scala.Worker]] that represents serial execution of actions., +   * <p>]