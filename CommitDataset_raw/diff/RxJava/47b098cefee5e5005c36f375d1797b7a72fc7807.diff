[+++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // the status of the current stream, +        volatile boolean finished = false;, +, +        @SuppressWarnings("unused"), +        , +        , +            if (isUnsubscribed()) {, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            // polling thread should skip any onNext still in the queue, +                long produced = 0;, +                long r = requested;, +                while (!child.isUnsubscribed()) {, +                    Throwable error;, +                    if (finished) {, +                        if ((error = this.error) != null) {, +                            // errors shortcut the queue so , +                            // release the elements in the queue for gc, +                            queue.clear();, +                        } else, +                        if (queue.isEmpty()) {, +                    }, +                    if (r > 0) {, +                        if (o != null) {, +                            child.onNext(on.getValue(o));, +                            r--;, +                            produced++;, +                        } else {, +                            break;, +                if (produced > 0 && requested != Long.MAX_VALUE) {, +                    REQUESTED.addAndGet(this, -produced);, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +        // the status of the current stream, +        volatile boolean finished = false;, +, +        @SuppressWarnings("unused"), +        , +        , +            if (isUnsubscribed()) {, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            if (isUnsubscribed() || finished) {, +            finished = true;, +            // polling thread should skip any onNext still in the queue, +                long produced = 0;, +                long r = requested;, +                while (!child.isUnsubscribed()) {, +                    Throwable error;, +                    if (finished) {, +                        if ((error = this.error) != null) {, +                            // errors shortcut the queue so , +                            // release the elements in the queue for gc, +                            queue.clear();, +                        } else, +                        if (queue.isEmpty()) {, +                    }, +                    if (r > 0) {, +                        if (o != null) {, +                            child.onNext(on.getValue(o));, +                            r--;, +                            produced++;, +                        } else {, +                            break;, +                if (produced > 0 && requested != Long.MAX_VALUE) {, +                    REQUESTED.addAndGet(this, -produced);, +++ b/src/perf/java/rx/operators/OperatorObserveOnPerf.java, +    , +    @Benchmark, +    public void observeOnComputationSubscribedOnComputation(Input input) throws InterruptedException {, +        LatchedObserver<Integer> o = input.newLatchedObserver();, +        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).subscribe(o);, +        o.latch.await();, +    }, +, +    @Benchmark, +    public void observeOnNewThreadSubscribedOnComputation(Input input) throws InterruptedException {, +        LatchedObserver<Integer> o = input.newLatchedObserver();, +        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.newThread()).subscribe(o);, +        o.latch.await();, +    }, +, +    @Benchmark, +    public void observeOnImmediateSubscribedOnComputation(Input input) throws InterruptedException {, +        LatchedObserver<Integer> o = input.newLatchedObserver();, +        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.immediate()).subscribe(o);, +        o.latch.await();, +    }]