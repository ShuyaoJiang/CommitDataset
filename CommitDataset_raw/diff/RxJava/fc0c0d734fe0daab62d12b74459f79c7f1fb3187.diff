[+++ b/src/main/java/rx/Observable.java, +     * Passes all emitted values from {@code this} Observable to the provided {@link ConversionFunc} to be , +     * collected and returned as a single value. Note that it is legal for a {@link ConversionFunc} to , +     * return an Observable (enabling chaining). , +     * , +     * @param conversion a function that converts from this {@code Observable<T>} to an {@code R}, +     * @return an instance of R created by the provided Conversion, +     */, +    @Experimental, +    public <R> R x(Func1<? super OnSubscribe<T>, ? extends R> conversion) {, +        return conversion.call(new OnSubscribe<T>() {, +            @Override, +            public void call(Subscriber<? super T> subscriber) {, +                subscriber.add(Observable.subscribe(subscriber, Observable.this));, +            }});, +    }, +    , +    /**, +     * @param operator the Operator that implements the Observable-operating function to be applied to the source, +    public final <R> Observable<R> lift(final Operator<? extends R, ? super T> operator) {, +                    Subscriber<? super T> st = hook.onLift(operator).call(o);, +        return Observable.subscribe(subscriber, this);, +    }, +    , +    private static <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {, +        if (observable.onSubscribe == null) {, +            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);, +++ b/src/main/java/rx/Observable.java, +     * Passes all emitted values from {@code this} Observable to the provided {@link ConversionFunc} to be , +     * collected and returned as a single value. Note that it is legal for a {@link ConversionFunc} to , +     * return an Observable (enabling chaining). , +     * , +     * @param conversion a function that converts from this {@code Observable<T>} to an {@code R}, +     * @return an instance of R created by the provided Conversion, +     */, +    @Experimental, +    public <R> R x(Func1<? super OnSubscribe<T>, ? extends R> conversion) {, +        return conversion.call(new OnSubscribe<T>() {, +            @Override, +            public void call(Subscriber<? super T> subscriber) {, +                subscriber.add(Observable.subscribe(subscriber, Observable.this));, +            }});, +    }, +    , +    /**, +     * @param operator the Operator that implements the Observable-operating function to be applied to the source, +    public final <R> Observable<R> lift(final Operator<? extends R, ? super T> operator) {, +                    Subscriber<? super T> st = hook.onLift(operator).call(o);, +        return Observable.subscribe(subscriber, this);, +    }, +    , +    private static <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {, +        if (observable.onSubscribe == null) {, +            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);, +++ b/src/test/java/rx/ObservableConversionTest.java, +package rx;, +, +import java.util.Arrays;, +import java.util.List;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static junit.framework.Assert.*;, +, +import org.junit.Test;, +, +import rx.Observable.OnSubscribe;, +import rx.Observable.Operator;, +import rx.exceptions.OnErrorNotImplementedException;, +import rx.functions.Func1;, +import rx.functions.Func2;, +import rx.internal.operators.OperatorFilter;, +import rx.internal.operators.OperatorMap;, +import rx.observers.TestSubscriber;, +import rx.schedulers.Schedulers;, +, +public class ObservableConversionTest {, +    , +    public static class Cylon {}, +    , +    public static class Jail {, +        Object cylon;, +        , +        Jail(Object cylon) {, +            this.cylon = cylon;, +        }, +    }, +    , +    public static class CylonDetectorObservable<T> {, +        protected OnSubscribe<T> onSubscribe;, +        , +        public static <T> CylonDetectorObservable<T> create(OnSubscribe<T> onSubscribe) {, +            return new CylonDetectorObservable<T>(onSubscribe);, +        }, +, +        protected CylonDetectorObservable(OnSubscribe<T> onSubscribe) {, +            this.onSubscribe = onSubscribe;, +        }, +]