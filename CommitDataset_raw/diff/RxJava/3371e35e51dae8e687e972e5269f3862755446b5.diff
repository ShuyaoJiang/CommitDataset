[+++ b/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java, +    static final class DebounceTimedSubscriber<T>, +    extends AtomicLong, +                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");, +            if (!gate) {, +                gate = true;, +                long r = get();, +                if (r != 0L) {, +                    actual.onNext(t);, +                    if (r != Long.MAX_VALUE) {, +                        decrementAndGet();, +                    }, +                } else {, +                    done = true;, +                    cancel();, +                    actual.onError(new IllegalStateException("Could not deliver value due to lack of requests"));, +                    return;, +                // FIXME should this be a periodic blocking or a value-relative blocking?, +                if (TIMER.compareAndSet(this, d, NEW_TIMER)) {, +            , +        }, +        , +            gate = false;, +            BackpressureHelper.add(this, n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java, +    static final class DebounceTimedSubscriber<T>, +    extends AtomicLong, +                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");, +            if (!gate) {, +                gate = true;, +                long r = get();, +                if (r != 0L) {, +                    actual.onNext(t);, +                    if (r != Long.MAX_VALUE) {, +                        decrementAndGet();, +                    }, +                } else {, +                    done = true;, +                    cancel();, +                    actual.onError(new IllegalStateException("Could not deliver value due to lack of requests"));, +                    return;, +                // FIXME should this be a periodic blocking or a value-relative blocking?, +                if (TIMER.compareAndSet(this, d, NEW_TIMER)) {, +            , +        }, +        , +            gate = false;, +            BackpressureHelper.add(this, n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java, +            if (firstTimeoutSelector != null) {, +            } else {, +                a.onSubscribe(s);, +            }, +            if (firstTimeoutSelector != null) {, +            } else {, +                a.onSubscribe(arbiter);, +            }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java, +    static final class DebounceTimedSubscriber<T>, +    extends AtomicLong, +                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");, +            if (!gate) {, +                gate = true;, +                long r = get();, +                if (r != 0L) {, +                    actual.onNext(t);, +                    if (r != Long.MAX_VALUE) {, +                        decrementAndGet();, +                    }, +                } else {, +                    done = true;, +                    cancel();, +                    actual.onError(new IllegalStateException("Could not deliver value due to lack of requests"));, +                    return;, +                // FIXME should this be a periodic blocking or a value-relative blocking?, +                if (TIMER.compareAndSet(this, d, NEW_TIMER)) {, +            , +        }, +        , +            gate = false;, +            BackpressureHelper.add(this, n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java, +            if (firstTimeoutSelector != null) {, +            } else {, +                a.onSubscribe(s);, +            }, +            if (firstTimeoutSelector != null) {, +            } else {, +                a.onSubscribe(arbiter);, +            }, +++ b/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java, +    , +    volatile Subscription s;, +    static final Subscription INITIAL = new Subscription() {, +        @Override, +        public void request(long n) {, +            , +        }, +        @Override, +        public void cancel() {]