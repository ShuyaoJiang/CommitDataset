[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val sharedNumbers = numbers.replay, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val sharedNumbers = numbers.replay, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R] = {, +    new ConnectableObservable[R](asJavaObservable.multicast(s)), +  def replay: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.replay()), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val sharedNumbers = numbers.replay, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R] = {, +    new ConnectableObservable[R](asJavaObservable.multicast(s)), +  def replay: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.replay()), +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.OnActionComplete;, +, +    private static class ComputationSchedulerPool {, +        final int cores = Runtime.getRuntime().availableProcessors();, +        final EventLoopScheduler[] eventLoops;, +        ComputationSchedulerPool() {, +            eventLoops = new EventLoopScheduler[cores];, +                eventLoops[i] = new EventLoopScheduler(factory);, +        private static ComputationSchedulerPool INSTANCE = new ComputationSchedulerPool();, +, +        long n = 0;, +, +        public EventLoopScheduler getEventLoop() {, +            // round-robin selection (improvements to come), +        return new EventLoop();, +    private static class EventLoop extends Scheduler.Worker {, +        private final EventLoopScheduler pooledEventLoop;, +        private final OnActionComplete onComplete;, +        EventLoop() {, +            pooledEventLoop = ComputationSchedulerPool.INSTANCE.getEventLoop();, +            onComplete = new OnActionComplete() {, +                @Override, +                public void complete(Subscription s) {, +                    innerSubscription.remove(s);, +                }, +, +            };, +            if (innerSubscription.isUnsubscribed()) {, +                // don't schedule, we are unsubscribed, +                return Subscriptions.empty();, +            return pooledEventLoop.schedule(action, onComplete);, +        }, +, +            return pooledEventLoop.schedule(action, delayTime, unit, onComplete);, +    }, +, +    private static class EventLoopScheduler extends NewThreadScheduler.EventLoopScheduler {, +        EventLoopScheduler(ThreadFactory threadFactory) {, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +    val sharedNumbers = numbers.replay, +    sharedNumbers.connect, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R] = {, +    new ConnectableObservable[R](asJavaObservable.multicast(s)), +  def replay: ConnectableObservable[T] = {, +    new ConnectableObservable[T](asJavaObservable.replay()), +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +import rx.schedulers.NewThreadScheduler.OnActionComplete;, +, +    private static class ComputationSchedulerPool {, +        final int cores = Runtime.getRuntime().availableProcessors();, +        final EventLoopScheduler[] eventLoops;, +        ComputationSchedulerPool() {, +            eventLoops = new EventLoopScheduler[cores];, +                eventLoops[i] = new EventLoopScheduler(factory);, +        private static ComputationSchedulerPool INSTANCE = new ComputationSchedulerPool();, +, +        long n = 0;, +, +        public EventLoopScheduler getEventLoop() {, +            // round-robin selection (improvements to come), +        return new EventLoop();, +    private static class EventLoop extends Scheduler.Worker {, +        private final EventLoopScheduler pooledEventLoop;, +        private final OnActionComplete onComplete;, +        EventLoop() {, +            pooledEventLoop = ComputationSchedulerPool.INSTANCE.getEventLoop();, +            onComplete = new OnActionComplete() {, +                @Override, +                public void complete(Subscription s) {, +                    innerSubscription.remove(s);, +                }, +, +            };, +            if (innerSubscription.isUnsubscribed()) {, +                // don't schedule, we are unsubscribed, +                return Subscriptions.empty();, +            return pooledEventLoop.schedule(action, onComplete);, +        }]