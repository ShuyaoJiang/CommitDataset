[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWhere;, +    private final boolean isTrusted;, +        this(null, false);, +        this(onSubscribe, false);, +    }, +, +    /**, +     * @param onSubscribe, +     *            {@link Func1} to be executed when {@link #subscribe(Observer)} is called., +     * @param isTrusted, +     *            boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., +     */, +    private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +        this.isTrusted = isTrusted;, +            if (isTrusted) {, +        return subscribe(new Observer() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        return subscribe(new Observer() {, +        return subscribe(new Observer<T>() {, +        subscribe(new Observer<T>() {, +            }, true);, +            }, true);, +    /*, +     * Private version that creates a 'trusted' Observable to allow performance optimizations., +     */, +    private static <T> Observable<T> _create(Func1<Observer<T>, Subscription> func) {, +        return new Observable<T>(func, true);, +    }, +, +        return _create(OperationFilter.filter(that, predicate));, +        return _create(OperationWhere.where(that, predicate));, +        return _create(OperationDefer.defer(observableFactory));, +        return _create(OperationDefer.defer(new Func0<Observable<T>>() {, +        return _create(OperationMap.map(sequence, func));, +        return _create(OperationMap.mapMany(sequence, func));, +        return _create(OperationMaterialize.materialize(sequence));, +        return _create(OperationDematerialize.dematerialize(sequence));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationMerge.merge(source));, +        return _create(OperationConcat.concat(source));, +        return _create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, +        return _create(OperatorGroupBy.groupBy(source, keySelector));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationMergeDelayError.mergeDelayError(source));, +        return _create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(that, resumeFunction));, +        return _create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(that, resumeSequence));, +        return _create(OperationOnErrorReturn.onErrorReturn(that, resumeFunction));, +        return takeLast(_create(OperationScan.scan(sequence, accumulator)), 1);, +        return takeLast(_create(OperationScan.scan(sequence, initialValue, accumulator)), 1);, +        return _create(OperationScan.scan(sequence, accumulator));, +        return _create(OperationScan.scan(sequence, initialValue, accumulator));, +        return _create(OperationSkip.skip(items, num));, +        return _create(OperationSynchronize.synchronize(observable));, +        return _create(OperationTake.take(items, num));, +        return _create(OperationTakeLast.takeLast(items, count));, +        return create(OperationTake.takeWhile(items, predicate));, +        return create(OperationTake.takeWhileWithIndex(items, predicate));, +        return create(OperationTake.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>() {, +            public Boolean call(T t, Integer integer) {, +        return _create(OperationToObservableList.toObservableList(that));, +        return _create(OperationToObservableIterable.toObservableIterable(iterable));, +        return _create(OperationToObservableFuture.toObservableFuture(future));, +        return _create(OperationToObservableFuture.toObservableFuture(future, time, unit));, +        return _create(OperationToObservableSortedList.toSortedList(sequence));, +        return _create(OperationToObservableSortedList.toSortedList(sequence, sortFunction));, +        return _create(OperationToObservableSortedList.toSortedList(sequence, new Func2<T, T, Integer>() {, +        return _create(OperationZip.zip(w0, w1, reduceFunction));, +        return _create(OperationZip.zip(w0, w1, w2, function));, +        return _create(OperationZip.zip(w0, w1, w2, w3, reduceFunction));, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWhere;, +    private final boolean isTrusted;, +        this(null, false);, +        this(onSubscribe, false);, +    }, +, +    /**, +     * @param onSubscribe, +     *            {@link Func1} to be executed when {@link #subscribe(Observer)} is called., +     * @param isTrusted, +     *            boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., +     */, +    private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +        this.isTrusted = isTrusted;]