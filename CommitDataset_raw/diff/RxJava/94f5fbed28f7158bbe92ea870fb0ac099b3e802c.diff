[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map[B](f), +        override def subscribe(observer: Observer[_ >: String]): Subscription = {, +        val merged = Observable.merge[Int](observable), +    @Test def testZip2() {, +        val colors: Observable[String] = Observable.from("red", "green", "blue"), +        val names: Observable[String] = Observable.from("lion-o", "cheetara", "panthro"), +        , +        case class Character(color: String, name: String), +        , +        val cheetara = Character("green", "cheetara"), +        val panthro = Character("blue", "panthro"), +        val characters = Observable.zip[String, String, Character](colors, names, Character.apply _), +        assertSubscribeReceives(characters)(cheetara, panthro), +    }, +    , +        val characters = Observable.zip[Int, String, String, Character](numbers, colors, names, Character.apply _), +        val characters = Observable.zip[Int, String, String, Boolean, Character](numbers, colors, names, isLeader, Character.apply _), +        val mapped: Observable[Int] = numbers map ((x: Int) => x * x), +        mapped.subscribe((squareVal: Int) => {, +        val took = observable.take(2), +    @Test def testTakeWhileWithIndex {, +        val observable = Observable.from(1, 3, 5, 7, 9, 11, 12, 13, 15, 17), +        val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx < 8), +        assertSubscribeReceives(took)(1, 3, 5, 7, 9, 11), +    }, +        val filteredObservable: Observable[Int] = for {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map[B](f), +        override def subscribe(observer: Observer[_ >: String]): Subscription = {, +        val merged = Observable.merge[Int](observable), +    @Test def testZip2() {, +        val colors: Observable[String] = Observable.from("red", "green", "blue"), +        val names: Observable[String] = Observable.from("lion-o", "cheetara", "panthro"), +        , +        case class Character(color: String, name: String), +        , +        val cheetara = Character("green", "cheetara"), +        val panthro = Character("blue", "panthro"), +        val characters = Observable.zip[String, String, Character](colors, names, Character.apply _), +        assertSubscribeReceives(characters)(cheetara, panthro), +    }, +    , +        val characters = Observable.zip[Int, String, String, Character](numbers, colors, names, Character.apply _), +        val characters = Observable.zip[Int, String, String, Boolean, Character](numbers, colors, names, isLeader, Character.apply _), +        val mapped: Observable[Int] = numbers map ((x: Int) => x * x), +        mapped.subscribe((squareVal: Int) => {, +        val took = observable.take(2), +    @Test def testTakeWhileWithIndex {, +        val observable = Observable.from(1, 3, 5, 7, 9, 11, 12, 13, 15, 17), +        val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx < 8), +        assertSubscribeReceives(took)(1, 3, 5, 7, 9, 11), +    }, +        val filteredObservable: Observable[Int] = for {, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +, +, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {, +            @SuppressWarnings("unchecked"), +            @SuppressWarnings("unchecked"), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +        def map[B](f: A => B): Observable[B] = wrapped.map[B](f), +        override def subscribe(observer: Observer[_ >: String]): Subscription = {, +        val merged = Observable.merge[Int](observable), +    @Test def testZip2() {, +        val colors: Observable[String] = Observable.from("red", "green", "blue"), +        val names: Observable[String] = Observable.from("lion-o", "cheetara", "panthro"), +        , +        case class Character(color: String, name: String), +        , +        val cheetara = Character("green", "cheetara"), +        val panthro = Character("blue", "panthro"), +        val characters = Observable.zip[String, String, Character](colors, names, Character.apply _), +        assertSubscribeReceives(characters)(cheetara, panthro), +    }, +    , +        val characters = Observable.zip[Int, String, String, Character](numbers, colors, names, Character.apply _), +        val characters = Observable.zip[Int, String, String, Boolean, Character](numbers, colors, names, isLeader, Character.apply _), +        val mapped: Observable[Int] = numbers map ((x: Int) => x * x), +        mapped.subscribe((squareVal: Int) => {, +        val took = observable.take(2), +    @Test def testTakeWhileWithIndex {, +        val observable = Observable.from(1, 3, 5, 7, 9, 11, 12, 13, 15, 17), +        val took = observable.takeWhileWithIndex((i: Int, idx: Int) => isOdd(i) && idx < 8), +        assertSubscribeReceives(took)(1, 3, 5, 7, 9, 11), +    }, +        val filteredObservable: Observable[Int] = for {, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +, +, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {, +            @SuppressWarnings("unchecked"), +            @SuppressWarnings("unchecked"), +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action) {, +    public <T> Subscription schedule(final T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long dueTime, TimeUnit unit) {, +    public <T> Subscription schedulePeriodically(T state, final Func2<? super Scheduler, ? super T, ? extends Subscription> action, long initialDelay, long period, TimeUnit unit) {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala]