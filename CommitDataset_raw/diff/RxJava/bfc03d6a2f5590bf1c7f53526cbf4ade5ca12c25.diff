[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +  (:refer-clojure :exclude [concat cons count cycle, +                            distinct do drop drop-while, +                            empty every?, +                            interpose into, +                            keep keep-indexed, +                            merge next nth partition reduce reductions, +(defn subscribe-on, +  "Cause subscriptions to the given observable to happen on the given scheduler., +, +  Returns a new Observable., +, +  See:, +    rx.Observable/subscribeOn, +  ", +  [^rx.Scheduler s ^Observable xs], +  (.subscribeOn xs s)), +, +(defn unsubscribe-on, +  "Cause unsubscriptions from the given observable to happen on the given scheduler., +, +  Returns a new Observable., +, +  See:, +    rx.Observable/unsubscribeOn, +  ", +  [^rx.Scheduler s ^Observable xs], +  (.unsubscribeOn xs s)), +, +;################################################################################, +, +(defn synchronize, +  ([^Observable xs], +  (.synchronize xs)), +  ([lock ^Observable xs], +  (.synchronize xs lock))), +, +(defn count, +  "Returns an Observable that emits the number of items is xs as a long., +, +  See:, +    rx.Observable/longCount, +  ", +  [^Observable xs], +  (.longCount xs)), +, +(defn cycle, +  "Returns an Observable that emits the items of xs repeatedly, forever., +, +  TODO: Other sigs., +, +  See:, +    rx.Observable/repeat, +    clojure.core/cycle, +  ", +  [^Observable xs], +  (.repeat xs)), +, +(defn distinct, +  "Returns an Observable of the elements of Observable xs with duplicates, +  removed. key-fn, if provided, is a one arg function that determines the, +  key used to determined duplicates. key-fn defaults to identity., +, +  This implementation doesn't use rx.Observable/distinct because it doesn't, +  honor Clojure's equality semantics., +, +  See:, +    clojure.core/distinct, +  ", +  ([xs] (distinct identity xs)), +  ([key-fn ^Observable xs], +  (let [op (fn->operator (fn [o], +                           (let [seen (atom #{})], +                             (->subscriber o, +                                           (fn [o v], +                                             (let [key (key-fn v)], +                                               (when-not (contains? @seen key), +                                                 (swap! seen conj key), +                                                 (on-next o v))))))))], +    (lift op xs)))), +, +, +  See:, +    rx.Observable/doOnNext, +  [do-fn ^Observable xs], +  (.doOnNext xs (iop/action* do-fn))), +(defn ^Observable every?, +  "Returns an Observable that emits a single true value if (p x) is true for, +  all x in xs. Otherwise emits false., +, +  See:, +    clojure.core/every?, +    rx.Observable/all, +  ", +  [p ^Observable xs], +  (.all xs (fn->predicate p))), +, +; TODO group-by, +, +(defn ^Observable map*]