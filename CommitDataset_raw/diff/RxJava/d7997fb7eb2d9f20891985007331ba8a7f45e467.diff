[+++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.currentThread());, +        return create(OperationToObservableIterable.toObservableIterable(iterable, scheduler));, +     * @param items the source array, +        return from(Arrays.asList(items));, +    }, +, +    /**, +     * Converts an Array into an Observable., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">, +     * <p>, +     * Note: the entire array is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     *, +     * @param items the source array, +     * @param scheduler the scheduler to emit the items of the array, +     * @param <T> the type of items in the Array and the type of items to be, +     *            emitted by the resulting Observable, +     * @return an Observable that emits each item in the source Array, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a>, +     */, +    public static <T> Observable<T> from(T[] items, Scheduler scheduler) {, +        return from(Arrays.asList(items), scheduler);, +        return from(Range.createWithCount(start, count), scheduler);, +        return from(Arrays.asList((value)));, +        return from(Arrays.asList((value)), scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.currentThread());, +        return create(OperationToObservableIterable.toObservableIterable(iterable, scheduler));, +     * @param items the source array, +        return from(Arrays.asList(items));, +    }, +, +    /**, +     * Converts an Array into an Observable., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">, +     * <p>, +     * Note: the entire array is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     *, +     * @param items the source array, +     * @param scheduler the scheduler to emit the items of the array, +     * @param <T> the type of items in the Array and the type of items to be, +     *            emitted by the resulting Observable, +     * @return an Observable that emits each item in the source Array, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a>, +     */, +    public static <T> Observable<T> from(T[] items, Scheduler scheduler) {, +        return from(Arrays.asList(items), scheduler);, +        return from(Range.createWithCount(start, count), scheduler);, +        return from(Arrays.asList((value)));, +        return from(Arrays.asList((value)), scheduler);, +++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java, +import rx.Scheduler;, +import rx.schedulers.Schedulers;, +import rx.util.functions.Action0;, +import rx.util.functions.Action1;, +, +import java.util.Iterator;, +    public static <T> OnSubscribeFunc<T> toObservableIterable(Iterable<? extends T> list, Scheduler scheduler) {, +        return new ToObservableIterable<T>(list, scheduler);, +    }, +, +        return toObservableIterable(list, Schedulers.currentThread());, +, +        public ToObservableIterable(Iterable<? extends T> list, Scheduler scheduler) {, +            this.scheduler = scheduler;, +        Scheduler scheduler;, +        final Iterable<? extends T> iterable;, +        public Subscription onSubscribe(final Observer<? super T> observer) {, +            final Iterator<? extends T> iterator = iterable.iterator();, +            return scheduler.schedule(new Action1<Action0>() {, +                @Override, +                public void call(Action0 self) {, +                    try {, +                        if (iterator.hasNext()) {, +                            T x = iterator.next();, +                            observer.onNext(x);, +                            self.call();, +                        } else {, +                        }, +                    } catch (Exception e) {, +                        observer.onError(e);, +                    }, +                }, +            });, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return from(iterable, Schedulers.currentThread());, +        return create(OperationToObservableIterable.toObservableIterable(iterable, scheduler));, +     * @param items the source array, +        return from(Arrays.asList(items));, +    }, +, +    /**]