[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSkip;, +import rx.operators.OperatorSkipUntil;, +        return create(new OperationSkip.SkipTimed<T>(this, time, unit, scheduler));, +        return lift(new OperatorSkipUntil<T, U>(other));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSkip;, +import rx.operators.OperatorSkipUntil;, +        return create(new OperationSkip.SkipTimed<T>(this, time, unit, scheduler));, +        return lift(new OperatorSkipUntil<T, U>(other));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkip.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Scheduler;, +import rx.Scheduler.Worker;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.functions.Action0;, +import rx.subscriptions.CompositeSubscription;, +, +/**, + * Returns an Observable that skips the first <code>num</code> items emitted by the source, + * Observable., + * <p>, + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/skip.png">, + * <p>, + * You can ignore the first <code>num</code> items emitted by an Observable and attend only to, + * those items that come after, by modifying the Observable with the skip operation., + */, +public final class OperationSkip {, +, +    /**, +     * Skip the items after subscription for the given duration., +     * , +     * @param <T>, +     *            the value type, +     */, +    public static final class SkipTimed<T> implements OnSubscribeFunc<T> {, +        final Observable<? extends T> source;, +        final long time;, +        final TimeUnit unit;, +        final Scheduler scheduler;, +, +        public SkipTimed(Observable<? extends T> source, long time, TimeUnit unit, Scheduler scheduler) {, +            this.source = source;, +            this.time = time;, +            this.unit = unit;, +            this.scheduler = scheduler;, +        }, +, +        @Override, +        public Subscription onSubscribe(Observer<? super T> t1) {, +            Worker inner = scheduler.createWorker();, +            CompositeSubscription csub = new CompositeSubscription(inner);, +            final SourceObserver<T> so = new SourceObserver<T>(t1, csub);, +            csub.add(so);, +            source.unsafeSubscribe(so);, +            if (!so.isUnsubscribed()) {, +                inner.schedule(so, time, unit);, +            }, +, +            return csub;, +        }, +, +        /**, +         * Observes the source and relays its values once gate turns into true., +         * , +         * @param <T>, +         *            the observed value type, +         */, +        private static final class SourceObserver<T> extends Subscriber<T> implements Action0 {, +            final AtomicBoolean gate;, +            final Observer<? super T> observer;, +            final Subscription cancel;, +, +            public SourceObserver(Observer<? super T> observer,, +                    Subscription cancel) {, +                this.gate = new AtomicBoolean();, +                this.observer = observer;]