[+++ b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +, +    private final ConcurrentLinkedQueue<Notification<T>> queue = new ConcurrentLinkedQueue<Notification<T>>();, +    private final AtomicInteger counter = new AtomicInteger(0);, +, +    public void onNext(final T args) {, +        enqueue(new Notification<T>(args));, +    private void enqueue(Notification<T> notification) {, +        // this must happen before 'counter' is used to provide synchronization between threads, +        queue.offer(notification);, +        // we now use counter to atomically determine if we need to start processing or not, +        // it will be 0 if it's the first notification or the scheduler has finished processing work, +        // and we need to start doing it again, +        if (counter.getAndIncrement() == 0) {, +            processQueue();, +        }, +    }, +    private void processQueue() {, +                Notification<T> not = queue.poll();, +, +                switch (not.getKind()) {, +                    underlying.onNext(not.getValue());, +                    underlying.onError(not.getException());, +                    throw new IllegalStateException("Unknown kind of notification " + not);, +, +                // decrement count and if we still have work to do, +                // recursively schedule ourselves to process again, +                if (counter.decrementAndGet() > 0) {, +                    scheduler.schedule(this);, +                }, +]