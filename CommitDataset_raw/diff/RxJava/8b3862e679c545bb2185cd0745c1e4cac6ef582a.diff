[+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +        System.out.println("********** onCompleted");, +        terminateIfNecessary(newState);, +        System.out.println("********** onError");, +        terminateIfNecessary(newState);, +            newState = current.offerItem(t);, +        if (newState.shouldProcess()) {, +, +            // finish processing to let this thread move on, +                newState = current.finishProcessing(items.length + 1); // the + 1 is for the first onNext of itself, +            System.out.println("********** finishProcessing");, +    @SuppressWarnings("unchecked"), +    private void terminateIfNecessary(State current) {, +        if (current.isTerminated()) {, +            State newState = null;, +            do {, +                current = state.get();, +                newState = current.startTermination();, +            } while (!state.compareAndSet(current, newState));, +            if (newState.shouldProcess()) {, +                // drain any items left, +                for (int i = 0; i < newState.queue.length; i++) {, +                    s.onNext((T) newState.queue[i]);, +                }, +, +                // now terminate, +                if (newState.onComplete) {, +                    s.onError(newState.onError);, +                }, +        final boolean shouldProcess;, +        final boolean isSomeoneProcessing;, +        final int queueSize;, +        private final static State NON_TERMINATED_EMPTY = new State(false, false, 0, false, null, EMPTY);, +        private final static State NON_TERMINATED_PROCESS_SELF = new State(true, true, 1, false, null, EMPTY);, +        public State(boolean shouldProcess, boolean isSomeoneProcessing, int queueSize, boolean onComplete, Throwable onError, Object[] queue) {, +            this.shouldProcess = shouldProcess;, +            this.isSomeoneProcessing = isSomeoneProcessing;, +            this.queueSize = queueSize;, +            return new State(false, false, 0, false, null, EMPTY);, +        }, +, +        public boolean shouldProcess() {, +            return shouldProcess;, +            return new State(false, isSomeoneProcessing, queueSize, true, onError, queue);, +            // immediately empty the queue and emit error as soon as possible, +            return new State(false, isSomeoneProcessing, queueSize, onComplete, e, EMPTY);, +        }, +, +        public State startTermination() {, +            if (isSomeoneProcessing) {, +                System.out.println("start terminate and DO NOT process => queue size: " + (queueSize + 1));, +                return new State(false, isSomeoneProcessing, queueSize, onComplete, onError, queue);, +            } else {, +                System.out.println("start terminate and process => queue size: " + (queueSize + 1));, +                return new State(true, isSomeoneProcessing, queueSize, onComplete, onError, queue);, +            }, +        public State offerItem(Object item) {, +            if (queueSize == 0) {, +                    return new State(false, false, 0, onComplete, onError, EMPTY);, +                    return NON_TERMINATED_PROCESS_SELF;, +                // there are items queued so we need to queue, +                if (isSomeoneProcessing) {, +                    // we just add to queue, +                    return new State(false, isSomeoneProcessing, queueSize + 1, onComplete, onError, newQueue);, +                } else {, +                    // we add to queue and claim work, +                    return new State(false, true, queueSize + 1, onComplete, onError, newQueue);, +        public State finishProcessing(int numOnNextSent) {, +            int numOnNextFromQueue = numOnNextSent - 1; // we remove the "self" onNext as it doesn't affect the queue, +            int size = queueSize - numOnNextFromQueue;, +            System.out.println("finishProcessing => queue size: " + size + "   after processing: " + numOnNextSent);, +            if (size > 1 || isTerminated()) {, +                Object[] newQueue = new Object[queue.length - numOnNextFromQueue];, +                System.arraycopy(queue, numOnNextFromQueue, newQueue, 0, newQueue.length);, +                return new State(false, false, size, onComplete, onError, newQueue);, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +        System.out.println("********** onCompleted");, +        terminateIfNecessary(newState);, +        System.out.println("********** onError");, +        terminateIfNecessary(newState);, +            newState = current.offerItem(t);, +        if (newState.shouldProcess()) {, +, +            // finish processing to let this thread move on, +                newState = current.finishProcessing(items.length + 1); // the + 1 is for the first onNext of itself, +            System.out.println("********** finishProcessing");, +    @SuppressWarnings("unchecked"), +    private void terminateIfNecessary(State current) {, +        if (current.isTerminated()) {, +            State newState = null;, +            do {, +                current = state.get();, +                newState = current.startTermination();, +            } while (!state.compareAndSet(current, newState));, +            if (newState.shouldProcess()) {, +                // drain any items left, +                for (int i = 0; i < newState.queue.length; i++) {, +                    s.onNext((T) newState.queue[i]);, +                }, +]