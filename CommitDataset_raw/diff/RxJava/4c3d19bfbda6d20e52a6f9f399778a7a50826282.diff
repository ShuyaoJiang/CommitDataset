[+++ b/src/main/java/io/reactivex/internal/operators/PublisherGenerate.java, +                    if (n == Long.MAX_VALUE) {, +                        continue;, +                    }, +                    n += e;, +++ b/src/main/java/io/reactivex/internal/operators/PublisherGenerate.java, +                    if (n == Long.MAX_VALUE) {, +                        continue;, +                    }, +                    n += e;, +++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java, +/**, + * Subject that allows only a single Subscriber to subscribe to it during its lifetime., + * , + * <p>This subject buffers notifications and replays them to the Subscriber as requested., + * , + * <p>This subject holds an unbounded internal buffer., + * , + * <p>If more than one Subscriber attempts to subscribe to this Subject, they, + * will receive an IllegalStateException if this Subject hasn't terminated yet,, + * or the Subscribers receive the terminal event (error or completion) if this, + * Subject has terminated., + * , + * @param <T> the value type unicasted, + */, +    /**, +     * Creates an UnicastSubject with an internal buffer capacity hint 16., +     * @return an UnicastSubject instance, +     */, +    /**, +     * Creates an UnicastSubject with the given internal buffer capacity hint., +     * @param capacityHint the hint to size the internal unbounded buffer, +     * @return an UnicastSubject instance, +     */, +        return create(capacityHint, null);, +    }, +, +    /**, +     * Creates an UnicastSubject with the given internal buffer capacity hint and a callback for, +     * the case when the single Subscriber cancels its subscription., +     * , +     * <p>The callback, if not null, is called exactly once and, +     * non-overlapped with any active replay., +     * , +     * @param capacityHint the hint to size the internal unbounded buffer, +     * @param onCancelled the optional callback, +     * @return an UnicastSubject instance, +     */, +    public static <T> UnicastSubject<T> create(int capacityHint, Runnable onCancelled) {, +        State<T> state = new State<>(capacityHint, onCancelled);, +    /** The subject state. */, +    /**, +     * Constructs the Observable base class., +     * @param state the subject state, +     */, +    // TODO may need to have a direct WIP field to avoid clashing on the object header, +    /** Pads the WIP counter. */, +        /** Cache line padding 1. */, +        volatile long p1a, p2a, p3a, p4a, p5a, p6a, p7a;, +        /** Cache line padding 2. */, +        volatile long p8a, p9a, p10a, p11a, p12a, p13a, p14a, p15a;, +    /** Contains the requested counter. */, +        /** Holds the current requested amount. */, +        /** Updater to the field requested. */, +    /** Pads away the requested counter. */, +        /** Cache line padding 3. */, +        volatile long p1b, p2b, p3b, p4b, p5b, p6b, p7b;, +        /** Cache line padding 4. */, +        volatile long p8b, p9b, p10b, p11b, p12b, p13b, p14b, p15b;, +    /** The state of the UnicastSubject. */, +        /** The queue that buffers the source events. */, +        /** The single subscriber. */, +        /** Updater to the field subscriber. */, +        /** Indicates the single subscriber has cancelled. */, +        /** Indicates the source has terminated. */, +        /** , +         * The terminal error if not null. , +         * Must be set before writing to done and read after done == true., +         */, +        /** Set to 1 atomically for the first and only Subscriber. */, +        /** Updater to field once. */, +        /** , +         * Called when the Subscriber has called cancel., +         * This allows early termination for those who emit into this, +         * subject so that they can stop immediately , +         */, +        Runnable onCancelled;, +        , +        /**, +         * Constructs the state with the given capacity and optional cancellation callback., +         * @param capacityHint the capacity hint for the internal buffer, +         * @param onCancelled the optional cancellation callback, +         */, +        public State(int capacityHint, Runnable onCancelled) {, +            this.onCancelled = onCancelled;, +        void notifyOnCancelled() {, +            Runnable r = onCancelled;, +            onCancelled = null;, +            if (r != null) {, +                r.run();]