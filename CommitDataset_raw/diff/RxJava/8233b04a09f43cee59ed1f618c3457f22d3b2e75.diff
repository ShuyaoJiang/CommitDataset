[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.operators.OperationBuffer.BufferClosing;, +import rx.operators.OperationBuffer.BufferOpening;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.fail;, +, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyString;, +     * , +     * Creates an Observable which produces buffers of collected values. This Observable produces connected, +     * non-overlapping buffers. The current buffer is emitted and replaced with a new buffer when the, +     * Observable produced by the specified {@link Func0} produces a {@link BufferClosing} object. The, +     * {@link Func0} will then be used to create a new Observable to listen for the end of the next buffer., +     *, +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param bufferClosingSelector, +     *            The {@link Func0} which is used to produce an {@link Observable} for every buffer created., +     *            When this {@link Observable} produces a {@link BufferClosing} object, the associated buffer, +     *            is emitted and replaced with a new one., +     * @return, +     *            An {@link Observable} which produces connected non-overlapping buffers, which are emitted, +     *            when the current {@link Observable} created with the {@link Func0} argument produces a, +     *            {@link BufferClosing} object., +     */, +    public static <T> Observable<List<T>> buffer(Observable<T> source, Func0<Observable<BufferClosing>> bufferClosingSelector) {, +        return create(OperationBuffer.buffer(source, bufferClosingSelector));, +    }, +, +    /**, +     * Creates an Observable which produces buffers of collected values. This Observable produces buffers., +     * Buffers are created when the specified "bufferOpenings" Observable produces a {@link BufferOpening} object., +     * Additionally the {@link Func0} argument is used to create an Observable which produces {@link BufferClosing}, +     * objects. When this Observable produces such an object, the associated buffer is emitted., +     *, +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param bufferOpenings, +     *            The {@link Observable} which when it produces a {@link BufferOpening} object, will cause, +     *            another buffer to be created., +     * @param bufferClosingSelector, +     *            The {@link Func0} which is used to produce an {@link Observable} for every buffer created., +     *            When this {@link Observable} produces a {@link BufferClosing} object, the associated buffer, +     *            is emitted., +     * @return, +     *            An {@link Observable} which produces buffers which are created and emitted when the specified, +     *            {@link Observable}s publish certain objects., +     */, +    public static <T> Observable<List<T>> buffer(Observable<T> source, Observable<BufferOpening> bufferOpenings, Func1<BufferOpening, Observable<BufferClosing>> bufferClosingSelector) {, +        return create(OperationBuffer.buffer(source, bufferOpenings, bufferClosingSelector));, +    }, +, +    /**, +     * Creates an Observable which produces buffers of collected values. This Observable produces connected, +     * non-overlapping buffers, each containing "count" elements. When the source Observable completes or, +     * encounters an error, the current buffer is emitted, and the event is propagated., +     *, +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param count, +     *            The maximum size of each buffer before it should be emitted., +     * @return, +     *            An {@link Observable} which produces connected non-overlapping buffers containing at most, +     *            "count" produced values., +     */, +    public static <T> Observable<List<T>> buffer(Observable<T> source, int count) {, +        return create(OperationBuffer.buffer(source, count));, +    }, +, +    /**, +     * Creates an Observable which produces buffers of collected values. This Observable produces buffers every, +     * "skip" values, each containing "count" elements. When the source Observable completes or encounters an error,, +     * the current buffer is emitted and the event is propagated., +     *, +     * @param source, +     *            The source {@link Observable} which produces values., +     * @param count, +     *            The maximum size of each buffer before it should be emitted., +     * @param skip, +     *            How many produced values need to be skipped before starting a new buffer. Note that when "skip" and, +     *            "count" are equals that this is the same operation as {@link Observable#buffer(Observable, int)}., +     * @return, +     *            An {@link Observable} which produces buffers every "skipped" values containing at most, +     *            "count" produced values., +     */, +    public static <T> Observable<List<T>> buffer(Observable<T> source, int count, int skip) {, +        return create(OperationBuffer.buffer(source, count, skip));, +    }, +, +    /**, +     * Creates an Observable which produces buffers of collected values. This Observable produces connected, +     * non-overlapping buffers, each of a fixed duration specified by the "timespan" argument. When the source, +     * Observable completes or encounters an error, the current buffer is emitted and the event is propagated.]