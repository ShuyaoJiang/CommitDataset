[+++ b/src/main/java/io/reactivex/Observable.java, +    static final int BUFFER_SIZE;, +    static {, +        BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, +    public static <T> Observable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {, +        return create(new PublisherAmb<>(null, sources));, +    public static int bufferSize() {, +        return BUFFER_SIZE;, +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, +        return combineLatest(sources, combiner, false, bufferSize());, +, +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, +        return combineLatest(sources, combiner, delayError, bufferSize());, +    }, +, +    public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {, +        validateBufferSize(bufferSize);, +        Objects.requireNonNull(combiner);, +        if (sources.length == 0) {, +            return empty();, +        }, +        // the queue holds a pair of values so we need to double the capacity, +        int s = bufferSize << 1;, +        return create(new PublisherCombineLatest<>(sources, null, combiner, s, delayError));, +    public static <T> Observable<T> concat(int prefetch, Iterable<? extends Publisher<? extends T>> sources) {, +        Objects.requireNonNull(sources);, +        return fromIterable(sources).concatMap(v -> v, prefetch);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> concat(int prefetch, Publisher<? extends T>... sources) {, +        Objects.requireNonNull(sources);, +        return fromArray(sources).concatMap(v -> v, prefetch);, +    }, +, +    public static <T> Observable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {, +        Objects.requireNonNull(sources);, +        return fromIterable(sources).concatMap(v -> v);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> concat(Publisher<? extends T>... sources) {, +        if (sources.length == 0) {, +            return empty();, +        } else, +        if (sources.length == 1) {, +            return fromPublisher(sources[0]);, +        }, +        return fromArray(sources).concatMap(v -> v);, +    }, +, +    public static <T> Observable<T> create(Publisher<T> onSubscribe) {, +        Objects.requireNonNull(onSubscribe);, +        onSubscribe = RxJavaPlugins.onCreate(onSubscribe);, +        return new Observable<>(onSubscribe);, +    }, +, +    public static <T> Observable<T> defer(Supplier<? extends Publisher<? extends T>> supplier) {, +        return create(new PublisherDefer<>(supplier));, +    }, +, +    @SuppressWarnings("unchecked"), +    public static <T> Observable<T> empty() {, +        return (Observable<T>)EMPTY;, +    }, +, +    public static <T> Observable<T> error(Supplier<? extends Throwable> errorSupplier) {, +        Objects.requireNonNull(errorSupplier);, +        return create(new PublisherErrorSource<>(errorSupplier));, +    }, +, +    public static <T> Observable<T> error(Throwable e) {, +        Objects.requireNonNull(e);, +        return error(() -> e);, +    }, +, +    @SafeVarargs, +    public static <T> Observable<T> fromArray(T... values) {, +        Objects.requireNonNull(values);, +        if (values.length == 0) {, +            return empty();, +        } else, +            if (values.length == 1) {, +                return just(values[0]);, +            }, +        return create(new PublisherArraySource<>(values));, +    }, +, +    // TODO match naming with RxJava 1.x, +    public static <T> Observable<T> fromCallable(Callable<? extends T> supplier) {, +        Objects.requireNonNull(supplier);, +        return create(new PublisherScalarAsyncSource<>(supplier));, +    }, +, +    public static <T> Observable<T> fromFuture(CompletableFuture<? extends T> future) {, +        Objects.requireNonNull(future);, +        return create(new PublisherCompletableFutureSource<>(future));, +    }, +, +    /*]