[+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java, +, +    /**, +     * Creates an observable that emits the set of all currently pressed keys each time, +     * this set changes. , +     * @param component, +     *            The component to register the observable for., +     * @return Observable of currently pressed keys., +     */, +    public static Observable<Set<Integer>> currentlyPressedKeys(JComponent component) {, +        return KeyEventSource.currentlyPressedKeysOf(component);, +    }, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java, +, +    /**, +     * Creates an observable that emits the set of all currently pressed keys each time, +     * this set changes. , +     * @param component, +     *            The component to register the observable for., +     * @return Observable of currently pressed keys., +     */, +    public static Observable<Set<Integer>> currentlyPressedKeys(JComponent component) {, +        return KeyEventSource.currentlyPressedKeysOf(component);, +    }, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +import static java.util.Arrays.asList;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import org.mockito.InOrder;, +import rx.util.functions.Func2;, +    public static Observable<Set<Integer>> currentlyPressedKeysOf(JComponent component) {, +        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {, +            @Override, +            public Set<Integer> call(Set<Integer> pressedKeys, KeyEvent event) {, +                Set<Integer> afterEvent = new HashSet<Integer>(pressedKeys);, +                switch (event.getID()) {, +                    case KeyEvent.KEY_PRESSED:, +                        afterEvent.add(event.getKeyCode());, +                        break;, +                        , +                    case KeyEvent.KEY_RELEASED:, +                        afterEvent.remove(event.getKeyCode());, +                        break;, +                      , +                    default: // nothing to do, +                }, +                return afterEvent;, +            }, +        });, +    }, +    , +        private JComponent comp = new JPanel();, +        , +        public void testObservingKeyEvents() {, +            Action1<KeyEvent> action = mock(Action1.class);, +            verify(action, never()).call(Matchers.<KeyEvent>any());, +            fireKeyEvent(event);, +            verify(action, times(1)).call(Matchers.<KeyEvent>any());, +            fireKeyEvent(event);, +            verify(action, times(2)).call(Matchers.<KeyEvent>any());, +            fireKeyEvent(event);, +            verify(action, times(2)).call(Matchers.<KeyEvent>any());, +        @Test, +        public void testObservingPressedKeys() {, +            @SuppressWarnings("unchecked"), +            Action1<Set<Integer>> action = mock(Action1.class);, +            @SuppressWarnings("unchecked"), +            Action1<Exception> error = mock(Action1.class);, +            Action0 complete = mock(Action0.class);, +            , +            Subscription sub = currentlyPressedKeysOf(comp).subscribe(action, error, complete);, +            , +            InOrder inOrder = inOrder(action);, +            inOrder.verify(action, times(1)).call(Collections.<Integer>emptySet());, +            verify(error, never()).call(Matchers.<Exception>any());, +            verify(complete, never()).call();, +            , +            fireKeyEvent(keyEvent(1, KeyEvent.KEY_PRESSED));, +            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1)));, +            verify(error, never()).call(Matchers.<Exception>any());, +            verify(complete, never()).call();, +, +            fireKeyEvent(keyEvent(2, KeyEvent.KEY_PRESSED));, +            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1, 2)));]