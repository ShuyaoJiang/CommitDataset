[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java, +import java.util.concurrent.atomic.*;, +    public void restartTimerMany() throws Exception {, +        final AtomicBoolean cancel1 = new AtomicBoolean();, +        .doOnCancel(new Action() {, +            @Override, +            public void run() throws Exception {, +                cancel1.set(true);, +            }, +        }), +, +        int timeout = 20;, +        while (timeout-- > 0 && !cancel1.get()) {, +            Thread.sleep(100);, +        }, +, +        assertTrue("intervalRange was not cancelled!", cancel1.get());]