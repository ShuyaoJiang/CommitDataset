[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java, +                    try {, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java, +                    try {, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java, +        return new DistinctUntilChanged<T, U>(source, keySelector);, +        return new DistinctUntilChanged<T, T>(source, Functions.<T>identity());, +        private DistinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {, +                    try {, +                        } else {, +                            if (lastKey == null) {, +                                if (nextKey != null) {, +                            } else {, +                                if (!lastKey.equals(nextKey)) {, +                                    observer.onNext(next);, +                                }, +                            }, +                        }, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +                    }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java, +                    try {, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java, +        return new DistinctUntilChanged<T, U>(source, keySelector);, +        return new DistinctUntilChanged<T, T>(source, Functions.<T>identity());, +        private DistinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {, +                    try {, +                        } else {, +                            if (lastKey == null) {, +                                if (nextKey != null) {, +                            } else {, +                                if (!lastKey.equals(nextKey)) {, +                                    observer.onNext(next);, +                                }, +                            }, +                        }, +                    } catch (Throwable t) {, +                        // keySelector is a user function, may throw something, +                        observer.onError(t);, +                    }, +++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java, +import rx.observables.ConnectableObservable;, +        return interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));, +    public static OnSubscribeFunc<Long> interval(final long interval, final TimeUnit unit, final Scheduler scheduler) {, +        // wrapped in order to work with multiple subscribers, +        return new OnSubscribeFunc<Long>() {, +            @Override, +            public Subscription onSubscribe(Observer<? super Long> observer) {, +                return new Interval(interval, unit, scheduler).onSubscribe(observer);, +            }, +        };, +        private Observer<Long> observer2;, +            observer2 = mock(Observer.class);, +        , +        @Test, +        public void testWithMultipleSubscribersStartingAtSameTime() {, +            Observable<Long> w = Observable.create(OperationInterval.interval(1, TimeUnit.SECONDS, scheduler));, +            Subscription sub1 = w.subscribe(observer);, +            Subscription sub2 = w.subscribe(observer2);, +, +            verify(observer, never()).onNext(anyLong());, +            verify(observer2, never()).onNext(anyLong());, +            , +            scheduler.advanceTimeTo(2, TimeUnit.SECONDS);, +            , +            InOrder inOrder1 = inOrder(observer);, +            InOrder inOrder2 = inOrder(observer2);, +            , +            inOrder1.verify(observer, times(1)).onNext(0L);, +            inOrder1.verify(observer, times(1)).onNext(1L);, +            inOrder1.verify(observer, never()).onNext(2L);, +            verify(observer, never()).onCompleted();, +            verify(observer, never()).onError(any(Throwable.class));, +, +            inOrder2.verify(observer2, times(1)).onNext(0L);, +            inOrder2.verify(observer2, times(1)).onNext(1L);, +            inOrder2.verify(observer2, never()).onNext(2L);, +            verify(observer2, never()).onCompleted();, +            verify(observer2, never()).onError(any(Throwable.class));, +, +            sub1.unsubscribe();, +            sub2.unsubscribe();, +            scheduler.advanceTimeTo(4, TimeUnit.SECONDS);, +, +            verify(observer, never()).onNext(2L);]