[+++ b/src/main/java/io/reactivex/Flowable.java, +     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, +     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, +    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));, +++ b/src/main/java/io/reactivex/Flowable.java, +     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, +     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, +    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));, +++ b/src/main/java/io/reactivex/Observable.java, +        T v = singleElement().blockingGet();, +        if (v == null) {, +            throw new NoSuchElementException();, +        }, +        return v;, +        return single(defaultItem).blockingGet();, +     * Returns a Single that counts the total number of items emitted by the source ObservableSource and emits, +     * @return a Single that emits a single item: the number of items emitted by the source ObservableSource as a, +    public final Single<Long> count() {, +        return RxJavaPlugins.onAssembly(new ObservableCountSingle<T>(this));, +     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from a, +     * @return a Maybe that emits a single item: the item at the specified position in the sequence of, +    public final Maybe<T> elementAt(long index) {, +        return RxJavaPlugins.onAssembly(new ObservableElementAtMaybe<T>(this, index));, +     * Returns a Single that emits the item found at a specified index in a sequence of emissions from a, +     * @return a Single that emits the item at the specified position in the sequence emitted by the source, +    public final Single<T> elementAt(long index, T defaultItem) {, +        return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, defaultItem));, +     * Returns a Maybe that emits only the very first item emitted by the source ObservableSource, or, +     * completes if the source ObservableSource is empty., +     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return the new Maybe instance, +    public final Maybe<T> firstElement() {, +        return elementAt(0L);, +     * Returns a Single that emits only the very first item emitted by the source ObservableSource, or a default, +     * @return the new Single instance, +    public final Single<T> first(T defaultItem) {, +        return elementAt(0L, defaultItem);, +     * @return the new Completable instance, +    public final Completable ignoreElements() {, +        return RxJavaPlugins.onAssembly(new ObservableIgnoreElementsCompletable<T>(this));, +     * Returns a Maybe that emits the last item emitted by the source ObservableSource or, +     * completes if the source is empty., +     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a Maybe that emits the last item from the source ObservableSource or notifies observers of an, +    public final Maybe<T> lastElement() {, +        return RxJavaPlugins.onAssembly(new ObservableLastMaybe<T>(this));, +     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, +     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, +    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {, +        return scan(reducer).takeLast(1).singleElement();, +    public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<R>(scan(seed, reducer).takeLast(1), null));, +     * Returns a Single that applies a specified accumulator function to the first item emitted by a source, +     * @return a Single that emits a single item that is the result of accumulating the output from the, +    public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<R>(scanWith(seedSupplier, reducer).takeLast(1), null));, +     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.</dd>, +    public final Maybe<T> singleElement() {, +        return RxJavaPlugins.onAssembly(new ObservableSingleMaybe<T>(this));, +    public final Single<T> single(T defaultItem) {, +        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(this, defaultItem));, +            return RxJavaPlugins.onAssembly(new ObservableIgnoreElements<T>(this));, +++ b/src/main/java/io/reactivex/Flowable.java, +     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, +     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, +    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));, +++ b/src/main/java/io/reactivex/Observable.java, +        T v = singleElement().blockingGet();, +        if (v == null) {, +            throw new NoSuchElementException();, +        }, +        return v;, +        return single(defaultItem).blockingGet();, +     * Returns a Single that counts the total number of items emitted by the source ObservableSource and emits, +     * @return a Single that emits a single item: the number of items emitted by the source ObservableSource as a, +    public final Single<Long> count() {, +        return RxJavaPlugins.onAssembly(new ObservableCountSingle<T>(this));, +     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from a, +     * @return a Maybe that emits a single item: the item at the specified position in the sequence of, +    public final Maybe<T> elementAt(long index) {, +        return RxJavaPlugins.onAssembly(new ObservableElementAtMaybe<T>(this, index));, +     * Returns a Single that emits the item found at a specified index in a sequence of emissions from a, +     * @return a Single that emits the item at the specified position in the sequence emitted by the source, +    public final Single<T> elementAt(long index, T defaultItem) {, +        return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, defaultItem));, +     * Returns a Maybe that emits only the very first item emitted by the source ObservableSource, or, +     * completes if the source ObservableSource is empty., +     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return the new Maybe instance, +    public final Maybe<T> firstElement() {, +        return elementAt(0L);, +     * Returns a Single that emits only the very first item emitted by the source ObservableSource, or a default, +     * @return the new Single instance, +    public final Single<T> first(T defaultItem) {, +        return elementAt(0L, defaultItem);, +     * @return the new Completable instance, +    public final Completable ignoreElements() {]