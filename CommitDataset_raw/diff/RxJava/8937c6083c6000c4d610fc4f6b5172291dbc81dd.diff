[+++ b/src/main/java/rx/Observable.java, +     * Returns an Observable that emits items emitted by the source Observable, checks the specified predicate, +     * for each item, and then completes if the condition is satisfied., +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is, +     * evaluated <em>after</em> the item is emitted., +     * @return an Observable that first emits items emitted by the source Observable, checks the specified, +     *         condition after each item, and then completes if the condition is satisfied., +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/main/java/rx/Observable.java, +     * Returns an Observable that emits items emitted by the source Observable, checks the specified predicate, +     * for each item, and then completes if the condition is satisfied., +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is, +     * evaluated <em>after</em> the item is emitted., +     * @return an Observable that first emits items emitted by the source Observable, checks the specified, +     *         condition after each item, and then completes if the condition is satisfied., +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/main/java/rx/exceptions/Exceptions.java, +     * @warn javadoc missing, +            throw new RuntimeException(t);, +, +++ b/src/main/java/rx/Observable.java, +     * Returns an Observable that emits items emitted by the source Observable, checks the specified predicate, +     * for each item, and then completes if the condition is satisfied., +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is, +     * evaluated <em>after</em> the item is emitted., +     * @return an Observable that first emits items emitted by the source Observable, checks the specified, +     *         condition after each item, and then completes if the condition is satisfied., +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/main/java/rx/exceptions/Exceptions.java, +     * @warn javadoc missing, +            throw new RuntimeException(t);, +, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.exceptions.CompositeException;, +import rx.exceptions.Exceptions;, +import rx.exceptions.MissingBackpressureException;, +import rx.functions.Action0;, +import rx.functions.Action1;, +import rx.functions.Func1;, +            if (errors != null) {, +                if (errors.size() == 1) {, +                    Exceptions.propagate(errors.get(0));, +                } else {, +                    throw new CompositeException("Errors while emitting onError", errors);, +                }, +            }, +++ b/src/main/java/rx/Observable.java, +     * Returns an Observable that emits items emitted by the source Observable, checks the specified predicate, +     * for each item, and then completes if the condition is satisfied., +     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is, +     * evaluated <em>after</em> the item is emitted., +     * @return an Observable that first emits items emitted by the source Observable, checks the specified, +     *         condition after each item, and then completes if the condition is satisfied., +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/main/java/rx/exceptions/Exceptions.java, +     * @warn javadoc missing, +            throw new RuntimeException(t);, +, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.exceptions.CompositeException;, +import rx.exceptions.Exceptions;, +import rx.exceptions.MissingBackpressureException;, +import rx.functions.Action0;, +import rx.functions.Action1;, +import rx.functions.Func1;, +            if (errors != null) {, +                if (errors.size() == 1) {, +                    Exceptions.propagate(errors.get(0));, +                } else {, +                    throw new CompositeException("Errors while emitting onError", errors);, +                }, +            }, +++ b/src/main/java/rx/internal/util/SubscriptionList.java, +import rx.exceptions.CompositeException;, +        if (es != null) {, +            if (es.size() == 1) {, +                Throwable t = es.get(0);, +                if (t instanceof RuntimeException) {, +                    throw (RuntimeException) t;, +                } else {, +                    throw new CompositeException(, +                            "Failed to unsubscribe to 1 or more subscriptions.", es);]