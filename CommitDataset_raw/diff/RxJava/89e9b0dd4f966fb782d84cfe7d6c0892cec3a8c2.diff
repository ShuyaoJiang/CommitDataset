[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.schedulers.*;, +    public static Observable<Long> timer(long delay, TimeUnit unit) {, +        return timer(delay, unit, Schedulers.computation());, +    public static Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {, +    public static Observable<Long> interval(long period, TimeUnit unit) {, +        return interval(period, period, unit, Schedulers.computation());, +    }, +, +    public static Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {, +        return interval(period, period, unit, scheduler);, +    }, +    private static <T1, T2, R> Function<Object[], R> toFunction(BiFunction<? super T1, ? super T2, ? extends R> biFunction) {, +        return a -> {, +            return ((BiFunction<Object, Object, R>)biFunction).apply(a[0], a[1]);, +    public static <T1, T2, R> Observable<R> zip(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            BiFunction<? super T1, ? super T2, ? extends R> zipper) {, +        return zipArray(toFunction(zipper), false, bufferSize(), p1, p2);, +    }, +, +    public static <T1, T2, R> Observable<R> zip(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {, +        return zipArray(toFunction(zipper), delayError, bufferSize(), p1, p2);, +    }, +, +    public static <T1, T2, R> Observable<R> zip(, +            Publisher<? extends T1> p1, Publisher<? extends T2> p2, , +            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {, +        return zipArray(toFunction(zipper), delayError, bufferSize, p1, p2);, +    }, +, +    , +    public final <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {, +    , +    public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {, +        return zip(this, other, zipper);, +    }, +, +    public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {, +        return zip(this, other, zipper, delayError);, +    }, +, +    public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {, +        return zip(this, other, zipper, delayError, bufferSize);, +    }, +, +    public final <U, R> Observable<R> zipWith(Iterable<? extends U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {, +        return zip(this, new PublisherIterableSource<>(other), zipper);, +    }, +, +    public final <U, R> Observable<R> zipWith(Iterable<? extends U> other,  BiFunction<? super T, ? super U, ? extends R> zipper, int bufferSize) {, +        return zip(this, new PublisherIterableSource<>(other), zipper, false, bufferSize);, +    }, +, +    public static <T, R> Observable<R> zip(Publisher<? extends Publisher<? extends T>> sources, Function<Object[], R> zipper) {, +        return fromPublisher(sources).toList().flatMap(list -> {, +            return zipIterable(zipper, false, bufferSize(), list);, +        });, +    }, +    , +    public final <U> Observable<U> cast(Class<U> clazz) {, +        return map(clazz::cast);, +    }, +    , +    public final Observable<Boolean> contains(Object o) {, +        return any(v -> Objects.equals(v, o));, +    }, +    , +    /**, +     * @deprecated use {@link #any(Predicate)}, +     */, +    @Deprecated, +    public final Observable<Boolean> exists(Predicate<? super T> predicate) {, +        return any(predicate);, +    }, +    , +    public final <U> Observable<U> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {, +        return flatMap(v -> new PublisherIterableSource<>(mapper.apply(v)));, +    }, +, +    public final <U> Observable<U> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {, +        return flatMap(v -> new PublisherIterableSource<>(mapper.apply(v)), false, bufferSize);, +    }, +, +    public final <U> Observable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {, +        return concatMap(v -> new PublisherIterableSource<>(mapper.apply(v)));, +    }, +    , +    public final <U> Observable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {, +        return concatMap(v -> new PublisherIterableSource<>(mapper.apply(v)), prefetch);, +    }, +, +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError) {, +        return flatMap(mapper, combiner, delayError, bufferSize(), bufferSize());, +    }, +    , +    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {, +        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());]