[+++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +        val merged = Observable.merge(observable1, observable2), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +        val merged = Observable.merge(observable1, observable2), +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * @param t1, +     *            an Observable to be merged, +     * @param t2, +     *            an Observable to be merged, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +    public static <T> Observable<T> mergeDelayError(Observable<? extends T> t1, Observable<? extends T> t2) {, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2));, +    }, +    , +    /**, +     * This behaves like {@link #merge(Observable...)} except that if any of the merged Observables, +     * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will, +     * refrain from propagating that error notification until all of the merged Observables have, +     * finished emitting items., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">, +     * <p>, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Observers once., +     * <p>, +     * This method allows an Observer to receive all successfully emitted items from all of the, +     * source Observables without being interrupted by an error notification from one of them., +     * , +     * @param t1, +     *            an Observable to be merged, +     * @param t2, +     *            an Observable to be merged, +     * @param t3, +     *            an Observable to be merged, +     * @return an Observable that emits items that are the result of flattening the items emitted by, +     *         the {@code source} Observables, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a>, +     */, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +    public static <T> Observable<T> mergeDelayError(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3) {, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3));, +    }, +    , +    /**, +     * This behaves like {@link #merge(Observable...)} except that if any of the merged Observables, +     * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will, +     * refrain from propagating that error notification until all of the merged Observables have, +     * finished emitting items., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">, +     * <p>, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Observers once., +     * <p>, +     * This method allows an Observer to receive all successfully emitted items from all of the, +     * source Observables without being interrupted by an error notification from one of them., +     * , +     * @param t1, +     *            an Observable to be merged, +     * @param t2, +     *            an Observable to be merged, +     * @param t3, +     *            an Observable to be merged, +     * @param t4, +     *            an Observable to be merged, +     * @return an Observable that emits items that are the result of flattening the items emitted by, +     *         the {@code source} Observables, +     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a>, +     */, +    @SuppressWarnings("unchecked"), +    // suppress because the types are checked by the method signature before using a vararg, +    public static <T> Observable<T> mergeDelayError(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4) {, +        return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4));, +    }, +    , +    /**, +     * This behaves like {@link #merge(Observable...)} except that if any of the merged Observables, +     * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will, +     * refrain from propagating that error notification until all of the merged Observables have, +     * finished emitting items., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">, +     * <p>, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +     * Observers once., +     * <p>, +     * This method allows an Observer to receive all successfully emitted items from all of the, +     * source Observables without being interrupted by an error notification from one of them., +     * , +     * @param t1, +     *            an Observable to be merged, +     * @param t2, +     *            an Observable to be merged, +     * @param t3, +     *            an Observable to be merged, +     * @param t4, +     *            an Observable to be merged, +     * @param t5]