[+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java, +        , +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java, +        , +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java, +        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java, +        , +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java, +        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.concurrent.atomic.AtomicInteger;, +        // Stores how many observers have already completed, +        private final AtomicInteger numCompleted = new AtomicInteger(0);, +        // Used as an internal lock for handling the latest values of each observer, +        private final Object lockObject = new Object();, +            int completed = numCompleted.incrementAndGet();, +            if (completed == observers.size()) {, +                if (hasLatestValue.size() < observers.size()) {, +                , +                // if we get to here this means all the observers have a latest value]