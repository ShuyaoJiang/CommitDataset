[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  // There is no method corresponding to, +  // public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second), +  // because the Scala-idiomatic way of doing this is, +  // (first zip second) map (p => p._1 == p._2), +  , +  // There is no method corresponding to  , +  // public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality), +  // because the Scala-idiomatic way of doing this is, +  // (first zip second) map (p => equality(p._1, p._2)), +  // There is no method like, +  // public Observable<T> where(Func1<? super T, Boolean> predicate), +  // because that's called filter in Scala., +, +  // There's no method like, +  // public <R> Observable<R> mapMany(Func1<? super T, ? extends Observable<? extends R>> func), +  // because that's called flatMap in Scala., +  , +  // There is no aggregate function with signature, +  // public Observable<T> aggregate(Func2<? super T, ? super T, ? extends T> accumulator), +  // because that's called reduce in Scala., +  , +  // corresponds to Java's, +  // public <R> Observable<R> reduce(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) , +  // public <R> Observable<R> aggregate(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) , +  , +  // There is no method like, +  // public Observable<T> scan(Func2<? super T, ? super T, ? extends T> accumulator), +  // because scan has a seed in Scala, +  // corresponds to Scala's, +  // public <R> Observable<R> scan(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) , +  // corresponds to Java's, +  // public Observable<Boolean> all(Func1<? super T, Boolean> predicate) , +  // corresponds to Java's, +  // public Observable<T> skip(int num), +  // corresponds to Java's, +  // public Observable<T> takeLast(final int count) , +  // corresponds to Java's method, +  // public Observable<List<T>> toList() {, +, +  // There are no toSortedList methods because Scala can sort itself, +  // public Observable<List<T>> toSortedList() , +  // public Observable<List<T>> toSortedList(Func2<? super T, ? super T, Integer> sortFunction) , +  , +  // There is no method , +  // def startWith[U >: T](values: U*): Observable[U], +  // because we can just use ++ instead , +  // There's no method corresponding to, +  // public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) , +  // because this can be obtained by combining groupBy and map (as in Scala), +  , +  // corresponds to Java's, +  // public static <T> Observable<T> create(OnSubscribeFunc<T> func) , +  , +  // Java's, +  // public static <T> Observable<T> empty(), +  // is not needed in Scala because it's a special case of varargs apply, +  // corresponds to Java's, +  // public static <T> Observable<T> error(Throwable exception) , +  , +  // There is no method corresponding to, +  // public static <T> Observable<T> from(Iterable<? extends T> iterable) , +  // because Scala automatically uses the varargs apply for this, +  // corresponds to Java's, +  // public static <T> Observable<T> from(T... items) , +  // There is no method corresponding to, +  // public static Observable<Integer> range(int start, int count) , +  // because the Scala collection library provides enough methods to create Iterables., +  // Examples: Observable(1 to 5), Observable(1 until 10), +  , +  // corresponds to Java's, +  // public static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) , +  // corresponds to Java's, +  // public static <T> Observable<T> just(T value) , +  // There is no method corresponding to, +  // public static <T> Observable<T> concat(Observable<? extends T>... source) , +  // because we have the instance method ++ instead, +  , +  // There is no method corresponding to, +  // public static <T> Observable<T> switchDo(Observable<? extends Observable<? extends T>> sequenceOfSequences) , +  // because it's deprecated., +    , +  // There's no , +  // public static <T> Observable<T> switchOnNext(Observable<? extends Observable<? extends T>> sequenceOfSequences), +  // here because that's an instance method., +  , +  // There is no method here corresponding to, +  // public static <T> Observable<T> synchronize(Observable<? extends T> observable) , +  // because that's an instance method., +, +  // corresponds to, +  // public static <T> Observable<T> from(Future<? extends T> future), +  // public static <T> Observable<T> from(Future<? extends T> future, Scheduler scheduler), +  // corresponds to, +  // public static <T> Observable<T> from(Future<? extends T> future, long timeout, TimeUnit unit), +  , +  // There is no method here corresponding to, +  // public static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> zipFunction), +  // because it's an instance method, +  ]