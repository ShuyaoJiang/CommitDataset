[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +        observable (rx/observable* (fn [observer], +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +        observable (rx/observable* (fn [observer], +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +; Tools for creating new operators and observables, +, +(declare unsubscribed?), +, +(defn ^Subscriber subscriber, +  "", +  ([o on-next-action] (subscriber o on-next-action nil nil)), +  ([o on-next-action on-error-action] (subscriber o on-next-action on-error-action nil)), +  ([^Subscriber o on-next-action on-error-action on-completed-action], +   (proxy [Subscriber] [o], +     (onCompleted [], +       (if on-completed-action, +         (on-completed-action o), +         (on-completed o))), +     (onError [e], +       (if on-error-action, +         (on-error-action o e), +         (on-error o e))), +     (onNext [t], +       (if on-next-action, +         (on-next-action o t), +         (on-next o t)))))), +, +(defn ^Subscription subscription, +  "Create a new subscription that calls the given no-arg handler function when, +  unsubscribe is called, +, +  See:, +    rx.subscriptions.Subscriptions/create, +  ", +  [handler], +  (Subscriptions/create ^Action0 (iop/action* handler))), +, +(defn ^Observable$Operator operator*, +  "Returns a new implementation of rx.Observable$Operator that calls the given, +  function with a rx.Subscriber. The function should return a rx.Subscriber., +, +  See:, +    lift, +    rx.Observable$Operator, +  ", +  [f], +  {:pre [(fn? f)]}, +  (reify Observable$Operator, +    (call [this o], +      (f o)))), +, +(defn ^Observable observable*, +  "Create an Observable from the given function., +, +  When subscribed to, (f subscriber) is called at which point, f can start emitting values, etc., +  The passed subscriber is of type rx.Subscriber., +, +  See:, +    rx.Subscriber, +    rx.Observable/create, +  ", +  [f], +  (Observable/create ^Observable$OnSubscribe (iop/action* f))), +, +(defn wrap-on-completed, +  "Wrap handler with code that automaticaly calls rx.Observable.onCompleted.", +  [handler], +  (fn [^Observer observer], +    (handler observer), +    (when-not (unsubscribed? observer), +      (.onCompleted observer)))), +, +(defn wrap-on-error, +  "Wrap handler with code that automaticaly calls (on-error) if an exception is thrown", +  [handler], +  (fn [^Observer observer], +    (try, +      (handler observer), +      (catch Throwable e, +        (when-not (unsubscribed? observer), +          (.onError observer e)))))), +, +(defn lift, +  "Lift the Operator op over the given Observable xs, +, +  Example:, +, +    (->> my-observable, +         (rx/lift (rx/operator ...)), +         ...), +, +  See:, +    rx.Observable/lift, +    operator, +  ", +  [^Observable$Operator op ^Observable xs], +  (.lift xs op)), +, +;################################################################################]