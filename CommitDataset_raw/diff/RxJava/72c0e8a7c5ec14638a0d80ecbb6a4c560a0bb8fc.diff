[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + , +  import scala.collection.JavaConverters._, +   * Returns an Observable formed from this Observable and another Observable by combining , +   * corresponding elements in pairs. , +   * The number of {@code onNext} invocations of the resulting {@code Observable[(T, U)]}, +   * is the minumum of the number of {@code onNext} invocations of {@code this} and {@code that}. , +  def buffer(bufferClosingSelector: () => Observable[Closing]) : Observable[java.util.List[_ <: T]] = {, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(f), +    val oScala1: Observable[java.util.List[_]] = new Observable[java.util.List[_]](oJava), +    oScala1.asInstanceOf[Observable[java.util.List[_ <: T]]], +  // TODO decide whether to return Java list or Scala list , +  , +  def bufferReturningScalaList(bufferClosingSelector: () => Observable[Closing]) : Observable[List[T]] = {, +    val f: rx.util.functions.Func0[_ <: rx.Observable[_ <: Closing]] = bufferClosingSelector().asJava, +    val oJava: rx.Observable[_ <: java.util.List[_]] = asJava.buffer(f), +    val oScala1: Observable[java.util.List[_]] = new Observable[java.util.List[_]](oJava), +    val oScala2 = oScala1.map((lJava: java.util.List[_]) => {, +      val bufferScala: scala.collection.mutable.Buffer[_] = lJava.asScala, +      val listScala: List[Any] = bufferScala.toList, +      listScala.asInstanceOf[List[T]], +    }), +    oScala2, +  }, +  def buffer(bufferOpenings: Observable[Opening], bufferClosingSelector: Opening => Observable[Closing]): Observable[List[T]] = {, +    ???, +  }, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJava.window(func), +    val o2 = new Observable[rx.Observable[_]](o1).map((x: rx.Observable[_]) => {, +      val x2 = x.asInstanceOf[rx.Observable[_ <: T]], +      new Observable[T](x2), +    }), +    o2, +    new Observable[Notification[T]](asJava.materialize()), +  }, +  def dematerialize[Notif >: T <: Notification[U], U]: Observable[U] = {, +    val o: rx.Observable[Nothing] = asJava.dematerialize(), +    new Observable[U](o.asInstanceOf[rx.Observable[U]]), +  }, +  import scala.collection.JavaConverters._, +  @Test def testDematerialize() {, +    val o = Observable(1, 2, 3), +    val mat = o.materialize, +    val demat = mat.dematerialize[Notification[Int], Int], +    , +    // correctly rejected:, +    // val wrongDemat = mat.dematerialize[Notification[String], String], +    , +    // inferring the type parameters is not (yet?) possible:, +    // val demat2 = mat.dematerialize, +    , +    assertEquals(demat.toBlockingObservable.toIterable().asScala.toList, List(1, 2, 3)), +  }, +  ]