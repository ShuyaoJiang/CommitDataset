[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +, +  def items[T](items: T*): Observable[T] = {, +    toScalaObservable[T](rx.Observable.from(items.toIterable.asJava)), +  }, +, +   * @param T the type of items in the `Iterable` sequence and the, +   *, +   * @param iterable  the source `Iterable` sequence, +   * @param scheduler the scheduler to use, +   * @tparam T   the type of items in the `Iterable` sequence and the, +   *            type of items to be emitted by the resulting Observable, +   * @return   an Observable that emits each item in the source `Iterable`, +   *         sequence, +   */, +  def from[T](iterable: Iterable[T], scheduler: Scheduler): Observable[T] = {, +    toScalaObservable(rx.Observable.from(iterable.asJava, scheduler.asJavaScheduler)), +  }, +, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +, +  def items[T](items: T*): Observable[T] = {, +    toScalaObservable[T](rx.Observable.from(items.toIterable.asJava)), +  }, +, +   * @param T the type of items in the `Iterable` sequence and the, +   *, +   * @param iterable  the source `Iterable` sequence, +   * @param scheduler the scheduler to use, +   * @tparam T   the type of items in the `Iterable` sequence and the, +   *            type of items to be emitted by the resulting Observable, +   * @return   an Observable that emits each item in the source `Iterable`, +   *         sequence, +   */, +  def from[T](iterable: Iterable[T], scheduler: Scheduler): Observable[T] = {, +    toScalaObservable(rx.Observable.from(iterable.asJava, scheduler.asJavaScheduler)), +  }, +, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observer.scala, +  // Java calls XXX, Scala receives XXX, +  private [scala] val asJavaObserver: rx.Observer[_ >: T] = new rx.Observer[T] {, +    def onNext(value: T): Unit = Observer.this.onNext(value), +    def onError(error: Throwable): Unit = Observer.this.onError(error), +    def onCompleted(): Unit = Observer.this.onCompleted(), +  }, +  def onNext(value: T): Unit = {}, +  def onError(error: Throwable): Unit= {}, +  def onCompleted(): Unit = {}, +       override val asJavaObserver = observer, +       override def onNext(value: T): Unit = asJavaObserver.onNext(value), +       override def onError(error: Throwable): Unit = asJavaObserver.onError(error), +       override def onCompleted(): Unit = asJavaObserver.onCompleted(), +  def apply[T](onNext: T=>Unit, onError: Throwable=>Unit, onCompleted: ()=>Unit): Observer[T] = {, +      val n = onNext; val e = onError; val c = onCompleted, +         override def onNext(value: T): Unit = n(value), +         override def onError(error: Throwable): Unit = e(error), +         override def onCompleted(): Unit = c(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +, +  def items[T](items: T*): Observable[T] = {, +    toScalaObservable[T](rx.Observable.from(items.toIterable.asJava)), +  }, +, +   * @param T the type of items in the `Iterable` sequence and the, +   *, +   * @param iterable  the source `Iterable` sequence, +   * @param scheduler the scheduler to use, +   * @tparam T   the type of items in the `Iterable` sequence and the, +   *            type of items to be emitted by the resulting Observable, +   * @return   an Observable that emits each item in the source `Iterable`, +   *         sequence, +   */, +  def from[T](iterable: Iterable[T], scheduler: Scheduler): Observable[T] = {, +    toScalaObservable(rx.Observable.from(iterable.asJava, scheduler.asJavaScheduler)), +  }, +, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observer.scala, +  // Java calls XXX, Scala receives XXX, +  private [scala] val asJavaObserver: rx.Observer[_ >: T] = new rx.Observer[T] {, +    def onNext(value: T): Unit = Observer.this.onNext(value), +    def onError(error: Throwable): Unit = Observer.this.onError(error), +    def onCompleted(): Unit = Observer.this.onCompleted(), +  }, +  def onNext(value: T): Unit = {}, +  def onError(error: Throwable): Unit= {}, +  def onCompleted(): Unit = {}, +       override val asJavaObserver = observer, +       override def onNext(value: T): Unit = asJavaObserver.onNext(value), +       override def onError(error: Throwable): Unit = asJavaObserver.onError(error), +       override def onCompleted(): Unit = asJavaObserver.onCompleted(), +  def apply[T](onNext: T=>Unit, onError: Throwable=>Unit, onCompleted: ()=>Unit): Observer[T] = {]