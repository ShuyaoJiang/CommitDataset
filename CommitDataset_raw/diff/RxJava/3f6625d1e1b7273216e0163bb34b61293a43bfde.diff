[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * register itself to receive push-based notifications from the Observable. A typical, +     * implementation of the <code>subscribe</code> method does the following:, +     * It returns a reference to the {@link Subscription} interface. This enables Observers to, +     * unsubscribe (that is, to stop receiving notifications) before the Observable stops sending, +     * them and calls the Observer's {@link Observer#onCompleted()} method., +     * An <code>Observable<T></code> instance is responsible for accepting all subscriptions and, +     * notifying all subscribers. Unless the documentation for a particular, +     * <code>Observable<T></code> implementation indicates otherwise, Observers should make no, +     * assumptions about the <code>Observable<T></code> implementation, such as in what order, +     * multiple Observers will receive their notifications., +     * @return a {@link Subscription} reference that allows Observers to stop receiving, +     *             notifications before the Observable has finished sending them, +     *             if the Observer provided as the argument to subscribe() is null, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * register itself to receive push-based notifications from the Observable. A typical, +     * implementation of the <code>subscribe</code> method does the following:, +     * It returns a reference to the {@link Subscription} interface. This enables Observers to, +     * unsubscribe (that is, to stop receiving notifications) before the Observable stops sending, +     * them and calls the Observer's {@link Observer#onCompleted()} method., +     * An <code>Observable<T></code> instance is responsible for accepting all subscriptions and, +     * notifying all subscribers. Unless the documentation for a particular, +     * <code>Observable<T></code> implementation indicates otherwise, Observers should make no, +     * assumptions about the <code>Observable<T></code> implementation, such as in what order, +     * multiple Observers will receive their notifications., +     *            the {@link Scheduler} that the sequence is subscribed to on, +     * @return a {@link Subscription} reference that allows Observers to stop receiving, +     *             notifications before the Observable has finished sending them, +     *             if an argument to <code>subscribe()</code> is <codee>null</code>, +     * Returns a connectable Observable that upon connection causes the source sequence to, +     * push results into the specified subject., +     *            the subject for the connectable Observable to push source elements into, +     * @return a connectable Observable that upon connection causes the source sequence to push, +     *         results into the specified subject, +     * Creates an Observable that will execute the given function when a {@link Observer}, +     * subscribes to it., +     * Write the function you pass to <code>create</code> so that it behaves as an Observable: It, +     * should call the Observer's <code>onNext</code>, <code>onError</code>, and, +     * <code>onCompleted</code> methods appropriately., +     * A well-formed Observable must call either the {@link Observer}'s <code>onCompleted</code>, +     * method exactly once or its <code>onError</code> method exactly once., +     * See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a>, +     * for detailed information., +     *            the type of the values that this Observable sequence emits, +     *            a function that accepts an <code>Observer<T></code>, calls its, +     *            <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods, +     *            as appropriate, and returns a {@link Subscription} to allow canceling the, +     *            subscription (if applicable), +     * @return an Observable that, when an {@link Observer} subscribes to it, will execute the given, +     *         function, +     * Creates an Observable that will execute the given function when a {@link Observer}, +     * subscribes to it., +     * This method accept {@link Object} to allow different languages to pass in closures using, +     * {@link FunctionLanguageAdaptor}., +     * Write the function you pass to <code>create</code> so that it behaves as an Observable: It, +     * should call the Observer's <code>onNext</code>, <code>onError</code>, and, +     * <code>onCompleted</code> methods appropriately., +     * A well-formed Observable must call either the {@link Observer}'s <code>onCompleted</code>, +     * method exactly once or its <code>onError</code> method exactly once., +     * See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a>, +     * for detailed information., +     *            the type of the values that this Observable sequence emits, +     *            a function that accepts an <code>Observer<T></code>, calls its, +     *            <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods, +     *            as appropriate, and returns a {@link Subscription} to allow canceling the, +     *            subscription (if applicable), +     * @return an Observable that, when an {@link Observer} subscribes to it, will execute the given, +     *         function, +     * Returns an Observable that emits no data to the {@link Observer} and immediately invokes, +     * its <code>onCompleted</code> method., +     *            the type of the values (ostensibly) emitted by the Observable, +     * @return an Observable that returns no data to the {@link Observer} and immediately invokes, +     *         the {@link Observer}'s <code>onCompleted</code> method, +     *            the type of the values (ostensibly) emitted by the Observable, +     * @return an Observable object that calls <code>onError</code> when an {@link Observer}, +     *         subscribes, +     *            a function that evaluates the items emitted by the source Observable, returning, +     *            <code>true</code> if they pass the filter, +     * @return an Observable that emits only those items in the original Observable that the filter, +     *         evaluates as true, +     *            a function that evaluates an item emitted by the source Observable, and, +     *            returns <code>true</code> if it passes the filter, +     * @return an Observable that emits only those items in the original Observable that the filter, +     *         evaluates as true, +     *            a function that evaluates an item emitted by the source Observable, and, +     *            returns <code>true</code> if it passes the filter, +     * @return an Observable that emits only those items in the original Observable that the filter, +     *         evaluates as true, +     *            the type of items in the {@link Iterable} sequence and the type emitted by the, +     *            resulting Observable, +     *            the type of items in the Array, and the type of items emitted by the resulting, +     *            Observable, +     *            the value of the first integer in the sequence, +     *            the number of sequential integers to generate, +     * @return an Observable that emits a range of sequential integers, +     * Asynchronously subscribes and unsubscribes Observers on the specified Scheduler., +     *            the source Observable, +     *            the Scheduler to perform subscription and unsubscription actions on, +     *            the type of the values emitted by the Observable]