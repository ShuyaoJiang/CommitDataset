[+++ b/rxjava-core/src/main/java/rx/Observable.java, +                return ReplaySubject.<T>createWithSize(bufferSize);, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithSize(bufferSize));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler));, +                        ReplaySubject.<T>createWithSize(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTime(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +                return ReplaySubject.<T>createWithSize(bufferSize);, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithSize(bufferSize));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler));, +                        ReplaySubject.<T>createWithSize(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTime(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorReplay.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +                return ReplaySubject.<T>createWithSize(bufferSize);, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithSize(bufferSize));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler));, +                        ReplaySubject.<T>createWithSize(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTime(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorReplay.java, +++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java, +                NotificationLite<T> nl = NotificationLite.instance();, +                if (v == null || (!nl.isCompleted(v) && !nl.isError(v))) {, +                    o.onCompleted();, +                }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +                return ReplaySubject.<T>createWithSize(bufferSize);, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithSize(bufferSize));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler));, +                        ReplaySubject.<T>createWithSize(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTime(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorReplay.java, +++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java, +                NotificationLite<T> nl = NotificationLite.instance();, +                if (v == null || (!nl.isCompleted(v) && !nl.isError(v))) {, +                    o.onCompleted();, +                }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +                return ReplaySubject.<T>createWithSize(bufferSize);, +                return ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler);, +                return OperatorReplay.<T> createScheduledSubject(ReplaySubject.<T>createWithSize(bufferSize), scheduler);, +                return ReplaySubject.<T>createWithTime(time, unit, scheduler);, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithSize(bufferSize));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTimeAndSize(time, unit, bufferSize, scheduler));, +                        ReplaySubject.<T>createWithSize(bufferSize), scheduler));, +        return new OperatorMulticast<T, T>(this, ReplaySubject.<T>createWithTime(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorReplay.java, +++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java, +                NotificationLite<T> nl = NotificationLite.instance();, +                if (v == null || (!nl.isCompleted(v) && !nl.isError(v))) {, +                    o.onCompleted();, +                }, +++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java, +++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.Scheduler;, +import rx.functions.Func1;, +import rx.functions.Functions;, +import rx.schedulers.Timestamped;, +import rx.subjects.ReplaySubject.NodeList.Node;, + * @param <T> the input and output type, +    /**, +     * Create an unbounded replay subject., +     * <p>The internal buffer is backed by an {@link ArrayList} and starts with, +     * an initial capacity of 16. Once the number of elements reaches this capacity,, +     * it will grow as necessary (usually by 50%). However, as the number of, +     * elements grows, this causes frequent array reallocation and copying, and, +     * may hurt performance and latency. This can be avoided with the {@link #create(int)}, +     * overload which takes an initial capacity parameter and can be tuned to, +     * reduce the array reallocation frequency as needed., +     * @param <T> The input and output types, +     * @return the created subject, +     */, +    /**, +     * Create an unbounded replay subject with the specified initial buffer capacity., +     * <p>Use this method to avoid excessive array reallocation while the internal, +     * buffer grows to accomodate new elements. For example, if it is known that the, +     * buffer will hold 32k elements, one can ask the ReplaySubject to preallocate, +     * it internal array with a capacity to hold that many elements. Once the elements, +     * start to arrive, the internal array won't need to grow, creating less garbage and, +     * no overhead due to frequent array-copying., +     * @param <T> The input and output types, +     * @param capacity the initial buffer capacity, +     * @return the created subject, +     */, +    public static <T> ReplaySubject<T> create(int capacity) {]