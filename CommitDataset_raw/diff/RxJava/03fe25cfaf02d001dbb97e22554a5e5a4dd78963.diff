[+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java, +import java.util.NoSuchElementException;, +                return mostRecentObserver.getIterable();, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /**, +         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one, +         * thread expect {@link Iterator#next()} called from a different thread to work., +         * @return, +         */, +        public Iterator<T> getIterable() {, +            return new Iterator<T>() {, +                /**, +                 * buffer to make sure that the state of the iterator doesn't change between calling hasNext() and next()., +                 */, +                private Object buf = null;, +, +                @Override, +                public boolean hasNext() {, +                    buf = value;, +                    return !nl.isCompleted(buf);, +                @Override, +                public T next() {, +                    try {, +                        // if hasNext wasn't called before calling next., +                        if (buf == null), +                            buf = value;, +                        if (nl.isCompleted(buf)), +                            throw new NoSuchElementException();, +                        if (nl.isError(buf)) {, +                            throw Exceptions.propagate(nl.getError(buf));, +                        }, +                        return nl.getValue(buf);, +                    }, +                    finally {, +                        buf = null;, +                    }, +                @Override, +                public void remove() {, +                    throw new UnsupportedOperationException("Read only iterator");, +            };, +        }, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java, +import java.util.NoSuchElementException;, +                return mostRecentObserver.getIterable();, +        final NotificationLite<T> nl = NotificationLite.instance();, +        /**, +         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one, +         * thread expect {@link Iterator#next()} called from a different thread to work., +         * @return, +         */, +        public Iterator<T> getIterable() {, +            return new Iterator<T>() {, +                /**, +                 * buffer to make sure that the state of the iterator doesn't change between calling hasNext() and next()., +                 */, +                private Object buf = null;, +, +                @Override, +                public boolean hasNext() {, +                    buf = value;, +                    return !nl.isCompleted(buf);, +                @Override, +                public T next() {, +                    try {, +                        // if hasNext wasn't called before calling next., +                        if (buf == null), +                            buf = value;, +                        if (nl.isCompleted(buf)), +                            throw new NoSuchElementException();, +                        if (nl.isError(buf)) {, +                            throw Exceptions.propagate(nl.getError(buf));, +                        }, +                        return nl.getValue(buf);, +                    }, +                    finally {, +                        buf = null;, +                    }, +                @Override, +                public void remove() {, +                    throw new UnsupportedOperationException("Read only iterator");, +            };, +        }, +++ b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorMostRecentTest.java, +    @Test, +    public void testMostRecentNull() {, +        assertEquals(null, Observable.<Void>never().toBlocking().mostRecent(null).iterator().next());, +    }]