[+++ b/src/main/java/io/reactivex/Flowable.java, +        return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Flowable.java, +        return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Observable.java, +        return subscribeWith(new FutureObserver<T>());, +++ b/src/main/java/io/reactivex/Flowable.java, +        return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Observable.java, +        return subscribeWith(new FutureObserver<T>());, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromRunnable(run);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Runnable that is, +     * executed exactly once when the Disposable is disposed., +     * @param run the Runnable to wrap, +     * @return the new Disposable instance, +     */, +    public static Disposable fromRunnable(Runnable run) {, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromAction(run);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Action that is, +     * executed exactly once when the Disposable is disposed., +     * @param run the Action to wrap, +     * @return the new Disposable instance, +     */, +    public static Disposable fromAction(Action run) {, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromFuture(future, true);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Runnable that is, +     * executed exactly once when the Disposable is disposed., +     * @param future the Runnable to wrap, +     * @param allowInterrupt if true, the future cancel happens via Future.cancel(true), +     * @return the new Disposable instance, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +     */, +    @Deprecated, +    public static Disposable from(Future<?> future, boolean allowInterrupt) {, +        return fromFuture(future, allowInterrupt);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Future that is, +     * cancelled exactly once when the Disposable is disposed., +     * @param future the Future to wrap, +     * @return the new Disposable instance, +     */, +    public static Disposable fromFuture(Future<?> future) {, +        return fromFuture(future, true);, +    public static Disposable fromFuture(Future<?> future, boolean allowInterrupt) {, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromSubscription(subscription);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Subscription that is, +     * cancelled exactly once when the Disposable is disposed., +     * @param subscription the Runnable to wrap, +     * @return the new Disposable instance, +     */, +    public static Disposable fromSubscription(Subscription subscription) {, +        return fromRunnable(Functions.EMPTY_RUNNABLE);, +++ b/src/main/java/io/reactivex/Flowable.java, +        return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Observable.java, +        return subscribeWith(new FutureObserver<T>());, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromRunnable(run);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Runnable that is, +     * executed exactly once when the Disposable is disposed., +     * @param run the Runnable to wrap, +     * @return the new Disposable instance, +     */, +    public static Disposable fromRunnable(Runnable run) {, +     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, +    @Deprecated, +        return fromAction(run);, +    }, +, +    /**, +     * Construct a Disposable by wrapping a Action that is, +     * executed exactly once when the Disposable is disposed.]