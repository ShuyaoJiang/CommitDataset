[+++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java, +            source.unsafeSubscribe(Subscribers.from(cache));, +             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values., +++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java, +            source.unsafeSubscribe(Subscribers.from(cache));, +             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values., +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                    OriginSubscriber<T> s = requestHandler.state.getOrigin();, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +            add(buffer);, +     * This does however mean we can't rely on a reference to State being consistent. For example, it can end up with a null OriginSubscriber. , +     * , +        , +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber != null) {, +                drainQueue(originSubscriber);, +            }, +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber == null) {, +                // unsubscribed so break ... we are done, +                return;, +            if (notifier.isCompleted(t)) {, +                originSubscriber.buffer.onCompleted();, +            } else {, +                originSubscriber.buffer.onNext(notifier.getValue(t));, +            }, +            drainQueue(originSubscriber);, +        public void drainQueue(OriginSubscriber<T> originSubscriber) {, +                        Object o = originSubscriber.buffer.poll();, +++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java, +            source.unsafeSubscribe(Subscribers.from(cache));, +             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values., +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                    OriginSubscriber<T> s = requestHandler.state.getOrigin();, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +            add(buffer);, +     * This does however mean we can't rely on a reference to State being consistent. For example, it can end up with a null OriginSubscriber. , +     * , +        , +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber != null) {, +                drainQueue(originSubscriber);, +            }, +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber == null) {, +                // unsubscribed so break ... we are done, +                return;, +            if (notifier.isCompleted(t)) {, +                originSubscriber.buffer.onCompleted();, +            } else {, +                originSubscriber.buffer.onNext(notifier.getValue(t));, +            }, +            drainQueue(originSubscriber);, +        public void drainQueue(OriginSubscriber<T> originSubscriber) {, +                        Object o = originSubscriber.buffer.poll();, +++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +                        if (subscriber.isUnsubscribed()), +                            return;, +++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java, +            source.unsafeSubscribe(Subscribers.from(cache));, +             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values., +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                    OriginSubscriber<T> s = requestHandler.state.getOrigin();, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +            add(buffer);, +     * This does however mean we can't rely on a reference to State being consistent. For example, it can end up with a null OriginSubscriber. , +     * , +        , +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber != null) {, +                drainQueue(originSubscriber);, +            }, +            OriginSubscriber<T> originSubscriber = state.getOrigin();, +            if(originSubscriber == null) {, +                // unsubscribed so break ... we are done, +                return;, +            if (notifier.isCompleted(t)) {, +                originSubscriber.buffer.onCompleted();, +            } else {, +                originSubscriber.buffer.onNext(notifier.getValue(t));, +            }, +            drainQueue(originSubscriber);, +        public void drainQueue(OriginSubscriber<T> originSubscriber) {, +                        Object o = originSubscriber.buffer.poll();, +++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +                        if (subscriber.isUnsubscribed()), +                            return;, +++ b/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java, +import rx.internal.operators.OnSubscribeCache;, +++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java, +            source.unsafeSubscribe(Subscribers.from(cache));, +             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values., +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +                    OriginSubscriber<T> s = requestHandler.state.getOrigin();, +        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();, +            add(buffer);, +     * This does however mean we can't rely on a reference to State being consistent. For example, it can end up with a null OriginSubscriber. , +     * , +        , +            OriginSubscriber<T> originSubscriber = state.getOrigin();]