[+++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java, +    /** Indicates that the parent tracking this task has been notified about its completion. */, +    static final Object PARENT_DISPOSED = new Object();, +    /** Indicates the dispose() was called from within the run/call method. */, +    static final Object SYNC_DISPOSED = new Object();, +    /** Indicates the dispose() was called from another thread. */, +    static final Object ASYNC_DISPOSED = new Object();, +            if (o != PARENT_DISPOSED && compareAndSet(PARENT_INDEX, o, DONE) && o != null) {, +                if (o == SYNC_DISPOSED || o == ASYNC_DISPOSED || compareAndSet(FUTURE_INDEX, o, DONE)) {, +            if (o == SYNC_DISPOSED) {, +                f.cancel(false);, +                return;, +            }, +            if (o == ASYNC_DISPOSED) {, +                f.cancel(true);, +            if (o == DONE || o == SYNC_DISPOSED || o == ASYNC_DISPOSED) {, +            boolean async = get(THREAD_INDEX) != Thread.currentThread();, +            if (compareAndSet(FUTURE_INDEX, o, async ? ASYNC_DISPOSED : SYNC_DISPOSED)) {, +                    ((Future<?>)o).cancel(async);, +            if (o == DONE || o == PARENT_DISPOSED || o == null) {, +            if (compareAndSet(PARENT_INDEX, o, PARENT_DISPOSED)) {, +        Object o = get(PARENT_INDEX);, +        return o == PARENT_DISPOSED || o == DONE;, +++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java, +    /** Indicates that the parent tracking this task has been notified about its completion. */, +    static final Object PARENT_DISPOSED = new Object();, +    /** Indicates the dispose() was called from within the run/call method. */, +    static final Object SYNC_DISPOSED = new Object();, +    /** Indicates the dispose() was called from another thread. */, +    static final Object ASYNC_DISPOSED = new Object();, +            if (o != PARENT_DISPOSED && compareAndSet(PARENT_INDEX, o, DONE) && o != null) {, +                if (o == SYNC_DISPOSED || o == ASYNC_DISPOSED || compareAndSet(FUTURE_INDEX, o, DONE)) {, +            if (o == SYNC_DISPOSED) {, +                f.cancel(false);, +                return;, +            }, +            if (o == ASYNC_DISPOSED) {, +                f.cancel(true);, +            if (o == DONE || o == SYNC_DISPOSED || o == ASYNC_DISPOSED) {, +            boolean async = get(THREAD_INDEX) != Thread.currentThread();, +            if (compareAndSet(FUTURE_INDEX, o, async ? ASYNC_DISPOSED : SYNC_DISPOSED)) {, +                    ((Future<?>)o).cancel(async);, +            if (o == DONE || o == PARENT_DISPOSED || o == null) {, +            if (compareAndSet(PARENT_INDEX, o, PARENT_DISPOSED)) {, +        Object o = get(PARENT_INDEX);, +        return o == PARENT_DISPOSED || o == DONE;, +++ b/src/test/java/io/reactivex/internal/schedulers/ScheduledRunnableTest.java, +import java.util.concurrent.atomic.*;, +, +    @Test, +    public void syncWorkerCancelRace() {, +        for (int i = 0; i < 10000; i++) {, +            final CompositeDisposable set = new CompositeDisposable();, +            final AtomicBoolean interrupted = new AtomicBoolean();, +            final AtomicInteger sync = new AtomicInteger(2);, +            final AtomicInteger syncb = new AtomicInteger(2);, +, +            Runnable r0 = new Runnable() {, +                @Override, +                public void run() {, +                    set.dispose();, +                    if (sync.decrementAndGet() != 0) {, +                        while (sync.get() != 0) { }, +                    }, +                    if (syncb.decrementAndGet() != 0) {, +                        while (syncb.get() != 0) { }, +                    }, +                    for (int j = 0; j < 1000; j++) {, +                        if (Thread.currentThread().isInterrupted()) {, +                            interrupted.set(true);, +                            break;, +                        }, +                    }, +                }, +            };, +, +            final ScheduledRunnable run = new ScheduledRunnable(r0, set);, +            set.add(run);, +, +            final FutureTask<Void> ft = new FutureTask<Void>(run, null);, +, +            Runnable r2 = new Runnable() {, +                @Override, +                public void run() {, +                    if (sync.decrementAndGet() != 0) {, +                        while (sync.get() != 0) { }, +                    }, +                    run.setFuture(ft);, +                    if (syncb.decrementAndGet() != 0) {, +                        while (syncb.get() != 0) { }, +                    }, +                }, +            };, +, +            TestHelper.race(ft, r2);, +, +            assertFalse("The task was interrupted", interrupted.get());, +        }, +    }, +]