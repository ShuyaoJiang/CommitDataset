[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.OnErrorNotImplementedException;, +     * Observable with Function to execute when subscribed to., +     * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you specifically have a need for inheritance., +    protected Observable() {, +        this(null);, +        //TODO should this be made private to prevent it? It really serves no good purpose and only confuses things. Unit tests are incorrectly using it today, +    }, +, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * register itself to receive push-based notifications from the Observable. A typical, +     * implementation of the <code>subscribe</code> method does the following:, +     * It returns a reference to the {@link Subscription} interface. This enables Observers to, +     * unsubscribe (that is, to stop receiving notifications) before the Observable stops sending, +     * them and invokes the Observer's {@link Observer#onCompleted()} method., +     * An <code>Observable<T></code> instance is responsible for accepting all subscriptions and, +     * notifying all Observers. Unless the documentation for a particular, +     * <code>Observable<T></code> implementation indicates otherwise, Observers should make no, +     * assumptions about the <code>Observable<T></code> implementation, such as in what order, +     * multiple Observers will receive their notifications., +     * @return a {@link Subscription} reference that allows Observers to stop receiving, +     *             notifications before the Observable has finished sending them, +     * @throws IllegalArgumentException, +     *             if the Observer provided as the argument to subscribe() is null, +        if (observer == null) {, +            throw new IllegalArgumentException("observer can not be null");, +        }, +        } catch (OnErrorNotImplementedException e) {, +            // special handling when onError is not implemented ... we just rethrow, +            throw e;, +            } catch (OnErrorNotImplementedException e2) {, +                // special handling when onError is not implemented ... we just rethrow, +                throw e2;, +     * An {@link Observer} must call an Observable's <code>subscribe</code> method in order to, +     * register itself to receive push-based notifications from the Observable. A typical, +     * implementation of the <code>subscribe</code> method does the following:, +     * It returns a reference to the {@link Subscription} interface. This enables Observers to, +     * unsubscribe (that is, to stop receiving notifications) before the Observable stops sending, +     * them and invokes the Observer's {@link Observer#onCompleted()} method., +     * An <code>Observable<T></code> instance is responsible for accepting all subscriptions and, +     * notifying all Observers. Unless the documentation for a particular, +     * <code>Observable<T></code> implementation indicates otherwise, Observers should make no, +     * assumptions about the <code>Observable<T></code> implementation, such as in what order, +     * multiple Observers will receive their notifications., +     *            the {@link Scheduler} on which Observers subscribe to the Observable, +     * @return a {@link Subscription} reference that allows Observers to stop receiving, +     *             notifications before the Observable has finished sending them, +     * @throws IllegalArgumentException, +     *             if an argument to <code>subscribe()</code> is <code>null</code>, +        if (callbacks == null) {, +            throw new RuntimeException("callbacks map can not be null");, +        }, +            throw new RuntimeException("'onNext' key must contain an implementation");, +        // lookup and memoize onNext, +                } else {, +                    throw new OnErrorNotImplementedException(e);, +            throw new IllegalArgumentException("onNext can not be null");, +, +        // lookup and memoize onNext, +                throw new OnErrorNotImplementedException(e);, +        if (onNext == null) {, +            throw new IllegalArgumentException("onNext can not be null");, +        }, +                throw new OnErrorNotImplementedException(e);, +            throw new IllegalArgumentException("onNext can not be null");, +        if (onError == null) {, +            throw new IllegalArgumentException("onError can not be null");, +        }, +, +        // lookup and memoize onNext, +        if (onNext == null) {, +            throw new IllegalArgumentException("onNext can not be null");, +        }, +        if (onError == null) {, +            throw new IllegalArgumentException("onError can not be null");, +        }, +            throw new IllegalArgumentException("onNext can not be null");, +        if (onError == null) {, +            throw new IllegalArgumentException("onError can not be null");, +        }, +        if (onComplete == null) {, +            throw new IllegalArgumentException("onComplete can not be null");, +        }, +, +        // lookup and memoize onNext        , +        if (onNext == null) {, +            throw new IllegalArgumentException("onNext can not be null");, +        }, +        if (onError == null) {, +            throw new IllegalArgumentException("onError can not be null");, +        }, +        if (onComplete == null) {, +            throw new IllegalArgumentException("onComplete can not be null");, +        }, +     * Returns a connectable Observable that upon connection causes the source Observable to, +     * push results into the specified subject., +     *            the subject for the connectable Observable to push source items into, +     * @return a connectable Observable that upon connection causes the source Observable to push, +     *         results into the specified subject, +     * an Observable that invokes {@link Observer#onError(Exception)} when the Observer subscribes.]