[+++ b/language-adaptors/rxjava-clojure/build.gradle, +// include /src/examples folder, +sourceSets {, +    examples, +}, +, +// make 'examples' use the same classpath, +configurations {, +    examplesCompile.extendsFrom compile, +    examplesRuntime.extendsFrom runtime, +}, +, +// include 'examples' in build task, +build.dependsOn examplesClasses, +, +// setup Eclipse, +++ b/language-adaptors/rxjava-clojure/build.gradle, +// include /src/examples folder, +sourceSets {, +    examples, +}, +, +// make 'examples' use the same classpath, +configurations {, +    examplesCompile.extendsFrom compile, +    examplesRuntime.extendsFrom runtime, +}, +, +// include 'examples' in build task, +build.dependsOn examplesClasses, +, +// setup Eclipse, +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.clj, +(ns rx.lang.clojure.examples.rx-examples, +  (import rx.Observable), +  (:require [clj-http.client :as http])), +, +; NOTE on naming conventions. I'm using camelCase names (against clojure convention), +; in this file as I'm purposefully keeping functions and methods across, +; different language implementations in-sync for easy comparison., +, +; --------------------------------------------------, +; Hello World!, +; --------------------------------------------------, +, +(defn hello, +  [& args], +  (-> (Observable/toObservable args), +    (.subscribe #(println (str "Hello " % "!"))))), +, +; To see output, +(comment, +  (hello "Ben" "George")), +, +; --------------------------------------------------, +; Create Observable from Existing Data, +; --------------------------------------------------, +, +(defn existingDataFromNumbers [], +  (Observable/toObservable [1 2 3 4 5 6])), +, +(defn existingDataFromNumbersUsingFrom [], +  (Observable/from [1 2 3 4 5 6])), +, +(defn existingDataFromObjects [], +  (Observable/toObservable ["a" "b" "c"])), +, +(defn existingDataFromObjectsUsingFrom [], +  (Observable/from ["a" "b" "c"])), +, +(defn existingDataFromList [], +  (let [list [5, 6, 7, 8]], +    (Observable/toObservable list))), +, +(defn existingDataFromListUsingFrom [], +  (let [list [5, 6, 7, 8]], +    (Observable/from list))), +, +(defn existingDataWithJust [], +  (Observable/just "one object")), +, +; --------------------------------------------------, +; Custom Observable, +; --------------------------------------------------, +, +(defn customObservableBlocking [], +  "This example shows a custom Observable that blocks, +   when subscribed to (does not spawn an extra thread)., +, +  returns Observable<String>", +  (Observable/create, +    (fn [observer], +      (doseq [x (range 50)] (-> observer (.onNext (str "value_" x)))), +      ; after sending all values we complete the sequence, +      (-> observer .onCompleted), +      ; return a NoOpSubsription since this blocks and thus, +      ; can't be unsubscribed from, +      (Observable/noOpSubscription)))), +, +; To see output]