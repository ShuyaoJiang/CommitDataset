[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/CHANGES.md, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * This Observable produces connected non-overlapping buffers. The current buffer is, +   * emitted and replaced with a new buffer when the Observable produced by the specified function produces an object. The function will then, +   * be used to create a new Observable to listen for the end of the next buffer., +   *, +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every buffer created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated buffer, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping buffers, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +   */, +  def buffer(closings: () => Observable[Any]) : Observable[Seq[T]] = {, +    val f: Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Any](f), +    Observable.jObsOfListToScObsOfSeq(jObs.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  /**, +   * Creates an Observable which produces buffers of collected values., +   *, +   * @param boundary the boundary Observable, +  def buffer(boundary: Observable[Any]): Observable[Seq[T]] = {, +    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable(thisJava.buffer(boundary.asJavaObservable)).map(_.asScala), +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Any](func), +    val o2 = Observable.items(o1).map((x: rx.Observable[_]) => {, +      val x2 = x.asInstanceOf[rx.Observable[_ <: T]], +      toScalaObservable[T](x2), +    }), +    o2, +    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +    }), +   * Converts an Observable into a [[rx.lang.scala.observables.BlockingObservable]] (an Observable with blocking, +  def toBlockingObservable: BlockingObservable[T] = {, +    new BlockingObservable[T](asJavaObservable.toBlockingObservable), +++ b/CHANGES.md, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * This Observable produces connected non-overlapping buffers. The current buffer is, +   * emitted and replaced with a new buffer when the Observable produced by the specified function produces an object. The function will then, +   * be used to create a new Observable to listen for the end of the next buffer., +   *, +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every buffer created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated buffer, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping buffers, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +   */, +  def buffer(closings: () => Observable[Any]) : Observable[Seq[T]] = {, +    val f: Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Any](f), +    Observable.jObsOfListToScObsOfSeq(jObs.asInstanceOf[rx.Observable[_ <: java.util.List[T]]]), +  }, +  /**, +   * Creates an Observable which produces buffers of collected values., +   *, +   * @param boundary the boundary Observable, +  def buffer(boundary: Observable[Any]): Observable[Seq[T]] = {, +    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[T]], +    toScalaObservable(thisJava.buffer(boundary.asJavaObservable)).map(_.asScala), +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Any](func), +    val o2 = Observable.items(o1).map((x: rx.Observable[_]) => {, +      val x2 = x.asInstanceOf[rx.Observable[_ <: T]], +      toScalaObservable[T](x2)]