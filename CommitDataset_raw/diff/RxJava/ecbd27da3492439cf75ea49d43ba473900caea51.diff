[+++ b/src/main/java/rx/exceptions/OnErrorThrowable.java, +         * or calls to toString() which may throw exceptions. See PR #1401 for details., +         * @return a string version of the object if primitive, otherwise the classname of the object, +++ b/src/main/java/rx/exceptions/OnErrorThrowable.java, +         * or calls to toString() which may throw exceptions. See PR #1401 for details., +         * @return a string version of the object if primitive, otherwise the classname of the object, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +import java.util.Queue;, +import java.util.concurrent.atomic.*;, +import rx.*;, +import rx.internal.util.*;, +import rx.internal.util.unsafe.*;, +import rx.schedulers.*;, +        final Scheduler.Worker recursiveScheduler;, +        final ScheduledUnsubscribe scheduledUnsubscribe;, +        final Queue<Object> queue;, +        volatile boolean completed = false;, +        volatile boolean failure = false;, +        volatile long requested = 0;, +        volatile Throwable error;, +, +            if (UnsafeAccess.isUnsafeAvailable()) {, +                queue = new SpscArrayQueue<Object>(RxRingBuffer.SIZE);, +            } else {, +                queue = new SynchronizedQueue<Object>(RxRingBuffer.SIZE);, +            }, +            this.scheduledUnsubscribe = new ScheduledUnsubscribe(recursiveScheduler);, +            if (!queue.offer(on.next(t))) {, +                onError(new MissingBackpressureException());, +            if (error != null) {, +                return;, +            }, +            if (error != null) {, +                return;, +            }, +            error = e;, +            completed = true;, +        final Action0 action = new Action0() {, +        };, +, +        protected void schedule() {, +            if (COUNTER_UPDATER.getAndIncrement(this) == 0) {, +                recursiveScheduler.schedule(action);, +        void pollQueue() {, +                counter = 1;, +//                middle:, +                        child.onError(error);, +                        return;, +                    } else {, +                        if (requested == 0 && completed && queue.isEmpty()) {, +                            child.onCompleted();, +                                if (completed) {, +                                    if (failure) {, +                                        child.onError(error);, +                                    } else {, +                                        child.onCompleted();, +                                    }, +                                    return;, +                                }, +        public ScheduledUnsubscribe(Scheduler.Worker worker) {, +++ b/src/main/java/rx/exceptions/OnErrorThrowable.java, +         * or calls to toString() which may throw exceptions. See PR #1401 for details., +         * @return a string version of the object if primitive, otherwise the classname of the object, +++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java, +import java.util.Queue;, +import java.util.concurrent.atomic.*;, +import rx.*;, +import rx.internal.util.*;, +import rx.internal.util.unsafe.*;, +import rx.schedulers.*;, +        final Scheduler.Worker recursiveScheduler;, +        final ScheduledUnsubscribe scheduledUnsubscribe;, +        final Queue<Object> queue;, +        volatile boolean completed = false;, +        volatile boolean failure = false;, +        volatile long requested = 0;, +        volatile Throwable error;, +, +            if (UnsafeAccess.isUnsafeAvailable()) {, +                queue = new SpscArrayQueue<Object>(RxRingBuffer.SIZE);, +            } else {, +                queue = new SynchronizedQueue<Object>(RxRingBuffer.SIZE);, +            }, +            this.scheduledUnsubscribe = new ScheduledUnsubscribe(recursiveScheduler);, +            if (!queue.offer(on.next(t))) {, +                onError(new MissingBackpressureException());, +            if (error != null) {, +                return;, +            }, +            if (error != null) {, +                return;, +            }, +            error = e;, +            completed = true;, +        final Action0 action = new Action0() {, +        };, +, +        protected void schedule() {, +            if (COUNTER_UPDATER.getAndIncrement(this) == 0) {, +                recursiveScheduler.schedule(action);]