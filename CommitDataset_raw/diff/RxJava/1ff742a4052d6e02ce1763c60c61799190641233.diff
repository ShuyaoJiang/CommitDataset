[+++ b/src/main/java/io/reactivex/Observable.java, +            throw new IndexOutOfBoundsException("n >= required but it was " + n);, +            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/Observable.java, +            throw new IndexOutOfBoundsException("n >= required but it was " + n);, +            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateRequest(n)) {, +            drain();, +++ b/src/main/java/io/reactivex/Observable.java, +            throw new IndexOutOfBoundsException("n >= required but it was " + n);, +            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateRequest(n)) {, +            drain();, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java, +                        if ((Long)ts < scheduler.now(unit) - time) {, +                            continue;, +                        }, +                        , +                missed = addAndGet(-missed);, +++ b/src/main/java/io/reactivex/Observable.java, +            throw new IndexOutOfBoundsException("n >= required but it was " + n);, +            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateRequest(n)) {, +            drain();, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java, +                        if ((Long)ts < scheduler.now(unit) - time) {, +                            continue;, +                        }, +                        , +                missed = addAndGet(-missed);, +++ b/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java, +    public void testSynchronizationOfMultipleSequencesLoop() throws Throwable {, +        for (int i = 0; i < 100; i++) {, +            System.out.println("testSynchronizationOfMultipleSequencesLoop > " + i);, +            testSynchronizationOfMultipleSequences();, +        }, +    }, +    , +    @Test, +                    // avoid deadlocking the main thread, +                    if (Thread.currentThread().getName().equals("TestASynchronousObservable")) {, +                    }, +            }, "TestASynchronousObservable");, +++ b/src/main/java/io/reactivex/Observable.java, +            throw new IndexOutOfBoundsException("n >= required but it was " + n);, +            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +            if (SubscriptionHelper.validateRequest(n)) {, +            drain();, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java, +                        if ((Long)ts < scheduler.now(unit) - time) {, +                            continue;, +                        }, +                        , +                missed = addAndGet(-missed);, +++ b/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java, +    public void testSynchronizationOfMultipleSequencesLoop() throws Throwable {, +        for (int i = 0; i < 100; i++) {, +            System.out.println("testSynchronizationOfMultipleSequencesLoop > " + i);, +            testSynchronizationOfMultipleSequences();, +        }, +    }, +    , +    @Test, +                    // avoid deadlocking the main thread, +                    if (Thread.currentThread().getName().equals("TestASynchronousObservable")) {, +                    }, +            }, "TestASynchronousObservable");, +++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastOneTest.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import static org.junit.Assert.*;, +, +import java.util.*;, +import java.util.concurrent.atomic.*;, +import java.util.function.Consumer;, +, +import org.junit.Test;, +, +import io.reactivex.Observable;]