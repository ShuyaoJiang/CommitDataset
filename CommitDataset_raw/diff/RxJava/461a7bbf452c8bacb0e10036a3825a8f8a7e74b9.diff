[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.subscribers.completable.*;, +    static final Completable COMPLETE = new CompletableEmpty();, +    static final Completable NEVER = new CompletableNever();, +        return new CompletableAmbArray(sources);, +        return new CompletableAmbIterable(sources);, +        return new CompletableConcatArray(sources);, +        return new CompletableConcatIterable(sources);, +        return new CompletableConcat(sources, prefetch);, +     * @deprecated, +    @Deprecated // FIXME temporary, +        if (onSubscribe instanceof Completable) {, +            throw new IllegalArgumentException("Use of create(Completable)!");, +        }, +        return new CompletableDefer(completableSupplier);, +        return new CompletableErrorSupplier(errorSupplier);, +        return new CompletableError(error);, +        return new CompletableFromCallable(callable);, +        return new CompletableFromFlowable<T>(flowable);, +     * Returns a Completable instance that subscribes to the given Observable, ignores all values and, +     * @param <T> the type of the Observable, +    public static <T> Completable fromObservable(final ObservableConsumable<T> observable) {, +        return new CompletableFromObservable<T>(observable);, +        return new CompletableFromRunnable(run);, +        return new CompletableFromSingle<T>(single);, +        return new CompletableMergeArray(sources);, +        return new CompletableMergeIterable(sources);, +        return new CompletableMerge(sources, maxConcurrency, delayErrors);, +        return new CompletableMergeDelayErrorArray(sources);, +        return new CompletableMergeDelayErrorIterable(sources);, +        return new CompletableTimer(delay, unit, scheduler);, +        return new CompletableUsing<R>(resourceSupplier, completableFunction, disposer, eager);, +        CompletableAwait.await(this);, +        return CompletableAwait.await(this, timeout, unit);, +        return new CompletableDelay(this, delay, unit, scheduler, delayError);, +        return new CompletablePeek(this, onSubscribe, onError, onComplete, onAfterComplete, onDisposed);, +        return this.<T>toObservable().endWith(next);, +        return CompletableAwait.get(this);, +        return CompletableAwait.get(this, timeout, unit);, +    @Deprecated // FIXME temporary, +        return new CompletableLift(this, onLift);, +        return new CompletableObserveOn(this, scheduler);, +        return new CompletableOnErrorComplete(this, predicate);, +        return new CompletableResumeNext(this, errorMapper);, +        return other.endWith(this.<T>toObservable());, +        EmptyCompletableSubscriber s = new EmptyCompletableSubscriber();, +        subscribe(s);, +        return s;, +        CallbackCompletableSubscriber s = new CallbackCompletableSubscriber(onError, onComplete);, +        subscribe(s);, +        return s;, +     * @param <T> the Observer's value type, +    public final <T> void subscribe(final Observer<? super T> s) {, +        ObserverCompletableSubscriber<T> os = new ObserverCompletableSubscriber<T>(s);, +        subscribe(os);, +        CallbackCompletableSubscriber s = new CallbackCompletableSubscriber(onComplete);, +        subscribe(s);, +        return s;, +        SubscriberCompletableSubscriber<T> os = new SubscriberCompletableSubscriber<T>(s);, +        subscribe(os);, +        return new CompletableSubscribeOn(this, scheduler);, +        return new CompletableTimeout(this, timeout, unit, scheduler, other);, +        return new CompletableToFlowable<T>(this);, +    public final <T> Observable<T> toObservable() {, +        return new CompletableToObservable<T>(this);, +        return new CompletableToSingle<T>(this, completionValueSupplier, null);, +        return new CompletableToSingle<T>(this, null, completionValue);, +        return new CompletableUnsubscribeOn(this, scheduler);, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.subscribers.completable.*;, +    static final Completable COMPLETE = new CompletableEmpty();, +    static final Completable NEVER = new CompletableNever();, +        return new CompletableAmbArray(sources);, +        return new CompletableAmbIterable(sources);, +        return new CompletableConcatArray(sources);, +        return new CompletableConcatIterable(sources);, +        return new CompletableConcat(sources, prefetch);, +     * @deprecated, +    @Deprecated // FIXME temporary, +        if (onSubscribe instanceof Completable) {, +            throw new IllegalArgumentException("Use of create(Completable)!");, +        }, +        return new CompletableDefer(completableSupplier);, +        return new CompletableErrorSupplier(errorSupplier);, +        return new CompletableError(error);, +        return new CompletableFromCallable(callable);, +        return new CompletableFromFlowable<T>(flowable);, +     * Returns a Completable instance that subscribes to the given Observable, ignores all values and, +     * @param <T> the type of the Observable, +    public static <T> Completable fromObservable(final ObservableConsumable<T> observable) {, +        return new CompletableFromObservable<T>(observable);, +        return new CompletableFromRunnable(run);, +        return new CompletableFromSingle<T>(single);, +        return new CompletableMergeArray(sources);, +        return new CompletableMergeIterable(sources);, +        return new CompletableMerge(sources, maxConcurrency, delayErrors);, +        return new CompletableMergeDelayErrorArray(sources);, +        return new CompletableMergeDelayErrorIterable(sources);]