[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Long): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable.asInstanceOf[rx.Observable[T]])), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  def retry(retryCount: Long): Observable[T] = {, +    toScalaObservable[T](rx.Observable.defer[T](() => observable.asJavaObservable.asInstanceOf[rx.Observable[T]])), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "flatMap(Func1[_ >: T, _ <: Observable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapWith(T => Observable[U])((T, U) => R)",, +      "flatMapIterable(Func1[_ >: T, _ <: Iterable[_ <: U]], Func2[_ >: T, _ >: U, _ <: R])" -> "flatMapIterableWith(T => Iterable[U])((T, U) => R)",, +      "ofType(Class[R])" -> "[use `filter(_.isInstanceOf[Class])`]",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]])" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]])",, +      "repeatWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "repeatWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_ <: Notification[_]]], Scheduler)" -> "retryWhen(Observable[Notification[Any]] => Observable[Notification[Any]], Scheduler)",, +      "retryWhen(Func1[_ >: Observable[_ <: Notification[_]], _ <: Observable[_]])" -> "retryWhen(Observable[Notification[Any]] => Observable[Any])",, +      "defer(Func0[Observable[T]])" -> "defer(=> Observable[T])",, +      "merge(Iterable[_ <: Observable[_ <: T]], Int, Scheduler)" -> "[use `Observable.from(iter, scheduler).flatten(n)`]",, +      "range(Int, Int, Scheduler)" -> "[use `(start until (start + count)).toObservable.subscribeOn(scheduler)` instead of `range(start, count, scheduler)`]",, +      "zipWith(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U])((T, U) => R)",, +    methodMembersToMethodStrings(tp.declarations.filter {, +      m =>, +        m.isMethod && m.isPublic &&, +          m.annotations.forall(_.toString != "java.lang.Deprecated") // don't check deprecated classes, +    }), +]