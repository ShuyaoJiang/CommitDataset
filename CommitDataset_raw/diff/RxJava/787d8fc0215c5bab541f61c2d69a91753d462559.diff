[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import org.mockito.Mockito;, +import rx.util.AtomicObservableSubscription;, +import rx.util.AtomicObserver;, +import rx.util.functions.Action0;, +import rx.util.functions.Action1;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, +import rx.util.functions.Func3;, +import rx.util.functions.Func4;, +import rx.util.functions.FuncN;, +import rx.util.functions.Functions;, +public class Observable<T> {, +    private final Func1<Observer<T>, Subscription> onSubscribe;, +, +    public Observable(Func1<Observer<T>, Subscription> onSubscribe) {, +        this.onSubscribe = onSubscribe;, +    public Subscription subscribe(Observer<T> observer) {, +        /*, +         * Wrap the observer and subscription in Atomic* wrappers to:, +         * , +         * - ensure correct behavior of onNext, onCompleted and onError., +         * - allow the Observer to have access to the subscription in asynchronous execution for checking if unsubscribed occurred without onComplete/onError., +         * - handle both synchronous and asynchronous subscribe() execution flows, +         */, +        final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +        final Observer<T> atomicObserver = new AtomicObserver<T>(observer, subscription);, +        return subscription.wrap(onSubscribe.call(atomicObserver));, +    };, +        public NeverObservable() {, +            super(new Func1<Observer<T>, Subscription>() {, +, +                @Override, +                public Subscription call(Observer<T> t1) {, +, +            });, +        }, +        public ThrowObservable(final Exception exception) {, +            super(new Func1<Observer<T>, Subscription>() {, +                @Override, +                public Subscription call(Observer<T> observer) {, +                    observer.onError(exception);, +, +            });, +        }, +, +        return new Observable<T>(func);, +        return create(OperationFilter.filter(that, predicate));, +        return create(OperationLast.last(that));, +        return create(OperationMap.map(sequence, func));, +        return create(OperationMap.mapMany(sequence, func));, +        return create(OperationMaterialize.materialize(sequence));, +        return create(OperationMerge.merge(source));, +        return create(OperationMerge.merge(source));, +        return create(OperationMerge.merge(source));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(that, resumeFunction));, +        return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(that, resumeSequence));, +        return create(OperationOnErrorReturn.onErrorReturn(that, resumeFunction));, +        return last(create(OperationScan.scan(sequence, accumulator)));, +        return last(create(OperationScan.scan(sequence, initialValue, accumulator)));, +        return create(OperationScan.scan(sequence, accumulator));, +        return create(OperationScan.scan(sequence, initialValue, accumulator));, +        return create(OperationSkip.skip(items, num));, +        return create(OperationSynchronize.synchronize(observable));, +        return create(OperationTake.take(items, num));, +        return create(OperationToObservableList.toObservableList(that));, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +        return create(OperationToObservableSortedList.toSortedList(sequence));, +        return create(OperationToObservableSortedList.toSortedList(sequence, sortFunction));, +        return create(OperationToObservableSortedList.toSortedList(sequence, new Func2<T, T, Integer>() {, +        }));]