[+++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From, StartWith, +* [Pull 496](https://github.com/Netflix/RxJava/pull/496) Add contravariant for min and max, +, +++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From, StartWith, +* [Pull 496](https://github.com/Netflix/RxJava/pull/496) Add contravariant for min and max, +, +++ b/gradle.properties, +version=0.15.1-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From, StartWith, +* [Pull 496](https://github.com/Netflix/RxJava/pull/496) Add contravariant for min and max, +, +++ b/gradle.properties, +version=0.15.1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Alternative Rx bindings for Scala, +=================================, +The current RxScala binding attempt to optimize for seamless interop between Scala and Java., +The intended interop is illustrated by the following example where in Scala a class is defined that takes, +an `Observable[Movie]` that is transformed using RxScala operators:, +class MovieLib(val moviesStream: Observable[Movie]) {, +   val threshold = 1200, +   def shortMovies: Observable[Movie] = ???, +   def longMovies: Observable[Movie] = ???, +}, +which is then called in Java, passing a Java `Observable<Movie>` to the constructor, +```java, +public void test() {, +   MovieLib lib = new MovieLib(Observable.from(...));, +   lib.longMovies().subscribe(moviePrinter);, +}, +```, +The technique used to obtain this transparency is to use a value class with a private constructor that implements, +the Rx operators in an idiomatic Scala way, and a companion object that is used to construct instances in Scala, +object Observable {, +   def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = { new Observable[T](asJava) }, +}, +, +class Observable[+T] private[scala] (val asJava: rx.Observable[_ <: T])  extends AnyVal {, +   // Idiomatic Scala friendly definitions of Rx operators, +}, +Since `rx.lang.scala.Observable[T] extends AnyVal`, the underlying representation of `rx.lang.scala.Observable[T]`, +is the same as `rx.Observable<T>`. Because `rx.lang.scala.Observable[T]` is an opaque type in Scala,, +the Scala programmer only sees the Scala-friendly operators., +However, in the current the illusion of interop is quickly lost when going beyond this simple example., +For example but type `Notification[T]` and `Scheduler[T]` are defined using wrappers,, +and hence they are not compatible with `Notification<T>` respectively `Scheduler<T>`., +For instance, when materializing an `Observable[T]` in Scala to an `Observable[Notification[T]]`,, +we lost the seamless interop with `Observable<Notification<T>>` on the Java side., +However, the real problems with seamless interop show up when we try to creating bindings for other Rx types., +In particular types that have inheritance or more structure., +, +For example, RxScala currently defines a type synonym `type Observer[-T] = rx.Observer[_ >: T]`,, +but no further bindings for observers., +Similarly, for subjects RxScala defines `type Subject[-T, +R] = rx.subjects.Subject[_ >: T, _ <: R]`., +The problem with these definitions is that on the Java side, subjects are defined as:, +public abstract class Subject<T, R> extends Observable<R> implements Observer<T> { …}, +without binding any of the Rx subjects., +The consequence is that `Subject[S,T]` in Scala is unrelated to `rx.lang.scala.Observable[T]` in Scala,, +but shows up as a `rx.Observable[T]`. The problem however is that if we want to expose subjects in Scala, +such that they derive from both `Observable[S]` and `Observer[T]` we cannot use the `extend AnyVal` trick, +we used for `Observable[T]` and immediately lose transparent interop with Java., +The problem is even worse because `AsyncSubject<T>`, `BehaviorSubject<T>`, … all derive from `Subject<T,T>`,, +so if we want them to derive from a common base `Subject[T,T]` type in Scala we lose transparency for those as well., +And again, if we expose the various subjects by extending `AnyVal`, they are useless in Scala because they do not inherit, +from a common base type. To avoid implementing all methods of observable and observer on each specific subject, +we might add implicit conversions to `Observable[T]` and `Observer[T]` but that still does not give Scala users, +a native `Subject[S,T]` type., +object AsyncSubject {, +    def apply[T](): AsyncSubject[T] =, +      new AsyncSubject[T](rx.subjects.AsyncSubject.create())]