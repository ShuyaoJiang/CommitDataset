[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +//@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +//@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Accepts an Observable and wraps it in another Observable that ensures that the resulting, +     * Observable is chronologically well-behaved. This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     * <p>, +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +     * <p>, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     *, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     *            the type of item emitted by the source Observable, +     * @return an Observable that is a chronologically well-behaved version of the source, +     *         Observable, and that synchronously notifies its {@link Observer}s, +     */, +    public Observable<T> synchronize(Object lock) {, +        return create(OperationSynchronize.synchronize(this, lock));, +    }, +, +    /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +//@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Accepts an Observable and wraps it in another Observable that ensures that the resulting, +     * Observable is chronologically well-behaved. This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     * <p>, +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +     * <p>, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     *, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     *            the type of item emitted by the source Observable, +     * @return an Observable that is a chronologically well-behaved version of the source, +     *         Observable, and that synchronously notifies its {@link Observer}s, +     */, +    public Observable<T> synchronize(Object lock) {, +        return create(OperationSynchronize.synchronize(this, lock));, +    }, +, +    /**, +++ b/rxjava-core/src/main/java/rx/operators/OperationSynchronize.java, +        return new Synchronize<T>(observable, null);, +    }, +, +    /**, +     * Accepts an observable and wraps it in another observable which ensures that the resulting observable is well-behaved., +     * This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     *, +     * A well-behaved observable ensures onNext, onCompleted, or onError calls to its subscribers are, +     * not interleaved, onCompleted and onError are only called once respectively, and no, +     * onNext calls follow onCompleted and onError calls., +     *, +     * @param observable, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     * @return the wrapped synchronized observable sequence, +     */, +    public static <T> OnSubscribeFunc<T> synchronize(Observable<? extends T> observable, Object lock) {, +        return new Synchronize<T>(observable, lock);, +        public Synchronize(Observable<? extends T> innerObservable, Object lock) {, +            this.lock = lock;, +        private Object lock;, +            if(lock == null) {, +            }, +            else {, +                atomicObserver = new SynchronizedObserver<T>(observer, subscription, lock);, +            }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +//@Ignore // Since this doesn't do automatic testing, don't increase build time unnecessarily, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Accepts an Observable and wraps it in another Observable that ensures that the resulting, +     * Observable is chronologically well-behaved. This is accomplished by acquiring a mutual-exclusion lock for the object provided as the lock parameter., +     * <p>, +     * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +     * <p>, +     * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +     * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +     * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +     *, +     * @param lock, +     *            The lock object to synchronize each observer call on, +     * @param <T>, +     *            the type of item emitted by the source Observable, +     * @return an Observable that is a chronologically well-behaved version of the source, +     *         Observable, and that synchronously notifies its {@link Observer}s, +     */, +    public Observable<T> synchronize(Object lock) {, +        return create(OperationSynchronize.synchronize(this, lock));, +    }]