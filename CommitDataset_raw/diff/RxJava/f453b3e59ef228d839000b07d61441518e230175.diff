[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +    }), +   * Converts an Observable into a [[rx.lang.scala.observables.BlockingObservable]] (an Observable with blocking, +  def toBlockingObservable: BlockingObservable[T] = {, +    new BlockingObservable[T](asJavaObservable.toBlockingObservable), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +    }), +   * Converts an Observable into a [[rx.lang.scala.observables.BlockingObservable]] (an Observable with blocking, +  def toBlockingObservable: BlockingObservable[T] = {, +    new BlockingObservable[T](asJavaObservable.toBlockingObservable), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "single(Func1[_ >: T, Boolean])" -> "[use `filter(predicate).single`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U], (T, U) => R)",, +      "zip(Iterable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Iterable[U], (T, U) => R)",, +      "zip(Iterable[_ <: Observable[_]], FuncN[_ <: R])" -> "[use `zip` in companion object and `map`]", +  }).toMap, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +    }), +   * Converts an Observable into a [[rx.lang.scala.observables.BlockingObservable]] (an Observable with blocking, +  def toBlockingObservable: BlockingObservable[T] = {, +    new BlockingObservable[T](asJavaObservable.toBlockingObservable), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "single(Func1[_ >: T, Boolean])" -> "[use `filter(predicate).single`]",, +      "zip(Observable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Observable[U], (T, U) => R)",, +      "zip(Iterable[_ <: T2], Func2[_ >: T, _ >: T2, _ <: R])" -> "zipWith(Iterable[U], (T, U) => R)",, +      "zip(Iterable[_ <: Observable[_]], FuncN[_ <: R])" -> "[use `zip` in companion object and `map`]", +  }).toMap, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * non-overlapping windows. The current window is emitted and replaced with a new window when the, +   * Observable produced by the specified function produces an object. , +   * The function will then be used to create a new Observable to listen for the end of the next, +   * window., +   * @param closings, +   *            The function which is used to produce an [[rx.lang.scala.Observable]] for every window created., +   *            When this [[rx.lang.scala.Observable]] produces an object, the associated window, +   *            is emitted and replaced with a new one., +   * @return, +   *         An [[rx.lang.scala.Observable]] which produces connected non-overlapping windows, which are emitted, +   *         when the current [[rx.lang.scala.Observable]] created with the function argument produces an object., +  def window(closings: () => Observable[Any]): Observable[Observable[T]] = {, +    val func : Func0[_ <: rx.Observable[_ <: Any]] = closings().asJavaObservable, +    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +    }), +   * Converts an Observable into a [[rx.lang.scala.observables.BlockingObservable]] (an Observable with blocking]