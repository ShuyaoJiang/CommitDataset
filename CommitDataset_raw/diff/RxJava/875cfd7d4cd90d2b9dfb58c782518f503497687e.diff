[+++ b/rxjava-core/src/main/java/rx/schedulers/TrampolineScheduler.java, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>() {, +        @Override, +        protected PriorityQueue<TimedAction> initialValue() {, +            return new PriorityQueue<TimedAction>();, +        }, +    };, +    static final AtomicIntegerFieldUpdater<TrampolineScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(TrampolineScheduler.class, "counter");, +        private final AtomicInteger wip = new AtomicInteger();, +            if (wip.getAndIncrement() == 0) {, +                do {, +                } while (wip.decrementAndGet() > 0);, +                // queue wasn't empty, a parent is already processing so we just add to the end of the queue, +        final int count; // In case if time between enqueueing took less than 1ms, +        private TimedAction(Action0 action, Long execTime, int count) {, +                return compare(count, that.count);, +    // because I can't use Integer.compare from Java 7, +    private static int compare(int x, int y) {, +        return (x < y) ? -1 : ((x == y) ? 0 : 1);, +    }, +]