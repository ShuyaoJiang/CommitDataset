[+++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationFilter.java, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationFilter.java, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +++ /dev/null, +++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationFilter.java, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationScan.java, +import rx.util.functions.Action1;, +    public static <T, R> Func1<Observer<R>, Subscription> scan(Observable<T> sequence, R initialValue, Func2<R, T, R> accumulator) {, +        return new Accumulator<T, R>(sequence, initialValue, accumulator);, +        return new AccuWithoutInitialValue<T>(sequence, accumulator);, +    private static class AccuWithoutInitialValue<T> implements Func1<Observer<T>, Subscription> {, +        private final Func2<T, T, T> accumlatorFunction;, +        private T initialValue;, +, +        private AccuWithoutInitialValue(Observable<T> sequence, Func2<T, T, T> accumulator) {, +            this.sequence = sequence;, +            this.accumlatorFunction = accumulator;, +        }, +        , +        @Override, +        public Subscription call(final Observer<T> observer) {, +            sequence.take(1).subscribe(new Action1<T>() {, +                @Override, +                public void call(T value) {, +                    initialValue = value;, +                    observer.onNext(value);, +                }, +            });, +            Accumulator<T, T> scan = new Accumulator<T, T>(sequence /* FIXME .drop(1) */, initialValue, accumlatorFunction);, +            return scan.call(observer);, +        }, +    }, +    , +    private static class Accumulator<T, R> implements Func1<Observer<R>, Subscription> {, +        private final Observable<T> sequence;, +        private final R initialValue;, +        private final Func2<R, T, R> accumlatorFunction;, +        private Accumulator(Observable<T> sequence, R initialValue, Func2<R, T, R> accumulator) {, +        @Override, +        public Subscription call(final Observer<R> observer) {, +                private R acc = initialValue;, +                @Override, +                @Override, +                @Override, +                public void onCompleted() {, +++ b/CHANGES.md, +See See https://github.com/Netflix/RxJava/issues/19 for background, discussion and status of Schedulers., +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationFilter.java, +        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationScan.java, +import rx.util.functions.Action1;, +    public static <T, R> Func1<Observer<R>, Subscription> scan(Observable<T> sequence, R initialValue, Func2<R, T, R> accumulator) {, +        return new Accumulator<T, R>(sequence, initialValue, accumulator);, +        return new AccuWithoutInitialValue<T>(sequence, accumulator);, +    private static class AccuWithoutInitialValue<T> implements Func1<Observer<T>, Subscription> {, +        private final Func2<T, T, T> accumlatorFunction;, +        private T initialValue;, +, +        private AccuWithoutInitialValue(Observable<T> sequence, Func2<T, T, T> accumulator) {, +            this.sequence = sequence;, +            this.accumlatorFunction = accumulator;, +        }, +        , +        @Override, +        public Subscription call(final Observer<T> observer) {, +            sequence.take(1).subscribe(new Action1<T>() {, +                @Override, +                public void call(T value) {, +                    initialValue = value;, +                    observer.onNext(value);, +                }, +            });, +            Accumulator<T, T> scan = new Accumulator<T, T>(sequence /* FIXME .drop(1) */, initialValue, accumlatorFunction);, +            return scan.call(observer);, +        }, +    }, +    , +    private static class Accumulator<T, R> implements Func1<Observer<R>, Subscription> {, +        private final Observable<T> sequence;, +        private final R initialValue;, +        private final Func2<R, T, R> accumlatorFunction;]