[+++ b/src/test/java/io/reactivex/XFlatMapTest.java, +            Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/XFlatMapTest.java, +            Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java, +import io.reactivex.disposables.SerialDisposable;, +        int repeat = 0;, +        for (;;) {, +            final SerialDisposable task = new SerialDisposable();, +            try {, +                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {, +                                    while (running.get() && !task.isDisposed()) {, +                        }));, +                break;, +            } catch (AssertionError ex) {, +                if (++repeat == 3) {, +                    throw ex;, +                }, +                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));, +            } finally {, +                task.dispose();, +            }, +        }, +++ b/src/test/java/io/reactivex/XFlatMapTest.java, +            Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java, +import io.reactivex.disposables.SerialDisposable;, +        int repeat = 0;, +        for (;;) {, +            final SerialDisposable task = new SerialDisposable();, +            try {, +                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {, +                                    while (running.get() && !task.isDisposed()) {, +                        }));, +                break;, +            } catch (AssertionError ex) {, +                if (++repeat == 3) {, +                    throw ex;, +                }, +                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));, +            } finally {, +                task.dispose();, +            }, +        }, +++ b/src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java, +import io.reactivex.disposables.*;, +        int repeat = 0;, +        for (;;) {, +            final SerialDisposable task = new SerialDisposable();, +            try {, +                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {, +                                    while (running.get() && !task.isDisposed()) {, +                        }));, +                break;, +            } catch (AssertionError ex) {, +                if (++repeat == 3) {, +                    throw ex;, +                }, +                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));, +            } finally {, +                task.dispose();, +            }, +        }]