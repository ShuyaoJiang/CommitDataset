[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +package rx.lang.groovy, +, +import org.junit.Test, +, +import rx.Observable, +import rx.Scheduler, +import rx.concurrency.Schedulers, +import rx.util.functions.Func1, +, +class TestParallel {, +, +    @Test, +    public void testParallelOperator() {, +        Observable.range(0, 100), +                .parallel({, +                    it.map({ return it; }), +                }), +                .toBlockingObservable(), +                .forEach({ println("T: " + it + " Thread: " + Thread.currentThread());  });, +    }, +}, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +package rx.lang.groovy, +, +import org.junit.Test, +, +import rx.Observable, +import rx.Scheduler, +import rx.concurrency.Schedulers, +import rx.util.functions.Func1, +, +class TestParallel {, +, +    @Test, +    public void testParallelOperator() {, +        Observable.range(0, 100), +                .parallel({, +                    it.map({ return it; }), +                }), +                .toBlockingObservable(), +                .forEach({ println("T: " + it + " Thread: " + Thread.currentThread());  });, +    }, +}, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDebounce;, +import rx.operators.OperationDistinctUntilChanged;, +import rx.operators.OperationParallel;, +    public Observable<T> synchronize() {, +        return create(OperationSynchronize.synchronize(this));, +     * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Schedulers#threadPoolForComputation()} {@link Scheduler} and return an {@code Observable<R>} with the output., +     * , +     * @param f, +     *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +     * @return an Observable with the output of the {@link Func1} executed on a {@link Scheduler}, +     */, +    public <R> Observable<R> parallel(Func1<Observable<T>, Observable<R>> f) {, +        return OperationParallel.parallel(this, f);, +    }, +, +    /**, +     * Perform work in parallel by sharding an {@code Observable<T>} on a {@link Scheduler} and return an {@code Observable<R>} with the output., +     * , +     * @param f, +     *            a {@link Func1} that applies Observable operators to {@code Observable<T>} in parallel and returns an {@code Observable<R>}, +     * @param s, +     *            a {@link Scheduler} to perform the work on., +     * @return an Observable with the output of the {@link Func1} executed on a {@link Scheduler}, +     */, +    , +    public <R> Observable<R> parallel(final Func1<Observable<T>, Observable<R>> f, final Scheduler s) {, +        return OperationParallel.parallel(this, f, s);, +    }, +    , +    /**, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +package rx.lang.groovy, +, +import org.junit.Test, +, +import rx.Observable, +import rx.Scheduler, +import rx.concurrency.Schedulers, +import rx.util.functions.Func1, +, +class TestParallel {, +, +    @Test, +    public void testParallelOperator() {, +        Observable.range(0, 100), +                .parallel({, +                    it.map({ return it; }), +                }), +                .toBlockingObservable(), +                .forEach({ println("T: " + it + " Thread: " + Thread.currentThread());  });, +    }, +}, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDebounce;, +import rx.operators.OperationDistinctUntilChanged;]