[+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.Producer;, +    private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> controlHandlerFunction;, +    private final AtomicBoolean isStarted = new AtomicBoolean(false);, +    // incremented when requests are made, decremented when requests are fulfilled, +    private final AtomicLong consumerCapacity = new AtomicLong(0l);, +    private final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        this.controlHandlerFunction = f;, +        isStarted.set(false);, +        isLocked.set(true);, +        consumerCapacity.set(0l);, +        currentProducer.set(null);, +, +                        consumerCapacity.decrementAndGet();, +, +                    @Override, +                    public void setProducer(Producer producer) {, +                        currentProducer.set(producer);, +                        producer.request(consumerCapacity.get());, +                    }, +        // the observable received by the control handler function will receive notifications of onCompleted in the case of 'repeat' , +        // type operators or notifications of onError for 'retry' this is done by lifting in a custom operator to selectively divert , +        // the retry/repeat relevant values to the control handler, +        final Observable<?> restarts = controlHandlerFunction.call(, +, +                            @Override, +                            public void setProducer(Producer producer) {, +                                producer.request(Long.MAX_VALUE);, +                            }, +, +                    @Override, +                    public void setProducer(Producer producer) {, +                        producer.request(Long.MAX_VALUE);, +                    }, +, +        child.setProducer(new Producer() {, +, +            @Override, +            public void request(long n) {, +                if (isStarted.compareAndSet(false, true)) {, +                    consumerCapacity.set(n);, +                    if (!child.isUnsubscribed()) child.add(inner.schedule(subscribeToSource));, +                } else if (currentProducer.get() != null) {, +                    consumerCapacity.getAndAdd(n);, +                    currentProducer.get().request(n);, +        });, +, +    }, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import java.util.concurrent.atomic.AtomicReference;, +import rx.Producer;, +    private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> controlHandlerFunction;, +    private final AtomicBoolean isStarted = new AtomicBoolean(false);, +    // incremented when requests are made, decremented when requests are fulfilled, +    private final AtomicLong consumerCapacity = new AtomicLong(0l);, +    private final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        this.controlHandlerFunction = f;, +        isStarted.set(false);, +        isLocked.set(true);, +        consumerCapacity.set(0l);, +        currentProducer.set(null);, +, +                        consumerCapacity.decrementAndGet();, +, +                    @Override, +                    public void setProducer(Producer producer) {, +                        currentProducer.set(producer);, +                        producer.request(consumerCapacity.get());, +                    }, +        // the observable received by the control handler function will receive notifications of onCompleted in the case of 'repeat' , +        // type operators or notifications of onError for 'retry' this is done by lifting in a custom operator to selectively divert , +        // the retry/repeat relevant values to the control handler, +        final Observable<?> restarts = controlHandlerFunction.call(, +, +                            @Override, +                            public void setProducer(Producer producer) {, +                                producer.request(Long.MAX_VALUE);, +                            }, +, +                    @Override, +                    public void setProducer(Producer producer) {, +                        producer.request(Long.MAX_VALUE);, +                    }, +, +        child.setProducer(new Producer() {, +, +            @Override, +            public void request(long n) {, +                if (isStarted.compareAndSet(false, true)) {, +                    consumerCapacity.set(n);, +                    if (!child.isUnsubscribed()) child.add(inner.schedule(subscribeToSource));, +                } else if (currentProducer.get() != null) {, +                    consumerCapacity.getAndAdd(n);, +                    currentProducer.get().request(n);, +        });]