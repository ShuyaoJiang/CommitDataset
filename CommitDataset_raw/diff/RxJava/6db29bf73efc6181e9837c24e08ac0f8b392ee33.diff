[+++ b/language-adaptors/rxjava-groovy/build.gradle, +apply plugin: 'groovy', +    groovy 'org.codehaus.groovy:groovy-all:2.+', +++ b/language-adaptors/rxjava-groovy/build.gradle, +apply plugin: 'groovy', +    groovy 'org.codehaus.groovy:groovy-all:2.+', +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-groovy/build.gradle, +apply plugin: 'groovy', +    groovy 'org.codehaus.groovy:groovy-all:2.+', +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.lang.groovy, +, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +, +import java.util.Arrays;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.util.functions.Func1;, +, +def class ObservableTests {, +, +    @Mock, +    ScriptAssertion a;, +, +    @Mock, +    Observer<Integer> w;, +, +    @Before, +    public void before() {, +        MockitoAnnotations.initMocks(this);, +    }, +, +    @Test, +    public void testCreate() {, +        Observable.create({it.onNext('hello');it.onCompleted();}).subscribe({ result -> a.received(result)});, +        verify(a, times(1)).received("hello");, +    }, +, +    @Test, +    public void testFilter() {, +        Observable.filter(Observable.toObservable(1, 2, 3), {it >= 2}).subscribe({ result -> a.received(result)});, +        verify(a, times(0)).received(1);, +        verify(a, times(1)).received(2);, +        verify(a, times(1)).received(3);, +    }, +, +    @Test, +    public void testLast() {, +        new TestFactory().getObservable().last().subscribe({ result -> a.received(result)});, +        verify(a, times(1)).received("hello_1");, +    }, +, +    @Test, +    public void testMap1() {, +        new TestFactory().getObservable().map({v -> 'say' + v}).subscribe({ result -> a.received(result)});, +        verify(a, times(1)).received("sayhello_1");, +    }, +, +    @Test, +    public void testMap2() {, +        Observable.map(Observable.toObservable(1, 2, 3), {'hello_' + it}).subscribe({ result -> a.received(result)});, +        verify(a, times(1)).received("hello_" + 1);, +        verify(a, times(1)).received("hello_" + 2);, +        verify(a, times(1)).received("hello_" + 3);, +    }, +, +    @Test, +    public void testMaterialize() {, +        Observable.materialize(Observable.toObservable(1, 2, 3)).subscribe({ result -> a.received(result)});, +        // we expect 4 onNext calls: 3 for 1, 2, 3 ObservableNotification.OnNext and 1 for ObservableNotification.OnCompleted, +        verify(a, times(4)).received(any(Notification.class));, +        verify(a, times(0)).error(any(Exception.class));, +    }, +]