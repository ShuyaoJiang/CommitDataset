[+++ b/src/main/java/io/reactivex/internal/operators/OperatorSwitchMap.java, +        volatile SwitchMapInnerSubscriber<T, R> active;, +        static final AtomicReferenceFieldUpdater<SwitchMapSubscriber, SwitchMapInnerSubscriber> ACTIVE =, +                AtomicReferenceFieldUpdater.newUpdater(SwitchMapSubscriber.class, SwitchMapInnerSubscriber.class, "active");, +        volatile long requested;, +        @SuppressWarnings("rawtypes"), +        static final AtomicLongFieldUpdater<SwitchMapSubscriber> REQUESTED =, +                AtomicLongFieldUpdater.newUpdater(SwitchMapSubscriber.class, "requested");, +        , +        static final SwitchMapInnerSubscriber<Object, Object> CANCELLED;, +        static {, +            CANCELLED = new SwitchMapInnerSubscriber<>(null, -1L, 1);, +            CANCELLED.cancel();, +        }, +            long c = unique + 1;, +            unique = c;, +            , +            SwitchMapInnerSubscriber<T, R> inner = active;, +            if (inner != null) {, +                inner.cancel();, +            }, +            , +            if (p == null) {, +                s.cancel();, +                onError(new NullPointerException("The publisher returned is null"));, +                return;, +            }, +            , +            SwitchMapInnerSubscriber<T, R> nextInner = new SwitchMapInnerSubscriber<>(this, c, bufferSize);, +            , +            for (;;) {, +                inner = active;, +                if (inner == CANCELLED) {, +                    break;, +                }, +                if (ACTIVE.compareAndSet(this, inner, nextInner)) {, +                    p.subscribe(nextInner);, +                    break;, +                }, +            }, +            if (done) {, +                RxJavaPlugins.onError(t);, +                return;, +            }, +            if (done) {, +                return;, +            }, +            BackpressureHelper.add(REQUESTED, this, n);, +                disposeInner();, +        void disposeInner() {, +            SwitchMapInnerSubscriber<T, R> a = active;, +            if (a != CANCELLED) {, +                a = ACTIVE.getAndSet(this, CANCELLED);, +                if (a != CANCELLED && a != null) {, +                    s.cancel();, +                }, +            }, +        }, +        , +                , +                if (done) {, +                    Throwable err = error;, +                    if (err != null) {, +                        disposeInner();, +                        s.cancel();, +                        a.onError(err);, +                        return;, +                    } else, +                    if (active == null) {, +                        a.onComplete();, +                        return;, +                    }, +                }, +                , +                SwitchMapInnerSubscriber<T, R> inner = active;, +, +                if (inner != null) {, +                    Queue<R> q = inner.queue;, +, +                    if (inner.done) {, +                        Throwable err = inner.error;, +                        if (err != null) {, +                            s.cancel();, +                            disposeInner();, +                            a.onError(err);, +                            return;, +                        } else, +                        if (q.isEmpty()) {, +                            ACTIVE.compareAndSet(this, inner, null);, +                            continue;, +                        }, +                    }, +                    , +                    long r = requested;, +                    boolean unbounded = r == Long.MAX_VALUE;, +                    long e = 0L;, +                    boolean retry = false;, +                    , +                    while (r != 0L) {, +                        boolean d = inner.done;]