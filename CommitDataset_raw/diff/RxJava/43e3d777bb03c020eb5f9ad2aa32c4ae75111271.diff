[+++ b/rxjava-core/src/main/java/rx/schedulers/CurrentThreadScheduler.java, +import rx.util.functions.Func1;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>() {, +        protected java.util.PriorityQueue<TimedAction> initialValue() {, +            return new PriorityQueue<TimedAction>();, +        };, +    };, +, +    private static final ThreadLocal<Boolean> PROCESSING = new ThreadLocal<Boolean>() {, +        protected Boolean initialValue() {, +            return Boolean.FALSE;, +        };, +    };, +        innerScheduler.enqueue(new DiscardableAction<T>(state, action), now());, +        enqueueFromOuter(innerScheduler, now());, +        // create an inner scheduler and queue it for execution, +        innerScheduler.enqueue(new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime)), execTime);, +        enqueueFromOuter(innerScheduler, execTime);, +        return innerScheduler;, +    /*, +     * This will accept InnerCurrentThreadScheduler instances and execute them in order they are received, +     * and on each of them will loop internally until each is complete., +     */, +    private void enqueueFromOuter(final InnerCurrentThreadScheduler innerScheduler, long execTime) {, +        // Note that everything here is single-threaded so we won't have race conditions, +        queue.add(new TimedAction(new Func1<Scheduler, Subscription>() {, +            @Override, +            public Subscription call(Scheduler _) {, +                // when the InnerCurrentThreadScheduler gets scheduled we want to process its tasks, +                return innerScheduler.startProcessing();, +        }, execTime, counter.incrementAndGet()));, +        // first time through starts the loop, +        if (!PROCESSING.get()) {, +            PROCESSING.set(Boolean.TRUE);, +                queue.poll().action.call(innerScheduler);, +            PROCESSING.set(Boolean.FALSE);, +        private final PriorityQueue<TimedAction> innerQueue = new PriorityQueue<TimedAction>();, +            enqueue(discardableAction, now());, +            enqueue(discardableAction, execTime);, +        private void enqueue(Func1<Scheduler, Subscription> action, long execTime) {, +            innerQueue.add(new TimedAction(action, execTime, counter.incrementAndGet()));, +        }, +, +        private Subscription startProcessing() {, +            while (!innerQueue.isEmpty()) {, +                innerQueue.poll().action.call(this);, +            }, +            return this;, +        }, +, +        final Func1<Scheduler, Subscription> action;, +        private TimedAction(Func1<Scheduler, Subscription> action, Long execTime, Long count) {]