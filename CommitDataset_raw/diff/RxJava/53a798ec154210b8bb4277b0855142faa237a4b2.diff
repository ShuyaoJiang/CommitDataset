[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeDelayError;, +        return source.lift(new OperatorMergeDelayError<T>());, +        return mergeDelayError(from(t1, t2));, +        return mergeDelayError(from(t1, t2, t3));, +        return mergeDelayError(from(t1, t2, t3, t4));, +        return mergeDelayError(from(t1, t2, t3, t4, t5));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeDelayError;, +        return source.lift(new OperatorMergeDelayError<T>());, +        return mergeDelayError(from(t1, t2));, +        return mergeDelayError(from(t1, t2, t3));, +        return mergeDelayError(from(t1, t2, t3, t4));, +        return mergeDelayError(from(t1, t2, t3, t4, t5));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeDelayError;, +        return source.lift(new OperatorMergeDelayError<T>());, +        return mergeDelayError(from(t1, t2));, +        return mergeDelayError(from(t1, t2, t3));, +        return mergeDelayError(from(t1, t2, t3, t4));, +        return mergeDelayError(from(t1, t2, t3, t4, t5));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, +        return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMergeDelayError.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.operators;, +, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.Observable;, +import rx.Observable.Operator;, +import rx.Subscriber;, +import rx.exceptions.CompositeException;, +import rx.observers.SerializedSubscriber;, +import rx.subscriptions.CompositeSubscription;, +, +/**, + * This behaves like {@link OperatorMerge} except that if any of the merged Observables notify of, + * an error via <code>onError</code>, mergeDelayError will refrain from propagating that error, + * notification until all of the merged Observables have finished emitting items., + * <p>, + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/mergeDelayError.png">, + * <p>, + * Even if multiple merged Observables send <code>onError</code> notifications, mergeDelayError will, + * only invoke the <code>onError</code> method of its Observers once., + * <p>, + * This operation allows an Observer to receive all successfully emitted items from all of the, + * source Observables without being interrupted by an error notification from one of them., + * <p>, + * NOTE: If this is used on an Observable that never completes, it will never call, + * <code>onError</code> and will effectively swallow errors., + * , + * @param <T> the source and result value type, + */, +public final class OperatorMergeDelayError<T> implements Operator<T, Observable<? extends T>> {, +, +    @Override, +    public Subscriber<? super Observable<? extends T>> call(Subscriber<? super T> child) {, +        final SerializedSubscriber<T> s = new SerializedSubscriber<T>(child);, +        final CompositeSubscription csub = new CompositeSubscription();, +        child.add(csub);, +        final AtomicInteger wip = new AtomicInteger(1);, +        final ConcurrentLinkedQueue<Throwable> exceptions = new ConcurrentLinkedQueue<Throwable>();, +        , +        return new Subscriber<Observable<? extends T>>() {, +, +            @Override, +            public void onNext(Observable<? extends T> t) {, +                wip.incrementAndGet();, +                , +                Subscriber<T> itemSub = new Subscriber<T>() {, +                    /** Make sure terminal events are handled once to avoid wip problems. */, +                    boolean once = true;, +                    @Override]