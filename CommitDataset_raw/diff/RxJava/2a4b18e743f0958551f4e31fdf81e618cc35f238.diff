[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                clearScalarQueue();, +                clearScalarQueue();, +        void clearScalarQueue() {, +            SimpleQueue<U> q = queue;, +            if (q != null) {, +                q.clear();, +            }, +        }, +, +, +        void innerError(InnerSubscriber<T, U> inner, Throwable t) {, +            if (errs.addThrowable(t)) {, +                inner.done = true;, +                if (!delayErrors) {, +                    s.cancel();, +                    for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {, +                        a.dispose();, +                    }, +                }, +                drain();, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +        }, +            lazySet(SubscriptionHelper.CANCELLED);, +            parent.innerError(this, t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                clearScalarQueue();, +                clearScalarQueue();, +        void clearScalarQueue() {, +            SimpleQueue<U> q = queue;, +            if (q != null) {, +                q.clear();, +            }, +        }, +, +, +        void innerError(InnerSubscriber<T, U> inner, Throwable t) {, +            if (errs.addThrowable(t)) {, +                inner.done = true;, +                if (!delayErrors) {, +                    s.cancel();, +                    for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {, +                        a.dispose();, +                    }, +                }, +                drain();, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +        }, +            lazySet(SubscriptionHelper.CANCELLED);, +            parent.innerError(this, t);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java, +import io.reactivex.exceptions.TestException;, +import io.reactivex.plugins.RxJavaPlugins;, +, +    @Test, +    public void mergeErrors() {, +        List<Throwable> errors = TestHelper.trackPluginErrors();, +        try {, +            Flowable<Integer> source1 = Flowable.error(new TestException("First"));, +            Flowable<Integer> source2 = Flowable.error(new TestException("Second"));, +, +            Flowable.merge(source1, source2), +            .test(), +            .assertFailureAndMessage(TestException.class, "First");, +, +            assertTrue(errors.toString(), errors.isEmpty());, +        } finally {, +            RxJavaPlugins.reset();, +        }, +    }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +                clearScalarQueue();, +                clearScalarQueue();, +        void clearScalarQueue() {, +            SimpleQueue<U> q = queue;, +            if (q != null) {, +                q.clear();, +            }, +        }, +, +, +        void innerError(InnerSubscriber<T, U> inner, Throwable t) {, +            if (errs.addThrowable(t)) {, +                inner.done = true;, +                if (!delayErrors) {, +                    s.cancel();, +                    for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {, +                        a.dispose();, +                    }, +                }, +                drain();, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +        }, +            lazySet(SubscriptionHelper.CANCELLED);]