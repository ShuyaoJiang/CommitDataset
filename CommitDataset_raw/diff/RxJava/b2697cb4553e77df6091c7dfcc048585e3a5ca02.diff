[+++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +        return create(OperationTakeWhile.takeWhile(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>(), +        {, +            public Boolean call(T t, Integer integer), +            {, +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +        return create(OperationTakeWhile.takeWhile(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, predicate));, +        return create(OperationTakeWhile.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>(), +        {, +            public Boolean call(T t, Integer integer), +            {, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.LinkedHashMap;, +            a.error(this, e);, +        public void onNext(Object args) {, +     * Receive notifications from each of the Observables we are reducing and execute the combineLatestFunction whenever we have received events from all Observables., +     * , +     * @param <R>, +        private Observer<R> Observer;, +        private AtomicBoolean running = new AtomicBoolean(true);, +         * Use LinkedHashMap to retain the order we receive the CombineLatestObserver objects in., +         * Note that access to this LinkedList inside MUST BE SYNCHRONIZED, +        private Map<CombineObserver<R, ?>, LinkedList<Object>> receivedValuesPerObserver = new LinkedHashMap<CombineObserver<R, ?>, LinkedList<Object>>();, +, +        /**, +         * store when a Observer completes, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED, +         * */, +        private HashSet<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();, +, +        /**, +         * The last value from a Observer, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED, +         * */, +        private HashMap<CombineObserver<R, ?>, Object> lastValue = new HashMap<CombineObserver<R, ?>, Object>();, +         * @param w, +        synchronized void addObserver(CombineObserver<R, ?> w) {, +            // initialize this CombineLatestObserver, +            receivedValuesPerObserver.put(w, new LinkedList<Object>());, +         * @param w, +        synchronized void complete(CombineObserver<R, ?> w) {, +            // store that this ZipObserver is completed, +            if (completed.size() == receivedValuesPerObserver.size()) {, +                    Observer.onCompleted();, +         * , +         * @param w, +        synchronized void error(CombineObserver<R, ?> w, Exception e) {, +            Observer.onError(e);, +            /* tell ourselves to stop processing onNext events, event if the Observers don't obey the unsubscribe we're about to send */, +            running.set(false);, +            /* tell all Observers to unsubscribe since we had an error */, +         * Receive the next value from a Observer., +         * If we have received values from all Observers, trigger the combineLatest function, otherwise store the value and keep waiting., +        void next(CombineObserver<R, ?> w, Object arg) {, +            if (Observer == null) {, +                throw new RuntimeException("This shouldn't be running if a Observer isn't registered");, +            Object[] argsToCombineLatest = new Object[receivedValuesPerObserver.size()];, +            // we synchronize everything that touches receivedValues and the internal LinkedList objects, +            synchronized (this) {, +                // add this value to the queue of the CombineLatestObserver for values received, +                receivedValuesPerObserver.get(w).add(arg);, +                // remember this as the last value for this Observer, +                lastValue.put(w, arg);, +                // if all CombineLatestObservers in 'receivedValues' map have a value, invoke the combineLatestFunction, +                for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {, +                    if (receivedValuesPerObserver.get(rw).peek() == null && !completed.contains(rw)) {, +                        // we have a null (and the Observer isn't completed) meaning the queues aren't all populated so won't do anything, +                // if we get to here this means all the queues have data (or some are completed), +                boolean foundData = false;, +                for (CombineObserver<R, ?> _w : receivedValuesPerObserver.keySet()) {, +                    LinkedList<Object> q = receivedValuesPerObserver.get(_w);, +                    if (q.peek() == null) {, +                        // this is a completed Observer, +                        // we rely on the check above looking at completed.contains to mean that NULL here represents a completed Observer, +                        argsToCombineLatest[i++] = lastValue.get(_w);, +                    } else {, +                        foundData = true;, +                        argsToCombineLatest[i++] = q.remove();, +                    }, +                }, +                if (completed.size() == receivedValuesPerObserver.size() && !foundData) {, +                    // all are completed and queues have run out of data, so return and don't send empty data, +                    return;, +            Observer.onNext(combineLatestFunction.call(argsToCombineLatest));, +        public Subscription call(Observer<R> Observer) {]