[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import scala.concurrent.Await, +  @Test def fattenSomeExample() {, +  @Test def nextExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.next) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def latestExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.latest) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def toFutureExample() {, +    val o = Observable.interval(500 millis).take(1), +    val r = Await.result(o.toBlocking.toFuture, 2 seconds), +    println(r), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import scala.concurrent.Await, +  @Test def fattenSomeExample() {, +  @Test def nextExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.next) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def latestExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.latest) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def toFutureExample() {, +    val o = Observable.interval(500 millis).take(1), +    val r = Await.result(o.toBlocking.toFuture, 2 seconds), +    println(r), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * item. If the source Observable emits more than one item or no items, notify of an `IllegalArgumentException`, +   * or `NoSuchElementException` respectively., +   * @throws IllegalArgumentException if the source emits more than one item, +   * @throws NoSuchElementException if the source emits no items, +    new BlockingObservable[T](this), +    new BlockingObservable[T](this), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import scala.concurrent.Await, +  @Test def fattenSomeExample() {, +  @Test def nextExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.next) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def latestExample() {, +    val o = Observable.interval(100 millis).take(20), +    for(i <- o.toBlocking.latest) {, +      println(i), +      Thread.sleep(200), +    }, +  }, +, +  @Test def toFutureExample() {, +    val o = Observable.interval(500 millis).take(1), +    val r = Await.result(o.toBlocking.toFuture, 2 seconds), +    println(r), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * item. If the source Observable emits more than one item or no items, notify of an `IllegalArgumentException`, +   * or `NoSuchElementException` respectively., +   * @throws IllegalArgumentException if the source emits more than one item, +   * @throws NoSuchElementException if the source emits no items, +    new BlockingObservable[T](this), +    new BlockingObservable[T](this), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/BlockingObservable.scala, +import scala.concurrent.{Future, Promise}, +import rx.lang.scala.Observable, +import rx.observables.{BlockingObservable => JBlockingObservable}, + * You can obtain a BlockingObservable from an Observable using [[rx.lang.scala.Observable.toBlocking]], +// constructor is private because users should use Observable.toBlocking, +class BlockingObservable[+T] private[scala] (val o: Observable[T]), +  // This is def because "field definition is not allowed in value class", +  private def asJava: JBlockingObservable[_ <: T] = o.asJavaObservable.toBlocking, +   * Returns an `Option` with the last item emitted by the source Observable,, +   * or `None` if the source Observable completes without emitting any items.]