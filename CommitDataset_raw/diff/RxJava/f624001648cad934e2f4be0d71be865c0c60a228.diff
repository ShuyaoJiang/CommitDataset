[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * All methods are safe to call from multiple threads, but note that there is no guarantee, + * whose terminal event will win and get delivered to the downstream., + * Calling {@link #onComplete()} multiple times has no effect., + * Calling {@link #onError(Throwable)} multiple times or after {@code onComplete} will route the, + * exception into the global error handler via {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., + * <p>, + * The emitter allows the registration of a single resource, in the form of a {@link Disposable}, + * or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link #setCancellable(Cancellable)}, + * respectively. The emitter implementations will dispose/cancel this instance when the, + * downstream cancels the flow or after the event generator logic calls, + * {@link #onError(Throwable)}, {@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds., + * <p>, + * Only one {@code Disposable} or {@code Cancellable} object can be associated with the emitter at, + * a time. Calling either {@code set} method will dispose/cancel any previous object. If there, + * is a need for handling multiple resources, one can create a {@link io.reactivex.disposables.CompositeDisposable}, + * and associate that with the emitter instead., + * <p>, + * The {@link Cancellable} is logically equivalent to {@code Disposable} but allows using cleanup logic that can, + * throw a checked exception (such as many {@code close()} methods on Java IO components). Since, + * the release of resources happens after the terminal events have been delivered or the sequence gets, + * cancelled, exceptions throw within {@code Cancellable} are routed to the global error handler via, + * {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., +     * Returns true if the downstream disposed the sequence or the, +     * emitter was terminated via {@link #onError(Throwable)},, +     * {@link #onComplete} or a successful {@link #tryOnError(Throwable)}., +     * <p>This method is thread-safe., +     * @return true if the downstream disposed the sequence or the emitter was terminated, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * All methods are safe to call from multiple threads, but note that there is no guarantee, + * whose terminal event will win and get delivered to the downstream., + * Calling {@link #onComplete()} multiple times has no effect., + * Calling {@link #onError(Throwable)} multiple times or after {@code onComplete} will route the, + * exception into the global error handler via {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., + * <p>, + * The emitter allows the registration of a single resource, in the form of a {@link Disposable}, + * or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link #setCancellable(Cancellable)}, + * respectively. The emitter implementations will dispose/cancel this instance when the, + * downstream cancels the flow or after the event generator logic calls, + * {@link #onError(Throwable)}, {@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds., + * <p>, + * Only one {@code Disposable} or {@code Cancellable} object can be associated with the emitter at, + * a time. Calling either {@code set} method will dispose/cancel any previous object. If there, + * is a need for handling multiple resources, one can create a {@link io.reactivex.disposables.CompositeDisposable}, + * and associate that with the emitter instead., + * <p>, + * The {@link Cancellable} is logically equivalent to {@code Disposable} but allows using cleanup logic that can, + * throw a checked exception (such as many {@code close()} methods on Java IO components). Since, + * the release of resources happens after the terminal events have been delivered or the sequence gets, + * cancelled, exceptions throw within {@code Cancellable} are routed to the global error handler via, + * {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., +     * Returns true if the downstream disposed the sequence or the, +     * emitter was terminated via {@link #onError(Throwable)},, +     * {@link #onComplete} or a successful {@link #tryOnError(Throwable)}., +     * <p>This method is thread-safe., +     * @return true if the downstream disposed the sequence or the emitter was terminated, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, + * The {@link #onNext(Object)}, {@link #onError(Throwable)}, {@link #tryOnError(Throwable)}, + * and {@link #onComplete()} methods should be called in a sequential manner, just like, + * the {@link org.reactivestreams.Subscriber Subscriber}'s methods., + * Use the {@code FlowableEmitter} the {@link #serialize()} method returns instead of the original, + * {@code FlowableEmitter} instance provided by the generator routine if you want to ensure this., + * <p>, + * The emitter allows the registration of a single resource, in the form of a {@link Disposable}, + * or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link #setCancellable(Cancellable)}, + * respectively. The emitter implementations will dispose/cancel this instance when the, + * downstream cancels the flow or after the event generator logic calls {@link #onError(Throwable)},, + * {@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds., + * <p>, + * Only one {@code Disposable} or {@code Cancellable} object can be associated with the emitter at, + * a time. Calling either {@code set} method will dispose/cancel any previous object. If there, + * is a need for handling multiple resources, one can create a {@link io.reactivex.disposables.CompositeDisposable}, + * and associate that with the emitter instead., + * <p>, + * The {@link Cancellable} is logically equivalent to {@code Disposable} but allows using cleanup logic that can, + * throw a checked exception (such as many {@code close()} methods on Java IO components). Since, + * the release of resources happens after the terminal events have been delivered or the sequence gets, + * cancelled, exceptions throw within {@code Cancellable} are routed to the global error handler via, + * {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., +     * Returns true if the downstream cancelled the sequence or the, +     * emitter was terminated via {@link #onError(Throwable)}, {@link #onComplete} or a, +     * successful {@link #tryOnError(Throwable)}., +     * @return true if the downstream cancelled the sequence or the emitter was terminated, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * All methods are safe to call from multiple threads, but note that there is no guarantee, + * whose terminal event will win and get delivered to the downstream., + * Calling {@link #onComplete()} multiple times has no effect., + * Calling {@link #onError(Throwable)} multiple times or after {@code onComplete} will route the, + * exception into the global error handler via {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., + * <p>, + * The emitter allows the registration of a single resource, in the form of a {@link Disposable}, + * or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link #setCancellable(Cancellable)}, + * respectively. The emitter implementations will dispose/cancel this instance when the, + * downstream cancels the flow or after the event generator logic calls, + * {@link #onError(Throwable)}, {@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds., + * <p>, + * Only one {@code Disposable} or {@code Cancellable} object can be associated with the emitter at, + * a time. Calling either {@code set} method will dispose/cancel any previous object. If there, + * is a need for handling multiple resources, one can create a {@link io.reactivex.disposables.CompositeDisposable}, + * and associate that with the emitter instead.]