[+++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED_UPDATER, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;, +            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {, +                if (actualSubscriber == null && wip > 0) {, +                    // return here as we don't want to do the requestMore logic below (which would double request), +                    return;, +                , +            if (actualSubscriber != null) {, +                // otherwise we are just passing it through to the currentSubscriber, +                actualSubscriber.requestMore(n);, +            }, +            REQUESTED_UPDATER.decrementAndGet(this);, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {, +            request(initialRequest);, +        }, +, +        void requestMore(long n) {, +            request(n);, +            child.onNext(t);, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED_UPDATER, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;, +            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {, +                if (actualSubscriber == null && wip > 0) {, +                    // return here as we don't want to do the requestMore logic below (which would double request), +                    return;, +                , +            if (actualSubscriber != null) {, +                // otherwise we are just passing it through to the currentSubscriber, +                actualSubscriber.requestMore(n);, +            }, +            REQUESTED_UPDATER.decrementAndGet(this);, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {, +            request(initialRequest);, +        }, +, +        void requestMore(long n) {, +            request(n);, +            child.onNext(t);, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +++ b/src/main/java/rx/internal/producers/ProducerArbiter.java, +                    throw new IllegalStateException();, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED_UPDATER, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;, +            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {, +                if (actualSubscriber == null && wip > 0) {, +                    // return here as we don't want to do the requestMore logic below (which would double request), +                    return;, +                , +            if (actualSubscriber != null) {, +                // otherwise we are just passing it through to the currentSubscriber, +                actualSubscriber.requestMore(n);, +            }, +            REQUESTED_UPDATER.decrementAndGet(this);, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.getAndIncrement(this) == 0) {, +            if (WIP_UPDATER.decrementAndGet(this) > 0) {, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);, +        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {, +            request(initialRequest);, +        }, +, +        void requestMore(long n) {, +            request(n);, +            child.onNext(t);, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {, +++ b/src/main/java/rx/internal/producers/ProducerArbiter.java, +                    throw new IllegalStateException();, +++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java, +import rx.Scheduler.Worker;, +import rx.functions.Action0;, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +        // accessed by REQUESTED_UPDATER, +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;, +            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {]