[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Creates an Observable with a Function to execute when it is subscribed to., +     * Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass, +     * the values of the current Observable through the Operator function., +     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe(), +     * @param lift the Operator that implements the Observable-operating function to be applied to the source, +     *             Observable, +     * @return an Observable that is the result of applying the lifted Operator to the source Observable, +     * Mirrors the one Observable in an Iterable of several Observables that first emits an item., +     * Given two Observables, mirrors the one that first emits an item., +     * Given three Observables, mirrors the one that first emits an item., +     * Given four Observables, mirrors the one that first emits an item., +     * Given five Observables, mirrors the one that first emits an item., +     * Given six Observables, mirrors the one that first emits an item., +     * Given seven Observables, mirrors the one that first emits an item., +     * Given eight Observables, mirrors the one that first emits an item., +     * Given nine Observables, mirrors the one that first emits an item., +     * Combines a list of source Observables by emitting an item that aggregates the latest values of each of, +     * the source Observables each time an item is received from any of the source Observables, where this, +     *, +     * @param <T>, +     *            the common base type of source values, +     * @param <R>, +     *            the result type, +     * @param sources, +     *            the list of source Observables, +     * Returns an Observable that emits the items emitted by each of the Observables emitted by the source, +     * Observable, one after the other, without interleaving them., +     * @return an Observable that emits items all of the items emitted by the Observables emitted by, +     *         {@code observables}, one after the other, without interleaving them, +     * Returns an Observable that calls an Observable factory to create an Observable for each new Observer, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its, +     * {@link Observer#onCompleted onCompleted} method., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the, +     *         {@link Observer}'s {@link Observer#onCompleted() onCompleted} method, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its, +     * {@link Observer#onCompleted onCompleted} method on the specified Scheduler., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the, +     *         {@link Observer}'s {@link Observer#onCompleted() onCompleted} method with the specified, +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}, +     * method., +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}, +     * method., +     *            the maximum time to wait before calling {@code get}, +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}, +     * method., +     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as, +     *            {@link Schedulers#io()} that can block and wait on the Future, +     * To convert any object into an Observable that emits that object, pass that object into the {@code just}, +     * method., +     * This is similar to the {@link #from(java.lang.Object[])} method, except that {@code from} will convert, +     * time, while the {@code just} method converts an Iterable into an Observable that emits the entire, +     * @return an Observable that emits items that are the result of flattening the Observables emitted by the, +     *         {@code source} Observable, +     * @return an Observable that emits items that are the result of flattening the Observables emitted by the, +     *         {@code source} Observable, +     * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to, +     * receive all successfully emitted items from all of the source Observables without being interrupted by, +     * an error notification from one of them., +     * @return an Observable that emits all of the items emitted by the Observables emitted by the, +     *         {@code source} Observable, +     * Flattens two Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from each of the source Observables without being interrupted by an error, +     * notification from one of them., +     * Flattens three Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * Flattens four Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError}, +     * will refrain from propagating that error notification until all of the merged Observables have finished, +     * Flattens five Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * if any of the merged Observables notify of an error via {@link Observer#onError onError},, +     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * Flattens six Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable)}, +     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},, +     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * Flattens seven Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * This behaves like, +     * {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable)}, +     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},, +     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * Flattens eight Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)}, +     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},, +     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * Flattens nine Observables into one Observable, in a way that allows an Observer to receive all, +     * successfully emitted items from all of the source Observables without being interrupted by an error, +     * notification from one of them., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)}]