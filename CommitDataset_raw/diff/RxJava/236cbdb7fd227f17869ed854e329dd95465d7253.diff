[+++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +  (:import [rx, +            Observable, +            Observer Observable$Operator Observable$OnSubscribe, +            Subscriber Subscription], +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action))), +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action), +                ^Action1 (iop/action* on-error-action))), +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action), +                ^Action1 (iop/action* on-error-action), +                ^Action0 (iop/action* on-completed-action)))), +  ([o on-next-action on-error-action] (->subscriber o on-next-action on-error-action nil)), +(defn ^Observable$Operator fn->operator, +  "Create a basic Operator with f. If a handler is omitted or nil, +  [f], +  {:pre [(fn? f)]}, +      (f o)))), +         (rx/lift (rx/fn->operator ...)), +    fn->operator, +    (when-not (unsubscribed? observer), +      (.onCompleted observer)))), +        (when-not (unsubscribed? observer), +          (.onError observer e)))))), +  "Observable.mergeDelayError", +  "rx.Observable.zip. You want map.", +, +(defn ^Observable never, +  "Returns an Observable that never emits any values and never completes., +  See:, +    rx.Observable/never, +  ", +  [], +  (Observable/never)), +(defn ^Observable empty, +  "Returns an Observable that completes immediately without emitting any values., +  See:, +    rx.Observable/empty, +  ", +  [], +  (Observable/empty)), +    rx.Observable/just, +  (let [op (fn->operator (fn [o], +  (let [op (fn->operator (fn [o], +  "Creates an observable that calls (f observable & args) which should emit values, +  with (rx/on-next observable value)., +  f should exit early if (rx/unsubscribed? observable) returns true, +    (rx/generator* on-next 99), +  The body should exit early if (rx/unsubscribed? observable) returns true, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +  (:import [rx, +            Observable, +            Observer Observable$Operator Observable$OnSubscribe, +            Subscriber Subscription], +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action))), +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action), +                ^Action1 (iop/action* on-error-action))), +, +    (.subscribe o, +                ^Action1 (iop/action* on-next-action), +                ^Action1 (iop/action* on-error-action), +                ^Action0 (iop/action* on-completed-action)))), +  ([o on-next-action on-error-action] (->subscriber o on-next-action on-error-action nil)), +(defn ^Observable$Operator fn->operator, +  "Create a basic Operator with f. If a handler is omitted or nil, +  [f], +  {:pre [(fn? f)]}, +      (f o)))), +         (rx/lift (rx/fn->operator ...)), +    fn->operator, +    (when-not (unsubscribed? observer), +      (.onCompleted observer)))), +        (when-not (unsubscribed? observer), +          (.onError observer e)))))), +  "Observable.mergeDelayError", +  "rx.Observable.zip. You want map.", +, +(defn ^Observable never, +  "Returns an Observable that never emits any values and never completes., +  See:, +    rx.Observable/never, +  ", +  [], +  (Observable/never)), +(defn ^Observable empty, +  "Returns an Observable that completes immediately without emitting any values., +  See:, +    rx.Observable/empty, +  ", +  [], +  (Observable/empty))]