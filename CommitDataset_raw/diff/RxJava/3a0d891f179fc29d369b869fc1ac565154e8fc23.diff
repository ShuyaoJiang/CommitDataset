[+++ b/rxjava-core/src/main/java/rx/Subscriber.java, +        int toRequest;, +            toRequest = requested;, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +        int toRequest;, +            toRequest = requested;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java, +                    emitted += s.drainQueue();, +                    //                    }, +                parentSubscriber.drainQueuesIfNeeded();, +        private int drainRequested() {, +            int emitted = 0;, +            // drain what was requested, +            long toEmit = producer.requested;, +            Object o;, +            for (int i = 0; i < toEmit; i++) {, +                o = q.poll();, +                if (o == null) {, +                    // no more items, +                    break;, +                } else if (q.isCompleted(o)) {, +                    parentSubscriber.completeInner(this);, +                } else {, +                    if (!q.accept(o, parentSubscriber.actual)) {, +                        emitted++;, +                    }, +                }, +            }, +, +            // decrement the number we emitted from outstanding requests, +            producer.REQUESTED.getAndAdd(producer, -emitted);, +            return emitted;, +        }, +, +        private int drainAll() {, +            int emitted = 0;, +            // drain it all, +                if (q.isCompleted(o)) {, +                    parentSubscriber.completeInner(this);, +                        emitted++;, +            return emitted;, +, +        private int drainQueue() {, +            if (producer != null) {, +                return drainRequested();, +            } else {, +                return drainAll();, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +        int toRequest;, +            toRequest = requested;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java, +                    emitted += s.drainQueue();, +                    //                    }, +                parentSubscriber.drainQueuesIfNeeded();, +        private int drainRequested() {, +            int emitted = 0;, +            // drain what was requested, +            long toEmit = producer.requested;, +            Object o;, +            for (int i = 0; i < toEmit; i++) {, +                o = q.poll();, +                if (o == null) {, +                    // no more items, +                    break;, +                } else if (q.isCompleted(o)) {, +                    parentSubscriber.completeInner(this);, +                } else {, +                    if (!q.accept(o, parentSubscriber.actual)) {, +                        emitted++;, +                    }, +                }, +            }, +, +            // decrement the number we emitted from outstanding requests, +            producer.REQUESTED.getAndAdd(producer, -emitted);, +            return emitted;, +        }, +, +        private int drainAll() {, +            int emitted = 0;, +            // drain it all, +                if (q.isCompleted(o)) {, +                    parentSubscriber.completeInner(this);, +                        emitted++;, +            return emitted;, +, +        private int drainQueue() {, +            if (producer != null) {, +                return drainRequested();, +            } else {, +                return drainAll();, +++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java, +/**, + * This assumes Spsc or Spmc usage. This means only a single producer calling the on* methods. This is the Rx contract of an Observer., + * Concurrent invocations of on* methods will not be thread-safe., + */, +     * With SynchronizedQueue (synchronized LinkedList), +     * , +     * r.i.RxRingBufferPerf.createUseAndDestroy1       thrpt         5 33231667.136   685757.510    ops/s, +     * r.i.RxRingBufferPerf.createUseAndDestroy1000    thrpt         5    74623.614     5493.766    ops/s]