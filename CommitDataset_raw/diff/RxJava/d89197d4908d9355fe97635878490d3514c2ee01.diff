[+++ b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.subscriptions.BooleanSubscription;, +        private final AtomicObservableSubscription actualParentSubscription = new AtomicObservableSubscription();, +        private final AtomicInteger numGroupSubscriptions = new AtomicInteger();, +        private final AtomicBoolean unsubscribeRequested = new AtomicBoolean(false);, +            final GroupBy<K, V> _this = this;, +            actualParentSubscription.wrap(source.subscribe(new Observer<KeyValue<K, V>>() {, +                        if (unsubscribeRequested.get()) {, +                            // unsubscribe has been requested so don't create new groups, +                            // only send data to groups already created, +                            return;, +                        }, +                        GroupedSubject<K, V> newGs = GroupedSubject.<K, V> create(value.key, _this);, +            }));, +, +            return new Subscription() {, +, +                @Override, +                public void unsubscribe() {, +                    if (numGroupSubscriptions.get() == 0) {, +                        // if we have no group subscriptions we will unsubscribe, +                        actualParentSubscription.unsubscribe();, +                        // otherwise we mark to not send any more groups (waiting on existing groups to finish), +                        unsubscribeRequested.set(true);, +                    }, +                }, +            };, +        }, +, +        /**, +         * Children notify of being subscribed to., +         * , +         * @param key, +         */, +        private void subscribeKey(K key) {, +            numGroupSubscriptions.incrementAndGet();, +        }, +, +        /**, +         * Children notify of being unsubscribed from., +         * , +         * @param key, +         */, +        private void unsubscribeKey(K key) {, +            int c = numGroupSubscriptions.decrementAndGet();, +            if (c == 0) {, +                actualParentSubscription.unsubscribe();, +            }, +        static <K, T> GroupedSubject<K, T> create(final K key, final GroupBy<K, T> parent) {, +                private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();, +, +                    parent.subscribeKey(key);, +, +                    return subscription.wrap(new Subscription() {, +                            // now we need to notify the parent that we're unsubscribed, +                            parent.unsubscribeKey(key);, +                    });, +        @Test, +        public void testError() {, +            Observable<String> sourceStrings = Observable.from("one", "two", "three", "four", "five", "six");, +            Observable<String> errorSource = Observable.error(new RuntimeException("forced failure"));, +            @SuppressWarnings("unchecked"), +            Observable<String> source = Observable.concat(sourceStrings, errorSource);, +, +            Observable<GroupedObservable<Integer, String>> grouped = Observable.create(groupBy(source, length));, +, +            final AtomicInteger groupCounter = new AtomicInteger();, +            final AtomicInteger eventCounter = new AtomicInteger();, +            final AtomicReference<Exception> error = new AtomicReference<Exception>();, +, +            grouped.mapMany(new Func1<GroupedObservable<Integer, String>, Observable<String>>() {, +, +                @Override, +                public Observable<String> call(final GroupedObservable<Integer, String> o) {, +                    groupCounter.incrementAndGet();, +                    return o.map(new Func1<String, String>() {, +, +                        @Override, +                        public String call(String v) {, +                            return "Event => key: " + o.getKey() + " value: " + v;, +                        }, +                    });, +                }, +            }).subscribe(new Observer<String>() {, +, +                @Override, +                public void onCompleted() {, +, +                }, +, +                @Override, +                public void onError(Exception e) {, +                    e.printStackTrace();, +                    error.set(e);, +                }, +, +                @Override, +                public void onNext(String v) {, +                    eventCounter.incrementAndGet();]