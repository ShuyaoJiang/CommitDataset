[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.observers.SafeSubscriber;, +import rx.operators.OperationTakeTimed;, +     * time as an Observer subscribes to the Observable. This allows an {@link Observer} to easily, +     *            the Observable factory function to invoke for each {@link Observer} that, +     * @return an Observable whose {@link Observer}s' subscriptions trigger an invocation of the, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method on the specified scheduler., +     *            the scheduler to use to call the {@link Observer#onCompleted onCompleted} method, +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method with the, +     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it., +     *            the particular Throwable to pass to {@link Observer#onError onError}, +     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it, +     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method on the specified scheduler., +     *            the particular Throwable to pass to {@link Observer#onError onError}, +     *            the scheduler on which to call {@link Observer#onError onError}, +     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method, on the specified scheduler, +     * Note: the entire iterable sequence is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not possible, +     * Note: the item is immediately emitted each time an {@link Observer} subscribes. Since this, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * Note: the items will be immediately emitted each time an {@link Observer} subscribes. Since, +     * <em>Note:</em> the entire array is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not possible, +     * <em>Note:</em> the entire array is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not, +     * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain, +     * Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged Observables, +     * the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of, +     * if any of the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of, +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via {@link Observer#onError onError}, +     * {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * Returns an Observable that never sends any items or notifications to an {@link Observer}., +     * @return an Observable that never emits any items or sends any notifications to an {@link Observer}, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * subscribe/unsubscribe behavior of all the {@link Observer}s., +        Observer<T> observer = new Observer<T>() {, +        Observer<T> observer = new Observer<T>() {, +    public final Observable<T> doOnEach(Observer<? super T> observer) {, +        Observer<T> observer = new Observer<T>() {, +        Observer<T> observer = new Observer<T>() {, +     * Registers an {@link Action0} to be called when this Observable invokes either {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}., +     * Modify the source Observable so that it asynchronously notifies {@link Observer}s on the, +     *            the {@link Scheduler} to notify {@link Observer}s on, +     * @return the source Observable modified so that its {@link Observer}s are notified on the, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an error., +     * expected item to its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits without invoking any more of its Observer's methods. The, +     * will invoke the Observer's {@link Observer#onNext onNext} method if it is able to do so. In, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an error., +     * expected item to its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits without invoking any more of its Observer's methods. The, +     * will instead relinquish control to {@code resumeSequence} which will invoke the Observer's {@link Observer#onNext onNext} method if it is able to do so. In such a case, because no, +     * invoking {@link Observer#onError onError} if it encounters an error., +     * expected item to its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits without invoking any more of its Observer's methods. The, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an {@link java.lang.Exception}., +     * expected item to its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits without invoking any more of its Observer's methods. The, +     * will invoke the Observer's {@link Observer#onNext onNext} method if it is able to do so. In, +        return subscribe(new SafeSubscriber<T>(o));, +     * items to those {@link Observer}s that have subscribed to it., +     *         emit items to its {@link Observer}s, +     * Observable that will replay all of its items and notifications to any future {@link Observer}., +     *         emit its items to its {@link Observer}s, +     * Observable that will replay all of its items and notifications to any future {@link Observer} on the given {@link Scheduler}., +     *         Observable that will replay all of its items and notifications to any future {@link Observer} on the given {@link Scheduler}, +     * If the source Observable calls {@link Observer#onError}, this method will resubscribe to the, +     * If the source Observable calls {@link Observer#onError}, this method will resubscribe to the, +     *            Observable, whose result will be emitted to {@link Observer}s via {@link Observer#onNext onNext} and used in the next accumulator call, +     *            Observable, whose result will be emitted to {@link Observer}s via {@link Observer#onNext onNext} and used in the next accumulator call, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive, +     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving, +    public final Subscription subscribe(final Observer<? super T> observer) {, +        return subscribe(new Subscriber<T>() {, +, +            @Override, +            public void onCompleted() {, +                observer.onCompleted();]