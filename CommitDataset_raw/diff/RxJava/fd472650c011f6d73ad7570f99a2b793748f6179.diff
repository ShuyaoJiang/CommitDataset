[+++ b/README.md, +### Setting up the dependency, +, +(Please replace `x` and `y` with the latest version numbers: [![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava2/rxjava/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava2/rxjava), +), +, +### Hello World, +, +### Base classes, +, +  - [`io.reactivex.Observable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html): 0..N flows, no backpressure,, +  - [`io.reactivex.Single`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html): a flow of exactly 1 item or an error,, +  - [`io.reactivex.Completable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html): a flow without items but only a completion or error signal,, +  - [`io.reactivex.Maybe`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html): a flow with no items, exactly one item or an error., +, +### Some terminology, +, +#### Upstream, downstream, +, +The dataflows in RxJava consist of a source, zero or more intermediate steps followed by a data consumer or combinator step (where the step is responsible to consume the dataflow by some means):, +, +```java, +source.operator1().operator2().operator3().subscribe(consumer);, +, +source.flatMap(value -> source.operator1().operator2().operator3());, +```, +, +Here, if we imagine ourselves on `operator2`, looking to the left towards the source, is called the **upstream**. Looking to the right towards the subscriber/consumer, is called the **downstream**. This is often more apparent when each element is written on a separate line:, +, +```java, +source, +  .operator1(), +  .operator2(), +  .operator3(), +  .subscribe(consumer), +```, +, +#### Objects in motion, +, +In RxJava's documentation, **emission**, **emits**, **item**, **event**, **signal**, **data** and **message** are considered synonyms and represent the object traveling along the dataflow., +, +#### Backpressure, +, +When the dataflow runs through asynchronous steps, each step may perform different things with different speed. To avoid overwhelming such steps, which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping/dropping data, a so-called backpressure is applied, which is a form of flow control where the steps can express how many items are they ready to process. This allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it., +, +In RxJava, the dedicated `Flowable` class is designated to support backpressure and `Observable` is dedicated for the non-backpressured operations (short sequences, GUI interactions, etc.). The other types, `Single`, `Maybe` and `Completable` don't support backpressure nor should they; there is always room to store one item temporarily., +, +#### Assembly time, +, +The preparation of dataflows by applying various intermediate operators happens in the so-called **assembly time**:, +, +```java, +Flowable<Integer> flow = Flowable.range(1, 5), +.map(v -> v* v), +.filter(v -> v % 3 == 0), +;, +```, +, +At this point, the data is not flowing yet and no side-effects are happening., +, +#### Subscription time, +, +This is a temporary state when `subscribe()` is called on a flow that establishes the chain of processing steps internally:, +, +```java, +flow.subscribe(System.out::println), +````, +, +This is when the **subscription side-effects** are triggered (see `doOnSubscribe`). Some sources block or start emitting items right away in this state., +, +#### Runtime, +, +This is the state when the flows are actively emitting items, errors or completion signals:, +, +```java, +, +Observable.create(emitter -> {, +     while (!emitter.isDisposed()) {, +         long time = System.currentTimeMillis();, +         emitter.onNext(time);, +         if (time % 2 != 0) {, +             emitter.onError(new IllegalStateException("Odd millisecond!");, +             break;, +         }, +     }, +}), +.subscribe(System.out::println, Throwable::printStackTrace);, +```, +, +Practically, this is when the body of the given example above executes., +, +### Simple background computation, +### Schedulers, +, +RxJava operators don't work with `Thread`s or `ExecutorService`s directly but with so called `Scheduler`s that abstract away sources of concurrency behind an uniform API. RxJava 2 features several standard schedulers accessible via `Schedulers` utility class. , +, +- `Schedulers.computation()`: Run computation intensive work on a fixed number of dedicated threads in the background. Most asynchronous operator use this as their default `Scheduler`., +- `Schedulers.io()`: Run I/O-like or blocking operations on a dynamically changing set of threads., +- `Schedulers.single()`: Run work on a single thread in a sequential and FIFO manner., +- `Schedulers.trampoline()`: Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.]