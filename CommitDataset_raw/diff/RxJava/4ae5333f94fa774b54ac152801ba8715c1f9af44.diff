[+++ b/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    /** The atomic state updater. */, +    static final AtomicReferenceFieldUpdater<CompositeSubscription, State> STATE_UPDATER, +            = AtomicReferenceFieldUpdater.newUpdater(CompositeSubscription.class, State.class, "state");, +    /** The subscription state. */, +    volatile State state;, +        // this creates only a store-store barrier which is generally faster when, +        // CompositeSubscriptions are created in a tight loop., +        STATE_UPDATER.lazySet(this, CLEAR_STATE);, +        STATE_UPDATER.lazySet(this, new State(false, subscriptions));, +        return state.isUnsubscribed;, +            oldState = state;, +        } while (!STATE_UPDATER.compareAndSet(this, oldState, newState));, +            oldState = state;, +        } while (!STATE_UPDATER.compareAndSet(this, oldState, newState));, +            oldState = state;, +        } while (!STATE_UPDATER.compareAndSet(this, oldState, newState));, +        State oldState = state;, +        // intrinsics may make this a single instruction and may prevent concurrent add/remove faster, +        oldState = STATE_UPDATER.getAndSet(this, oldState.unsubscribe());]