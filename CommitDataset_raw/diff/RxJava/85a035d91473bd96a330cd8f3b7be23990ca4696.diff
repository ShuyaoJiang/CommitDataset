[+++ b/src/main/java/rx/internal/operators/OperatorAny.java, +                boolean result = predicate.call(t);, +                    child.onNext(!returnOnEmpty);, +                    child.onCompleted();, +                } else {, +                    // if we drop values we must replace them upstream as downstream won't receive and request more, +                    request(1);, +                        child.onNext(false);, +                        child.onNext(returnOnEmpty);, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorAny.java, +                boolean result = predicate.call(t);, +                    child.onNext(!returnOnEmpty);, +                    child.onCompleted();, +                } else {, +                    // if we drop values we must replace them upstream as downstream won't receive and request more, +                    request(1);, +                        child.onNext(false);, +                        child.onNext(returnOnEmpty);, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorTake.java, +import java.util.concurrent.atomic.AtomicLong;, +, +                    // keeps track of requests up to maximum of `limit`, +                    final AtomicLong requested = new AtomicLong(0);, +                    , +                        if (n >0 && !completed) {, +                            // because requests may happen concurrently use a CAS loop to , +                            // ensure we only request as much as needed, no more no less, +                            while (true) {, +                                long r = requested.get();, +                                long c = Math.min(n, limit - r);, +                                if (c == 0), +                                    break;, +                                else if (requested.compareAndSet(r, r + c)) {, +                                    break;, +                                }, +++ b/src/main/java/rx/internal/operators/OperatorAny.java, +                boolean result = predicate.call(t);, +                    child.onNext(!returnOnEmpty);, +                    child.onCompleted();, +                } else {, +                    // if we drop values we must replace them upstream as downstream won't receive and request more, +                    request(1);, +                        child.onNext(false);, +                        child.onNext(returnOnEmpty);, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorTake.java, +import java.util.concurrent.atomic.AtomicLong;, +, +                    // keeps track of requests up to maximum of `limit`, +                    final AtomicLong requested = new AtomicLong(0);, +                    , +                        if (n >0 && !completed) {, +                            // because requests may happen concurrently use a CAS loop to , +                            // ensure we only request as much as needed, no more no less, +                            while (true) {, +                                long r = requested.get();, +                                long c = Math.min(n, limit - r);, +                                if (c == 0), +                                    break;, +                                else if (requested.compareAndSet(r, r + c)) {, +                                    break;, +                                }, +++ b/src/test/java/rx/internal/operators/OperatorAnyTest.java, +++ b/src/main/java/rx/internal/operators/OperatorAny.java, +                boolean result = predicate.call(t);, +                    child.onNext(!returnOnEmpty);, +                    child.onCompleted();, +                } else {, +                    // if we drop values we must replace them upstream as downstream won't receive and request more, +                    request(1);, +                        child.onNext(false);, +                        child.onNext(returnOnEmpty);, +                    child.onCompleted();, +++ b/src/main/java/rx/internal/operators/OperatorTake.java, +import java.util.concurrent.atomic.AtomicLong;, +, +                    // keeps track of requests up to maximum of `limit`, +                    final AtomicLong requested = new AtomicLong(0);, +                    , +                        if (n >0 && !completed) {, +                            // because requests may happen concurrently use a CAS loop to , +                            // ensure we only request as much as needed, no more no less, +                            while (true) {, +                                long r = requested.get();, +                                long c = Math.min(n, limit - r);, +                                if (c == 0), +                                    break;, +                                else if (requested.compareAndSet(r, r + c)) {, +                                    break;, +                                }, +++ b/src/test/java/rx/internal/operators/OperatorAnyTest.java, +++ b/src/test/java/rx/internal/operators/OperatorTakeTest.java, +import java.util.concurrent.TimeUnit;, +    , +    @Test, +    public void testDoesntRequestMoreThanNeededFromUpstream() throws InterruptedException {, +        final AtomicLong requests = new AtomicLong();, +        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);]