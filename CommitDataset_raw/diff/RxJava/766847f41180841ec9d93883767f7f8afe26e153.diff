[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +    o.observeOn(NewThreadScheduler()).subscribe(, +    o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +    o.observeOn(NewThreadScheduler()).subscribe(, +    o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//  implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +//    new Func2[rx.Scheduler, T, rx.Subscription] {, +//      def call(s: rx.Scheduler, t: T): rx.Subscription = {, +//        action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +//      }, +//    }, +, +        action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +    o.observeOn(NewThreadScheduler()).subscribe(, +    o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//  implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +//    new Func2[rx.Scheduler, T, rx.Subscription] {, +//      def call(s: rx.Scheduler, t: T): rx.Subscription = {, +//        action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +//      }, +//    }, +, +        action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +    zip(that, (t: T, u: U) => (t, u)), +  }, +, +  /**, +   * Returns an Observable formed from this Observable and another Observable by combining, +   * corresponding elements using the selector function., +   * The number of `onNext` invocations of the resulting `Observable[(T, U)]`, +   * is the minumum of the number of `onNext` invocations of `this` and `that`., +   *, +   * Note that this function is private because Scala collections don't have such a function., +   */, +  private def zip[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {, +    Observable[R](rx.Observable.zip[T, U, R](this.asJavaObservable, that.asJavaObservable, selector)), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +    o.observeOn(NewThreadScheduler()).subscribe(, +    o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//  implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +//    new Func2[rx.Scheduler, T, rx.Subscription] {, +//      def call(s: rx.Scheduler, t: T): rx.Subscription = {, +//        action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +//      }, +//    }, +, +        action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +    zip(that, (t: T, u: U) => (t, u)), +  }, +, +  /**, +   * Returns an Observable formed from this Observable and another Observable by combining, +   * corresponding elements using the selector function., +   * The number of `onNext` invocations of the resulting `Observable[(T, U)]`, +   * is the minumum of the number of `onNext` invocations of `this` and `that`., +   *, +   * Note that this function is private because Scala collections don't have such a function., +   */, +  private def zip[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {, +    Observable[R](rx.Observable.zip[T, U, R](this.asJavaObservable, that.asJavaObservable, selector)), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observer.scala, +import rx.joins.ObserverBase, +, +, +  private [scala] def apply[T](observer: rx.Observer[T]) : Observer[T] = {, +, +  /**, +   * Creates an [[rx.lang.scala.Observer]], +   * @param onNext the onNext action, +   * @param onError the onError action, +   * @param onCompleted the onCompleted action, +   */, +  def apply[T](onNext: T => Unit, onError: Throwable => Unit, onCompleted: () => Unit): Observer[T] = {, +    Observer(new ObserverBase[T] () {, +      protected def onCompletedCore(): Unit = onCompleted(), +      protected def onErrorCore(error: Throwable): Unit = onError(error), +      protected def onNextCore(value: T): Unit = onNext(value), +    }), +  }, +]