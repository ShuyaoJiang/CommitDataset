[+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                return notifications.poll();, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                return notifications.poll();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicLong;, +import rx.Observable.OnSubscribe;, +import rx.Producer;, +        @SuppressWarnings("unchecked"), +        final Subscriber<? super T>[] ss = new Subscriber[degreeOfParallelism];, +        final ParentSubscriber subscriber = new ParentSubscriber(child, ss);, +        for (int i = 0; i < os.length; i++) {, +            final int index = i;, +            Observable<T> o = Observable.create(new OnSubscribe<T>() {, +, +                @Override, +                public void call(Subscriber<? super T> inner) {, +                    ss[index] = inner;, +                    child.add(inner); // unsubscribe chain, +                    inner.setProducer(new Producer() {, +, +                        @Override, +                        public void request(long n) {, +                            // as we receive requests from observeOn propagate upstream to the parent Subscriber, +                            subscriber.requestMore(n);, +                        }, +, +                    });, +                }, +, +            });, +            os[i] = f.call(o.observeOn(scheduler));, +        return subscriber;, +    }, +    private class ParentSubscriber extends Subscriber<T> {, +        final Subscriber<? super R> child;, +        final Subscriber<? super T>[] ss;, +        int index = 0;, +        final AtomicLong initialRequest = new AtomicLong();, +        final AtomicBoolean started = new AtomicBoolean();, +, +        private ParentSubscriber(Subscriber<? super R> child, Subscriber<? super T>[] ss) {, +            super(child);, +            this.child = child;, +            this.ss = ss;, +        }, +, +        public void requestMore(long n) {, +            if (started.get()) {, +                request(n);, +            } else {, +                initialRequest.addAndGet(n);, +            }, +        }, +, +        @Override, +        public void onStart() {, +            if (started.compareAndSet(false, true)) {, +                // if no request via requestMore has been sent yet, we start with 0 (rather than default Long.MAX_VALUE)., +                request(initialRequest.get());, +            }, +        }, +            for (Subscriber<? super T> s : ss) {, +            /*, +             * There is a possible bug here ... we could get a MissingBackpressureException, +             * if the processing on each of the threads is unbalanced. In other words, if 1 of the, +             * observeOn queues has space, but another is full, this could try emitting to one that, +             * is full and get a MissingBackpressureException., +             * , +             * To solve that we'd need to check the outstanding request per Subscriber, which will, +             * need a more complicated mechanism to expose a type that has both the requested + the, +             * Subscriber to emit to., +             */, +            ss[index++].onNext(t);, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +                return notifications.poll();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicLong;, +import rx.Observable.OnSubscribe;, +import rx.Producer;, +        @SuppressWarnings("unchecked"), +        final Subscriber<? super T>[] ss = new Subscriber[degreeOfParallelism];, +        final ParentSubscriber subscriber = new ParentSubscriber(child, ss);, +        for (int i = 0; i < os.length; i++) {, +            final int index = i;, +            Observable<T> o = Observable.create(new OnSubscribe<T>() {, +, +                @Override, +                public void call(Subscriber<? super T> inner) {, +                    ss[index] = inner;, +                    child.add(inner); // unsubscribe chain, +                    inner.setProducer(new Producer() {, +, +                        @Override, +                        public void request(long n) {, +                            // as we receive requests from observeOn propagate upstream to the parent Subscriber, +                            subscriber.requestMore(n);, +                        }]