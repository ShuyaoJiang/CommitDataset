[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Forces an Observable to make synchronous calls and to be well-behaved., +     * <p>, +     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different, +     * threads. This could make an Observable poorly-behaved, in that it might invoke {@code onCompleted} or, +     * {@code onError} before one of its {@code onNext} invocations. You can force such an Observable to be, +     * well-behaved and synchronous by applying the {@code serialize()} method to it., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png">, +     *, +     * @return a {@link Observable} that is guaranteed to be well-behaved and synchronous, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize">RxJava Wiki: serialize()</a>, +     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as, +     * there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. , +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png">, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount">RxJava Wiki: refCount()</a>, +     * @since 0.19, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +        return toBlockingObservable();, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Forces an Observable to make synchronous calls and to be well-behaved., +     * <p>, +     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different, +     * threads. This could make an Observable poorly-behaved, in that it might invoke {@code onCompleted} or, +     * {@code onError} before one of its {@code onNext} invocations. You can force such an Observable to be, +     * well-behaved and synchronous by applying the {@code serialize()} method to it., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png">, +     *, +     * @return a {@link Observable} that is guaranteed to be well-behaved and synchronous, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize">RxJava Wiki: serialize()</a>, +     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as, +     * there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. , +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png">, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount">RxJava Wiki: refCount()</a>, +     * @since 0.19, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +        return toBlockingObservable();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, + * <code>Observable</code> with {@link #from(Observable)} or {@link Observable#toBlockingObservable()} <p>, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Forces an Observable to make synchronous calls and to be well-behaved., +     * <p>, +     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different, +     * threads. This could make an Observable poorly-behaved, in that it might invoke {@code onCompleted} or, +     * {@code onError} before one of its {@code onNext} invocations. You can force such an Observable to be, +     * well-behaved and synchronous by applying the {@code serialize()} method to it., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png">, +     *, +     * @return a {@link Observable} that is guaranteed to be well-behaved and synchronous, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize">RxJava Wiki: serialize()</a>, +     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as, +     * there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. , +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png">, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount">RxJava Wiki: refCount()</a>, +     * @since 0.19, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +        return toBlockingObservable();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, + * <code>Observable</code> with {@link #from(Observable)} or {@link Observable#toBlockingObservable()} <p>, +++ b/rxjava-core/src/perf/java/rx/archive/schedulers/TestRecursionMemoryUsage.java, +        }).toBlockingObservable().last();, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Forces an Observable to make synchronous calls and to be well-behaved., +     * <p>, +     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different, +     * threads. This could make an Observable poorly-behaved, in that it might invoke {@code onCompleted} or, +     * {@code onError} before one of its {@code onNext} invocations. You can force such an Observable to be, +     * well-behaved and synchronous by applying the {@code serialize()} method to it., +     * <p>, +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png">, +     *, +     * @return a {@link Observable} that is guaranteed to be well-behaved and synchronous, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize">RxJava Wiki: serialize()</a>, +     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as, +     * there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. , +     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png">, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount">RxJava Wiki: refCount()</a>, +     * @since 0.19, +     * This method is an alias for {@link #toBlockingObservable()}., +     *, +        return toBlockingObservable();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, + * <code>Observable</code> with {@link #from(Observable)} or {@link Observable#toBlockingObservable()} <p>, +++ b/rxjava-core/src/perf/java/rx/archive/schedulers/TestRecursionMemoryUsage.java, +        }).toBlockingObservable().last();, +++ b/rxjava-core/src/test/java/rx/CombineLatestTests.java, +        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);, +        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);, +        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(extendedAction);, +        Observable.<Media, Rating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);, +        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Forces an Observable to make synchronous calls and to be well-behaved., +     * <p>, +     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different]