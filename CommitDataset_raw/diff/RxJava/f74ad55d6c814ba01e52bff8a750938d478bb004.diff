[+++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/http_examples.clj, +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/http_examples.clj, +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.clj, +(defn customObservable, +  "This example shows a custom Observable. Note the, +  .isUnsubscribed check so that it can be stopped early., +  [], +    (rx/action [^rx.Subscriber s], +      (loop [x (range 50)], +        (when (and (not (.isUnsubscribed s)) x), +          ; TODO, +          (println "HERE " (.isUnsubscribed s) (first x)), +          (-> s (.onNext (str "value_" (first x)))), +          (recur (next x)))), +      (-> s .onCompleted)))), +  (.subscribe (customObservable) (rx/action* println))), +(defn simpleComposition, +  "Calls 'customObservable' and defines, +  [], +    (customObservable), +(defn getUser, +  [userId], +    (rx/action [^rx.Subscriber s], +                  (-> s (.onNext {:user-id userId, +                  (-> s .onCompleted), +                  (catch Exception e, +                    (-> s (.onError e))))) ], +        (.add s (Subscriptions/create (rx/action [] (future-cancel f)))))))), +(defn getVideoBookmark, +  [userId, videoId], +    (rx/action [^rx.Subscriber s], +                  (-> s (.onNext {:video-id videoId, +                  (-> s .onCompleted), +                  (catch Exception e, +                    (-> s (.onError e)))))], +        (.add s (Subscriptions/create (rx/action [] (future-cancel f)))))))), +(defn getVideoMetadata, +  [videoId, preferredLanguage], +    (rx/action [^rx.Subscriber s], +                (println "getVideoMetadata " videoId), +                    (-> s (.onNext {:video-id videoId, +                    (-> s (.onNext {:video-id videoId, +                  (-> s .onCompleted), +                  (catch Exception e, +                    (-> s (.onError e))))) ], +        (.add s (Subscriptions/create (rx/action [] (future-cancel f)))))))), +                                      (.map (rx/fn [user], +                                              {:user-name (:name user), +      (.toBlockingObservable), +      .single)), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/http_examples.clj, +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +    (rx/action [observer], +        (.add observer (Subscriptions/create (rx/action [] (future-cancel f)))))))), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.clj, +(defn customObservable, +  "This example shows a custom Observable. Note the, +  .isUnsubscribed check so that it can be stopped early., +  [], +    (rx/action [^rx.Subscriber s], +      (loop [x (range 50)], +        (when (and (not (.isUnsubscribed s)) x), +          ; TODO, +          (println "HERE " (.isUnsubscribed s) (first x)), +          (-> s (.onNext (str "value_" (first x)))), +          (recur (next x)))), +      (-> s .onCompleted)))), +  (.subscribe (customObservable) (rx/action* println))), +(defn simpleComposition, +  "Calls 'customObservable' and defines, +  [], +    (customObservable), +(defn getUser, +  [userId], +    (rx/action [^rx.Subscriber s], +                  (-> s (.onNext {:user-id userId, +                  (-> s .onCompleted), +                  (catch Exception e, +                    (-> s (.onError e))))) ], +        (.add s (Subscriptions/create (rx/action [] (future-cancel f)))))))), +(defn getVideoBookmark, +  [userId, videoId], +    (rx/action [^rx.Subscriber s], +                  (-> s (.onNext {:video-id videoId, +                  (-> s .onCompleted), +                  (catch Exception e, +                    (-> s (.onError e)))))], +        (.add s (Subscriptions/create (rx/action [] (future-cancel f)))))))), +(defn getVideoMetadata, +  [videoId, preferredLanguage], +    (rx/action [^rx.Subscriber s]]