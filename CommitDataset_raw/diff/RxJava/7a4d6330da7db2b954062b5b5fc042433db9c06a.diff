[+++ b/src/main/java/io/reactivex/Completable.java, +    public interface CompletableTransformer extends Function<Completable, CompletableConsumable> {, +     * Wraps the given CompletableConsumable into a Completable, +     * if not already Completable., +     * @param source the source to wrap, +     * @return the source or its wrapper Completable, +     * @throws NullPointerException if source is null, +     */, +    static Completable wrap(CompletableConsumable source) {, +        Objects.requireNonNull(source, "source is null");, +        if (source instanceof Completable) {, +            return (Completable)source;, +        }, +        return new CompletableWrapper(source);, +    }, +    , +    /**, +    public static Completable amb(final CompletableConsumable... sources) {, +            return wrap(sources[0]);, +                for (CompletableConsumable c : sources) {, +    public static Completable amb(final Iterable<? extends CompletableConsumable> sources) {, +                Iterator<? extends CompletableConsumable> it;, +                    CompletableConsumable c;, +    public static Completable concat(CompletableConsumable... sources) {, +            return wrap(sources[0]);, +    public static Completable concat(Iterable<? extends CompletableConsumable> sources) {, +    public static Completable concat(Publisher<? extends CompletableConsumable> sources) {, +    public static Completable concat(Publisher<? extends CompletableConsumable> sources, int prefetch) {, +    public static Completable defer(final Supplier<? extends CompletableConsumable> completableSupplier) {, +                CompletableConsumable c;, +    public static <T> Completable fromFlowable(final Publisher<T> flowable) {, +    public static <T> Completable fromNbpObservable(final ObservableConsumable<T> observable) {, +    public static <T> Completable fromSingle(final SingleConsumable<T> single) {, +    public static Completable merge(CompletableConsumable... sources) {, +            return wrap(sources[0]);, +    public static Completable merge(Iterable<? extends CompletableConsumable> sources) {, +    public static Completable merge(Publisher<? extends CompletableConsumable> sources) {, +    public static Completable merge(Publisher<? extends CompletableConsumable> sources, int maxConcurrency) {, +    protected static Completable merge0(Publisher<? extends CompletableConsumable> sources, int maxConcurrency, boolean delayErrors) {, +     * Returns a CompletableConsumable that subscribes to all Completables in the source array and delays, +    public static Completable mergeDelayError(CompletableConsumable... sources) {, +    public static Completable mergeDelayError(Iterable<? extends CompletableConsumable> sources) {, +    public static Completable mergeDelayError(Publisher<? extends CompletableConsumable> sources) {, +    public static Completable mergeDelayError(Publisher<? extends CompletableConsumable> sources, int maxConcurrency) {, +            Function<? super R, ? extends CompletableConsumable> completableFunction, , +            final Function<? super R, ? extends CompletableConsumable> completableFunction, , +                CompletableConsumable cs;, +    public final Completable ambWith(CompletableConsumable other) {, +        return wrap(to(transformer));, +    public final Completable concatWith(CompletableConsumable other) {, +     * This is an alias for {@link #concatWith(CompletableConsumable)}., +     * @param other the other CompletableConsumable, not null, +    public final Completable endWith(CompletableConsumable other) {, +    public final <T> Observable<T> endWith(ObservableConsumable<T> next) {, +        return this.<T>toNbpObservable().endWith(next);, +    public final <T> Flowable<T> endWith(Publisher<T> next) {, +        return this.<T>toFlowable().endWith(next);, +    public final Completable mergeWith(CompletableConsumable other) {, +    public final Completable onErrorResumeNext(final Function<? super Throwable, ? extends CompletableConsumable> errorMapper) {, +                        CompletableConsumable c;, +                            NullPointerException npe = new NullPointerException("The CompletableConsumable returned is null");, +    public final Completable startWith(CompletableConsumable other) {, +     * of the other NbpObservable then runs this CompletableConsumable., +    public final <T> Flowable<T> startWith(Publisher<T> other) {, +        return this.<T>toFlowable().startWith(other);, +     * Subscribes to this CompletableConsumable and returns a Disposable which can be used to cancel, +    public final Completable timeout(long timeout, TimeUnit unit, CompletableConsumable other) {, +    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableConsumable other) {, +    public final Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, CompletableConsumable other) {, +++ b/src/main/java/io/reactivex/Completable.java, +    public interface CompletableTransformer extends Function<Completable, CompletableConsumable> {, +     * Wraps the given CompletableConsumable into a Completable, +     * if not already Completable., +     * @param source the source to wrap, +     * @return the source or its wrapper Completable, +     * @throws NullPointerException if source is null, +     */, +    static Completable wrap(CompletableConsumable source) {, +        Objects.requireNonNull(source, "source is null");, +        if (source instanceof Completable) {, +            return (Completable)source;, +        }, +        return new CompletableWrapper(source);, +    }, +    , +    /**, +    public static Completable amb(final CompletableConsumable... sources) {, +            return wrap(sources[0]);, +                for (CompletableConsumable c : sources) {, +    public static Completable amb(final Iterable<? extends CompletableConsumable> sources) {, +                Iterator<? extends CompletableConsumable> it;, +                    CompletableConsumable c;, +    public static Completable concat(CompletableConsumable... sources) {, +            return wrap(sources[0]);, +    public static Completable concat(Iterable<? extends CompletableConsumable> sources) {, +    public static Completable concat(Publisher<? extends CompletableConsumable> sources) {, +    public static Completable concat(Publisher<? extends CompletableConsumable> sources, int prefetch) {, +    public static Completable defer(final Supplier<? extends CompletableConsumable> completableSupplier) {, +                CompletableConsumable c;, +    public static <T> Completable fromFlowable(final Publisher<T> flowable) {]