[+++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyString;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import rx.subscriptions.MultipleAssignmentSubscription;, + * Transforms an Observable that emits Observables into a single Observable that, + * emits the items emitted by the most recently published of those Observables., + * <img width="640" src=, + * "https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">, +     * This function transforms an {@link Observable} sequence of, +     * {@link Observable} sequences into a single {@link Observable} sequence, +     * which produces values from the most recently published {@link Observable}, +     * ., +     *            The {@link Observable} sequence consisting of, +     *            {@link Observable} sequences., +        private final Object                         gate;, +        private final MultipleAssignmentSubscription innerSubscription;, +        private long                                 latest;, +        private boolean                              stopped;, +        private boolean                              hasLatest;, +            this.gate = new Object();, +            this.innerSubscription = new MultipleAssignmentSubscription();, +            final long id;, +            synchronized (gate) {, +                id = ++latest;, +                hasLatest = true;, +            }, +            final SafeObservableSubscription sub;, +            sub = new SafeObservableSubscription();, +            sub.wrap(args.subscribe(new Observer<T>() {, +                public void onNext(T args) {, +                    synchronized (gate) {, +                        if (latest == id) {, +                            observer.onNext(args);, +                        }, +                    }, +                    synchronized (gate) {, +                        sub.unsubscribe();, +                        if (latest == id) {, +                            parent.unsubscribe();, +                        }, +                    }, +                public void onCompleted() {, +                    synchronized (gate) {, +                        sub.unsubscribe();, +                        if (latest == id) {, +                            hasLatest = false;, +                        if (stopped) {, +                            observer.onCompleted();, +                            parent.unsubscribe();, +                        }, +, +, +            }));, +, +            innerSubscription.setSubscription(sub);, +        }, +, +        @Override, +        public void onError(Throwable e) {, +            synchronized (gate) {, +                observer.onError(e);, +            }, +, +            parent.unsubscribe();, +        }, +, +        @Override, +        public void onCompleted() {, +            synchronized (gate) {, +                innerSubscription.unsubscribe();, +                stopped = true;, +                if (!hasLatest) {, +                    observer.onCompleted();, +                    parent.unsubscribe();, +                }, +            }, +        }, +, +        public void testSwitchWhenOuterCompleteBeforeInner() {, +            Observable<Observable<String>> source = Observable.create(new OnSubscribeFunc<Observable<String>>() {, +                @Override, +                public Subscription onSubscribe(Observer<? super Observable<String>> observer) {, +                    publishNext(observer, 50, Observable.create(new OnSubscribeFunc<String>() {, +                        @Override, +                        public Subscription onSubscribe(Observer<? super String> observer) {, +                            publishNext(observer, 70, "one");, +                            publishNext(observer, 100, "two");, +                            publishCompleted(observer, 200);, +                            return Subscriptions.empty();, +                        }, +                    }));, +                    publishCompleted(observer, 60);, +, +                    return Subscriptions.empty();, +                }]