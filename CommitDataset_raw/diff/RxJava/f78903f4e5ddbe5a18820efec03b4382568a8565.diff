[+++ b/src/main/java/rx/internal/util/unsafe/ConcurrentCircularArrayQueue.java, +        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);, +        mask = actualCapacity - 1;, +        buffer = (E[]) new Object[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        return calcElementOffset(index, mask);, +    }, +    /**, +     * @param index desirable element index, +     * @param mask , +     * @return the offset in bytes within the array for a given index., +     */, +    protected final long calcElementOffset(long index, long mask) {, +    @Override, +    public void clear() {, +        // we have to test isEmpty because of the weaker poll() guarantee, +        while (poll() != null || !isEmpty()), +            ;, +    }, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentCircularArrayQueue.java, +        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);, +        mask = actualCapacity - 1;, +        buffer = (E[]) new Object[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        return calcElementOffset(index, mask);, +    }, +    /**, +     * @param index desirable element index, +     * @param mask , +     * @return the offset in bytes within the array for a given index., +     */, +    protected final long calcElementOffset(long index, long mask) {, +    @Override, +    public void clear() {, +        // we have to test isEmpty because of the weaker poll() guarantee, +        while (poll() != null || !isEmpty()), +            ;, +    }, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue.java, +        int actualCapacity = (int) (this.mask + 1);, +        sequenceBuffer = new long[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        for (long i = 0; i < actualCapacity; i++) {, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentCircularArrayQueue.java, +        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);, +        mask = actualCapacity - 1;, +        buffer = (E[]) new Object[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        return calcElementOffset(index, mask);, +    }, +    /**, +     * @param index desirable element index, +     * @param mask , +     * @return the offset in bytes within the array for a given index., +     */, +    protected final long calcElementOffset(long index, long mask) {, +    @Override, +    public void clear() {, +        // we have to test isEmpty because of the weaker poll() guarantee, +        while (poll() != null || !isEmpty()), +            ;, +    }, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue.java, +        int actualCapacity = (int) (this.mask + 1);, +        sequenceBuffer = new long[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        for (long i = 0; i < actualCapacity; i++) {, +++ b/src/main/java/rx/internal/util/unsafe/MessagePassingQueue.java, +     * {@link Queue#offer(Object)} interface., +     * @return true if element was inserted into the queue, false iff full, +     * the {@link Queue#poll()} interface., +     * @return a message from the queue if one is available, null iff empty, +     * the {@link Queue#peek()} interface., +     * @return a message from the queue if one is available, null iff empty, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentCircularArrayQueue.java, +        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);, +        mask = actualCapacity - 1;, +        buffer = (E[]) new Object[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        return calcElementOffset(index, mask);, +    }, +    /**, +     * @param index desirable element index, +     * @param mask , +     * @return the offset in bytes within the array for a given index., +     */, +    protected final long calcElementOffset(long index, long mask) {, +    @Override, +    public void clear() {, +        // we have to test isEmpty because of the weaker poll() guarantee, +        while (poll() != null || !isEmpty()), +            ;, +    }, +++ b/src/main/java/rx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue.java, +        int actualCapacity = (int) (this.mask + 1);, +        sequenceBuffer = new long[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];, +        for (long i = 0; i < actualCapacity; i++) {, +++ b/src/main/java/rx/internal/util/unsafe/MessagePassingQueue.java, +     * {@link Queue#offer(Object)} interface., +     * @return true if element was inserted into the queue, false iff full, +     * the {@link Queue#poll()} interface., +     * @return a message from the queue if one is available, null iff empty, +     * the {@link Queue#peek()} interface., +     * @return a message from the queue if one is available, null iff empty, +++ b/src/main/java/rx/internal/util/unsafe/MpmcArrayQueue.java, +            P_INDEX_OFFSET = UNSAFE.objectFieldOffset(MpmcArrayQueueProducerField.class]