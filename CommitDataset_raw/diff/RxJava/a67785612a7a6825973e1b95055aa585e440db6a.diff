[+++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +                        once = false;, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +                        once = false;, +++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +            _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +                        once = false;, +++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +            _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +++ b/src/test/java/rx/exceptions/ExceptionsTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +, +    @Test, +    public void testStackOverflowWouldOccur() {, +        final int MAX_STACK_DEPTH = 1000;, +        final AtomicInteger depth = new AtomicInteger();, +            public void onNext(Integer n) {, +                b.onNext(n + 1);, +            public void onNext(Integer n) {, +                if (depth.get() < MAX_STACK_DEPTH) { , +                    depth.set(Thread.currentThread().getStackTrace().length);, +                    a.onNext(n + 1);, +                }, +        assertTrue(depth.get() > MAX_STACK_DEPTH);, +    }, +    , +    @Test(expected = StackOverflowError.class), +    public void testStackOverflowErrorIsThrown() {, +        Observable.just(1).subscribe(new Observer<Integer>() {, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                e.printStackTrace();, +            }, +, +            @Override, +            public void onNext(Integer t) {, +                throw new StackOverflowError();, +            }, +, +        });, +++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java, +                        once = false;, +++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java, +            _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);, +++ b/src/test/java/rx/exceptions/ExceptionsTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +, +    @Test, +    public void testStackOverflowWouldOccur() {, +        final int MAX_STACK_DEPTH = 1000;, +        final AtomicInteger depth = new AtomicInteger();, +            public void onNext(Integer n) {, +                b.onNext(n + 1);, +            public void onNext(Integer n) {, +                if (depth.get() < MAX_STACK_DEPTH) { , +                    depth.set(Thread.currentThread().getStackTrace().length);, +                    a.onNext(n + 1);, +                }, +        assertTrue(depth.get() > MAX_STACK_DEPTH);, +    }, +    , +    @Test(expected = StackOverflowError.class), +    public void testStackOverflowErrorIsThrown() {, +        Observable.just(1).subscribe(new Observer<Integer>() {, +, +            @Override, +            public void onCompleted() {, +, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                e.printStackTrace();, +            }, +, +            @Override, +            public void onNext(Integer t) {, +                throw new StackOverflowError();, +            }, +, +        });, +++ b/src/test/java/rx/internal/operators/OperatorTakeLastTest.java, +import java.util.ArrayList;, +import java.util.List;, +    , +    @Test(timeout=10000), +    public void testRequestOverflow() {, +        final List<Integer> list = new ArrayList<Integer>();, +        Observable.range(1, 100).takeLast(50).subscribe(new Subscriber<Integer>() {, +, +            @Override, +            public void onStart() {, +                request(2);]