[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Returns an Observable that will execute the specified function when an {@link Observer} subscribes to it., +     * invoke the Observer's {@link Observer#onNext onNext}, {@link Observer#onError onError}, and {@link Observer#onCompleted onCompleted} methods appropriately., +     *            a function that accepts an {@code Observer<T>}, invokes its {@code onNext}, {@code onError}, and {@code onCompleted} methods as appropriate, and returns a {@link Subscription} that, +     *            allows the Observer to cancel the subscription, +     * Returns an Observable that will execute the specified function when an {@link Observer} subscribes to it., +     * invoke the Observer's {@link Observer#onNext onNext}, {@link Observer#onError onError}, and {@link Observer#onCompleted onCompleted} methods appropriately., +     *            a function that accepts an {@code Observer<T>}, invokes its {@code onNext}, {@code onError}, and {@code onCompleted} methods as appropriate, and returns a {@link Subscription} that, +     *            allows the Observer to cancel the subscription, +     * @return an Observable that emits items all of the items emitted by the Observables emitted by {@code observables}, one after the other, without interleaving them, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method on the specified scheduler., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method with the, +     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it., +     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method when the Observer subscribes to it, +     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method on the specified scheduler., +     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method, on the specified scheduler, +     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as {@link Schedulers#threadPoolForIO()} that can block and wait on the future., +     * Note: the entire iterable sequence is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not possible, +     * <em>Note:</em> the entire array is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not possible, +     * <em>Note:</em> the entire array is immediately emitted each time an {@link Observer} subscribes. Since this occurs before the {@link Subscription} is returned, it is not, +     * To convert any object into an Observable that emits that object, pass that object into the {@code just} method., +     * This is similar to the {@link #from(java.lang.Object[])} method, except that {@code from()} will convert an {@link Iterable} object into an Observable that emits each of the items in, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * @return an Observable that emits all of the items emitted by the Observables emitted by the {@code source} Observable, +     * Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged Observables, +     * Even if both merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * if any of the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via {@link Observer#onError onError}, +     * , {@code mergeDelayError} will refrain from propagating that, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error, +     * via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify, +     * of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that, +     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its Observers once., +     * @return an Observable that never emits any items or sends any notifications to an {@link Observer}, +     * Converts an {@code Observable<Observable<T>>} into another {@code Observable<Observable<T>>} whose emitted Observables emit the same items, but the number of such Observables is, +     * For example, if the original {@code Observable<Observable<T>>} emits 100 Observables and {@code parallelObservables} is 8, the items emitted by the 100 original Observables will be, +     * Converts an {@code Observable<Observable<T>>} into another {@code Observable<Observable<T>>} whose emitted Observables emit the same items, but the number of such Observables is, +     * For example, if the original {@code Observable<Observable<T>>} emits 100 Observables and {@code parallelObservables} is 8, the items emitted by the 100 original Observables will be, +     *         numbers after each {@code period} of time thereafter, while running on the given {@code scheduler}, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * Observable will be the result of the function applied to the first item emitted by {@code o1} and the first item emitted by {@code o2}; the second item emitted by the new Observable will, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * Observable will be the result of the function applied to the first item emitted by {@code o1}, the first item emitted by {@code o2}, and the first item emitted by {@code o3};, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * Observable will be the result of the function applied to the first item emitted by {@code o1}, the first item emitted by {@code o2}, the first item emitted by {@code o3}, and, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * Observable will be the result of the function applied to the first item emitted by {@code o1}, the first item emitted by {@code o2}, the first item emitted by {@code o3}, the, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of, +     * buffer and replaces it with a new buffer when the Observable produced by the specified {@code bufferClosingSelector} emits an item. It then uses the {@code bufferClosingSelector} to create a, +     * new Observable to observe to indicate the end of the next buffer., +     *         the source Observable each time the current Observable created with the {@code bufferClosingSelector} argument emits an item, +     * The resulting Observable emits connected, non-overlapping buffers, each containing {@code count} items. When the source Observable completes or encounters an error, the, +     * The resulting Observable emits buffers every {@code skip} items, each containing {@code count} items. When the source Observable completes or encounters an error, the, +     * The resulting Observable starts a new buffer periodically, as determined by the {@code timeshift} argument. It emits each buffer after a fixed timespan, specified by the {@code timespan}, +     * argument. When the source Observable completes or encounters an error, the, +     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments, +     * The resulting Observable starts a new buffer periodically, as determined by the {@code timeshift} argument, and on the specified {@code scheduler}. It emits each buffer, +     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments, +     * specified by the {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached first). When the source Observable completes or encounters an, +     * The resulting Observable emits buffers that it creates when the specified {@code bufferOpenings} Observable emits an item, and closes when the Observable returned from, +     * happens when {@code subscribe} is called the first time on the Observable returned by {@code cache()}., +     * <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the {@code cache()} operator so be careful not to use this operator on Observables that emit an, +     * @param state, +     *            FIXME FIXME FIXME, +     * @param collector, +     *            FIXME FIXME FIXME, +     * <em>Note:</code> the resulting Observable will immediately propagate any {@code onError} notification from the source Observable., +     * <em>Note:</code> the resulting Observable will immediately propagate any {@code onError} notification from the source Observable., +     * @return an Observable that emits the items and notifications embedded in the {@link Notification} objects emitted by the source Observable, +     * satisfies a specified condition, otherwise {@code false}. <em>Note:</em> this always emits {@code false} if the source Observable is empty., +     *            a function that evaluates the items emitted by the source Observable, returning {@code true} if they pass the filter, +     * Registers an {@link Action0} to be called when this Observable invokes either {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}., +     * @return an Observable that emits the same items as the source Observable, then invokes the {@link Action0}, +     *         that satisfies the {@code predicate}, or raises an {@code IllegalArgumentException} if no such items are emitted, +     * grouped items, transformed by a selector, within {@link GroupedObservable}s, one {@code GroupedObservable} per group.]