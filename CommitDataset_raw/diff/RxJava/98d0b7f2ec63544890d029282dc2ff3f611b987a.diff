[+++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, +    public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, +        @Override, +        public void accept(Subscription t) throws Exception {, +            t.request(Long.MAX_VALUE);, +        }, +    };, +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, +    public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, +        @Override, +        public void accept(Subscription t) throws Exception {, +            t.request(Long.MAX_VALUE);, +        }, +    };, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, +                if (o == BlockingSubscriber.TERMINATED, +                        || NotificationLite.acceptFull(v, subscriber)) {, +            subscriber.onError(e);, +        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();, +        callback, callback, Functions.REQUEST_MAX);, +        BlockingHelper.awaitForComplete(callback, ls);, +        Throwable e = callback.error;, +        subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));, +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, +    public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, +        @Override, +        public void accept(Subscription t) throws Exception {, +            t.request(Long.MAX_VALUE);, +        }, +    };, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, +                if (o == BlockingSubscriber.TERMINATED, +                        || NotificationLite.acceptFull(v, subscriber)) {, +            subscriber.onError(e);, +        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();, +        callback, callback, Functions.REQUEST_MAX);, +        BlockingHelper.awaitForComplete(callback, ls);, +        Throwable e = callback.error;, +        subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, +                boolean d = active.decrementAndGet() == 0;, +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, +    public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, +        @Override, +        public void accept(Subscription t) throws Exception {, +            t.request(Long.MAX_VALUE);, +        }, +    };, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, +                if (o == BlockingSubscriber.TERMINATED, +                        || NotificationLite.acceptFull(v, subscriber)) {, +            subscriber.onError(e);, +        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();, +        callback, callback, Functions.REQUEST_MAX);, +        BlockingHelper.awaitForComplete(callback, ls);, +        Throwable e = callback.error;, +        subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, +                boolean d = active.decrementAndGet() == 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java, +                boolean d = active.decrementAndGet() == 0;, +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, +    public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, +        @Override, +        public void accept(Subscription t) throws Exception {, +            t.request(Long.MAX_VALUE);, +        }, +    };, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, +                if (o == BlockingSubscriber.TERMINATED, +                        || NotificationLite.acceptFull(v, subscriber)) {, +            subscriber.onError(e);, +        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();, +        callback, callback, Functions.REQUEST_MAX);, +        BlockingHelper.awaitForComplete(callback, ls);, +        Throwable e = callback.error;, +        subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, +                boolean d = active.decrementAndGet() == 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java, +                boolean d = active.decrementAndGet() == 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java, +import java.util.concurrent.atomic.AtomicLong;, +import io.reactivex.Notification;, +import io.reactivex.plugins.RxJavaPlugins;]