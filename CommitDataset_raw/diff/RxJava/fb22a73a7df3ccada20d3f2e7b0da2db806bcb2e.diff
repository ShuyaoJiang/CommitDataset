[+++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/build.gradle, +    compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.LinkedHashMap;, +            a.error(this, e);, +        public void onNext(Object args) {, +     * Receive notifications from each of the Observables we are reducing and execute the combineLatestFunction whenever we have received events from all Observables., +     * , +     * @param <R>, +        private Observer<R> Observer;, +        private AtomicBoolean running = new AtomicBoolean(true);, +         * Use LinkedHashMap to retain the order we receive the CombineLatestObserver objects in., +         * Note that access to this LinkedList inside MUST BE SYNCHRONIZED, +        private Map<CombineObserver<R, ?>, LinkedList<Object>> receivedValuesPerObserver = new LinkedHashMap<CombineObserver<R, ?>, LinkedList<Object>>();, +, +        /**, +         * store when a Observer completes, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED, +         * */, +        private HashSet<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();, +, +        /**, +         * The last value from a Observer, +         * <p>, +         * Note that access to this set MUST BE SYNCHRONIZED, +         * */, +        private HashMap<CombineObserver<R, ?>, Object> lastValue = new HashMap<CombineObserver<R, ?>, Object>();, +         * @param w, +        synchronized void addObserver(CombineObserver<R, ?> w) {, +            // initialize this CombineLatestObserver, +            receivedValuesPerObserver.put(w, new LinkedList<Object>());, +         * @param w, +        synchronized void complete(CombineObserver<R, ?> w) {, +            // store that this ZipObserver is completed, +            if (completed.size() == receivedValuesPerObserver.size()) {, +                    Observer.onCompleted();, +         * , +         * @param w, +        synchronized void error(CombineObserver<R, ?> w, Exception e) {, +            Observer.onError(e);, +            /* tell ourselves to stop processing onNext events, event if the Observers don't obey the unsubscribe we're about to send */, +            running.set(false);, +            /* tell all Observers to unsubscribe since we had an error */, +         * Receive the next value from a Observer., +         * If we have received values from all Observers, trigger the combineLatest function, otherwise store the value and keep waiting., +        void next(CombineObserver<R, ?> w, Object arg) {, +            if (Observer == null) {, +                throw new RuntimeException("This shouldn't be running if a Observer isn't registered");, +            Object[] argsToCombineLatest = new Object[receivedValuesPerObserver.size()];, +            // we synchronize everything that touches receivedValues and the internal LinkedList objects, +            synchronized (this) {, +                // add this value to the queue of the CombineLatestObserver for values received, +                receivedValuesPerObserver.get(w).add(arg);, +                // remember this as the last value for this Observer, +                lastValue.put(w, arg);, +                // if all CombineLatestObservers in 'receivedValues' map have a value, invoke the combineLatestFunction, +                for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {, +                    if (receivedValuesPerObserver.get(rw).peek() == null && !completed.contains(rw)) {, +                        // we have a null (and the Observer isn't completed) meaning the queues aren't all populated so won't do anything, +                // if we get to here this means all the queues have data (or some are completed), +                boolean foundData = false;, +                for (CombineObserver<R, ?> _w : receivedValuesPerObserver.keySet()) {, +                    LinkedList<Object> q = receivedValuesPerObserver.get(_w);, +                    if (q.peek() == null) {, +                        // this is a completed Observer, +                        // we rely on the check above looking at completed.contains to mean that NULL here represents a completed Observer, +                        argsToCombineLatest[i++] = lastValue.get(_w);, +                    } else {, +                        foundData = true;, +                        argsToCombineLatest[i++] = q.remove();, +                    }, +                }, +                if (completed.size() == receivedValuesPerObserver.size() && !foundData) {, +                    // all are completed and queues have run out of data, so return and don't send empty data, +                    return;, +            Observer.onNext(combineLatestFunction.call(argsToCombineLatest));, +        public Subscription call(Observer<R> Observer) {, +            if (this.Observer != null) {, +            this.Observer = Observer;, +            /* start the Observers */, +            for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {, +, +, +            /* propogate to all Observers to unsubscribe */, +            for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {, +, +            w2.Observer.onNext("2a");, +            w3.Observer.onNext("3a");, +, +            inOrder.verify(w, times(1)).onNext("1a2a3a");, +            CombineObserver<String, Integer> r2 = mock(CombineObserver.class);, +            verify(aObserver, times(1)).onNext("oneA");, +            verify(aObserver, times(1)).onNext("twoB");, +            verify(aObserver, times(1)).onNext("threeC");, +            a.error(r1, new RuntimeException(""));, +            verify(aObserver, never()).onError(any(Exception.class));, +            verify(aObserver, never()).onCompleted();]