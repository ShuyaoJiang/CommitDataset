[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/RxImplicitsTests.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.lang.scala, +, +import org.scalatest.junit.JUnitSuite, +, +class UnitTestSuite extends JUnitSuite {, +    import rx.lang.scala.RxImplicits._, +, +    import org.junit.{ Before, Test }, +    import org.junit.Assert._, +    import org.mockito.Matchers.any, +    import org.mockito.Mockito._, +    import org.mockito.{ MockitoAnnotations, Mock }, +    import rx.{ Notification, Observer, Observable, Subscription }, +    import rx.Observable.OnSubscribeFunc, +    import rx.observables.GroupedObservable, +    import rx.subscriptions.Subscriptions, +    import collection.mutable.ArrayBuffer, +    import collection.JavaConverters._, +            , +    @Mock private[this], +    val observer: Observer[Any] = null, +    , +    @Mock private[this], +    val subscription: Subscription = null, +    , +    val isOdd = (i: Int) => i % 2 == 1, +    val isEven = (i: Int) => i % 2 == 0, +    , +    class OnSubscribeWithException(s: Subscription, values: String*) extends OnSubscribeFunc[String] {, +        var t: Thread = null, +        , +        override def onSubscribe(observer: Observer[_ >: String]): Subscription = {, +            println("ObservableWithException subscribed to ..."), +                    try {, +                        println("running ObservableWithException thread"), +                        values.toList.foreach(v => {, +                            println("ObservableWithException onNext: " + v), +                            observer.onNext(v), +                        }), +                        throw new RuntimeException("Forced Failure"), +                    } catch {, +                        case ex: Exception => observer.onError(ex), +                    }, +            s, +        }, +    }, +    , +    @Before def before {, +        MockitoAnnotations.initMocks(this), +    }, +    , +    // tests of static methods, +    @Test def testSingle {, +        assertEquals(1, Observable.from(1).toBlockingObservable.single), +    }, +    , +    @Test def testSinglePredicate {, +        val found = Observable.from(1, 2, 3).toBlockingObservable.single(isEven), +        assertEquals(2, found), +    }, +    , +    @Test def testSingleOrDefault {, +        assertEquals(0, Observable.from[Int]().toBlockingObservable.singleOrDefault(0)), +        assertEquals(1, Observable.from(1).toBlockingObservable.singleOrDefault(0)), +        try {, +            Observable.from(1, 2, 3).toBlockingObservable.singleOrDefault(0), +            fail("Did not catch any exception, expected IllegalStateException"), +        } catch {, +            case ex: IllegalStateException => println("Caught expected IllegalStateException"), +            case ex: Throwable => fail("Caught unexpected exception " + ex.getCause + ", expected IllegalStateException"), +        }, +    }, +    , +    @Test def testSingleOrDefaultPredicate {, +        assertEquals(2, Observable.from(1, 2, 3).toBlockingObservable.singleOrDefault(0, isEven)), +        assertEquals(0, Observable.from(1, 3).toBlockingObservable.singleOrDefault(0, isEven)), +        try {, +            Observable.from(1, 2, 3).toBlockingObservable.singleOrDefault(0, isOdd), +            fail("Did not catch any exception, expected IllegalStateException"), +        } catch {, +            case ex: IllegalStateException => println("Caught expected IllegalStateException"), +            case ex: Throwable => fail("Caught unexpected exception " + ex.getCause + ", expected IllegalStateException")]