[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  /**, +   * Zips this Observable with its indices., +   * , +   * @return An Observable emitting pairs consisting of all elements of this Observable paired with , +   *         their index. Indices start at 0., +   */, +  def zipWithIndex: Observable[(T, Int)] = {, +    val fScala: (T, Integer) => (T, Int) = (elem: T, index: Integer) => (elem, index), +    val fJava : Func2[_ >: T, Integer, _ <: (T, Int)] = fScala, +    Observable[(T, Int)](asJava.mapWithIndex[(T, Int)](fJava)), +  }, +   * Returns an Observable that sums up the elements of this Observable., +   * , +   * @return an Observable emitting the sum of all the elements of the source Observable, +   *         as its single item., +   */, +  def sum[U >: T](implicit num: Numeric[U]): Observable[U] = {, +    fold(num.zero)(num.plus), +  }, +  , +  /**, +   * Returns an Observable that multiplies up the elements of this Observable., +   * , +   * @return an Observable emitting the product of all the elements of the source Observable, +   *         as its single item., +   */, +  def product[U >: T](implicit num: Numeric[U]): Observable[U] = {, +    fold(num.one)(num.times), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  /**, +   * Zips this Observable with its indices., +   * , +   * @return An Observable emitting pairs consisting of all elements of this Observable paired with , +   *         their index. Indices start at 0., +   */, +  def zipWithIndex: Observable[(T, Int)] = {, +    val fScala: (T, Integer) => (T, Int) = (elem: T, index: Integer) => (elem, index), +    val fJava : Func2[_ >: T, Integer, _ <: (T, Int)] = fScala, +    Observable[(T, Int)](asJava.mapWithIndex[(T, Int)](fJava)), +  }, +   * Returns an Observable that sums up the elements of this Observable., +   * , +   * @return an Observable emitting the sum of all the elements of the source Observable, +   *         as its single item., +   */, +  def sum[U >: T](implicit num: Numeric[U]): Observable[U] = {, +    fold(num.zero)(num.plus), +  }, +  , +  /**, +   * Returns an Observable that multiplies up the elements of this Observable., +   * , +   * @return an Observable emitting the product of all the elements of the source Observable, +   *         as its single item., +   */, +  def product[U >: T](implicit num: Numeric[U]): Observable[U] = {, +    fold(num.one)(num.times), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  , +  // We can't put a general average method into Observable.scala, because Scala's Numeric, +  // does not have scalar multiplication (we would need to calculate (1.0/numberOfElements)*sum), +  def doubleAverage(o: Observable[Double]): Observable[Double] = {, +    for ((finalSum, finalCount) <- o.fold((0.0, 0))({case ((sum, count), elem) => (sum+elem, count+1)})), +      yield finalSum / finalCount, +  }, +  , +  @Test def averageExample() {, +    println(doubleAverage(Observable()).toBlockingObservable.single), +    println(doubleAverage(Observable(0)).toBlockingObservable.single), +    println(doubleAverage(Observable(4.44)).toBlockingObservable.single), +    println(doubleAverage(Observable(1, 2, 3.5)).toBlockingObservable.single), +  }, +  , +  @Test def testSum() {, +    assertEquals(10, Observable(1, 2, 3, 4).sum.toBlockingObservable.single), +    assertEquals(6, Observable(4, 2).sum.toBlockingObservable.single), +    assertEquals(0, Observable[Int]().sum.toBlockingObservable.single), +  }, +  , +  @Test def testProduct() {, +    assertEquals(24, Observable(1, 2, 3, 4).product.toBlockingObservable.single), +    assertEquals(8, Observable(4, 2).product.toBlockingObservable.single), +    assertEquals(1, Observable[Int]().product.toBlockingObservable.single), +  }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  /**, +   * Zips this Observable with its indices., +   * , +   * @return An Observable emitting pairs consisting of all elements of this Observable paired with , +   *         their index. Indices start at 0., +   */, +  def zipWithIndex: Observable[(T, Int)] = {, +    val fScala: (T, Integer) => (T, Int) = (elem: T, index: Integer) => (elem, index)]