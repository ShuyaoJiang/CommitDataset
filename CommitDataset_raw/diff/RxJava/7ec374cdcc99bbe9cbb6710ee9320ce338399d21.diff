[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */, +  override val asJavaSubscription: rx.subscriptions.SerialSubscription = new rx.subscriptions.SerialSubscription() {, +    override def unsubscribe(): Unit = {, +      if(unsubscribed.compareAndSet(false, true)) { serial.unsubscribe() }, +    override def setSubscription(subscription: rx.Subscription): Unit = serial.setSubscription(subscription), +    override def getSubscription(): rx.Subscription = serial.getSubscription(), +  }, +, +  def subscription_=(value: Subscription): this.type = { asJavaSubscription.setSubscription(value.asJavaSubscription); this }, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */, +  override val asJavaSubscription: rx.subscriptions.SerialSubscription = new rx.subscriptions.SerialSubscription() {, +    override def unsubscribe(): Unit = {, +      if(unsubscribed.compareAndSet(false, true)) { serial.unsubscribe() }, +    override def setSubscription(subscription: rx.Subscription): Unit = serial.setSubscription(subscription), +    override def getSubscription(): rx.Subscription = serial.getSubscription(), +  }, +, +  def subscription_=(value: Subscription): this.type = { asJavaSubscription.setSubscription(value.asJavaSubscription); this }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +        return from(iterable).observeOn(scheduler);, +     * @param items the source sequence, +        return create(OperationToObservableIterable.toObservableIterable(Arrays.asList(items)));, +     * Note: the items will be immediately emitted each time an {@link Observer}, +     * subscribes. Since this occurs before the {@link Subscription} is, +     * returned, it is not possible to unsubscribe from the sequence before it, +     * completes., +     * , +     * Note: the entire range is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     * , +        return range(start, count).observeOn(scheduler);, +        List<T> list = new ArrayList<T>();, +        list.add(value);, +, +        return from(list);, +        return just(value).observeOn(scheduler);, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */, +  override val asJavaSubscription: rx.subscriptions.SerialSubscription = new rx.subscriptions.SerialSubscription() {, +    override def unsubscribe(): Unit = {, +      if(unsubscribed.compareAndSet(false, true)) { serial.unsubscribe() }, +    override def setSubscription(subscription: rx.Subscription): Unit = serial.setSubscription(subscription), +    override def getSubscription(): rx.Subscription = serial.getSubscription(), +  }, +, +  def subscription_=(value: Subscription): this.type = { asJavaSubscription.setSubscription(value.asJavaSubscription); this }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +        return from(iterable).observeOn(scheduler);, +     * @param items the source sequence, +        return create(OperationToObservableIterable.toObservableIterable(Arrays.asList(items)));, +     * Note: the items will be immediately emitted each time an {@link Observer}, +     * subscribes. Since this occurs before the {@link Subscription} is, +     * returned, it is not possible to unsubscribe from the sequence before it, +     * completes., +     * , +     * Note: the entire range is immediately emitted each time an, +     * {@link Observer} subscribes. Since this occurs before the, +     * {@link Subscription} is returned, it is not possible to unsubscribe from, +     * the sequence before it completes., +     * , +        return range(start, count).observeOn(scheduler);, +        List<T> list = new ArrayList<T>();, +        list.add(value);, +, +        return from(list);, +        return just(value).observeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java, +        return new ToObservableIterable<T>(list);, +        public ToObservableIterable(Iterable<? extends T> list) {, +        public Iterable<? extends T> iterable;, +        public Subscription onSubscribe(Observer<? super T> observer) {, +            for (T item : iterable) {, +                observer.onNext(item);, +            }, +, +            return Subscriptions.empty();, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptions/SerialSubscription.scala, +class SerialSubscription private[scala] (serial: rx.subscriptions.SerialSubscription) extends Subscription {, +  /*, +  * As long as rx.subscriptions.SerialSubscription has no isUnsubscribed,, +  * we need to intercept and do it ourselves., +   */]