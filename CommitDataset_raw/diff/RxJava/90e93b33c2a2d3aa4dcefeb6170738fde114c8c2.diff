[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId}"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId}"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +    val inOrdr = inOrder(observer), +    sub.unsubscribe(), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId}"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +    val inOrdr = inOrder(observer), +    sub.unsubscribe(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//  implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +//    new Func2[rx.Scheduler, T, rx.Subscription] {, +//      def call(s: rx.Scheduler, t: T): rx.Subscription = {, +//        action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +//      }, +//    }, +, +        action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), +    o.observeOn(NewThreadScheduler()).subscribe(, +      i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), +    println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), +    println(s"map() is being called on thread ${Thread.currentThread().getId}"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +    val inOrdr = inOrder(observer), +    sub.unsubscribe(), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//  implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +//    new Func2[rx.Scheduler, T, rx.Subscription] {, +//      def call(s: rx.Scheduler, t: T): rx.Subscription = {, +//        action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +//      }, +//    }, +, +        action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +    zip(that, (t: T, u: U) => (t, u)), +  }, +, +  /**, +   * Returns an Observable formed from this Observable and another Observable by combining, +   * corresponding elements using the selector function., +   * The number of `onNext` invocations of the resulting `Observable[(T, U)]`, +   * is the minumum of the number of `onNext` invocations of `this` and `that`., +   *, +   * Note that this function is private because Scala collections don't have such a function., +   */, +  private def zip[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {, +    Observable[R](rx.Observable.zip[T, U, R](this.asJavaObservable, that.asJavaObservable, selector)), +  private [scala] def apply[T](observable: rx.Observable[_ <: T]): Observable[T] = {, +   *            the type of the items that this Observable emits., +   *            canceling the subscription., +   * @return, +   *         an Observable that, when an [[rx.lang.scala.Observer]] subscribes to it, will execute the given function., +  def create[T](func: Observer[T] => Subscription): Observable[T] = {, +    Observable[T](rx.Observable.create(new OnSubscribeFunc[T] {, +      def onSubscribe(t1: rx.Observer[_ >: T]): rx.Subscription = {, +        func(Observer(t1)), +      }, +    })), +  }, +]