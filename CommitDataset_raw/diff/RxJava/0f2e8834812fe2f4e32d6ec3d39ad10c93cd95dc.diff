[+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    }, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    }, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    }, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/main/java/rx/subscriptions/Subscriptions.java, +     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing except to change, +     * {@code isUnsubscribed} to {@code true}. It's stateful and {@code isUnsubscribed} indicates if, +     * {@code unsubscribe} is called, which is different from {@link #unsubscribed()}., +     * @return a {@link Subscription} to which {@code unsubscribe} does nothing except to change, +     *         {@code isUnsubscribed} to {@code true}, +     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed., +     * Its {@code isUnsubscribed} always returns {@code true}, which is different from {@link #empty()}., +     * @return a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed, +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    }, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/main/java/rx/subscriptions/Subscriptions.java, +     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing except to change, +     * {@code isUnsubscribed} to {@code true}. It's stateful and {@code isUnsubscribed} indicates if, +     * {@code unsubscribe} is called, which is different from {@link #unsubscribed()}., +     * @return a {@link Subscription} to which {@code unsubscribe} does nothing except to change, +     *         {@code isUnsubscribed} to {@code true}, +     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed., +     * Its {@code isUnsubscribed} always returns {@code true}, which is different from {@link #empty()}., +     * @return a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed, +     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number), +++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +        volatile int terminated;, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +                if (groups.size() == 0) {, +            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +                if (removed.buffer.size() > 0) {, +            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer, +            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {, +, +                    if (child.isUnsubscribed()) {, +                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up., +                        unsubscribe();, +                    }, +++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java, +        child.add(sampler);, +++ b/src/main/java/rx/subscriptions/Subscriptions.java]