[+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java, +        final Subscription s = that.single().subscribe(new Subscriber<T>() {, +                // "single" guarantees there is only one "onNext", +                value.set(v);, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java, +        final Subscription s = that.single().subscribe(new Subscriber<T>() {, +                // "single" guarantees there is only one "onNext", +                value.set(v);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    unsubscribe();, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java, +        final Subscription s = that.single().subscribe(new Subscriber<T>() {, +                // "single" guarantees there is only one "onNext", +                value.set(v);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    unsubscribe();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +     * If {@link BlockingObservable} emits more than one item, {@link java.util.concurrent.Future} will receive an, +     * {@link java.lang.IllegalArgumentException}. If {@link BlockingObservable} is empty, {@link java.util.concurrent.Future}, +     * will receive an {@link java.util.NoSuchElementException}., +     * <p>, +     * If the {@code BlockingObservable} may emit more than one item, use {@code Observable.toList().toBlocking().toFuture()}., +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java, +        final Subscription s = that.single().subscribe(new Subscriber<T>() {, +                // "single" guarantees there is only one "onNext", +                value.set(v);, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java, +                    unsubscribe();, +++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java, +     * If {@link BlockingObservable} emits more than one item, {@link java.util.concurrent.Future} will receive an, +     * {@link java.lang.IllegalArgumentException}. If {@link BlockingObservable} is empty, {@link java.util.concurrent.Future}, +     * will receive an {@link java.util.NoSuchElementException}., +     * <p>, +     * If the {@code BlockingObservable} may emit more than one item, use {@code Observable.toList().toBlocking().toFuture()}., +++ b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToFutureTest.java, +import java.util.NoSuchElementException;, +    @Test(expected = IllegalArgumentException.class), +    public void testExceptionWithMoreThanOneElement() throws Throwable {, +        try {, +            f.get();, +        }, +        catch(ExecutionException e) {, +            throw e.getCause();, +        }, +, +    @Test(expected = NoSuchElementException.class), +    public void testGetWithEmptyObservable() throws Throwable {, +        Observable<String> obs = Observable.empty();, +        Future<String> f = obs.toBlocking().toFuture();, +        try {, +            f.get();, +        }, +        catch(ExecutionException e) {, +            throw e.getCause();, +        }, +    }, +, +    @Test, +    public void testGetWithASingleNullItem() throws Exception {, +        Observable<String> obs = Observable.from((String)null);, +        Future<String> f = obs.toBlocking().toFuture();, +        assertEquals(null, f.get());, +    }]