[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java, +        Object[] latest;, +        final SpscLinkedArrayQueue<Object[]> queue;, +            this.latest = new Object[count];, +            CombinerObserver<T, R>[] as = new CombinerObserver[count];, +            for (int i = 0; i < count; i++) {, +                as[i] = new CombinerObserver<T, R>(this, i);, +            }, +            this.observers = as;, +            this.queue = new SpscLinkedArrayQueue<Object[]>(bufferSize);, +                latest = null;, +            final SpscLinkedArrayQueue<Object[]> q = queue;, +                for (;;) {, +                    if (cancelled) {, +                        clear(q);, +                    if (!delayError && errors.get() != null) {, +                        cancelSources();, +                        clear(q);, +                        a.onError(errors.terminate());, +                        return;, +                    }, +                    Object[] s = q.poll();, +                    boolean empty = s == null;, +                    if (d && empty) {, +                        clear(q);, +                        Throwable ex = errors.terminate();, +                        if (ex == null) {, +                            a.onComplete();, +                        } else {, +                            a.onError(ex);, +                        }, +, +                        v = ObjectHelper.requireNonNull(combiner.apply(s), "The combiner returned a null value");, +                        errors.addThrowable(ex);, +                        cancelSources();, +                        clear(q);, +                        ex = errors.terminate();, +        void innerNext(int index, T item) {, +            boolean shouldDrain = false;, +            synchronized (this) {, +                Object[] latest = this.latest;, +                if (latest == null) {, +                    return;, +                Object o = latest[index];, +                int a = active;, +                if (o == null) {, +                    active = ++a;, +                }, +                latest[index] = item;, +                if (a == latest.length) {, +                    queue.offer(latest.clone());, +                    shouldDrain = true;, +                }, +            }, +            if (shouldDrain) {, +                drain();, +            }, +        }, +, +        void innerError(int index, Throwable ex) {, +            if (errors.addThrowable(ex)) {, +                boolean cancelOthers = true;, +                    synchronized (this) {, +                        Object[] latest = this.latest;, +                        if (latest == null) {, +                            return;, +                        cancelOthers = latest[index] == null;, +                        if (cancelOthers || ++complete == latest.length) {, +                            done = true;, +                if (cancelOthers) {, +                    cancelSources();, +                }, +                drain();, +            } else {, +                RxJavaPlugins.onError(ex);, +            }, +        }, +        void innerComplete(int index) {, +            boolean cancelOthers = false;, +            synchronized (this) {, +                Object[] latest = this.latest;, +                if (latest == null) {, +                    return;, +                }, +, +                cancelOthers = latest[index] == null;, +                if (cancelOthers || ++complete == latest.length) {, +                    done = true;, +                }, +            }, +            if (cancelOthers) {, +                cancelSources();, +            }, +            drain();, +        }, +, +    }, +, +    static final class CombinerObserver<T, R> extends AtomicReference<Disposable> implements Observer<T> {, +        private static final long serialVersionUID = -4823716997131257941L;]