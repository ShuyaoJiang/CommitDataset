[+++ b/src/main/java/io/reactivex/Observable.java, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {, +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +++ b/src/main/java/io/reactivex/Observable.java, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {, +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +++ b/src/main/java/io/reactivex/internal/operators/OperatorGroupBy.java, +import io.reactivex.internal.subscriptions.*;, +public final class OperatorGroupBy<T, K, V> implements Operator<GroupedObservable<K, V>, T>{, +    public Subscriber<? super T> apply(Subscriber<? super GroupedObservable<K, V>> t) {, +        final Subscriber<? super GroupedObservable<K, V>> actual;, +        final Map<Object, GroupedUnicast<K, V>> groups;, +        , +        static final Object NULL_KEY = new Object();, +        public GroupBySubscriber(Subscriber<? super GroupedObservable<K, V>> actual, Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector, int bufferSize, boolean delayError) {, +            this.lazySet(1);, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            Object mapKey = key != null ? key : NULL_KEY;, +            GroupedUnicast<K, V> group = groups.get(mapKey);, +                groups.put(mapKey, group);, +            List<GroupedUnicast<K, V>> list = new ArrayList<>(groups.values());, +            for (GroupedUnicast<K, V> e : list) {, +            List<GroupedUnicast<K, V>> list = new ArrayList<>(groups.values());, +            for (GroupedUnicast<K, V> e : list) {, +            Object mapKey = key != null ? key : NULL_KEY;, +            groups.remove(mapKey);, +    static final class GroupedUnicast<K, T> extends GroupedObservable<K, T> {, +        public static <T, K> GroupedUnicast<K, T> createWith(K key, int bufferSize, GroupBySubscriber<?, K, T> parent, boolean delayError) {, +            if (SubscriptionHelper.validateRequest(n)) {, +            parent.request(n);, +++ b/src/main/java/io/reactivex/Observable.java, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {, +    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {, +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +++ b/src/main/java/io/reactivex/internal/operators/OperatorGroupBy.java, +import io.reactivex.internal.subscriptions.*;, +public final class OperatorGroupBy<T, K, V> implements Operator<GroupedObservable<K, V>, T>{, +    public Subscriber<? super T> apply(Subscriber<? super GroupedObservable<K, V>> t) {, +        final Subscriber<? super GroupedObservable<K, V>> actual;, +        final Map<Object, GroupedUnicast<K, V>> groups;, +        , +        static final Object NULL_KEY = new Object();, +        public GroupBySubscriber(Subscriber<? super GroupedObservable<K, V>> actual, Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector, int bufferSize, boolean delayError) {, +            this.lazySet(1);, +            if (SubscriptionHelper.validateSubscription(this.s, s)) {, +            Object mapKey = key != null ? key : NULL_KEY;, +            GroupedUnicast<K, V> group = groups.get(mapKey);, +                groups.put(mapKey, group);, +            List<GroupedUnicast<K, V>> list = new ArrayList<>(groups.values());, +            for (GroupedUnicast<K, V> e : list) {, +            List<GroupedUnicast<K, V>> list = new ArrayList<>(groups.values());, +            for (GroupedUnicast<K, V> e : list) {, +            Object mapKey = key != null ? key : NULL_KEY;, +            groups.remove(mapKey);, +    static final class GroupedUnicast<K, T> extends GroupedObservable<K, T> {, +        public static <T, K> GroupedUnicast<K, T> createWith(K key, int bufferSize, GroupBySubscriber<?, K, T> parent, boolean delayError) {, +            if (SubscriptionHelper.validateRequest(n)) {, +            parent.request(n);, +++ b/src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +package io.reactivex.internal.subscriptions;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import org.reactivestreams.Subscription;, +, +/**, + * Subscription implementation that ignores request but remembers the cancellation, + * which can be checked via isCancelled., + */, +public final class BooleanSubscription extends AtomicBoolean implements Subscription {, +    /** */, +    private static final long serialVersionUID = -8127758972444290902L;, +, +    @Override, +    public void request(long n) {, +        if (SubscriptionHelper.validateRequest(n)) {, +            return;, +        }, +    }, +    ]