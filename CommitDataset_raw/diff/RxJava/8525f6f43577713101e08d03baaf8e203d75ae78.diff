[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., +     *            a function that accepts an {@code Subscriber<T>}, and invokes its {@code onNext}, {@code onError}, and {@code onCompleted} methods as appropriate, +     * @return an Observable that emits items all of the items emitted by the Observables emitted by {@code observables}, one after the other, without interleaving them, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method, +     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method on the specified Scheduler., +     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method with the specified, +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from} method., +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from} method., +     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from} method., +     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as {@link Schedulers#io()} that can block and wait on the Future, +     * To convert any object into an Observable that emits that object, pass that object into the {@code just} method., +     * @return an Observable that emits items that are the result of flattening the Observables emitted by the {@code source} Observable, +     * @return an Observable that emits items that are the result of flattening the Observables emitted by the {@code source} Observable, +     * @return an Observable that emits all of the items emitted by the Observables emitted by the {@code source} Observable, +     * the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged Observables, +     * have finished, +     * if any of the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via, +     * {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error via, +     * {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify of an error, +     * via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)} except that if any of the merged Observables notify, +     * of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that error notification until all of the merged, +     * emitted Observables emit the same items, but the number of such Observables is restricted by {@code parallelObservables}., +     * For example, if the original {@code Observable<Observable<T>>} emits 100 Observables and {@code parallelObservables} is 8, the items emitted by the 100 original Observables will be distributed, +     * emitted Observables emit the same items, but the number of such Observables is restricted by {@code parallelObservables}, and each runs on a defined Scheduler., +     * For example, if the original {@code Observable<Observable<T>>} emits 100 Observables and {@code parallelObservables} is 8, the items emitted by the 100 original Observables will be distributed, +     * <p> {@code switchDo()} subscribes to an Observable that emits Observables. Each time it observes one of these, +     * <p> {@code switchLatest()} subscribes to an Observable that emits Observables. Each time it observes one of, +     * <p> {@code switchOnNext()} subscribes to an Observable that emits Observables. Each time it observes one of, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     *            a function that, when applied to an item emitted by each of the Observables emitted by {@code ws}, results in an item that will be emitted by the resulting Observable, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable, +     * The resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext} as many times as the number of {@code onNext} invocations of the source Observable that, +     * emits the fewest, +     *            a {@link Func0} that produces an Observable for each buffer created. When this {@code Observable} emits an item, {@code buffer()} emits the associated buffer and replaces it, +     * @return an Observable that emits connected, non-overlapping buffers, each containing at most {@code count} items from the source Observable, +     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as {@link #buffer(int)}., +     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source Observable completes or encounters an error, the resulting, +     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the {@code timespan} argument. When the source Observable completes or encounters an error, the, +     * resulting, +     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is, +     * reached, +     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size, +     * specified by, +     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the {@code timespan} argument and on the specified {@code scheduler}. When the source Observable, +     * completes or, +     * When you call {@code cache()}, it does not yet subscribe to the source Observable. This only happens when {@code subscribe} is called the first time on the Observable returned by, +     * {@code cache()}., +     * <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the {@code cache()} Observer so be careful not to use this Observer on Observables that emit an infinite or, +     * very large number, +     * Returns an Observable that reverses the effect of {@link #materialize materialize} by transforming the {@link Notification} objects emitted by the source Observable into the items or, +     * notifications they, +     *            a function that evaluates the items emitted by the source Observable, returning {@code true} if they pass the filter, +     * Registers an {@link Action0} to be called when this Observable invokes either {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}., +     * @return an Observable that emits the same items as the source Observable, then invokes the {@link Action0}, +     * Returns an Observable that emits only the very first item emitted by the source Observable, or raises an {@code IllegalArgumentException} if the source Observable is empty., +     * @return an Observable that emits only the very first item emitted by the source Observable, or raises an {@code IllegalArgumentException} if the source Observable is empty, +     *            the default item to emit if the source Observable doesn't emit anything that satisfies the {@code predicate}, +     * @return an Observable that emits only the last item satisfying the given condition from the source, or an {@code IllegalArgumentException} if no such items are emitted, +     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}, +     * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#wiki-observablepublish-and-observablemulticast">RxJava Wiki: Observable.publish() and, +     *      Observable.multicast()</a>, +     * @return the source Observable modified so that its {@link Observer}s are notified on the specified {@link Scheduler}, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an error., +     * behavior. If you pass a function that returns an Observable ({@code resumeFunction}) to {@code onErrorResumeNext}, if the original Observable encounters an error, instead of invoking its, +     * Observer's {@code onError} method, it will instead relinquish control to the Observable returned from {@code resumeFunction}, which will invoke the Observer's {@link Observer#onNext onNext}, +     * method if it is, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an error., +     * behavior. If you pass another Observable ({@code resumeSequence}) to an Observable's {@code onErrorResumeNext} method, if the original Observable encounters an error, instead of invoking its, +     * Instruct an Observable to emit an item (returned by a specified function) rather than invoking {@link Observer#onError onError} if it encounters an error., +     * behavior. If you pass a function ({@code resumeFunction}) to an Observable's {@code onErrorReturn} method, if the original Observable encounters an error, instead of invoking its Observer's, +     * Instruct an Observable to pass control to another Observable rather than invoking {@link Observer#onError onError} if it encounters an {@link java.lang.Exception}., +     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable} or {@link java.lang.Error} but lets those continue through.]