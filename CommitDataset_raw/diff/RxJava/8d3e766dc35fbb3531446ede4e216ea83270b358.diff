[+++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.PriorityQueue;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>();, +        enqueue(discardableAction, now());, +        long execTime = now() + unit.toMillis(dueTime);, +, +        DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime));, +        enqueue(discardableAction, execTime);, +        return discardableAction;, +    private void enqueue(DiscardableAction<?> action, long execTime) {, +        PriorityQueue<TimedAction> queue = QUEUE.get();, +            queue = new PriorityQueue<TimedAction>();, +        queue.add(new TimedAction(action, execTime));, +                queue.poll().action.call(this);, +    private static class TimedAction implements Comparable<TimedAction> {, +        final DiscardableAction<?> action;, +        final Long execTime;, +, +        private TimedAction(DiscardableAction<?> action, Long execTime) {, +            this.action = action;, +            this.execTime = execTime;, +        }, +, +        @Override, +        public int compareTo(TimedAction timedAction) {, +            return execTime.compareTo(timedAction.execTime);, +        }, +    }, +, +        @Test, +        public void testSequenceOfDelayedActions() {, +            final CurrentThreadScheduler scheduler = new CurrentThreadScheduler();, +, +            final Action0 first = mock(Action0.class);, +            final Action0 second = mock(Action0.class);, +, +            scheduler.schedule(new Action0() {, +                @Override, +                public void call() {, +                    scheduler.schedule(first, 30, TimeUnit.MILLISECONDS);, +                    scheduler.schedule(second, 10, TimeUnit.MILLISECONDS);, +                }, +            });, +, +            InOrder inOrder = inOrder(first, second);, +, +            inOrder.verify(second, times(1)).call();, +            inOrder.verify(first, times(1)).call();, +, +, +        }, +, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import java.util.PriorityQueue;, +    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>();, +        enqueue(discardableAction, now());, +        long execTime = now() + unit.toMillis(dueTime);, +, +        DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime));, +        enqueue(discardableAction, execTime);, +        return discardableAction;, +    private void enqueue(DiscardableAction<?> action, long execTime) {, +        PriorityQueue<TimedAction> queue = QUEUE.get();, +            queue = new PriorityQueue<TimedAction>();, +        queue.add(new TimedAction(action, execTime));, +                queue.poll().action.call(this);, +    private static class TimedAction implements Comparable<TimedAction> {, +        final DiscardableAction<?> action;, +        final Long execTime;, +, +        private TimedAction(DiscardableAction<?> action, Long execTime) {, +            this.action = action;, +            this.execTime = execTime;, +        }, +, +        @Override, +        public int compareTo(TimedAction timedAction) {, +            return execTime.compareTo(timedAction.execTime);, +        }, +    }, +, +        @Test, +        public void testSequenceOfDelayedActions() {, +            final CurrentThreadScheduler scheduler = new CurrentThreadScheduler();, +, +            final Action0 first = mock(Action0.class);, +            final Action0 second = mock(Action0.class);, +, +            scheduler.schedule(new Action0() {, +                @Override, +                public void call() {, +                    scheduler.schedule(first, 30, TimeUnit.MILLISECONDS);, +                    scheduler.schedule(second, 10, TimeUnit.MILLISECONDS);, +                }, +            });, +, +            InOrder inOrder = inOrder(first, second);, +, +            inOrder.verify(second, times(1)).call();, +            inOrder.verify(first, times(1)).call();]