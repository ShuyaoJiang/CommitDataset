[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Users should import rx.lang.scala.All._ and nothing else , + */, +object All {, +  // fix covariance/contravariance once and for all, +  type Timestamped[T] = rx.util.Timestamped[_ <: T], +  type Observer[T] = rx.Observer[_ >: T], +  type Notification[T] = rx.Notification[_ <: T], +  // rx.Observable not here because we need its static methods, and users don't need it, +  , +  type Subscription = rx.Subscription, +  type Scheduler = rx.Scheduler, +}, +, +, +/**, +  import All._, +  import rx.{Observable => JObservable}, +/*, +  def subscribe(observer: Observer[T]): Subscription = {, +  def subscribe(observer: Observer[T], scheduler: Scheduler): Subscription = {, +  */, +  /*, +  /**, +   * TODO doc, +   */, +  def ++[U >: T](that: Observable[U]): Observable[U] = {, +    val o1: JObservable[_ <: U] = this.asJava, +    val o2: JObservable[_ <: U] = that.asJava, +    new Observable(JObservable.concat(o1, o2)), +  }, +  */, +  /**, +   * Wraps this Observable in another Observable that ensures that the resulting, +   * Observable is chronologically well-behaved., +   * <p>, +   * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png">, +   * <p>, +   * A well-behaved Observable does not interleave its invocations of the {@link Observer#onNext onNext}, {@link Observer#onCompleted onCompleted}, and {@link Observer#onError onError} methods of, +   * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}., +   * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously., +   * , +   * @param observable, +   *            the source Observable, +   * @param <T>, +   *            the type of item emitted by the source Observable, +   * @return an Observable that is a chronologically well-behaved version of the source, +   *         Observable, and that synchronously notifies its {@link Observer}s, +   */, +  // If 1st line commented, 2nd active: OK, +  // If 1st line active, 2nd commented: compiler crashes, +  //def synchronize: Observable[T] = {, +  def synchronize: Any = {, +    new Observable(JObservable.synchronize(asJava)), +  }, +  , +  /*, +  /**, +   * Wraps each item emitted by a source Observable in a {@link Timestamped} object., +   * <p>, +   * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/timestamp.png">, +   * , +   * @return an Observable that emits timestamped items from the source Observable, +   */, +  def timestamp: Observable[Timestamped[T]] = {, +    new Observable(asJava.timestamp()), +  }, +  , +  */, +  , +  import rx.lang.scala.All._, +  import rx.{Observable => JObservable}, +  /*, +  def apply[T](func: Observer[T] => Subscription): Observable[T] = {, +  // There is no method corresponding to, +  // public static <T> Observable<T> concat(Observable<? extends T>... source) , +  // because we have the instance method ++ instead, +  /**, +   * This behaves like {@link #merge(java.util.List)} except that if any of the merged Observables, +   * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will, +   * refrain from propagating that error notification until all of the merged Observables have, +   * finished emitting items., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">, +   * <p>, +   * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only invoke the {@code onError} method of its, +   * Observers once., +   * <p>, +   * This method allows an Observer to receive all successfully emitted items from all of the, +   * source Observables without being interrupted by an error notification from one of them., +   * , +   * @param source, +   *            a list of Observables, +   * @return an Observable that emits items that are the result of flattening the items emitted by, +   *         the {@code source} list of Observables, +   * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a>, +   */, +  // public static <T> Observable<T> mergeDelayError(List<? extends Observable<? extends T>> source) , +  // TODO decide if instance method mergeWithDelayError (?), +    /**]