[+++ b/src/main/java/io/reactivex/Observable.java, +        return cacheWithInitialCapacity(16);, +        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, +        return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));, +++ b/src/main/java/io/reactivex/Observable.java, +        return cacheWithInitialCapacity(16);, +        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, +        return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +import io.reactivex.internal.util.BackpressureHelper;, +public final class FlowableCache<T> extends AbstractFlowableWithUpstream<T, T>, +implements FlowableSubscriber<T> {, +    /**, +     * The subscription to the source should happen at most once., +     */, +     * The number of items per cached nodes., +    final int capacityHint;, +, +    /**, +     * The current known array of subscriber state to notify., +     */, +    final AtomicReference<CacheSubscription<T>[]> subscribers;, +, +    /**, +     * A shared instance of an empty array of subscribers to avoid creating, +     * a new empty array when all subscribers cancel., +     */, +    @SuppressWarnings("rawtypes"), +    static final CacheSubscription[] EMPTY = new CacheSubscription[0];, +    /**, +     * A shared instance indicating the source has no more events and there, +     * is no need to remember subscribers anymore., +     */, +    @SuppressWarnings("rawtypes"), +    static final CacheSubscription[] TERMINATED = new CacheSubscription[0];, +, +    /**, +     * The total number of elements in the list available for reads., +     */, +    volatile long size;, +, +    /**, +     * The starting point of the cached items., +     */, +    final Node<T> head;, +, +    /**, +     * The current tail of the linked structure holding the items., +     */, +    Node<T> tail;, +, +    /**, +     * How many items have been put into the tail node so far., +     */, +    int tailOffset;, +, +    /**, +     * If {@link #subscribers} is {@link #TERMINATED}, this holds the terminal error if not null., +     */, +    Throwable error;, +, +    /**, +     * True if the source has terminated., +     */, +    volatile boolean done;, +, +    /**, +     * Constructs an empty, non-connected cache., +     * @param source the source to subscribe to for the first incoming subscriber, +     * @param capacityHint the number of items expected (reduce allocation frequency), +     */, +    @SuppressWarnings("unchecked"), +        this.capacityHint = capacityHint;, +        Node<T> n = new Node<T>(capacityHint);, +        this.head = n;, +        this.tail = n;, +        this.subscribers = new AtomicReference<CacheSubscription<T>[]>(EMPTY);, +        CacheSubscription<T> consumer = new CacheSubscription<T>(t, this);, +        t.onSubscribe(consumer);, +        add(consumer);, +            source.subscribe(this);, +        } else {, +            replay(consumer);, +        return once.get();, +        return subscribers.get().length != 0;, +    /* public */ long cachedEventCount() {, +        return size;, +     * Atomically adds the consumer to the {@link #subscribers} copy-on-write array, +     * if the source has not yet terminated., +     * @param consumer the consumer to add, +    void add(CacheSubscription<T> consumer) {, +            CacheSubscription<T>[] current = subscribers.get();, +            if (current == TERMINATED) {, +                return;, +            int n = current.length;, +, +            CacheSubscription<T>[] next = new CacheSubscription[n + 1];, +            System.arraycopy(current, 0, next, 0, n);, +            next[n] = consumer;, +]