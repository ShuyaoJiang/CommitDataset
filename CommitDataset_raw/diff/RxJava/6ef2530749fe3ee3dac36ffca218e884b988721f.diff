[+++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java, +import java.util.concurrent.TimeUnit;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action0;, +import rx.util.functions.Action1;, +                        System.out.println("unsubscribe from merge");, +            CompositeSubscription completeSubscription = new CompositeSubscription();, +            completeSubscription.add(subscription);, +            completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));, +            return completeSubscription;, +        public void testUnSubscribeObservableOfObservables() throws InterruptedException {, +, +            final AtomicBoolean unsubscribed = new AtomicBoolean();, +            final CountDownLatch latch = new CountDownLatch(1);, +, +            Observable<Observable<Long>> source = Observable.create(new OnSubscribeFunc<Observable<Long>>() {, +, +                @Override, +                public Subscription onSubscribe(final Observer<? super Observable<Long>> observer) {, +                    // verbose on purpose so I can track the inside of it, +                    final Subscription s = Subscriptions.create(new Action0() {, +, +                        @Override, +                        public void call() {, +                            System.out.println("*** unsubscribed");, +                            unsubscribed.set(true);, +                        }, +, +                    });, +, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +, +                            while (!unsubscribed.get()) {, +                                observer.onNext(Observable.from(1L, 2L));, +                            }, +                            System.out.println("Done looping after unsubscribe: " + unsubscribed.get());, +                            observer.onCompleted();, +, +                            // mark that the thread is finished, +                            latch.countDown();, +                        }, +                    }).start();, +, +                    return s;, +                };, +, +            });, +, +            final AtomicInteger count = new AtomicInteger();, +            Observable.create(merge(source)).take(6).toBlockingObservable().forEach(new Action1<Long>() {, +, +                @Override, +                public void call(Long v) {, +                    System.out.println("Value: " + v);, +                    int c = count.incrementAndGet();, +                    if (c > 6) {, +                        fail("Should be only 6");, +                    }, +, +                }, +            });, +, +            latch.await(1000, TimeUnit.MILLISECONDS);, +, +            System.out.println("unsubscribed: " + unsubscribed.get());, +, +            assertTrue(unsubscribed.get());, +, +        }, +, +        @Test]