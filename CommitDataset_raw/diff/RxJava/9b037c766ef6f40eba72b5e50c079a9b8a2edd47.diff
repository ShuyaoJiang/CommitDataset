[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.plugins.RxJavaPlugins;, +        TimeoutMainObserver<T> parent = new TimeoutMainObserver<T>(s, other);, +        s.onSubscribe(parent);, +        DisposableHelper.replace(parent.task, scheduler.scheduleDirect(parent, timeout, unit));, +        source.subscribe(parent);, +    static final class TimeoutMainObserver<T> extends AtomicReference<Disposable>, +    implements SingleObserver<T>, Runnable, Disposable {, +        private static final long serialVersionUID = 37497744973048446L;, +, +        final SingleObserver<? super T> actual;, +, +        final AtomicReference<Disposable> task;, +, +        final TimeoutFallbackObserver<T> fallback;, +, +        SingleSource<? extends T> other;, +, +        static final class TimeoutFallbackObserver<T> extends AtomicReference<Disposable>, +        implements SingleObserver<T> {, +, +            private static final long serialVersionUID = 2071387740092105509L;, +            final SingleObserver<? super T> actual;, +, +            TimeoutFallbackObserver(SingleObserver<? super T> actual) {, +                this.actual = actual;, +            }, +, +            @Override, +            public void onSubscribe(Disposable d) {, +                DisposableHelper.setOnce(this, d);, +            }, +, +            @Override, +            public void onSuccess(T t) {, +                actual.onSuccess(t);, +            }, +, +            @Override, +            public void onError(Throwable e) {, +                actual.onError(e);, +            }, +        }, +, +        TimeoutMainObserver(SingleObserver<? super T> actual, SingleSource<? extends T> other) {, +            this.actual = actual;, +            this.other = other;, +            this.task = new AtomicReference<Disposable>();, +            if (other != null) {, +                this.fallback = new TimeoutFallbackObserver<T>(actual);, +            } else {, +                this.fallback = null;, +            }, +            Disposable d = get();, +            if (d != DisposableHelper.DISPOSED && compareAndSet(d, DisposableHelper.DISPOSED)) {, +                if (d != null) {, +                    d.dispose();, +                }, +                SingleSource<? extends T> other = this.other;, +                if (other == null) {, +                    actual.onError(new TimeoutException());, +                    this.other = null;, +                    other.subscribe(fallback);, +            DisposableHelper.setOnce(this, d);, +        public void onSuccess(T t) {, +            Disposable d = get();, +            if (d != DisposableHelper.DISPOSED && compareAndSet(d, DisposableHelper.DISPOSED)) {, +                DisposableHelper.dispose(task);, +                actual.onSuccess(t);, +        @Override, +        public void onError(Throwable e) {, +            Disposable d = get();, +            if (d != DisposableHelper.DISPOSED && compareAndSet(d, DisposableHelper.DISPOSED)) {, +                DisposableHelper.dispose(task);, +                actual.onError(e);, +            } else {, +                RxJavaPlugins.onError(e);, +            }, +        }, +, +        @Override, +        public void dispose() {, +            DisposableHelper.dispose(this);, +            DisposableHelper.dispose(task);, +            if (fallback != null) {, +                DisposableHelper.dispose(fallback);, +            }, +        }, +, +        @Override, +        public boolean isDisposed() {, +            return DisposableHelper.isDisposed(get());, +        }, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.DisposableHelper;]