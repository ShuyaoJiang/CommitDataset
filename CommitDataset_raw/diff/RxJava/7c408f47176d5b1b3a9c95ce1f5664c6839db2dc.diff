[+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.subscriptions.Subscriptions;, +        // We should not call `unsubscribe()` until `groups.isEmpty() && child.isUnsubscribed()` is true., +        // Use `WIP_FOR_UNSUBSCRIBE_UPDATER` to monitor these statuses and call `unsubscribe()` properly., +        // Should check both when `child.unsubscribe` is called and any group is removed., +        @SuppressWarnings("rawtypes"), +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP_FOR_UNSUBSCRIBE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "wipForUnsubscribe");, +        volatile int wipForUnsubscribe = 1;, +, +            child.add(Subscriptions.create(new Action0() {, +, +                @Override, +                public void call() {, +                    if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(self) == 0) {, +                        self.unsubscribe();, +                    }, +                }, +, +            }));, +, +        private static final int UNTERMINATED = 0;, +        private static final int TERMINATED_WITH_COMPLETED = 1;, +        private static final int TERMINATED_WITH_ERROR = 2;, +, +        // Must be one of `UNTERMINATED`, `TERMINATED_WITH_COMPLETED`, `TERMINATED_WITH_ERROR`, +        volatile int terminated = UNTERMINATED;, +            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_COMPLETED)) {, +                if (groups.isEmpty()) {, +            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_ERROR)) {, +                // It's safe to access all groups and emit the error., +                // onNext and onError are in sequence so no group will be created in the loop., +                for (GroupState<K, T> group : groups.values()) {, +                    emitItem(group, nl.error(e));, +                }, +                try {, +                } finally {, +                    // We have not chained the subscribers, so need to call it explicitly., +                    unsubscribe();, +                }, +                if (group != null) {, +                }, +                            // eagerly cleanup instead of waiting for unsubscribe, +                            if (once.compareAndSet(false, true)) {, +                                // done once per instance, either onComplete or onUnSubscribe, +                                cleanupGroup(key);, +                            }, +            GroupState<K, T> putIfAbsent;, +            for (;;) {, +                int wip = wipForUnsubscribe;, +                if (wip <= 0) {, +                    return null;, +                }, +                if (WIP_FOR_UNSUBSCRIBE_UPDATER.compareAndSet(this, wip, wip + 1)) {, +                    putIfAbsent = groups.putIfAbsent(key, groupState);, +                    break;, +                }, +            }, +                if (!removed.buffer.isEmpty()) {, +            // A group is removed, so check if we need to call `unsubscribe`, +            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {, +                // It means `groups.isEmpty() && child.isUnsubscribed()` is true, +                unsubscribe();, +            } else if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {, +                // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.subscriptions.Subscriptions;, +        // We should not call `unsubscribe()` until `groups.isEmpty() && child.isUnsubscribed()` is true., +        // Use `WIP_FOR_UNSUBSCRIBE_UPDATER` to monitor these statuses and call `unsubscribe()` properly., +        // Should check both when `child.unsubscribe` is called and any group is removed., +        @SuppressWarnings("rawtypes"), +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP_FOR_UNSUBSCRIBE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "wipForUnsubscribe");, +        volatile int wipForUnsubscribe = 1;, +, +            child.add(Subscriptions.create(new Action0() {, +, +                @Override, +                public void call() {, +                    if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(self) == 0) {, +                        self.unsubscribe();, +                    }, +                }, +, +            }));, +, +        private static final int UNTERMINATED = 0;, +        private static final int TERMINATED_WITH_COMPLETED = 1;, +        private static final int TERMINATED_WITH_ERROR = 2;, +, +        // Must be one of `UNTERMINATED`, `TERMINATED_WITH_COMPLETED`, `TERMINATED_WITH_ERROR`, +        volatile int terminated = UNTERMINATED;, +            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_COMPLETED)) {, +                if (groups.isEmpty()) {, +            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_ERROR)) {, +                // It's safe to access all groups and emit the error., +                // onNext and onError are in sequence so no group will be created in the loop., +                for (GroupState<K, T> group : groups.values()) {]