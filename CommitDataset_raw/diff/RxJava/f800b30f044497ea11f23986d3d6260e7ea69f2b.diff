[+++ b/src/main/java/io/reactivex/Flowable.java, +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     *, +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     *, +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     *, +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     *, +     * <p>, +     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, +     * the unconsumed groups may starve other groups due to the internal backpressure, +     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, +     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, +     * value to be greater or equal to the expected number of groups, possibly using, +     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., +     *]