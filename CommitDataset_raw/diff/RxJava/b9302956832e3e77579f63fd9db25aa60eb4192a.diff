[+++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.Observable;, +import rx.subjects.Subject;, + * @param <K>, + *            the key type, + * @param <T>, + *            the source and group value type, + * @param <R>, + *            the value type of the groups, +public class OperatorGroupBy<T, K, R> implements Operator<GroupedObservable<K, R>, T> {, +    final Func1<? super T, ? extends R> valueSelector;, +    public OperatorGroupBy(, +            Func1<? super T, ? extends K> keySelector,, +            Func1<? super T, ? extends R> valueSelector) {, +        this.valueSelector = valueSelector;, +        return new GroupBySubscriber<K, T, R>(keySelector, valueSelector, child);, +, +        final GroupBySubscriber<K, T, R> self = this;, +        public GroupBySubscriber(, +                Func1<? super T, ? extends K> keySelector,, +                Func1<? super T, ? extends R> elementSelector,, +                Subscriber<? super GroupedObservable<K, R>> child) {, +, +        private static class GroupState<K, T> {, +            private final Subject<T, T> s = BufferUntilSubscriber.create();, +            private final AtomicLong requested = new AtomicLong();, +            private final AtomicLong count = new AtomicLong();, +            private final Queue<Object> buffer = new ConcurrentLinkedQueue<Object>(); // TODO should this be lazily created?, +, +            public Observable<T> getObservable() {, +                return s;, +            }, +, +            public Observer<T> getObserver() {, +                return s;, +            }, +, +        }, +, +        private final ConcurrentHashMap<K, GroupState<K, T>> groups = new ConcurrentHashMap<K, GroupState<K, T>>();, +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_EMITTED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "completionEmitted");, +        static final AtomicIntegerFieldUpdater<GroupBySubscriber> TERMINATED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "terminated");, +                for (GroupState<K, T> group : groups.values()) {, +                    emitItem(group, nl.completed());, +, +                // special case (no groups emitted ... or all unsubscribed), +                if (groups.size() == 0) {, +        void requestFromGroupedObservable(long n, GroupState<K, T> group) {, +            group.requested.getAndAdd(n);, +            if (group.count.getAndIncrement() == 0) {, +                pollQueue(group);, +                GroupState<K, T> group = groups.get(key);, +                    group = createNewGroup(key);, +                }, +                emitItem(group, nl.next(t));, +            } catch (Throwable e) {, +                onError(OnErrorThrowable.addValueAsLastCause(e, t));, +            }, +        }, +, +        private GroupState<K, T> createNewGroup(final K key) {, +            final GroupState<K, T> groupState = new GroupState<K, T>();, +                            requestFromGroupedObservable(n, groupState);, +, +                    final AtomicBoolean once = new AtomicBoolean();, +, +                    groupState.getObservable().doOnUnsubscribe(new Action0() {, +, +                        @Override, +                        public void call() {, +                            if (once.compareAndSet(false, true)) {, +                                // done once per instance, either onComplete or onUnSubscribe, +                                cleanupGroup(key);, +                            }, +                        }, +, +                    }).unsafeSubscribe(new Subscriber<T>(o) {, +                            // eagerly cleanup instead of waiting for unsubscribe, +                            if (once.compareAndSet(false, true)) {, +                                // done once per instance, either onComplete or onUnSubscribe, +                                cleanupGroup(key);, +                            }, +                            try {, +                    });, +                }, +            });, +            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);, +            if (putIfAbsent != null) {, +                // this shouldn't happen (because we receive onNext sequentially) and would mean we have a bug, +                throw new IllegalStateException("Group already existed while creating a new one");, +            }, +            child.onNext(go);, +            return groupState;, +        private void cleanupGroup(K key) {, +            GroupState<K, T> removed;, +            removed = groups.remove(key);, +            if (removed != null) {]