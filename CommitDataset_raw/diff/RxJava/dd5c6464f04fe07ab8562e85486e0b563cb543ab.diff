[+++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import static rx.internal.util.PlatformDependent.ANDROID_API_VERSION_IS_NOT_ANDROID;, +, +    private static final boolean SHOULD_TRY_ENABLE_CANCEL_POLICY;, +, +        // Forces the use of purge even if setRemoveOnCancelPolicy is available, +        final boolean purgeForce = Boolean.getBoolean(PURGE_FORCE_KEY);, +, +        final int androidApiVersion = PlatformDependent.getAndroidApiVersion();, +, +        // According to http://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy(boolean), +        // setRemoveOnCancelPolicy available since Android API 21, +        SHOULD_TRY_ENABLE_CANCEL_POLICY = !purgeForce, +                && (androidApiVersion == ANDROID_API_VERSION_IS_NOT_ANDROID || androidApiVersion >= 21);, +, +     * Improves performance of {@link #tryEnableCancelPolicy(ScheduledExecutorService)}., +     * Also, it works even for inheritance: {@link Method} of base class can be invoked on the instance of child class., +     */, +    private static volatile Object cachedSetRemoveOnCancelPolicyMethod;, +, +    /**, +     * Possible value of {@link #cachedSetRemoveOnCancelPolicyMethod} which means that cancel policy is not supported., +     */, +     private static final Object SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED = new Object();, +, +    /**, +     * @param executor the executor to call setRemoveOnCaneclPolicy if available., +    public static boolean tryEnableCancelPolicy(ScheduledExecutorService executor) {, +        if (SHOULD_TRY_ENABLE_CANCEL_POLICY) {, +            final boolean isInstanceOfScheduledThreadPoolExecutor = executor instanceof ScheduledThreadPoolExecutor;, +, +            final Method methodToCall;, +, +            if (isInstanceOfScheduledThreadPoolExecutor) {, +                final Object localSetRemoveOnCancelPolicyMethod = cachedSetRemoveOnCancelPolicyMethod;, +, +                if (localSetRemoveOnCancelPolicyMethod == SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED) {, +                if (localSetRemoveOnCancelPolicyMethod == null) {, +                    Method method = findSetRemoveOnCancelPolicyMethod(executor);, +, +                    cachedSetRemoveOnCancelPolicyMethod = method != null, +                            ? method, +                            : SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED;, +, +                    methodToCall = method;, +                } else {, +                    methodToCall = (Method) localSetRemoveOnCancelPolicyMethod;, +                }, +            } else {, +                methodToCall = findSetRemoveOnCancelPolicyMethod(executor);, +            }, +, +            if (methodToCall != null) {, +                try {, +                    methodToCall.invoke(executor, true);, +                    return true;, +                } catch (Exception e) {, +                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);, +                }, +            }, +        }, +, +        return false;, +    }, +, +    /**, +     * Tries to find {@code "setRemoveOnCancelPolicy(boolean)"} method in the class of passed executor., +     *, +     * @param executor whose class will be used to search for required method., +     * @return {@code "setRemoveOnCancelPolicy(boolean)"} {@link Method}, +     * or {@code null} if required {@link Method} was not found., +     */, +    static Method findSetRemoveOnCancelPolicyMethod(ScheduledExecutorService executor) {, +        // The reason for the loop is to avoid NoSuchMethodException being thrown on JDK 6, +        // which is more costly than looping through ~70 methods., +        for (final Method method : executor.getClass().getMethods()) {, +            if (method.getName().equals("setRemoveOnCancelPolicy")) {, +                final Class<?>[] parameterTypes = method.getParameterTypes();, +, +                if (parameterTypes.length == 1 && parameterTypes[0] == Boolean.TYPE) {, +                    return method;, +                }, +            }, +        }, +, +        return null;, +    }, +    , +++ b/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java, +++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java, +import static rx.internal.util.PlatformDependent.ANDROID_API_VERSION_IS_NOT_ANDROID;, +, +    private static final boolean SHOULD_TRY_ENABLE_CANCEL_POLICY;, +, +        // Forces the use of purge even if setRemoveOnCancelPolicy is available, +        final boolean purgeForce = Boolean.getBoolean(PURGE_FORCE_KEY);, +, +        final int androidApiVersion = PlatformDependent.getAndroidApiVersion();]