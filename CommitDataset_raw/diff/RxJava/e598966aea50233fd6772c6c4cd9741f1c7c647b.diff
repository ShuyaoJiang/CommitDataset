[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import rx.observables.GroupedObservable;, +    public Subscriber<? super T> call(Subscriber<? super R> op) {, +        Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =, +                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {, +                    long i = 0;, +                    public Long call(T t) {, +                        return i++ % degreeOfParallelism;, +        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Long, T>>> map =, +                new OperatorMap<GroupedObservable<Long, T>, Observable<R>>(, +                        new Func1<GroupedObservable<Long, T>, Observable<R>>() {, +                            public Observable<R> call(GroupedObservable<Long, T> g) {, +                                // Must use observeOn not subscribeOn because we have a single source behind groupBy., +                                // The origin is already subscribed to, we are moving each group on to a new thread, +                                // but the origin itself can only be on a single thread., +                                return f.call(g.observeOn(scheduler));, +                        });, +        // bind together Observers, +        return groupBy.call(map.call(new OperatorMerge<R>().call(op)));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import rx.observables.GroupedObservable;, +    public Subscriber<? super T> call(Subscriber<? super R> op) {, +        Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =, +                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {, +                    long i = 0;, +                    public Long call(T t) {, +                        return i++ % degreeOfParallelism;, +        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Long, T>>> map =, +                new OperatorMap<GroupedObservable<Long, T>, Observable<R>>(, +                        new Func1<GroupedObservable<Long, T>, Observable<R>>() {, +                            public Observable<R> call(GroupedObservable<Long, T> g) {, +                                // Must use observeOn not subscribeOn because we have a single source behind groupBy., +                                // The origin is already subscribed to, we are moving each group on to a new thread, +                                // but the origin itself can only be on a single thread., +                                return f.call(g.observeOn(scheduler));, +                        });, +        // bind together Observers, +        return groupBy.call(map.call(new OperatorMerge<R>().call(op)));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Observer;, +import rx.observers.SerializedObserver;, +                Outer<K1, K2, T> newOuter = Outer.<K1, K2, T> create(key2);, +        private final Observer<T> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<T>(subscriber);, +        private final Observer<GroupedObservable<K1, T>> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<GroupedObservable<K1, T>>(subscriber);, +        public static <K1, K2, T> Outer<K1, K2, T> create(final K2 key2) {, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import rx.observables.GroupedObservable;, +    public Subscriber<? super T> call(Subscriber<? super R> op) {, +        Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =, +                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {, +                    long i = 0;, +                    public Long call(T t) {, +                        return i++ % degreeOfParallelism;, +        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Long, T>>> map =, +                new OperatorMap<GroupedObservable<Long, T>, Observable<R>>(, +                        new Func1<GroupedObservable<Long, T>, Observable<R>>() {, +                            public Observable<R> call(GroupedObservable<Long, T> g) {, +                                // Must use observeOn not subscribeOn because we have a single source behind groupBy., +                                // The origin is already subscribed to, we are moving each group on to a new thread, +                                // but the origin itself can only be on a single thread., +                                return f.call(g.observeOn(scheduler));, +                        });, +        // bind together Observers, +        return groupBy.call(map.call(new OperatorMerge<R>().call(op)));, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Observer;, +import rx.observers.SerializedObserver;, +                Outer<K1, K2, T> newOuter = Outer.<K1, K2, T> create(key2);, +        private final Observer<T> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<T>(subscriber);, +        private final Observer<GroupedObservable<K1, T>> subscriber;, +            // since multiple threads are being pivoted we need to make sure this is serialized, +            this.subscriber = new SerializedObserver<GroupedObservable<K1, T>>(subscriber);, +        public static <K1, K2, T> Outer<K1, K2, T> create(final K2 key2) {, +++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorParallelTest.java, +    @Test, +    @Test, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorParallel.java, +import rx.observables.GroupedObservable;, +    public Subscriber<? super T> call(Subscriber<? super R> op) {, +        Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =, +                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {, +                    long i = 0;, +                    public Long call(T t) {, +                        return i++ % degreeOfParallelism;, +        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Long, T>>> map =, +                new OperatorMap<GroupedObservable<Long, T>, Observable<R>>(, +                        new Func1<GroupedObservable<Long, T>, Observable<R>>() {, +                            public Observable<R> call(GroupedObservable<Long, T> g) {, +                                // Must use observeOn not subscribeOn because we have a single source behind groupBy., +                                // The origin is already subscribed to, we are moving each group on to a new thread, +                                // but the origin itself can only be on a single thread., +                                return f.call(g.observeOn(scheduler));, +                        });, +        // bind together Observers]