[+++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java, +import static rx.subscriptions.Subscriptions.empty;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +	private final AtomicBoolean unsubscribed = new AtomicBoolean();, +	private final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());, +		if (unsubscribed.compareAndSet(false, true)) {, +			reference.getAndSet(empty()).unsubscribe();, +, +	public void setSubscription(final Subscription subscription) {, +		if (unsubscribed.get()) {, +			subscription.unsubscribe();, +		} else {, +			reference.getAndSet(subscription == null ? empty() : subscription).unsubscribe();, +		return reference.get();, +++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java, +import static rx.subscriptions.Subscriptions.empty;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +	private final AtomicBoolean unsubscribed = new AtomicBoolean();, +	private final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());, +		if (unsubscribed.compareAndSet(false, true)) {, +			reference.getAndSet(empty()).unsubscribe();, +, +	public void setSubscription(final Subscription subscription) {, +		if (unsubscribed.get()) {, +			subscription.unsubscribe();, +		} else {, +			reference.getAndSet(subscription == null ? empty() : subscription).unsubscribe();, +		return reference.get();, +++ b/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java, +import static org.junit.Assert.fail;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.CountDownLatch;, +	public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() {, +, +	@Test(timeout = 1000), +	public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently(), +			throws InterruptedException {, +		final Subscription firstSet = mock(Subscription.class);, +		serialSubscription.setSubscription(firstSet);, +, +		final CountDownLatch start = new CountDownLatch(1);, +, +		final int count = 10;, +		final CountDownLatch end = new CountDownLatch(count);, +, +		final List<Thread> threads = new ArrayList<Thread>();, +		for (int i = 0 ; i < count ; i++) {, +			final Thread t = new Thread() {, +				@Override, +				public void run() {, +					try {, +						start.await();, +						serialSubscription.unsubscribe();, +					} catch (InterruptedException e) {, +						fail(e.getMessage());, +					} finally {, +						end.countDown();, +					}, +				}, +			};, +			t.start();, +			threads.add(t);, +		}, +, +		final Subscription underlying = mock(Subscription.class);, +		start.countDown();, +		serialSubscription.setSubscription(underlying);, +		end.await();, +		verify(firstSet).unsubscribe();, +		verify(underlying).unsubscribe();, +, +		for (final Thread t : threads) {, +			t.interrupt();, +		}, +	}]