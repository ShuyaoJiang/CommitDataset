[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.single.SingleReduceFlowable;, +        return singleElement().blockingGet();, +        return single(defaultItem).blockingGet();, +     * Returns a Single that counts the total number of items emitted by the source Publisher and emits, +     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a, +    public final Single<Long> count() {, +        return RxJavaPlugins.onAssembly(new FlowableCountSingle<T>(this));, +     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from a, +     * @return a Maybe that emits a single item: the item at the specified position in the sequence of, +    public final Maybe<T> elementAt(long index) {, +        return RxJavaPlugins.onAssembly(new FlowableElementAtMaybe<T>(this, index));, +    public final Single<T> elementAt(long index, T defaultItem) {, +        return RxJavaPlugins.onAssembly(new FlowableElementAtSingle<T>(this, index, defaultItem));, +     * Returns a Maybe that emits only the very first item emitted by the source Publisher, or notifies, +     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a Maybe that emits only the very first item emitted by the source Publisher, or raises an, +    public final Maybe<T> firstElement() {, +        return elementAt(0);, +     * Returns a Single that emits only the very first item emitted by the source Publisher, or a default, +     * @return a Single that emits only the very first item from the source, or a default item if the, +    public final Single<T> first(T defaultItem) {, +        return elementAt(0, defaultItem);, +     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is, +    public final Completable ignoreElements() {, +        return RxJavaPlugins.onAssembly(new FlowableIgnoreElementsCompletable<T>(this));, +     * Returns a Maybe that emits the last item emitted by the source Publisher or completes if the source Publisher is empty., +     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a new Maybe instance, +    public final Maybe<T> lastElement() {, +        return RxJavaPlugins.onAssembly(new FlowableLastMaybe<T>(this));, +    public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<R>(scan(seed, reducer).takeLast(1), null)); // TODO dedicated operator, +    public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<R>(scanWith(seedSupplier, reducer).takeLast(1), null)); // TODO dedicated operator, +     * Returns a Maybe that emits the single item emitted by the source Publisher, if that Publisher, +     * emits only a single item. If the source Publisher emits more than one item, notify of an, +     * {@code IllegalArgumentException}., +     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a Maybe that emits the single item emitted by the source Publisher, +    public final Maybe<T> singleElement() {, +        return RxJavaPlugins.onAssembly(new FlowableSingleMaybe<T>(this));, +     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher, +     * @return a Single that emits the single item emitted by the source Publisher, or a default item if, +    public final Single<T> single(T defaultItem) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<T>(this, defaultItem));, +            return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<T>(this));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.single.SingleReduceFlowable;, +        return singleElement().blockingGet();, +        return single(defaultItem).blockingGet();, +     * Returns a Single that counts the total number of items emitted by the source Publisher and emits, +     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a, +    public final Single<Long> count() {, +        return RxJavaPlugins.onAssembly(new FlowableCountSingle<T>(this));, +     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from a, +     * @return a Maybe that emits a single item: the item at the specified position in the sequence of, +    public final Maybe<T> elementAt(long index) {, +        return RxJavaPlugins.onAssembly(new FlowableElementAtMaybe<T>(this, index));, +    public final Single<T> elementAt(long index, T defaultItem) {, +        return RxJavaPlugins.onAssembly(new FlowableElementAtSingle<T>(this, index, defaultItem));, +     * Returns a Maybe that emits only the very first item emitted by the source Publisher, or notifies, +     *  <dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a Maybe that emits only the very first item emitted by the source Publisher, or raises an, +    public final Maybe<T> firstElement() {, +        return elementAt(0);, +     * Returns a Single that emits only the very first item emitted by the source Publisher, or a default, +     * @return a Single that emits only the very first item from the source, or a default item if the, +    public final Single<T> first(T defaultItem) {, +        return elementAt(0, defaultItem);, +     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is, +    public final Completable ignoreElements() {, +        return RxJavaPlugins.onAssembly(new FlowableIgnoreElementsCompletable<T>(this));, +     * Returns a Maybe that emits the last item emitted by the source Publisher or completes if the source Publisher is empty., +     *  <dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a new Maybe instance, +    public final Maybe<T> lastElement() {, +        return RxJavaPlugins.onAssembly(new FlowableLastMaybe<T>(this));, +    public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<R>(scan(seed, reducer).takeLast(1), null)); // TODO dedicated operator, +    public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<R>(scanWith(seedSupplier, reducer).takeLast(1), null)); // TODO dedicated operator, +     * Returns a Maybe that emits the single item emitted by the source Publisher, if that Publisher, +     * emits only a single item. If the source Publisher emits more than one item, notify of an, +     * {@code IllegalArgumentException}., +     *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.</dd>, +     * @return a Maybe that emits the single item emitted by the source Publisher, +    public final Maybe<T> singleElement() {, +        return RxJavaPlugins.onAssembly(new FlowableSingleMaybe<T>(this));, +     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher, +     * @return a Single that emits the single item emitted by the source Publisher, or a default item if, +    public final Single<T> single(T defaultItem) {, +        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<T>(this, defaultItem));, +            return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<T>(this));, +++ b/src/main/java/io/reactivex/Maybe.java, +        return toFlowable().retry(predicate).singleElement();, +        return toFlowable().retry(times, predicate).singleElement();, +        return toFlowable().retryWhen(handler).singleElement();, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.single.SingleReduceFlowable;]