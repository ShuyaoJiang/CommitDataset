[+++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +* `AsyncSubject[T]()`, +* `BehaviorSubject[T](value)`, +* `PublishSubject[T]()`, +* `ReplaySubject[T]()`, +* `CurrentThreadScheduler()`, +* `ExecutorScheduler(executor)`, +* `ImmediateScheduler()`, +* `NewThreadScheduler()`, +* `ScheduledExecutorServiceScheduler(scheduledExecutorService)`, +* `TestScheduler()`, +* `ThreadPoolForComputationScheduler()`, +* `ThreadPoolForIOScheduler()`, +Subscriptions, +-------------, +, +The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`, +and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bugfix in RxJava,, +`SerialSubscription` implements its own `isUnsubscribed`., +, +, +```scala, +trait Subscription {, +, +  private [scala] val asJavaSubscription: rx.Subscription = {...}, +  private [scala] val unsubscribed = new AtomicBoolean(false), +, +  def unsubscribe(): Unit = { unsubscribed.set(true) }, +  def isUnsubscribed: Boolean = unsubscribed.get(), +}, +, +object Subscription {...}, + ```, +, + To create a `Subscription` use one of the following factory methods:, +, + * `Subscription{...}`, `Subscription()`, + * `CompositeSubscription(subscriptions)`, + * `MultipleAssignmentSubscription`, + * `SerialSubscription`, +, + In case you do feel tempted to call `new Subscription{ ...}` directly make sure you wire up `isUnsubscribed` properly., +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +* `AsyncSubject[T]()`, +* `BehaviorSubject[T](value)`, +* `PublishSubject[T]()`, +* `ReplaySubject[T]()`, +* `CurrentThreadScheduler()`, +* `ExecutorScheduler(executor)`, +* `ImmediateScheduler()`, +* `NewThreadScheduler()`, +* `ScheduledExecutorServiceScheduler(scheduledExecutorService)`, +* `TestScheduler()`, +* `ThreadPoolForComputationScheduler()`, +* `ThreadPoolForIOScheduler()`, +Subscriptions, +-------------, +, +The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`, +and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bugfix in RxJava,, +`SerialSubscription` implements its own `isUnsubscribed`., +, +, +```scala, +trait Subscription {, +, +  private [scala] val asJavaSubscription: rx.Subscription = {...}, +  private [scala] val unsubscribed = new AtomicBoolean(false), +, +  def unsubscribe(): Unit = { unsubscribed.set(true) }, +  def isUnsubscribed: Boolean = unsubscribed.get(), +}, +, +object Subscription {...}, + ```, +, + To create a `Subscription` use one of the following factory methods:, +, + * `Subscription{...}`, `Subscription()`, + * `CompositeSubscription(subscriptions)`, + * `MultipleAssignmentSubscription`, + * `SerialSubscription`, +, + In case you do feel tempted to call `new Subscription{ ...}` directly make sure you wire up `isUnsubscribed` properly., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +// TODO add switch statement to pick specific constructor so you can downcast, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +* `AsyncSubject[T]()`, +* `BehaviorSubject[T](value)`, +* `PublishSubject[T]()`, +* `ReplaySubject[T]()`, +* `CurrentThreadScheduler()`, +* `ExecutorScheduler(executor)`, +* `ImmediateScheduler()`, +* `NewThreadScheduler()`, +* `ScheduledExecutorServiceScheduler(scheduledExecutorService)`, +* `TestScheduler()`, +* `ThreadPoolForComputationScheduler()`, +* `ThreadPoolForIOScheduler()`, +Subscriptions]