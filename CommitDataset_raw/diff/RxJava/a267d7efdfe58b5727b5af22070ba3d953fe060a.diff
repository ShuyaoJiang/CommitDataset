[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutSupport;, +            Observable<T> source,, +    protected void subscribeActual(Observer<? super T> s) {, +            TimeoutObserver<T> parent = new TimeoutObserver<T>(s, itemTimeoutIndicator);, +            s.onSubscribe(parent);, +            parent.startFirstTimeout(firstTimeoutIndicator);, +            source.subscribe(parent);, +            TimeoutFallbackObserver<T> parent = new TimeoutFallbackObserver<T>(s, itemTimeoutIndicator, other);, +            s.onSubscribe(parent);, +            parent.startFirstTimeout(firstTimeoutIndicator);, +            source.subscribe(parent);, +    interface TimeoutSelectorSupport extends TimeoutSupport {, +        void onTimeoutError(long idx, Throwable ex);, +    }, +    static final class TimeoutObserver<T> extends AtomicLong, +    implements Observer<T>, Disposable, TimeoutSelectorSupport {, +, +        private static final long serialVersionUID = 3764492702657003550L;, +, +        final Function<? super T, ? extends ObservableSource<?>> itemTimeoutIndicator;, +        final SequentialDisposable task;, +        final AtomicReference<Disposable> upstream;, +, +        TimeoutObserver(Observer<? super T> actual, Function<? super T, ? extends ObservableSource<?>> itemTimeoutIndicator) {, +            this.task = new SequentialDisposable();, +            this.upstream = new AtomicReference<Disposable>();, +            DisposableHelper.setOnce(upstream, s);, +            long idx = get();, +            if (idx == Long.MAX_VALUE || !compareAndSet(idx, idx + 1)) {, +                return;, +            }, +            Disposable d = task.get();, +            actual.onNext(t);, +, +            ObservableSource<?> itemTimeoutObservableSource;, +                itemTimeoutObservableSource = ObjectHelper.requireNonNull(, +                        itemTimeoutIndicator.apply(t),, +                        "The itemTimeoutIndicator returned a null ObservableSource.");, +            } catch (Throwable ex) {, +                Exceptions.throwIfFatal(ex);, +                upstream.get().dispose();, +                getAndSet(Long.MAX_VALUE);, +                actual.onError(ex);, +            TimeoutConsumer consumer = new TimeoutConsumer(idx + 1, this);, +            if (task.replace(consumer)) {, +                itemTimeoutObservableSource.subscribe(consumer);, +            }, +        }, +        void startFirstTimeout(ObservableSource<?> firstTimeoutIndicator) {, +            if (firstTimeoutIndicator != null) {, +                TimeoutConsumer consumer = new TimeoutConsumer(0L, this);, +                if (task.replace(consumer)) {, +                    firstTimeoutIndicator.subscribe(consumer);, +                }, +            if (getAndSet(Long.MAX_VALUE) != Long.MAX_VALUE) {, +                task.dispose();, +, +            } else {, +                RxJavaPlugins.onError(t);, +            }, +            if (getAndSet(Long.MAX_VALUE) != Long.MAX_VALUE) {, +                task.dispose();, +, +        public void onTimeout(long idx) {, +            if (compareAndSet(idx, Long.MAX_VALUE)) {, +                DisposableHelper.dispose(upstream);, +        public void onTimeoutError(long idx, Throwable ex) {, +            if (compareAndSet(idx, Long.MAX_VALUE)) {, +                DisposableHelper.dispose(upstream);, +                actual.onError(ex);, +                RxJavaPlugins.onError(ex);, +            DisposableHelper.dispose(upstream);, +            task.dispose();, +            return DisposableHelper.isDisposed(upstream.get());, +        }, +    }, +, +    static final class TimeoutFallbackObserver<T>, +    extends AtomicReference<Disposable>, +    implements Observer<T>, Disposable, TimeoutSelectorSupport {, +, +        private static final long serialVersionUID = -7508389464265974549L;, +, +        final Observer<? super T> actual;, +, +        final Function<? super T, ? extends ObservableSource<?>> itemTimeoutIndicator;, +, +        final SequentialDisposable task;, +, +        final AtomicLong index;, +, +        final AtomicReference<Disposable> upstream;]