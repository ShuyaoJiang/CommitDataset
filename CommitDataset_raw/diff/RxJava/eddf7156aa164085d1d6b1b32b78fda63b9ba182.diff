[+++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java, +    /* public: test support. */, +    public static final class ExecutorWorker extends Scheduler.Worker implements Runnable {, +        final SetCompositeResource<Disposable> tasks = new SetCompositeResource<>(Disposable::dispose);, +        , +            ScheduledRunnable sr = new ScheduledRunnable(() -> {, +                mar.setResource(schedule(decoratedRun));, +            }, tasks);, +            tasks.add(sr);, +                    Future<?> f = ((ScheduledExecutorService)executor).schedule(sr, delay, unit);, +                    sr.setFuture(f);, +                Disposable d = HELPER.scheduleDirect(sr, delay, unit);, +                sr.setFuture(new Future<Object>() {, +                    @Override, +                    public boolean cancel(boolean mayInterruptIfRunning) {, +                        d.dispose();, +                        return false;, +                    @Override, +                    public boolean isCancelled() {, +                        return false;, +                    }, +, +                    @Override, +                    public boolean isDone() {, +                        return false;, +                    }, +, +                    @Override, +                    public Object get() throws InterruptedException, ExecutionException {, +                        return null;, +                    }, +, +                    @Override, +                    public Object get(long timeout, TimeUnit unit), +                            throws InterruptedException, ExecutionException, TimeoutException {, +                        return null;, +                    }, +                    , +                });, +            }, +            , +            first.setResource(sr);, +                tasks.dispose();, +++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java, +    /* public: test support. */, +    public static final class ExecutorWorker extends Scheduler.Worker implements Runnable {, +        final SetCompositeResource<Disposable> tasks = new SetCompositeResource<>(Disposable::dispose);, +        , +            ScheduledRunnable sr = new ScheduledRunnable(() -> {, +                mar.setResource(schedule(decoratedRun));, +            }, tasks);, +            tasks.add(sr);, +                    Future<?> f = ((ScheduledExecutorService)executor).schedule(sr, delay, unit);, +                    sr.setFuture(f);, +                Disposable d = HELPER.scheduleDirect(sr, delay, unit);, +                sr.setFuture(new Future<Object>() {, +                    @Override, +                    public boolean cancel(boolean mayInterruptIfRunning) {, +                        d.dispose();, +                        return false;, +                    @Override, +                    public boolean isCancelled() {, +                        return false;, +                    }, +, +                    @Override, +                    public boolean isDone() {, +                        return false;, +                    }, +, +                    @Override, +                    public Object get() throws InterruptedException, ExecutionException {, +                        return null;, +                    }, +, +                    @Override, +                    public Object get(long timeout, TimeUnit unit), +                            throws InterruptedException, ExecutionException, TimeoutException {, +                        return null;, +                    }, +                    , +                });, +            }, +            , +            first.setResource(sr);, +                tasks.dispose();, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +    , +    public static void shutdown() {, +        computation().shutdown();, +        io().shutdown();, +        newThread().shutdown();, +        single().shutdown();, +        trampoline().shutdown();, +    }, +    , +    public static void start() {, +        computation().start();, +        io().start();, +        newThread().start();]