[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   *            the `rx.lang.scala.subjects.Subject` to push source items into. Note: this is a by-name parameter., +  def multicast[R >: T](subject: => rx.lang.scala.Subject[R]): ConnectableObservable[R] = {, +    val f = new rx.functions.Func0[rx.subjects.Subject[_ >: R, _ <: R]]() {, +      override def call(): rx.subjects.Subject[_ >: R, _ <: R] = subject.asJavaSubject, +    }, +    val thisJava: rx.Observable[_ <: R] = asJavaObservable, +    new ConnectableObservable[R](thisJava.multicast[R](f)), +   * {@code onError}. An {@code onError} notification from the source will result in the emission of a, +   * {@link Notification} to the Observable provided as an argument to the {@code notificationHandler}, +   * function. If the Observable returned {@code onCompletes} or {@code onErrors} then {@code retry} will call, +   * {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will, +   * <pre> {@code, +   * } </pre>, +   * <pre> {@code, +   * } </pre>, +   *  <dd>{@code retryWhen} operates by default on the {@code trampoline} {@link Scheduler}.</dd>, +   * Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}., +   * An onError will emit a {@link Notification} to the observable provided as an argument to the notificationHandler, +   * func. If the observable returned {@code onCompletes} or {@code onErrors} then retry will call {@code onCompleted}, +   * or {@code onError} on the child subscription. Otherwise, this observable will resubscribe to the source observable, on a particular Scheduler., +   *  <dd>you specify which {@link Scheduler} this operator will use</dd>, +   * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of, +   * a {@link Notification} to the Observable provided as an argument to the {@code notificationHandler}, +   * function. If the Observable returned {@code onCompletes} or {@code onErrors} then {@code repeatWhen} will, +   * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will, +   *  <dd>you specify which {@link Scheduler} this operator will use</dd>, +   * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of, +   * a {@link Notification} to the Observable provided as an argument to the {@code notificationHandler}, +   * function. If the Observable returned {@code onCompletes} or {@code onErrors} then {@code repeatWhen} will, +   * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will, +   *  <dd>{@code repeatWhen} operates by default on the {@code trampoline} {@link Scheduler}.</dd>, +   * source Observable, mapped by the keys returned by a specified {@code keySelector} function., +   * Return an Observable that emits a single Map, returned by a specified {@code mapFactory} function, that, +   * Lift a function to the current Observable and return a new Observable that when subscribed to will pass, +   * the values of the current Observable through the function., +   * observable.map(...).filter(...).take(5).lift(new ObserverA()).lift(new ObserverB(...)).subscribe(), +   * @param operator, +   * @return an Observable that emits values that are the result of applying the bind function to the values, +   *         of the current Observable, +   * Return an Observable that emits a 0L after the {@code initialDelay} and ever increasing, +   * numbers after each {@code period} of time thereafter, on a specified Scheduler., +   * @return an Observable that emits a 0L after the { @code initialDelay} and ever increasing, +   *                                                         numbers after each { @code period} of time thereafter, while running on the given { @code scheduler}, +   * Return an Observable that emits a 0L after the {@code initialDelay} and ever increasing, +   * numbers after each {@code period} of time thereafter, on a specified Scheduler., +   * @return an Observable that emits a 0L after the { @code initialDelay} and ever increasing, +   *                                                         numbers after each { @code period} of time thereafter, while running on the given { @code scheduler}]