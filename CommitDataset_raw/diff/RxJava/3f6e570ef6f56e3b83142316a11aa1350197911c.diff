[+++ b/src/main/java/io/reactivex/annotations/SchedulerSupport.java, +    /**, +     * The operator/class runs on RxJava's {@linkplain Schedulers#single() single scheduler}, +     * or takes timing information from it., +     * @since 2.0.8 - experimental, +     */, +    @Experimental, +    String SINGLE = "io.reactivex:single";, +++ b/src/main/java/io/reactivex/annotations/SchedulerSupport.java, +    /**, +     * The operator/class runs on RxJava's {@linkplain Schedulers#single() single scheduler}, +     * or takes timing information from it., +     * @since 2.0.8 - experimental, +     */, +    @Experimental, +    String SINGLE = "io.reactivex:single";, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, + * The initial and runtime values of the various scheduler types can be overridden via the, + * {@code RxJavaPlugins.setInit(scheduler name)SchedulerHandler()} and, + * {@code RxJavaPlugins.set(scheduler name)SchedulerHandler()} respectively., + * <p>, +     * Returns a default, shared {@link Scheduler} instance intended for computational work., +     * It is not recommended to perform blocking, IO-bound work on this scheduler. Use {@link #io()} instead., +     * <p>, +     * The default instance has a backing pool of single-threaded {@link ScheduledExecutorService} instances equal to, +     * the number of available processors ({@link java.lang.Runtime#availableProcessors()}) to the Java VM., +     * <p>, +     * This type of scheduler is less sensitive to leaking {@link io.reactivex.Scheduler.Worker} instances, although, +     * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or, +     * execute those tasks "unexpectedly"., +     * <p>, +     * If the {@link RxJavaPlugins#setFailOnNonBlockingScheduler(boolean)} is set to true, attempting to execute, +     * operators that block while running on this scheduler will throw an {@link IllegalStateException}., +     * <p>, +     * You can control certain properties of this standard scheduler via system properties that have to be set, +     * before the {@link Schedulers} class is referenced in your code., +     * <br><strong>Supported system properties ({@code System.getProperty()}):</strong>, +     * <ul>, +     * <li>{@code rx2.computation-threads} (int): sets the number of threads in the {@link #computation()} Scheduler, default is the number of available CPUs</li>, +     * <li>{@code rx2.computation-priority} (int): sets the thread priority of the {@link #computation()} Scheduler, default is {@link Thread#NORM_PRIORITY}</li>, +     * </ul>, +     * <p>, +     * The default value of this scheduler can be overridden at initialization time via the , +     * {@link RxJavaPlugins#setInitComputationSchedulerHandler(io.reactivex.functions.Function)} plugin method., +     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will, +     * result in a {@code NullPointerException}., +     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance, +     * via the {@link RxJavaPlugins#setComputationSchedulerHandler(io.reactivex.functions.Function)} method., +     * <p>, +     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the, +     * {@link RxJavaPlugins#createComputationScheduler(ThreadFactory)} method. Note that such custom, +     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the, +     * (J2EE) container to unload properly., +     * <p>Operators on the base reactive classes that use this scheduler are marked with the, +     * &#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#COMPUTATION COMPUTATION}), +     * annotation., +     * Returns a default, shared {@link Scheduler} instance intended for IO-bound work., +     * The implementation is backed by a pool of single-threaded {link ScheduledExecutorService} instances, +     * that will try to reuse previoulsy started instances used by the worker, +     * returned by {@link io.reactivex.Scheduler#createWorker()} but otherwise will start a new backing, +     * {link ScheduledExecutorService} instance. Note that this scheduler may create an unbounded number, +     * of worker threads that can result in system slowdowns or {@code OutOfMemoryError}. Therefore, for casual uses , +     * or when implementing an operator, the Worker instances must be disposed via {@link io.reactivex.Scheduler.Worker#dispose()}., +     * <p>, +     * It is not recommended to perform computational work on this scheduler. Use {@link #computation()} instead., +     * <p>, +     * You can control certain properties of this standard scheduler via system properties that have to be set, +     * before the {@link Schedulers} class is referenced in your code., +     * <br><strong>Supported system properties ({@code System.getProperty()}):</strong>, +     * <ul>, +     * <li>{@code rx2.io-priority} (int): sets the thread priority of the {@link #io()} Scheduler, default is {@link Thread#NORM_PRIORITY}</li>, +     * </ul>, +     * <p>, +     * The default value of this scheduler can be overridden at initialization time via the , +     * {@link RxJavaPlugins#setInitIoSchedulerHandler(io.reactivex.functions.Function)} plugin method., +     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will, +     * result in a {@code NullPointerException}., +     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance, +     * via the {@link RxJavaPlugins#setIoSchedulerHandler(io.reactivex.functions.Function)} method., +     * <p>, +     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the, +     * {@link RxJavaPlugins#createIoScheduler(ThreadFactory)} method. Note that such custom, +     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the, +     * (J2EE) container to unload properly., +     * <p>Operators on the base reactive classes that use this scheduler are marked with the, +     * &#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#IO IO}), +     * annotation., +     * Returns a default, shared {@link Scheduler} instance whose {@link io.reactivex.Scheduler.Worker}, +     * instances queue work and execute them in a FIFO manner on one of the participating threads., +     * <p>, +     * The default implementation's {@link Scheduler#scheduleDirect(Runnable)} methods execute the tasks on the current thread, +     * without any queueing and the timed overloads use blocking sleep as well., +     * <p>, +     * Note that this scheduler can't be reliably used to return the execution of, +     * tasks to the "main" thread. Such behavior requires a blocking-queueing scheduler currently not provided, +     * by RxJava itself but may be found in external libraries., +     * <p>, +     * This scheduler can't be overridden via an {@link RxJavaPlugins} method., +     * Returns a default, shared {@link Scheduler} instance that creates a new {@link Thread} for each unit of work., +     * <p>]