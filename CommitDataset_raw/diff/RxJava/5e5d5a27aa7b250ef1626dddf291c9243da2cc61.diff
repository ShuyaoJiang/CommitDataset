[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +        final void trimHead() {, +            Node head = get();, +            if (head.value != null) {, +                Node n = new Node(null, 0L);, +                n.lazySet(head.get());, +                set(n);, +            }, +        }, +, +            trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +        final void trimHead() {, +            Node head = get();, +            if (head.value != null) {, +                Node n = new Node(null, 0L);, +                n.lazySet(head.get());, +                set(n);, +            }, +        }, +, +            trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +, +        final void trimHead() {, +            Node head = get();, +            if (head.value != null) {, +                Node n = new Node(null);, +                n.lazySet(head.get());, +                set(n);, +            }, +        }, +, +            trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, +        final void trimHead() {, +            Node head = get();, +            if (head.value != null) {, +                Node n = new Node(null, 0L);, +                n.lazySet(head.get());, +                set(n);, +            }, +        }, +, +            trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +, +        final void trimHead() {, +            Node head = get();, +            if (head.value != null) {, +                Node n = new Node(null);, +                n.lazySet(head.get());, +                set(n);, +            }, +        }, +, +            trimHead();, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.*;, +     * Makes sure the item cached by the head node in a bounded, +     * ReplayProcessor is released (as it is never part of a replay)., +     * <p>, +     * By default, live bounded buffers will remember one item before, +     * the currently receivable one to ensure subscribers can always, +     * receive a continuous sequence of items. A terminated ReplayProcessor, +     * automatically releases this inaccessible item., +     * <p>, +     * The method must be called sequentially, similar to the standard, +     * {@code onXXX} methods., +     * @since 2.1.11 - experimental, +     */, +    @Experimental, +    public void cleanupBuffer() {, +        buffer.trimHead();, +    }, +, +    /**, +, +        /**, +         * Make sure an old inaccessible head value is released, +         * in a bounded buffer., +         */, +        void trimHead();, +        public void trimHead() {, +            // not applicable for an unbounded buffer, +        }, +, +        @Override, +            trimHead();, +            trimHead();, +        public void trimHead() {, +            if (head.value != null) {, +                Node<T> n = new Node<T>(null);, +                n.lazySet(head.get());, +                head = n;, +            }, +        }, +, +        @Override, +                    if (h.value != null) {]