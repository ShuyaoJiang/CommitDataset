[+++ b/rxjava-core/src/main/java/rx/Observable.java, +     *             if {@code count} is less than zero, or if {@code start} + {@code count} - 1 exceeds {@code Integer.MAX_VALUE}, +        if (count == 0) {, +            return Observable.empty();, +        }, +        if (start > Integer.MAX_VALUE - count + 1) {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     *             if {@code count} is less than zero, or if {@code start} + {@code count} - 1 exceeds {@code Integer.MAX_VALUE}, +        if (count == 0) {, +            return Observable.empty();, +        }, +        if (start > Integer.MAX_VALUE - count + 1) {, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +     *             if {@code count} is less than zero, or if {@code start} + {@code count} - 1 exceeds {@code Integer.MAX_VALUE}, +        if (count == 0) {, +            return Observable.empty();, +        }, +        if (start > Integer.MAX_VALUE - count + 1) {, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/schedulers/ExecutorScheduler.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +package rx.schedulers;, +, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.Executor;, +import java.util.concurrent.Future;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +import rx.Scheduler;, +import rx.Subscription;, +import rx.functions.Action0;, +import rx.plugins.RxJavaPlugins;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.MultipleAssignmentSubscription;, +import rx.subscriptions.Subscriptions;, +, +/**, + * Scheduler that wraps an Executor instance and establishes the Scheduler contract upon it., + * <p>, + * Note that thread-hopping is unavoidable with this kind of Scheduler as we don't know, + * about the underlying threading behavior of the executor., + */, +/* public */final class ExecutorScheduler extends Scheduler {, +    final Executor executor;, +    public ExecutorScheduler(Executor executor) {, +        this.executor = executor;, +    }, +    @Override, +    public Worker createWorker() {, +        return new ExecutorSchedulerWorker(executor);, +    }, +    /** Worker that schedules tasks on the executor indirectly through a trampoline mechanism. */, +    static final class ExecutorSchedulerWorker extends Scheduler.Worker implements Runnable {, +        final Executor executor;, +        // TODO: use a better performing structure for task tracking, +        final CompositeSubscription tasks;, +        // TODO: use MpscLinkedQueue once available, +        final ConcurrentLinkedQueue<ExecutorAction> queue; , +        final AtomicInteger wip;, +        , +        public ExecutorSchedulerWorker(Executor executor) {, +            this.executor = executor;, +            this.queue = new ConcurrentLinkedQueue<ExecutorAction>();, +            this.wip = new AtomicInteger();, +            this.tasks = new CompositeSubscription();, +        }, +, +        @Override, +        public Subscription schedule(Action0 action) {, +            if (isUnsubscribed()) {, +                return Subscriptions.empty();, +            }, +            ExecutorAction ea = new ExecutorAction(action, tasks);, +            tasks.add(ea);, +            queue.offer(ea);, +            if (wip.getAndIncrement() == 0) {, +                try {, +                    executor.execute(this);, +                } catch (RejectedExecutionException t) {, +                    // cleanup if rejected, +                    tasks.remove(ea);, +                    wip.decrementAndGet();]