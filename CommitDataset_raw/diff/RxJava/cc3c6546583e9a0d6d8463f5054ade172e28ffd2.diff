[+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +    final AtomicInteger received = new AtomicInteger();, +    final AtomicInteger counter = new AtomicInteger();, +    final AtomicInteger offered = new AtomicInteger();, +    static AtomicInteger decremented = new AtomicInteger();, +, +    AtomicInteger conc = new AtomicInteger();, +    AtomicInteger lost = new AtomicInteger();, +    Set<Object> items = Collections.synchronizedSet(new HashSet<Object>());, +, +, +        int contention = 0;, +        State orig = null;, +            if (orig == null) {, +                orig = current;, +            }, +            contention++;, +        do {, +            current = state.get();, +            newState = current.startProcessing();, +        } while (!state.compareAndSet(current, newState));, +            // drain queue , +                counter.incrementAndGet();, +                newState = current.finishProcessing(items.length);, +, +        terminateIfNecessary(newState);, +, +        private final static Object[] PROCESS_SELF = new Object[1];, +            return new State(false, isSomeoneProcessing, 0, onComplete, e, EMPTY);, +                return new State(true, true, queueSize, onComplete, onError, queue);, +                return new State(false, isSomeoneProcessing, 0, onComplete, onError, EMPTY);, +, +        public State startProcessing() {, +            if (isSomeoneProcessing) {, +                return new State(false, true, queueSize, onComplete, onError, queue);, +            } else {, +                return new State(true, true, queueSize, onComplete, onError, queue);, +            }, +            int size = queueSize - numOnNextSent;, +            if (size > 0 || isTerminated()) {, +                // if size == 0 but we are terminated then it's an empty queue, +                Object[] newQueue = EMPTY;, +                if (size > 0) {, +                    newQueue = new Object[queue.length - numOnNextSent];, +                    System.arraycopy(queue, numOnNextSent, newQueue, 0, newQueue.length);, +                }, +        @Override, +        public String toString() {, +            return "State => shouldProcess: " + shouldProcess + " processing: " + isSomeoneProcessing + " queueSize: " + queueSize + " queue: " + queue.length + " terminated: " + isTerminated();, +        }, +, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +    final AtomicInteger received = new AtomicInteger();, +    final AtomicInteger counter = new AtomicInteger();, +    final AtomicInteger offered = new AtomicInteger();, +    static AtomicInteger decremented = new AtomicInteger();, +, +    AtomicInteger conc = new AtomicInteger();, +    AtomicInteger lost = new AtomicInteger();, +    Set<Object> items = Collections.synchronizedSet(new HashSet<Object>());, +, +, +        int contention = 0;, +        State orig = null;, +            if (orig == null) {, +                orig = current;, +            }, +            contention++;, +        do {, +            current = state.get();, +            newState = current.startProcessing();, +        } while (!state.compareAndSet(current, newState));, +            // drain queue , +                counter.incrementAndGet();, +                newState = current.finishProcessing(items.length);, +, +        terminateIfNecessary(newState);, +, +        private final static Object[] PROCESS_SELF = new Object[1];, +            return new State(false, isSomeoneProcessing, 0, onComplete, e, EMPTY);, +                return new State(true, true, queueSize, onComplete, onError, queue);, +                return new State(false, isSomeoneProcessing, 0, onComplete, onError, EMPTY);, +, +        public State startProcessing() {, +            if (isSomeoneProcessing) {, +                return new State(false, true, queueSize, onComplete, onError, queue);, +            } else {, +                return new State(true, true, queueSize, onComplete, onError, queue);, +            }, +            int size = queueSize - numOnNextSent;, +            if (size > 0 || isTerminated()) {, +                // if size == 0 but we are terminated then it's an empty queue, +                Object[] newQueue = EMPTY;, +                if (size > 0) {]