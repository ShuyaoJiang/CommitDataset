[+++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, +import java.util.concurrent.atomic.AtomicReference;, +, +public final class ToNotificationObserver<T>, +extends AtomicReference<Disposable>, +implements Observer<T>, Disposable {, +    private static final long serialVersionUID = -7420197867343208289L;, +    final Consumer<? super Notification<Object>> consumer;, +        DisposableHelper.setOnce(this, s);, +            get().dispose();, +                get().dispose();, +, +    @Override, +    public void dispose() {, +        DisposableHelper.dispose(this);, +    }, +, +    @Override, +    public boolean isDisposed() {, +        return DisposableHelper.isDisposed(get());, +    }, +++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, +import java.util.concurrent.atomic.AtomicReference;, +, +public final class ToNotificationObserver<T>, +extends AtomicReference<Disposable>, +implements Observer<T>, Disposable {, +    private static final long serialVersionUID = -7420197867343208289L;, +    final Consumer<? super Notification<Object>> consumer;, +        DisposableHelper.setOnce(this, s);, +            get().dispose();, +                get().dispose();, +, +    @Override, +    public void dispose() {, +        DisposableHelper.dispose(this);, +    }, +, +    @Override, +    public boolean isDisposed() {, +        return DisposableHelper.isDisposed(get());, +    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java, +import io.reactivex.internal.disposables.*;, +        ToNotificationObserver<Object> actionObserver = new ToNotificationObserver<Object>(new Consumer<Notification<Object>>() {, +            @Override, +            public void accept(Notification<Object> o) {, +                parent.handle(o);, +            }, +        });, +        ListCompositeDisposable cd = new ListCompositeDisposable(parent.arbiter, actionObserver);, +        s.onSubscribe(cd);, +        action.subscribe(actionObserver);, +++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, +import java.util.concurrent.atomic.AtomicReference;, +, +public final class ToNotificationObserver<T>, +extends AtomicReference<Disposable>, +implements Observer<T>, Disposable {, +    private static final long serialVersionUID = -7420197867343208289L;, +    final Consumer<? super Notification<Object>> consumer;, +        DisposableHelper.setOnce(this, s);, +            get().dispose();, +                get().dispose();, +, +    @Override, +    public void dispose() {, +        DisposableHelper.dispose(this);, +    }, +, +    @Override, +    public boolean isDisposed() {, +        return DisposableHelper.isDisposed(get());, +    }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java, +import io.reactivex.internal.disposables.*;, +        ToNotificationObserver<Object> actionObserver = new ToNotificationObserver<Object>(new Consumer<Notification<Object>>() {, +            @Override, +            public void accept(Notification<Object> o) {, +                parent.handle(o);, +            }, +        });, +        ListCompositeDisposable cd = new ListCompositeDisposable(parent.arbiter, actionObserver);, +        s.onSubscribe(cd);, +        action.subscribe(actionObserver);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.processors.PublishProcessor;, +    @Test, +    public void shouldDisposeInnerObservable() {, +      final PublishProcessor<Object> subject = PublishProcessor.create();, +      final Disposable disposable = Flowable.just("Leak"), +          .repeatWhen(new Function<Flowable<Object>, Flowable<Object>>() {, +            @Override, +            public Flowable<Object> apply(Flowable<Object> completions) throws Exception {, +                return completions.switchMap(new Function<Object, Flowable<Object>>() {, +                    @Override, +                    public Flowable<Object> apply(Object ignore) throws Exception {, +                        return subject;, +                    }]