[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.subjects.ReplaySubject;, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications., +     * , +     * @param that, +     *            the source Observable, +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public static <T> ConnectableObservable<T> replay(final Observable<T> that) {, +        return OperationMulticast.multicast(that, ReplaySubject.<T> create());, +    }, +, +    /**, +     * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications., +     * , +     * @return a connectable observable sequence that upon connection causes the source sequence to push results into the specified subject., +     */, +    public ConnectableObservable<T> replay() {, +        return replay(this);, +    }, +, +    /**, +        return publish(this);, +                            counter.incrementAndGet();, +        @Test, +        public void testReplay() throws InterruptedException {, +            final AtomicInteger counter = new AtomicInteger();, +            ConnectableObservable<String> o = Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(final Observer<String> observer) {, +                    final BooleanSubscription subscription = new BooleanSubscription();, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +                            System.out.println("published observable being executed");, +                            observer.onNext("one");, +                            observer.onCompleted();, +                            counter.incrementAndGet();, +                        }, +                    }).start();, +                    return subscription;, +                }, +            }).replay();, +, +            // we connect immediately and it will emit the value, +            Subscription s = o.connect();, +            try {, +, +                // we then expect the following 2 subscriptions to get that same value, +                final CountDownLatch latch = new CountDownLatch(2);, +, +                // subscribe once, +                o.subscribe(new Action1<String>() {, +, +                    @Override, +                    public void call(String v) {, +                        assertEquals("one", v);, +                        System.out.println("v: " + v);, +                        latch.countDown();, +                    }, +                });, +, +                // subscribe again, +                o.subscribe(new Action1<String>() {, +, +                    @Override, +                    public void call(String v) {, +                        assertEquals("one", v);, +                        System.out.println("v: " + v);, +                        latch.countDown();, +                    }, +                });, +, +                if (!latch.await(1000, TimeUnit.MILLISECONDS)) {, +                    fail("subscriptions did not receive values");, +                }, +                assertEquals(1, counter.get());, +            } finally {, +                s.unsubscribe();, +            }, +        }, +]