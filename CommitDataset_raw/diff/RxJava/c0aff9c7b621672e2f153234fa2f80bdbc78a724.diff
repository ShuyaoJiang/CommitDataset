[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java, +import io.reactivex.processors.*;, +        FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();, +        final FlowProcessor<Try<Optional<Object>>> subject;, +        public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java, +import io.reactivex.processors.*;, +        FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();, +        final FlowProcessor<Try<Optional<Object>>> subject;, +        public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {, +++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java, +            , +            if (decrementAndGet() != 0) {, +                drainLoop();, +            }, +, +, +                if (decrementAndGet() != 0) {, +                    drainLoop();, +                }, +, +        long requestAmount = 0L;, +        Subscription requestTarget = null;, +        , +                        requestAmount = BackpressureHelper.addCap(requestAmount, r);, +                        requestTarget = ms;, +                } else if (a != null && mr != 0L) {, +                    requestAmount = BackpressureHelper.addCap(requestAmount, mr);, +                    requestTarget = a;, +                if (requestAmount != 0L) {, +                    requestTarget.request(requestAmount);, +                }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java, +import io.reactivex.processors.*;, +        FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();, +        final FlowProcessor<Try<Optional<Object>>> subject;, +        public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {, +++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java, +            , +            if (decrementAndGet() != 0) {, +                drainLoop();, +            }, +, +, +                if (decrementAndGet() != 0) {, +                    drainLoop();, +                }, +, +        long requestAmount = 0L;, +        Subscription requestTarget = null;, +        , +                        requestAmount = BackpressureHelper.addCap(requestAmount, r);, +                        requestTarget = ms;, +                } else if (a != null && mr != 0L) {, +                    requestAmount = BackpressureHelper.addCap(requestAmount, mr);, +                    requestTarget = a;, +                if (requestAmount != 0L) {, +                    requestTarget.request(requestAmount);, +                }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, +    , +    static final class InfiniteIterator implements Iterator<Integer>, Iterable<Integer> {, +, +        int count;, +        , +        @Override, +        public boolean hasNext() {, +            return true;, +        }, +, +        @Override, +        public Integer next() {, +            return count++;, +        }, +        , +        @Override, +        public void remove() {, +        }, +        , +        @Override, +        public Iterator<Integer> iterator() {, +            return this;, +        }, +    }, +    , +    @Test(timeout = 5000), +    public void veryLongTake() {, +        Flowable.fromIterable(new InfiniteIterator()).concatWith(Flowable.<Integer>empty()).take(10), +        .test(), +        .assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);, +    }]