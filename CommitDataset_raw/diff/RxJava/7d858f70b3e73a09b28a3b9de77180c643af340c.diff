[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object that takes an `rx.Observer` private to the Scala bindings package., +, +```scala, +trait Observer[-T] {, +  private [scala] def asJavaObserver: rx.Observer[_ >: T], +, +  def onNext(value: T): Unit, +  def onError(error: Throwable): Unit, +  def onCompleted(): Unit, +}, +, +object Observer {...}, +```, +, +To create an instance of say `Observer[SensorEvent]` in user code, you can create a new instance of the `Observer` trait, +and implement any of the methods that you care about:, +```scala, +   val printObserver = new Observer[SensorEvent] {, +      override def onNext(value: SensorEvent): Unit = {...value.toString...}, +      override def onError(error: Throwable): Unit = {...}, +      override def onCompleted(): Unit = {...}, +   }, +```, + or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,, + `onError` or `onCompleted` methods., +, +Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`, +(for instance `subscribe`) usually come with overloads that accept the individual methods, +`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers., +, +While *technically* it is a breaking change make the `asJavaObserver` property, +private, you should probably not have touched `asJavaObserver` in the first place., +, +Observable, +----------, +, +Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor, +function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public)., +Again, while *technically* this is a breaking change, this should not have any influence on user code., +, +```scala, +trait Observable[+T] {, +   private [scala] val asJavaObservable: rx.Observable[_ <: T], +}, +, +object Observable {, +   private [scala] def apply[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}, +}, +```, +, +The major changes in `Observable` are wrt to the factory methods *Can't write this when I don't have Samuel's changes*., +, +Subject, +-------, +, +The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`, +and takes only a single *invariant* type parameter `T`. all existing implementations of `Subject` are parametrized, +by a single type, and this reflects that reality., +, +```scala, +trait Subject[T] extends Observable[T] with Observer[T] {, +  private [scala] val asJavaSubject: rx.subjects.Subject[_ >: T, _<: T], +}, +```, +For each kind of subject, there is a pair of a companion object and a class with a private constructor:, +, +```scala, +object XXXSubject {, +  def apply[T](...): XXXSubject[T] = {, +    new XXXSubject[T](... create corresponding rx subject ...), +  }, +}, +, +class XXXSubject[T] private[scala] (val asJavaSubject: rx.subjects.XXXSubject[T]) extends Subject[T,T] {}, +```, +, +The subjects that are available are:, +, +* `AsyncSubject[T]()`, +* `BehaviorSubject[T](value)`, +* `Subject[T]()`, +* `ReplaySubject[T]()`, +]