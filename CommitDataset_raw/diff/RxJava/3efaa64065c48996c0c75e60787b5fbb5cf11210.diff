[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/src/main/java/rx/observables/StringObservable.java, +package rx.observables;, +, +import java.nio.ByteBuffer;, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.Charset;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CharsetEncoder;, +import java.nio.charset.CoderResult;, +import java.nio.charset.CodingErrorAction;, +import java.util.Arrays;, +import java.util.regex.Pattern;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.Observable.OnSubscribeFunc;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, +, +public class StringObservable {, +    /**, +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams and where handles when a multibyte character spans two chunks., +     * , +     * @param src, +     * @param charsetName, +     * @return, +     */, +    public static Observable<String> decode(Observable<byte[]> src, String charsetName) {, +        return decode(src, Charset.forName(charsetName));, +    }, +, +    /**, +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams and where handles when a multibyte character spans two chunks., +     * , +     * @param src, +     * @param charset, +     * @return, +     */, +    public static Observable<String> decode(Observable<byte[]> src, Charset charset) {, +        return decode(src, charset.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE));, +    }, +, +    /**, +     * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams and where handles when a multibyte character spans two chunks., +     * This method allows for more control over how malformed and unmappable characters are handled., +     * , +     * @param src, +     * @param charsetDecoder, +     * @return, +     */, +    public static Observable<String> decode(final Observable<byte[]> src, final CharsetDecoder charsetDecoder) {, +        return Observable.create(new OnSubscribeFunc<String>() {, +            @Override, +            public Subscription onSubscribe(final Observer<? super String> observer) {, +                return src.subscribe(new Observer<byte[]>() {, +                    private ByteBuffer leftOver = null;, +, +                    @Override, +                    public void onCompleted() {, +                        if (process(null, leftOver, true)), +                            observer.onCompleted();, +                    }, +, +                    @Override, +                    public void onError(Throwable e) {, +                        if (process(null, leftOver, true)), +                            observer.onError(e);, +                    }, +, +                    @Override, +                    public void onNext(byte[] bytes) {, +                        process(bytes, leftOver, false);, +                    }, +, +                    public boolean process(byte[] next, ByteBuffer last, boolean endOfInput) {, +                        ByteBuffer bb;, +                        if (last != null) {, +                            if (next != null) {, +                                // merge leftover in front of the next bytes, +                                bb = ByteBuffer.allocate(last.remaining() + next.length);, +                                bb.put(last);, +                                bb.put(next);, +                                bb.flip();, +                            }, +                            else { // next == null, +                                bb = last;, +                            }, +                        }, +                        else { // last == null, +                            if (next != null) {, +                                bb = ByteBuffer.wrap(next);, +                            }, +                            else { // next == null, +                                return true;, +                            }, +                        }]