[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * [[Observable.serialize serialize]] enforces this, and the Observable it returns invokes `onNext` and `onCompleted` or `onError` synchronously., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * [[Observable.serialize serialize]] enforces this, and the Observable it returns invokes `onNext` and `onCompleted` or `onError` synchronously., +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +      "contains(Any)" -> "contains(U)",, +      "elementAtOrDefault(Int, T)" -> "elementAtOrDefault(Int, U)",, +      "firstOrDefault(T, Func1[_ >: T, Boolean])" -> "[use `.filter(condition).firstOrElse(default)`]",, +      "repeat()" -> "repeat()",, +      "subscribe()" -> "subscribe()",, +      "takeFirst(Func1[_ >: T, Boolean])" -> "[use `filter(condition).take(1)`]",, +      "from(Array[T])" -> "[use apply(T*)]",, +      "from(Iterable[_ <: T])" -> "from(Iterable[T])",, +      "just(T)" -> "[use apply(T*)]",, +      "just(T, Scheduler)" -> "[use apply(T*).subscribeOn(scheduler)]",, +      "from(" + _ + ")" -> "[use apply(T*)]", +    // `access$000` is public. How to distinguish it from others without hard-code?, +    .filter(! _.contains("access$000")), +---, +layout: comparison, +title: Comparison of Scala Observable and Java Observable, +---]