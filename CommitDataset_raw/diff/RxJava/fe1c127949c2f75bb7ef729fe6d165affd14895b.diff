[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable, or, +   * a default value if the source Observable is empty., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">, +   *, +   * @param defaultValue, +   *            The default value to emit if the source Observable doesn't emit anything., +   *            This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything., +   * @return an Observable that emits only the very first item from the source, or a default value, +   *         if the source Observable completes without emitting any item., +    this.take(1).fold[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for {@code take(1)}., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">, +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = {, +    take(1), +  def apply[T](exception: Throwable): Observable[T] = {, +    Observable[T](JObservable.error(exception)), +  // Test that Java's firstOrDefault propagates errors., +  // If this changes (i.e. it suppresses errors and returns default) then Scala's firstOrElse, +  // should be changed accordingly., +  @Test def testJavaFirstOrDefault() {, +    assertEquals(1, rx.Observable.from(1, 2).firstOrDefault(10).toBlockingObservable().single), +    assertEquals(10, rx.Observable.empty().firstOrDefault(10).toBlockingObservable().single), +    val msg = "msg6251", +    var receivedMsg = "none", +    try {, +      rx.Observable.error(new Exception(msg)).firstOrDefault(10).toBlockingObservable().single, +    } catch {, +      case e: Exception => receivedMsg = e.getCause().getMessage(), +    }, +    assertEquals(receivedMsg, msg), +  }, +  , +  @Test def testFirstOrElse() {, +    def mustNotBeCalled: String = error("this method should not be called"), +    def mustBeCalled: String = "this is the default value", +    assertEquals("hello", Observable("hello").firstOrElse(mustNotBeCalled).toBlockingObservable.single), +    assertEquals("this is the default value", Observable().firstOrElse(mustBeCalled).toBlockingObservable.single), +  }, +  , +  @Test def testFirstOrElseWithError() {, +    val msg = "msg6251", +    var receivedMsg = "none", +    try {, +      Observable[Int](new Exception(msg)).firstOrElse(10).toBlockingObservable.single, +    } catch {, +      case e: Exception => receivedMsg = e.getCause().getMessage(), +    }, +    assertEquals(receivedMsg, msg), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Returns an Observable that emits only the very first item emitted by the source Observable, or, +   * a default value if the source Observable is empty., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">, +   *, +   * @param defaultValue, +   *            The default value to emit if the source Observable doesn't emit anything., +   *            This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything., +   * @return an Observable that emits only the very first item from the source, or a default value, +   *         if the source Observable completes without emitting any item., +    this.take(1).fold[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({, +      case Some(element) => element, +      case None => default, +   * Returns an Observable that emits only the very first item emitted by the source Observable., +   * This is just a shorthand for {@code take(1)}., +   * <p>, +   * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">, +   *, +   * @return an Observable that emits only the very first item from the source, or none if the, +   *         source Observable completes without emitting a single item., +  def first: Observable[T] = {, +    take(1), +  def apply[T](exception: Throwable): Observable[T] = {, +    Observable[T](JObservable.error(exception)), +  // Test that Java's firstOrDefault propagates errors., +  // If this changes (i.e. it suppresses errors and returns default) then Scala's firstOrElse, +  // should be changed accordingly., +  @Test def testJavaFirstOrDefault() {, +    assertEquals(1, rx.Observable.from(1, 2).firstOrDefault(10).toBlockingObservable().single), +    assertEquals(10, rx.Observable.empty().firstOrDefault(10).toBlockingObservable().single), +    val msg = "msg6251", +    var receivedMsg = "none", +    try {, +      rx.Observable.error(new Exception(msg)).firstOrDefault(10).toBlockingObservable().single, +    } catch {, +      case e: Exception => receivedMsg = e.getCause().getMessage(), +    }, +    assertEquals(receivedMsg, msg), +  }, +  , +  @Test def testFirstOrElse() {, +    def mustNotBeCalled: String = error("this method should not be called")]