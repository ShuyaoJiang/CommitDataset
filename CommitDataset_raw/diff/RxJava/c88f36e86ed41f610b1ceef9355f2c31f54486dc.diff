[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCombineLatest;, +     * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineFunction , +     *          The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +     */, +    public static <R, T0, T1> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Func2<? super T0, ? super T1, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));, +    }, +    , +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Func3<? super T0, ? super T1, ? super T2, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));, +    }, +, +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Observable<? super T3> w3, Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));, +    }, +    , +    /**, +     * Filters an Observable by discarding any of its emissions that do not meet some test., +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCombineLatest;, +     * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineFunction , +     *          The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +     */, +    public static <R, T0, T1> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Func2<? super T0, ? super T1, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));, +    }, +    , +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Func3<? super T0, ? super T1, ? super T2, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));, +    }, +, +    /**, +     * @see #combineLatest(Observable, Observable, Func2), +     */, +    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Observable<? super T3> w3, Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineFunction) {, +        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));, +    }, +    , +    /**, +     * Filters an Observable by discarding any of its emissions that do not meet some test., +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +import org.mockito.Matchers;, +     * Combines the two given observables, emitting an event containing an aggregation of the latest values of each of the source observables, +     * each time an event is received from one of the source observables, where the aggregation is defined by the given function., +     * @param w0 , +     *          The first source observable., +     * @param w1 , +     *          The second source observable., +     * @param combineLatestFunction , +     *          The aggregation function used to combine the source observable values., +     * @return A function from an observer to a subscription. This can be used to create an observable from., +    public static <T0, T1, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Func2<? super T0, ? super T1, ? extends R> combineLatestFunction) {, +    public static <T0, T1, T2, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Func3<? super T0, ? super T1, ? super T2, ? extends R> combineLatestFunction) {, +    public static <T0, T1, T2, T3, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Observable<? super T3> w3, Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineLatestFunction) {, +        final Observable<? super T> w;, +        final Aggregator<? super R> a;, +        public CombineObserver(Aggregator<? super R> a, Observable<? super T> w) {, +        private void startWatching() {, +    private static class Aggregator<R> implements Func1<Observer<? super R>, Subscription> {, +        private volatile Observer<? super R> observer;, +        private final FuncN<? extends R> combineLatestFunction;, +        // Stores how many observers have already completed, +        private final AtomicInteger numCompleted = new AtomicInteger(0);, +         * The latest value from each observer., +         */, +        private final Map<CombineObserver<? extends R, ?>, Object> latestValue = new ConcurrentHashMap<CombineObserver<? extends R, ?>, Object>();, +        public Aggregator(FuncN<? extends R> combineLatestFunction) {, +        <T> void complete(CombineObserver<? extends R, ? super T> w) {, +            int completed = numCompleted.incrementAndGet();, +            if (completed == observers.size()) {, +        <T> void next(CombineObserver<? extends R, ? super T> w, T arg) {, +            if (latestValue.size() < observers.size()) {, +            , +            Object[] argsToCombineLatest = new Object[observers.size()];]