[+++ b/src/main/java/io/reactivex/subscribers/SerializedSubscriber.java, +                done = true;, +++ b/src/main/java/io/reactivex/subscribers/SerializedSubscriber.java, +                done = true;, +++ b/src/test/java/io/reactivex/internal/operators/OperatorSerializeTest.java, +package io.reactivex.internal.operators;, +, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.junit.*;, +import org.reactivestreams.*;, +, +import io.reactivex.*;, +import io.reactivex.internal.subscriptions.EmptySubscription;, +, +public class OperatorSerializeTest {, +, +    Subscriber<String> observer;, +, +    @Before, +    public void before() {, +        observer = TestHelper.mockSubscriber();, +    }, +, +    @Test, +    public void testSingleThreadedBasic() {, +        TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable("one", "two", "three");, +        Observable<String> w = Observable.create(onSubscribe);, +, +        w.serialize().subscribe(observer);, +        onSubscribe.waitToFinish();, +, +        verify(observer, times(1)).onNext("one");, +        verify(observer, times(1)).onNext("two");, +        verify(observer, times(1)).onNext("three");, +        verify(observer, never()).onError(any(Throwable.class));, +        verify(observer, times(1)).onComplete();, +        // non-deterministic because unsubscribe happens after 'waitToFinish' releases, +        // so commenting out for now as this is not a critical thing to test here, +        //            verify(s, times(1)).unsubscribe();, +    }, +, +    @Test, +    public void testMultiThreadedBasic() {, +        TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable("one", "two", "three");, +        Observable<String> w = Observable.create(onSubscribe);, +, +        BusyObserver busyobserver = new BusyObserver();, +, +        w.serialize().subscribe(busyobserver);, +        onSubscribe.waitToFinish();, +, +        assertEquals(3, busyobserver.onNextCount.get());, +        assertFalse(busyobserver.onError);, +        assertTrue(busyobserver.onCompleted);, +        // non-deterministic because unsubscribe happens after 'waitToFinish' releases, +        // so commenting out for now as this is not a critical thing to test here, +        //            verify(s, times(1)).unsubscribe();, +, +        // we can have concurrency ..., +        assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);, +        // ... but the onNext execution should be single threaded, +        assertEquals(1, busyobserver.maxConcurrentThreads.get());, +    }, +, +    @Test, +    public void testMultiThreadedWithNPE() {, +        TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable("one", "two", "three", null);, +        Observable<String> w = Observable.create(onSubscribe);, +, +        BusyObserver busyobserver = new BusyObserver();, +, +        w.serialize().subscribe(busyobserver);, +        onSubscribe.waitToFinish();, +, +        System.out.println("maxConcurrentThreads: " + onSubscribe.maxConcurrentThreads.get());, +, +        // we can't know how many onNext calls will occur since they each run on a separate thread, +        // that depends on thread scheduling so 0, 1, 2 and 3 are all valid options, +        // assertEquals(3, busyobserver.onNextCount.get());, +        assertTrue(busyobserver.onNextCount.get() < 4);, +        assertTrue(busyobserver.onError);, +        // no onCompleted because onError was invoked, +        assertFalse(busyobserver.onCompleted);, +        // non-deterministic because unsubscribe happens after 'waitToFinish' releases, +        // so commenting out for now as this is not a critical thing to test here, +        //verify(s, times(1)).unsubscribe();, +, +        // we can have concurrency ..., +        assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);, +        // ... but the onNext execution should be single threaded, +        assertEquals(1, busyobserver.maxConcurrentThreads.get());, +    }, +, +    @Test]