[+++ b/rxjava-core/src/main/java/rx/operators/OperationMap.java, +import static org.junit.Assert.*;, +import java.util.concurrent.atomic.AtomicInteger;, +            // let the exception be thrown if func fails as a SafeObserver wrapping this will handle it, +        @Test, +        public void testMapWithSynchronousObservableContainingError() {, +            Observable<String> w = Observable.from("one", "fail", "two", "three", "fail");, +            final AtomicInteger c1 = new AtomicInteger();, +            final AtomicInteger c2 = new AtomicInteger();, +            Observable<String> m = Observable.create(map(w, new Func1<String, String>() {, +                public String call(String s) {, +                    if ("fail".equals(s)), +                        throw new RuntimeException("Forced Failure");, +                    System.out.println("BadMapper:" + s);, +                    c1.incrementAndGet();, +                    return s;, +                }, +            })).map(new Func1<String, String>() {, +                public String call(String s) {, +                    System.out.println("SecondMapper:" + s);, +                    c2.incrementAndGet();, +                    return s;, +                }, +            });, +, +            m.subscribe(stringObserver);, +, +            verify(stringObserver, times(1)).onNext("one");, +            verify(stringObserver, never()).onNext("two");, +            verify(stringObserver, never()).onNext("three");, +            verify(stringObserver, never()).onCompleted();, +            verify(stringObserver, times(1)).onError(any(Exception.class));, +, +            // we should have only returned 1 value: "one", +            assertEquals(1, c1.get());, +            assertEquals(1, c2.get());, +        }, +]