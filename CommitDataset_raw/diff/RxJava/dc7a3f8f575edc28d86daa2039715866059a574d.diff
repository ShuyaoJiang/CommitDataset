[+++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.MultipleAssignmentSubscription;, +import rx.util.functions.Action1;, +    /**, +     * Schedules an action and receives back an action for recursive execution., +     * , +     * @param action, +     *            action, +     * @return a subscription to be able to unsubscribe from action., +     */, +    public Subscription schedule(final Action1<Action0> action) {, +        final CompositeSubscription parentSubscription = new CompositeSubscription();, +        final MultipleAssignmentSubscription childSubscription = new MultipleAssignmentSubscription();, +        parentSubscription.add(childSubscription);, +, +        final Func2<Scheduler, Func2, Subscription> parentAction = new Func2<Scheduler, Func2, Subscription>() {, +, +            @Override, +            public Subscription call(final Scheduler scheduler, final Func2 parentAction) {, +                action.call(new Action0() {, +, +                    @Override, +                    public void call() {, +                        if (!parentSubscription.isUnsubscribed()) {, +                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));, +                        }, +                    }, +, +                });, +                return childSubscription;, +            }, +        };, +, +        parentSubscription.add(schedule(parentAction, parentAction));, +, +        return parentSubscription;, +    }, +        @SuppressWarnings("unchecked"), +        // mocking is unchecked, unfortunately, +                @Override, +                public void call() {, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.MultipleAssignmentSubscription;, +import rx.util.functions.Action1;, +    /**, +     * Schedules an action and receives back an action for recursive execution., +     * , +     * @param action, +     *            action, +     * @return a subscription to be able to unsubscribe from action., +     */, +    public Subscription schedule(final Action1<Action0> action) {, +        final CompositeSubscription parentSubscription = new CompositeSubscription();, +        final MultipleAssignmentSubscription childSubscription = new MultipleAssignmentSubscription();, +        parentSubscription.add(childSubscription);, +, +        final Func2<Scheduler, Func2, Subscription> parentAction = new Func2<Scheduler, Func2, Subscription>() {, +, +            @Override, +            public Subscription call(final Scheduler scheduler, final Func2 parentAction) {, +                action.call(new Action0() {, +, +                    @Override, +                    public void call() {, +                        if (!parentSubscription.isUnsubscribed()) {, +                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));, +                        }, +                    }, +, +                });, +                return childSubscription;, +            }, +        };, +, +        parentSubscription.add(schedule(parentAction, parentAction));, +, +        return parentSubscription;, +    }, +        @SuppressWarnings("unchecked"), +        // mocking is unchecked, unfortunately, +                @Override, +                public void call() {, +++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java, +import rx.util.functions.Action0;, +    @Test, +    public void testRecursion() {, +        TestScheduler s = new TestScheduler();, +, +        final AtomicInteger counter = new AtomicInteger(0);, +, +        Subscription subscription = s.schedule(new Action1<Action0>() {, +, +            @Override, +            public void call(Action0 self) {, +                counter.incrementAndGet();, +                System.out.println("counter: " + counter.get());, +                self.call();, +            }]