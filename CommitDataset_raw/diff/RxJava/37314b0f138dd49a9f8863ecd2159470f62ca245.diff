[+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/schedulers/TestScheduler.java, +            time = current.time;, +        private BooleanSubscription s = new BooleanSubscription();, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);, +                            } else {, +                                resumeBoundary.compareAndSet(false, true);, +            public void request(final long n) {, +                long c = consumerCapacity.getAndAdd(n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(c + n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java, +            if (REQUESTED.get(this) == 0 && terminated == 0) {, +++ b/src/main/java/rx/schedulers/TestScheduler.java, +            time = current.time;, +        private BooleanSubscription s = new BooleanSubscription();, +++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java, +import rx.observables.GroupedObservable;, +                System.out.println("FuncWithErrors @ " + count.get()); , +                System.out.println("FuncWithErrors @ onSuccessOnly"); , +                System.out.println("FuncWithErrors @ onCompleted"); , +                System.out.println("FuncWithErrors !"); , +    @Test(timeout = 3000), +    @Test(timeout = 3000), +    public void testIssue1900() throws InterruptedException {, +        @SuppressWarnings("unchecked"), +        Observer<String> observer = mock(Observer.class);, +        final int NUM_MSG = 1034;, +        final AtomicInteger count = new AtomicInteger();, +, +        Observable<String> origin = Observable.range(0, NUM_MSG), +                .map(new Func1<Integer, String>() {, +                    @Override, +                    public String call(Integer t1) {, +                        return "msg: " + count.incrementAndGet();, +                    }, +                });, +        , +        origin.retry(), +        .groupBy(new Func1<String, String>() {, +            @Override, +            public String call(String t1) {, +                return t1;, +            }, +        }), +        .flatMap(new Func1<GroupedObservable<String,String>, Observable<String>>() {, +            @Override, +            public Observable<String> call(GroupedObservable<String, String> t1) {, +                return t1.take(1);, +            }, +        }), +        .unsafeSubscribe(new TestSubscriber<String>(observer));, +        , +        InOrder inOrder = inOrder(observer);, +        // should show 3 attempts, +        inOrder.verify(observer, times(NUM_MSG)).onNext(any(java.lang.String.class));, +        //        // should have no errors, +        inOrder.verify(observer, never()).onError(any(Throwable.class));, +        // should have a single success, +        //inOrder.verify(observer, times(1)).onNext("onSuccessOnly");]