[+++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java, +import java.util.Queue;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import org.junit.Ignore;, +        return new Concat<T>(sequences);, +    private static class Concat<T> implements Func1<Observer<T>, Subscription> {, +        private Observable<Observable<T>> sequences;, +        private AtomicObservableSubscription innerSubscription = null;, +        public Concat(Observable<Observable<T>> sequences) {, +            this.sequences = sequences;, +        }, +, +        public Subscription call(final Observer<T> observer) {, +            final AtomicBoolean completedOrErred = new AtomicBoolean(false);, +            final AtomicBoolean allSequencesReceived = new AtomicBoolean(false);, +            final Queue<Observable<T>> nextSequences = new ConcurrentLinkedQueue<Observable<T>>();, +, +            final Observer<T> reusableObserver = new Observer<T>() {, +                    if (completedOrErred.compareAndSet(false, true)) {, +                    }, +                    synchronized (nextSequences) {, +                        if (nextSequences.isEmpty()) {, +                            // No new sequences available at the moment, +                            innerSubscription = null;, +                            if (allSequencesReceived.get()) {, +                                // No new sequences are coming, we are finished, +                                if (completedOrErred.compareAndSet(false, true)) {, +                        } else {, +                            // Continue on to the next sequence, +                            innerSubscription = new AtomicObservableSubscription();, +                            innerSubscription.wrap(nextSequences.poll().subscribe(this));, +                        }, +                    }, +                }, +            };, +, +            outerSubscription.wrap(sequences.subscribe(new Observer<Observable<T>>() {, +                @Override, +                public void onNext(Observable<T> nextSequence) {, +                    synchronized (nextSequences) {, +                        if (innerSubscription == null) {, +                            // We are currently not subscribed to any sequence, +                            innerSubscription = new AtomicObservableSubscription();, +                            innerSubscription.wrap(nextSequence.subscribe(reusableObserver));, +                        } else {, +                            // Put this sequence at the end of the queue, +                            nextSequences.add(nextSequence);, +                        }, +                    }, +                }, +                @Override, +                public void onError(Exception e) {, +                    if (completedOrErred.compareAndSet(false, true)) {, +                        if (innerSubscription != null) {, +                            innerSubscription.unsubscribe();, +                        }, +                        observer.onError(e);, +                    }, +                }, +                @Override, +                public void onCompleted() {, +                    allSequencesReceived.set(true);, +                    if (innerSubscription == null) {, +                        // We are not subscribed to any sequence, and none are coming anymore, +                        if (completedOrErred.compareAndSet(false, true)) {, +                            observer.onCompleted();, +                        }, +                    }, +                }, +, +            return new Subscription() {, +                @Override, +                public void unsubscribe() {, +                    synchronized (nextSequences) {, +                        if (innerSubscription != null), +                            innerSubscription.unsubscribe();, +                        outerSubscription.unsubscribe();, +                    }, +                }, +            };, +       , +        @Test, + 		public void testConcatUnSubscribeNotBlockingObservables() {, + , +        	final CountDownLatch okToContinueW1 = new CountDownLatch(1);, +        	final CountDownLatch okToContinueW2 = new CountDownLatch(1);, +        	, +           	final TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, "one", "two", "three");, +           	final TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, "four", "five", "six");, +, +             @SuppressWarnings("unchecked"), +             Observer<String> aObserver = mock(Observer.class);, +             Observable<Observable<String>> observableOfObservables = Observable.create(new Func1<Observer<Observable<String>>, Subscription>() {, +, +                 @Override, +                 public Subscription call(Observer<Observable<String>> observer) {, +                     // simulate what would happen in an observable, +                     observer.onNext(w1);, +                     observer.onNext(w2);]