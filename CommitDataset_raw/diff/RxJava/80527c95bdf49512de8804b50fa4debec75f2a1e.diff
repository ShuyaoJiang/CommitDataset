[+++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +While *technically* it is a breaking change make the `asJavaObserver` property private, you should probably not have, +touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`, +call `toJava`., +The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`, +method hindered type inference and made Scala code look unnecessarily different than that in other language bindings., +In fact the only occurence left of `apply` if for the varargs case. All other factory methods now have their own name., +, +* `def apply[T](items: T*): Observable[T]`, +* `def from[T](f: Future[T]): Observable[T]`, +* `def from[T](iterable: Iterable[T]): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +* `def error[T](exception: Throwable): Observable[T]`, +`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored., +Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them, +be kind to the reader of your code and call them explicitly., +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +While *technically* it is a breaking change make the `asJavaObserver` property private, you should probably not have, +touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`, +call `toJava`., +The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`, +method hindered type inference and made Scala code look unnecessarily different than that in other language bindings., +In fact the only occurence left of `apply` if for the varargs case. All other factory methods now have their own name., +, +* `def apply[T](items: T*): Observable[T]`, +* `def from[T](f: Future[T]): Observable[T]`, +* `def from[T](iterable: Iterable[T]): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +* `def error[T](exception: Throwable): Observable[T]`, +`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored., +Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them, +be kind to the reader of your code and call them explicitly., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = s.asJavaNotification, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +While *technically* it is a breaking change make the `asJavaObserver` property private, you should probably not have, +touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`, +call `toJava`., +The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`, +method hindered type inference and made Scala code look unnecessarily different than that in other language bindings., +In fact the only occurence left of `apply` if for the varargs case. All other factory methods now have their own name., +, +* `def apply[T](items: T*): Observable[T]`, +* `def from[T](f: Future[T]): Observable[T]`, +* `def from[T](iterable: Iterable[T]): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +* `def error[T](exception: Throwable): Observable[T]`, +`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored., +Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them, +be kind to the reader of your code and call them explicitly., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = s.asJavaNotification, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +  private [scala] val asJavaNotification: rx.Notification[_ <: T], +, +  override def equals(that: Any): Boolean = that match {, +    case other: Notification[_] => asJavaNotification.equals(other.asJavaNotification), +    case _ => false, +  }, +  override def hashCode(): Int = asJavaNotification.hashCode(), +  class OnNext[+T] private[scala] (val asJavaNotification: rx.Notification[_ <: T]) extends Notification[T] {, +    def value: T = asJavaNotification.getValue, +    override def toString = s"OnNext($value)", +  class OnError[+T] private[scala] (val asJavaNotification: rx.Notification[_ <: T]) extends Notification[T] {, +    def error: Throwable = asJavaNotification.getThrowable, +    override def toString = s"OnError($error)", +  class OnCompleted[T] private[scala](val asJavaNotification: rx.Notification[_ <: T]) extends Notification[T] {, +    override def toString = "OnCompleted()", +  }, +, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +While *technically* it is a breaking change make the `asJavaObserver` property private, you should probably not have, +touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`, +call `toJava`., +The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`, +method hindered type inference and made Scala code look unnecessarily different than that in other language bindings., +In fact the only occurence left of `apply` if for the varargs case. All other factory methods now have their own name., +, +* `def apply[T](items: T*): Observable[T]`, +* `def from[T](f: Future[T]): Observable[T]`, +* `def from[T](iterable: Iterable[T]): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +* `def error[T](exception: Throwable): Observable[T]`, +`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored., +Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them, +be kind to the reader of your code and call them explicitly., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = s.asJavaNotification, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +  private [scala] val asJavaNotification: rx.Notification[_ <: T], +, +  override def equals(that: Any): Boolean = that match {, +    case other: Notification[_] => asJavaNotification.equals(other.asJavaNotification), +    case _ => false, +  }, +  override def hashCode(): Int = asJavaNotification.hashCode(), +  class OnNext[+T] private[scala] (val asJavaNotification: rx.Notification[_ <: T]) extends Notification[T] {, +    def value: T = asJavaNotification.getValue, +    override def toString = s"OnNext($value)", +  class OnError[+T] private[scala] (val asJavaNotification: rx.Notification[_ <: T]) extends Notification[T] {]