[+++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +        public synchronized long requestFromSubscriber(Subscriber<? super T> subscriber, long request) {, +            Map<Subscriber<? super T>, AtomicLong> subs = ss;, +            AtomicLong r = subs.get(subscriber);, +                subs.put(subscriber, new AtomicLong(request));, +                do {, +                    long current = r.get();, +                    if (current == Long.MAX_VALUE) {, +                        break;, +                    long u = current + request;, +                    if (u < 0) {, +                        u = Long.MAX_VALUE;, +                    if (r.compareAndSet(current, u)) {, +                        break;, +                    }, +                } while (true);, +            return resetAfterSubscriberUpdate(subs);, +            Map<Subscriber<? super T>, AtomicLong> subs = ss;, +            subs.remove(subscriber);, +            resetAfterSubscriberUpdate(subs);, +        private long resetAfterSubscriberUpdate(Map<Subscriber<? super T>, AtomicLong> subs) {, +            Subscriber<? super T>[] subscriberArray = new Subscriber[subs.size()];, +            for (Map.Entry<Subscriber<? super T>, AtomicLong> e : subs.entrySet()) {, +                subscriberArray[i++] = e.getKey();, +                AtomicLong l = e.getValue();, +                long c = l.get();, +            this.subscribers = subscriberArray;, +            return lowest;, +        public void requestFromChildSubscriber(Subscriber<? super T> subscriber, long request) {, +                State<T> localState = state;, +                Map<Subscriber<? super T>, AtomicLong> localMap = localState.ss;, +                RxRingBuffer localBuffer = originSubscriber.buffer;, +                NotificationLite<T> nl = notifier;, +                , +                    , +                        boolean shouldEmit = localState.canEmitWithDecrement();, +                        Object o = localBuffer.poll();, +                            localState.incrementOutstandingAfterFailedEmit();, +                        for (Subscriber<? super T> s : localState.getSubscribers()) {, +                            AtomicLong req = localMap.get(s);, +                            if (req != null) { // null req indicates a concurrent unsubscription happened, +                                nl.accept(s, o);, +                                req.decrementAndGet();, +++ b/src/main/java/rx/internal/operators/OperatorPublish.java, +        public synchronized long requestFromSubscriber(Subscriber<? super T> subscriber, long request) {, +            Map<Subscriber<? super T>, AtomicLong> subs = ss;, +            AtomicLong r = subs.get(subscriber);, +                subs.put(subscriber, new AtomicLong(request));, +                do {, +                    long current = r.get();, +                    if (current == Long.MAX_VALUE) {, +                        break;, +                    long u = current + request;, +                    if (u < 0) {, +                        u = Long.MAX_VALUE;, +                    if (r.compareAndSet(current, u)) {, +                        break;, +                    }, +                } while (true);, +            return resetAfterSubscriberUpdate(subs);, +            Map<Subscriber<? super T>, AtomicLong> subs = ss;, +            subs.remove(subscriber);, +            resetAfterSubscriberUpdate(subs);, +        private long resetAfterSubscriberUpdate(Map<Subscriber<? super T>, AtomicLong> subs) {, +            Subscriber<? super T>[] subscriberArray = new Subscriber[subs.size()];, +            for (Map.Entry<Subscriber<? super T>, AtomicLong> e : subs.entrySet()) {, +                subscriberArray[i++] = e.getKey();, +                AtomicLong l = e.getValue();, +                long c = l.get();, +            this.subscribers = subscriberArray;, +            return lowest;, +        public void requestFromChildSubscriber(Subscriber<? super T> subscriber, long request) {, +                State<T> localState = state;, +                Map<Subscriber<? super T>, AtomicLong> localMap = localState.ss;, +                RxRingBuffer localBuffer = originSubscriber.buffer;, +                NotificationLite<T> nl = notifier;, +                , +                    , +                        boolean shouldEmit = localState.canEmitWithDecrement();, +                        Object o = localBuffer.poll();, +                            localState.incrementOutstandingAfterFailedEmit();, +                        for (Subscriber<? super T> s : localState.getSubscribers()) {, +                            AtomicLong req = localMap.get(s);, +                            if (req != null) { // null req indicates a concurrent unsubscription happened, +                                nl.accept(s, o);, +                                req.decrementAndGet();, +++ b/src/test/java/rx/internal/operators/OperatorPublishTest.java, +import static org.junit.Assert.*;, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.*;, +import rx.*;, +import rx.functions.*;, +    @Test(timeout = 10000), +    public void testBackpressureTwoConsumers() {, +        final AtomicInteger sourceEmission = new AtomicInteger();, +        final AtomicBoolean sourceUnsubscribed = new AtomicBoolean();, +        final Observable<Integer> source = Observable.range(1, 100), +                .doOnNext(new Action1<Integer>() {, +                    @Override, +                    public void call(Integer t1) {]