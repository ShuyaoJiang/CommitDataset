[+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapCompletable.java, +import java.util.concurrent.Callable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.*;, +import io.reactivex.internal.fuseable.*;, +        if (!tryScalarSource(source, mapper, s)) {, +    }, +        SimpleQueue<T> queue;, +                if (s instanceof QueueDisposable) {, +                    @SuppressWarnings("unchecked"), +                    QueueDisposable<T> qd = (QueueDisposable<T>) s;, +, +                    int m = qd.requestFusion(QueueDisposable.ANY);, +                    if (m == QueueDisposable.SYNC) {, +                        queue = qd;, +                        done = true;, +                        downstream.onSubscribe(this);, +                        drain();, +                        return;, +                    }, +                    if (m == QueueDisposable.ASYNC) {, +                        queue = qd;, +                        downstream.onSubscribe(this);, +                        return;, +                    }, +                }, +                queue = new SpscLinkedArrayQueue<T>(prefetch);, +            if (t != null) {, +            }, +            AtomicThrowable errors = this.errors;, +            ErrorMode errorMode = this.errorMode;, +, +                    boolean empty = true;, +                    CompletableSource cs = null;, +                    try {, +                        if (v != null) {, +                            cs = ObjectHelper.requireNonNull(mapper.apply(v), "The mapper returned a null CompletableSource");, +                            empty = false;, +                        }, +                    } catch (Throwable ex) {, +                        Exceptions.throwIfFatal(ex);, +                        disposed = true;, +                        queue.clear();, +                        upstream.dispose();, +                        errors.addThrowable(ex);, +                        ex = errors.terminate();, +                        downstream.onError(ex);, +                        return;, +                    }, +, +    static <T> boolean tryScalarSource(Observable<T> source, Function<? super T, ? extends CompletableSource> mapper, CompletableObserver observer) {, +        if (source instanceof Callable) {, +            @SuppressWarnings("unchecked"), +            Callable<T> call = (Callable<T>) source;, +            CompletableSource cs = null;, +            try {, +                T item = call.call();, +                if (item != null) {, +                    cs = ObjectHelper.requireNonNull(mapper.apply(item), "The mapper returned a null CompletableSource");, +                }, +            } catch (Throwable ex) {, +                Exceptions.throwIfFatal(ex);, +                EmptyDisposable.error(ex, observer);, +                return true;, +            }, +, +            if (cs == null) {, +                EmptyDisposable.complete(observer);, +            } else {, +                cs.subscribe(observer);, +            }, +            return true;, +        }, +        return false;, +    }, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapCompletable.java, +import java.util.concurrent.Callable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.*;, +import io.reactivex.internal.fuseable.*;, +        if (!tryScalarSource(source, mapper, s)) {, +    }, +        SimpleQueue<T> queue;, +                if (s instanceof QueueDisposable) {, +                    @SuppressWarnings("unchecked"), +                    QueueDisposable<T> qd = (QueueDisposable<T>) s;, +, +                    int m = qd.requestFusion(QueueDisposable.ANY);, +                    if (m == QueueDisposable.SYNC) {, +                        queue = qd;, +                        done = true;, +                        downstream.onSubscribe(this);, +                        drain();, +                        return;, +                    }, +                    if (m == QueueDisposable.ASYNC) {, +                        queue = qd;, +                        downstream.onSubscribe(this);, +                        return;, +                    }]