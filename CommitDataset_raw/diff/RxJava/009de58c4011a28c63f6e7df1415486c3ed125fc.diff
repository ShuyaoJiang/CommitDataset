[+++ b/src/main/java/io/reactivex/Observable.java, +        } else, +        if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/Observable.java, +        } else, +        if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java, +    , +        if (!it.hasNext()) {, +            EmptySubscription.complete(s);, +            return;, +        }, +++ b/src/main/java/io/reactivex/Observable.java, +        } else, +        if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java, +    , +        if (!it.hasNext()) {, +            EmptySubscription.complete(s);, +            return;, +        }, +++ b/src/main/java/io/reactivex/internal/operators/PublisherRangeSource.java, +    final long end;, +        this.end = (long)start + (count - 1);, +        final long end;, +        public RangeSubscription(Subscriber<? super Integer> actual, int start, long end) {, +++ b/src/main/java/io/reactivex/Observable.java, +        } else, +        if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java, +    , +        if (!it.hasNext()) {, +            EmptySubscription.complete(s);, +            return;, +        }, +++ b/src/main/java/io/reactivex/internal/operators/PublisherRangeSource.java, +    final long end;, +        this.end = (long)start + (count - 1);, +        final long end;, +        public RangeSubscription(Subscriber<? super Integer> actual, int start, long end) {, +++ b/src/test/java/io/reactivex/internal/operators/OnSubscribeFromIterableTest.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing permissions and limitations under the License., + */, +, +package io.reactivex.internal.operators;, +, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.*;, +, +import java.util.*;, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import org.junit.Test;, +import org.mockito.Mockito;, +import org.reactivestreams.Subscriber;, +, +import io.reactivex.Observable;, +import io.reactivex.Observer;, +import io.reactivex.TestHelper;, +import io.reactivex.schedulers.Schedulers;, +import io.reactivex.subscribers.TestSubscriber;, +, +public class OnSubscribeFromIterableTest {, +, +    @Test(expected = NullPointerException.class), +    public void testNull() {, +        Observable.fromIterable(null);, +    }, +    , +    @Test, +    public void testListIterable() {, +        Observable<String> observable = Observable.fromIterable(Arrays.<String> asList("one", "two", "three"));, +, +        Subscriber<String> observer = TestHelper.mockSubscriber();, +        , +        observable.subscribe(observer);, +        , +        verify(observer, times(1)).onNext("one");, +        verify(observer, times(1)).onNext("two");, +        verify(observer, times(1)).onNext("three");, +        verify(observer, Mockito.never()).onError(any(Throwable.class));, +        verify(observer, times(1)).onComplete();, +    }, +, +    /**, +     * This tests the path that can not optimize based on size so must use setProducer., +     */, +    @Test]