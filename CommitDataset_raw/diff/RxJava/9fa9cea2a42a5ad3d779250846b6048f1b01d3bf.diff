[+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +, +                while (true) {, +                    } else if (it.hasNext()) {, +                    } else if (!o.isUnsubscribed()) {, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                    }, +                         * This complicated logic is done to avoid touching the, +                         * volatile `requested` value during the loop itself. If, +                         * it is touched during the loop the performance is, +                         * impacted significantly., +                        while (true) {, +                            } else if (it.hasNext()) {, +                                if (--numToEmit >= 0) {, +                                } else, +                                    break;, +                            } else if (!o.isUnsubscribed()) {, +                                return;, +                            } else {, +                                // is unsubscribed, +                        }, +                            // we're done emitting the number requested so, +                            // return, +++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +, +                while (true) {, +                    } else if (it.hasNext()) {, +                    } else if (!o.isUnsubscribed()) {, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                    }, +                         * This complicated logic is done to avoid touching the, +                         * volatile `requested` value during the loop itself. If, +                         * it is touched during the loop the performance is, +                         * impacted significantly., +                        while (true) {, +                            } else if (it.hasNext()) {, +                                if (--numToEmit >= 0) {, +                                } else, +                                    break;, +                            } else if (!o.isUnsubscribed()) {, +                                return;, +                            } else {, +                                // is unsubscribed, +                        }, +                            // we're done emitting the number requested so, +                            // return, +++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java, +import java.util.concurrent.atomic.AtomicReference;, +import rx.subjects.PublishSubject;, +    static final Func1<Observable<? extends Notification<?>>, Observable<?>> REDO_INIFINITE = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {, +        return retry(source, REDO_INIFINITE);, +        return repeat(source, REDO_INIFINITE, scheduler);, +    private Observable<T> source;, +    private boolean stopOnComplete;, +    private boolean stopOnError;, +        final AtomicBoolean isLocked = new AtomicBoolean(true);, +        final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();, +        final PublishSubject<Notification<?>> terminals = PublishSubject.create();, +                            currentProducer.set(null);, +                            currentProducer.set(null);, +                            if (consumerCapacity.get() != Long.MAX_VALUE) {, +                                consumerCapacity.decrementAndGet();, +                            }, +                        currentProducer.set(producer);, +                        long c = consumerCapacity.get();, +                        if (c > 0) {, +                            producer.request(c);, +                        }, +                                if (t.isOnCompleted() && stopOnComplete), +                                    child.onCompleted();, +                                else if (t.isOnError() && stopOnError), +                                    child.onError(t.getThrowable());, +                                else {, +                                    isLocked.set(false);, +                        if (!isLocked.get() && !child.isUnsubscribed()) {, +                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);, +                Producer producer = currentProducer.get();, +                if (producer != null) {, +                    producer.request(n);, +                } else, +                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {, +++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java, +, +                while (true) {, +                    } else if (it.hasNext()) {, +                    } else if (!o.isUnsubscribed()) {, +                        return;, +                    } else {, +                        // is unsubscribed, +                        return;, +                    }, +                         * This complicated logic is done to avoid touching the, +                         * volatile `requested` value during the loop itself. If, +                         * it is touched during the loop the performance is]