[+++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +package rx.lang.scala, +, +import java.util.Calendar, +, +import scala.collection.SortedMap, +import scala.reflect.runtime.universe, +import scala.reflect.runtime.universe.Symbol, +import scala.reflect.runtime.universe.Type, +import scala.reflect.runtime.universe.typeOf, +, +import org.junit.Ignore, +import org.junit.Test, +import org.scalatest.junit.JUnitSuite, +, +/**, + * These tests can be used to check if all methods of the Java Observable have a corresponding, + * method in the Scala Observable., + * , + * These tests don't contain any assertions, so they will always succeed, but they print their, + * results to stdout., + */, +class CompletenessTest extends JUnitSuite {, +  , +  // some frequently used comments:, +  val unnecessary = "[considered unnecessary in Scala land]", +  val deprecated = "[deprecated in RxJava]", +  val averageProblem = "[We can't have a general average method because Scala's `Numeric` does not have " +, +     "scalar multiplication (we would need to calculate `(1.0/numberOfElements)*sum`). " + , +     "You can use `fold` instead to accumulate `sum` and `numberOfElements` and divide at the end.]", +  val commentForFirstWithPredicate = "[use `.filter(condition).first`]", +  val fromFuture = "[TODO: Decide how Scala Futures should relate to Observables. Should there be a " +, +     "common base interface for Future and Observable? And should Futures also have an unsubscribe method?]", +  , +  /**, +   * Maps each method from the Java Observable to its corresponding method in the Scala Observable, +   */, +  val correspondence = defaultMethodCorrespondence ++ correspondenceChanges // ++ overrides LHS with RHS, +  , +  /**, +   * Creates default method correspondence mappings, assuming that Scala methods have the same, +   * name and the same argument types as in Java, +   */, +  def defaultMethodCorrespondence: Map[String, String] = {, +    val allMethods = getPublicInstanceAndCompanionMethods(typeOf[rx.Observable[_]])      , +    val tuples = for (javaM <- allMethods) yield (javaM, javaMethodSignatureToScala(javaM)), +    tuples.toMap, +  }, +  , +  /**, +   * Manually added mappings from Java Observable methods to Scala Observable methods, +   */, +  def correspondenceChanges = Map(, +      // manually added entries for Java instance methods, +      "aggregate(Func2[T, T, T])" -> "reduce((U, U) => U)",, +      "aggregate(R, Func2[R, _ >: T, R])" -> "foldLeft(R)((R, T) => R)",, +      "all(Func1[_ >: T, Boolean])" -> "forall(T => Boolean)",, +      "buffer(Long, Long, TimeUnit)" -> "buffer(Duration, Duration)",, +      "buffer(Long, Long, TimeUnit, Scheduler)" -> "buffer(Duration, Duration, Scheduler)",, +      "count()" -> "length",, +      "dematerialize()" -> "dematerialize(<:<[Observable[T], Observable[Notification[U]]])",, +      "elementAt(Int)" -> "[use `.drop(index).first`]",, +      "elementAtOrDefault(Int, T)" -> "[use `.drop(index).firstOrElse(default)`]",, +      "first(Func1[_ >: T, Boolean])" -> commentForFirstWithPredicate,, +      "firstOrDefault(T)" -> "firstOrElse(=> U)", , +      "firstOrDefault(Func1[_ >: T, Boolean], T)" -> "[use `.filter(condition).firstOrElse(default)`]",, +      "groupBy(Func1[_ >: T, _ <: K], Func1[_ >: T, _ <: R])" -> "[use `groupBy` and `map`]",, +      "mapMany(Func1[_ >: T, _ <: Observable[_ <: R]])" -> "flatMap(T => Observable[R])",, +      "mapWithIndex(Func2[_ >: T, Integer, _ <: R])" -> "[combine `zipWithIndex` with `map` or with a for comprehension]",, +      "onErrorResumeNext(Func1[Throwable, _ <: Observable[_ <: T]])" -> "onErrorResumeNext(Throwable => Observable[U])",, +      "onErrorResumeNext(Observable[_ <: T])" -> "onErrorResumeNext(Observable[U])",, +      "onErrorReturn(Func1[Throwable, _ <: T])" -> "onErrorReturn(Throwable => U)",, +      "onExceptionResumeNext(Observable[_ <: T])" -> "onExceptionResumeNext(Observable[U])",, +      "parallel(Func1[Observable[T], Observable[R]])" -> "parallel(Observable[T] => Observable[R])",, +      "parallel(Func1[Observable[T], Observable[R]], Scheduler)" -> "parallel(Observable[T] => Observable[R], Scheduler)",, +      "reduce(Func2[T, T, T])" -> "reduce((U, U) => U)",, +      "reduce(R, Func2[R, _ >: T, R])" -> "foldLeft(R)((R, T) => R)",, +      "scan(Func2[T, T, T])" -> unnecessary,, +      "scan(R, Func2[R, _ >: T, R])" -> "scan(R)((R, T) => R)",, +      "skip(Int)" -> "drop(Int)",, +      "skipWhile(Func1[_ >: T, Boolean])" -> "dropWhile(T => Boolean)",, +      "skipWhileWithIndex(Func2[_ >: T, Integer, Boolean])" -> unnecessary,, +      "startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",, +      "takeFirst()" -> "first",, +      "takeFirst(Func1[_ >: T, Boolean])" -> commentForFirstWithPredicate,, +      "takeLast(Int)" -> "takeRight(Int)",, +      "takeWhileWithIndex(Func2[_ >: T, _ >: Integer, Boolean])" -> "[use `.zipWithIndex.takeWhile{case (elem, index) => condition}.map(_._1)`]",, +      "toList()" -> "toSeq",, +      "toSortedList()" -> "[Sorting is already done in Scala's collection library, use `.toSeq.map(_.sorted)`]",, +      "toSortedList(Func2[_ >: T, _ >: T, Integer])" -> "[Sorting is already done in Scala's collection library, use `.toSeq.map(_.sortWith(f))`]",, +      "where(Func1[_ >: T, Boolean])" -> "filter(T => Boolean)",, +      "window(Long, Long, TimeUnit)" -> "window(Duration, Duration)",, +      "window(Long, Long, TimeUnit, Scheduler)" -> "window(Duration, Duration, Scheduler)",, +      , +      // manually added entries for Java static methods, +      "average(Observable[Integer])" -> averageProblem,, +      "averageDoubles(Observable[Double])" -> averageProblem,, +      "averageFloats(Observable[Float])" -> averageProblem,, +      "averageLongs(Observable[Long])" -> averageProblem,, +      "create(OnSubscribeFunc[T])" -> "apply(Observer[T] => Subscription)",]