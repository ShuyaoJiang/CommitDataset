[+++ b/rxjava-core/src/main/java/rx/operators/OperatorRetry.java, +                        Subscriber<T> subscriber = new Subscriber<T>() {, +++ b/rxjava-core/src/main/java/rx/operators/OperatorRetry.java, +                        Subscriber<T> subscriber = new Subscriber<T>() {, +++ b/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import rx.functions.Action0;, +, +    class SlowObservable implements Observable.OnSubscribe<Long> {, +, +        private AtomicInteger efforts=new AtomicInteger(0);, +        private AtomicInteger active=new AtomicInteger(0),maxActive=new AtomicInteger(0);, +        private AtomicInteger nextBeforeFailure;, +, +        private final int emitDelay;, +, +        public SlowObservable(int emitDelay,int countNext) {, +            this.emitDelay=emitDelay;, +            this.nextBeforeFailure=new AtomicInteger(countNext);, +        }, +, +        public void call(final Subscriber<? super Long> subscriber) {, +            final AtomicBoolean terminate=new AtomicBoolean(false);, +            efforts.getAndIncrement();, +            active.getAndIncrement();, +            maxActive.set(Math.max(active.get(),maxActive.get()));, +            final Thread thread = new Thread() {, +                @Override, +                public void run() {, +                    long nr = 0;, +                    try {, +                        while (!terminate.get()) {, +                            Thread.sleep(emitDelay);, +                            if (nextBeforeFailure.getAndDecrement()>0) {, +                                subscriber.onNext(nr++);, +                            }, +                            else {, +                                subscriber.onError(new RuntimeException("expected-failed"));, +                            }, +                        }, +                    }, +                    catch(InterruptedException t) {, +                    }, +                }, +            };, +            thread.start();, +            subscriber.add(Subscriptions.create(new Action0() {, +                @Override, +                public void call() {, +                    terminate.set(true);, +                    active.decrementAndGet();, +                }, +            }));, +        }, +    }, +, +    /** Observer for listener on seperate thread */, +    class AsyncObserver<T> implements Observer<T> {, +, +        protected CountDownLatch latch=new CountDownLatch(1);, +, +        protected Observer<T> target;, +, +        /** Wrap existing Observer */, +        public AsyncObserver(Observer<T> target) {, +            this.target=target;, +        }, +, +        /** Wait */, +        public void await() {, +            try {, +                latch.await();, +            } catch (InterruptedException e) {, +                fail("Test interrupted");, +            }, +        }, +, +        // Observer implementation, +, +        @Override, +        public void onCompleted() {, +            target.onCompleted();, +            latch.countDown();, +        }, +, +        @Override, +        public void onError(Throwable t) {, +            target.onError(t);, +            latch.countDown();, +        }, +, +        @Override, +        public void onNext(T v) {, +            target.onNext(v);, +        }, +    }, +, +    @Test, +    public void testUnsubscribeAfterError() {, +]