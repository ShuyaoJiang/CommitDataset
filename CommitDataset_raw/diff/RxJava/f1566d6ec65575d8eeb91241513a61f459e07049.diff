[+++ b/src/main/java/io/reactivex/Observable.java, +    public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {, +        Objects.requireNonNull(zipper);, +        Objects.requireNonNull(sources);, +        return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));, +    }, +, +    , +++ b/src/main/java/io/reactivex/Observable.java, +    public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {, +        Objects.requireNonNull(zipper);, +        Objects.requireNonNull(sources);, +        return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));, +    }, +, +    , +++ b/src/main/java/io/reactivex/internal/operators/OperatorDebounceTimed.java, +            , +            DebounceEmitter<T> de = new DebounceEmitter<>(t, idx, this);, +            if (!TIMER.compareAndSet(this, d, de)) {, +                return;, +            d = worker.schedule(de, timeout, unit);, +            de.setResource(d);, +            // TODO may want to trigger early delivery of the very last value? depends on further tests, +            done();, +        , +        void emit(long idx, T t, DebounceEmitter<T> emitter) {, +            if (idx == index) {, +                long r = requested;, +                if (r != 0L) {, +                    actual.onNext(t);, +                    if (r != Long.MAX_VALUE) {, +                        REQUESTED.decrementAndGet(this);, +                    }, +                    , +                    emitter.dispose();, +                } else {, +                    cancel();, +                    actual.onError(new IllegalStateException("Could not deliver value due to lack of requests"));, +                }, +            }, +        }, +        , +        void done() {, +            if (decrementAndGet() == 0) {, +                disposeTimer();, +                worker.dispose();, +                actual.onComplete();, +            }, +        }, +    }, +    , +    static final class DebounceEmitter<T> extends AtomicReference<Disposable> implements Runnable, Disposable {, +        /** */, +        private static final long serialVersionUID = 6812032969491025141L;, +, +        static final Disposable DISPOSED = () -> { };, +        , +        final T value;, +        final long idx;, +        final DebounceTimedSubscriber<T> parent;, +        , +        public DebounceEmitter(T value, long idx, DebounceTimedSubscriber<T> parent) {, +            this.value = value;, +            this.idx = idx;, +            this.parent = parent;, +        }, +, +        @Override, +        public void run() {, +            parent.emit(idx, value, this);, +        }, +        , +        @Override, +        public void dispose() {, +            Disposable d = get();, +            if (d != DISPOSED) {, +                d = getAndSet(DISPOSED);, +                if (d != DISPOSED && d != null) {, +                    d.dispose();, +                    parent.done();, +                }, +            }, +        }, +        , +        public void setResource(Disposable d) {, +            for (;;) {, +                Disposable a = get();, +                if (a == DISPOSED) {, +                    d.dispose();, +                    return;, +                }, +                if (compareAndSet(a, d)) {, +                    return;, +                }, +            }, +        }, +++ b/src/main/java/io/reactivex/Observable.java, +    public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {, +        Objects.requireNonNull(zipper);]