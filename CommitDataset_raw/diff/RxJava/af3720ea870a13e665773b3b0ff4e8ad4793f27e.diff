[+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import org.mockito.InOrder;, +, +        @Test, +        @SuppressWarnings("unchecked"), +        public void testOrdering() throws InterruptedException {, +            Observable<String> obs = Observable.from("one", null, "two", "three", "four");, +, +            Observer<String> observer = mock(Observer.class);, +, +            InOrder inOrder = inOrder(observer);, +, +            obs.observeOn(Schedulers.threadPoolForComputation()).subscribe(observer);, +, +            Thread.sleep(500); // !!! not a true unit test, +, +            inOrder.verify(observer, times(1)).onNext("one");, +            inOrder.verify(observer, times(1)).onNext(null);, +            inOrder.verify(observer, times(1)).onNext("two");, +            inOrder.verify(observer, times(1)).onNext("three");, +            inOrder.verify(observer, times(1)).onNext("four");, +            inOrder.verify(observer, times(1)).onCompleted();, +            inOrder.verifyNoMoreInteractions();, +        }, +, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import org.mockito.InOrder;, +, +        @Test, +        @SuppressWarnings("unchecked"), +        public void testOrdering() throws InterruptedException {, +            Observable<String> obs = Observable.from("one", null, "two", "three", "four");, +, +            Observer<String> observer = mock(Observer.class);, +, +            InOrder inOrder = inOrder(observer);, +, +            obs.observeOn(Schedulers.threadPoolForComputation()).subscribe(observer);, +, +            Thread.sleep(500); // !!! not a true unit test, +, +            inOrder.verify(observer, times(1)).onNext("one");, +            inOrder.verify(observer, times(1)).onNext(null);, +            inOrder.verify(observer, times(1)).onNext("two");, +            inOrder.verify(observer, times(1)).onNext("three");, +            inOrder.verify(observer, times(1)).onNext("four");, +            inOrder.verify(observer, times(1)).onCompleted();, +            inOrder.verifyNoMoreInteractions();, +        }, +, +++ b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java, +import rx.Notification;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +, +    private final ConcurrentLinkedQueue<Notification<T>> queue = new ConcurrentLinkedQueue<Notification<T>>();, +    private final AtomicInteger counter = new AtomicInteger(0);, +, +        enqueue(new Notification<T>());, +        enqueue(new Notification<T>(e));, +        enqueue(new Notification<T>(args));, +    }, +, +    private void enqueue(Notification<T> notification) {, +        int count = counter.getAndIncrement();, +, +        queue.offer(notification);, +, +        if (count == 0) {, +            processQueue();, +        }, +    }, +, +    private void processQueue() {, +                Notification<T> not = queue.poll();, +, +                switch (not.getKind()) {, +                    case OnNext:, +                        underlying.onNext(not.getValue());, +                        break;, +                    case OnError:, +                        underlying.onError(not.getException());, +                        break;, +                    case OnCompleted:, +                        underlying.onCompleted();, +                        break;, +                    default:, +                        throw new IllegalStateException("Unknown kind of notification " + not);, +, +                }, +, +                int count = counter.decrementAndGet();, +                if (count > 0) {, +                    scheduler.schedule(this);, +                }, +]