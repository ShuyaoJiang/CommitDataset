[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def flattenSomeExample() {, +  @Test def flattenExample() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten.toBlocking.foreach(println(_)), +  }, +, +  @Test def flattenExample2() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten(2).toBlocking.foreach(println(_)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def flattenSomeExample() {, +  @Test def flattenExample() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten.toBlocking.foreach(println(_)), +  }, +, +  @Test def flattenExample2() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten(2).toBlocking.foreach(println(_)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Flattens an Observable that emits Observables into a single Observable that emits the items emitted by, +   * those Observables, without any transformation, while limiting the maximum number of concurrent, +   * subscriptions to these Observables., +   *, +   * <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.oo.png">, +   *, +   * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by, +   * using the `flatten` method., +   *, +   * @param maxConcurrent the maximum number of Observables that may be subscribed to concurrently, +   * @return an Observable that emits items that are the result of flattening the Observables emitted by the `source` Observable, +   * @throws IllegalArgumentException  if `maxConcurrent` is less than or equal to 0, +   */, +  def flatten[U](maxConcurrent: Int)(implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJavaObservable), +    val o4: rx.Observable[_ <: rx.Observable[_ <: U]] = o3.asJavaObservable, +    val o5 = rx.Observable.merge[U](o4, maxConcurrent), +    toScalaObservable[U](o5), +  }, +, +  /**, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +  @Test def flattenSomeExample() {, +  @Test def flattenExample() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten.toBlocking.foreach(println(_)), +  }, +, +  @Test def flattenExample2() {, +    List(, +      Observable.interval(200 millis).map(_ => 1).take(5),, +      Observable.interval(200 millis).map(_ => 2).take(5),, +      Observable.interval(200 millis).map(_ => 3).take(5),, +      Observable.interval(200 millis).map(_ => 4).take(5), +    ).toObservable.flatten(2).toBlocking.foreach(println(_)), +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +   * Flattens an Observable that emits Observables into a single Observable that emits the items emitted by, +   * those Observables, without any transformation, while limiting the maximum number of concurrent, +   * subscriptions to these Observables., +   *, +   * <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.oo.png">, +   *, +   * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by, +   * using the `flatten` method., +   *, +   * @param maxConcurrent the maximum number of Observables that may be subscribed to concurrently, +   * @return an Observable that emits items that are the result of flattening the Observables emitted by the `source` Observable, +   * @throws IllegalArgumentException  if `maxConcurrent` is less than or equal to 0, +   */, +  def flatten[U](maxConcurrent: Int)(implicit evidence: Observable[T] <:< Observable[Observable[U]]): Observable[U] = {, +    val o2: Observable[Observable[U]] = this, +    val o3: Observable[rx.Observable[_ <: U]] = o2.map(_.asJavaObservable)]