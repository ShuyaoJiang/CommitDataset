[+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorConcat.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +import rx.Producer;, + * @param <T>, + *            the source and result value type, +        ConcatSubscriber<T> cs = new ConcatSubscriber<T>(s, current);, +        ConcatProducer<T> cp = new ConcatProducer<T>(cs);, +        child.setProducer(cp);, +        return cs;, +    }, +, +    static final class ConcatProducer<T> implements Producer {, +        final ConcatSubscriber<T> cs;, +, +        ConcatProducer(ConcatSubscriber<T> cs) {, +            this.cs = cs;, +        }, +, +        @Override, +        public void request(long n) {, +            cs.requestFromChild(n);, +        }, +, +        private final Subscriber<T> child;, +, +        volatile ConcatInnerSubscriber<T> currentSubscriber;, +, +        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");, +, +        // accessed by REQUESTED_UPDATER, +        private volatile long requested;, +        @SuppressWarnings("rawtypes"), +        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");, +            this.child = s;, +        private void requestFromChild(long n) {, +            // we track 'requested' so we know whether we should subscribe the next or not, +            if (REQUESTED_UPDATER.getAndAdd(this, n) == 0) {, +                if (currentSubscriber == null && wip > 0) {, +                    // this means we may be moving from one subscriber to another after having stopped processing, +                    // so need to kick off the subscribe via this request notification, +                    subscribeNext();, +                    // return here as we don't want to do the requestMore logic below (which would double request), +                    return;, +                }, +            } , +                , +            if (currentSubscriber != null) {, +                // otherwise we are just passing it through to the currentSubscriber, +                currentSubscriber.requestMore(n);, +            }, +        }, +, +        private void decrementRequested() {, +            REQUESTED_UPDATER.decrementAndGet(this);, +        }, +, +            child.onError(e);, +            currentSubscriber = null;, +            if (requested > 0) {, +                    child.onCompleted();, +                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);, +                    current.set(currentSubscriber);, +                    obs.unsafeSubscribe(currentSubscriber);, +                }, +            } else {, +                // requested == 0, so we'll peek to see if we are completed, otherwise wait until another request, +                Object o = queue.peek();, +                if (nl.isCompleted(o)) {, +                    child.onCompleted();, +                }, +            }, +        }, +    }, +, +    static class ConcatInnerSubscriber<T> extends Subscriber<T> {, +, +        private final Subscriber<T> child;, +        private final ConcatSubscriber<T> parent;, +, +        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {, +            this.parent = parent;, +            this.child = child;, +            request(initialRequest);, +        }, +, +        void requestMore(long n) {, +            request(n);, +        }, +            parent.decrementRequested();, +            child.onNext(t);, +            // terminal error through parent so everything gets cleaned up, including this inner, +            parent.onError(e);, +            // terminal completion to parent so it continues to the next, +            parent.completeInner();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorConcat.java, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +import rx.Producer;, + * @param <T>]