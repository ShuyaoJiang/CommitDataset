[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import scala.concurrent.{Future, ExecutionContext}, +  import scala.util.{Success, Failure}, +  import rx.lang.scala.subjects.AsyncSubject, + /** Returns an Observable emitting the value produced by the Future as its single item., +   * If the future fails, the Observable will fail as well., +   *, +   * @param f Future whose value ends up in the resulting Observable, +   * @return an Observable completed after producing the value of the future, or with an exception, +   */, +  def from[T](f: Future[T])(implicit execContext: ExecutionContext): Observable[T] = {, +    val s = AsyncSubject[T](), +    f.onComplete {, +      case Failure(e) =>, +        s.onError(e), +      case Success(c) =>, +        s.onNext(c), +        s.onCompleted(), +    }, +    s, +  }, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +  import scala.concurrent.{Future, ExecutionContext}, +  import scala.util.{Success, Failure}, +  import rx.lang.scala.subjects.AsyncSubject, + /** Returns an Observable emitting the value produced by the Future as its single item., +   * If the future fails, the Observable will fail as well., +   *, +   * @param f Future whose value ends up in the resulting Observable, +   * @return an Observable completed after producing the value of the future, or with an exception, +   */, +  def from[T](f: Future[T])(implicit execContext: ExecutionContext): Observable[T] = {, +    val s = AsyncSubject[T](), +    f.onComplete {, +      case Failure(e) =>, +        s.onError(e), +      case Success(c) =>, +        s.onNext(c), +        s.onCompleted(), +    }, +    s, +  }, +, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, +import scala.concurrent.{Future, Await}, +import scala.concurrent.duration.Duration, +import scala.concurrent.ExecutionContext.Implicits.global, +  @Test def testFromFuture() {, +    val o = Observable from Future { 5 }, +    assertEquals(5, o.toBlockingObservable.single), +  }, +, +  @Test def testFromFutureWithDelay() {, +    val o = Observable from Future { Thread.sleep(200); 42 }, +    assertEquals(42, o.toBlockingObservable.single), +  }, +, +  @Test def testFromFutureWithError() {, +    val err = new Exception("ooops42"), +    val o: Observable[Int] = Observable from Future { Thread.sleep(200); throw err }, +    assertEquals(List(Notification.OnError(err)), o.materialize.toBlockingObservable.toList), +  }, +, +  @Test def testFromFutureWithSubscribeOnlyAfterCompletion() {, +    val f = Future { Thread.sleep(200); 6 }, +    val o = Observable from f, +    val res = Await.result(f, Duration.Inf), +    assertEquals(6, res), +    assertEquals(6, o.toBlockingObservable.single), +  }, +]