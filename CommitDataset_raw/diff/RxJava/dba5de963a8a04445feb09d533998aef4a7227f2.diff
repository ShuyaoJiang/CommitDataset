[+++ b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package rx.subjects;, +, +import static org.junit.Assert.*;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Test;, +, +import rx.Observable;, +import rx.Observable.OnSubscribeFunc;, +import rx.Observer;, +import rx.Subscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Action1;, +, +public class ReplaySubjectConcurrencyTest {, +, +    public static void main(String args[]) {, +        try {, +            for (int i = 0; i < 100; i++) {, +                new ReplaySubjectConcurrencyTest().testSubscribeCompletionRaceCondition();, +                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscriptions();, +                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther();, +            }, +        } catch (InterruptedException e) {, +            e.printStackTrace();, +        }, +    }, +, +    @Test(timeout = 4000), +    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {, +        final ReplaySubject<Long> replay = ReplaySubject.create();, +        Thread source = new Thread(new Runnable() {, +, +            @Override, +            public void run() {, +                Observable.create(new OnSubscribeFunc<Long>() {, +, +                    @Override, +                    public Subscription onSubscribe(Observer<? super Long> o) {, +                        System.out.println("********* Start Source Data ***********");, +                        for (long l = 1; l <= 10000; l++) {, +                            o.onNext(l);, +                        }, +                        System.out.println("********* Finished Source Data ***********");, +                        o.onCompleted();, +                        return Subscriptions.empty();, +                    }, +                }).subscribe(replay);, +            }, +        });, +        source.start();, +, +        long v = replay.toBlockingObservable().last();, +        assertEquals(10000, v);, +, +        // it's been played through once so now it will all be replays, +        final CountDownLatch slowLatch = new CountDownLatch(1);, +        Thread slowThread = new Thread(new Runnable() {, +, +            @Override, +            public void run() {, +                Observer<Long> slow = new Observer<Long>() {, +, +                    @Override, +                    public void onCompleted() {, +                        System.out.println("*** Slow Observer completed");, +                        slowLatch.countDown();, +                    }, +, +                    @Override, +                    public void onError(Throwable e) {, +                    }, +, +                    @Override, +                    public void onNext(Long args) {, +                        if (args == 1) {, +                            System.out.println("*** Slow Observer STARTED");, +                        }]