[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object that takes an `rx.Observer` private to the Scala bindings package., +, +```scala, +trait Observer[-T] {, +  def onNext(value: T): Unit, +  def onError(error: Throwable): Unit, +  def onCompleted(): Unit, +}, +, +object Observer {...}, +```, +, +To create an instance of say `Observer[SensorEvent]` in user code, you can create a new instance of the `Observer` trait, +and implement any of the methods that you care about:, +```scala, +   val printObserver = new Observer[SensorEvent] {, +      override def onNext(value: SensorEvent): Unit = {...value.toString...}, +      override def onError(error: Throwable): Unit = {...}, +      override def onCompleted(): Unit = {...}, +   }, +```, + or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,, + `onError` or `onCompleted` methods., +, +Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`, +(for instance `subscribe`) usually come with overloads that accept the individual methods, +`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers., +, +While *technically* it is a breaking change make the `asJavaObserver` property private, you should probably not have, +touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`, +call `toJava`., +, +Observable, +----------, +, +Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor, +function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public)., +Again, while *technically* this is a breaking change, this should not have any influence on user code., +, +```scala, +trait Observable[+T] {, +    def subscribe(observer: Observer[T]): Subscription = {...}, +    def apply(observer: Observer[T]): Subscription = {...}, +    ..., +}, +object Observable {, +   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}, +   ..., +}, +```, +, +The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`, +method hindered type inference and made Scala code look unnecessarily different than that in other language bindings., +In fact the only occurence left of `apply` if for the varargs case. All other factory methods now have their own name., +, +* `def apply[T](items: T*): Observable[T]`, +* `def from[T](f: Future[T]): Observable[T]`, +* `def from[T](iterable: Iterable[T]): Observable[T]`, +* `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`, +* `def error[T](exception: Throwable): Observable[T]`, +, +Subject, +-------, +, +The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`, +and takes only a single *invariant* type parameter `T`. all existing implementations of `Subject` are parametrized, +by a single type, and this reflects that reality., +, +```scala, +trait Subject[T] extends Observable[T] with Observer[T] {}, +object Subject {, +   def apply(): Subject[T] = {...}, +}, +```, +For each kind of subject, there is a class with a private constructor and a companion object, +that you should use to create a new kind of subject :, +, +```scala, +object XXXSubject {, +  def apply[T](...): XXXSubject[T] = {...}, +}, +, +class XXXSubject[T] private[scala] (val asJavaSubject: rx.subjects.XXXSubject[T]) extends Subject[T,T] {}]