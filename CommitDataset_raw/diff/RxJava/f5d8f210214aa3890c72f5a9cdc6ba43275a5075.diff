[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.util.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.util.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.util.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.util.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.util.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.util.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.util.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.util.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.util.functions.Action0, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.util.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.util.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.util.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.util.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.util.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.util.functions Action0 Action1 Func0 Func1 Func2])), +(defn synchronize, +  "Synchronize execution., +    rx.Observable/synchronize, +  (.synchronize xs)), +  ([lock ^Observable xs], +  (.synchronize xs lock))), +    rx.Observable/takeFirst, +  (.takeFirst xs)), +    http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.util.functions.Func1), +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, +        //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the namespace is required, you can use the `rx/fn` macro anywhere RxJava wants a `rx.util.functions.Func` object. The syntax is exactly the same as `clojure.core/fn`:, +If you already have a plain old Clojure function you'd like to use, you can pass it to the `rx/fn*` function to get a new object that implements `rx.util.functions.Func`:, +The `rx/action` macro is identical to `rx/fn` except that the object returned implements `rx.util.functions.Action` interfaces. It's used in `subscribe` and other side-effect-y contexts:, +As of 0.17, `rx.Observable/create` takes an implementation of `rx.Observable$OnSubscribe` which is basically an alias for `rx.util.functions.Action1` that takes an `rx.Subscriber` as its argument. Thus, you can just use `rx/action` when creating new observables:, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/chunk.clj, +                                                    (reify rx.util.functions.Action0, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, +           [rx.util.functions Action0 Action1 Func0 Func1 Func2])), +(defn synchronize, +  "Synchronize execution., +    rx.Observable/synchronize, +  (.synchronize xs)), +  ([lock ^Observable xs]]