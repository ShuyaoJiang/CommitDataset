[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperationWhere;, +import rx.subscriptions.BooleanSubscription;, +        this(null);, +            /**, +             * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", +             */, +            if (observer.getClass().getPackage().getName().startsWith("rx")) {, +            });, +            });, +        return create(OperationFilter.filter(that, predicate));, +        return create(OperationWhere.where(that, predicate));, +        return create(OperationDefer.defer(observableFactory));, +        return create(OperationDefer.defer(new Func0<Observable<T>>() {, +        return create(OperationMap.map(sequence, func));, +        return create(OperationMap.mapMany(sequence, func));, +        return create(OperationMaterialize.materialize(sequence));, +        return create(OperationDematerialize.dematerialize(sequence));, +        return create(OperationMerge.merge(source));, +        return create(OperationMerge.merge(source));, +        return create(OperationMerge.merge(source));, +        return create(OperationConcat.concat(source));, +        return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, +        return create(OperatorGroupBy.groupBy(source, keySelector));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationMergeDelayError.mergeDelayError(source));, +        return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(that, resumeFunction));, +        return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(that, resumeSequence));, +        return create(OperationOnErrorReturn.onErrorReturn(that, resumeFunction));, +        return takeLast(create(OperationScan.scan(sequence, accumulator)), 1);, +        return takeLast(create(OperationScan.scan(sequence, initialValue, accumulator)), 1);, +        return create(OperationScan.scan(sequence, accumulator));, +        return create(OperationScan.scan(sequence, initialValue, accumulator));, +     * , +     * @param sequence, +     *            an observable sequence whose elements to apply the predicate to., +     * @param predicate, +     *            a function to test each element for a condition., +     * @param <T>, +     *            the type of observable., +        return create(OperationAll.all(sequence, predicate));, +     * , +     * @param sequence, +     *            an observable sequence whose elements to apply the predicate to., +     * @param predicate, +     *            a function to test each element for a condition., +     * @param <T>, +     *            the type of observable., +        return create(OperationSkip.skip(items, num));, +        return create(OperationSynchronize.synchronize(observable));, +        return create(OperationTake.take(items, num));, +        return create(OperationTakeLast.takeLast(items, count));, +        return create(OperationToObservableList.toObservableList(that));, +        return create(OperationToObservableIterable.toObservableIterable(iterable));, +        return create(OperationToObservableFuture.toObservableFuture(future));, +        return create(OperationToObservableFuture.toObservableFuture(future, time, unit));, +        return create(OperationToObservableSortedList.toSortedList(sequence));, +        return create(OperationToObservableSortedList.toSortedList(sequence, sortFunction));, +        return create(OperationToObservableSortedList.toSortedList(sequence, new Func2<T, T, Integer>() {, +        return create(OperationZip.zip(w0, w1, reduceFunction));, +        return create(OperationZip.zip(w0, w1, w2, function));, +        return create(OperationZip.zip(w0, w1, w2, w3, reduceFunction));, +     * , +     * @param predicate, +     *            a function to test each element for a condition., +     * , +     * @param predicate, +     *            a function to test each element for a condition., +        /**, +         * The error from the user provided Observer is not handled by the subscribe method try/catch., +         * , +         * It is handled by the AtomicObserver that wraps the provided Observer., +         * , +         * Result: Passes (if AtomicObserver functionality exists), +         */, +        @Test, +        public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {, +            final CountDownLatch latch = new CountDownLatch(1);, +            final AtomicInteger count = new AtomicInteger();, +            final AtomicReference<Exception> error = new AtomicReference<Exception>();, +            Observable.create(new Func1<Observer<String>, Subscription>() {, +, +                @Override, +                public Subscription call(final Observer<String> observer) {, +                    final BooleanSubscription s = new BooleanSubscription();, +                    new Thread(new Runnable() {, +, +                        @Override, +                        public void run() {, +                            try {, +                                if (!s.isUnsubscribed()) {, +                                    observer.onNext("1");, +                                    observer.onNext("2");, +                                    observer.onNext("three");, +                                    observer.onNext("4");, +                                    observer.onCompleted();]