[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java, +import static com.bumptech.glide.test.Matchers.anyBitmap;, +import static com.bumptech.glide.test.Matchers.anyBitmapTarget;, +import static com.bumptech.glide.test.Matchers.anyDrawable;, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +import static org.mockito.Mockito.verify;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;, +import com.bumptech.glide.load.engine.cache.LruResourceCache;, +import com.bumptech.glide.request.RequestListener;, +import com.bumptech.glide.util.Util;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +  @Mock private RequestListener<Bitmap> bitmapListener;, +  @Mock private RequestListener<Drawable> drawableListener;, +, +    MockitoAnnotations.initMocks(this);, +  @Test, +  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10)), +        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .load(bitmap), +                .centerCrop(), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    assertThat(bitmap.isRecycled()).isFalse();, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context), +            .load(bitmap), +            .centerCrop(), +            .listener(drawableListener), +            .submit(100, 100));, +, +    verify(drawableListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyDrawableTarget(),, +            eq(DataSource.LOCAL),, +            anyBoolean());, +  }, +, +  @Test, +  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10)), +        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .asDrawable(), +                .load(bitmap), +                .centerCrop(), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    assertThat(bitmap.isRecycled()).isFalse();, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context)]