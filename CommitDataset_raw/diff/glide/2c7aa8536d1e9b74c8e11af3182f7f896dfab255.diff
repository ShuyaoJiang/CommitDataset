[+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +import android.os.Handler;, +import android.os.Handler.Callback;, +import android.os.Message;, +import android.os.Process;, +import com.bumptech.glide.util.Util;, +import java.util.concurrent.TimeUnit;, +  private static final int MSG_CLEAN_REF = 1;, +, +  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {, +    @Override, +    public boolean handleMessage(Message msg) {, +      if (msg.what == MSG_CLEAN_REF) {, +        cleanupActiveReference((ResourceWeakReference) msg.obj);, +        return true;, +      }, +      return false;, +    }, +  });, +, +  private ResourceListener listener;, +, +  @Nullable, +  private Thread cleanReferenceQueueThread;, +  private volatile boolean isShutdown;, +  @Nullable, +  private volatile DequeuedResourceCallback cb;, +    Util.assertMainThread();, +      cleanReferenceQueueThread = new Thread(new Runnable() {, +        @SuppressWarnings("InfiniteLoopStatement"), +        @Override, +        public void run() {, +          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);, +          ResourceWeakReference ref;, +          while (!isShutdown) {, +            try {, +              ref = (ResourceWeakReference) resourceReferenceQueue.remove();, +              mainHandler.obtainMessage(MSG_CLEAN_REF, ref).sendToTarget();, +, +              // This section for testing only., +              DequeuedResourceCallback current = cb;, +              if (current != null) {, +                current.onResourceDequeued();, +              }, +              // End for testing only., +            } catch (InterruptedException e) {, +              Thread.currentThread().interrupt();, +            }, +          }, +        }, +      }, "glide-active-resources");, +      cleanReferenceQueueThread.start();, +  @VisibleForTesting, +  void setEnqueuedResourceCallback(DequeuedResourceCallback cb) {, +    this.cb = cb;, +, +  @VisibleForTesting, +  interface DequeuedResourceCallback {, +    void onResourceDequeued();, +  }, +, +  @VisibleForTesting, +  void shutdown() {, +    isShutdown = true;, +    if (cleanReferenceQueueThread == null) {, +      return;, +    }, +, +    cleanReferenceQueueThread.interrupt();, +    try {, +      cleanReferenceQueueThread.join(TimeUnit.SECONDS.toMillis(5));, +      if (cleanReferenceQueueThread.isAlive()) {, +        throw new RuntimeException("Failed to join in time");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +import android.os.Handler;, +import android.os.Handler.Callback;, +import android.os.Message;, +import android.os.Process;, +import com.bumptech.glide.util.Util;, +import java.util.concurrent.TimeUnit;, +  private static final int MSG_CLEAN_REF = 1;, +, +  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {, +    @Override, +    public boolean handleMessage(Message msg) {, +      if (msg.what == MSG_CLEAN_REF) {, +        cleanupActiveReference((ResourceWeakReference) msg.obj);, +        return true;, +      }, +      return false;, +    }, +  });, +, +  private ResourceListener listener;, +, +  @Nullable, +  private Thread cleanReferenceQueueThread;]