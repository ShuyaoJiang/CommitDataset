[+++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                return resizer.loadAsIs(is1);, +                return resizer.loadAtLeast(is1, width, height);, +                return resizer.centerCrop(is1, width, height);, +                return resizer.fitInSpace(is1, width, height);, +                        Bitmap result = resizer.loadAsIs(is1);, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                return resizer.loadAsIs(is1);, +                return resizer.loadAtLeast(is1, width, height);, +                return resizer.centerCrop(is1, width, height);, +                return resizer.fitInSpace(is1, width, height);, +                        Bitmap result = resizer.loadAsIs(is1);, +++ b/library/src/com/bumptech/glide/resize/ImageResizer.java, +    private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb, +    private static final int MARK_POSITION = 5 * 1024 * 1024; //5mb, +    public Bitmap centerCrop(InputStream is1, int width, int height) {, +        final Bitmap streamed = loadAtLeast(is1, width, height);, +    public Bitmap fitInSpace(InputStream is1, int width, int height) {, +        final Bitmap streamed = loadAtLeast(is1, width > height ? 1 : width, height > width ? 1 : height);, +        Bitmap result = loadAtLeast(new FileInputStream(path), width, height);, +     * @param is1 An inputStream for the image, +    public Bitmap loadAtLeast(InputStream is1, int width, int height) {, +        byte[] bytes = getTempBytes();, +        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is1, bytes);, +        final int[] dimens = getDimensions(bis);, +        Bitmap result = decodeStream(bis, decodeBitmapOptions);, +        releaseTempBytes(bytes);, +        return result;, +    public Bitmap loadAtMost(InputStream is, int width, int height) {, +        byte[] bytes = getTempBytes();, +        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);, +        final int[] dimens = getDimensions(bis);, +        Bitmap result = decodeStream(bis, decodeBitmapOptions);, +        releaseTempBytes(bytes);, +        return result;, +     * @param is The InputStream used to get the dimensions of the image, +    public Bitmap loadAsIs(final InputStream is) {, +        byte[] bytes = getTempBytes();, +        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);, +        int[] dimens = getDimensions(bis);, +        Bitmap result = load(bis, getRecycled(dimens));, +        releaseTempBytes(bytes);, +        return result;, +        byte[] bytes = getTempBytes();, +        Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));, +        releaseTempBytes(bytes);, +        return result;, +    private Bitmap load(RecyclableBufferedInputStream is, Bitmap recycle){, +    private int[] getDimensions(RecyclableBufferedInputStream is) {, +        RecyclableBufferedInputStream is = null;, +            byte[] bytes = getTempBytes();, +            is = new RecyclableBufferedInputStream(new FileInputStream(path), bytes);, +            releaseTempBytes(bytes);, +    private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {, +        decodeBitmapOptions.inTempStorage = getTempBytes();, +, +        if (decodeBitmapOptions.inJustDecodeBounds) {, +            bis.mark(MARK_POSITION); //this is absurdly large, but jpeg headers are not size bounded so we need, +                                     //something large enough to minimize the possibility of not being able to fit, +                                     //enough of the header in the buffer to get the image size so that we don't fail, +                                     //to load images. The BufferedInputStream will create a new buffer of 2x the, +                                     //original size each time we use up the buffer space without passing the mark so, +                                     //this is a maximum bound on the buffer size, not a default. Most of the time we, +                                     //won't go past our pre-allocated 32kb, +        }, +        final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);, +            if (decodeBitmapOptions.inJustDecodeBounds) {, +                bis.reset();, +            } else {, +            }, +, +        releaseTempBytes(decodeBitmapOptions.inTempStorage);, +, +    private byte[] getTempBytes() {, +        byte[] result;, +            result = tempQueue.poll();, +        }, +        if (result == null) {, +            result = new byte[TEMP_BYTES_SIZE];, +    private void releaseTempBytes(byte[] bytes) {, +            tempQueue.offer(bytes);, +        }]