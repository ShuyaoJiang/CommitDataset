[+++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +     *, +     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this, +     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead., +     *, +     * @param keyBytes The bytes of the {@link String} used as the key for this particular, +     * {@link Option}. Should be added to the {@code messageDigest} using, +     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with, +     * the given {@code value} parameter., +     *, +     * @param value The value of of this particular option. Typically you should convert the value, +     * to a byte array using some stable mechanism and then call, +     * {@link MessageDigest#update(byte[])} to update the given digest., +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +     *, +     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this, +     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead., +     *, +     * @param keyBytes The bytes of the {@link String} used as the key for this particular, +     * {@link Option}. Should be added to the {@code messageDigest} using, +     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with, +     * the given {@code value} parameter., +     *, +     * @param value The value of of this particular option. Typically you should convert the value, +     * to a byte array using some stable mechanism and then call, +     * {@link MessageDigest#update(byte[])} to update the given digest., +++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java, +import com.bumptech.glide.tests.KeyTester;, +import org.junit.Rule;, +  @Rule public final KeyTester keyTester = new KeyTester();, +, +    doAnswer(new Util.WriteDigest("first")).when(first), +        .updateDiskCacheKey(any(MessageDigest.class));, +    doAnswer(new Util.WriteDigest("second")).when(second), +        .updateDiskCacheKey(any(MessageDigest.class));, +    keyTester, +        .addEquivalenceGroup(, +            new MultiTransformation<>(first),, +            new MultiTransformation<>(first)), +        .addEquivalenceGroup(new MultiTransformation<>(second)), +        .addEquivalenceGroup(new MultiTransformation<>(first, second)), +        .addEquivalenceGroup(new MultiTransformation<>(second, first)), +        .addRegressionTest(, +            new MultiTransformation<>(first),, +            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e"), +        .addRegressionTest(, +            new MultiTransformation<>(first, second),, +            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2"), +        .test();, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +     *, +     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this, +     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead., +     *, +     * @param keyBytes The bytes of the {@link String} used as the key for this particular, +     * {@link Option}. Should be added to the {@code messageDigest} using, +     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with, +     * the given {@code value} parameter., +     *, +     * @param value The value of of this particular option. Typically you should convert the value, +     * to a byte array using some stable mechanism and then call, +     * {@link MessageDigest#update(byte[])} to update the given digest., +++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java, +import com.bumptech.glide.tests.KeyTester;, +import org.junit.Rule;, +  @Rule public final KeyTester keyTester = new KeyTester();, +, +    doAnswer(new Util.WriteDigest("first")).when(first), +        .updateDiskCacheKey(any(MessageDigest.class));, +    doAnswer(new Util.WriteDigest("second")).when(second), +        .updateDiskCacheKey(any(MessageDigest.class));, +    keyTester, +        .addEquivalenceGroup(, +            new MultiTransformation<>(first),, +            new MultiTransformation<>(first)), +        .addEquivalenceGroup(new MultiTransformation<>(second)), +        .addEquivalenceGroup(new MultiTransformation<>(first, second)), +        .addEquivalenceGroup(new MultiTransformation<>(second, first)), +        .addRegressionTest(, +            new MultiTransformation<>(first),, +            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e"), +        .addRegressionTest(, +            new MultiTransformation<>(first, second),, +            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2"), +        .test();, +++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java, +import com.bumptech.glide.tests.KeyTester;, +import org.junit.Rule;, +  @Rule public final KeyTester keyTester = new KeyTester();, +  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {, +    keyTester, +        .addEquivalenceGroup(, +            new DataCacheKey(firstKey, firstSignature),, +            new DataCacheKey(firstKey, firstSignature)), +        .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature)), +        .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature)), +        .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature)), +        .addRegressionTest(, +            new DataCacheKey(firstKey, firstSignature),, +            "801d7440d65a0e7c9ad0097d417f346dac4d4c4d5630724110fa3f3fe66236d9")]