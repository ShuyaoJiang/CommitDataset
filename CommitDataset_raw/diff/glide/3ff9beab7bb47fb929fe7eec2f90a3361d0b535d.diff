[+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.load.data.DataFetcher.DataCallback;, +import com.bumptech.glide.util.Preconditions;, +import java.util.ArrayList;, +/**, + * Allows attempting multiple ModelLoaders registered for a given model and data class., + *, + * <p> TODO: we should try to find a way to remove this class. It exists to allow individual, + * ModelLoaders to delegate to multiple ModelLoaders without having to duplicate this logic, + * everywhere. We have very similar logic in the {@link, + * com.bumptech.glide.load.engine.DataFetcherGenerator} implementations and should try to avoid this, + * duplication. </p>, + */, +    Key sourceKey = null;, +    List<DataFetcher<Data>> fetchers = new ArrayList<>();, +        LoadData<Data> loadData = modelLoader.buildLoadData(model, width, height, options);, +        if (loadData != null) {, +          sourceKey = loadData.sourceKey;, +          fetchers.add(loadData.fetcher);, +    return !fetchers.isEmpty() ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers)) : null;, +, +  static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {, +, +    private final List<DataFetcher<Data>> fetchers;, +    private int currentIndex;, +    private Priority priority;, +    private DataCallback<? super Data> callback;, +, +    MultiFetcher(List<DataFetcher<Data>> fetchers) {, +      Preconditions.checkNotEmpty(fetchers);, +      this.fetchers = fetchers;, +      currentIndex = 0;, +    }, +, +    @Override, +    public void loadData(Priority priority, DataCallback<? super Data> callback) {, +      this.priority = priority;, +      this.callback = callback;, +      fetchers.get(currentIndex).loadData(priority, this);, +    }, +, +    @Override, +    public void cleanup() {, +      for (DataFetcher<Data> fetcher : fetchers) {, +        fetcher.cleanup();, +      }, +    }, +, +    @Override, +    public void cancel() {, +      for (DataFetcher<Data> fetcher : fetchers) {, +        fetcher.cancel();, +      }, +    }, +, +    @Override, +    public Class<Data> getDataClass() {, +      return fetchers.get(0).getDataClass();, +    }, +, +    @Override, +    public DataSource getDataSource() {, +      return fetchers.get(0).getDataSource();, +    }, +, +    @Override, +    public void onDataReady(Data data) {, +      if (data != null) {, +        callback.onDataReady(data);, +      } else if (currentIndex < fetchers.size() - 1) {, +        currentIndex++;, +        loadData(priority, callback);, +      } else {, +        callback.onDataReady(null /*data*/);, +      }, +    }, +  }]