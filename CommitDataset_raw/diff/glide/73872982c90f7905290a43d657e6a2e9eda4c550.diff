[+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java, +  @VisibleForTesting, +  static final String TAG = "PreFillRunner";, +  public BitmapPreFillRunner(, +      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {, +    this(, +        bitmapPool,, +        memoryCache,, +        allocationOrder,, +        DEFAULT_CLOCK,, +  BitmapPreFillRunner(, +      BitmapPool bitmapPool,, +      MemoryCache memoryCache,, +      PreFillQueue allocationOrder,, +      Clock clock,, +      Handler handler) {, +  @VisibleForTesting, +  boolean allocate() {, +        bitmap =, +            bitmapPool.getDirty(, +                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());, +        bitmap =, +            Bitmap.createBitmap(, +                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());, +      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be, +      // recycled after the call to bitmapPool#put below., +      int bitmapSize = Util.getBitmapByteSize(bitmap);, +, +      // not empty so that we use all available space., +      if (getFreeMemoryCacheBytes() >= bitmapSize) {, +            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] ", +                + toAllocate.getConfig() + " size: " + bitmapSize);, +  private static final class UniqueKey implements Key {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java, +  @VisibleForTesting, +  static final String TAG = "PreFillRunner";, +  public BitmapPreFillRunner(, +      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {, +    this(, +        bitmapPool,, +        memoryCache,, +        allocationOrder,, +        DEFAULT_CLOCK,, +  BitmapPreFillRunner(, +      BitmapPool bitmapPool,, +      MemoryCache memoryCache,, +      PreFillQueue allocationOrder,, +      Clock clock,, +      Handler handler) {, +  @VisibleForTesting, +  boolean allocate() {, +        bitmap =, +            bitmapPool.getDirty(, +                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());, +        bitmap =, +            Bitmap.createBitmap(, +                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());, +      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be, +      // recycled after the call to bitmapPool#put below., +      int bitmapSize = Util.getBitmapByteSize(bitmap);, +, +      // not empty so that we use all available space., +      if (getFreeMemoryCacheBytes() >= bitmapSize) {, +            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] ", +                + toAllocate.getConfig() + " size: " + bitmapSize);, +  private static final class UniqueKey implements Key {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java, +import android.util.Log;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import org.robolectric.shadows.ShadowLog;, +  @Test, +  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {, +    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);, +, +    int dimensions = 10;, +    Bitmap.Config config = Bitmap.Config.ARGB_8888;, +    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);, +    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();, +    Map<PreFillType, Integer> allocationOrder = new HashMap<>();, +    allocationOrder.put(preFillType, 1);, +    PreFillQueue queue = new PreFillQueue(allocationOrder);, +    BitmapPreFillRunner runner =, +        new BitmapPreFillRunner(, +            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);, +, +    runner.allocate();, +  }, +]