[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.reset;, +import android.view.ViewGroup.LayoutParams;, +import android.widget.ImageView;, +import org.mockito.ArgumentMatchers;, +, +  @Test, +  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(),, +        imageView);, +, +    // Casting avoids a varags array warning., +    reset((RequestListener) requestListener);, +, +    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we, +    // do end up re-using the old Target, our wait will always timeout anyway if we use, +    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener, +    // below, which expects to be called synchronously., +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {, +            GlideApp.with(context), +                .load(ResourceIds.raw.canonical), +                .listener(requestListener), +                .dontTransform(), +                .into(imageView);, +          }, +        });, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            ArgumentMatchers.any(),, +            anyDrawableTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(), +            .skipMemoryCache(true),, +        imageView);, +, +    // Casting avoids a varags array warning., +    reset((RequestListener) requestListener);, +, +    // If this test fails due to a timeout, it's because we re-used the Target from the previous, +    // request, which breaks the logic in loadOnMainThread that expects a new Target's, +    // onResourceReady callback to be called. This can be confirmed by changing this to, +    // runOnMainThread and verifying that the RequestListener assertion below fails because, +    // the DataSource was from the memory cache., +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(), +            .skipMemoryCache(true),, +        imageView);, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            ArgumentMatchers.any(),, +            anyDrawableTarget(),, +            not(eq(DataSource.MEMORY_CACHE)),, +            anyBoolean());, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.reset;, +import android.view.ViewGroup.LayoutParams;, +import android.widget.ImageView;, +import org.mockito.ArgumentMatchers;, +, +  @Test, +  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(),]