[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.TargetApi;, +    @TargetApi(12), +            if (Build.VERSION.SDK_INT >= 12) {, +                result.setHasAlpha(true);, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.TargetApi;, +    @TargetApi(12), +            if (Build.VERSION.SDK_INT >= 12) {, +                result.setHasAlpha(true);, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +, +        /**, +         * Note - Using the disk cache can potentially cause frames to be decoded incorrectly because the decoder is, +         * sequential. If earlier frames are evicted for some reason, later ones may then not be decoded correctly., +         */, +, +        // We can decode non transparent (cached as jpegs) frames more quickly from cache, but transparent, +        // (cached as png) frames more quickly from the gif data., +        boolean skipDiskCache = decoder.isTransparent();, +                .diskCacheStrategy(skipDiskCache ? DiskCacheStrategy.NONE : DiskCacheStrategy.RESULT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.TargetApi;, +    @TargetApi(12), +            if (Build.VERSION.SDK_INT >= 12) {, +                result.setHasAlpha(true);, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +, +        /**, +         * Note - Using the disk cache can potentially cause frames to be decoded incorrectly because the decoder is, +         * sequential. If earlier frames are evicted for some reason, later ones may then not be decoded correctly., +         */, +, +        // We can decode non transparent (cached as jpegs) frames more quickly from cache, but transparent, +        // (cached as png) frames more quickly from the gif data., +        boolean skipDiskCache = decoder.isTransparent();, +                .diskCacheStrategy(skipDiskCache ? DiskCacheStrategy.NONE : DiskCacheStrategy.RESULT), +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        GifHeader gifHeader = new GifHeader();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.TargetApi;, +    @TargetApi(12), +            if (Build.VERSION.SDK_INT >= 12) {, +                result.setHasAlpha(true);, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +, +        /**, +         * Note - Using the disk cache can potentially cause frames to be decoded incorrectly because the decoder is, +         * sequential. If earlier frames are evicted for some reason, later ones may then not be decoded correctly., +         */, +, +        // We can decode non transparent (cached as jpegs) frames more quickly from cache, but transparent, +        // (cached as png) frames more quickly from the gif data., +        boolean skipDiskCache = decoder.isTransparent();, +                .diskCacheStrategy(skipDiskCache ? DiskCacheStrategy.NONE : DiskCacheStrategy.RESULT), +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        GifHeader gifHeader = new GifHeader();, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java, +package com.bumptech.glide.samples.giphy;, +, +import android.content.Context;, +, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;, +, +import java.io.InputStream;, +, +public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {, +    public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {, +, +        @Override, +        public ModelLoader<Api.GifResult, InputStream> build(Context context, GenericLoaderFactory factories) {, +            return new GiphyModelLoader(context);, +        }, +, +        @Override, +        public void teardown() {, +            // Do nothing., +        }, +    }, +, +    public GiphyModelLoader(Context context) {, +        super(context);, +    }, +, +    @Override, +    protected String getUrl(Api.GifResult model, int width, int height) {, +        Api.GifImage fixedHeight = model.images.fixed_height_downsampled;, +        int fixedHeightDifference = getDifference(fixedHeight, width, height);, +        Api.GifImage fixedWidth = model.images.fixed_width_downsampled;, +        int fixedWidthDifference = getDifference(fixedWidth, width, height);]