[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame;, +    } else {, +      previousFrame = header.frames.get(getFrameCount() - 1);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame;, +    } else {, +      previousFrame = header.frames.get(getFrameCount() - 1);, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import static org.junit.Assert.assertTrue;, +import static org.robolectric.Shadows.shadowOf;, +import org.robolectric.annotation.Implementation;, +import org.robolectric.annotation.Implements;, +import org.robolectric.shadows.ShadowBitmap;, +import java.util.Arrays;, +  @Test, +  @Config(shadows = { CustomShadowBitmap.class }), +  public void testFirstFrameMustUsingLastFrameDispose() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_dispose.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new GifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap firstFrame = decoder.getNextFrame();, +    decoder.advance();, +    decoder.getNextFrame();, +    decoder.advance();, +    Bitmap firstFrameTwice = decoder.getNextFrame();, +    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),, +        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));, +  }, +, +  /**, +   * Preserve generated bitmap data for checking., +   */, +  @Implements(Bitmap.class), +  public static class CustomShadowBitmap extends ShadowBitmap {, +, +    private int[] pixels;, +, +    @Implementation, +    public void setPixels(int[] pixels, int offset, int stride,, +        int x, int y, int width, int height) {, +      this.pixels = new int[pixels.length];, +      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);, +    }, +, +    public int[] getPixels() {, +      return pixels;, +    }, +  }, +, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame;, +    } else {, +      previousFrame = header.frames.get(getFrameCount() - 1);, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import static org.junit.Assert.assertTrue;, +import static org.robolectric.Shadows.shadowOf;, +import org.robolectric.annotation.Implementation;, +import org.robolectric.annotation.Implements;, +import org.robolectric.shadows.ShadowBitmap;, +import java.util.Arrays;, +  @Test, +  @Config(shadows = { CustomShadowBitmap.class }), +  public void testFirstFrameMustUsingLastFrameDispose() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_dispose.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new GifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap firstFrame = decoder.getNextFrame();, +    decoder.advance();, +    decoder.getNextFrame();, +    decoder.advance();, +    Bitmap firstFrameTwice = decoder.getNextFrame();, +    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),, +        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));, +  }, +, +  /**, +   * Preserve generated bitmap data for checking., +   */, +  @Implements(Bitmap.class), +  public static class CustomShadowBitmap extends ShadowBitmap {, +, +    private int[] pixels;, +, +    @Implementation, +    public void setPixels(int[] pixels, int offset, int stride,, +        int x, int y, int width, int height) {, +      this.pixels = new int[pixels.length];, +      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);, +    }, +, +    public int[] getPixels() {]