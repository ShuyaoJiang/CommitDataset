[+++ b/src/com/bumptech/photos/PhotoManager.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();, +    private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();, +        memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {, +            @Override, +            public void onPhotoRemoved(String key, Bitmap bitmap) {, +                Log.d("RECYCLE: onPhotoRemoved key=" + key + " bitmap=" + bitmap);, +                releaseBitmap(bitmap);, +            }, +        });, +                memoryCache.put(key, resized);, +                acquireBitmap(resized);, +, +    public void acquireBitmap(Bitmap b) {, +        if (!b.isMutable()) return;, +, +        Integer currentCount = bitmapReferenceCounter.get(b);, +        if (currentCount == null) {, +            currentCount = 0;, +        bitmapReferenceCounter.put(b, currentCount+1);, +    }, +, +    public void releaseBitmap(Bitmap b) {, +        if (!b.isMutable()) return;, +, +        Integer currentCount = bitmapReferenceCounter.get(b);, +        currentCount--;, +        if (currentCount == 0) {, +            bitmapReferenceCounter.remove(b);, +            final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());, +            Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);, +            if (available == null) {, +                available = new LinkedList<Bitmap>();, +                recycledBitmapsForSize.put(sizeKey, available);, +            }, +            available.add(b);, +        } else {, +            bitmapReferenceCounter.put(b, currentCount);, +        }, +    }, +, +    private static String getSizeKey(int width, int height) {, +        return "_" + width + "_" + height;, +        return sha1Hash(path) + getSizeKey(width, height);, +++ b/src/com/bumptech/photos/PhotoManager.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();, +    private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();, +        memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {, +            @Override, +            public void onPhotoRemoved(String key, Bitmap bitmap) {, +                Log.d("RECYCLE: onPhotoRemoved key=" + key + " bitmap=" + bitmap);, +                releaseBitmap(bitmap);, +            }, +        });, +                memoryCache.put(key, resized);, +                acquireBitmap(resized);, +, +    public void acquireBitmap(Bitmap b) {, +        if (!b.isMutable()) return;, +, +        Integer currentCount = bitmapReferenceCounter.get(b);, +        if (currentCount == null) {, +            currentCount = 0;, +        bitmapReferenceCounter.put(b, currentCount+1);, +    }, +, +    public void releaseBitmap(Bitmap b) {, +        if (!b.isMutable()) return;, +, +        Integer currentCount = bitmapReferenceCounter.get(b);, +        currentCount--;, +        if (currentCount == 0) {, +            bitmapReferenceCounter.remove(b);, +            final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());, +            Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);, +            if (available == null) {, +                available = new LinkedList<Bitmap>();, +                recycledBitmapsForSize.put(sizeKey, available);, +            }, +            available.add(b);, +        } else {, +            bitmapReferenceCounter.put(b, currentCount);, +        }, +    }, +, +    private static String getSizeKey(int width, int height) {, +        return "_" + width + "_" + height;, +        return sha1Hash(path) + getSizeKey(width, height);, +++ b/src/com/bumptech/photos/cache/LruPhotoCache.java, +    private PhotoRemovedListener photoRemovedListener;, +, +    public interface PhotoRemovedListener {, +        public void onPhotoRemoved(String key, Bitmap bitmap);, +    }, +, +        @Override]