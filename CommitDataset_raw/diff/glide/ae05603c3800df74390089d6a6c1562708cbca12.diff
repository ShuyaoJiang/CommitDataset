[+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +     * <p>, +     *     Note - this method will throw an exception of a Bitmap with dimensions not matching, +     *     those of the image for the given InputStream is provided., +     * </p>, +     * @param is An {@link InputStream} to the data for the image, +    @SuppressWarnings("resource"), +    // see BitmapDecoder.decode, +        final byte[] bytesForOptions = byteArrayPool.getBytes();, +        final byte[] bytesForStream = byteArrayPool.getBytes();, +        final BitmapFactory.Options options = getDefaultOptions();, +        final RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytesForStream);, +        try {, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot determine the image orientation from header", e);, +            } finally {, +                    if (Log.isLoggable(TAG, Log.WARN)) {, +                        Log.w(TAG, "Cannot reset the input stream", e);, +                    }, +                }, +            final Bitmap downsampled =, +                    downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize, decodeFormat);, +            return rotated;, +        } finally {, +        }, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Cannot determine the image type from header", e);, +            }, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot reset the input stream", e);, +                }, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);, +            }, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot reset the input stream", e);, +                }, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +     * <p>, +     *     Note - this method will throw an exception of a Bitmap with dimensions not matching, +     *     those of the image for the given InputStream is provided., +     * </p>, +     * @param is An {@link InputStream} to the data for the image, +    @SuppressWarnings("resource"), +    // see BitmapDecoder.decode, +        final byte[] bytesForOptions = byteArrayPool.getBytes();, +        final byte[] bytesForStream = byteArrayPool.getBytes();, +        final BitmapFactory.Options options = getDefaultOptions();, +        final RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytesForStream);, +        try {, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot determine the image orientation from header", e);, +            } finally {, +                    if (Log.isLoggable(TAG, Log.WARN)) {, +                        Log.w(TAG, "Cannot reset the input stream", e);, +                    }, +                }, +            final Bitmap downsampled =, +                    downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize, decodeFormat);, +            return rotated;, +        } finally {]