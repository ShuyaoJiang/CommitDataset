[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    TransformationUtils.getBitmapDrawableLock().lock();, +    } finally {, +      TransformationUtils.getBitmapDrawableLock().unlock();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    TransformationUtils.getBitmapDrawableLock().lock();, +    } finally {, +      TransformationUtils.getBitmapDrawableLock().unlock();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +, +  /**, +   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap, +   * drawing is not thread safe., +   * This lock only locks for these specific devices. For other types of devices the lock is always, +   * available and therefore does not impact performance, +   */, +  private static final Lock BITMAP_DRAWABLE_LOCK = "XT1097".equals(Build.MODEL), +      && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1, +      ? new ReentrantLock(), +      : new NoLock();, +, +, +  public static Lock getBitmapDrawableLock() {, +    return BITMAP_DRAWABLE_LOCK;, +  }, +, +    applyMatrix(inBitmap, result, m);, +    applyMatrix(inBitmap, toReuse, matrix);, +    applyMatrix(inBitmap, result, matrix);, +, +    BITMAP_DRAWABLE_LOCK.lock();, +    try {, +      Canvas canvas = new Canvas(result);, +    } finally {, +      BITMAP_DRAWABLE_LOCK.unlock();, +    }, +    BITMAP_DRAWABLE_LOCK.lock();, +    try {, +    } finally {, +      BITMAP_DRAWABLE_LOCK.unlock();, +    }, +  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,, +      Matrix matrix) {, +    BITMAP_DRAWABLE_LOCK.lock();, +    try {, +      Canvas canvas = new Canvas(targetBitmap);, +      canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +      clear(canvas);, +    } finally {, +      BITMAP_DRAWABLE_LOCK.unlock();, +    }, +  }, +, +, +  private static final class NoLock implements Lock {, +    @Override, +    public void lock() {, +      // do nothing, +    }, +, +    @Override, +    public void lockInterruptibly() throws InterruptedException {, +      // do nothing, +    }, +, +    @Override, +    public boolean tryLock() {, +      return true;, +    }, +, +    @Override, +    public boolean tryLock(long time, @NonNull TimeUnit unit) throws InterruptedException {, +      return true;, +    }, +, +    @Override, +    public void unlock() {, +      // do nothing, +    }, +, +    @NonNull, +    @Override, +    public Condition newCondition() {, +      throw new UnsupportedOperationException("Should not be called");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    TransformationUtils.getBitmapDrawableLock().lock();, +    } finally {, +      TransformationUtils.getBitmapDrawableLock().unlock();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +]