[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +   * Determines if the GIF is animated by trying to read in the first 2 frames, +   * This method reparses the data even if the header has already been read, +   */, +  public boolean isAnimated() {, +    readHeader();, +    if (!err()) {, +      readContents(2 /* maxFrames */);, +    }, +    return header.frameCount > 1;, +  }, +, +  /**, +    readContents(Integer.MAX_VALUE /* maxFrames */);, +  }, +, +  /**, +   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames, +   */, +  private void readContents(int maxFrames) {, +    while (!(done || err() || header.frameCount > maxFrames)) {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +   * Determines if the GIF is animated by trying to read in the first 2 frames, +   * This method reparses the data even if the header has already been read, +   */, +  public boolean isAnimated() {, +    readHeader();, +    if (!err()) {, +      readContents(2 /* maxFrames */);, +    }, +    return header.frameCount > 1;, +  }, +, +  /**, +    readContents(Integer.MAX_VALUE /* maxFrames */);, +  }, +, +  /**, +   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames, +   */, +  private void readContents(int maxFrames) {, +    while (!(done || err() || header.frameCount > maxFrames)) {, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +import static org.junit.Assert.assertTrue;, +  @Test, +  public void testIsAnimatedMultipleFrames() {, +    final int lzwMinCodeSize = 2;, +    final int numFrames = 3;, +, +    final int frameSize =, +        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);, +    ByteBuffer buffer =, +        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize), +            .order(ByteOrder.LITTLE_ENDIAN);, +, +    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +    for (int i = 0; i < numFrames; i++) {, +      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);, +      GifBytesTestUtil.writeFakeImageData(buffer, 2);, +    }, +, +    parser.setData(buffer.array());, +    assertTrue(parser.isAnimated());, +  }, +, +  @Test, +  public void testIsNotAnimatedOneFrame() {, +    final int lzwMinCodeSize = 2;, +, +    final int frameSize =, +        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);, +, +    ByteBuffer buffer =, +        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize), +            .order(ByteOrder.LITTLE_ENDIAN);, +, +    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);, +    GifBytesTestUtil.writeFakeImageData(buffer, 2);, +, +    parser.setData(buffer.array());, +    assertFalse(parser.isAnimated());, +  }, +, +]