[+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +  // Used when we realize we're cancelled on a background thread in reschedule and can recycle, +  // immediately rather than waiting for a result or an error., +  private static final int MSG_CANCELLED = 3;, +  private final StateVerifier stateVerifier = new DefaultStateVerifier();, +, +, +  // Checked primarily on the main thread, but also on other threads in reschedule., +  private volatile boolean isCancelled;, +    stateVerifier.setRecycled(false /*isReleased*/);, +    stateVerifier.throwIfRecycled();, +    stateVerifier.throwIfRecycled();, +    stateVerifier.throwIfRecycled();, +    } else if (hasResource) {, +      throw new IllegalStateException("Already have resource");, +  private void handleCancelledOnMainThread() {, +    stateVerifier.throwIfRecycled();, +    if (!isCancelled) {, +      throw new IllegalStateException("Not cancelled");, +    }, +    listener.onEngineJobCancelled(this, key);, +    release();, +  }, +, +    Util.assertMainThread();, +    stateVerifier.setRecycled(true /*isReleased*/);, +      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();, +    stateVerifier.throwIfRecycled();, +    } else if (hasLoadFailed) {, +      throw new IllegalStateException("Already failed once");, +      switch (message.what) {, +        case MSG_COMPLETE:, +          break;, +        case MSG_EXCEPTION:, +          break;, +        case MSG_CANCELLED:, +          job.handleCancelledOnMainThread();, +          break;, +        default:, +          throw new IllegalStateException("Unrecognized message: " + message.what);, +  }, +  /**, +   * Verifies that the job is not in the recycled state., +   */, +  private interface StateVerifier {, +    void throwIfRecycled();, +    void setRecycled(boolean isRecycled);, +  }, +, +  private static class DefaultStateVerifier implements StateVerifier {, +, +    private boolean isReleased;, +, +    @Override, +    public void throwIfRecycled() {, +      if (isReleased) {, +        throw new IllegalStateException("Already released");, +      }, +    }, +, +    @Override, +    public void setRecycled(boolean isRecycled) {, +      this.isReleased = isRecycled;, +    }, +  }, +, +  // Used for debugging., +  @SuppressWarnings("unused"), +  private static class DebugStateVerifier implements StateVerifier {, +, +    // Keeps track of the stack trace where our state was set to recycled., +    private RuntimeException recycledAtStackTraceException;, +, +    @Override, +    public void throwIfRecycled() {, +      if (recycledAtStackTraceException != null) {, +        throw new IllegalStateException("Already released", recycledAtStackTraceException);, +      }, +    }, +, +    @Override, +    public void setRecycled(boolean isRecycled) {, +      if (isRecycled) {, +        this.recycledAtStackTraceException = new RuntimeException("Released");, +      } else {, +        this.recycledAtStackTraceException = null;, +      }]