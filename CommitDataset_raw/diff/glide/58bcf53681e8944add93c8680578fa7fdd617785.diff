[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.ParameterSpec;, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +            .addParameters(parameters);, +      for (ParameterSpec param : parameters) {, +        args.add(param.name);, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +    ParameterSpec parameter = parameters.iterator().next();, +        .addParameters(parameters), +            parameter.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.ParameterSpec;, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +            .addParameters(parameters);, +      for (ParameterSpec param : parameters) {, +        args.add(param.name);, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +    ParameterSpec parameter = parameters.iterator().next();, +        .addParameters(parameters), +            parameter.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  static CodeBlock generateCastingSuperCall(TypeName toReturn, MethodSpec method) {, +        .add("return ($T) super.$N(", toReturn, method.name), +            FluentIterable.from(method.parameters), +                .transform(new Function<ParameterSpec, String>() {, +                  public String apply(ParameterSpec input) {, +                    return input.name;, +    return dedupedParameters(result);, +  private static List<ParameterSpec> dedupedParameters(List<ParameterSpec> parameters) {, +    boolean hasDupes = false;, +    Set<String> names = new HashSet<>();, +    for (ParameterSpec parameter : parameters) {, +      String name = parameter.name;, +      if (names.contains(name)) {, +        hasDupes = true;, +      } else {, +        names.add(name);, +      }, +    }, +, +    if (hasDupes) {, +      List<ParameterSpec> copy = parameters;, +      parameters = new ArrayList<>();, +      for (int i = 0; i < copy.size(); i++) {, +        ParameterSpec parameter = copy.get(i);, +        parameters.add(ParameterSpec.builder(parameter.type, parameter.name + i), +            .addModifiers(parameter.modifiers), +            .addAnnotations(parameter.annotations), +            .build());, +      }, +    }, +, +    return parameters;, +  }, +, +  private static ParameterSpec getParameter(VariableElement parameter) {, +    TypeName type = TypeName.get(parameter.asType());, +    return ParameterSpec.builder(type, computeParameterName(parameter, type)), +        .addModifiers(parameter.getModifiers()), +        .addAnnotations(getAnnotations(parameter)), +  private static String computeParameterName(VariableElement parameter, TypeName type) {, +    String rawClassName = type.withoutAnnotations().toString();, +, +    String name;, +, +    if (type.isPrimitive() || type.isBoxedPrimitive()) {, +      name = getSmartPrimitiveParameterName(parameter);, +    } else {, +      if (rawClassName.contains("<") && rawClassName.contains(">")) {, +        String[] preGenericSplit = rawClassName.split("<");, +        String preGeneric = preGenericSplit[0];, +        String[] postGenericSplit = rawClassName.split(">");, +        String postGeneric = postGenericSplit[postGenericSplit.length - 1];, +        if (postGenericSplit.length > 1) {, +          rawClassName = preGeneric + postGeneric;, +        } else {, +          rawClassName = preGeneric;, +        }, +      }, +, +      String[] qualifiers = rawClassName.split("\\.");, +      rawClassName = qualifiers[qualifiers.length - 1];, +, +      rawClassName = applySmartParameterNameReplacements(rawClassName);, +, +      boolean allCaps = true;, +      for (char c : rawClassName.toCharArray()) {, +        if (Character.isLowerCase(c)) {, +          allCaps = false;, +          break;, +        }, +      }, +      if (allCaps) {, +        name = rawClassName.toLowerCase();, +      } else {, +        int indexOfLastWordStart = 0;, +        char[] chars = rawClassName.toCharArray();, +        for (int i = 0, charArrayLength = chars.length; i < charArrayLength; i++) {, +          char c = chars[i];, +          if (Character.isUpperCase(c)) {]