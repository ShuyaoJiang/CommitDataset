[+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    private List<ResourceCallback> cbs;, +    private ResourceCallback cb;, +        if (this.cb == null) {, +            this.cb = cb;, +        } else {, +            if (cbs == null) {, +                cbs = new ArrayList<ResourceCallback>(2);, +                cbs.add(this.cb);, +            }, +    }, +        if (cbs != null) {, +        } else if (this.cb == cb) {, +            this.cb = null;, +            cancel();, +        }, +                // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it, +                // synchronously released by one of the callbacks., +                resource.acquire(1);, +                    resource.acquire(1);, +                if (cbs != null) {, +                    resource.acquire(cbs.size());, +                } else {, +                    resource.acquire(1);, +                    cb.onResourceReady(resource);, +                }, +                if (cbs != null) {, +                } else {, +                    cb.onException(e);, +                }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    private List<ResourceCallback> cbs;, +    private ResourceCallback cb;, +        if (this.cb == null) {, +            this.cb = cb;, +        } else {, +            if (cbs == null) {, +                cbs = new ArrayList<ResourceCallback>(2);, +                cbs.add(this.cb);, +            }, +    }, +        if (cbs != null) {, +        } else if (this.cb == cb) {, +            this.cb = null;, +            cancel();, +        }, +                // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it, +                // synchronously released by one of the callbacks., +                resource.acquire(1);, +                    resource.acquire(1);, +                if (cbs != null) {, +                    resource.acquire(cbs.size());, +                } else {, +                    resource.acquire(1);, +                    cb.onResourceReady(resource);, +                }, +                if (cbs != null) {, +                } else {, +                    cb.onException(e);, +                }, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import com.bumptech.glide.request.ResourceCallback;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.List;, +, +     @Test, +    public void testNotifiesAllCallbacksOnReady() {, +         MultiCbHarness harness = new MultiCbHarness();, +        harness.job.onResourceReady(harness.resource);, +        for (ResourceCallback cb : harness.cbs) {, +            verify(cb).onResourceReady(eq(harness.resource));, +        }, +    }, +, +    @Test, +    public void testNotifiesAllCallbacksOnException() {, +        MultiCbHarness harness = new MultiCbHarness();, +        Exception exception = new IOException("test");, +        harness.job.onException(exception);, +        for (ResourceCallback cb : harness.cbs) {, +            verify(cb).onException(eq(exception));, +        }, +    }, +, +    @Test, +    public void testAcquiresResourceOncePerCallback() {, +        MultiCbHarness harness = new MultiCbHarness();, +        harness.job.onResourceReady(harness.resource);, +        verify(harness.resource).acquire(eq(harness.numCbs));, +    }, +        verify(harness.resource, times(3)).acquire(eq(1));, +        verify(harness.resource, times(3)).acquire(eq(1));, +    public void testDoesNotAcquireOnceForMemoryCacheIfNotCacheable() {, +        verify(harness.resource, times(2)).acquire(eq(1));, +    }, +, +    private static class MultiCbHarness {, +        Key key = mock(Key.class);, +        MemoryCache memoryCache = mock(MemoryCache.class);]