[+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.content.Context;, +import android.graphics.Point;, +import android.support.annotation.VisibleForTesting;, +import android.view.Display;, +import android.view.WindowManager;, +    this(view, false /*waitForLayout*/);, +  }, +, +  public ViewTarget(T view, boolean waitForLayout) {, +    sizeDeterminer = new SizeDeterminer(view, waitForLayout);, +  @VisibleForTesting, +  static final class SizeDeterminer {, +    @VisibleForTesting, +    @Nullable, +    static Integer maxDisplayLength;, +    private final boolean waitForLayout;, +    SizeDeterminer(View view, boolean waitForLayout) {, +      this.waitForLayout = waitForLayout;, +    }, +, +    // Use the maximum to avoid depending on the device's current orientation., +    private static int getMaxDisplayLength(Context context) {, +      if (maxDisplayLength == null) {, +        WindowManager windowManager =, +            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);, +        Display display = windowManager.getDefaultDisplay();, +        Point displayDimensions = new Point();, +        display.getSize(displayDimensions);, +        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);, +      }, +      return maxDisplayLength;, +    private boolean isViewStateAndSizeValid(int width, int height) {, +      return isDimensionValid(width) && isDimensionValid(height);, +      if (waitForLayout && view.isLayoutRequested()) {, +, +      // We consider the View state as valid if the View has non-null layout params and a non-zero, +      // layout params width and height. This is imperfect. We're making an assumption that View, +      // parents will obey their child's layout parameters, which isn't always the case., +      int adjustedParamSize = paramSize - paddingSize;, +      if (adjustedParamSize > 0) {, +        return adjustedParamSize;, +      // We also consider the View state valid if the View has a non-zero width and height. This, +      // means that the View has gone through at least one layout pass. It does not mean the Views, +      // width and height are from the current layout pass. For example, if a View is re-used in, +      // RecyclerView or ListView, this width/height may be from an old position. In some cases, +      // the dimensions of the View at the old position may be different than the dimensions of the, +      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to, +      // change them. Nevertheless, in most cases this should be a reasonable choice., +      int adjustedViewSize = viewSize - paddingSize;, +      if (adjustedViewSize > 0) {, +        return adjustedViewSize;, +      }, +, +      // Finally we consider the view valid if the layout parameter size is set to wrap_content., +      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a, +      // coherent choice, it's extremely dangerous and therefore a bad default. If users want the, +      // original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content, +      // may never resolve to a real size unless we load something, we aim for a square whose length, +      // is the largest screen size. That way we're loading something and that something has some, +      // hope of being downsampled to a size that the device can support. We also log a warning that, +      // tries to explain what Glide is doing and why some alternatives are preferable., +      if (paramSize == LayoutParams.WRAP_CONTENT) {, +        if (Log.isLoggable(TAG, Log.INFO)) {, +          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of", +              + " this device's screen dimensions. If you want to load the original image and are", +              + " ok with the corresponding memory cost and OOMs (depending on the input size), use", +              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set", +              + " layout_width and layout_height to fixed dimension, or use .override() with fixed", +              + " dimensions.");, +        }, +        return getMaxDisplayLength(view.getContext());, +      }, +, +      // If the layout parameters are < padding, the view size is < padding, or the layout, +      // parameters are set to match_parent or wrap_content and no layout has occurred, we should, +      // wait for layout and repeat., +      return PENDING_SIZE;, +    }, +, +    private boolean isDimensionValid(int size) {, +      return size > 0 || size == SIZE_ORIGINAL;, +    }, +, +    private static final class SizeDeterminerLayoutListener, +        implements ViewTreeObserver.OnPreDrawListener {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.content.Context;, +import android.graphics.Point;, +import android.support.annotation.VisibleForTesting;, +import android.view.Display;, +import android.view.WindowManager;, +    this(view, false /*waitForLayout*/);, +  }, +, +  public ViewTarget(T view, boolean waitForLayout) {, +    sizeDeterminer = new SizeDeterminer(view, waitForLayout);, +  @VisibleForTesting, +  static final class SizeDeterminer {, +    @VisibleForTesting]