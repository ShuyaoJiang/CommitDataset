[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called., +     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the, +     *         resource in a blocking manner., +     */, +    public FutureTarget<TranscodeType> into(int width, int height) {, +        final RequestFutureTarget<ModelType, TranscodeType> target =, +                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);, +        listener(target);, +, +        // TODO: Currently all loads must be started on the main thread..., +        glide.getMainHandler().post(new Runnable() {, +            @Override, +            public void run() {, +                if (!target.isCancelled()) {, +                    into(target);, +                }, +            }, +        });, +, +        return target;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called., +     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the, +     *         resource in a blocking manner., +     */, +    public FutureTarget<TranscodeType> into(int width, int height) {, +        final RequestFutureTarget<ModelType, TranscodeType> target =, +                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);, +        listener(target);, +, +        // TODO: Currently all loads must be started on the main thread..., +        glide.getMainHandler().post(new Runnable() {, +            @Override, +            public void run() {, +                if (!target.isCancelled()) {, +                    into(target);, +                }, +            }, +        });, +, +        return target;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Handler;, +import android.os.Looper;, +, +import com.bumptech.glide.request.FutureTarget;, +    private final Handler mainHandler;, +            synchronized (Glide.class) {, +                if (GLIDE == null) {, +            }, +        }, +        mainHandler = new Handler(Looper.getMainLooper());, +    Handler getMainHandler() {, +        return mainHandler;, +    }, +, +     * Cancel any pending loads Glide may have for the target and free any resources that mayhave been loaded into, +     * the target so they may be reused., +     *, +     * @param target The target to cancel loads for., +     */, +    public static void clear(FutureTarget target) {, +        target.clear();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called.]