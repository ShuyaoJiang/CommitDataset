[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Integer.highestOneBit(, +          Math.min(sourceHeight / requestedHeight, sourceWidth / requestedWidth));, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Math.min(widthPercentage, heightPercentage);, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      float widthPercentage = requestedWidth / (float) sourceWidth;, +      float heightPercentage = requestedHeight / (float) sourceHeight;, +      return Math.max(widthPercentage, heightPercentage);, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Integer.highestOneBit(, +          Math.max(sourceHeight / requestedHeight, sourceWidth / requestedWidth));, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return 1f;, +   * Returns a float between 0 and +infinity indicating a scale factor to apply to the source, +   * width and height when displayed in the requested width and height., +   *, +   * <p>The returned scale factor will be split into a power of two sample size applied via, +   * {@link android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied, +   * after downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and, +   * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale, +   * factor may not be applied precisely., +  public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Integer.highestOneBit(, +          Math.min(sourceHeight / requestedHeight, sourceWidth / requestedWidth));, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Math.min(widthPercentage, heightPercentage);, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      float widthPercentage = requestedWidth / (float) sourceWidth;, +      float heightPercentage = requestedHeight / (float) sourceHeight;, +      return Math.max(widthPercentage, heightPercentage);, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return Integer.highestOneBit(, +          Math.max(sourceHeight / requestedHeight, sourceWidth / requestedWidth));, +    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +      return 1f;, +   * Returns a float between 0 and +infinity indicating a scale factor to apply to the source, +   * width and height when displayed in the requested width and height., +   *, +   * <p>The returned scale factor will be split into a power of two sample size applied via, +   * {@link android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied, +   * after downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and, +   * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale, +   * factor may not be applied precisely., +  public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,, +        requestedHeight, options);, +  private static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,, +      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,, +      BitmapFactory.Options options) {, +    final float exactScaleFactor;, +      exactScaleFactor = downsampleStrategy.getScaleFactor(sourceHeight, sourceWidth,, +          targetWidth, targetHeight);, +      exactScaleFactor =, +          downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight);, +    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);, +    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);, +    int widthScaleFactor = sourceWidth / outWidth;, +    int heightScaleFactor = sourceHeight / outHeight;, +    int scaleFactor = Math.min(widthScaleFactor, heightScaleFactor);, +, +    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));, +    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;, +, +    options.inSampleSize = powerOfTwoSampleSize;, +    options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);, +    options.inDensity = 1000;, +    if (isScaling(options)) {, +      options.inScaled = true;, +    } else {, +      options.inDensity = options.inTargetDensity = 0;, +    }, +, +    if (Log.isLoggable(TAG, Log.VERBOSE)) {, +      Log.v(TAG, "Calculate scaling", +          + ", source: [" + sourceWidth + "x" + sourceHeight + "]", +          + ", target: [" + targetWidth + "x" + targetHeight + "]", +          + ", exact scale factor: " + exactScaleFactor, +          + ", power of 2 sample size: " + powerOfTwoSampleSize, +          + ", adjusted scale factor: " + adjustedScaleFactor, +          + ", target density: " + options.inTargetDensity, +          + ", density: " + options.inDensity);, +    }, +      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);, +      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);]