[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      paint = new Paint(Paint.FILTER_BITMAP_FLAG);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      paint = new Paint(Paint.FILTER_BITMAP_FLAG);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +import android.util.Log;, +  private static final String TAG = "GifFrameLoader";, +    this(context,, +        Glide.with(context),, +        new GifDecoder(bitmapProvider, gifHeader, byteBuffer,, +            getSampleSize(gifHeader, width, height)),, +        null /*handler*/,, +        getRequestBuilder(context, width, height), transformation, firstFrame);, +  private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {, +    int exactSampleSize = Math.min(gifHeader.getHeight() / targetHeight,, +        gifHeader.getWidth() / targetWidth);, +    int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);, +    // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code, +    // than 0., +    int sampleSize = Math.max(1, powerOfTwoSampleSize);, +    if (Log.isLoggable(TAG, Log.VERBOSE)) {, +      Log.v(TAG, "Downsampling gif", +          + ", sampleSize: " + sampleSize, +          + ", target dimens: [" + targetWidth + "x" + targetHeight, +          + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight());, +    }, +    return sampleSize;, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      paint = new Paint(Paint.FILTER_BITMAP_FLAG);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +import android.util.Log;, +  private static final String TAG = "GifFrameLoader";, +    this(context,, +        Glide.with(context),, +        new GifDecoder(bitmapProvider, gifHeader, byteBuffer,, +            getSampleSize(gifHeader, width, height)),, +        null /*handler*/,, +        getRequestBuilder(context, width, height), transformation, firstFrame);, +  private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {, +    int exactSampleSize = Math.min(gifHeader.getHeight() / targetHeight,, +        gifHeader.getWidth() / targetWidth);, +    int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);, +    // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code, +    // than 0., +    int sampleSize = Math.max(1, powerOfTwoSampleSize);, +    if (Log.isLoggable(TAG, Log.VERBOSE)) {, +      Log.v(TAG, "Downsampling gif", +          + ", sampleSize: " + sampleSize, +          + ", target dimens: [" + targetWidth + "x" + targetHeight, +          + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight());, +    }, +    return sampleSize;, +  }, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +  private int sampleSize;, +  private int downsampledHeight;, +  private int downsampledWidth;, +    this(provider, gifHeader, rawData, 1 /*sampleSize*/);, +  }, +, +  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,, +      int sampleSize) {, +    if (sampleSize <= 0) {, +      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);, +    }, +    setData(gifHeader, rawData, sampleSize);, +    setData(header, buffer, 1);, +  }, +, +  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {, +    this.sampleSize = sampleSize;, +    // TODO: Find a way to avoid this entirely or at least downsample it, +    // (either should be possible)., +    mainScratch = new int[(header.width / sampleSize) * (header.height / sampleSize)];, +    downsampledWidth = header.width / sampleSize;, +    downsampledHeight = header.height / sampleSize;, +      setData(header, data);, +      // mainScratch and therefore so will our dest array., +        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,, +            downsampledHeight);, +    int downsampledIH = currentFrame.ih / sampleSize;, +    int downsampledIY = currentFrame.iy / sampleSize;, +    int downsampledIW = currentFrame.iw / sampleSize;, +    int downsampledIX = currentFrame.ix / sampleSize;, +    for (int i = 0; i < downsampledIH; i++) {, +        if (iline >= downsampledIH) {, +      line += downsampledIY;, +      if (line < downsampledHeight) {, +        int k = line * downsampledWidth;, +        int dx = k + downsampledIX;, +        int dlim = dx + downsampledIW;, +        if (k + downsampledWidth < dlim) {, +          dlim = k + downsampledWidth;, +        int sx = i * sampleSize * currentFrame.iw;, +        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);, +          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);, +          if (averageColor != 0) {, +            dest[dx] = averageColor;, +          sx += sampleSize;]