[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.google.common.truth.Truth.assertThat;, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +  // Tests #2428., +  @Test, +  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {, +    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    GlideApp.with(context), +        .load(waitModel), +        .submit();, +, +    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context), +        .load(waitModel), +        .onlyRetrieveFromCache(true), +        .submit();, +    try {, +      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);, +      throw new IllegalStateException();, +    } catch (InterruptedException | TimeoutException e) {, +      throw new RuntimeException(e);, +    } catch (ExecutionException e) {, +      // Expected., +    }, +    waitModel.countDown();, +  }, +, +  // Tests #2428., +  @Test, +  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {, +    // Block the main thread so that we know that both requests will be queued but not started at, +    // the same time., +    final CountDownLatch blockMainThread = new CountDownLatch(1);, +    new Handler(Looper.getMainLooper()).post(new Runnable() {, +      @Override, +      public void run() {, +         try {, +          blockMainThread.await();, +        } catch (InterruptedException e) {, +          throw new RuntimeException(e);, +        }, +      }, +    });, +, +    // Queue the retrieve from cache request first., +    GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .onlyRetrieveFromCache(true), +        .submit();, +, +    // Then queue the normal request., +    FutureTarget<Drawable> expectedFuture =, +        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();, +, +    // Run the requests., +    blockMainThread.countDown();, +, +    // Verify that the request that didn't have retrieve from cache succeeds, +    assertThat(concurrency.get(expectedFuture)).isNotNull();, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.google.common.truth.Truth.assertThat;, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +  // Tests #2428., +  @Test, +  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {, +    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    GlideApp.with(context), +        .load(waitModel), +        .submit();, +, +    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context), +        .load(waitModel), +        .onlyRetrieveFromCache(true), +        .submit();, +    try {, +      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);, +      throw new IllegalStateException();, +    } catch (InterruptedException | TimeoutException e) {, +      throw new RuntimeException(e);, +    } catch (ExecutionException e) {, +      // Expected., +    }, +    waitModel.countDown();, +  }, +, +  // Tests #2428., +  @Test, +  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {]