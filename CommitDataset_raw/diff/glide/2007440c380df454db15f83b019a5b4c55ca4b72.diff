[+++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize,, +                            decodeFormat);, +            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch, +    private Bitmap downsampleWithSize(ExceptionCatchingInputStream is, BitmapFactory.Options options, BitmapPool pool,, +            int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {, +    public int[] getDimensions(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +    private static Bitmap decodeStream(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +         } else {, +             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid, +             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our, +             // current buffer size here. See issue #225., +             is.fixMarkLimit();, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize,, +                            decodeFormat);, +            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch, +    private Bitmap downsampleWithSize(ExceptionCatchingInputStream is, BitmapFactory.Options options, BitmapPool pool,, +            int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {, +    public int[] getDimensions(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +    private static Bitmap decodeStream(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +         } else {, +             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid, +             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our, +             // current buffer size here. See issue #225., +             is.fixMarkLimit();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +import android.util.Log;, +, +    private static final String TAG = "BufferedIs";, +    private volatile byte[] buf;, +    private int count;, +    private int marklimit;, +    private int markpos = -1;, +    private int pos;, +     * Reduces the mark limit to match the current buffer length to prevent the buffer from, +     * continuing to increase in size., +     *, +     * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size]