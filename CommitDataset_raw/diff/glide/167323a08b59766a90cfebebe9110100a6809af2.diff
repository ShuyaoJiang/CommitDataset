[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +import android.support.annotation.Nullable;, +  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,, +  // to greatly reduce JNI overhead., +  private static final int WORK_BUFFER_SIZE = 16384;, +  @Nullable private byte[] workBuffer;, +  private int workBufferSize = 0;, +  private int workBufferPosition = 0;, +, +    if (workBuffer != null) {, +      bitmapProvider.release(workBuffer);, +    }, +    workBufferSize = 0;, +    workBufferPosition = 0;, +   * Reads the next chunk for the intermediate work buffer., +   */, +  private void readChunkIfNeeded() {, +    if (workBufferSize > workBufferPosition) {, +      return;, +    }, +    if (workBuffer == null) {, +      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);, +    }, +    workBufferPosition = 0;, +    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);, +    rawData.get(workBuffer, 0, workBufferSize);, +  }, +, +  /**, +      readChunkIfNeeded();, +      return workBuffer[workBufferPosition++] & 0xFF;, +      return 0;, +        final int remaining = workBufferSize - workBufferPosition;, +        if (remaining >= blockSize) {, +          // Block can be read from the current work buffer., +          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);, +          workBufferPosition += blockSize;, +        } else if (rawData.remaining() + remaining >= blockSize) {, +          // Block can be read in two passes., +          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);, +          workBufferPosition = workBufferSize;, +          readChunkIfNeeded();, +          final int secondHalfRemaining = blockSize - remaining;, +          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);, +          workBufferPosition += secondHalfRemaining;, +        } else {, +          status = STATUS_FORMAT_ERROR;, +        }]