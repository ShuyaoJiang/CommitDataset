[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java, +import com.bumptech.glide.request.target.Target;, +    // Arguably we should handle the case where just width or just height is set to, +    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting, +    // the dimensions to the display width and height if they aren't specified (ie, +    // getScaledFrameAtTime is not used). Given that this is an optimization only if, +    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the, +    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now., +    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1, +         && outWidth != Target.SIZE_ORIGINAL, +         && outHeight != Target.SIZE_ORIGINAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java, +import com.bumptech.glide.request.target.Target;, +    // Arguably we should handle the case where just width or just height is set to, +    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting, +    // the dimensions to the display width and height if they aren't specified (ie, +    // getScaledFrameAtTime is not used). Given that this is an optimization only if, +    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the, +    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now., +    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1, +         && outWidth != Target.SIZE_ORIGINAL, +         && outHeight != Target.SIZE_ORIGINAL) {, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Mockito.never;, +import com.bumptech.glide.request.target.Target;, +, +  @Test, +  public void decodeFrame_withTargetSizeOriginal_onApi27_doesNotThrow() throws IOException {, +    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)), +        .thenReturn(expected);, +, +    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());, +    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL, options).get()), +        .isSameAs(expected);, +  }, +, +  @Test, +  public void decodeFrame_withTargetSizeOriginalWidthOnly_onApi27_doesNotThrow(), +      throws IOException {, +    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)), +        .thenReturn(expected);, +, +    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());, +    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, 100, options).get()), +        .isSameAs(expected);, +  }, +, +  @Test, +  public void decodeFrame_withTargetSizeOriginalHeightOnly_onApi27_doesNotThrow(), +      throws IOException {, +    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)), +        .thenReturn(expected);, +, +    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());, +    assertThat(decoder.decode(resource, 100, Target.SIZE_ORIGINAL, options).get()), +        .isSameAs(expected);, +  }]