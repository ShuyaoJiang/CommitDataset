[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);, +    private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {, +        final int exactSampleSize;, +        if (degreesToRotate == 90 || degreesToRotate == 270) {, +            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is, +            // decreased to near our target's height and the image height is decreased to near our target width., +            exactSampleSize = getSampleSize(inHeight, inWidth, outWidth, outHeight);, +        } else {, +            exactSampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);, +        }, +, +        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than, +        // or equal to the sample size we provide. Because we need to estimate the final image width and height to, +        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see, +        // http://stackoverflow.com/a/17379704/800716., +        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize - 1);, +, +        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0., +        return Math.max(1, powerOfTwoSampleSize);, +    }, +, +            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);, +            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);, +            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));]