[+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java, +  public <Z> ViewTarget<ImageView, Z> buildTarget(ImageView view, Class<Z> clazz) {, +      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);, +      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java, +  public <Z> ViewTarget<ImageView, Z> buildTarget(ImageView view, Class<Z> clazz) {, +      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);, +      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.support.annotation.CallSuper;, +import android.view.View.OnAttachStateChangeListener;, +  @Nullable, +  private OnAttachStateChangeListener attachStateListener;, +  private boolean isClearedByUs;, +  private boolean isAttachStateListenerAdded;, +, +   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its, +   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is, +   * re-attached from its {@link android.view.Window}., +   *, +   * <p>This is an experimental API that may be removed in a future version., +   *, +   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when, +   * transitioning screens or swapping adapters in scrolling views. However it also substantially, +   * increases the odds that images will not be in memory if users subsequently return to a screen, +   * where images were previously loaded. Whether or not this happens will depend on the number, +   * of images loaded in the new screen and the size of the memory cache. Increasing the size of, +   * the memory cache can improve this behavior but it largely negates the memory benefits of using, +   * this method., +   *, +   * <p>Use this method with caution and measure your memory usage to ensure that it's actually, +   * improving your memory usage in the cases you care about., +   */, +  // Public API., +  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}), +  public final ViewTarget<T, Z> clearOnDetach() {, +    if (attachStateListener != null) {, +      return this;, +    }, +    attachStateListener = new OnAttachStateChangeListener() {, +      @Override, +      public void onViewAttachedToWindow(View v) {, +        Request request = getRequest();, +        if (request != null && request.isPaused()) {, +          request.begin();, +        }, +      }, +, +      @Override, +      public void onViewDetachedFromWindow(View v) {, +        Request request = getRequest();, +        if (request != null && !request.isCancelled() && !request.isPaused()) {, +          isClearedByUs = true;, +          request.pause();, +          isClearedByUs = false;, +        }, +      }, +    };, +    maybeAddAttachStateListener();, +    return this;, +  }, +, +  @CallSuper, +  @Override, +  public void onLoadStarted(@Nullable Drawable placeholder) {, +    super.onLoadStarted(placeholder);, +    maybeAddAttachStateListener();, +  }, +, +  private void maybeAddAttachStateListener() {, +    if (attachStateListener == null || isAttachStateListenerAdded) {, +      return;, +    }, +, +    view.addOnAttachStateChangeListener(attachStateListener);]