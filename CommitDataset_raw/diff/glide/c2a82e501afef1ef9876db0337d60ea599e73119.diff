[+++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +    private static final String STATE_POSITION_INDEX = "state_position_index";, +, +    private GridView grid;, +        grid = (GridView) result.findViewById(R.id.images);, +        if (currentPhotos != null) {, +        }, +, +        if (savedInstanceState != null) {, +            int index = savedInstanceState.getInt(STATE_POSITION_INDEX);, +            grid.setSelection(index);, +        }, +    public void onSaveInstanceState(Bundle outState) {, +        super.onSaveInstanceState(outState);, +        if (grid != null) {, +            int index = grid.getFirstVisiblePosition();, +            outState.putInt(STATE_POSITION_INDEX, index);, +        }, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml]