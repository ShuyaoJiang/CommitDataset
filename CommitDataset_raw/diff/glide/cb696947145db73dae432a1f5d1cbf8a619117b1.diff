[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.os.Debug;, +import java.util.concurrent.atomic.AtomicReference;, +  private static final long TIMEOUT_SECONDS = 5;, +  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;, +  public <T> T get(final Future<T> future) {, +    final AtomicReference<T> reference = new AtomicReference<>();, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +          reference.set(future.get(timeout, timeUnit));, +          return true;, +        } catch (ExecutionException e) {, +        } catch (TimeoutException e) {, +          return false;, +    });, +    return reference.get();, +  }, +    final Thread thread = new Thread(new Runnable() {, +, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +        thread.join(timeUnit.toMillis(timeout));, +        return isDone.get();, +    });, +  static void waitOnLatch(final CountDownLatch latch) {, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +        return latch.await(timeout, timeUnit);, +      }, +    });, +  }, +, +  private interface Waiter {, +    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;, +  }, +, +  private static void wait(Waiter waiter) {, +    boolean isFinished = false;, +     do {, +         try {, +           isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);, +           if (!isFinished) {, +             throw new RuntimeException("Timed out while waiting");, +       } catch (RuntimeException e) {, +         if (Debug.isDebuggerConnected()) {, +           continue;, +         }, +         throw e;, +       }, +     } while (Debug.isDebuggerConnected() && !isFinished);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.os.Debug;, +import java.util.concurrent.atomic.AtomicReference;, +  private static final long TIMEOUT_SECONDS = 5;, +  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;, +  public <T> T get(final Future<T> future) {, +    final AtomicReference<T> reference = new AtomicReference<>();, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +          reference.set(future.get(timeout, timeUnit));, +          return true;, +        } catch (ExecutionException e) {, +        } catch (TimeoutException e) {, +          return false;, +    });, +    return reference.get();, +  }, +    final Thread thread = new Thread(new Runnable() {, +, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +        thread.join(timeUnit.toMillis(timeout));, +        return isDone.get();, +    });, +  static void waitOnLatch(final CountDownLatch latch) {, +    wait(new Waiter() {, +      @Override, +      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {, +        return latch.await(timeout, timeUnit);, +      }, +    });, +  }, +, +  private interface Waiter {, +    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;, +  }, +, +  private static void wait(Waiter waiter) {, +    boolean isFinished = false;, +     do {, +         try {, +           isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);, +           if (!isFinished) {, +             throw new RuntimeException("Timed out while waiting");, +       } catch (RuntimeException e) {]