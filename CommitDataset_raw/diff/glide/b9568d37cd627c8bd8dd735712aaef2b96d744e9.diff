[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +/**, + * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class., + */, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +/**, + * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class., + */, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +/**]