[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  public void reschedule() {, +    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;, +    callback.reschedule(this);, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  public void reschedule() {, +    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;, +    callback.reschedule(this);, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +  private Object dataToCache;, +    if (dataToCache != null) {, +      cacheData();, +      dataToCache = null;, +    }, +  private void cacheData() {, +    long startTime = LogTime.getLogTime();, +    try {, +      Encoder<Object> encoder = requestContext.getSourceEncoder(dataToCache);, +      DataCacheWriter<Object> writer =, +          new DataCacheWriter<>(encoder, dataToCache, requestContext.getOptions());, +      Key originalKey = new DataCacheKey(loadData.sourceKey, requestContext.getSignature());, +      diskCache.put(originalKey, writer);, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Finished encoding source to cache", +            + ", key: " + originalKey, +            + ", data: " + dataToCache, +            + ", encoder: " + encoder, +            + ", duration: " + LogTime.getElapsedMillis(startTime));, +      }, +    } finally {, +      loadData.fetcher.cleanup();, +    }, +, +    sourceCacheGenerator =, +        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), width, height,, +            diskCache, requestContext, this);, +  }, +, +      dataToCache = data;, +      // We might be being called back on someone else's thread. Before doing anything, we should, +      // reschedule to get back onto Glide's thread., +      cb.reschedule();, +  @Override, +  public void reschedule() {, +    // We don't expect this to happen, although if we ever need it to we can delegate to our, +    // callback., +    throw new UnsupportedOperationException();, +  }, +]