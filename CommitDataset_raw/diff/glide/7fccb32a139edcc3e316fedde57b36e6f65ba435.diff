[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import javax.lang.model.type.DeclaredType;, +        validateExtensionConstructor(element);, +      } else if (element.getKind() == ElementKind.METHOD) {, +        ExecutableElement executableElement = (ExecutableElement) element;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +          validateGlideOption(executableElement);, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +          validateGlideType(executableElement);, +        }, +      }, +    }, +  }, +, +  private static void validateExtensionConstructor(Element element) {, +    if (returnsVoid(executableElement)) {, +  private void validateGlideType(ExecutableElement executableElement) {, +    if (returnsVoid(executableElement)) {, +      validateDeprecatedGlideType(executableElement);, +    } else {, +      validateNewGlideType(executableElement);, +    }, +  }, +  private void validateNewGlideType(ExecutableElement executableElement) {, +    TypeMirror returnType = executableElement.getReturnType();, +    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {, +      String expectedClassName = getGlideTypeValue(executableElement);, +      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<", +          + expectedClassName + "> object, but given: " + returnType + ". If you're", +          + " using old style @GlideType methods, your method may have a void return type, but", +          + " doing so is deprecated and support will be removed in a future version");, +    }, +    validateGlideTypeParameters(executableElement);, +  }, +, +  private String getGlideTypeValue(ExecutableElement executableElement) {, +    return, +        processorUtil, +            .findClassValuesFromAnnotationOnClassAsNames(, +                executableElement, GlideType.class).iterator().next();, +  }, +, +  private boolean typeMatchesExpected(, +      TypeMirror returnType, ExecutableElement executableElement) {, +    if (!(returnType instanceof DeclaredType)) {, +      return false;, +    }, +    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();, +    if (typeArguments.size() != 1) {, +      return false;, +    }, +    TypeMirror argument = typeArguments.get(0);, +    String expected = getGlideTypeValue(executableElement);, +    if (!argument.toString().equals(expected)) {, +      return false;, +    }, +    return true;, +  }, +, +  private boolean isRequestBuilder(TypeMirror typeMirror) {, +    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);, +    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");, +  }, +, +  private static void validateDeprecatedGlideType(ExecutableElement executableElement) {, +    validateGlideTypeParameters(executableElement);, +  }, +, +  private static void validateGlideTypeParameters(ExecutableElement executableElement) {, +  private static boolean returnsVoid(ExecutableElement executableElement) {, +    if (!returnsVoid(executableElement)) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import javax.lang.model.type.DeclaredType;, +        validateExtensionConstructor(element);, +      } else if (element.getKind() == ElementKind.METHOD) {, +        ExecutableElement executableElement = (ExecutableElement) element;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +          validateGlideOption(executableElement);, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +          validateGlideType(executableElement);, +        }, +      }, +    }, +  }, +, +  private static void validateExtensionConstructor(Element element) {, +    if (returnsVoid(executableElement)) {, +  private void validateGlideType(ExecutableElement executableElement) {, +    if (returnsVoid(executableElement)) {, +      validateDeprecatedGlideType(executableElement);, +    } else {, +      validateNewGlideType(executableElement);, +    }, +  }, +  private void validateNewGlideType(ExecutableElement executableElement) {, +    TypeMirror returnType = executableElement.getReturnType();, +    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {, +      String expectedClassName = getGlideTypeValue(executableElement);, +      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<", +          + expectedClassName + "> object, but given: " + returnType + ". If you're"]