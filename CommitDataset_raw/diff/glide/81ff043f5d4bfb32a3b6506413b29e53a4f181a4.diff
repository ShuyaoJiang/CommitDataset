[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import android.support.annotation.NonNull;, +import java.io.File;, +import java.io.FilenameFilter;, +import java.util.regex.Pattern;, +, +  private static final String CPU_NAME_REGEX = "cpu[0-9]+";, +  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";, +  // Don't use more than four threads when automatically determining thread count.., +  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;, +, +  /**, +   * Constructor to build a fixed thread pool with an automatically determined number of threads., +   *, +   * @see #calculateBestThreadCount(), +   */, +  public GlideExecutor() {, +    this(calculateBestThreadCount());, +  }, +   * Constructor to build a fixed thread pool with the given name and an automatically determined, +   * number of threads., +   *, +   * @see #calculateBestThreadCount(), +   */, +  public GlideExecutor(String name) {, +    this(calculateBestThreadCount(), new DefaultThreadFactory(name));, +  }, +, +  /**, +    super(, +        corePoolSize /*corePoolSize*/,, +        corePoolSize /*maximumPoolSize*/,, +        0 /*keepAliveTime*/,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        threadFactory);, +   * Determines the number of cores available on the device., +   *, +   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not, +   * be the number of available cores depending on the device's current state. See, +   * http://goo.gl/8H670N., +   */, +  public static int calculateBestThreadCount() {, +    File cpuInfo = new File(CPU_LOCATION);, +    final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);, +    File[] cpus = cpuInfo.listFiles(new FilenameFilter() {, +      @Override, +      public boolean accept(File file, String s) {, +        return cpuNamePattern.matcher(s).matches();, +      }, +    });, +, +    int cpuCount = cpus != null ? cpus.length : 0;, +    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());, +    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));, +  }, +, +  /**, +   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the, +   * pool., +     * Silently catches and ignores the uncaught {@link Throwable}s., +     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}., +     * Rethrows the uncaught {@link Throwable}s to crash the app., +    public Thread newThread(@NonNull Runnable runnable) {, +      synchronized (this) {, +      }]