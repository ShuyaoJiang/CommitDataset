[+++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +, +    private static class InnerTrackerPool {, +        private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();, +, +        public InnerTracker get() {, +            InnerTracker result = pool.poll();, +            if (result == null) {, +                result = new InnerTracker();, +            }, +, +            return result;, +        }, +, +        public void release(InnerTracker innerTracker) {, +            pool.offer(innerTracker);, +        }, +    }, +, +    private static class InnerTracker {, +        private volatile int refs = 0;, +        private volatile boolean pending = false;, +, +        public void acquire() {, +            pending = false;, +            synchronized (this) {, +                refs++;, +            }, +        }, +, +        public boolean release() {, +            synchronized (this) {, +                refs--;, +            }, +, +            return refs == 0 && !pending;, +        }, +, +        public boolean reject() {, +            pending = false;, +            return refs == 0;, +        }, +, +        public void markPending() {, +            pending = true;, +        }, +    }, +, +    private final Map<Integer, InnerTracker> counter;, +    private final InnerTrackerPool pool = new InnerTrackerPool();, +    public BitmapTracker(SizedBitmapCache target, int bitmapsPerSize) {, +        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);, +    public void initBitmap(Bitmap toInit) {, +        counter.put(toInit.hashCode(), pool.get());, +    public void acquireBitmap(Bitmap bitmap) {, +        get(bitmap).acquire();, +    }, +, +    public void releaseBitmap(Bitmap bitmap) {, +        final InnerTracker tracker = get(bitmap);, +        if (tracker.release()) {, +            recycle(tracker, bitmap);, +        }, +    }, +, +    public void rejectBitmap(Bitmap bitmap) {, +        final InnerTracker tracker = get(bitmap);, +        if (tracker.reject()) {, +            recycle(tracker, bitmap);, +        }, +    }, +, +    public void markPending(Bitmap bitmap) {, +        get(bitmap).markPending();, +    }, +, +    private InnerTracker get(Bitmap bitmap) {, +        return counter.get(bitmap.hashCode());, +    }, +, +    private void recycle(InnerTracker tracker, Bitmap bitmap) {, +        counter.remove(bitmap.hashCode());, +        pool.release(tracker);, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +, +    private static class InnerTrackerPool {, +        private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();, +, +        public InnerTracker get() {, +            InnerTracker result = pool.poll();, +            if (result == null) {, +                result = new InnerTracker();, +            }, +, +            return result;, +        }]