[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import static org.mockito.Mockito.doAnswer;, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));, +, +    @Test, +    public void testHandlesNonEngineResourcesFromCacheIfPresent() {, +        final Object expected = new Object();, +        Resource fromCache = mock(Resource.class);, +        when(fromCache.get()).thenReturn(expected);, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource resource = (Resource) invocationOnMock.getArguments()[0];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cb).onResourceReady(any(Resource.class));, +, +        harness.doLoad();, +, +        verify(harness.cb).onResourceReady(any(Resource.class));, +    }, +, +        WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);, +        final Object expected = new Object();, +        when(harness.resource.isCacheable()).thenReturn(true);, +        when(harness.resource.get()).thenReturn(expected);, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));, +, +, +        verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));, +        harness.resource.setCacheable(false);, +        harness.resource.setCacheable(true);, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        Map<Key, WeakReference<EngineResource<?>>> activeResources =, +                new HashMap<Key, WeakReference<EngineResource<?>>>();, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import static org.mockito.Mockito.doAnswer;, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));, +, +    @Test, +    public void testHandlesNonEngineResourcesFromCacheIfPresent() {, +        final Object expected = new Object();, +        Resource fromCache = mock(Resource.class);, +        when(fromCache.get()).thenReturn(expected);, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource resource = (Resource) invocationOnMock.getArguments()[0];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cb).onResourceReady(any(Resource.class));, +, +        harness.doLoad();, +, +        verify(harness.cb).onResourceReady(any(Resource.class));, +    }, +, +        WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);, +        final Object expected = new Object();, +        when(harness.resource.isCacheable()).thenReturn(true);, +        when(harness.resource.get()).thenReturn(expected);, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];]