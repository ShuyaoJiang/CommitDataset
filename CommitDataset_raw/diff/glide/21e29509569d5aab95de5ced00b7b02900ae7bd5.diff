[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  /**, +   * Ensure that the size of the bitmap is fixed to the requested width and height of the, +   * resource from the caller.  The final resource dimensions may differ from the requested, +   * width and height, and thus setting this to true may result in the bitmap size differing, +   * from the resource dimensions., +   *, +   * This can be used as a performance optimization for KitKat and above by fixing the size of the, +   * bitmap for a collection of requested resources so that the bitmap pool will not need to, +   * allocate new bitmaps for images of different sizes., +   */, +  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =, +      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);, +, +    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;, +    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;, +, +    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,, +        targetHeight, options);, +, +    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding., +    if ((options.inSampleSize == 1 || isKitKatOrGreater), +        && shouldUsePool(is)) {, +      int expectedWidth;, +      int expectedHeight;, +      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +        expectedWidth = targetWidth;, +        expectedHeight = targetHeight;, +      } else {, +        float densityMultiplier = isScaling(options), +            ? (float) options.inTargetDensity / options.inDensity : 1f;, +        int sampleSize = options.inSampleSize;, +        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);, +        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);, +        expectedWidth = Math.round(downsampledWidth * densityMultiplier);, +        expectedHeight = Math.round(downsampledHeight * densityMultiplier);, +, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source", +              + " [" + sourceWidth + "x" + sourceHeight + "]", +              + ", sampleSize: " + sampleSize, +              + ", targetDensity: " + options.inTargetDensity, +              + ", density: " + options.inDensity, +              + ", density multiplier: " + densityMultiplier);, +        }, +      }, +      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height, +      // will be -1 here., +      if (expectedWidth > 0 && expectedHeight > 0) {, +        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);, +      }, +    }, +    Bitmap downsampled = decodeStream(is, options, callbacks);, +      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,, +      int height) {, +      options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  /**, +   * Ensure that the size of the bitmap is fixed to the requested width and height of the, +   * resource from the caller.  The final resource dimensions may differ from the requested, +   * width and height, and thus setting this to true may result in the bitmap size differing, +   * from the resource dimensions., +   *, +   * This can be used as a performance optimization for KitKat and above by fixing the size of the, +   * bitmap for a collection of requested resources so that the bitmap pool will not need to, +   * allocate new bitmaps for images of different sizes., +   */, +  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =, +      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);, +, +    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;, +    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;, +, +    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,, +        targetHeight, options);, +, +    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding., +    if ((options.inSampleSize == 1 || isKitKatOrGreater), +        && shouldUsePool(is)) {, +      int expectedWidth;, +      int expectedHeight;, +      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +        expectedWidth = targetWidth;, +        expectedHeight = targetHeight;, +      } else {, +        float densityMultiplier = isScaling(options), +            ? (float) options.inTargetDensity / options.inDensity : 1f;, +        int sampleSize = options.inSampleSize;, +        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);, +        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);]