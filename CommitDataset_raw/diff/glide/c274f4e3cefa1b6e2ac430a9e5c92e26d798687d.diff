[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +package com.bumptech.glide.load.engine;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Encoder;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.provider.DataLoadProvider;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.util.Arrays;, +import java.util.List;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class DecodeJobTest {, +, +    private Harness harness;, +, +    @Before, +    public void setUp() {, +        harness = new Harness();, +    }, +, +    private void mockCacheToReturnResultResource() throws IOException {, +        File cacheFile = new File("fake");, +        when(harness.diskCache.get(eq(harness.key))).thenReturn(cacheFile);, +        when(harness.cacheDecoder.decode(eq(cacheFile), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.resource);, +    }, +, +    /** decodeResultFromCache **/, +, +    @Test, +    public void testDiskCacheIsCheckedForResultWhenCacheStrategyIncludesResult() throws Exception {, +        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.RESULT)) {, +            harness = new Harness(strategy);, +, +            mockCacheToReturnResultResource();, +, +            assertEquals("diskCacheStrategy: " + strategy, harness.resource, harness.getJob().decodeResultFromCache());, +        }, +    }, +, +    @Test, +    public void testDiskCacheIsNotCheckedForResultWhenCacheStrategyDoesNotIncludeResult() throws Exception {, +        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.SOURCE)) {, +            harness = new Harness(strategy);, +, +            harness.getJob().decodeResultFromCache();, +, +            verify(harness.diskCache, never()).get(eq(harness.key));, +        }, +    }, +, +    @Test, +    public void testDecodeResultFromCacheReturnsNullIfDiskCacheStrategyDoesNotIncludeResult() throws Exception {, +        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.SOURCE)) {, +            harness = new Harness(strategy);, +            mockCacheToReturnResultResource();, +, +            assertNull(harness.getJob().decodeResultFromCache());, +        }, +    }, +, +    @Test, +    public void testResultDecodedFromCacheIsTranscodedIfDecodeSucceeds() throws Exception {, +        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;, +        mockCacheToReturnResultResource();, +        Resource<Object> transcoded = mock(Resource.class);, +        when(harness.transcoder.transcode(eq(harness.resource))).thenReturn(transcoded);, +, +        assertEquals(transcoded, harness.getJob().decodeResultFromCache());, +    }, +]