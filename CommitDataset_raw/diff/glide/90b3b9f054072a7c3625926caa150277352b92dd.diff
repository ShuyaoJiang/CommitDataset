[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +  private DelayTarget pendingTarget;, +    if (pendingTarget != null) {, +      requestManager.clear(pendingTarget);, +      pendingTarget = null;, +    }, +      Preconditions.checkArgument(, +          pendingTarget == null, "Pending target must be null when starting from the first frame");, +    if (pendingTarget != null) {, +      DelayTarget temp = pendingTarget;, +      pendingTarget = null;, +      onFrameReady(temp);, +      return;, +    }, +    if (pendingTarget != null) {, +      requestManager.clear(pendingTarget);, +      pendingTarget = null;, +    }, +    isLoadPending = false;, +    // If we're not running, notifying here will recycle the frame that we might currently be, +    // showing, which breaks things (see #2526). We also can't discard this frame because we've, +    // already incremented the frame pointer and can't decode the same frame again. Instead we'll, +    // just hang on to this next frame until start() or clear() are called., +    if (!isRunning) {, +      pendingTarget = delayTarget;, +      return;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +  private DelayTarget pendingTarget;, +    if (pendingTarget != null) {, +      requestManager.clear(pendingTarget);, +      pendingTarget = null;, +    }, +      Preconditions.checkArgument(, +          pendingTarget == null, "Pending target must be null when starting from the first frame");, +    if (pendingTarget != null) {, +      DelayTarget temp = pendingTarget;, +      pendingTarget = null;, +      onFrameReady(temp);, +      return;, +    }, +    if (pendingTarget != null) {, +      requestManager.clear(pendingTarget);, +      pendingTarget = null;, +    }, +    isLoadPending = false;, +    // If we're not running, notifying here will recycle the frame that we might currently be, +    // showing, which breaks things (see #2526). We also can't discard this frame because we've, +    // already incremented the frame pointer and can't decode the same frame again. Instead we'll, +    // just hang on to this next frame until start() or clear() are called., +    if (!isRunning) {, +      pendingTarget = delayTarget;, +      return;, +    }, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +    GifFrameLoader result = new GifFrameLoader(, +    result.subscribe(callback);, +    return result;, +    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));, +    verify(requestBuilder, times(3)).apply(isA(RequestOptions.class));, +    verify(requestBuilder, times(1)).into(aTarget());, +    loader.unsubscribe(callback);, +    verify(requestBuilder, times(1)).into(aTarget());, +  @Test, +  public void onFrameReady_whenNotRunning_doesNotClearPreviouslyLoadedImage() {, +    loader = createGifFrameLoader(/*handler=*/ null);, +    DelayTarget loaded = mock(DelayTarget.class);, +    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +    loader.onFrameReady(loaded);, +    loader.unsubscribe(callback);, +, +    DelayTarget nextFrame = mock(DelayTarget.class);, +    when(nextFrame.getResource()), +        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +    loader.onFrameReady(nextFrame);, +    verify(requestManager, never()).clear(loaded);, +  }, +, +  @Test, +  public void onFrameReady_whenNotRunning_clearsPendingFrameOnClear() {, +    loader = createGifFrameLoader(/*handler=*/ null);, +    DelayTarget loaded = mock(DelayTarget.class);, +    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +    loader.onFrameReady(loaded);, +    loader.unsubscribe(callback);, +, +    DelayTarget nextFrame = mock(DelayTarget.class);, +    when(nextFrame.getResource()), +        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +    loader.onFrameReady(nextFrame);, +, +    loader.clear();, +    verify(requestManager).clear(loaded);, +    verify(requestManager).clear(nextFrame);, +  }, +, +  @Test, +  public void onFrameReady_whenNotRunning_clearsOldFrameOnStart() {, +    loader = createGifFrameLoader(/*handler=*/ null);, +    DelayTarget loaded = mock(DelayTarget.class);]