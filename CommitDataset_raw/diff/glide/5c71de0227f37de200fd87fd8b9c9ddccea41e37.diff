[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    int sampleSize = getRoundedSampleSize(downsampleStrategy, degreesToRotate, inWidth, inHeight,, +        outWidth, outHeight);, +  private static int getOrientation(InputStream is) throws IOException {, +    // out* is reset by most calls to decodeStream, successful or otherwise., +    int outWidth = options.outWidth;, +    int outHeight = options.outHeight;, +    String outMimeType = options.outMimeType;, +    final Bitmap result;, +    try {, +      result = BitmapFactory.decodeStream(is, null, options);, +    } catch (IllegalArgumentException e) {, +      throw newIoExceptionForInBitmapAssertion(e, outWidth, outHeight, outMimeType, options);, +    }, +  // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a, +  // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log, +  // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so, +  // want some useful log output. In most cases this can be safely treated as a normal IOException., +  @TargetApi(Build.VERSION_CODES.HONEYCOMB), +  private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,, +      int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {, +    final String inBitmapString;, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && options.inBitmap != null) {, +      inBitmapString =  "[" + options.inBitmap.getWidth() + "x" + options.inBitmap.getHeight(), +          + "] " + options.inBitmap.getConfig();, +    } else {, +      inBitmapString = null;, +    }, +    return new IOException("Exception decoding bitmap", +          + ", outWidth: " + outWidth, +          + ", outHeight: " + outHeight, +          + ", outMimeType: " + outMimeType, +          + ", inBitmap: " + inBitmapString, e);, +  }, +]