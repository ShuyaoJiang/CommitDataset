[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();, +  private final ReleaseManager releaseManager = new ReleaseManager(deferredEncodeManager);, +, +  private RunReason runReason;, +  private long startFetchTime;, +, +  private Key currentAttemptingKey;, +  private volatile DataFetcherGenerator currentGenerator;, +  private volatile boolean isCallbackNotified;, +    this.runReason = RunReason.INITIALIZE;, +  /**, +   * Called when this object is no longer in use externally., +   */, +    if (releaseManager.release()) {, +      releaseInternal();, +    }, +  }, +, +  private void onEncodeComplete() {, +    if (releaseManager.onEncodeComplete()) {, +      releaseInternal();, +    }, +  }, +, +  private void releaseInternal() {, +    releaseManager.reset();, +    deferredEncodeManager.clear();, +    currentGenerator = null;, +    DataFetcherGenerator local = currentGenerator;, +        Log.d(TAG, "DecodeJob threw unexpectedly", +            + ", isCancelled: " + isCancelled, +            + ", stage: " + stage, e);, +      // When we're encoding we've already notified our callback and it isn't safe to do so again., +      if (stage != Stage.ENCODE) {, +      }, +        currentGenerator = getNextGenerator();, +      case FINISHED:, +        return null;, +    while (!isCancelled && currentGenerator != null, +        && !(isStarted = currentGenerator.startNext())) {, +      currentGenerator = getNextGenerator();, +    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {, +      case SOURCE:, +      case FINISHED:, +        return Stage.FINISHED;, +        throw new IllegalArgumentException("Unrecognized stage: " + current);, +      notifyEncodeAndRelease(resource);, +  private void notifyEncodeAndRelease(Resource<R> resource) {, +    Resource<R> result = resource;, +    LockedResource<R> lockedResource = null;, +    if (deferredEncodeManager.hasResourceToEncode()) {, +      lockedResource = LockedResource.obtain(resource);, +      result = lockedResource;, +    }, +, +    notifyComplete(result);, +, +    stage = Stage.ENCODE;, +    try {, +      if (deferredEncodeManager.hasResourceToEncode()) {, +        deferredEncodeManager.encode(diskCacheProvider, options);, +      }, +    } finally {, +      if (lockedResource != null) {, +        lockedResource.unlock();, +      }, +      onEncodeComplete();, +    }, +      Resource<Z> result = transformed;, +        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);, +        deferredEncodeManager.init(key, encoder, lockedResult);, +        result = lockedResult;, +      return result;, +  private static class ReleaseManager {, +    private final DeferredEncodeManager<?> encodeManager;, +    private boolean isReleased;, +    private boolean isEncodeComplete;, +, +    ReleaseManager(DeferredEncodeManager<?> encodeManager) {, +      this.encodeManager = encodeManager;, +    }, +, +    synchronized boolean release() {, +      isReleased = true;, +      return isComplete();, +    }, +, +    synchronized boolean onEncodeComplete() {, +      isEncodeComplete = true;, +      return isComplete();, +    }, +, +    synchronized void reset() {, +      isEncodeComplete = false;, +      isReleased = false;, +    }, +, +    private boolean isComplete() {, +      return (!encodeManager.hasResourceToEncode() || isEncodeComplete) && isReleased;]