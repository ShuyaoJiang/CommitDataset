[+++ b/library/src/com/bumptech/glide/Glide.java, +     * A class for monitoring the status of a request while images load., +     *, +     * @param <T> The type of the model being loaded, +     */, +    public static abstract class RequestListener<T> {, +, +        /**, +         * Called when an exception occurs during a load. Will only be called if we currently want to display an image, +         * for the given model in the given target. It is recommended to create a single instance per activity/fragment, +         * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn., +         *, +         * <p>, +         *     It is safe to reload this or a different model or change what is displayed in the target at this point., +         *     For example:, +         * <pre>, +         * <code>, +         *     public void onException(Exception e, T model, Target target) {, +         *         target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);, +         *         Glide.load(model).into(target);, +         *     }, +         * </code>, +         * </pre>, +         * </p>, +         *, +         * <p>, +         *     Note - if you want to reload this or any other model after an exception, you will need to include all, +         *     relevant builder calls (like centerCrop, placeholder etc)., +         * </p>, +         *, +         * @param e The exception, or null, +         * @param model The model we were trying to load when the exception occured, +         * @param target The {@link Target} we were trying to load the image into, +         */, +        public abstract void onException(Exception e, T model, Target target);, +, +        /**, +         * Called when a load completes successfully, immediately before, +         * {@link Target#onImageReady(android.graphics.Bitmap)}., +         *, +         * @param model The specific model that was used to load the image., +         * @param target The target the model was loaded into., +         */, +        public abstract void onImageReady(T model, Target target);, +, +        /**, +         * {@inheritDoc}, +         *, +         * <p>, +         *     By default we only check the both objects are not null and that their classes are identical. This assumes, +         *     that two instances of the same anonymous inner class will behave identically., +         * </p>, +         */, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +, +            return true;, +        }, +, +        /**, +         * {@inheritDoc }, +         */, +        @Override, +        public int hashCode() {, +            throw new UnsupportedOperationException();, +        }, +    }, +, +    /**, +        private RequestListener<T> requestListener;, +         * Sets a Request listener to monitor the image load. It's best to create a single instance of an exception, +         * handler per type of request (usually activity/fragment) rather than pass one in per request to avoid some, +         * redundant object allocation., +         *, +         * @param requestListener The request listener to use, +         * @return This request, +         */, +        public Request<T> listener(RequestListener<T> requestListener) {, +            this.requestListener = requestListener;, +, +            return this;, +        }, +, +        /**, +        private ImagePresenter<T> buildImagePresenter(final Target target) {, +            if (animationId != -1 || requestListener != null) {, +                final Animation animation;, +                    animation = AnimationUtils.loadAnimation(context, animationId);, +                } else {, +                    animation = null;, +                }, +                builder.setImageReadyCallback(new ImagePresenter.ImageReadyCallback<T>() {, +                    public void onImageReady(T model, Target target, boolean fromCache) {, +                        if (animation != null && !fromCache) {, +                        if (requestListener != null) {, +                            requestListener.onImageReady(null, target);, +                        }, +            if (requestListener != null) {]