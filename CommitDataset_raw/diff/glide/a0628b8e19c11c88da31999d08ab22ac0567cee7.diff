[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * @see #getDrawable(Context, int, Theme), +   */, +  public static Drawable getDrawable(Context context, @DrawableRes int id) {, +    return getDrawable(context, id, /*theme=*/ null);, +  }, +, +  /**, +   *, +   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if, +   * non-null when loading the {@link Drawable}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * @see #getDrawable(Context, int, Theme), +   */, +  public static Drawable getDrawable(Context context, @DrawableRes int id) {, +    return getDrawable(context, id, /*theme=*/ null);, +  }, +, +  /**, +   *, +   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if, +   * non-null when loading the {@link Drawable}., +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java, +import android.content.pm.PackageManager.NameNotFoundException;, +import android.support.annotation.DrawableRes;, +import android.support.annotation.NonNull;, + * Decodes {@link Drawable}s given resource {@link Uri}s., + *, + * <p>This is typically used as a fallback for resource types that either aren't Bitmaps (see #350), + * or for resource types that we can't obtain an {@link java.io.InputStream} for using a standard, + * {@link ContentResolver}, including some types of application icons and resources loaded from, + * other packages., +  // android.resource://<package_name>/<type>/<name>., +  private static final int NAME_URI_PATH_SEGMENTS = 2;, +  // android.resource://<package_name>/<resource_id>, +  private static final int ID_PATH_SEGMENTS = 1;, +  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;, +    @DrawableRes int resId = loadResourceIdFromUri(source);, +    String packageName = source.getAuthority();, +    Context toUse = packageName.equals(context.getPackageName()), +        ? context : getContextForPackage(source, packageName);, +    // We can't get a theme from another application., +    Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);, +    return new InternalDrawableResource(drawable);, +, +  @NonNull, +  private Context getContextForPackage(Uri source, String packageName) {, +    try {, +      return context.createPackageContext(packageName, /*flags=*/ 0);, +    } catch (NameNotFoundException e) {, +      throw new IllegalArgumentException(, +          "Failed to obtain context or unrecognized Uri format for: " + source, e);, +    }, +  }, +, +  @DrawableRes, +  private int loadResourceIdFromUri(Uri source) {, +    List<String> segments = source.getPathSegments();, +    @DrawableRes Integer result = null;, +    if (segments.size() == NAME_URI_PATH_SEGMENTS) {, +       result = context.getResources().getIdentifier(resourceName, typeName, packageName);, +    } else if (segments.size() == ID_PATH_SEGMENTS) {, +       try {, +         result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));, +       } catch (NumberFormatException e) {, +         // Ignored., +     }, +, +     if (result == null) {, +       throw new IllegalArgumentException("Unrecognized Uri format: " + source);, +     } else if (result == 0) {, +       throw new IllegalArgumentException("Failed to obtain resource id for: " + source);, +     }, +     return result;, +  }, +, +  private static final class InternalDrawableResource extends DrawableResource<Drawable> {, +, +    InternalDrawableResource(Drawable drawable) {, +      super(drawable);, +    }, +, +      // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If, +      // there are no intrinsic bounds, we can fall back just to 1., +      return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);]