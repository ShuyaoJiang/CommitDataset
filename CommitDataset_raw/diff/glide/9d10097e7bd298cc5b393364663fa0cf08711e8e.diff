[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +, +  /**, +   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has, +   * all of the same options and sizes)., +   *, +   * <p>This method is identical to {@link #equals(Object)} except that it's specific to, +   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track, +   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to, +   * have two different {@link Request} objects for two different, +   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different, +   * method let's us selectively compare {@link Request} objects to each other when it's useful in, +   * specific scenarios., +   */, +  boolean isEquivalentTo(Request other);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +, +  /**, +   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has, +   * all of the same options and sizes)., +   *, +   * <p>This method is identical to {@link #equals(Object)} except that it's specific to, +   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track, +   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to, +   * have two different {@link Request} objects for two different, +   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different, +   * method let's us selectively compare {@link Request} objects to each other when it's useful in, +   * specific scenarios., +   */, +  boolean isEquivalentTo(Request other);, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +, +  @Override, +  public boolean equals(Object o) {, +    if (o instanceof RequestOptions) {, +      RequestOptions other = (RequestOptions) o;, +      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0, +          && errorId == other.errorId, +          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder), +          && placeholderId == other.placeholderId, +          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable), +          && fallbackId == other.fallbackId, +          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable), +          && isCacheable == other.isCacheable, +          && overrideHeight == other.overrideHeight, +          && overrideWidth == other.overrideWidth, +          && isTransformationRequired == other.isTransformationRequired, +          && isTransformationAllowed == other.isTransformationAllowed, +          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool, +          && onlyRetrieveFromCache == other.onlyRetrieveFromCache, +          && diskCacheStrategy.equals(other.diskCacheStrategy), +          && priority == other.priority, +          && options.equals(other.options), +          && transformations.equals(other.transformations), +          && resourceClass.equals(other.resourceClass), +          && Util.bothNullOrEqual(signature, other.signature), +          && Util.bothNullOrEqual(theme, other.theme);, +    }, +    return false;, +  }, +, +  @Override, +  public int hashCode() {, +    int hashCode = Util.hashCode(sizeMultiplier);, +    hashCode = Util.hashCode(errorId, hashCode);, +    hashCode = Util.hashCode(errorPlaceholder, hashCode);, +    hashCode = Util.hashCode(placeholderId, hashCode);, +    hashCode = Util.hashCode(placeholderDrawable, hashCode);, +    hashCode = Util.hashCode(fallbackId, hashCode);, +    hashCode = Util.hashCode(fallbackDrawable, hashCode);, +    hashCode = Util.hashCode(isCacheable, hashCode);, +    hashCode = Util.hashCode(overrideHeight, hashCode);, +    hashCode = Util.hashCode(overrideWidth, hashCode);, +    hashCode = Util.hashCode(isTransformationRequired, hashCode);, +    hashCode = Util.hashCode(isTransformationAllowed, hashCode);, +    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);]