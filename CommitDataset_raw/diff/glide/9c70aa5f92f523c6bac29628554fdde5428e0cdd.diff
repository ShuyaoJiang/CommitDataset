[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +    // Don't check primary.isFailed() here because it will have been reset by the clear call, +    // immediately before this., +    if (error.isRunning()) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +    // Don't check primary.isFailed() here because it will have been reset by the clear call, +    // immediately before this., +    if (error.isRunning()) {, +++ b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java, +  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {, +    when(error.isRunning()).thenReturn(true);, +  public void clear_whenErrorIsRunning_clearsError() {, +    when(error.isRunning()).thenReturn(true);, +    coordinator.clear();, +, +    verify(error).clear();]