[+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +public interface ConnectivityMonitor extends LifecycleListener {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +public interface ConnectivityMonitor extends LifecycleListener {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +    private void register() {, +    private void unregister() {]