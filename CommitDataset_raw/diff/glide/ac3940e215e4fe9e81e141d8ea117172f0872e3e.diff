[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +  static final int EXIF_MAGIC_NUMBER = 0xFFD8;, +  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";, +  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =, +  static final int SEGMENT_START_ID = 0xFF;, +  static final int EXIF_SEGMENT_TYPE = 0xE1;, +  private static final class RandomAccessReader {, +    RandomAccessReader(byte[] data, int length) {, +    void order(ByteOrder byteOrder) {, +    int length() {, +    int getInt32(int offset) {, +      return isAvailable(offset, 4) ? data.getInt(offset) : -1;, +    short getInt16(int offset) {, +      return isAvailable(offset, 2) ? data.getShort(offset) : -1;, +    }, +, +    private boolean isAvailable(int offset, int byteSize) {, +      return data.remaining() - offset >= byteSize;, +  private static final class ByteBufferReader implements Reader {, +    ByteBufferReader(ByteBuffer byteBuffer) {, +      if (toRead == 0) {, +        return -1;, +      }, +      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);, +  private static final class StreamReader implements Reader {, +    StreamReader(InputStream is) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +  static final int EXIF_MAGIC_NUMBER = 0xFFD8;, +  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";, +  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =, +  static final int SEGMENT_START_ID = 0xFF;, +  static final int EXIF_SEGMENT_TYPE = 0xE1;, +  private static final class RandomAccessReader {, +    RandomAccessReader(byte[] data, int length) {, +    void order(ByteOrder byteOrder) {, +    int length() {, +    int getInt32(int offset) {, +      return isAvailable(offset, 4) ? data.getInt(offset) : -1;, +    short getInt16(int offset) {, +      return isAvailable(offset, 2) ? data.getShort(offset) : -1;, +    }, +, +    private boolean isAvailable(int offset, int byteSize) {, +      return data.remaining() - offset >= byteSize;, +  private static final class ByteBufferReader implements Reader {, +    ByteBufferReader(ByteBuffer byteBuffer) {, +      if (toRead == 0) {, +        return -1;, +      }, +      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);, +  private static final class StreamReader implements Reader {, +    StreamReader(InputStream is) {, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java, +  @Test, +  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {, +    ByteBuffer jpegHeaderBytes = getExifMagicNumber();, +    byte[] data = new byte[] {, +        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),, +        (byte) ImageHeaderParser.SEGMENT_START_ID,, +        (byte) ImageHeaderParser.EXIF_SEGMENT_TYPE,, +        // SEGMENT_LENGTH, +        (byte) 0xFF, (byte) 0xFF,, +    };, +    ByteBuffer byteBuffer = ByteBuffer.wrap(data);, +    ImageHeaderParser parser = new ImageHeaderParser(byteBuffer, byteArrayPool);, +    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation());, +  }, +, +  @Test, +  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {, +    ByteBuffer jpegHeaderBytes = getExifMagicNumber();, +    byte[] data = new byte[] {, +        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),, +        (byte) ImageHeaderParser.SEGMENT_START_ID,, +        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE), +        (byte) 0xE5,, +        // SEGMENT_LENGTH, +        (byte) 0xFF, (byte) 0xFF,, +    };, +    ByteBuffer byteBuffer = ByteBuffer.wrap(data);, +    ImageHeaderParser parser = new ImageHeaderParser(byteBuffer, byteArrayPool);, +    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation());, +  }, +, +  @Test, +  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown(), +      throws IOException {, +    ByteBuffer jpegHeaderBytes = getExifMagicNumber();, +    ByteBuffer exifSegmentPreamble =, +        ByteBuffer.wrap(ImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);, +, +    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());, +    data.put(jpegHeaderBytes), +        .put((byte) ImageHeaderParser.SEGMENT_START_ID), +        .put((byte) ImageHeaderParser.EXIF_SEGMENT_TYPE), +        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go, +        // beyond the preamble bytes length for the test., +        .putShort((short) (ImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1)), +        .put(ImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);, +]