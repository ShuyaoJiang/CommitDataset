[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        throw new RuntimeException("Load failed");, +    doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(any(SizeReadyCallback.class));, +    doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(any(SizeReadyCallback.class));, +    RequestBuilder<Drawable> firstRequest = Glide.with(getContext()), +        .asDrawable(), +        .load(mockUri("content://first"));, +    firstRequest.into(firstTarget);, +, +    firstRequest.clone(), +        .apply(placeholderOf(new ColorDrawable(Color.RED))), +        .into(secondTarget);, +, +    verify(firstTarget).onResourceReady(any(Resource.class), any(Transition.class));, +    verify(secondTarget).onResourceReady(anyObject(), any(Transition.class));, +  // where we seem to get one content resolver shadow in one part of the test and a different one in, +  // a different part of the test. Each one ends up with different registered uris, which causes, +  // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue., +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        throw new RuntimeException("Load failed");, +    doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(any(SizeReadyCallback.class));, +    doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(any(SizeReadyCallback.class));, +    RequestBuilder<Drawable> firstRequest = Glide.with(getContext()), +        .asDrawable(), +        .load(mockUri("content://first"));, +    firstRequest.into(firstTarget);, +, +    firstRequest.clone(), +        .apply(placeholderOf(new ColorDrawable(Color.RED))), +        .into(secondTarget);, +, +    verify(firstTarget).onResourceReady(any(Resource.class), any(Transition.class));, +    verify(secondTarget).onResourceReady(anyObject(), any(Transition.class));, +  // where we seem to get one content resolver shadow in one part of the test and a different one in, +  // a different part of the test. Each one ends up with different registered uris, which causes, +  // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue., +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +  @Mock GlideContext glideContext;, +  @Mock RequestTracker requestTracker;, +  @Mock Lifecycle lifecycle;, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        throw new RuntimeException("Load failed");, +    doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(any(SizeReadyCallback.class));, +    doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(any(SizeReadyCallback.class));, +    RequestBuilder<Drawable> firstRequest = Glide.with(getContext()), +        .asDrawable(), +        .load(mockUri("content://first"));, +    firstRequest.into(firstTarget);, +, +    firstRequest.clone(), +        .apply(placeholderOf(new ColorDrawable(Color.RED))), +        .into(secondTarget);, +, +    verify(firstTarget).onResourceReady(any(Resource.class), any(Transition.class));, +    verify(secondTarget).onResourceReady(anyObject(), any(Transition.class));, +  // where we seem to get one content resolver shadow in one part of the test and a different one in, +  // a different part of the test. Each one ends up with different registered uris, which causes, +  // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue., +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +  @Mock GlideContext glideContext;, +  @Mock RequestTracker requestTracker;, +  @Mock Lifecycle lifecycle;, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        throw new RuntimeException("Load failed");, +    doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(any(SizeReadyCallback.class));, +    doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(any(SizeReadyCallback.class));, +    RequestBuilder<Drawable> firstRequest = Glide.with(getContext()), +        .asDrawable(), +        .load(mockUri("content://first"));, +    firstRequest.into(firstTarget);, +, +    firstRequest.clone(), +        .apply(placeholderOf(new ColorDrawable(Color.RED))), +        .into(secondTarget);, +, +    verify(firstTarget).onResourceReady(any(Resource.class), any(Transition.class));, +    verify(secondTarget).onResourceReady(anyObject(), any(Transition.class));, +  // where we seem to get one content resolver shadow in one part of the test and a different one in, +  // a different part of the test. Each one ends up with different registered uris, which causes, +  // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue., +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +  @Mock GlideContext glideContext;, +  @Mock RequestTracker requestTracker;, +  @Mock Lifecycle lifecycle;, +++ /dev/null, +++ /dev/null]