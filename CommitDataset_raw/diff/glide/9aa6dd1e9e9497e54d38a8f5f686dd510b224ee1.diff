[+++ b/library/src/com/bumptech/glide/loader/bitmap/model/Cache.java, +import com.bumptech.glide.util.LruCache;, +    private LruCache<ModelKey, A> cache = new LruCache<ModelKey, A>(250);, +++ b/library/src/com/bumptech/glide/loader/bitmap/model/Cache.java, +import com.bumptech.glide.util.LruCache;, +    private LruCache<ModelKey, A> cache = new LruCache<ModelKey, A>(250);, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +import com.bumptech.glide.util.LruCache;, +    private final LruCache<LoadId, String> loadIdToSafeHash = new LruCache<LoadId, String>(250);, +++ b/library/src/com/bumptech/glide/loader/bitmap/model/Cache.java, +import com.bumptech.glide.util.LruCache;, +    private LruCache<ModelKey, A> cache = new LruCache<ModelKey, A>(250);, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +import com.bumptech.glide.util.LruCache;, +    private final LruCache<LoadId, String> loadIdToSafeHash = new LruCache<LoadId, String>(250);, +++ b/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java, +import com.bumptech.glide.util.LruCache;, +public class LruMemoryCache extends LruCache<String, Bitmap> implements MemoryCache {, +        super(size);, +    protected int getSize(Bitmap item) {, +        return Util.getSize(item);, +    protected void onItemRemoved(Bitmap item) {, +        if (imageRemovedListener != null) {, +            imageRemovedListener.onImageRemoved(item);, +            trimToSize(getCurrentSize() / 2);, +++ b/library/src/com/bumptech/glide/loader/bitmap/model/Cache.java, +import com.bumptech.glide.util.LruCache;, +    private LruCache<ModelKey, A> cache = new LruCache<ModelKey, A>(250);, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +import com.bumptech.glide.util.LruCache;, +    private final LruCache<LoadId, String> loadIdToSafeHash = new LruCache<LoadId, String>(250);, +++ b/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java, +import com.bumptech.glide.util.LruCache;, +public class LruMemoryCache extends LruCache<String, Bitmap> implements MemoryCache {, +        super(size);, +    protected int getSize(Bitmap item) {, +        return Util.getSize(item);, +    protected void onItemRemoved(Bitmap item) {, +        if (imageRemovedListener != null) {, +            imageRemovedListener.onImageRemoved(item);, +            trimToSize(getCurrentSize() / 2);, +++ b/library/src/com/bumptech/glide/util/LruCache.java, +package com.bumptech.glide.util;, +, +import java.util.LinkedHashMap;, +import java.util.Map;, +, +/**, + * A general purpose size limited cache that evicts items using an LRU algorithm. By default every item is assumed to, + * have a size of one. Subclasses can override {@link #getSize(Object)}} to change the size on a per item basis., + *, + * @param <T> The type of the keys., + * @param <Y> The type of the values., + */, +public class LruCache<T, Y> {, +    private final LinkedHashMap<T, Y> cache = new LinkedHashMap<T, Y>(100, 0.75f, true);, +    private final int maxSize;, +    private int currentSize = 0;, +, +    public LruCache(int size) {, +        this.maxSize = size;, +    }, +, +    protected int getSize(Y item) {, +        return 1;, +    }, +, +    protected void onItemRemoved(Y item) {, +, +    }, +, +    public int getCurrentSize() {, +        return currentSize;, +    }, +, +    public boolean contains(T key) {, +        return cache.containsKey(key);, +    }, +, +    public Y get(T key) {, +        return cache.get(key);, +    }, +, +    public Y put(T key, Y item) {, +        currentSize += getSize(item);, +        final Y result = cache.put(key, item);, +        evict();, +        return result;, +    }, +, +    public void clearMemory() {, +        trimToSize(0);, +    }, +, +    protected void trimToSize(int size) {, +        Map.Entry<T, Y> last;, +        while (currentSize > size) {, +            last = cache.entrySet().iterator().next();, +            final Y toRemove = last.getValue();, +            currentSize -= getSize(toRemove);]