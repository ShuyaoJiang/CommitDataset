[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +        return new ResourceRunner<Z, R>(key, width, height, diskCache, cacheDecoder, transformation, transcoder,, +                sourceRunner, service, bgHandler, engineJob);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +        return new ResourceRunner<Z, R>(key, width, height, diskCache, cacheDecoder, transformation, transcoder,, +                sourceRunner, service, bgHandler, engineJob);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +    private Transformation<Z> transformation;, +            ResourceDecoder<InputStream, Z> cacheDecoder, Transformation<Z> transformation,, +            ResourceTranscoder<Z, R> transcoder, SourceResourceRunner sourceRunner, ExecutorService executorService,, +            Handler bgHandler, EngineJob job) {, +        this.transformation = transformation;, +            Resource<Z> transformed = transformation.transform(fromCache, width, height);, +            if (transformed != fromCache) {, +                fromCache.recycle();, +            }, +            Resource<R> transcoded = transcoder.transcode(transformed);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +        return new ResourceRunner<Z, R>(key, width, height, diskCache, cacheDecoder, transformation, transcoder,, +                sourceRunner, service, bgHandler, engineJob);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +    private Transformation<Z> transformation;, +            ResourceDecoder<InputStream, Z> cacheDecoder, Transformation<Z> transformation,, +            ResourceTranscoder<Z, R> transcoder, SourceResourceRunner sourceRunner, ExecutorService executorService,, +            Handler bgHandler, EngineJob job) {, +        this.transformation = transformation;, +            Resource<Z> transformed = transformation.transform(fromCache, width, height);, +            if (transformed != fromCache) {, +                fromCache.recycle();, +            }, +            Resource<R> transcoded = transcoder.transcode(transformed);, +++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +    public void testTransformationIsCalledIfCacheDecodeSucceeds() throws IOException {, +        verify(harness.tranformation).transform(eq(harness.decoded), eq(harness.width), eq(harness.height));, +    }, +, +    @Test, +    public void testTranscoderIsCalledIfCacheDecodeSucceeds() throws IOException {, +        InputStream is = new ByteArrayInputStream(new byte[0]);, +        when(harness.diskCache.get(eq(harness.key))).thenReturn(is);, +        when(harness.decoder.decode(eq(is), eq(harness.width), eq(harness.height))).thenReturn(harness.decoded);, +        when(harness.tranformation.transform(eq(harness.decoded), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.transformed);, +, +        harness.runner.run();, +, +        verify(harness.transcoder).transcode(eq(harness.transformed));, +        when(harness.tranformation.transform(eq(harness.decoded), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.transformed);, +        when(harness.transcoder, +                .transcode(eq(harness.transformed))).thenReturn(harness.transcoded);, +        when(harness.tranformation.transform(eq(harness.decoded), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.transformed);, +        when(harness.transcoder, +                .transcode(eq(harness.transformed))).thenReturn(harness.transcoded);, +        verify(harness.transformed, never()).recycle();, +        verify(harness.transformed, never()).release();, +    @Test, +    public void testDecodedResourceIsRecycledIfTransformedResourceIsDifferent() throws IOException {, +        InputStream is = new ByteArrayInputStream(new byte[0]);, +        when(harness.diskCache.get(eq(harness.key))).thenReturn(is);, +        when(harness.decoder.decode(eq(is), eq(harness.width), eq(harness.height))).thenReturn(harness.decoded);, +        when(harness.tranformation.transform(eq(harness.decoded), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.transformed);, +, +        harness.runner.run();, +, +        verify(harness.decoded).recycle();, +    }, +, +    @Test, +    public void testDecodedResourceIsNotRecycledIfTransformedResourceIsDecodedResource() throws IOException {, +        InputStream is = new ByteArrayInputStream(new byte[0]);, +        when(harness.diskCache.get(eq(harness.key))).thenReturn(is);, +        when(harness.decoder.decode(eq(is), eq(harness.width), eq(harness.height))).thenReturn(harness.decoded);, +        when(harness.tranformation.transform(eq(harness.decoded), eq(harness.width), eq(harness.height))), +                .thenReturn(harness.decoded);, +, +        harness.runner.run();, +, +        verify(harness.decoded, never()).recycle();, +    }, +, +        Transformation<Object> tranformation = mock(Transformation.class);, +                tranformation, transcoder, sourceRunner, service, bgHandler, engineJob);, +        Resource<Object> transformed = mock(Resource.class);]