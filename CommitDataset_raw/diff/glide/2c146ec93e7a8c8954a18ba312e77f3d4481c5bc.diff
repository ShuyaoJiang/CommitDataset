[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    // Allow the request to be run and GCed without being cleared., +    concurrency.loadOnOtherThread(new Runnable() {, +      @Override, +      public void run() {, +      }, +    });, +    // Wait for the weak reference to be cleared and the request to be removed from active, +    // resources., +    for (int j = 0; j < 100; j++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    // Allow the request to be run and GCed without being cleared., +    concurrency.loadOnOtherThread(new Runnable() {, +      @Override, +      public void run() {, +      }, +    });, +    // Wait for the weak reference to be cleared and the request to be removed from active, +    // resources., +    for (int j = 0; j < 100; j++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import java.util.concurrent.atomic.AtomicBoolean;, +  public void loadOnOtherThread(final Runnable runnable) {, +    final AtomicBoolean isDone = new AtomicBoolean();, +    Thread thread = new Thread(new Runnable() {, +      @Override, +      public void run() {, +        runnable.run();, +        isDone.set(true);, +      }, +    });, +    thread.start();, +    try {, +      thread.join(TIMEOUT_MS, /*nanos=*/0);, +    } catch (InterruptedException e) {, +      throw new RuntimeException(e);, +    }, +    if (!isDone.get()) {, +      throw new IllegalStateException("Failed to finish job in available time");, +    }, +  }, +]