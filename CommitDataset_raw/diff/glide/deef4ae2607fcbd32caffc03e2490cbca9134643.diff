[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +import android.util.Log;, +, +    private static final String TAG = "BufferedIs";, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "allocate buffer of length: " + newLength);, +            }, +        // TODO: This is a violation of the API because it requires that you call mark() once per call to reset()., +        // We reset markpos to -1 so that after reset is called, we no longer continue to allocate larger and larger, +        // buffers. If we don't do this, we continually allocate new buffers so that the entire stream is held in memory, +        // at once. We could use a fixed size buffer, but that limits our mark size. In practice requiring users to, +        // call mark once per call to reset seems to work. See issue #225., +        markpos = -1;]