[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.AdditionalMatchers.not;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import com.bumptech.glide.test.ResourceIds.raw;, +  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +, +    concurrency.get(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .submit());, +, +    verify(requestListener), +        .onResourceReady(, +            any(Drawable.class),, +            any(),, +            anyTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +, +    // Allow first to be GCed and removed from active resources., +    //noinspection UnusedAssignment, +    first = null;, +    // De-flake by allowing multiple tries, +    for (int j = 0; j < 10; j++) {, +      Runtime.getRuntime().gc();, +      concurrency.pokeMainThread();, +      try {, +        // Loading again here won't shuffle our resource around because it only changes our, +        // reference count from 1 to 2 and back. The reference we're waiting for will only be, +        // decremented when the target is GCed., +        FutureTarget<Drawable> target =, +            concurrency.wait(, +                GlideApp.with(context), +                    .load(ResourceIds.raw.canonical), +                    .onlyRetrieveFromCache(true), +                    .diskCacheStrategy(DiskCacheStrategy.NONE), +                    .submit());, +        GlideApp.with(context).clear(target);, +      } catch (RuntimeException e) {, +        // The item has been cleared from active resources., +        break;, +      }, +    }, +, +    concurrency.get(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .submit());, +, +    verify(requestListener), +        .onResourceReady(, +            any(Drawable.class),, +            any(),, +            anyTarget(),, +            not(eq(DataSource.MEMORY_CACHE)),, +            anyBoolean());, +  }, +, +  @Test, +, +    concurrency.pokeMainThread();, +, +, +    concurrency.pokeMainThread();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.AdditionalMatchers.not;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import com.bumptech.glide.test.ResourceIds.raw;, +  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +]