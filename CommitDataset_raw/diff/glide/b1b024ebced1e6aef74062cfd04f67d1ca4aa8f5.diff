[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.load.ImageHeaderParser.ImageType;, +  // Defines the level of precision we get when using inDensity/inTargetDensity to calculate an, +  // arbitrary float scale factor., +  private static final int DENSITY_PRECISION_MULTIPLIER = 1000000000;, +    ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);, +, +    calculateScaling(, +        imageType,, +        is,, +        callbacks,, +        bitmapPool,, +        downsampleStrategy,, +        degreesToRotate,, +        sourceWidth,, +        sourceHeight,, +        targetWidth,, +        targetHeight,, +        options);, +    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {, +  static void calculateScaling(, +      ImageType imageType,, +      InputStream is,, +      DecodeCallbacks decodeCallbacks,, +      BitmapPool bitmapPool,, +      DownsampleStrategy downsampleStrategy,, +      int sourceWidth,, +      int sourceHeight,, +      int targetWidth,, +      int targetHeight,, +      BitmapFactory.Options options) throws IOException {, +          + " from: " + downsampleStrategy, +          + ", source: [" + sourceWidth + "x" + sourceHeight + "]", +          + ", target: [" + targetWidth + "x" + targetHeight + "]");, +    int outWidth = round(exactScaleFactor * sourceWidth);, +    int outHeight = round(exactScaleFactor * sourceHeight);, +    // Here we mimic framework logic for determining how inSampleSize division is rounded on various, +    // versions of Android. The logic here has been tested on emulators for Android versions 15-26., +    // PNG - Always uses floor, +    // JPEG - Always uses ceiling, +    // Webp - Prior to N, always uses floor. At and after N, always uses round., +    final int powerOfTwoWidth;, +    final int powerOfTwoHeight;, +    // Jpeg rounds with ceiling on all API verisons., +    if (imageType == ImageType.JPEG) {, +      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) powerOfTwoSampleSize);, +      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) powerOfTwoSampleSize);, +    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {, +      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);, +      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);, +    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {, +      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {, +        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);, +        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);, +      } else {, +        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);, +        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);, +      }, +    } else if (, +        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {, +      // If we're not confident the image is in one of our types, fall back to checking the, +      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize., +      int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);, +      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine, +      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make, +      // sure that we at least provide a Bitmap that's large enough to fit the content we're going, +      // to load., +      powerOfTwoWidth = dimensions[0];, +      powerOfTwoHeight = dimensions[1];, +    } else {, +      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;, +      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;, +    }, +, +    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(, +        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);, +, +      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);, +      options.inDensity = DENSITY_PRECISION_MULTIPLIER;, +          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]", +  /**, +   * BitmapFactory calculates the density scale factor as a float. This introduces some non-trivial, +   * error. This method attempts to account for that error by adjusting the inTargetDensity so that, +   * the final scale factor is as close to our target as possible., +   */, +  private static int adjustTargetDensityForError(double adjustedScaleFactor) {, +    int targetDensity = round(DENSITY_PRECISION_MULTIPLIER * adjustedScaleFactor);, +    float scaleFactorWithError = targetDensity / (float) DENSITY_PRECISION_MULTIPLIER;, +    double difference = adjustedScaleFactor / scaleFactorWithError;, +    return round(difference * targetDensity);, +  }, +, +  // This is weird, but it matches the logic in a bunch of Android views/framework classes for, +  // rounding., +  private static int round(double value) {, +    return (int) (value + 0.5d);, +  }, +, +  private boolean shouldUsePool(ImageType imageType) throws IOException {, +    return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(imageType);]