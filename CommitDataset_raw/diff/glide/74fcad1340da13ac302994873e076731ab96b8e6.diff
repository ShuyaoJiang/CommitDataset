[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +  private final Pool<List<Throwable>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {, +    List<Throwable> exceptions = listPool.acquire();, +      int height, Options options, List<Throwable> exceptions) throws GlideException {, +      } catch (IOException | RuntimeException | OutOfMemoryError e) {, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +  private final Pool<List<Throwable>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {, +    List<Throwable> exceptions = listPool.acquire();, +      int height, Options options, List<Throwable> exceptions) throws GlideException {, +      } catch (IOException | RuntimeException | OutOfMemoryError e) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java, +  private final List<Throwable> causes;, +    this(message, Collections.<Throwable>emptyList());, +  public GlideException(String detailMessage, Throwable cause) {, +  public GlideException(String detailMessage, List<Throwable> causes) {, +  public List<Throwable> getCauses() {, +  public List<Throwable> getRootCauses() {, +    List<Throwable> rootCauses = new ArrayList<>();, +    List<Throwable> causes = getRootCauses();, +  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {, +    if (throwable instanceof GlideException) {, +      GlideException glideException = (GlideException) throwable;]