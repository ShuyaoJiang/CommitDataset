[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +   * Returns a request builder to load the given {@link Bitmap}., +   *, +   * <p>{@link Bitmap}s provided to this method become owned by Glide. The {@link Bitmap} may be, +   * recycled or re-used at any time. If you do not own the Bitmap or you need to continue to use, +   * the {@link Bitmap} after passing it in to Glide, consider passing a copy of the {@link Bitmap}, +   * to Glide instead. It's almost always better to allow Glide to load {@link Bitmap}s than, +   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is, +   * not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not, +   * compared., +   *, +   * @see #load(Object), +   */, +  @CheckResult, +  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {, +    return loadGeneric(bitmap), +        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));, +  }, +, +  /**, +   * Returns a request builder to load the given {@link Drawable}., +   *, +   * <p>{@link Drawable}s provided to this method become owned by Glide. They or {@link Bitmap}s, +   * they contain may be recycled or re-used at any time. If you do not own the {@link Drawable},, +   * do not pass it in to Glide. It's almost always better to allow Glide to load {@link Bitmap}s, +   * than pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that, +   * is not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not, +   * compared., +   *, +   * @see #load(Object), +   */, +  @CheckResult, +  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {, +    return loadGeneric(drawable), +        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));, +  }, +, +  /**, +   * Returns a request builder to load the given {@link java.lang.String}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +   * Returns a request builder to load the given {@link Bitmap}., +   *, +   * <p>{@link Bitmap}s provided to this method become owned by Glide. The {@link Bitmap} may be, +   * recycled or re-used at any time. If you do not own the Bitmap or you need to continue to use, +   * the {@link Bitmap} after passing it in to Glide, consider passing a copy of the {@link Bitmap}, +   * to Glide instead. It's almost always better to allow Glide to load {@link Bitmap}s than, +   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is, +   * not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not, +   * compared.]