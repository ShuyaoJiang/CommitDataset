[+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import java.util.Collection;, +import java.util.List;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.TimeoutException;, +public final class GlideExecutor implements ExecutorService {, +, +, +, +  private static final String ANIMATION_EXECUTOR_NAME = "animation";, +, +  // Don't use more than four threads when automatically determining thread count.., +  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;, +, +  // May be accessed on other threads, but this is an optimization only so it's ok if we set its, +  // value more than once., +  private static volatile int bestThreadCount;, +, +  private final ExecutorService delegate;, +    return newDiskCacheExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        UncaughtThrowableStrategy.DEFAULT);, +    return newDiskCacheExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        uncaughtThrowableStrategy);, +    return new GlideExecutor(new ThreadPoolExecutor(, +        threadCount /* corePoolSize */,, +        threadCount /* maximumPoolSize */,, +        0 /* keepAliveTime */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));, +    return newSourceExecutor(, +        calculateBestThreadCount(),, +        DEFAULT_SOURCE_EXECUTOR_NAME,, +    return newSourceExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        uncaughtThrowableStrategy);, +  public static GlideExecutor newSourceExecutor(, +      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {, +    return new GlideExecutor(new ThreadPoolExecutor(, +        threadCount /* corePoolSize */,, +        threadCount /* maximumPoolSize */,, +        0 /* keepAliveTime */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));, +    return new GlideExecutor(new ThreadPoolExecutor(, +        0,, +        Integer.MAX_VALUE,, +        TimeUnit.MILLISECONDS,, +        new SynchronousQueue<Runnable>(),, +        new DefaultThreadFactory(, +            false)));, +    return new GlideExecutor(new ThreadPoolExecutor(, +        0 /* corePoolSize */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(, +            true)));, +  GlideExecutor(ExecutorService delegate) {, +    this.delegate = delegate;, +    delegate.execute(command);, +    return delegate.submit(task);, +  @NonNull, +  @Override, +  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks), +      throws InterruptedException {, +    return delegate.invokeAll(tasks);, +, +  @NonNull, +  @Override, +  public <T> List<Future<T>> invokeAll(, +      @NonNull Collection<? extends Callable<T>> tasks,, +      long timeout,, +      @NonNull TimeUnit unit) throws InterruptedException {, +    return delegate.invokeAll(tasks, timeout, unit);, +, +  @NonNull, +  @Override, +  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks), +      throws InterruptedException, ExecutionException {, +    return delegate.invokeAny(tasks);, +, +  @Override, +  public <T> T invokeAny(, +      @NonNull Collection<? extends Callable<T>> tasks,, +      long timeout,, +      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {, +    return delegate.invokeAny(tasks, timeout, unit);, +    return delegate.submit(task, result);, +    return delegate.submit(task);, +  }, +, +  @Override, +  public void shutdown() {, +    delegate.shutdown();]