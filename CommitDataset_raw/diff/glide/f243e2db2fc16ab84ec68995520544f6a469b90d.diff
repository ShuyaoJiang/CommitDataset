[+++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java, +package com.bumptech.glide.resize.load;, +, +import com.bumptech.glide.util.Log;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +, +/**, + * A class for parsing the exif orientation from an InputStream for an image. Handles jpegs and tiffs., + */, +public class ImageHeaderParser {, +    private static final int GIF_HEADER = 0x474946;, +    private static final int PNG_HEADER = 0x89504E47;, +    private static final int EXIF_MAGIC_NUMBER = 0xFFD8;, +    private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;  // "MM", +    private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;     // "II", +    private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";, +, +    private static final int SEGMENT_SOS = 0xDA;, +    private static final int MARKER_EOI = 0xD9;, +, +    private static final int SEGMENT_START_ID = 0xFF;, +    private static final int EXIF_SEGMENT_TYPE = 0xE1;, +, +    private static final int ORIENTATION_TAG_TYPE = 0x0112;, +, +    private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };, +, +    private final StreamReader streamReader;, +, +    public ImageHeaderParser(InputStream is) {, +        streamReader = new StreamReader(is);, +    }, +, +, +    // 0xD0A3C68 -> <htm, +    // 0xCAFEBABE -> <!DOCTYPE..., +    public boolean hasAlpha() throws IOException {, +        int firstByte = streamReader.getUInt8();, +, +        if (firstByte == EXIF_MAGIC_NUMBER >> 8) { //JPEG, +            return false;, +        }, +, +        final int firstTwoBytes = firstByte << 8 & 0xFF00 | streamReader.getUInt8() & 0xFF;, +        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;, +        if (firstFourBytes == PNG_HEADER) { //PNG, +            //see: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type, +            streamReader.skip(25 - 4);, +            int alpha = streamReader.getByte();, +            return alpha > 3;, +        }, +, +        if (firstFourBytes >> 8 == GIF_HEADER) { //GIF from first 3 bytes, +            return true;, +        }, +, +        return false;, +    }, +, +    /**, +     * Parse the orientation from the image header. If it doesn't handle this image type (or this is not an image), +     * it will return a default value rather than throwing an exception., +     *, +     * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't contain an orientation, +     * @throws IOException, +     */, +    public int getOrientation() throws IOException {, +        final int magicNumber = streamReader.getUInt16();, +, +        if (!handles(magicNumber)) {, +            return -1;, +        } else {, +            byte[] exifData = getExifSegment();, +            if (exifData != null && exifData.length >= JPEG_EXIF_SEGMENT_PREAMBLE.length() &&, +                new String(exifData, 0, JPEG_EXIF_SEGMENT_PREAMBLE.length()).equalsIgnoreCase(JPEG_EXIF_SEGMENT_PREAMBLE)) {, +                return parseExifSegment(new RandomAccessReader(exifData));, +            } else {, +                return -1;, +            }, +        }, +    }, +, +    private byte[] getExifSegment() throws IOException {, +        short segmentId, segmentType;, +        int segmentLength;]