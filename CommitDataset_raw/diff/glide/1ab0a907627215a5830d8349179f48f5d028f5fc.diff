[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;, +  // Maximum size is 256, see GifHeaderParser.readColorTable, +  // Private color table that can be modified if needed, +  private final int[] pct = new int[256];, +    act = currentFrame.lct != null ? currentFrame.lct : header.gct;, +      // Prepare local copy of color table ("pct = act"), see #1068, +      System.arraycopy(act, 0, pct, 0, act.length);, +      // Forget about act reference from shared header object, use copied version, +      act = pct;, +      // Set transparent color if specified., +      act[currentFrame.transIndex] = 0;, +    // Transfer pixel data to image., +    return setPixels(currentFrame, previousFrame);, +    downsampledWidth = header.width / sampleSize;, +    downsampledHeight = header.height / sampleSize;, +    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);, +          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {, +            c = 0;, +          }, +        // The area used by the graphic must be restored to the background color., +        int downsampledIH = previousFrame.ih / sampleSize;, +        int downsampledIY = previousFrame.iy / sampleSize;, +        int downsampledIW = previousFrame.iw / sampleSize;, +        int downsampledIX = previousFrame.ix / sampleSize;, +        int topLeft = downsampledIY * downsampledWidth + downsampledIX;, +        int bottomLeft = topLeft + downsampledIH * downsampledWidth;, +        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {, +          int right = left + downsampledIW;, +          for (int pointer = left; pointer < right; pointer++) {, +            dest[pointer] = c;, +          }, +        }]