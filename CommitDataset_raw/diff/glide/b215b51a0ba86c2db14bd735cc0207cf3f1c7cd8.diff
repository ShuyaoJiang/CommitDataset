[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import android.content.ContentResolver;, +import android.graphics.Bitmap;, +import com.android.volley.Network;, +import com.android.volley.NetworkResponse;, +import com.android.volley.RequestQueue;, +import com.android.volley.toolbox.NoCache;, +import com.bumptech.glide.loader.GlideUrl;, +import com.bumptech.glide.loader.bitmap.resource.ResourceFetcher;, +import com.bumptech.glide.resize.EngineBuilder;, +import com.bumptech.glide.resize.ImageManager;, +import com.bumptech.glide.resize.Metadata;, +import com.bumptech.glide.resize.request.Request;, +import com.bumptech.glide.volley.VolleyRequestFuture;, +import com.bumptech.glide.volley.VolleyUrlLoader;, +import junit.framework.Assert;, +import org.junit.After;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import java.io.ByteArrayInputStream;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Future;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +    private Target target = null;, +        // Ensure that target's size ready callback will be called synchronously., +        target = mock(Target.class);, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocation) throws Throwable {, +                Target.SizeReadyCallback cb = (Target.SizeReadyCallback) invocation.getArguments()[0];, +                cb.onSizeReady(100, 100);, +                return null;, +            }, +        }).when(target).getSize(any(Target.SizeReadyCallback.class));, +, +        // Run all tasks on the main thread so they complete synchronously., +        ExecutorService service = mock(ExecutorService.class);, +        when(service.submit(any(Runnable.class))).thenAnswer(new Answer<Object>() {, +            @Override, +            public Object answer(InvocationOnMock invocation) throws Throwable {, +                Runnable runnable = (Runnable) invocation.getArguments()[0];, +                runnable.run();, +                return mock(Future.class);, +            }, +        });, +, +        // Make sure Volley does not actually perform any network requests., +        Network network = mock(Network.class);, +        when(network.performRequest(any(com.android.volley.Request.class))), +                .thenAnswer(new Answer<Object>() {, +                    @Override, +                    public Object answer(InvocationOnMock invocation) throws Throwable {, +                        return new NetworkResponse(new byte[0]);, +                    }, +                });, +, +        RequestQueue requestQueue = new RequestQueue(new NoCache(), network);, +        requestQueue.start();, +        Glide.setup(new GlideBuilder(Robolectric.application), +                .setEngine(new EngineBuilder(Robolectric.application), +                        .setExecutorService(service), +                        .build()), +                .setImageManager(new ImageManager.Builder(Robolectric.application), +                        .setResizeService(service), +                        .build()), +                .setRequestQueue(requestQueue));, +, +        // Sleep to avoid blocking the main thread while waiting for Volley's background thread to complete, +        // and for the result to be posted back to the main thread., +        VolleyUrlLoader.FutureFactory futureFactory = mock(VolleyUrlLoader.FutureFactory.class);, +        VolleyRequestFuture<InputStream> future = new VolleyRequestFuture<InputStream>() {, +            @Override, +            public InputStream get() throws InterruptedException, ExecutionException {, +                for (int i = 0; i < 10 && !isDone(); i++) {, +                    Thread.sleep(10);, +                    // Make sure the result callback posted on the main thread actually runs., +                    Robolectric.runUiThreadTasks();, +                }, +                if (!isDone()) {, +                    Assert.fail("Failed to get response from Volley in time");, +                }, +                return super.get();, +            }, +        };, +        when(futureFactory.build()).thenReturn(future);, +        Glide.get(getContext()).register(GlideUrl.class, InputStream.class,, +                new VolleyUrlLoader.Factory(Glide.get(getContext()).getRequestQueue(), futureFactory));, +    @After, +    public void tearDown() {, +        Glide.tearDown();, +        mockUri(Uri.fromFile(file));, +, +        Glide.with(getContext()).load(file).into(target);, +]