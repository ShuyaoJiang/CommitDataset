[+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java, +import java.util.regex.Pattern;, +  /**, +   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also, +   * matches dots in their percent-encoded form, {@code %2E}., +   *, +   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code, +   * index.html}) but when alone they have a special meaning. A single dot resolves to no path, +   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding, +   * directory, so {@code /one/../three/} becomes {@code /three/}., +   *, +   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect., +   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE, +   * /account/}., +   */, +  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");, +, +    String replacement = canonicalizeForPath(value, encoded);, +    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);, +    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {, +      throw new IllegalArgumentException(, +          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);, +    }, +    relativeUrl = newRelativeUrl;, +++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java, +import java.util.regex.Pattern;, +  /**, +   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also, +   * matches dots in their percent-encoded form, {@code %2E}., +   *, +   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code, +   * index.html}) but when alone they have a special meaning. A single dot resolves to no path, +   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding, +   * directory, so {@code /one/../three/} becomes {@code /three/}., +   *, +   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect., +   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE, +   * /account/}., +   */, +  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");, +, +    String replacement = canonicalizeForPath(value, encoded);, +    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);, +    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {, +      throw new IllegalArgumentException(, +          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);, +    }, +    relativeUrl = newRelativeUrl;, +++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java, +  @Test public void pathParametersAndPathTraversal() {, +    class Example {, +      @GET("/foo/bar/{ping}/") //, +      Call<ResponseBody> method(@Path(value = "ping") String ping) {, +        return null;, +      }, +    }, +, +    assertMalformedRequest(Example.class, ".");, +    assertMalformedRequest(Example.class, "..");, +, +    assertThat(buildRequest(Example.class, "./a").url().encodedPath()), +        .isEqualTo("/foo/bar/.%2Fa/");, +    assertThat(buildRequest(Example.class, "a/.").url().encodedPath()), +        .isEqualTo("/foo/bar/a%2F./");, +    assertThat(buildRequest(Example.class, "a/..").url().encodedPath()), +        .isEqualTo("/foo/bar/a%2F../");, +    assertThat(buildRequest(Example.class, "../a").url().encodedPath()), +        .isEqualTo("/foo/bar/..%2Fa/");, +    assertThat(buildRequest(Example.class, "..\\..").url().encodedPath()), +        .isEqualTo("/foo/bar/..%5C../");, +, +    assertThat(buildRequest(Example.class, "%2E").url().encodedPath()), +        .isEqualTo("/foo/bar/%252E/");, +    assertThat(buildRequest(Example.class, "%2E%2E").url().encodedPath()), +        .isEqualTo("/foo/bar/%252E%252E/");, +  }, +, +  @Test public void encodedPathParametersAndPathTraversal() {, +    class Example {, +      @GET("/foo/bar/{ping}/") //, +      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {, +        return null;, +      }, +    }, +, +    assertMalformedRequest(Example.class, ".");, +    assertMalformedRequest(Example.class, "%2E");, +    assertMalformedRequest(Example.class, "%2e");, +    assertMalformedRequest(Example.class, "..");, +    assertMalformedRequest(Example.class, "%2E.");, +    assertMalformedRequest(Example.class, "%2e.");, +    assertMalformedRequest(Example.class, ".%2E");, +    assertMalformedRequest(Example.class, ".%2e");, +    assertMalformedRequest(Example.class, "%2E%2e");, +    assertMalformedRequest(Example.class, "%2e%2E");, +    assertMalformedRequest(Example.class, "./a");, +    assertMalformedRequest(Example.class, "a/.");, +    assertMalformedRequest(Example.class, "../a");, +    assertMalformedRequest(Example.class, "a/..");, +    assertMalformedRequest(Example.class, "a/../b");]