[+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java, +import okio.Buffer;, +  private static final char[] HEX_DIGITS =, +      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };, +  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";, +, +    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));, +, +  static String canonicalize(String input, boolean alreadyEncoded) {, +    int codePoint;, +    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {, +      codePoint = input.codePointAt(i);, +      if (codePoint < 0x20 || codePoint >= 0x7f, +          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1, +          || (codePoint == '%' && !alreadyEncoded)) {, +        // Slow path: the character at i requires encoding!, +        Buffer out = new Buffer();, +        out.writeUtf8(input, 0, i);, +        canonicalize(out, input, i, limit, alreadyEncoded);, +        return out.readUtf8();, +      }, +    }, +, +    // Fast path: no characters required encoding., +    return input;, +  }, +, +  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {, +    Buffer utf8Buffer = null; // Lazily allocated., +    int codePoint;, +    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {, +      codePoint = input.codePointAt(i);, +      if (alreadyEncoded, +          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {, +        // Skip this character., +      } else if (codePoint < 0x20, +          || codePoint >= 0x7f, +          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1, +          || (codePoint == '%' && !alreadyEncoded)) {, +        // Percent encode this character., +        if (utf8Buffer == null) {, +          utf8Buffer = new Buffer();, +        }, +        utf8Buffer.writeUtf8CodePoint(codePoint);, +        while (!utf8Buffer.exhausted()) {, +          int b = utf8Buffer.readByte() & 0xff;, +          out.writeByte('%');, +          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);, +          out.writeByte(HEX_DIGITS[b & 0xf]);, +        }, +      } else {, +        // This character doesn't need encoding. Just copy it over., +        out.writeUtf8CodePoint(codePoint);, +      }, +++ b/retrofit/src/main/java/retrofit/RequestBuilder.java, +import okio.Buffer;, +  private static final char[] HEX_DIGITS =, +      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };, +  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";, +, +    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));, +, +  static String canonicalize(String input, boolean alreadyEncoded) {, +    int codePoint;, +    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {, +      codePoint = input.codePointAt(i);, +      if (codePoint < 0x20 || codePoint >= 0x7f, +          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1, +          || (codePoint == '%' && !alreadyEncoded)) {, +        // Slow path: the character at i requires encoding!, +        Buffer out = new Buffer();, +        out.writeUtf8(input, 0, i);, +        canonicalize(out, input, i, limit, alreadyEncoded);, +        return out.readUtf8();, +      }, +    }, +, +    // Fast path: no characters required encoding., +    return input;, +  }, +, +  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {, +    Buffer utf8Buffer = null; // Lazily allocated., +    int codePoint;, +    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {, +      codePoint = input.codePointAt(i);, +      if (alreadyEncoded, +          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {, +        // Skip this character., +      } else if (codePoint < 0x20, +          || codePoint >= 0x7f, +          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1, +          || (codePoint == '%' && !alreadyEncoded)) {, +        // Percent encode this character., +        if (utf8Buffer == null) {, +          utf8Buffer = new Buffer();, +        }, +        utf8Buffer.writeUtf8CodePoint(codePoint);, +        while (!utf8Buffer.exhausted()) {, +          int b = utf8Buffer.readByte() & 0xff;]