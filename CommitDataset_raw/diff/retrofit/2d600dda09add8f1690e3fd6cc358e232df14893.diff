[+++ /dev/null, +++ /dev/null, +++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java, +import java.util.LinkedHashMap;, +import java.util.Map;, +    // Add query parameter(s), if specified., +    for (QueryParam annotation : methodInfo.pathQueryParams) {, +      paramList.add(new Parameter(annotation.name(), annotation.value(), String.class));, +    }, +, +    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();, +          bodyParams.put(parameter.getName(), typedOutput);, +    return new Request(methodInfo.restMethod.value(), url.toString(), headers,, +        methodInfo.isMultipart, body, bodyParams);, +++ /dev/null, +++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java, +import java.util.LinkedHashMap;, +import java.util.Map;, +    // Add query parameter(s), if specified., +    for (QueryParam annotation : methodInfo.pathQueryParams) {, +      paramList.add(new Parameter(annotation.name(), annotation.value(), String.class));, +    }, +, +    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();, +          bodyParams.put(parameter.getName(), typedOutput);, +    return new Request(methodInfo.restMethod.value(), url.toString(), headers,, +        methodInfo.isMultipart, body, bodyParams);, +++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java, +    } else {, +      for (QueryParam pathQueryParam : pathQueryParams) {, +        if (pathParams.contains(pathQueryParam.name())) {, +          throw new IllegalStateException("Query parameters cannot be present in URL.");, +        }, +      }, +++ /dev/null, +++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java, +import java.util.LinkedHashMap;, +import java.util.Map;, +    // Add query parameter(s), if specified., +    for (QueryParam annotation : methodInfo.pathQueryParams) {, +      paramList.add(new Parameter(annotation.name(), annotation.value(), String.class));, +    }, +, +    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();, +          bodyParams.put(parameter.getName(), typedOutput);, +    return new Request(methodInfo.restMethod.value(), url.toString(), headers,, +        methodInfo.isMultipart, body, bodyParams);, +++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java, +    } else {, +      for (QueryParam pathQueryParam : pathQueryParams) {, +        if (pathParams.contains(pathQueryParam.name())) {, +          throw new IllegalStateException("Query parameters cannot be present in URL.");, +        }, +      }, +++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java, +import java.util.Map;, +import org.apache.http.entity.mime.MIME;, +import org.apache.http.entity.mime.MultipartEntity;, +import org.apache.http.entity.mime.content.AbstractContentBody;, +import static org.apache.http.entity.mime.HttpMultipartMode.BROWSER_COMPATIBLE;, +, +      if (!request.isMultipart()) {, +      } else {, +        Map<String, TypedOutput> bodyParameters = request.getBodyParameters();, +        if (bodyParameters != null && !bodyParameters.isEmpty()) {, +          MultipartEntity entity = new MultipartEntity(BROWSER_COMPATIBLE);, +          for (Map.Entry<String, TypedOutput> entry : bodyParameters.entrySet()) {, +            entity.addPart(entry.getKey(), new TypedOutputBody(entry.getValue()));, +          }, +          setEntity(entity);, +        }, +      }, +  /** Adapts {@link org.apache.http.entity.mime.content.ContentBody} to {@link TypedOutput}. */, +  private static class TypedOutputBody extends AbstractContentBody {, +    private final TypedOutput typedBytes;, +, +    TypedOutputBody(TypedOutput typedBytes) {, +      super(typedBytes.mimeType());, +      this.typedBytes = typedBytes;, +    }, +, +    @Override public long getContentLength() {, +      return typedBytes.length();, +    }, +, +    @Override public String getFilename() {, +      return null;, +    }, +, +    @Override public String getCharset() {, +      return null;, +    }, +, +    @Override public String getTransferEncoding() {, +      return MIME.ENC_BINARY;, +    }, +, +    @Override public void writeTo(OutputStream out) throws IOException {, +      // Note: We probably want to differentiate I/O errors that occur while reading a file from, +      // network errors. Network operations can be retried. File operations will probably continue]