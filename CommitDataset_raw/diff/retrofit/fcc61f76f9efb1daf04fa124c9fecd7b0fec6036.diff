[+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/ObservableTest.java, +/*, + * Copyright (C) 2015 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package retrofit2;, +, +import java.io.IOException;, +import okhttp3.mockwebserver.MockResponse;, +import okhttp3.mockwebserver.MockWebServer;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import retrofit2.http.GET;, +import rx.Observable;, +import rx.observables.BlockingObservable;, +, +import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;, +import static org.assertj.core.api.Assertions.assertThat;, +import static org.junit.Assert.fail;, +, +public final class ObservableTest {, +  @Rule public final MockWebServer server = new MockWebServer();, +, +  interface Service {, +    @GET("/") Observable<String> body();, +    @GET("/") Observable<Response<String>> response();, +    @GET("/") Observable<Result<String>> result();, +  }, +, +  private Service service;, +, +  @Before public void setUp() {, +    Retrofit retrofit = new Retrofit.Builder(), +        .baseUrl(server.url("/")), +        .addConverterFactory(new StringConverterFactory()), +        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()), +        .build();, +    service = retrofit.create(Service.class);, +  }, +, +  @Test public void bodySuccess200() {, +    server.enqueue(new MockResponse().setBody("Hi"));, +, +    BlockingObservable<String> o = service.body().toBlocking();, +    assertThat(o.first()).isEqualTo("Hi");, +  }, +, +  @Test public void bodySuccess404() {, +    server.enqueue(new MockResponse().setResponseCode(404));, +, +    BlockingObservable<String> o = service.body().toBlocking();, +    try {, +      o.first();, +      fail();, +    } catch (RuntimeException e) {, +      Throwable cause = e.getCause();, +      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");, +    }, +  }, +, +  @Test public void bodyFailure() {, +    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));, +, +    BlockingObservable<String> o = service.body().toBlocking();, +    try {, +      o.first();, +      fail();, +    } catch (RuntimeException e) {, +      assertThat(e.getCause()).isInstanceOf(IOException.class);, +    }, +  }, +, +  @Test public void responseSuccess200() {, +    server.enqueue(new MockResponse().setBody("Hi"));, +, +    BlockingObservable<Response<String>> o = service.response().toBlocking();, +    Response<String> response = o.first();, +    assertThat(response.isSuccess()).isTrue();, +    assertThat(response.body()).isEqualTo("Hi");, +  }, +, +  @Test public void responseSuccess404() throws IOException {, +    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));, +, +    BlockingObservable<Response<String>> o = service.response().toBlocking();, +    Response<String> response = o.first();, +    assertThat(response.isSuccess()).isFalse();, +    assertThat(response.errorBody().string()).isEqualTo("Hi");]