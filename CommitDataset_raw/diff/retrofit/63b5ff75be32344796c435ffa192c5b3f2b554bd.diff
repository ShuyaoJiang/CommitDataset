[+++ b/pom.xml, +    <okhttp.version>3.6.0</okhttp.version>, +++ b/pom.xml, +    <okhttp.version>3.6.0</okhttp.version>, +++ /dev/null, +++ b/pom.xml, +    <okhttp.version>3.6.0</okhttp.version>, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +    <okhttp.version>3.6.0</okhttp.version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +    <okhttp.version>3.6.0</okhttp.version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java, +/*, + * Copyright (C) 2016 Jake Wharton, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package retrofit2.adapter.rxjava;, +, +import java.util.concurrent.atomic.AtomicInteger;, +import retrofit2.Call;, +import retrofit2.Response;, +import rx.Observable.OnSubscribe;, +import rx.Producer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.exceptions.CompositeException;, +import rx.exceptions.Exceptions;, +import rx.plugins.RxJavaPlugins;, +, +final class CallOnSubscribe<T> implements OnSubscribe<Response<T>> {, +  private final Call<T> originalCall;, +, +  CallOnSubscribe(Call<T> originalCall) {, +    this.originalCall = originalCall;, +  }, +, +  @Override public void call(Subscriber<? super Response<T>> subscriber) {, +    // Since Call is a one-shot type, clone it for each new subscriber., +    Call<T> call = originalCall.clone();, +    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);, +    subscriber.add(arbiter);, +    subscriber.setProducer(arbiter);, +, +    Response<T> response;, +    try {, +      response = call.execute();, +    } catch (Throwable t) {, +      Exceptions.throwIfFatal(t);, +      arbiter.emitError(t);, +      return;, +    }, +    arbiter.emitResponse(response);, +  }, +, +  static final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {, +    private static final int STATE_WAITING = 0;, +    private static final int STATE_REQUESTED = 1;, +    private static final int STATE_HAS_RESPONSE = 2;, +    private static final int STATE_TERMINATED = 3;, +, +    private final Call<T> call;, +    private final Subscriber<? super Response<T>> subscriber;, +, +    private volatile Response<T> response;, +, +    CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {, +      super(STATE_WAITING);, +, +      this.call = call;, +      this.subscriber = subscriber;, +    }, +, +    @Override public void unsubscribe() {, +      call.cancel();, +    }, +, +    @Override public boolean isUnsubscribed() {, +      return call.isCanceled();, +    }, +, +    @Override public void request(long amount) {]