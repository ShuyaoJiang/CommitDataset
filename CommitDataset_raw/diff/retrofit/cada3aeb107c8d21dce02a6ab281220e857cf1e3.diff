[+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java, +/*, + * Copyright (C) 2013 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package retrofit;, +, +import java.io.IOException;, +import java.io.InterruptedIOException;, +import java.util.Random;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicReference;, +import org.junit.Before;, +import org.junit.Test;, +import retrofit.mock.CallBehaviorAdapter;, +import retrofit.mock.Calls;, +import retrofit.mock.MockRetrofit;, +import retrofit.mock.NetworkBehavior;, +, +import static java.util.concurrent.Executors.newSingleThreadExecutor;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, +import static org.assertj.core.api.Assertions.assertThat;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +, +public final class MockRetrofitTest {, +  interface DoWorkService {, +    Call<String> response();, +    Call<String> failure();, +  }, +, +  private final IOException mockFailure = new IOException("Timeout!");, +  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));, +  private DoWorkService service;, +, +  @Before public void setUp() {, +    Retrofit retrofit = new Retrofit.Builder(), +        .baseUrl("http://example.com"), +        .build();, +, +    DoWorkService mockService = new DoWorkService() {, +      @Override public Call<String> response() {, +        return Calls.response("Response!");, +      }, +, +      @Override public Call<String> failure() {, +        return Calls.failure(mockFailure);, +      }, +    };, +, +    NetworkBehavior.Adapter<?> adapter =, +        new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());, +    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);, +    service = mockRetrofit.create(DoWorkService.class, mockService);, +  }, +, +  @Test public void syncFailureThrowsAfterDelay() {, +    behavior.setDelay(100, MILLISECONDS);, +    behavior.setVariancePercent(0);, +    behavior.setFailurePercent(100);, +, +    Call<String> call = service.response();, +, +    long startNanos = System.nanoTime();, +    try {, +      call.execute();, +      fail();, +    } catch (IOException e) {, +      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);, +      assertThat(e).isSameAs(behavior.failureException());, +      assertThat(tookMs).isGreaterThanOrEqualTo(100);, +    }, +  }, +, +  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {, +    behavior.setDelay(100, MILLISECONDS);, +    behavior.setVariancePercent(0);, +    behavior.setFailurePercent(100);, +, +    Call<String> call = service.response();, +, +    final long startNanos = System.nanoTime();, +    final AtomicLong tookMs = new AtomicLong();, +    final AtomicReference<Throwable> failureRef = new AtomicReference<>();, +    final CountDownLatch latch = new CountDownLatch(1);]