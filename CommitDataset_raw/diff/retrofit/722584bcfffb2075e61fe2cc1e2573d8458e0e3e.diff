[+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java, +import rx.concurrency.Schedulers;, +    private final RestAdapter restAdapter;, +      this.restAdapter = restAdapter;, +      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));, +++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java, +import rx.concurrency.Schedulers;, +    private final RestAdapter restAdapter;, +      this.restAdapter = restAdapter;, +      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));, +++ b/retrofit/src/main/java/retrofit/RestAdapter.java, +    Scheduler getScheduler() {, +      return scheduler;, +    }, +, +      });, +        }).subscribeOn(rxSupport.getScheduler());, +++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java, +import rx.concurrency.Schedulers;, +    private final RestAdapter restAdapter;, +      this.restAdapter = restAdapter;, +      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));, +++ b/retrofit/src/main/java/retrofit/RestAdapter.java, +    Scheduler getScheduler() {, +      return scheduler;, +    }, +, +      });, +        }).subscribeOn(rxSupport.getScheduler());, +++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java, +          throw methodError("Failed to extract String 'value' from @%s annotation.",, +              annotationType.getSimpleName());, +        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",, +            header);, +    throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");, +              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");, +++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java, +import rx.concurrency.Schedulers;, +    private final RestAdapter restAdapter;, +      this.restAdapter = restAdapter;, +      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));, +++ b/retrofit/src/main/java/retrofit/RestAdapter.java, +    Scheduler getScheduler() {, +      return scheduler;, +    }, +, +      });, +        }).subscribeOn(rxSupport.getScheduler());, +++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java, +          throw methodError("Failed to extract String 'value' from @%s annotation.",, +              annotationType.getSimpleName());, +        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",, +            header);, +    throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");, +              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");, +++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java, +import static retrofit.RestMethodInfo.ParamUsage.FIELD;, +  @Test public void nonParameterizedCallbackFails() {, +    class Example {, +      @GET("/foo") void a(Callback cb) {, +      }, +    }, +, +    Method method = TestingUtils.getMethod(Example.class, "a");, +    try {, +      new RestMethodInfo(method);, +      fail();, +    } catch (IllegalArgumentException e) {, +      assertThat(e).hasMessage(, +          "Example.a: Last parameter must be of type Callback<X> or Callback<? super X>.");, +    }, +  }, +, +  @Test public void twoMethodsFail() {, +    class Example {, +      @PATCH("/foo") @POST("/foo") Response a() {, +        return null;, +      }, +    }, +, +    Method method = TestingUtils.getMethod(Example.class, "a");, +    RestMethodInfo methodInfo = new RestMethodInfo(method);, +, +    try {, +      methodInfo.init();, +      fail();, +    } catch (IllegalArgumentException e) {, +      assertThat(e).hasMessage(, +          "Example.a: Only one HTTP method is allowed. Found: PATCH and POST.");, +    }, +  }, +, +  @RestMethod("BAD"), +  @Target(METHOD) @Retention(RUNTIME), +  private @interface BAD_CUSTOM {, +    int value();, +  }, +, +  @Test public void customWithoutRestMethod() {, +    class Example {]