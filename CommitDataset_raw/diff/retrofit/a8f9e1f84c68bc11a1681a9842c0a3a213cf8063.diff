[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/retrofit/src/main/java/retrofit/RestAdapter.java, +    /**, +     * Log the headers, body, and metadata for both requests and responses., +     * <p>, +     * Note: This requires that the entire request and response body be buffered in memory!, +     */, +  private final Server server;, +  private final Executor httpExecutor;, +  private final Executor callbackExecutor;, +  private final RequestInterceptor requestInterceptor;, +  private final Converter converter;, +  private final ErrorHandler errorHandler;, +  private final Log log;, +  private volatile LogLevel logLevel;, +    if (!service.isInterface()) {, +      throw new IllegalArgumentException("Only interface endpoint definitions are supported.");, +    }, +    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in, +    // Android (http://b.android.com/58753) but it forces composition of API declarations which is, +    // the recommended pattern., +    if (service.getSuperclass() != null) {, +      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");, +    }, +        new RestHandler());, +    private final Map<Method, RestMethodInfo> methodDetailsCache =, +        new LinkedHashMap<Method, RestMethodInfo>();, +      final RestMethodInfo methodDetails;, +      synchronized (methodDetailsCache) {, +        RestMethodInfo tempMethodDetails = methodDetailsCache.get(method);, +        if (tempMethodDetails == null) {, +          tempMethodDetails = new RestMethodInfo(method);, +          methodDetailsCache.put(method, tempMethodDetails);, +        }, +        methodDetails = tempMethodDetails;, +      }, +      if (methodDetails.isSynchronous) {, +          return invokeRequest(requestInterceptor, methodDetails, args);, +          return (ResponseWrapper) invokeRequest(interceptorTape, methodDetails, args);, +        RestMethodInfo methodDetails, Object[] args) {, +      methodDetails.init(); // Ensure all relevant method information has been loaded., +        RequestBuilder requestBuilder = new RequestBuilder(converter, methodDetails);, +        if (!methodDetails.isSynchronous) {, +          request = logAndReplaceRequest(request);, +          RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);, +        Type type = methodDetails.responseObjectType;, +            if (methodDetails.isSynchronous) {, +            if (methodDetails.isSynchronous) {, +        if (!methodDetails.isSynchronous) {, +  private Request logAndReplaceRequest(Request request) throws IOException {, +    log.log(String.format("---> HTTP %s %s", request.getMethod(), request.getUrl()));, +      log.log(String.format("---> END HTTP (%s-byte body)", bodySize));, +  private void logException(Throwable t, String url) {, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null]