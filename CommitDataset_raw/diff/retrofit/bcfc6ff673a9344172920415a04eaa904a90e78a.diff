[+++ b/pom.xml, +    <jackson.version>2.3.1</jackson.version>, +++ b/pom.xml, +    <jackson.version>2.3.1</jackson.version>, +++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java, +import java.io.IOException;, +import java.io.UnsupportedEncodingException;, +import java.lang.reflect.Type;, +import retrofit.mime.TypedByteArray;, +import retrofit.mime.TypedInput;, +import retrofit.mime.TypedOutput;, +  public JacksonConverter() {, +    this(new ObjectMapper());, +  }, +, +  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {, +      JavaType javaType = objectMapper.getTypeFactory().constructType(type);, +    } catch (JsonParseException e) {, +    } catch (JsonMappingException e) {, +    } catch (IOException e) {, +      String json = objectMapper.writeValueAsString(object);, +    } catch (JsonProcessingException e) {, +    } catch (UnsupportedEncodingException e) {, +++ b/pom.xml, +    <jackson.version>2.3.1</jackson.version>, +++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java, +import java.io.IOException;, +import java.io.UnsupportedEncodingException;, +import java.lang.reflect.Type;, +import retrofit.mime.TypedByteArray;, +import retrofit.mime.TypedInput;, +import retrofit.mime.TypedOutput;, +  public JacksonConverter() {, +    this(new ObjectMapper());, +  }, +, +  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {, +      JavaType javaType = objectMapper.getTypeFactory().constructType(type);, +    } catch (JsonParseException e) {, +    } catch (JsonMappingException e) {, +    } catch (IOException e) {, +      String json = objectMapper.writeValueAsString(object);, +    } catch (JsonProcessingException e) {, +    } catch (UnsupportedEncodingException e) {, +++ b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java, +import com.fasterxml.jackson.annotation.JsonProperty;, +import static org.fest.assertions.api.Assertions.assertThat;, +  private static final MyObject OBJECT = new MyObject("hello world", 10);, +  private final String JSON = "{\"message\":\"hello world\",\"count\":10}";, +  private final JacksonConverter converter = new JacksonConverter();, +    TypedOutput typedOutput = converter.toBody(OBJECT);, +    assertThat(asString(typedOutput)).isEqualTo(JSON);, +    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());, +    MyObject result = (MyObject) converter.fromBody(input, MyObject.class);, +    assertThat(result).isEqualTo(OBJECT);, +  @Test(expected = ConversionException.class), +  public void deserializeWrongValue() throws Exception {, +    TypedInput input = new TypedByteArray(MIME_TYPE, "{\"foo\":\"bar\"}".getBytes());, +  @Test(expected = ConversionException.class), +  public void deserializeWrongClass() throws Exception {, +    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());, +    ByteArrayOutputStream bytes = new ByteArrayOutputStream();, +    @Override, +    public boolean equals(Object o) {, +      if (this == o) return true;, +      if (o == null || getClass() != o.getClass()) return false;, +      MyObject myObject = (MyObject) o;, +      return count == myObject.count, +          && !(message != null ? !message.equals(myObject.message) : myObject.message != null);, +      int result = message != null ? message.hashCode() : 0;, +      result = 31 * result + count;]