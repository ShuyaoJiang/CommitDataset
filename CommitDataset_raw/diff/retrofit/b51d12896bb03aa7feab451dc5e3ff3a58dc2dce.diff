[+++ b/retrofit/src/main/java/retrofit2/Utils.java, +  static Class<?> getRawType(Type type) {, +    if (type == null) throw new NullPointerException("type == null");, +, +    }, +    if (type instanceof ParameterizedType) {, +    }, +    if (type instanceof GenericArrayType) {, +    }, +    if (type instanceof TypeVariable) {, +    if (type instanceof WildcardType) {, +      return getRawType(((WildcardType) type).getUpperBounds()[0]);, +    }, +, +    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or ", +          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());, +  static boolean equals(Type a, Type b) {, +  static String typeToString(Type type) {, +  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {, +  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {, +    if (index < 0 || index >= types.length) {, +          "Index " + index + " not in range [0," + types.length + ") for " + type);, +++ b/retrofit/src/main/java/retrofit2/Utils.java, +  static Class<?> getRawType(Type type) {, +    if (type == null) throw new NullPointerException("type == null");, +, +    }, +    if (type instanceof ParameterizedType) {, +    }, +    if (type instanceof GenericArrayType) {, +    }, +    if (type instanceof TypeVariable) {, +    if (type instanceof WildcardType) {, +      return getRawType(((WildcardType) type).getUpperBounds()[0]);, +    }, +, +    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or ", +          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());, +  static boolean equals(Type a, Type b) {, +  static String typeToString(Type type) {, +  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {, +  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {, +    if (index < 0 || index >= types.length) {, +          "Index " + index + " not in range [0," + types.length + ") for " + type);, +++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java, +/*, + * Copyright (C) 2016 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package retrofit2;, +, +import com.google.common.reflect.TypeToken;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.util.List;, +import java.util.Map;, +import org.junit.Test;, +, +import static org.assertj.core.api.Assertions.assertThat;, +import static org.junit.Assert.fail;, +import static retrofit2.CallAdapter.Factory.getParameterUpperBound;, +import static retrofit2.CallAdapter.Factory.getRawType;, +, +public final class CallAdapterTest {, +  @Test public void parameterizedTypeInvalidIndex() {, +    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();, +    try {, +      getParameterUpperBound(-1, listOfString);, +      fail();, +    } catch (IllegalArgumentException e) {, +      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");, +    }, +    try {, +      getParameterUpperBound(1, listOfString);, +      fail();, +    } catch (IllegalArgumentException e) {, +      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");, +    }, +  }, +, +  @Test public void parameterizedTypes() {, +    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();, +    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);, +, +    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();, +    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);, +    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);, +, +    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {]