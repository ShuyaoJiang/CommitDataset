[+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java, +        .addCallAdapterFactory(ObservableCallAdapterFactory.create()), +++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java, +        .addCallAdapterFactory(ObservableCallAdapterFactory.create()), +++ b/retrofit/src/main/java/retrofit/MethodInfo.java, +import java.util.List;, +  final List<CallAdapter.Factory> factories;, +  MethodInfo(Method method, List<CallAdapter.Factory> factories, Converter converter) {, +    this.factories = factories;, +    CallAdapter adapter = null;, +    for (int i = 0, count = factories.size(); i < count; i++) {, +      CallAdapter.Factory factory = factories.get(i);, +      adapter = factory.get(returnType);, +      if (adapter != null) {, +        break;, +      }, +    }, +      throw methodError("No registered call adapters were able to handle return type ", +          + returnType, +          + ". Checked: ", +          + factories);, +    if (Utils.hasTypeVariable(responseType)) {, +      throw methodError("Method response type must not include a type variable.");, +    }, +++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java, +        .addCallAdapterFactory(ObservableCallAdapterFactory.create()), +++ b/retrofit/src/main/java/retrofit/MethodInfo.java, +import java.util.List;, +  final List<CallAdapter.Factory> factories;, +  MethodInfo(Method method, List<CallAdapter.Factory> factories, Converter converter) {, +    this.factories = factories;, +    CallAdapter adapter = null;, +    for (int i = 0, count = factories.size(); i < count; i++) {, +      CallAdapter.Factory factory = factories.get(i);, +      adapter = factory.get(returnType);, +      if (adapter != null) {, +        break;, +      }, +    }, +      throw methodError("No registered call adapters were able to handle return type ", +          + returnType, +          + ". Checked: ", +          + factories);, +    if (Utils.hasTypeVariable(responseType)) {, +      throw methodError("Method response type must not include a type variable.");, +    }, +++ b/retrofit/src/main/java/retrofit/Platform.java, +  Executor defaultCallbackExecutor() {, +    return new Utils.SynchronousExecutor();, +  private static class Android extends Platform {, +    @Override Executor defaultCallbackExecutor() {, +      return new Executor() {, +      };, +++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java, +        .addCallAdapterFactory(ObservableCallAdapterFactory.create()), +++ b/retrofit/src/main/java/retrofit/MethodInfo.java, +import java.util.List;, +  final List<CallAdapter.Factory> factories;, +  MethodInfo(Method method, List<CallAdapter.Factory> factories, Converter converter) {, +    this.factories = factories;, +    CallAdapter adapter = null;, +    for (int i = 0, count = factories.size(); i < count; i++) {, +      CallAdapter.Factory factory = factories.get(i);, +      adapter = factory.get(returnType);, +      if (adapter != null) {, +        break;, +      }, +    }, +      throw methodError("No registered call adapters were able to handle return type ", +          + returnType, +          + ". Checked: ", +          + factories);, +    if (Utils.hasTypeVariable(responseType)) {, +      throw methodError("Method response type must not include a type variable.");, +    }, +++ b/retrofit/src/main/java/retrofit/Platform.java, +  Executor defaultCallbackExecutor() {, +    return new Utils.SynchronousExecutor();, +  private static class Android extends Platform {, +    @Override Executor defaultCallbackExecutor() {, +      return new Executor() {, +      };, +++ b/retrofit/src/main/java/retrofit/RestAdapter.java, +import java.util.ArrayList;, +import java.util.List;, +import static java.util.Collections.unmodifiableList;, +  private final List<CallAdapter.Factory> factories;, +      List<CallAdapter.Factory> factories) {, +    this.factories = unmodifiableList(new ArrayList<>(factories));, +          methodInfo = new MethodInfo(method, factories, converter);, +  public List<CallAdapter.Factory> callAdapterFactories() {, +    return factories;, +    private Executor callbackExecutor;, +    private final List<CallAdapter.Factory> factories = new ArrayList<>();, +    /** Executor on which {@link Callback} methods will be invoked if {@link Call} is used. */, +    public Builder callbackExecutor(Executor callbackExecutor) {, +      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");, +      return this;, +    }, +]