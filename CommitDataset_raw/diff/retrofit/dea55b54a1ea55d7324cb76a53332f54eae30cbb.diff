[+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java, +          if (annotationType == Path.class) {, +            validatePathName(name);, +          } else if (annotationType == EncodedPath.class) {, +            String name = ((EncodedPath) parameterAnnotation).value();, +            validatePathName(name);, +, +            paramNames[i] = name;, +            paramUsage[i] = ParamUsage.ENCODED_PATH;, +            String name = ((EncodedQuery) parameterAnnotation).value();, +  private void validatePathName(String name) {, +    if (!PARAM_NAME_REGEX.matcher(name).matches()) {, +      throw new IllegalStateException("Path parameter name is not valid: ", +          + name, +          + ". Must match ", +          + PARAM_URL_REGEX.pattern());, +    }, +    // Verify URL replacement name is actually present in the URL path., +    if (!requestUrlParamNames.contains(name)) {, +      throw new IllegalStateException(, +          "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");, +    }, +  }, +, +++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java, +          if (annotationType == Path.class) {, +            validatePathName(name);, +          } else if (annotationType == EncodedPath.class) {, +            String name = ((EncodedPath) parameterAnnotation).value();, +            validatePathName(name);, +, +            paramNames[i] = name;, +            paramUsage[i] = ParamUsage.ENCODED_PATH;, +            String name = ((EncodedQuery) parameterAnnotation).value();, +  private void validatePathName(String name) {, +    if (!PARAM_NAME_REGEX.matcher(name).matches()) {, +      throw new IllegalStateException("Path parameter name is not valid: ", +          + name, +          + ". Must match ", +          + PARAM_URL_REGEX.pattern());, +    }, +    // Verify URL replacement name is actually present in the URL path., +    if (!requestUrlParamNames.contains(name)) {, +      throw new IllegalStateException(, +          "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");, +    }, +  }, +, +++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java, +import retrofit.http.EncodedPath;, +import retrofit.http.EncodedQuery;, +import static retrofit.RestMethodInfo.ParamUsage.ENCODED_PATH;, +import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY;, +      @GET("/foo") void a(@Query("id") String id, ResponseCallback cb) {, +      @GET("/foo") void a(@Query("id") String id, Callback<Response> c) {, +      @GET("/foo") void a(@Query("id") String id) {, +  @Test public void singlePathParam() {, +    class Example {, +      @GET("/{a}") Response a(@Path("a") String a) {, +        return null;, +      }, +    }, +, +    Method method = TestingUtils.getMethod(Example.class, "a");, +    RestMethodInfo methodInfo = new RestMethodInfo(method);, +    methodInfo.init();, +, +    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");, +    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(PATH);, +    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);, +  }, +, +  @Test public void singleEncodedPathParam() {, +    class Example {, +      @GET("/{a}") Response a(@EncodedPath("a") String a) {, +        return null;, +      }, +    }, +, +    Method method = TestingUtils.getMethod(Example.class, "a");, +    RestMethodInfo methodInfo = new RestMethodInfo(method);, +    methodInfo.init();, +, +    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");, +    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_PATH);, +    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);, +  }, +, +  @Test public void singleEncodedQueryParam() {, +    class Example {, +      @GET("/") Response a(@EncodedQuery("a") String a) {, +        return null;, +      }, +    }, +, +    Method method = TestingUtils.getMethod(Example.class, "a");, +    RestMethodInfo methodInfo = new RestMethodInfo(method);, +    methodInfo.init();, +, +    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");]