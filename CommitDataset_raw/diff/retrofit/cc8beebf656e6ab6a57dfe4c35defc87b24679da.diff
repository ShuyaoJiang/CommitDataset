[+++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java, +    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);, +++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java, +    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);, +++ b/retrofit/src/main/java/retrofit/http/Types.java, +/**, + * Copyright (C) 2008 Google Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package retrofit.http;, +, +import java.lang.reflect.Array;, +import java.lang.reflect.GenericArrayType;, +import java.lang.reflect.GenericDeclaration;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.lang.reflect.TypeVariable;, +import java.lang.reflect.WildcardType;, +import java.util.Arrays;, +import java.util.NoSuchElementException;, +, +/**, + * Static methods for working with types., + *, + * @author Bob Lee, + * @author Jesse Wilson, + */, +final class Types {, +  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};, +, +  private Types() {}, +, +  public static Class<?> getRawType(Type type) {, +    if (type instanceof Class<?>) {, +      // Type is a normal class., +      return (Class<?>) type;, +, +    } else if (type instanceof ParameterizedType) {, +      ParameterizedType parameterizedType = (ParameterizedType) type;, +, +      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but, +      // suspects some pathological case related to nested classes exists., +      Type rawType = parameterizedType.getRawType();, +      if (!(rawType instanceof Class)) throw new IllegalArgumentException();, +      return (Class<?>) rawType;, +, +    } else if (type instanceof GenericArrayType) {, +      Type componentType = ((GenericArrayType)type).getGenericComponentType();, +      return Array.newInstance(getRawType(componentType), 0).getClass();, +, +    } else if (type instanceof TypeVariable) {, +      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw, +      // type that's more general than necessary is okay., +      return Object.class;, +, +    } else if (type instanceof WildcardType) {, +      return getRawType(((WildcardType) type).getUpperBounds()[0]);, +, +    } else {, +      String className = type == null ? "null" : type.getClass().getName();, +      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or ", +          + "GenericArrayType, but <" + type + "> is of type " + className);, +    }, +  }, +, +  /** Returns true if {@code a} and {@code b} are equal. */, +  public static boolean equals(Type a, Type b) {, +    if (a == b) {, +      return true; // Also handles (a == null && b == null)., +, +    } else if (a instanceof Class) {, +      return a.equals(b); // Class already specifies equals()., +, +    } else if (a instanceof ParameterizedType) {, +      if (!(b instanceof ParameterizedType)) return false;, +      ParameterizedType pa = (ParameterizedType) a;, +      ParameterizedType pb = (ParameterizedType) b;, +      return equal(pa.getOwnerType(), pb.getOwnerType()), +          && pa.getRawType().equals(pb.getRawType()), +          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());, +, +    } else if (a instanceof GenericArrayType) {, +      if (!(b instanceof GenericArrayType)) return false;, +      GenericArrayType ga = (GenericArrayType) a;, +      GenericArrayType gb = (GenericArrayType) b;, +      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());, +, +    } else if (a instanceof WildcardType) {]