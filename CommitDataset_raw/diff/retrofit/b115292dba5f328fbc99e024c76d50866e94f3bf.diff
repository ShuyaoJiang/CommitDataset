[+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java, +        } else if (behavior.calculateIsError()) {, +          if (delaySleep()) {, +            //noinspection unchecked An error response has no body., +            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());, +          }, +++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java, +        } else if (behavior.calculateIsError()) {, +          if (delaySleep()) {, +            //noinspection unchecked An error response has no body., +            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());, +          }, +++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java, +import java.util.concurrent.Callable;, +import java.util.concurrent.atomic.AtomicBoolean;, +  /**, +   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is, +   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}., +   */, +  public static <T> Call<T> defer(Callable<Call<T>> callable) {, +    return new DeferredCall<>(callable);, +  }, +, +    return new FakeCall<>(Response.success(successValue), null);, +  public static <T> Call<T> response(Response<T> response) {, +    return new FakeCall<>(response, null);, +  public static <T> Call<T> failure(IOException failure) {, +    return new FakeCall<>(null, failure);, +, +  static final class FakeCall<T> implements Call<T> {, +    private final Response<T> response;, +    private final IOException error;, +    private final AtomicBoolean canceled = new AtomicBoolean();, +    private final AtomicBoolean executed = new AtomicBoolean();, +, +    FakeCall(Response<T> response, IOException error) {, +      if ((response == null) == (error == null)) {, +        throw new AssertionError("Only one of response or error can be set.");, +      }, +      this.response = response;, +      this.error = error;, +    }, +, +    @Override public Response<T> execute() throws IOException {, +      if (!executed.compareAndSet(false, true)) {, +        throw new IllegalStateException("Already executed");, +      }, +      if (canceled.get()) {, +        throw new IOException("canceled");, +      }, +      if (response != null) {, +        return response;, +      }, +      throw error;, +    }, +, +    @Override public void enqueue(Callback<T> callback) {, +      if (callback == null) {, +        throw new NullPointerException("callback == null");, +      }, +      if (!executed.compareAndSet(false, true)) {, +        throw new IllegalStateException("Already executed");, +      }, +      if (canceled.get()) {, +        callback.onFailure(this, new IOException("canceled"));, +      } else if (response != null) {, +        callback.onResponse(this, response);, +      } else {, +        callback.onFailure(this, error);, +      }, +    }, +, +    @Override public boolean isExecuted() {, +      return executed.get();, +    }, +, +    @Override public void cancel() {, +      canceled.set(true);, +    }, +, +    @Override public boolean isCanceled() {, +      return canceled.get();, +    }, +, +    @Override public Call<T> clone() {, +      return new FakeCall<>(response, error);, +    }, +, +    @Override public Request request() {, +      if (response != null) {, +        return response.raw().request();, +      }, +      return new Request.Builder().url("http://localhost").build();, +    }, +  }, +, +  static final class DeferredCall<T> implements Call<T> {, +    private final Callable<Call<T>> callable;, +    private Call<T> delegate;, +]