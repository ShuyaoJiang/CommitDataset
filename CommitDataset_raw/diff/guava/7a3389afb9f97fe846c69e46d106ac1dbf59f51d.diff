[+++ b/guava-tests/test/com/google/common/reflect/TypeResolverTest.java, +    assertEquals(t, new TypeResolver(), +    assertEquals(t, new TypeResolver(), +  public <K, V> void testWhere_actualArgHasWildcard() {, +    TypeResolver resolver = new TypeResolver().where(, +        new TypeCapture<Iterable<Map<?, V>>>() {}.capture(),, +        new TypeCapture<Iterable<Map<String, Integer>>>() {}.capture());, +    assertEquals(, +        new TypeCapture<K>() {}.capture(), resolver.resolveType(new TypeCapture<K>() {}.capture()));, +    assertEquals(, +        Integer.class, resolver.resolveType(new TypeCapture<V>() {}.capture()));, +  }, +, +  public <T> void testWhere_mapFromWildcard() {, +    Type subType = new TypeCapture<TypedKeyMap<T>>() {}.capture();, +    assertEquals(new TypeCapture<TypedKeyMap<String>>() {}.capture(),, +        new TypeResolver(), +            .where(, +                new TypeCapture<Map<Integer, T>>() {}.capture(),, +                new TypeCapture<Map<?, String>>() {}.capture()), +        .resolveType(subType));, +  }, +, +  public <T> void testWhere_mapFromWildcardToParameterized() {, +    Type subType = new TypeCapture<TypedListKeyMap<T>>() {}.capture();, +    assertEquals(new TypeCapture<TypedListKeyMap<String>>() {}.capture(),, +        new TypeResolver(), +            .where(, +                new TypeCapture<Map<List<Integer>, T>>() {}.capture(),, +                new TypeCapture<Map<?, String>>() {}.capture()), +        .resolveType(subType));, +  }, +, +  public <T> void testWhere_mapFromBoundedWildcard() {, +    Type subType = new TypeCapture<TypedKeyMap<T>>() {}.capture();, +    // TODO(benyu): This should check equality to an expected value, see discussion in cl/98674873, +    new TypeResolver(), +        .where(, +            new TypeCapture<Map<Integer, T>>() {}.capture(),, +            new TypeCapture<Map<? extends Number, ? extends Number>>() {}.capture()), +        .resolveType(subType);, +  }, +, +  interface TypedKeyMap<T> extends Map<Integer, T> {}, +  interface TypedListKeyMap<T> extends Map<List<Integer>, T> {}, +, +++ b/guava-tests/test/com/google/common/reflect/TypeResolverTest.java, +    assertEquals(t, new TypeResolver(), +    assertEquals(t, new TypeResolver(), +  public <K, V> void testWhere_actualArgHasWildcard() {, +    TypeResolver resolver = new TypeResolver().where(, +        new TypeCapture<Iterable<Map<?, V>>>() {}.capture(),, +        new TypeCapture<Iterable<Map<String, Integer>>>() {}.capture());, +    assertEquals(, +        new TypeCapture<K>() {}.capture(), resolver.resolveType(new TypeCapture<K>() {}.capture()));, +    assertEquals(, +        Integer.class, resolver.resolveType(new TypeCapture<V>() {}.capture()));, +  }, +, +  public <T> void testWhere_mapFromWildcard() {, +    Type subType = new TypeCapture<TypedKeyMap<T>>() {}.capture();, +    assertEquals(new TypeCapture<TypedKeyMap<String>>() {}.capture(),, +        new TypeResolver(), +            .where(, +                new TypeCapture<Map<Integer, T>>() {}.capture(),, +                new TypeCapture<Map<?, String>>() {}.capture()), +        .resolveType(subType));, +  }, +, +  public <T> void testWhere_mapFromWildcardToParameterized() {, +    Type subType = new TypeCapture<TypedListKeyMap<T>>() {}.capture();, +    assertEquals(new TypeCapture<TypedListKeyMap<String>>() {}.capture(),, +        new TypeResolver(), +            .where(, +                new TypeCapture<Map<List<Integer>, T>>() {}.capture(),, +                new TypeCapture<Map<?, String>>() {}.capture()), +        .resolveType(subType));, +  }, +, +  public <T> void testWhere_mapFromBoundedWildcard() {, +    Type subType = new TypeCapture<TypedKeyMap<T>>() {}.capture();, +    // TODO(benyu): This should check equality to an expected value, see discussion in cl/98674873, +    new TypeResolver(), +        .where(, +            new TypeCapture<Map<Integer, T>>() {}.capture(),, +            new TypeCapture<Map<? extends Number, ? extends Number>>() {}.capture()), +        .resolveType(subType);, +  }, +, +  interface TypedKeyMap<T> extends Map<Integer, T> {}, +  interface TypedListKeyMap<T> extends Map<List<Integer>, T> {}, +, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +  private static class ForGetSubType {, +  , +    private abstract static class TwoTypeArgs<K, V> {, +      class InnerType<K2, V2> {}, +    }, +, +    private abstract static class StringForFirstTypeArg<V> extends TwoTypeArgs<String, V> {]