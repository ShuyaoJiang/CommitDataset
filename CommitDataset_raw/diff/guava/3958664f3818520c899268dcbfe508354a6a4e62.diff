[+++ b/guava/src/com/google/common/base/Preconditions.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., +   * Ensures the truth of an expression involving one or more parameters to the calling method., +   * Ensures the truth of an expression involving one or more parameters to the calling method., +   * @param errorMessage the exception message to use if the check fails; will be converted to a, +   *     string using {@link String#valueOf(Object)}, +  public static void checkArgument(boolean expression, @Nullable Object errorMessage) {, +   * Ensures the truth of an expression involving one or more parameters to the calling method., +   * @param errorMessageTemplate a template for the exception message should the check fail. The, +   *     message is formed by replacing each {@code %s} placeholder in the template with an, +   *     argument. These are matched by position - the first {@code %s} gets {@code, +   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message, +   *     in square braces. Unmatched placeholders will be left as-is., +   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments, +   *     are converted to strings using {@link String#valueOf(Object)}., +   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or, +   *     {@code errorMessageArgs} is null (don't let this happen), +      throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));, +   * Ensures the truth of an expression involving the state of the calling instance, but not, +   * involving any parameters to the calling method., +   * Ensures the truth of an expression involving the state of the calling instance, but not, +   * involving any parameters to the calling method., +   * @param errorMessage the exception message to use if the check fails; will be converted to a, +   *     string using {@link String#valueOf(Object)}, +  public static void checkState(boolean expression, @Nullable Object errorMessage) {, +   * Ensures the truth of an expression involving the state of the calling instance, but not, +   * involving any parameters to the calling method., +   * @param errorMessageTemplate a template for the exception message should the check fail. The, +   *     message is formed by replacing each {@code %s} placeholder in the template with an, +   *     argument. These are matched by position - the first {@code %s} gets {@code, +   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message, +   *     in square braces. Unmatched placeholders will be left as-is., +   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments, +   *     are converted to strings using {@link String#valueOf(Object)}., +   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or, +   *     {@code errorMessageArgs} is null (don't let this happen), +      throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));, +   * Ensures that an object reference passed as a parameter to the calling method is not null., +   * Ensures that an object reference passed as a parameter to the calling method is not null., +   * @param errorMessage the exception message to use if the check fails; will be converted to a, +   *     string using {@link String#valueOf(Object)}, +   * Ensures that an object reference passed as a parameter to the calling method is not null., +   * @param errorMessageTemplate a template for the exception message should the check fail. The, +   *     message is formed by replacing each {@code %s} placeholder in the template with an, +   *     argument. These are matched by position - the first {@code %s} gets {@code, +   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message, +   *     in square braces. Unmatched placeholders will be left as-is., +   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments, +   *     are converted to strings using {@link String#valueOf(Object)}., +      throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));, +   * refactored so that messageExpression is moved to a separate String-returning method., +   * The alternative natural refactorings into void or Exception-returning methods are much slower., +   * This is a big deal - we're talking factors of 2-8 in microbenchmarks, not just 10-20%.  (This, +   * is a hotspot optimizer bug, which should be fixed, but that's a separate, big project)., +   * The coding pattern above is heavily used in java.util, e.g. in ArrayList.  There is a, +   * RangeCheckMicroBenchmark in the JDK that was used to test this., +   * But the methods in this class want to throw different exceptions, depending on the args, so it, +   * appears that this pattern is not directly applicable.  But we can use the ridiculous, devious, +   * trick of throwing an exception in the middle of the construction of another exception.  Hotspot, +   * is fine with that., +   * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size, +   * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive., +   * @param index a user-supplied index identifying an element of an array, list or string, +   * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}, +   * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size, +   * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive., +   * @param index a user-supplied index identifying an element of an array, list or string, +   * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}, +   * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of, +   * size {@code size}. A position index may range from zero to {@code size}, inclusive., +   * @param index a user-supplied index identifying a position in an array, list or string, +   * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}, +   * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of, +   * size {@code size}. A position index may range from zero to {@code size}, inclusive., +   * @param index a user-supplied index identifying a position in an array, list or string, +   * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}, +  public static int checkPositionIndex(int index, int size, @Nullable String desc) {, +      return format("%s (%s) must not be greater than size (%s)", desc, index, size);, +   * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list, +   * or string of size {@code size}, and are in order. A position index may range from zero to, +   * {@code size}, inclusive., +   * @param start a user-supplied index identifying a starting position in an array, list or string, +   * @param end a user-supplied index identifying a ending position in an array, list or string, +   * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},, +   *     or if {@code end} is less than {@code start}, +    return format("end index (%s) must not be less than start index (%s)", end, start);, +   * Substitutes each {@code %s} in {@code template} with an argument. These are matched by, +   * position: the first {@code %s} gets {@code args[0]}, etc.  If there are more arguments than, +   * placeholders, the unmatched arguments will be appended to the end of the formatted message in, +   * square braces., +   * @param template a non-null string containing 0 or more {@code %s} placeholders., +   * @param args the arguments to be substituted into the message template. Arguments are converted, +   *     to strings using {@link String#valueOf(Object)}. Arguments can be null., +  @VisibleForTesting static String format(String template, @Nullable Object... args) {, +    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);]