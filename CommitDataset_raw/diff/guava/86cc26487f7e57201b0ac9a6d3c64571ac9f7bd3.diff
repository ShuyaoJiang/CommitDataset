[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +   * a bucket in the hash table for a Set<V> associated with a key, the linked list, +  static final class ValueEntry<K, V> extends ImmutableEntry<K, V>, +    final int smearedValueHash;, +    @Nullable ValueEntry<K, V> nextInValueBucket;, +    ValueEntry(@Nullable K key, @Nullable V value, int smearedValueHash,, +        @Nullable ValueEntry<K, V> nextInValueBucket) {, +      super(key, value);, +      this.smearedValueHash = smearedValueHash;, +      this.nextInValueBucket = nextInValueBucket;, +    boolean matchesValue(@Nullable Object v, int smearedVHash) {, +      return smearedValueHash == smearedVHash && Objects.equal(getValue(), v);, +    private int mask() {, +      return hashTable.length - 1;, +    }, +, +          ValueSet.this.remove(toRemove.getValue());, +          expectedModCount = modCount;, +      int smearedHash = Hashing.smearedHash(o);, +      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()]; entry != null;, +          entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(o, smearedHash)) {, +      int smearedHash = Hashing.smearedHash(value);, +      int bucket = smearedHash & mask();, +      ValueEntry<K, V> rowHead = hashTable[bucket];, +          entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(value, smearedHash)) {, +      ValueEntry<K, V> newEntry = new ValueEntry<K, V>(key, value, smearedHash, rowHead);, +      hashTable[bucket] = newEntry;, +          int bucket = valueEntry.smearedValueHash & mask;, +          valueEntry.nextInValueBucket = hashTable[bucket];, +          hashTable[bucket] = valueEntry;, +      int smearedHash = Hashing.smearedHash(o);, +      int bucket = smearedHash & mask();, +      for (ValueEntry<K, V> entry = hashTable[bucket]; entry != null;, +           prev = entry, entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(o, smearedHash)) {, +            // first entry in the bucket, +            hashTable[bucket] = entry.nextInValueBucket;, +            prev.nextInValueBucket = entry.nextInValueBucket;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +   * a bucket in the hash table for a Set<V> associated with a key, the linked list, +  static final class ValueEntry<K, V> extends ImmutableEntry<K, V>, +    final int smearedValueHash;, +    @Nullable ValueEntry<K, V> nextInValueBucket;, +    ValueEntry(@Nullable K key, @Nullable V value, int smearedValueHash,, +        @Nullable ValueEntry<K, V> nextInValueBucket) {, +      super(key, value);, +      this.smearedValueHash = smearedValueHash;, +      this.nextInValueBucket = nextInValueBucket;, +    boolean matchesValue(@Nullable Object v, int smearedVHash) {, +      return smearedValueHash == smearedVHash && Objects.equal(getValue(), v);, +    private int mask() {, +      return hashTable.length - 1;, +    }, +, +          ValueSet.this.remove(toRemove.getValue());, +          expectedModCount = modCount;, +      int smearedHash = Hashing.smearedHash(o);, +      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()]; entry != null;, +          entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(o, smearedHash)) {, +      int smearedHash = Hashing.smearedHash(value);, +      int bucket = smearedHash & mask();, +      ValueEntry<K, V> rowHead = hashTable[bucket];, +          entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(value, smearedHash)) {, +      ValueEntry<K, V> newEntry = new ValueEntry<K, V>(key, value, smearedHash, rowHead);, +      hashTable[bucket] = newEntry;, +          int bucket = valueEntry.smearedValueHash & mask;, +          valueEntry.nextInValueBucket = hashTable[bucket];, +          hashTable[bucket] = valueEntry;, +      int smearedHash = Hashing.smearedHash(o);, +      int bucket = smearedHash & mask();, +      for (ValueEntry<K, V> entry = hashTable[bucket]; entry != null;, +           prev = entry, entry = entry.nextInValueBucket) {, +        if (entry.matchesValue(o, smearedHash)) {, +            // first entry in the bucket, +            hashTable[bucket] = entry.nextInValueBucket;, +            prev.nextInValueBucket = entry.nextInValueBucket;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ObjectArrays.java, +  , +  /**, +   * Implementation of {@link Collection#toArray(Object[])} for collections backed by an object, +   * array. the runtime type of the returned array is that of the specified array. If the collection, +   * fits in the specified array, it is returned therein. Otherwise, a new array is allocated with, +   * the runtime type of the specified array and the size of the specified collection., +   *, +   * <p>If the collection fits in the specified array with room to spare (i.e., the array has more, +   * elements than the collection), the element in the array immediately following the end of the, +   * collection is set to {@code null}. This is useful in determining the length of the collection, +   * <i>only</i> if the caller knows that the collection does not contain any null elements., +   */, +  static <T> T[] toArrayImpl(Object[] src, int offset, int len, T[] dst) {, +    checkPositionIndexes(offset, offset + len, src.length);, +    if (dst.length < len) {, +      dst = newArray(dst, len);, +    } else if (dst.length > len) {, +      dst[len] = null;, +    }]