[+++ b/guava-tests/test/com/google/common/collect/QueuesTest.java, +import static com.google.common.collect.Lists.newArrayList;, +import static com.google.common.truth.Truth.assertThat;, +import static java.lang.Long.MAX_VALUE;, +import static java.lang.Thread.currentThread;, +import static java.util.concurrent.Executors.newCachedThreadPool;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, +, +import com.google.common.base.Stopwatch;, +import java.util.concurrent.LinkedBlockingDeque;, +        new LinkedBlockingDeque<Object>(),, +        new LinkedBlockingDeque<Object>(10),, +    threadPool = newCachedThreadPool();, +    assertTrue("Some worker didn't finish in time", threadPool.awaitTermination(1, SECONDS));, +  private static <T> int drain(, +      BlockingQueue<T> q,, +      Collection<? super T> buffer,, +      int maxElements,, +      long timeout,, +      TimeUnit unit,, +      boolean interruptibly), +      throws InterruptedException {, +  private void testMultipleProducers(BlockingQueue<Object> q) throws InterruptedException {, +      List<Object> buf = newArrayList();, +      int elements = drain(q, buf, 100, MAX_VALUE, NANOSECONDS, interruptibly);, +      assertEquals(0, Queues.drain(q, ImmutableList.of(), 1, 10, MILLISECONDS));, +      producer.beganProducing.await();, +      Stopwatch timer = Stopwatch.createStarted();, +      int drained = drain(q, newArrayList(), 2, 10, MILLISECONDS, interruptibly);, +      assertThat(drained).isAtMost(1);, +      assertThat(timer.elapsed(MILLISECONDS)).isAtLeast(10L);, +      assertEquals(0, drain(q, ImmutableList.of(), 0, 10, MILLISECONDS, interruptibly));, +    List<Object> buf = newArrayList();, +    int elements = Queues.drain(q, buf, -1, MAX_VALUE, NANOSECONDS);, +    assertThat(buf).isEmpty();, +    threadPool.submit(new Interrupter(currentThread()));, +      Queues.drain(q, ImmutableList.of(), 100, MAX_VALUE, NANOSECONDS);, +    final Thread mainThread = currentThread();, +    threadPool.submit(, +        new Callable<Void>() {, +    List<Object> buf = newArrayList();, +    int elements = Queues.drainUninterruptibly(q, buf, 100, MAX_VALUE, NANOSECONDS);, +  /** Checks that #drain() invocations behave correctly for a drained (empty) queue. */, +      assertEquals(0, Queues.drain(q, ImmutableList.of(), 0, 10, MILLISECONDS));, +    threadPool.submit(new Interrupter(currentThread()));, +      Queues.drain(q, newArrayList(), 1, MAX_VALUE, NANOSECONDS);, +    assertEquals(0, Queues.drainUninterruptibly(q, ImmutableList.of(), 0, 10, MILLISECONDS));, +    threadPool.submit(new Interrupter(currentThread()));, +    Stopwatch timer = Stopwatch.createStarted();, +    Queues.drainUninterruptibly(q, newArrayList(), 1, 10, MILLISECONDS);, +    assertThat(timer.elapsed(MILLISECONDS)).isAtLeast(10L);, +    while (!Thread.interrupted()) {, +      Thread.yield();, +    }, +    final CountDownLatch beganProducing = new CountDownLatch(1);, +    @Override, +    public Void call() throws InterruptedException {, +        beganProducing.countDown();, +    @Override, +    public void run() {]