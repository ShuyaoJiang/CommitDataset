[+++ b/android/guava-tests/test/com/google/common/io/FilesTest.java, +++ b/android/guava-tests/test/com/google/common/io/FilesTest.java, +++ b/android/guava/src/com/google/common/io/ByteSource.java, +import java.util.Collection;, +      Optional<Long> size = sizeIfKnown();, +      return size.isPresent(), +          ? ByteStreams.toByteArray(in, size.get()), +          : ByteStreams.toByteArray(in);, +      if (!(sources instanceof Collection)) {, +        // Infinite Iterables can cause problems here. Of course, it's true that most of the other, +        // methods on this class also have potential problems with infinite  Iterables. But unlike, +        // those, this method can cause issues even if the user is dealing with a (finite) slice(), +        // of this source, since the slice's sizeIfKnown() method needs to know the size of the, +        // underlying source to know what its size actually is., +        return Optional.absent();, +      }, +        if (result < 0) {, +          // Overflow (or one or more sources that returned a negative size, but all bets are off in, +          // that case), +          // Can't represent anything higher, and realistically there probably isn't anything that, +          // can actually be done anyway with the supposed 8+ exbibytes of data the source is, +          // claiming to have if we get here, so just stop., +          return Optional.of(Long.MAX_VALUE);, +        }, +        if (result < 0) {, +          // Overflow (or one or more sources that returned a negative size, but all bets are off in, +          // that case), +          // Can't represent anything higher, and realistically there probably isn't anything that, +          // can actually be done anyway with the supposed 8+ exbibytes of data the source is, +          // claiming to have if we get here, so just stop., +          return Long.MAX_VALUE;, +        }, +++ b/android/guava-tests/test/com/google/common/io/FilesTest.java, +++ b/android/guava/src/com/google/common/io/ByteSource.java, +import java.util.Collection;, +      Optional<Long> size = sizeIfKnown();, +      return size.isPresent(), +          ? ByteStreams.toByteArray(in, size.get()), +          : ByteStreams.toByteArray(in);, +      if (!(sources instanceof Collection)) {, +        // Infinite Iterables can cause problems here. Of course, it's true that most of the other, +        // methods on this class also have potential problems with infinite  Iterables. But unlike, +        // those, this method can cause issues even if the user is dealing with a (finite) slice(), +        // of this source, since the slice's sizeIfKnown() method needs to know the size of the, +        // underlying source to know what its size actually is., +        return Optional.absent();, +      }, +        if (result < 0) {, +          // Overflow (or one or more sources that returned a negative size, but all bets are off in, +          // that case), +          // Can't represent anything higher, and realistically there probably isn't anything that, +          // can actually be done anyway with the supposed 8+ exbibytes of data the source is, +          // claiming to have if we get here, so just stop., +          return Optional.of(Long.MAX_VALUE);, +        }, +        if (result < 0) {, +          // Overflow (or one or more sources that returned a negative size, but all bets are off in, +          // that case), +          // Can't represent anything higher, and realistically there probably isn't anything that, +          // can actually be done anyway with the supposed 8+ exbibytes of data the source is, +          // claiming to have if we get here, so just stop., +          return Long.MAX_VALUE;, +        }, +++ b/android/guava/src/com/google/common/io/ByteStreams.java, +  private static final int BUFFER_SIZE = 8192;, +, +    return new byte[BUFFER_SIZE];, +    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(BUFFER_SIZE, in.available()));, +  static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {, +    checkArgument(expectedSize >= 0, "expectedSize (%s) must be non-negative", expectedSize);, +    if (expectedSize > Integer.MAX_VALUE) {, +      throw new OutOfMemoryError(expectedSize + " bytes is too large to fit in a byte array");, +    }, +, +    byte[] bytes = new byte[(int) expectedSize];, +    int remaining = (int) expectedSize;, +      int off = (int) expectedSize - remaining;, +    FastByteArrayOutputStream out = new FastByteArrayOutputStream(BUFFER_SIZE);, +    byte[] result = Arrays.copyOf(bytes, bytes.length + 1 + out.size());, +    result[bytes.length] = (byte) b;, +    out.writeTo(result, bytes.length + 1);, +    FastByteArrayOutputStream(int initialSize) {, +      super(initialSize);, +    }, +, +++ b/android/guava-tests/test/com/google/common/io/FilesTest.java, +++ b/android/guava/src/com/google/common/io/ByteSource.java, +import java.util.Collection;, +      Optional<Long> size = sizeIfKnown();, +      return size.isPresent(), +          ? ByteStreams.toByteArray(in, size.get()), +          : ByteStreams.toByteArray(in);, +      if (!(sources instanceof Collection)) {, +        // Infinite Iterables can cause problems here. Of course, it's true that most of the other, +        // methods on this class also have potential problems with infinite  Iterables. But unlike, +        // those, this method can cause issues even if the user is dealing with a (finite) slice(), +        // of this source, since the slice's sizeIfKnown() method needs to know the size of the, +        // underlying source to know what its size actually is., +        return Optional.absent();, +      }]