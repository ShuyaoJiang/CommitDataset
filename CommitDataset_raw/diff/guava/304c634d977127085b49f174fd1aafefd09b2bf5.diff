[+++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +  public void testToString() throws Exception {, +    // Two futures should not have the same toString, to avoid people asserting on it, +    assertThat(SettableFuture.create().toString()).isNotEqualTo(SettableFuture.create().toString());, +, +    AbstractFuture<Object> testFuture =, +        new AbstractFuture<Object>() {, +          @Override, +          public String pendingToString() {, +            return "cause=[Because this test isn't done]";, +          }, +        };, +    assertThat(testFuture.toString()), +        .contains("status=PENDING, info=[cause=[Because this test isn't done]]");, +    try {, +      testFuture.get(1, TimeUnit.NANOSECONDS);, +      fail();, +    } catch (TimeoutException e) {, +      assertThat(e.getMessage()).contains("1 nanoseconds");, +      assertThat(e.getMessage()).contains("Because this test isn't done");, +    }, +    AbstractFuture<Object> testFuture2 =, +        new AbstractFuture<Object>() {, +          @Override, +          public String pendingToString() {, +            return "cause=[Someday...]";, +          }, +        };, +    AbstractFuture<Object> testFuture3 = new AbstractFuture<Object>() {};, +    testFuture3.setFuture(testFuture2);, +    assertThat(testFuture3.toString()).contains("status=PENDING, info=[setFuture=[");, +    assertThat(testFuture3.toString()).contains("Someday...");, +    testFuture2.set("result string");, +    assertThat(testFuture3.toString()).contains("status=SUCCESS, result=[result string]");, +, +    assertThat(, +            new AbstractFuture<Object>() {, +              @Override, +              public String pendingToString() {, +                throw new RuntimeException("I'm a misbehaving implementation");, +              }, +            }.toString()), +        .contains("PENDING");, +  }, +, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +  public void testToString() throws Exception {, +    // Two futures should not have the same toString, to avoid people asserting on it, +    assertThat(SettableFuture.create().toString()).isNotEqualTo(SettableFuture.create().toString());, +, +    AbstractFuture<Object> testFuture =, +        new AbstractFuture<Object>() {, +          @Override, +          public String pendingToString() {, +            return "cause=[Because this test isn't done]";, +          }, +        };, +    assertThat(testFuture.toString()), +        .contains("status=PENDING, info=[cause=[Because this test isn't done]]");, +    try {, +      testFuture.get(1, TimeUnit.NANOSECONDS);, +      fail();, +    } catch (TimeoutException e) {, +      assertThat(e.getMessage()).contains("1 nanoseconds");, +      assertThat(e.getMessage()).contains("Because this test isn't done");, +    }, +    AbstractFuture<Object> testFuture2 =, +        new AbstractFuture<Object>() {, +          @Override, +          public String pendingToString() {, +            return "cause=[Someday...]";, +          }, +        };, +    AbstractFuture<Object> testFuture3 = new AbstractFuture<Object>() {};, +    testFuture3.setFuture(testFuture2);, +    assertThat(testFuture3.toString()).contains("status=PENDING, info=[setFuture=[");, +    assertThat(testFuture3.toString()).contains("Someday...");, +    testFuture2.set("result string");, +    assertThat(testFuture3.toString()).contains("status=SUCCESS, result=[result string]");, +, +    assertThat(, +            new AbstractFuture<Object>() {, +              @Override, +              public String pendingToString() {, +                throw new RuntimeException("I'm a misbehaving implementation");, +              }, +            }.toString()), +        .contains("PENDING");, +  }, +, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  @Override, +  protected String pendingToString() {, +    ListenableFuture<? extends V> localInputFuture = inputFuture;, +    Class<X> localExceptionType = exceptionType;, +    F localFallback = fallback;, +    if (localInputFuture != null && localExceptionType != null && localFallback != null) {, +      return "input=[", +          + localInputFuture, +          + "], exceptionType=["]