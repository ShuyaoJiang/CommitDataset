[+++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import com.google.common.base.Predicate;, +    ListenableFuture<String> future = CallerClass1.immediateCancelledFuture();, +, +    try {, +      CallerClass2.get(future);, +      fail();, +    } catch (CancellationException e) {, +      // There should be two CancellationException chained together.  The outer one should have the, +      // stack trace of where the get() call was made, and the inner should have the stack trace of, +      // where the immediateCancelledFuture() call was made., +      List<StackTraceElement> stackTrace = ImmutableList.copyOf(e.getStackTrace());, +      assertFalse(Iterables.any(stackTrace, hasClassName(CallerClass1.class)));, +      assertTrue(Iterables.any(stackTrace, hasClassName(CallerClass2.class)));, +, +      assertTrue(e.getCause() instanceof CancellationException);, +      stackTrace = ImmutableList.copyOf(e.getCause().getStackTrace());, +      assertTrue(Iterables.any(stackTrace, hasClassName(CallerClass1.class)));, +      assertFalse(Iterables.any(stackTrace, hasClassName(CallerClass2.class)));, +    }, +  }, +, +  private static Predicate<StackTraceElement> hasClassName(final Class<?> clazz) {, +    return new Predicate<StackTraceElement>() {, +      @Override, +      public boolean apply(StackTraceElement element) {, +        return element.getClassName().equals(clazz.getName());, +      }, +    };, +  }, +, +  private static final class CallerClass1 {, +    static ListenableFuture<String> immediateCancelledFuture() {, +      return Futures.immediateCancelledFuture();, +    }, +  }, +, +  private static final class CallerClass2 {, +    static <V> V get(ListenableFuture<V> future) throws ExecutionException, InterruptedException {, +      return future.get();, +    }]