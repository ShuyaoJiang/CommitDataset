[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +   * <b>To be deprecated:</b> These {@code AsyncFunction} overloads of {@code, +   * transform} are being renamed to {@code transformAsync}. (The {@code, +   * Function} overloads are keeping the "transform" name.), +   *, +   * <p>Returns a new {@code ListenableFuture} whose result is asynchronously, +    return transformAsync(input, function);, +   * <b>To be deprecated:</b> These {@code AsyncFunction} overloads of {@code, +   * transform} are being renamed to {@code transformAsync}. (The {@code, +   * Function} overloads are keeping the "transform" name.), +   *, +   * <p>Returns a new {@code ListenableFuture} whose result is asynchronously, +    return transformAsync(input, function, executor);, +  }, +, +  /**, +   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result, +   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from, +   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the, +   * original {@code Future}. Example:, +   *, +   * <pre>   {@code, +   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);, +   *   AsyncFunction<RowKey, QueryResult> queryFunction =, +   *       new AsyncFunction<RowKey, QueryResult>() {, +   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {, +   *           return dataService.read(rowKey);, +   *         }, +   *       };, +   *   ListenableFuture<QueryResult> queryFuture =, +   *       transformAsync(rowKeyFuture, queryFunction);}</pre>, +   *, +   * <p>Note: If the derived {@code Future} is slow or heavyweight to create (whether the {@code, +   * Future} itself is slow or heavyweight to complete is irrelevant), consider {@linkplain, +   * #transformAsync(ListenableFuture, AsyncFunction, Executor) supplying an executor}. If you do, +   * not supply an executor, {@code transformAsync} will use a {@linkplain, +   * MoreExecutors#directExecutor direct executor}, which carries some caveats for heavier, +   * operations. For example, the call to {@code function.apply} may run on an unpredictable or, +   * undesirable thread:, +   *, +   * <ul>, +   * <li>If the input {@code Future} is done at the time {@code transformAsync} is called, {@code, +   * transformAsync} will call {@code function.apply} inline., +   * <li>If the input {@code Future} is not yet done, {@code transformAsync} will schedule {@code, +   * function.apply} to be run by the thread that completes the input {@code Future}, which may be, +   * an internal system thread such as an RPC network thread., +   * </ul>, +   *, +   * <p>Also note that, regardless of which thread executes {@code function.apply}, all other, +   * registered but unexecuted listeners are prevented from running during its execution, even if, +   * those listeners are to run in other executors., +   *, +   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the, +   * input future and that of the future returned by the function. That is, if the returned {@code, +   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two, +   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to, +   * cancel itself., +   *, +   * @param input The future to transform, +   * @param function A function to transform the result of the input future to the result of the, +   *     output future, +   * @return A future that holds result of the function (if the input succeeded) or the original, +   *     input's failure (if not), +   * @since 19.0, +   */, +  public static <I, O> ListenableFuture<O> transformAsync(, +      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {, +    ChainingListenableFuture<I, O> output = new ChainingListenableFuture<I, O>(function, input);, +    input.addListener(output, directExecutor());, +    return output;, +  }, +, +  /**, +   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result, +   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from, +   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the, +   * original {@code Future}. Example:, +   *, +   * <pre>   {@code, +   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);, +   *   AsyncFunction<RowKey, QueryResult> queryFunction =, +   *       new AsyncFunction<RowKey, QueryResult>() {, +   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {, +   *           return dataService.read(rowKey);, +   *         }, +   *       };, +   *   ListenableFuture<QueryResult> queryFuture =, +   *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>, +   *, +   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the, +   * input future and that of the future returned by the chain function. That is, if the returned, +   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the, +   * other two is cancelled, the returned {@code Future} will receive a callback in which it will, +   * attempt to cancel itself., +   *, +   * <p>When the execution of {@code function.apply} is fast and lightweight (though the {@code, +   * Future} it returns need not meet these criteria), consider {@linkplain, +   * #transformAsync(ListenableFuture, AsyncFunction) omitting the executor} or explicitly, +   * specifying {@code directExecutor}. However, be aware of the caveats documented in the link, +   * above.]