[+++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());, +    Object arg = generator.generateFresh(param.getType());, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());, +    Object arg = generator.generateFresh(param.getType());, +++ b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java, +    T instance = generator.newFreshProxy(interfaceType);, +        .addEqualityGroup(wrapperFunction.apply(generator.newFreshProxy(interfaceType))), +    T proxy = new FreshValueGenerator().newFreshProxy(interfaceType);, +      passedArgs.add(paramValues.generateFresh(paramType));, +      this.returnValue = new FreshValueGenerator().generateFresh(method.getReturnType());, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());, +    Object arg = generator.generateFresh(param.getType());, +++ b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java, +    T instance = generator.newFreshProxy(interfaceType);, +        .addEqualityGroup(wrapperFunction.apply(generator.newFreshProxy(interfaceType))), +    T proxy = new FreshValueGenerator().newFreshProxy(interfaceType);, +      passedArgs.add(paramValues.generateFresh(paramType));, +      this.returnValue = new FreshValueGenerator().generateFresh(method.getReturnType());, +++ b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java, +  private static final ImmutableMap<Class<?>, Method> EMPTY_GENEREATORS;, +  static {, +    ImmutableMap.Builder<Class<?>, Method> builder =, +        ImmutableMap.builder();, +    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {, +      if (method.isAnnotationPresent(Empty.class)) {, +        builder.put(method.getReturnType(), method);, +      }, +    }, +    EMPTY_GENEREATORS = builder.build();, +  }, +  private final AtomicInteger freshness = new AtomicInteger(1);, +  private final ListMultimap<Class<?>, Object> sampleInstances = ArrayListMultimap.create();, +, +  /**, +   * The freshness level at which the {@link Empty @Empty} annotated method was invoked to generate, +   * instance., +   */, +  private final Map<Type, Integer> emptyInstanceGenerated = new HashMap<Type, Integer>();, +, +  final <T> void addSampleInstances(Class<T> type, Iterable<? extends T> instances) {, +   * <li>null if no value can be generated., +  @Nullable final Object generateFresh(TypeToken<?> type) {, +    Object generated = generate(type);, +    if (generated != null) {, +      freshness.incrementAndGet();, +    }, +    return generated;, +  }, +, +  @Nullable final <T> T generateFresh(Class<T> type) {, +    return Primitives.wrap(type).cast(generateFresh(TypeToken.of(type)));, +  }, +, +  final <T> T newFreshProxy(final Class<T> interfaceType) {, +    T proxy = newProxy(interfaceType);, +    freshness.incrementAndGet();, +    return proxy;, +  }, +, +  /**, +   * Generates an instance for {@code type} using the current {@link #freshness}., +   * The generated instance may or may not be unique across different calls., +   */, +  private Object generate(TypeToken<?> type) {, +    Object sample = pickInstance(samples, null);, +      return pickInstance(rawType.getEnumConstants(), null);, +    Method emptyGenerate = EMPTY_GENEREATORS.get(rawType);, +    if (emptyGenerate != null) {, +      if (emptyInstanceGenerated.containsKey(type.getType())) {, +        // empty instance already generated, +        if (emptyInstanceGenerated.get(type.getType()).intValue() == freshness.get()) {, +          // same freshness, generate again., +          return invokeGeneratorMethod(emptyGenerate);, +        } else {, +          // Cannot use empty generator. Proceed with other generators., +      } else {, +        // never generated empty instance for this type before., +        Object emptyInstance = invokeGeneratorMethod(emptyGenerate);, +        emptyInstanceGenerated.put(type.getType(), freshness.get());, +        return emptyInstance;, +      }, +    }, +    Method generate = GENERATORS.get(rawType);, +    if (generate != null) {, +      ImmutableList<Parameter> params = Invokable.from(generate).getParameters();, +        // values for their generic parameter types., +      return invokeGeneratorMethod(generate, args.toArray());, +  private <T> T newProxy(final Class<T> interfaceType) {, +  private Object invokeGeneratorMethod(Method generator, Object... args) {, +    try {, +      return generator.invoke(this, args);, +    } catch (InvocationTargetException e) {, +      throw Throwables.propagate(e.getCause());, +    } catch (Exception e) {, +      throw Throwables.propagate(e);, +    }, +  }]