[+++ b/guava-tests/test/com/google/common/collect/StreamsTest.java, +  public void testMapWithIndex_intStream() {, +    SpliteratorTester.of(, +            () -> Streams.mapWithIndex(IntStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0:0", "1:1", "2:2");, +  }, +, +  public void testMapWithIndex_longStream() {, +    SpliteratorTester.of(, +            () -> Streams.mapWithIndex(LongStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0:0", "1:1", "2:2");, +  }, +, +  public void testMapWithIndex_doubleStream() {, +    SpliteratorTester.of(, +            () ->, +                Streams.mapWithIndex(DoubleStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0.0:0", "1.0:1", "2.0:2");, +  }, +, +++ b/guava-tests/test/com/google/common/collect/StreamsTest.java, +  public void testMapWithIndex_intStream() {, +    SpliteratorTester.of(, +            () -> Streams.mapWithIndex(IntStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0:0", "1:1", "2:2");, +  }, +, +  public void testMapWithIndex_longStream() {, +    SpliteratorTester.of(, +            () -> Streams.mapWithIndex(LongStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0:0", "1:1", "2:2");, +  }, +, +  public void testMapWithIndex_doubleStream() {, +    SpliteratorTester.of(, +            () ->, +                Streams.mapWithIndex(DoubleStream.of(0, 1, 2), (x, i) -> x + ":" + i).spliterator()), +        .expect("0.0:0", "1.0:1", "2.0:2");, +  }, +, +++ b/guava/src/com/google/common/collect/Streams.java, +import java.util.PrimitiveIterator;, +import java.util.function.DoubleConsumer;, +import java.util.function.IntConsumer;, +import java.util.function.LongConsumer;, +    class Splitr extends MapWithIndexSpliterator<Spliterator<T>, R, Splitr> implements Consumer<T> {, +      T holder;, +        super(splitr, index);, +        if (fromSpliterator.tryAdvance(this)) {, +      Splitr createSplit(Spliterator<T> from, long i) {, +        return new Splitr(from, i);, +      }, +    }, +    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);, +  }, +, +  /**, +   * An analogue of {@link java.util.function.Function} also accepting an index., +   *, +   * <p>This interface is only intended for use by callers of {@link #mapWithIndex(Stream,, +   * FunctionWithIndex)}., +   *, +   * @since 21.0, +   */, +  @Beta, +  public interface FunctionWithIndex<T, R> {, +    /** Applies this function to the given argument and its index within a stream. */, +    R apply(T from, long index);, +  }, +, +  private abstract static class MapWithIndexSpliterator<, +          F extends Spliterator<?>, R, S extends MapWithIndexSpliterator<F, R, S>>, +      implements Spliterator<R> {, +    final F fromSpliterator;, +    long index;, +, +    MapWithIndexSpliterator(F fromSpliterator, long index) {, +      this.fromSpliterator = fromSpliterator;, +      this.index = index;, +    }, +, +    abstract S createSplit(F from, long i);, +, +    @Override, +    public S trySplit() {, +      @SuppressWarnings("unchecked"), +      F split = (F) fromSpliterator.trySplit();, +      S result = createSplit(split, index);, +      return fromSpliterator.estimateSize();, +      return fromSpliterator.characteristics(), +, +  /**, +   * Returns a stream consisting of the results of applying the given function to the elements of, +   * {@code stream} and their indexes in the stream. For example,, +   *, +   * <pre>{@code, +   * mapWithIndex(, +   *     IntStream.of(0, 1, 2),, +   *     (i, index) -> i + ":" + index), +   * }</pre>]