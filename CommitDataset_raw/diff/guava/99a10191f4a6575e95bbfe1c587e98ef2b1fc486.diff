[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        if (entry == null) { // entry is absent or invalid, +, +            int newCount = this.count + 1;, +            if (newCount > this.threshold) { // ensure capacity, +              expand();, +            }, +              if (evictEntries()) {, +                newCount = this.count + 1;, +                first = table.get(index);, +              }, +, +              ++modCount;, +              // recordWrite at computation start because count is incremented, +              recordWrite(entry);, +              this.count = newCount; // write-volatile, +            } else {, +              recordRead(entry);, +              // recursive computation is detected. This is not full-proof, +        }, +              ValueReference<K, V> valueReference = entry.getValueReference();, +              V value = valueReference.waitForValue();, +                clearValue(key, hash, valueReference);, +                scheduleCleanup();, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        if (entry == null) { // entry is absent or invalid, +, +            int newCount = this.count + 1;, +            if (newCount > this.threshold) { // ensure capacity, +              expand();, +            }, +              if (evictEntries()) {, +                newCount = this.count + 1;, +                first = table.get(index);, +              }, +, +              ++modCount;, +              // recordWrite at computation start because count is incremented, +              recordWrite(entry);, +              this.count = newCount; // write-volatile, +            } else {, +              recordRead(entry);, +              // recursive computation is detected. This is not full-proof, +        }, +              ValueReference<K, V> valueReference = entry.getValueReference();, +              V value = valueReference.waitForValue();, +                clearValue(key, hash, valueReference);, +                scheduleCleanup();, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +      if (previous != null) {, +    }, +      if (previous != null) {, +    }, +      if (previous != null) {, +    }, +    Segment segment = segmentFor(hash);, +    if (segment.clearValue(entry.getKey(), hash, valueReference)) {, +      evictionNotificationQueue.offer(entry);, +    }, +, +    segment.scheduleCleanup();, +  // expiration, +  @GuardedBy("Segment.this"), +  static <K, V> void connectExpirables(ReferenceEntry<K, V> previous,, +      ReferenceEntry<K, V> next) {, +    previous.setNextExpirable(next);, +    next.setPreviousExpirable(previous);, +  }, +, +  @GuardedBy("Segment.this"), +  static <K, V> void nullifyExpirable(ReferenceEntry<K, V> nulled) {, +    ReferenceEntry<K, V> nullEntry = nullEntry();, +    nulled.setNextExpirable(nullEntry);, +    nulled.setPreviousExpirable(nullEntry);, +   * Gets the value from an entry. Returns null if the value is null (i.e., +   * reclaimed or not computed yet) or if the entry is expired. If, +   * you already called expireEntries() you can just check the value for, +   * null and skip the expiration check., +  V getUnexpiredValue(ReferenceEntry<K, V> e) {, +, +      // TODO(user): move cleanup to an executor, +      processPendingCleanup();, +, +      // TODO(user): move cleanup to an executor, +      processPendingCleanup();, +            if (expires() && isExpired(e)) {, +              return null;, +            }, +            if (isInvalid(e)) {, +              return null;, +            recordRead(e);, +            return e;, +            return getUnexpiredValue(e) != null;, +            V entryValue = getUnexpiredValue(e);, +            // If the value disappeared, this entry is partially collected,, +            // and we should pretend like it doesn't exist., +            if (onlyIfAbsent && !absent) {, +            if (isInvalid(valueReference)) {, +              if (evictEntries()) {, +                newCount = this.count + 1;]