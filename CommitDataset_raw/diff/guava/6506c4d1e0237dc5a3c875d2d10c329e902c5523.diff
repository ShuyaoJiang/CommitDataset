[+++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +import java.util.Map;, +      } catch (IllegalArgumentException expected) {, +      }, +    } catch (NoSuchElementException expected) {, +    }, +      RangeMap<Integer, Integer> rangemap =, +          ImmutableRangeMap.<Integer, Integer>builder().put(range, 1).build();, +          RangeMap<Integer, Integer> rangemap =, +              ImmutableRangeMap.<Integer, Integer>builder().put(range1, 1).put(range2, 2).build();, +, +  public void testSubRangeMap() {, +    for (Range<Integer> range1 : RANGES) {, +      for (Range<Integer> range2 : RANGES) {, +        if (!range1.isConnected(range2) || range1.intersection(range2).isEmpty()) {, +          for (Range<Integer> subRange : RANGES) {, +            ImmutableRangeMap<Integer, Integer> rangeMap =, +                ImmutableRangeMap.<Integer, Integer>builder(), +                  .put(range1, 1).put(range2, 2).build();, +, +            ImmutableRangeMap.Builder<Integer, Integer> expectedBuilder =, +                ImmutableRangeMap.builder();, +            for (Map.Entry<Range<Integer>, Integer> entry : rangeMap.asMapOfRanges().entrySet()) {, +              if (entry.getKey().isConnected(subRange), +                  && !entry.getKey().intersection(subRange).isEmpty()) {, +                expectedBuilder.put(entry.getKey().intersection(subRange), entry.getValue());, +              }, +            }, +, +            ImmutableRangeMap<Integer, Integer> expected = expectedBuilder.build();, +            assertEquals(expected, rangeMap.subRangeMap(subRange));, +          }, +        }, +      }, +    }, +  }, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +import java.util.Map;, +      } catch (IllegalArgumentException expected) {, +      }, +    } catch (NoSuchElementException expected) {, +    }, +      RangeMap<Integer, Integer> rangemap =, +          ImmutableRangeMap.<Integer, Integer>builder().put(range, 1).build();, +          RangeMap<Integer, Integer> rangemap =, +              ImmutableRangeMap.<Integer, Integer>builder().put(range1, 1).put(range2, 2).build();, +, +  public void testSubRangeMap() {, +    for (Range<Integer> range1 : RANGES) {, +      for (Range<Integer> range2 : RANGES) {, +        if (!range1.isConnected(range2) || range1.intersection(range2).isEmpty()) {, +          for (Range<Integer> subRange : RANGES) {, +            ImmutableRangeMap<Integer, Integer> rangeMap =, +                ImmutableRangeMap.<Integer, Integer>builder(), +                  .put(range1, 1).put(range2, 2).build();, +, +            ImmutableRangeMap.Builder<Integer, Integer> expectedBuilder =, +                ImmutableRangeMap.builder();, +            for (Map.Entry<Range<Integer>, Integer> entry : rangeMap.asMapOfRanges().entrySet()) {, +              if (entry.getKey().isConnected(subRange), +                  && !entry.getKey().intersection(subRange).isEmpty()) {, +                expectedBuilder.put(entry.getKey().intersection(subRange), entry.getValue());, +              }, +            }, +, +            ImmutableRangeMap<Integer, Integer> expected = expectedBuilder.build();, +            assertEquals(expected, rangeMap.subRangeMap(subRange));, +          }, +        }, +      }, +    }, +  }, +++ b/guava/src/com/google/common/collect/ImmutableRangeMap.java, +import static com.google.common.base.Preconditions.checkElementIndex;, +public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K, V> {, +  public ImmutableRangeMap<K, V> subRangeMap(final Range<K> range) {, +    if (checkNotNull(range).isEmpty()) {, +      return ImmutableRangeMap.of();, +    }, +    int lowerIndex = SortedLists.binarySearch(, +        ranges, Range.<K>upperBoundFn(), range.lowerBound,, +        KeyPresentBehavior.FIRST_AFTER, KeyAbsentBehavior.NEXT_HIGHER);, +    int upperIndex = SortedLists.binarySearch(ranges, , +        Range.<K>lowerBoundFn(), range.upperBound,, +        KeyPresentBehavior.ANY_PRESENT, KeyAbsentBehavior.NEXT_HIGHER);, +    if (lowerIndex >= upperIndex) {, +      return ImmutableRangeMap.of();, +    }, +    final int off = lowerIndex;, +    final int len = upperIndex - lowerIndex;, +    ImmutableList<Range<K>> subRanges = new ImmutableList<Range<K>>() {, +      @Override, +      public int size() {, +        return len;, +      }, +, +      @Override, +      public Range<K> get(int index) {, +        checkElementIndex(index, len);, +        if (index == 0 || index == len - 1) {]