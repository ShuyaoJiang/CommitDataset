[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, + * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=, + * "https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description", + * >streams library</a> in a slightly different way., + *, + * <p>The following types of methods are provided:, + *, + * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents, + * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or, + *     array (for example {@link #toList}), + * <p>Several lesser-used features are currently available only as static methods on the {@link, + * Iterables} class., + *, + * <a name="streams"></a>, + * <h3>Comparison to streams</h3>, + *, + * <p>Starting with Java 8, the core Java class libraries provide a new "Streams" library (in {@code, + * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key, + * differences include:</b>, + *, + * <ul>, + * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any "terminal operation" such as, + *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains, + *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually, + *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is, + *     multiple-use, and does implement {@link Iterable}., + * <li>Streams offer many features not found here, including {@code min/max}, {@code, + *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in, + *     support for parallelizing stream operations., + * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are, + *     noted in the method descriptions below., + * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is, + *     strongly recommended., + * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code, + *     incompatible with Java 7 and earlier)., + * </ul>, + *, + * <h3>Example</h3>, + *, + * as a {@code List}: <pre>   {@code, + *   List<String> results =, + *       FluentIterable.from(database.getClientList()), + *           .filter(activeInLastMonthPredicate), + * The approximate stream equivalent is: <pre>   {@code, + *, + *   List<String> results =, + *       database.getClientList(), + *           .stream(), + *           .filter(activeInLastMonthPredicate), + *           .map(Functions.toStringFunction()), + *           .limit(10), + *           .collect(Collectors.toList());}</pre>, +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a, +   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise., +   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code, +   * Arrays.stream(elements)}., +   *, +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(", ", "[", "]"))}, +   * or (less efficiently) {@code collect(Collectors.toList()).toString()}., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}., +   * {@code equals(target)} is true., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}, +  public final boolean contains(@Nullable Object target) {, +    return Iterables.contains(iterable, target);, +   *, +   * <p><b>{@code Stream} equivalent:</b> if this iterable has only a single element {@code, +   * element}, use {@code Stream.generate(() -> element}. Otherwise there is no simple replacement., +   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}., +   *, +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same)., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same)., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same)., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}., +   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that, +   * produces streams, not iterables)., +   *, +   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code, +   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code, +   * stream.findFirst()}., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}, +   *, +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same), +   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same), +   *, +   * @param maxSize the maximum number of elements in the returned fluent iterable, +  public final FluentIterable<E> limit(int maxSize) {]