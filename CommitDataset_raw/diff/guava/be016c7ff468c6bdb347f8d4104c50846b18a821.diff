[+++ b/guava-tests/test/com/google/common/util/concurrent/FutureCallbackTest.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import com.google.common.base.Preconditions;, +, +import junit.framework.TestCase;, +, +import org.mockito.Mockito;, +, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.Executor;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +, +import javax.annotation.Nullable;, +, +/**, + * Test for {@link FutureCallback}., + *, + * @author Anthony Zana, + */, +public class FutureCallbackTest extends TestCase {, +  public void testSameThreadSuccess() {, +    SettableFuture<String> f = SettableFuture.create();, +    MockCallback callback = new MockCallback("foo");, +    Futures.addCallback(f, callback);, +    f.set("foo");, +  }, +, +  public void testExecutorSuccess() {, +    CountingSameThreadExecutor ex = new CountingSameThreadExecutor();, +    SettableFuture<String> f = SettableFuture.create();, +    MockCallback callback = new MockCallback("foo");, +    Futures.addCallback(f, callback, ex);, +    f.set("foo");, +    assertEquals(1, ex.runCount);, +  }, +, +  // Error cases, +  public void testSameThreadExecutionException() {, +    SettableFuture<String> f = SettableFuture.create();, +    Exception e = new IllegalArgumentException("foo not found");, +    MockCallback callback = new MockCallback(e);, +    Futures.addCallback(f, callback);, +    f.setException(e);, +  }, +, +  public void testCancel() {, +    SettableFuture<String> f = SettableFuture.create();, +    FutureCallback<String> callback =, +        new FutureCallback<String>() {, +          private boolean called = false;, +          @Override, +          public void onSuccess(String result) {, +            fail("Was not expecting onSuccess() to be called.");, +          }, +, +          @Override, +          public synchronized void onFailure(Throwable t) {, +            assertFalse(called);, +            assertTrue(t instanceof CancellationException);, +            called = true;, +          }, +        };, +    Futures.addCallback(f, callback);, +    f.cancel(true);, +  }, +, +  public void testThrowErrorFromGet() {, +    Error error = new AssertionError("ASSERT!");, +    ListenableFuture<String> f = ThrowingFuture.throwingError(error);, +    MockCallback callback = new MockCallback(error);, +    Futures.addCallback(f, callback);, +  }, +, +  public void testRuntimeExeceptionFromGet() {, +    RuntimeException e = new IllegalArgumentException("foo not found");, +    ListenableFuture<String> f = ThrowingFuture.throwingRuntimeException(e);, +    MockCallback callback = new MockCallback(e);, +    Futures.addCallback(f, callback);, +  }, +, +  public void testOnSuccessThrowsRuntimeException() throws Exception {, +    RuntimeException exception = new RuntimeException();]