[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        // TODO(user): refactor getLiveEntry into getLiveValue, +        if (entry != null) {, +          // current entry is live, and read was already recorded, +          V value = entry.getValueReference().get();, +          if (value != null) {, +            return value;, +          }, +        }, +, +        // entry is absent, invalid, or computing, +, +          // TODO(user): reuse partially-collected entries, +            // recursive computation is detected. This is not fool-proof, +                if (!valueReference.isComputingReference()) {, +                  invalidateValue(key, hash, valueReference);, +                }, +                // else computing thread will clearValue, +              recordRead(entry);, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return true;, +    }, +, +    public void notifyValueReclaimed() {}, +, +      // TODO(user): explore directly calling, +      // segmentFor(hash).put(key, hash, value, true);, +        segment.expireEntries();, +, +        int newCount = segment.count + 1;, +        if (newCount > segment.threshold) { // ensure capacity, +          segment.expand();, +        }, +, +              // putIfAbsent, +              ++segment.modCount;, +              if (segment.evictEntries()) {, +                newCount = segment.count + 1;, +              }, +, +              segment.count = newCount; // write-volatile, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        // TODO(user): refactor getLiveEntry into getLiveValue, +        if (entry != null) {, +          // current entry is live, and read was already recorded, +          V value = entry.getValueReference().get();, +          if (value != null) {, +            return value;, +          }, +        }, +, +        // entry is absent, invalid, or computing, +, +          // TODO(user): reuse partially-collected entries, +            // recursive computation is detected. This is not fool-proof, +                if (!valueReference.isComputingReference()) {, +                  invalidateValue(key, hash, valueReference);, +                }, +                // else computing thread will clearValue, +              recordRead(entry);, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return false;, +    }, +    public void notifyValueReclaimed() {}, +    public boolean isComputingReference() {, +      return true;, +    }, +, +    public void notifyValueReclaimed() {}, +, +      // TODO(user): explore directly calling, +      // segmentFor(hash).put(key, hash, value, true);, +        segment.expireEntries();, +, +        int newCount = segment.count + 1;, +        if (newCount > segment.threshold) { // ensure capacity, +          segment.expand();, +        }, +, +              // putIfAbsent]