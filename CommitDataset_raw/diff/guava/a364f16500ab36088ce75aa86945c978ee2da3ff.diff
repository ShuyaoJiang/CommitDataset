[+++ b/guava-tests/test/com/google/common/reflect/TypeResolverTest.java, +/*, + * Copyright (C) 2012 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.reflect;, +, +import junit.framework.TestCase;, +, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.util.List;, +import java.util.Map;, +, +/**, + * Unit tests of {@link TypeResolver}., + *, + * @author benyu@google.com (Ben Yu), + */, +public class TypeResolverTest extends TestCase {, +, +  public void testWhere_noMapping() {, +    Type t = aTypeVariable();, +    assertEquals(t, new TypeResolver().resolveType(t));, +  }, +, +  public void testWhere_typeVariableMapping() {, +    Type t = aTypeVariable();, +    assertEquals(String.class, new TypeResolver().where(t, String.class).resolveType(t));, +  }, +, +  public <T> void testWhere_indirectMapping() {, +    Type t1 = new TypeCapture<T>() {}.capture();, +    Type t2 = aTypeVariable();, +    assertEquals(String.class,, +        new TypeResolver().where(t1, t2).where(t2, String.class).resolveType(t1));, +  }, +, +  public void testWhere_typeVariableSelfMapping() {, +    TypeResolver resolver = new TypeResolver();, +    Type t = aTypeVariable();, +    assertEquals(t, resolver.where(t, t).resolveType(t));, +  }, +, +  public <T> void testWhere_parameterizedSelfMapping() {, +    TypeResolver resolver = new TypeResolver();, +    Type t = new TypeCapture<List<T>>() {}.capture();, +    assertEquals(t, resolver.where(t, t).resolveType(t));, +  }, +, +  public <T> void testWhere_genericArraySelfMapping() {, +    TypeResolver resolver = new TypeResolver();, +    Type t = new TypeCapture<T[]>() {}.capture();, +    assertEquals(t, resolver.where(t, t).resolveType(t));, +  }, +, +  public <T> void testWhere_rawClassSelfMapping() {, +    TypeResolver resolver = new TypeResolver();, +    assertEquals(String.class,, +        resolver.where(String.class, String.class).resolveType(String.class));, +  }, +, +  public <T> void testWhere_wildcardSelfMapping() {, +    TypeResolver resolver = new TypeResolver();, +    Type t = aWildcardType();, +    assertEquals(t, resolver.where(t, t).resolveType(t));, +  }, +, +  public <T> void testWhere_duplicateMapping() {, +    Type t = aTypeVariable();, +    TypeResolver resolver = new TypeResolver().where(t, String.class);, +    try {, +      resolver.where(t, String.class);, +      fail();, +    } catch (IllegalArgumentException expected) {}, +  }, +, +  public <T1, T2 extends List<T1>> void testWhere_recursiveMapping() {, +    Type t1 = new TypeCapture<T1>() {}.capture();, +    Type t2 = new TypeCapture<T2>() {}.capture();, +    assertEquals(t2, new TypeResolver().where(t1, t2).resolveType(t1));, +  }, +, +  public <T> void testWhere_genericArrayMapping() {, +    Type t = new TypeCapture<T>() {}.capture();, +    assertEquals(String.class, new TypeResolver(), +        .where(new TypeCapture<T[]>() {}.capture(), String[].class), +        .resolveType(t));]