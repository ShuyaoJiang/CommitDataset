[+++ b/guava-tests/test/com/google/common/util/concurrent/SerializingExecutorTest.java, +    fakePool.runNext(); // run just 1 sub task..., +    fakePool.runNext();, +    fakePool.runNext();, +    fakePool.runNext();, +++ b/guava-tests/test/com/google/common/util/concurrent/SerializingExecutorTest.java, +    fakePool.runNext(); // run just 1 sub task..., +    fakePool.runNext();, +    fakePool.runNext();, +    fakePool.runNext();, +++ b/guava/src/com/google/common/util/concurrent/SerializingExecutor.java, +import java.util.Queue;, + * TODO(user): The tasks are given to the underlying executor as a single, + * task, which means the semantics of the executor may be changed, e.g. the, + * executor may have an afterExecute method that runs after every task, + * TODO(user): What happens in case of shutdown or shutdownNow?  Should, + * TaskRunner check for interruption?, + * TODO(user): It would be nice to provide a handle to individual task, + * results using Future.  Maybe SerializingExecutorService?, + * @author JJ Furman, +  /** A list of Runnables to be run in order. */, +  private final Queue<Runnable> waitQueue = new ArrayDeque<Runnable>();, +  /**, +   * We explicitly keep track of if the TaskRunner is currently scheduled to, +   * run.  If it isn't, we start it.  We can't just use, +   * waitQueue.isEmpty() as a proxy because we need to ensure that only one, +   * Runnable submitted is running at a time so even if waitQueue is empty, +   * the isThreadScheduled isn't set to false until after the Runnable is, +   * finished., +   */, +  @GuardedBy("internalLock"), +  private boolean isThreadScheduled = false;, +  /** The object that actually runs the Runnables submitted, reused. */, +  private final TaskRunner taskRunner = new TaskRunner();, +, +  /**, +   * Creates a SerializingExecutor, running tasks using {@code executor}., +   *, +   * @param executor Executor in which tasks should be run. Must not be null., +   */, +    Preconditions.checkNotNull(executor, "'executor' must not be null.");, +    this.executor = executor;, +  private final Object internalLock = new Object() {, +    @Override public String toString() {, +      return "SerializingExecutor lock: " + super.toString();, +    }, +  };, +, +   * Runs the given runnable strictly after all Runnables that were submitted, +   * before it, and using the {@code executor} passed to the constructor.     ., +  @Override, +  public void execute(Runnable r) {, +    Preconditions.checkNotNull(r, "'r' must not be null.");, +    boolean scheduleTaskRunner = false;, +      waitQueue.add(r);, +      if (!isThreadScheduled) {, +        isThreadScheduled = true;, +        scheduleTaskRunner = true;, +    if (scheduleTaskRunner) {, +      boolean threw = true;, +        executor.execute(taskRunner);, +        threw = false;, +        if (threw) {, +            // It is possible that at this point that there are still tasks in, +            // the queue, it would be nice to keep trying but the error may not, +            // be recoverable.  So we update our state and propogate so that if, +            // our caller deems it recoverable we won't be stuck., +            isThreadScheduled = false;, +          }, +   * Task that actually runs the Runnables.  It takes the Runnables off of the, +   * queue one by one and runs them.  After it is done with all Runnables and, +   * there are no more to run, puts the SerializingExecutor in the state where, +   * isThreadScheduled = false and returns.  This allows the current worker, +   * thread to return to the original pool., +  private class TaskRunner implements Runnable {, +      boolean stillRunning = true;, +        while (true) {, +          Preconditions.checkState(isThreadScheduled);, +          Runnable nextToRun;, +            nextToRun = waitQueue.poll();, +            if (nextToRun == null) {, +              isThreadScheduled = false;, +              stillRunning = false;, +              break;, +          // Always run while not holding the lock, to avoid deadlocks., +            nextToRun.run();, +            // Log it and keep going., +            log.log(Level.SEVERE, "Exception while executing runnable ", +                + nextToRun, e);, +          }, +        }, +      } finally {, +        if (stillRunning) {, +          // An Error is bubbling up, we should mark ourselves as no longer, +          // running, that way if anyone tries to keep using us we won't be, +          // corrupted., +          synchronized (internalLock) {, +            isThreadScheduled = false;, +          }]