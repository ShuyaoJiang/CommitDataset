[+++ b/android/guava-tests/test/com/google/common/util/concurrent/UninterruptiblesTest.java, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +import java.util.Date;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +  // Condition.await() tests, +  public void testConditionAwaitTimeoutExceeded() {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +    Condition condition = TestCondition.create();, +, +    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 500, MILLISECONDS);, +, +    assertFalse(signaledBeforeTimeout);, +    assertAtLeastTimePassed(stopwatch, 500);, +    assertNotInterrupted();, +  }, +, +  public void testConditionAwaitTimeoutNotExceeded() {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +    Condition condition = TestCondition.createAndSignalAfter(500, MILLISECONDS);, +, +    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 1500, MILLISECONDS);, +, +    assertTrue(signaledBeforeTimeout);, +    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);, +    assertNotInterrupted();, +  }, +, +  public void testConditionAwaitInterruptedTimeoutExceeded() {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +    Condition condition = TestCondition.create();, +    requestInterruptIn(500);, +, +    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 1000, MILLISECONDS);, +, +    assertFalse(signaledBeforeTimeout);, +    assertAtLeastTimePassed(stopwatch, 1000);, +    assertInterrupted();, +  }, +, +  public void testConditionAwaitInterruptedTimeoutNotExceeded() {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +    Condition condition = TestCondition.createAndSignalAfter(1000, MILLISECONDS);, +    requestInterruptIn(500);, +, +    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 1500, MILLISECONDS);, +, +    assertTrue(signaledBeforeTimeout);, +    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);, +    assertInterrupted();, +  }, +, +  }, +     * behavior sometimes when running these tests publicly as part of Guava. "+ 5" is probably more, +     * generous than it needs to be., +, +  private static class TestCondition implements Condition {, +    private final Lock lock;, +    private final Condition condition;, +, +    private TestCondition(Lock lock, Condition condition) {, +      this.lock = lock;, +      this.condition = condition;, +    }, +, +    static TestCondition createAndSignalAfter(long delay, TimeUnit unit) {, +      final TestCondition testCondition = create();, +, +      ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(1);, +      // If signal() fails somehow, we should see a failed test, even without looking at the Future., +      Future<?> unused =, +          scheduledPool.schedule(, +              new Runnable() {, +                @Override, +                public void run() {, +                  testCondition.signal();, +                }, +              },, +              delay,, +              unit);, +, +      return testCondition;, +    }, +, +    static TestCondition create() {, +      Lock lock = new ReentrantLock();, +      Condition condition = lock.newCondition();, +      return new TestCondition(lock, condition);, +    }, +, +    @Override, +    public void await() throws InterruptedException {, +      lock.lock();, +      try {, +        condition.await();]