[+++ b/guava-tests/test/com/google/common/math/QuantilesTest.java, +import com.google.common.truth.Correspondence;, +import javax.annotation.Nullable;, +  /**, +   * A {@link Correspondence} which accepts finite values within {@link #ALLOWED_ERROR} of each, +   * other., +   */, +  private static final Correspondence<Number, Number> FINITE_QUANTILE_CORRESPONDENCE =, +      Correspondence.tolerance(ALLOWED_ERROR);, +, +  /**, +   * A {@link Correspondence} which accepts either finite values within {@link #ALLOWED_ERROR} of, +   * each other or identical non-finite values., +   */, +  private static final Correspondence<Double, Double> QUANTILE_CORRESPONDENCE =, +      new Correspondence<Double, Double>() {, +, +        @Override, +        public boolean compare(@Nullable Double actual, @Nullable Double expected) {, +          // Test for equality to allow non-finite values to match; otherwise, use the finite test., +          return actual.equals(expected), +              || FINITE_QUANTILE_CORRESPONDENCE.compare(actual, expected);, +        }, +, +        @Override, +        public String toString() {, +          return "is identical to or " + FINITE_QUANTILE_CORRESPONDENCE;, +        }, +      };, +, +    assertThat(median().compute(SIXTEEN_SQUARES_DOUBLES)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_MEDIAN);, +    assertThat(median().computeInPlace(dataset)).isWithin(ALLOWED_ERROR).of(SIXTEEN_SQUARES_MEDIAN);, +    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);, +    assertThat(quartiles().index(1).compute(SIXTEEN_SQUARES_DOUBLES)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_QUARTILE_1);, +    assertThat(quartiles().index(1).computeInPlace(dataset)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_QUARTILE_1);, +    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);, +    assertThat(quartiles().indexes(1, 3).compute(SIXTEEN_SQUARES_DOUBLES)), +        .comparingValuesUsing(QUANTILE_CORRESPONDENCE), +        .containsExactly(1, SIXTEEN_SQUARES_QUARTILE_1, 3, SIXTEEN_SQUARES_QUARTILE_3);, +    assertThat(quartiles().indexes(1, 3).computeInPlace(dataset)), +        .comparingValuesUsing(QUANTILE_CORRESPONDENCE), +        .containsExactly(, +            3, SIXTEEN_SQUARES_QUARTILE_3);, +    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);, +    assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_DOUBLES)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_LONGS)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_INTEGERS)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(Quantiles.scale(10).index(1).compute(dataset)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(dataset), +        .usingExactEquality(), +        .containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES), +        .inOrder();, +    assertThat(Quantiles.scale(10).index(1).compute(dataset)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_LONGS);, +    assertThat(Quantiles.scale(10).index(1).compute(dataset)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_INTEGERS);, +    assertThat(Quantiles.scale(10).index(1).computeInPlace(dataset)), +        .isWithin(ALLOWED_ERROR), +        .of(SIXTEEN_SQUARES_DECILE_1);, +    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);, +    assertThat(Quantiles.scale(10).index(5).computeInPlace(78.9, 12.3, 45.6)), +        .isWithin(ALLOWED_ERROR), +        .of(45.6);, +    // Note that we specify index 1 twice, which by the method contract should be ignored., +    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_DOUBLES)), +        .comparingValuesUsing(QUANTILE_CORRESPONDENCE), +        .containsExactly(, +            8, SIXTEEN_SQUARES_DECILE_8);, +    int[] indexes = { 0, 10, 5, 1, 8, 10 };, +    ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(indexes);, +    indexes[0] = 3;, +    assertThat(intermediate.compute(SIXTEEN_SQUARES_DOUBLES)), +        .comparingValuesUsing(QUANTILE_CORRESPONDENCE), +        .containsExactly(, +            8, SIXTEEN_SQUARES_DECILE_8);, +    assertThat(, +            Quantiles.scale(scale).indexes(0, scale, otherIndex).compute(SIXTEEN_SQUARES_DOUBLES)), +        .comparingValuesUsing(QUANTILE_CORRESPONDENCE), +        .containsExactly(, +            0, SIXTEEN_SQUARES_MIN, scale, SIXTEEN_SQUARES_MAX, otherIndex, otherValue);, +    // Note that we specify index 1 twice, which by the method contract should be ignored., +    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_LONGS))]