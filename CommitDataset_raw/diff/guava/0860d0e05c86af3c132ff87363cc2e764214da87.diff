[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // 1. Cancellation should propagate from the returned future to the input future(s)., +  //    assigned prior to calling addListener, and addListener happens-before any invocation of the, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'running' visible to, +  //    the listener., +  //    a (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,, +  //    it would just add an edge such that if cancel() observed non-null, then it would also, +  //    definitely observe all earlier writes, but we still have no guarantee that cancel() would, +  //    see the inital write (just stronger guarantees if it does)., +  // For a (long) discussion about this specific issue and the general futility of life., +  // methods that involve volatile read/write operations, in practice there is no issue.  Also, the, +  // way in such a visibility issue would surface is most likely as a failure of cancel() to, +  // propagate to the input.  Cancellation propagation is fundamentally racy so this is fine., +  //, +  // Future versions of the JMM may revise safe construction semantics in such a way that we can, +  // safely publish these objects and we won't need this whole discussion., +  // TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs, +  // that should resolve the issue.  This comes at the cost of adding more write barriers to the, +  // implementations., +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // 1. Cancellation should propagate from the returned future to the input future(s)., +  //    assigned prior to calling addListener, and addListener happens-before any invocation of the, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'running' visible to, +  //    the listener., +  //    a (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,, +  //    it would just add an edge such that if cancel() observed non-null, then it would also, +  //    definitely observe all earlier writes, but we still have no guarantee that cancel() would, +  //    see the inital write (just stronger guarantees if it does)., +  // For a (long) discussion about this specific issue and the general futility of life., +  // methods that involve volatile read/write operations, in practice there is no issue.  Also, the, +  // way in such a visibility issue would surface is most likely as a failure of cancel() to, +  // propagate to the input.  Cancellation propagation is fundamentally racy so this is fine., +  //, +  // Future versions of the JMM may revise safe construction semantics in such a way that we can, +  // safely publish these objects and we won't need this whole discussion., +  // TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs, +  // that should resolve the issue.  This comes at the cost of adding more write barriers to the, +  // implementations., +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +  // 1. Cancellation should propagate from the returned future to the input future(s)., +  //    assigned prior to calling addListener, and addListener happens-before any invocation of the, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'running' visible to, +  //    the listener., +  //    a (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,, +  //    it would just add an edge such that if cancel() observed non-null, then it would also, +  //    definitely observe all earlier writes, but we still have no guarantee that cancel() would, +  //    see the inital write (just stronger guarantees if it does)., +  // For a (long) discussion about this specific issue and the general futility of life., +  // methods that involve volatile read/write operations, in practice there is no issue.  Also, the, +  // way in such a visibility issue would surface is most likely as a failure of cancel() to, +  // propagate to the input.  Cancellation propagation is fundamentally racy so this is fine., +  //, +  // Future versions of the JMM may revise safe construction semantics in such a way that we can, +  // safely publish these objects and we won't need this whole discussion., +  // TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs, +  // that should resolve the issue.  This comes at the cost of adding more write barriers to the, +  // implementations., +      ImmutableList<ListenableFuture<?>> localFutures = this.futures;, +        if (localFutures != null) {, +          for (ListenableFuture<?> future : localFutures) {, +        }, +      if (cancelled && futuresToCancel != null) {]