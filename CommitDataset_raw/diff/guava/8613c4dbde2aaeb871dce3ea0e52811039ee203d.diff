[+++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +        helper =, +            new SafeAtomicHelper(, +        // For these users fallback to a suboptimal implementation, based on synchronized. This will, +        // be a definite performance hit to those users., +      // This is racy with removeWaiter. The consequence of the race is that we may spuriously call, +      // unpark even though the thread has already removed itself from the list. But even if we did, +      // use a CAS, that race would still exist (it would just be ever so slightly smaller)., +   * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved, +   * by two things., +   * <li>This is only called when a waiting thread times out or is interrupted. Both of which should, +   *     be rare., +   * <li>Any other non-null value, terminal state, {@code set} was called with a non-null argument., +  //   is). If we wanted to be strict about it, we could store the unpark() time in the Waiter node, +  //   and we could use that to make a decision about whether or not we timed out prior to being, +  //   unparked., +      // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if, +      // we're given a bad one. We only catch RuntimeException because we want Errors to propagate, +      // up., +   * <p>This is an implementation of last resort for when certain basic VM features are broken (like, +   * AtomicReferenceFieldUpdater)., +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +        helper =, +            new SafeAtomicHelper(, +        // For these users fallback to a suboptimal implementation, based on synchronized. This will, +        // be a definite performance hit to those users., +      // This is racy with removeWaiter. The consequence of the race is that we may spuriously call, +      // unpark even though the thread has already removed itself from the list. But even if we did, +      // use a CAS, that race would still exist (it would just be ever so slightly smaller)., +   * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved, +   * by two things., +   * <li>This is only called when a waiting thread times out or is interrupted. Both of which should, +   *     be rare., +   * <li>Any other non-null value, terminal state, {@code set} was called with a non-null argument., +  //   is). If we wanted to be strict about it, we could store the unpark() time in the Waiter node, +  //   and we could use that to make a decision about whether or not we timed out prior to being, +  //   unparked., +      // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if, +      // we're given a bad one. We only catch RuntimeException because we want Errors to propagate, +      // up., +   * <p>This is an implementation of last resort for when certain basic VM features are broken (like, +   * AtomicReferenceFieldUpdater)., +++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java, + * late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify, + * shared state without additional synchronization necessary for visibility to later executions of, + * the life cycle methods., +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +        helper =, +            new SafeAtomicHelper(, +        // For these users fallback to a suboptimal implementation, based on synchronized. This will, +        // be a definite performance hit to those users., +      // This is racy with removeWaiter. The consequence of the race is that we may spuriously call, +      // unpark even though the thread has already removed itself from the list. But even if we did, +      // use a CAS, that race would still exist (it would just be ever so slightly smaller)., +   * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved, +   * by two things., +   * <li>This is only called when a waiting thread times out or is interrupted. Both of which should, +   *     be rare., +   * <li>Any other non-null value, terminal state, {@code set} was called with a non-null argument., +  //   is). If we wanted to be strict about it, we could store the unpark() time in the Waiter node, +  //   and we could use that to make a decision about whether or not we timed out prior to being, +  //   unparked., +      // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if, +      // we're given a bad one. We only catch RuntimeException because we want Errors to propagate, +      // up., +   * <p>This is an implementation of last resort for when certain basic VM features are broken (like, +   * AtomicReferenceFieldUpdater)., +++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java, + * late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify, + * shared state without additional synchronization necessary for visibility to later executions of, + * the life cycle methods., +++ b/guava/src/com/google/common/util/concurrent/AbstractService.java, +     * The internal state, which equals external state unless shutdownWhenStartupFinishes is true., +     * If true, the user requested a shutdown while the service was still starting up., +     * The exception that caused this service to fail. This will be {@code null} unless the service, +     * has failed., +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +        helper =, +            new SafeAtomicHelper(, +        // For these users fallback to a suboptimal implementation, based on synchronized. This will, +        // be a definite performance hit to those users., +      // This is racy with removeWaiter. The consequence of the race is that we may spuriously call, +      // unpark even though the thread has already removed itself from the list. But even if we did, +      // use a CAS, that race would still exist (it would just be ever so slightly smaller)., +   * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved, +   * by two things., +   * <li>This is only called when a waiting thread times out or is interrupted. Both of which should, +   *     be rare., +   * <li>Any other non-null value, terminal state, {@code set} was called with a non-null argument., +  //   is). If we wanted to be strict about it, we could store the unpark() time in the Waiter node, +  //   and we could use that to make a decision about whether or not we timed out prior to being, +  //   unparked., +      // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if, +      // we're given a bad one. We only catch RuntimeException because we want Errors to propagate, +      // up., +   * <p>This is an implementation of last resort for when certain basic VM features are broken (like, +   * AtomicReferenceFieldUpdater)., +++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java, + * late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify, + * shared state without additional synchronization necessary for visibility to later executions of]