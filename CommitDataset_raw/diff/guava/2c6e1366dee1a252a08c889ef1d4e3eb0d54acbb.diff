[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +        assertTrue(BloomFilter.optimalNumOfHashFunctions(n, m) > 0);, +        assertTrue(BloomFilter.optimalNumOfBits(n, fpp) >= 0);, +      assertTrue(BloomFilter.optimalNumOfBits(random.nextInt(1 << 16), random.nextDouble()) >= 0);, +    assertEquals(Integer.MAX_VALUE, BloomFilter.optimalNumOfBits(, +        Integer.MAX_VALUE, Double.MIN_VALUE));, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +        assertTrue(BloomFilter.optimalNumOfHashFunctions(n, m) > 0);, +        assertTrue(BloomFilter.optimalNumOfBits(n, fpp) >= 0);, +      assertTrue(BloomFilter.optimalNumOfBits(random.nextInt(1 << 16), random.nextDouble()) >= 0);, +    assertEquals(Integer.MAX_VALUE, BloomFilter.optimalNumOfBits(, +        Integer.MAX_VALUE, Double.MIN_VALUE));, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +import com.google.common.hash.BloomFilterStrategies.BitArray;, +  /**, +   * A strategy to translate T instances, to {@code numHashFunctions} bit indexes., +   */, +  interface Strategy extends java.io.Serializable {, +    /**, +     * Sets {@code numHashFunctions} bits of the given bit array, by hashing a user element. , +     */, +    <T> void put(T object, Funnel<? super T> funnel, int numHashFunctions, BitArray bits);, +    /**, +     * Queries {@code numHashFunctions} bits of the given bit array, by hashing a user element;, +     * returns {@code true} if and only if all selected bits are set. , +     */, +    <T> boolean mightContain(, +        T object, Funnel<? super T> funnel, int numHashFunctions, BitArray bits);, +  }, +  , +  /** The bit set of the BloomFilter (not necessarily power of 2!)*/, +  private final BitArray bits;, +  /** The funnel to translate Ts to bytes */, +  /**, +   * The strategy we employ to map an element T to {@code numHashFunctions} bit indexes., +   */, +  private final Strategy strategy;, +      Strategy strategy) {, +    this.strategy = strategy;, +  public boolean mightContain(T object) {, +    return strategy.mightContain(object, funnel, numHashFunctions, bits);, +  public void put(T object) {, +    strategy.put(object, funnel, numHashFunctions, bits);, +    int numBits = optimalNumOfBits(expectedInsertions, falsePositiveProbability);, +    int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);, +    return new BloomFilter<T>(new BitArray(numBits), numHashFunctions, funnel,, +        BloomFilterStrategies.MURMUR128_MITZ_32);, +  /*, +   * Cheat sheet:, +   * , +   * m: total bits, +   * n: expected insertions, +   * b: m/n, bits per insertion, +, +   * p: expected false positive probability, +   * , +   * 1) Optimal k = b * ln2, +   * 2) p = (1 - e ^ (-kn/m))^k, +   * 3) For optimal k: p = 2 ^ (-k) ~= 0.6185^b, +   * 4) For optimal k: m = -nlnp / ((ln2) ^ 2), +   */, +  @VisibleForTesting static int optimalNumOfHashFunctions(int n, int m) {, +  @VisibleForTesting static int optimalNumOfBits(int n, double p) {, +    final Strategy strategy;, +      this.strategy = bf.strategy;, +      return new BloomFilter<T>(new BitArray(data), numHashFunctions, funnel, strategy);, +    private static final long serialVersionUID = 1;, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +        assertTrue(BloomFilter.optimalNumOfHashFunctions(n, m) > 0);, +        assertTrue(BloomFilter.optimalNumOfBits(n, fpp) >= 0);, +      assertTrue(BloomFilter.optimalNumOfBits(random.nextInt(1 << 16), random.nextDouble()) >= 0);, +    assertEquals(Integer.MAX_VALUE, BloomFilter.optimalNumOfBits(, +        Integer.MAX_VALUE, Double.MIN_VALUE));, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +import com.google.common.hash.BloomFilterStrategies.BitArray;, +  /**, +   * A strategy to translate T instances, to {@code numHashFunctions} bit indexes., +   */, +  interface Strategy extends java.io.Serializable {, +    /**, +     * Sets {@code numHashFunctions} bits of the given bit array, by hashing a user element. , +     */, +    <T> void put(T object, Funnel<? super T> funnel, int numHashFunctions, BitArray bits);, +    /**, +     * Queries {@code numHashFunctions} bits of the given bit array, by hashing a user element;, +     * returns {@code true} if and only if all selected bits are set. , +     */, +    <T> boolean mightContain(, +        T object, Funnel<? super T> funnel, int numHashFunctions, BitArray bits);, +  }, +  , +  /** The bit set of the BloomFilter (not necessarily power of 2!)*/, +  private final BitArray bits;, +  /** The funnel to translate Ts to bytes */, +  /**, +   * The strategy we employ to map an element T to {@code numHashFunctions} bit indexes., +   */, +  private final Strategy strategy;, +      Strategy strategy) {, +    this.strategy = strategy;]