[+++ b/guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java, +      int expectedRanges = 0;, +        boolean overlaps = false;, +        for (Range<Integer> other : mutable.asRanges()) {, +          if (other.isConnected(range) && !other.intersection(range).isEmpty()) {, +            overlaps = true;, +          }, +        }, +, +        try {, +          assertFalse(overlaps);, +          mutable.add(range);, +        } catch (IllegalArgumentException e) {, +          assertTrue(overlaps);, +        }, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java, +      int expectedRanges = 0;, +        boolean overlaps = false;, +        for (Range<Integer> other : mutable.asRanges()) {, +          if (other.isConnected(range) && !other.intersection(range).isEmpty()) {, +            overlaps = true;, +          }, +        }, +, +        try {, +          assertFalse(overlaps);, +          mutable.add(range);, +        } catch (IllegalArgumentException e) {, +          assertTrue(overlaps);, +        }, +++ b/guava/src/com/google/common/collect/ImmutableRangeSet.java, +import static com.google.common.base.Preconditions.checkArgument;, +   * A builder for immutable range sets., +     * Add the specified range to this builder.  {@linkplain Range#isConnected Connected} ranges, +     * will be {@linkplain Range#span(Range) coalesced}., +     *, +     * @throws IllegalArgumentException if {@code range} is empty or overlaps any ranges already, +     *         added to the builder, +      if (range.isEmpty()) {, +        throw new IllegalArgumentException("range must not be empty, but was " + range);, +      } else if (!rangeSet.complement().encloses(range)) {, +        for (Range<C> currentRange : rangeSet.asRanges()) {, +          checkArgument(, +              !currentRange.isConnected(range) || currentRange.intersection(range).isEmpty(),, +              "Ranges may not overlap, but received %s and %s", currentRange, range);, +        }, +        throw new AssertionError("should have thrown an IAE above");, +      }, +      for (Range<C> range : ranges.asRanges()) {, +        add(range);, +      }]