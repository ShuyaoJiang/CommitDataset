[+++ b/guava/src/com/google/common/base/Equivalence.java, + * @author Gregory Kick, +   * {@link Wrapper#equals(Object) Object.equals()} such that, +  public final <S extends T> Wrapper<S> wrap(@Nullable S reference) {, +    return new Wrapper<S>(this, reference);, +  }, +, +  /**, +   * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an, +   * {@link Equivalence}., +   *, +   * <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}, +   * that tests equivalence using their lengths:, +   *, +   * <pre>   {@code, +   *   equiv.wrap("a").equals(equiv.wrap("b")) // true, +   *   equiv.wrap("a").equals(equiv.wrap("hello")) // false, +   * }</pre>, +   *, +   * <p>Note in particular that an equivalence wrapper is never equal to the object it wraps., +   *, +   * <pre>   {@code, +   *   equiv.wrap(obj).equals(obj) // always false, +   * }</pre>, +   *, +   * @since Guava release 10, +   */, +  @Beta, +  public static final class Wrapper<T> {, +    private final Equivalence<? super T> equivalence;, +    @Nullable private final T reference;, +, +    private Wrapper(Equivalence<? super T> equivalence, @Nullable T reference) {, +      this.equivalence = checkNotNull(equivalence);, +      this.reference = reference;, +    }, +, +    /** Returns the (possibly null) reference wrapped by this instance. */, +    @Nullable public T get() {, +      return reference;, +    }, +, +    /**, +     * Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped, +     * references is {@code true} and both wrappers use the {@link Object#equals(Object) same}, +     * equivalence., +     */, +    @Override public boolean equals(@Nullable Object obj) {, +      if (obj == this) {, +        return true;, +      } else if (obj instanceof Wrapper) {, +        Wrapper<?> that = (Wrapper<?>) obj;, +        /*, +         * We cast to Equivalence<Object> here because we can't check the type of the reference held, +         * by the other wrapper.  But, by checking that the Equivalences are equal, we know that, +         * whatever type it is, it is assignable to the type handled by this wrapper's equivalence., +         */, +        @SuppressWarnings("unchecked"), +        Equivalence<Object> equivalence = (Equivalence<Object>) this.equivalence;, +        return equivalence.equals(that.equivalence), +            && equivalence.equivalent(this.reference, that.reference);, +      } else {, +        return false;, +      }, +    }, +, +    /**, +     * Returns the result of {@link Equivalence#hash(Object)} applied to the the wrapped reference., +     */, +    @Override public int hashCode() {, +      return equivalence.hash(reference);, +    }, +, +    /**, +     * Returns a string representation for this equivalence wrapper. The form of this string, +     * representation is not specified., +     */, +    @Override public String toString() {, +      return equivalence + ".wrap(" + reference + ")";, +    }, +++ b/guava/src/com/google/common/base/Equivalence.java, + * @author Gregory Kick, +   * {@link Wrapper#equals(Object) Object.equals()} such that, +  public final <S extends T> Wrapper<S> wrap(@Nullable S reference) {, +    return new Wrapper<S>(this, reference);, +  }, +, +  /**, +   * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an, +   * {@link Equivalence}., +   *, +   * <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}, +   * that tests equivalence using their lengths:, +   *, +   * <pre>   {@code, +   *   equiv.wrap("a").equals(equiv.wrap("b")) // true, +   *   equiv.wrap("a").equals(equiv.wrap("hello")) // false, +   * }</pre>, +   *, +   * <p>Note in particular that an equivalence wrapper is never equal to the object it wraps.]