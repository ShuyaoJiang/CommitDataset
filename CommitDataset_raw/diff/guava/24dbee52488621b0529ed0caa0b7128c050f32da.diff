[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java, +import com.google.common.base.Objects;, +import java.util.NoSuchElementException;, + * A multiset which maintains the ordering of its elements, according to either their natural order, + * or an explicit {@link Comparator}. In all cases, this implementation uses, + * {@link Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to, + * determine equivalence of instances., + * <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the, + * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the, + * {@link java.util.Collection} contract, which is specified in terms of {@link Object#equals}., +public final class TreeMultiset<E> extends AbstractSortedMultiset<E> implements Serializable {, +   * Creates a new, empty multiset, sorted according to the elements' natural order. All elements, +   * inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all, +   * such elements must be <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a, +   * {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the, +   * user attempts to add an element to the multiset that violates this constraint (for example,, +   * the user attempts to add a string element to a set whose elements are integers), the, +   * {@code add(Object)} call will throw a {@code ClassCastException}., +   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific, +   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics., +   * Creates a new, empty multiset, sorted according to the specified comparator. All elements, +   * inserted into the multiset must be <i>mutually comparable</i> by the specified comparator:, +   * {@code comparator.compare(e1,, +   * e2)} must not throw a {@code ClassCastException} for any elements {@code e1} and {@code e2} in, +   * the multiset. If the user attempts to add an element to the multiset that violates this, +   * constraint, the {@code add(Object)} call will throw a {@code ClassCastException}., +   * @param comparator, +   *          the comparator that will be used to sort this multiset. A null value indicates that, +   *          the elements' <i>natural ordering</i> should be used., +  public static <E> TreeMultiset<E> create(@Nullable Comparator<? super E> comparator) {, +   * Creates an empty multiset containing the given initial elements, sorted according to the, +   * elements' natural order., +   * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}., +   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific, +   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics., +  public static <E extends Comparable> TreeMultiset<E> create(Iterable<? extends E> elements) {, +  private final transient Reference<AvlNode<E>> rootReference;, +  private final transient GeneralRange<E> range;, +  private final transient AvlNode<E> header;, +, +  TreeMultiset(Reference<AvlNode<E>> rootReference, GeneralRange<E> range, AvlNode<E> endLink) {, +    super(range.comparator());, +    this.rootReference = rootReference;, +    this.range = range;, +    this.header = endLink;, +  TreeMultiset(Comparator<? super E> comparator) {, +    this.header = new AvlNode<E>(null, 1);, +    successor(header, header);, +    this.rootReference = new Reference<AvlNode<E>>();, +  /**, +   * A function which can be summed across a subtree., +   */, +  private enum Aggregate {, +    SIZE {, +      @Override, +      int nodeAggregate(AvlNode<?> node) {, +        return node.elemCount;, +      long treeAggregate(@Nullable AvlNode<?> root) {, +        return (root == null) ? 0 : root.totalCount;, +      }, +    },, +    DISTINCT {, +      @Override, +      int nodeAggregate(AvlNode<?> node) {, +        return 1;, +      }, +, +      @Override, +      long treeAggregate(@Nullable AvlNode<?> root) {, +        return (root == null) ? 0 : root.distinctElements;, +      }, +    };, +    abstract int nodeAggregate(AvlNode<?> node);, +, +    abstract long treeAggregate(@Nullable AvlNode<?> root);, +  }, +, +  private long aggregateForEntries(Aggregate aggr) {, +    AvlNode<E> root = rootReference.get();, +    long total = aggr.treeAggregate(root);, +    if (range.hasLowerBound()) {, +      total -= aggregateBelowRange(aggr, root);, +    }, +    if (range.hasUpperBound()) {, +      total -= aggregateAboveRange(aggr, root);, +    }, +    return total;, +  }, +, +  private long aggregateBelowRange(Aggregate aggr, @Nullable AvlNode<E> node) {, +    if (node == null) {, +      return 0;, +    }, +    int cmp = comparator().compare(range.getLowerEndpoint(), node.elem);, +    if (cmp < 0) {, +      return aggregateBelowRange(aggr, node.left);, +    } else if (cmp == 0) {, +      switch (range.getLowerBoundType()) {, +        case OPEN:, +          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);]