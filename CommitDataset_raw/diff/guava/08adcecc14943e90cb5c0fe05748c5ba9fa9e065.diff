[+++ b/android/guava-tests/test/com/google/common/base/SplitterTest.java, +    if (!CommonPattern.isPcreLike()) {, +    if (!CommonPattern.isPcreLike()) {, +++ b/android/guava-tests/test/com/google/common/base/SplitterTest.java, +    if (!CommonPattern.isPcreLike()) {, +    if (!CommonPattern.isPcreLike()) {, +++ b/android/guava/src/com/google/common/base/CommonPattern.java, +  public static CommonPattern compile(String pattern) {, +, +  public static boolean isPcreLike() {, +    return Platform.patternCompilerIsPcreLike();, +  }, +++ b/android/guava-tests/test/com/google/common/base/SplitterTest.java, +    if (!CommonPattern.isPcreLike()) {, +    if (!CommonPattern.isPcreLike()) {, +++ b/android/guava/src/com/google/common/base/CommonPattern.java, +  public static CommonPattern compile(String pattern) {, +, +  public static boolean isPcreLike() {, +    return Platform.patternCompilerIsPcreLike();, +  }, +++ b/android/guava/src/com/google/common/base/PatternCompiler.java, +, +  /**, +   * Returns {@code true} if the regex implementation behaves like Perl -- notably, by supporting, +   * possessive quantifiers but also being susceptible to catastrophic backtracking., +   */, +  boolean isPcreLike();, +++ b/android/guava-tests/test/com/google/common/base/SplitterTest.java, +    if (!CommonPattern.isPcreLike()) {, +    if (!CommonPattern.isPcreLike()) {, +++ b/android/guava/src/com/google/common/base/CommonPattern.java, +  public static CommonPattern compile(String pattern) {, +, +  public static boolean isPcreLike() {, +    return Platform.patternCompilerIsPcreLike();, +  }, +++ b/android/guava/src/com/google/common/base/PatternCompiler.java, +, +  /**, +   * Returns {@code true} if the regex implementation behaves like Perl -- notably, by supporting, +   * possessive quantifiers but also being susceptible to catastrophic backtracking., +   */, +  boolean isPcreLike();, +++ b/android/guava/src/com/google/common/base/Platform.java, +  static boolean patternCompilerIsPcreLike() {, +    return patternCompiler.isPcreLike();, +, +    @Override, +    public boolean isPcreLike() {, +      return true;, +    }, +++ b/android/guava-tests/test/com/google/common/base/SplitterTest.java, +    if (!CommonPattern.isPcreLike()) {, +    if (!CommonPattern.isPcreLike()) {, +++ b/android/guava/src/com/google/common/base/CommonPattern.java, +  public static CommonPattern compile(String pattern) {, +, +  public static boolean isPcreLike() {, +    return Platform.patternCompilerIsPcreLike();, +  }, +++ b/android/guava/src/com/google/common/base/PatternCompiler.java, +, +  /**, +   * Returns {@code true} if the regex implementation behaves like Perl -- notably, by supporting, +   * possessive quantifiers but also being susceptible to catastrophic backtracking., +   */, +  boolean isPcreLike();, +++ b/android/guava/src/com/google/common/base/Platform.java, +  static boolean patternCompilerIsPcreLike() {, +    return patternCompiler.isPcreLike();, +, +    @Override, +    public boolean isPcreLike() {, +      return true;, +    }, +++ b/android/guava/src/com/google/common/primitives/Doubles.java, +  static final, +  java.util.regex.Pattern, +      FLOATING_POINT_PATTERN = fpPattern();, +  private static, +  java.util.regex.Pattern, +      fpPattern() {, +    /*, +     * We use # instead of * for possessive quantifiers. This lets us strip them out when building, +     * the regex for RE2 (which doesn't support them) but leave them in when building it for, +     * java.util.regex (where we want them in order to avoid catastrophic backtracking)., +     */, +    String decimal = "(?:\\d+#(?:\\.\\d*#)?|\\.\\d+#)";, +    String completeDec = decimal + "(?:[eE][+-]?\\d+#)?[fFdD]?";, +    String hex = "(?:[0-9a-fA-F]+#(?:\\.[0-9a-fA-F]*#)?|\\.[0-9a-fA-F]+#)";, +    String completeHex = "0[xX]" + hex + "[pP][+-]?\\d+#[fFdD]?";, +    fpPattern =, +        fpPattern.replace(, +            "#",, +            "+", +            );, +    return, +    java.util.regex.Pattern, +        .compile(fpPattern);]