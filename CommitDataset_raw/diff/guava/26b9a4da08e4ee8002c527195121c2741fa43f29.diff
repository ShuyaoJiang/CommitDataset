[+++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +  public <A extends Interface1 & Interface2 & Interface3<String>>, +  void testGetTypes_manyBounds() {, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<A>() {}.capture()).getTypes();, +    ASSERT.that(types.rawTypes()).hasContentsAnyOrder(, +        Interface1.class, Interface2.class, Interface3.class, Iterable.class);, +  }, +, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +  public <A extends Interface1 & Interface2 & Interface3<String>>, +  void testGetTypes_manyBounds() {, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<A>() {}.capture()).getTypes();, +    ASSERT.that(types.rawTypes()).hasContentsAnyOrder(, +        Interface1.class, Interface2.class, Interface3.class, Iterable.class);, +  }, +, +++ b/guava/src/com/google/common/collect/SortedIterables.java, +      /*, +       * We assume that the comparator is consistent with equals (or rather, consistent with, +       * whatever |elements| uses for equality). Thus, we don't need to deduplicate., +       */, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +  public <A extends Interface1 & Interface2 & Interface3<String>>, +  void testGetTypes_manyBounds() {, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<A>() {}.capture()).getTypes();, +    ASSERT.that(types.rawTypes()).hasContentsAnyOrder(, +        Interface1.class, Interface2.class, Interface3.class, Iterable.class);, +  }, +, +++ b/guava/src/com/google/common/collect/SortedIterables.java, +      /*, +       * We assume that the comparator is consistent with equals (or rather, consistent with, +       * whatever |elements| uses for equality). Thus, we don't need to deduplicate., +       */, +++ b/guava/src/com/google/common/reflect/TypeToken.java, +            Iterables.filter(findAllTypes(), TypeFilter.IGNORE_TYPE_VARIABLE_OR_WILDCARD)));, +  private ImmutableList<TypeToken<? super T>> findAllTypes() {, +  private static <K, V> ImmutableList<K> sortKeysByValue(, +    Ordering<K> keyOrdering = new Ordering<K>() {, +    return keyOrdering.immutableSortedCopy(map.keySet());]