[+++ b/guava/src/com/google/common/collect/BstInOrderPath.java, +  private final BstSide sideExtension;, +  private BstInOrderPath(, +      N tip, @Nullable BstSide sideExtension, @Nullable BstInOrderPath<N> tail) {, +    this.sideExtension = sideExtension;, +    assert (sideExtension == null) == (tail == null);, +  private Optional<BstInOrderPath<N>> computeNextInOrder(BstSide side) {, +    if (getTip().hasChild(side)) {, +      BstInOrderPath<N> path = extension(this, side);, +      BstSide otherSide = side.other();, +      while (path.getTip().hasChild(otherSide)) {, +        path = extension(path, otherSide);, +      while (current.sideExtension == side) {, +  private Optional<BstInOrderPath<N>> nextInOrder(BstSide side) {, +    Optional<BstInOrderPath<N>> result;, +    switch (side) {, +      case LEFT:, +        result = prevInOrder;, +        return (result == null) ? prevInOrder = computeNextInOrder(side) : result;, +      case RIGHT:, +        result = nextInOrder;, +        return (result == null) ? nextInOrder = computeNextInOrder(side) : result;, +      default:, +        throw new AssertionError();, +   * Returns {@code true} if there is a next path in an in-order traversal in the given direction., +  public boolean hasNext(BstSide side) {, +    return nextInOrder(side).isPresent();, +   * Returns the next path in an in-order traversal in the given direction., +  public BstInOrderPath<N> next(BstSide side) {, +    if (!hasNext(side)) {, +    return nextInOrder(side).get();, +  public BstSide getSideOfExtension() {, +    return sideExtension;]