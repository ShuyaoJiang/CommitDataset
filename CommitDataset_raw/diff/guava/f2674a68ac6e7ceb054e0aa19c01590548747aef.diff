[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                if (value == null) {, +              entry = newEntry(key, hash, first);, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                if (value == null) {, +              entry = newEntry(key, hash, first);, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +  ReferenceEntry<K, V> newEntry(K key, int hash, ReferenceEntry<K, V> next) {, +    return entryFactory.newEntry(this, key, hash, next);, +  }, +, +  @GuardedBy("Segment.this"), +  @VisibleForTesting boolean isLive(ReferenceEntry<K, V> entry) {, +    return entry.getKey() != null && getLiveValue(entry) != null;, +   * Returns true if the entry has expired., +   * Returns true if the entry has expired., +  /**, +   * Returns true if the entry has been partially collected, meaning that either, +   * the key is null, or the value is null and it is not computing., +   */, +  boolean isCollected(ReferenceEntry<K, V> entry) {, +    if (entry.getKey() == null) {, +      return true;, +    }, +    ValueReference<K, V> valueReference = entry.getValueReference();, +    if (valueReference.isComputingReference()) {, +      return false;, +    }, +    return valueReference.get() == null;, +  }, +, +    ReferenceEntry<K, V> notifyEntry = newEntry(key, hash, null);, +    ReferenceEntry<K, V> notifyEntry = newEntry(key, hash, null);, +              unsetLiveEntry(e, hash);, +              recordRead(e);, +              return false;, +              unsetLiveEntry(e, hash);, +            if (entryValue == null) {, +              // Mimic, +              // "if (!map.containsKey(key)) ..., +              //  else return map.get(key);, +              recordRead(e);, +        ReferenceEntry<K, V> newEntry = newEntry(key, hash, first);, +              if (isCollected(e)) {, +            if (entryValue == null) {, +              unsetLiveEntry(e, hash);, +            } else {, +            if (entryValue == null) {, +              unsetLiveEntry(e, hash);, +            } else if (valueEquivalence.equivalent(value, entryValue)) {, +            return false;, +        if (isCollected(e)) {, +      if (valueReference.isComputingReference()) {, +        return false;, +      }, +, +      K key = entry.getKey();, +  /**, +   * Returns the entry for a given key. Note that the entry may not be live., +   * This is only used for testing., +   */, +  @VisibleForTesting ReferenceEntry<K, V> getEntry(Object key) {, +    int hash = hash(key);, +    return segmentFor(hash).getEntry(key, hash);, +  }, +]