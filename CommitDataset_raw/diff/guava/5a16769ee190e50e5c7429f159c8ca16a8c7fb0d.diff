[+++ b/guava/src/com/google/common/graph/Graph.java, +   * <p>If the graph is directed, {@code node1} is {@code edge}'s source,, +   * {@code node2} is {@code edge}'s target, and {@code edge} is an outgoing edge of, +++ b/guava/src/com/google/common/graph/Graph.java, +   * <p>If the graph is directed, {@code node1} is {@code edge}'s source,, +   * {@code node2} is {@code edge}'s target, and {@code edge} is an outgoing edge of, +++ b/guava/src/com/google/common/graph/Graphs.java, +import com.google.common.base.Function;, +import com.google.common.collect.Maps;, +   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and, +   * each edge has the same source and target in both graphs., +      @Nullable DirectedGraph<?, ?> graph1, @Nullable DirectedGraph<?, ?> graph2) {, +    if (graph1 == graph2) {, +    if (graph1 == null || graph2 == null) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.source(edge).equals(graph2.source(edge)), +          || !graph1.target(edge).equals(graph2.target(edge))) {, +   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and, +   * each edge has the same incident node set in both graphs., +  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {, +    if (graph1 == graph2) {, +    if (graph1 == null || graph2 == null) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {, +   * Returns a string representation of {@code graph}, encoding the direction of each edge., +   */, +  public static String toString(final DirectedGraph<?, ?> graph) {, +    Function<Object, String> edgeToEndpoints = new Function<Object, String>() {, +      @Override, +      public String apply(Object edge) {, +        return String.format("<%s -> %s>", graph.source(edge), graph.target(edge));, +      }, +    };, +    return String.format("config: %s, nodes: %s, edges: %s",, +        graph.config(),, +        graph.nodes(),, +        Maps.asMap(graph.edges(), edgeToEndpoints));, +  }, +, +  /**, +   * Returns a string representation of {@code graph}, without regard to direction of edges., +   */, +  public static String toString(final Graph<?, ?> graph) {, +    Function<Object, String> edgeToIncidentNodes = new Function<Object, String>() {, +      @Override, +      public String apply(Object edge) {, +        return graph.incidentNodes(edge).toString();, +      }, +    };, +    return String.format("config: %s, nodes: %s, edges: %s",, +        graph.config(),, +        graph.nodes(),, +        Maps.asMap(graph.edges(), edgeToIncidentNodes));, +  }, +, +  /**, +++ b/guava/src/com/google/common/graph/Graph.java, +   * <p>If the graph is directed, {@code node1} is {@code edge}'s source,, +   * {@code node2} is {@code edge}'s target, and {@code edge} is an outgoing edge of, +++ b/guava/src/com/google/common/graph/Graphs.java, +import com.google.common.base.Function;, +import com.google.common.collect.Maps;, +   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and, +   * each edge has the same source and target in both graphs., +      @Nullable DirectedGraph<?, ?> graph1, @Nullable DirectedGraph<?, ?> graph2) {, +    if (graph1 == graph2) {, +    if (graph1 == null || graph2 == null) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.source(edge).equals(graph2.source(edge)), +          || !graph1.target(edge).equals(graph2.target(edge))) {, +   * Returns true iff {@code graph1} and {@code graph2} have the same node and edge sets and, +   * each edge has the same incident node set in both graphs., +  public static boolean equal(@Nullable Graph<?, ?> graph1, @Nullable Graph<?, ?> graph2) {, +    if (graph1 == graph2) {, +    if (graph1 == null || graph2 == null) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {, +   * Returns a string representation of {@code graph}, encoding the direction of each edge., +   */, +  public static String toString(final DirectedGraph<?, ?> graph) {, +    Function<Object, String> edgeToEndpoints = new Function<Object, String>() {, +      @Override, +      public String apply(Object edge) {, +        return String.format("<%s -> %s>", graph.source(edge), graph.target(edge));, +      }, +    };, +    return String.format("config: %s, nodes: %s, edges: %s",, +        graph.config(),, +        graph.nodes(),, +        Maps.asMap(graph.edges(), edgeToEndpoints));, +  }, +, +  /**, +   * Returns a string representation of {@code graph}, without regard to direction of edges., +   */, +  public static String toString(final Graph<?, ?> graph) {]