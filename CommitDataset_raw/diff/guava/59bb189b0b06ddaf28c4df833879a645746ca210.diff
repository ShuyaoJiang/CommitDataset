[+++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +        builder.put(range1, 1).put(range2, 2);, +          ImmutableRangeMap<Integer, Integer> unused = builder.build();, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +        builder.put(range1, 1).put(range2, 2);, +          ImmutableRangeMap<Integer, Integer> unused = builder.build();, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java, +    subsets: for (Set<Range<Integer>> subset : Sets.powerSet(ranges)) {, +          ImmutableRangeSet<Integer> unused = builder.add(range).build();, +          continue subsets;, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +        builder.put(range1, 1).put(range2, 2);, +          ImmutableRangeMap<Integer, Integer> unused = builder.build();, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java, +    subsets: for (Set<Range<Integer>> subset : Sets.powerSet(ranges)) {, +          ImmutableRangeSet<Integer> unused = builder.add(range).build();, +          continue subsets;, +++ b/guava/src/com/google/common/collect/ImmutableRangeMap.java, +import java.util.Collections;, +import java.util.List;, +, +    private final List<Map.Entry<Range<K>, V>> entries;, +      this.entries = Lists.newArrayList();, +     * @throws IllegalArgumentException if {@code range} is empty, +      entries.add(Maps.immutableEntry(range, value));, +     *, +     * @throws IllegalArgumentException if any two ranges inserted into this builder overlap, +      Collections.sort(entries, Range.RANGE_LEX_ORDERING.onKeys());, +          new ImmutableList.Builder<Range<K>>(entries.size());, +      ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());, +      for (int i = 0; i < entries.size(); i++) {, +        Range<K> range = entries.get(i).getKey();, +        if (i > 0) {, +          Range<K> prevRange = entries.get(i - 1).getKey();, +          if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {, +            throw new IllegalArgumentException(, +                "Overlapping ranges: range " + prevRange + " overlaps with entry " + range);, +          }, +        }, +        rangesBuilder.add(range);, +        valuesBuilder.add(entries.get(i).getValue());, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeMapTest.java, +        builder.put(range1, 1).put(range2, 2);, +          ImmutableRangeMap<Integer, Integer> unused = builder.build();, +++ b/guava-tests/test/com/google/common/collect/ImmutableRangeSetTest.java, +    subsets: for (Set<Range<Integer>> subset : Sets.powerSet(ranges)) {, +          ImmutableRangeSet<Integer> unused = builder.add(range).build();, +          continue subsets;, +++ b/guava/src/com/google/common/collect/ImmutableRangeMap.java, +import java.util.Collections;, +import java.util.List;, +, +    private final List<Map.Entry<Range<K>, V>> entries;, +      this.entries = Lists.newArrayList();, +     * @throws IllegalArgumentException if {@code range} is empty, +      entries.add(Maps.immutableEntry(range, value));, +     *, +     * @throws IllegalArgumentException if any two ranges inserted into this builder overlap, +      Collections.sort(entries, Range.RANGE_LEX_ORDERING.onKeys());, +          new ImmutableList.Builder<Range<K>>(entries.size());, +      ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());, +      for (int i = 0; i < entries.size(); i++) {, +        Range<K> range = entries.get(i).getKey();, +        if (i > 0) {, +          Range<K> prevRange = entries.get(i - 1).getKey();, +          if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {, +            throw new IllegalArgumentException(, +                "Overlapping ranges: range " + prevRange + " overlaps with entry " + range);, +          }, +        }, +        rangesBuilder.add(range);, +        valuesBuilder.add(entries.get(i).getValue());, +++ b/guava/src/com/google/common/collect/ImmutableRangeSet.java, +import java.util.List;, +    private final List<Range<C>> ranges;, +      this.ranges = Lists.newArrayList();, +     * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,, +     * but overlapping ranges will cause an exception when {@link #build()} is called., +     * @throws IllegalArgumentException if {@code range} is empty, +      checkArgument(!range.isEmpty(), "range must not be empty, but was %s", range);, +      ranges.add(range);, +     * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted, +     * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is, +     * called., +     * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be, +     * merged, but overlapping ranges will cause an exception when {@link #build()} is called., +     * @throws IllegalArgumentException if any inserted ranges are empty, +     *, +     * @throws IllegalArgumentException if any input ranges have nonempty overlap, +      ImmutableList.Builder<Range<C>> mergedRangesBuilder =, +          new ImmutableList.Builder<Range<C>>(ranges.size());, +      Collections.sort(ranges, Range.RANGE_LEX_ORDERING);, +      PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());, +      while (peekingItr.hasNext()) {, +        Range<C> range = peekingItr.next();, +        while (peekingItr.hasNext()) {, +          Range<C> nextRange = peekingItr.peek();, +          if (range.isConnected(nextRange)) {, +            checkArgument(, +                range.intersection(nextRange).isEmpty(),]