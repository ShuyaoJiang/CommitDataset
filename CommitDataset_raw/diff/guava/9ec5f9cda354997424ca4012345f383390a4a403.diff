[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractExecutionThreadServiceTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +import com.google.common.util.concurrent.testing.TestingExecutors;, +import java.util.concurrent.ScheduledExecutorService;, +  public void testTimeout() {, +    // Create a service whose executor will never run its commands, +    Service service = new AbstractExecutionThreadService() {, +      @Override protected void run() throws Exception {}, +, +      @Override protected ScheduledExecutorService executor() {, +        return TestingExecutors.noOpScheduledExecutor();, +      }, +, +      @Override protected String serviceName() {, +        return "Foo";, +      }, +    };, +    try {, +      service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);, +      fail("Expected timeout");, +    } catch (TimeoutException e) {, +      assertThat(e.getMessage()), +          .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractExecutionThreadServiceTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +import com.google.common.util.concurrent.testing.TestingExecutors;, +import java.util.concurrent.ScheduledExecutorService;, +  public void testTimeout() {, +    // Create a service whose executor will never run its commands, +    Service service = new AbstractExecutionThreadService() {, +      @Override protected void run() throws Exception {}, +, +      @Override protected ScheduledExecutorService executor() {, +        return TestingExecutors.noOpScheduledExecutor();, +      }, +, +      @Override protected String serviceName() {, +        return "Foo";, +      }, +    };, +    try {, +      service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);, +      fail("Expected timeout");, +    } catch (TimeoutException e) {, +      assertThat(e.getMessage()), +          .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractIdleServiceTest.java, +, +      @Override protected String serviceName() {, +        return "Foo";, +      }, +      assertThat(e.getMessage()), +          .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractExecutionThreadServiceTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +import com.google.common.util.concurrent.testing.TestingExecutors;, +import java.util.concurrent.ScheduledExecutorService;, +  public void testTimeout() {, +    // Create a service whose executor will never run its commands, +    Service service = new AbstractExecutionThreadService() {, +      @Override protected void run() throws Exception {}, +, +      @Override protected ScheduledExecutorService executor() {, +        return TestingExecutors.noOpScheduledExecutor();, +      }, +, +      @Override protected String serviceName() {, +        return "Foo";, +      }, +    };, +    try {, +      service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);, +      fail("Expected timeout");, +    } catch (TimeoutException e) {, +      assertThat(e.getMessage()), +          .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractIdleServiceTest.java, +, +      @Override protected String serviceName() {, +        return "Foo";, +      }, +      assertThat(e.getMessage()), +          .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +import static com.google.common.truth.Truth.assertThat;, +import com.google.common.util.concurrent.testing.TestingExecutors;, +  public void testTimeout() {, +    // Create a service whose executor will never run its commands]