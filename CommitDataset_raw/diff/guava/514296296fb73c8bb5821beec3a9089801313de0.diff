[+++ b/guava/src/com/google/common/reflect/TypeResolver.java, +import com.google.common.annotations.Beta;, + * <p>Note that usually type mappings are already implied by the static type hierarchy (for example,, + * the {@code E} type variable declared by class {@code List} naturally maps to {@code String} in, + * the context of {@code class MyStringList implements List<String>}. In such case, prefer to use, + * {@link TypeToken#resolveType} since it's simpler and more type safe. This class should only be, + * used when the type mapping isn't implied by the static type hierarchy, but provided through other, + * means such as an annotation or external configuration file., + * @since 14.0, +@Beta, +public class TypeResolver {, +  static TypeResolver accordingTo(Type type) {, +    return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(type));, +  }, +, +  /**, +   * Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in, +   * {@code actual}., +   *, +   * <p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code, +   * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain, +   * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve, +   * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and, +   * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they, +   * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination, +   * thereof., +   *, +   * @param formal The type whose type variables or itself is mapped to other type(s). It's almost, +   *        always a bug if {@code formal} isn't a type variable and contains no type variable. Make, +   *        sure you are passing the two parameters in the right order., +   * @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet, +   *        other type variables, in which case these type variables will be further resolved if, +   *        corresponding mappings exist in the current {@code TypeResolver} instance., +   */, +  public final TypeResolver where(Type formal, Type actual) {, +    Map<TypeVariable<?>, Type> mappings = Maps.newHashMap();, +    populateTypeMappings(mappings, formal, actual);, +    return where(mappings);, +  }, +, +  public final Type resolveType(Type type) {]