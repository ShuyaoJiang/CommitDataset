[+++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().setKeyStrength(keyStrength).keyEquivalence(Equivalence.identity()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().setKeyStrength(keyStrength).keyEquivalence(Equivalence.equals()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().keyEquivalence(Equivalence.identity()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().setKeyStrength(keyStrength).keyEquivalence(Equivalence.identity()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().setKeyStrength(keyStrength).keyEquivalence(Equivalence.equals()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();, +    multiset = ConcurrentHashMultiset.create(map);, +    ConcurrentMap<String, AtomicInteger> map =, +        new MapMaker().keyEquivalence(Equivalence.identity()).makeMap();, +    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);, +++ b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java, +   * Creates a new, empty {@code ConcurrentHashMultiset} using {@code mapMaker} to construct the, +   * internal backing map., +   * multiset do not count as map updates at all, since we're usually just mutating the value stored, +   * in the map, so {@link MapMaker#expireAfterAccess} makes sense (evict the entry that was queried, +   * or updated longest ago), but {@link MapMaker#expireAfterWrite} doesn't, because the eviction, +   * time is measured from when we saw the first occurrence of the object., +   * <p>The returned multiset is serializable but any serialization caveats given in {@code, +   * MapMaker} apply., +   * @deprecated Use {@link #create(ConcurrentMap)} instead. This method is scheduled for deletion, +   *     in October 2016., +  @Deprecated, +    return create(mapMaker.<E, AtomicInteger>makeMap());, +   * Creates a new, empty {@code ConcurrentHashMultiset} using {@code countMap} as the internal, +   * backing map., +   * <p>This instance will assume ownership of {@code countMap}, and other code should not maintain, +   * references to the map or modify it in any way., +   * <p>The returned multiset is serializable if the input map is., +   *, +   * @param countMap backing map for storing the elements in the multiset and their counts. It must, +   *     be empty., +   * @since 20.0, +  @Beta, +  public static <E> ConcurrentHashMultiset<E> create(ConcurrentMap<E, AtomicInteger> countMap) {, +    return new ConcurrentHashMultiset<E>(countMap);, +  }, +, +    checkArgument(countMap.isEmpty(), "the backing map (%s) must be empty", countMap);]