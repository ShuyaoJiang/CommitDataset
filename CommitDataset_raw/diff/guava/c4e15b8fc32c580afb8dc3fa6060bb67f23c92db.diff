[+++ b/guava/src/com/google/common/collect/ComputingCache.java, +    return map.getOrCompute(key);, +++ b/guava/src/com/google/common/collect/ComputingCache.java, +    return map.getOrCompute(key);, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +  V getOrCompute(K key) throws ExecutionException {, +    return segmentFor(hash).getOrCompute(key, hash, loader);, +    V getOrCompute(K key, int hash, CacheLoader<? super K, ? extends V> loader), +              return compute(key, hash, e, computingValueReference);, +            }, +          }, +          // The entry already exists. Wait for the computation., +          checkState(!Thread.holdsLock(e), "Recursive computation");, +          // don't consider expiration as we're concurrent with computation, +          V value = e.getValueReference().waitForValue();, +          if (value != null) {, +            recordRead(e);, +            statsCounter.recordConcurrentMiss();, +            return value;, +          }, +          // else computing thread will clearValue, +          continue outer;, +        }, +      } finally {, +        postReadCleanup();, +      }, +    }, +, +    V compute(K key, int hash, ReferenceEntry<K, V> e,, +        ComputingValueReference<K, V> computingValueReference), +        throws ExecutionException {, +        value = getOrCompute((K) key);]