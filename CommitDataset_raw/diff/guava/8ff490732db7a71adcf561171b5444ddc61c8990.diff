[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java, +    boolean empty =, +        effectiveRange.isEmpty(), +                    range.upperBound.greatestValueBelow(domain)), +                > 0;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java, +    boolean empty =, +        effectiveRange.isEmpty(), +                    range.upperBound.greatestValueBelow(domain)), +                > 0;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java, +    boolean empty =, +        effectiveRange.isEmpty(), +                    range.upperBound.greatestValueBelow(domain)), +                > 0;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +  public static <K, V> LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {, +        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));, +, +, +  private static <K, V> void succeedsInMultimap(ValueEntry<K, V> pred, ValueEntry<K, V> succ) {, +  static final class ValueEntry<K, V> extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {, +    ValueEntry(, +        @Nullable K key,, +        @Nullable V value,, +        int smearedValueHash,, +  @Override, +  public Set<Map.Entry<K, V>> entries() {, +  @Override, +  public Collection<V> values() {, +      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];, +          entry != null;, +      for (ValueEntry<K, V> entry = rowHead; entry != null; entry = entry.nextInValueBucket) {, +            entry != this;, +            entry = entry.getSuccessorInValueSet()) {, +      for (ValueEntry<K, V> entry = hashTable[bucket];, +          entry != null;, +          entry != this;, +          entry = entry.getSuccessorInValueSet()) {, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java, +    boolean empty =, +        effectiveRange.isEmpty(), +                    range.upperBound.greatestValueBelow(domain)), +                > 0;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +  public static <K, V> LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {, +        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));, +, +, +  private static <K, V> void succeedsInMultimap(ValueEntry<K, V> pred, ValueEntry<K, V> succ) {, +  static final class ValueEntry<K, V> extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {, +    ValueEntry(, +        @Nullable K key,, +        @Nullable V value,, +        int smearedValueHash,, +  @Override, +  public Set<Map.Entry<K, V>> entries() {, +  @Override, +  public Collection<V> values() {, +      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];, +          entry != null;, +      for (ValueEntry<K, V> entry = rowHead; entry != null; entry = entry.nextInValueBucket) {, +            entry != this;, +            entry = entry.getSuccessorInValueSet()) {, +      for (ValueEntry<K, V> entry = hashTable[bucket];, +          entry != null;, +          entry != this;, +          entry = entry.getSuccessorInValueSet()) {, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultiset.java, +  public static <E> LinkedHashMultiset<E> create(Iterable<? extends E> elements) {, +    LinkedHashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java, +    boolean empty =, +        effectiveRange.isEmpty(), +                    range.upperBound.greatestValueBelow(domain)), +                > 0;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +  public static <K, V> LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {, +        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));, +, +, +  private static <K, V> void succeedsInMultimap(ValueEntry<K, V> pred, ValueEntry<K, V> succ) {, +  static final class ValueEntry<K, V> extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {, +    ValueEntry(, +        @Nullable K key,, +        @Nullable V value,, +        int smearedValueHash,, +  @Override, +  public Set<Map.Entry<K, V>> entries() {, +  @Override, +  public Collection<V> values() {, +      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];]