[+++ b/guava-tests/test/com/google/common/collect/RegularImmutableTableTest.java, +      new SparseImmutableTable<Character, Integer, String>(CELLS.asList(), ROW_SPACE,, +      new DenseImmutableTable<Character, Integer, String>(CELLS.asList(), ROW_SPACE,, +++ b/guava-tests/test/com/google/common/collect/RegularImmutableTableTest.java, +      new SparseImmutableTable<Character, Integer, String>(CELLS.asList(), ROW_SPACE,, +      new DenseImmutableTable<Character, Integer, String>(CELLS.asList(), ROW_SPACE,, +++ b/guava/src/com/google/common/collect/RegularImmutableTable.java, +import java.util.LinkedHashMap;, +  private RegularImmutableTable() {}, +  private transient ImmutableCollection<V> values;, +    ImmutableCollection<V> result = values;, +    return (result == null) ? values = createValues() : result;, +  abstract ImmutableCollection<V> createValues();, +, +  @Override public abstract int size();, +  private transient ImmutableSet<Cell<R, C, V>> cellSet;, +, +  @Override, +  public final ImmutableSet<Cell<R, C, V>> cellSet() {, +    ImmutableSet<Cell<R, C, V>> result = cellSet;, +    return (result == null) ? cellSet = createCellSet() : result;, +  }, +  , +  abstract ImmutableSet<Cell<R, C, V>> createCellSet();, +  , +  abstract class CellSet extends ImmutableSet<Cell<R, C, V>> {, +    @Override, +    public int size() {, +      return RegularImmutableTable.this.size();, +    }, +, +    @Override, +    public boolean contains(@Nullable Object object) {, +      if (object instanceof Cell) {, +        Cell<?, ?, ?> cell = (Cell<?, ?, ?>) object;, +        Object value = get(cell.getRowKey(), cell.getColumnKey());, +        return value != null && value.equals(cell.getValue());, +      }, +    @Override, +    boolean isPartialView() {, +      return false;, +    }, +  }, +, +  @Override public final boolean isEmpty() {, +    return false;, +    ImmutableList<Cell<R, C, V>> cellList = ImmutableList.copyOf(cells);, +    for (Cell<R, C, V> cell : cellList) {, +    return (cellList.size() > ((rowSpace.size() * columnSpace.size()) / 2)) ?, +        new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace) :, +        new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);, +    private final int[] iterationOrderRow;, +    private final int[] iterationOrderColumn;, +    SparseImmutableTable(ImmutableList<Cell<R, C, V>> cellList,, +      Map<R, Integer> rowIndex = Maps.newHashMap();, +      Map<R, Map<C, V>> rows = Maps.newLinkedHashMap();, +      for (R row : rowSpace) {, +        rowIndex.put(row, rows.size());, +        rows.put(row, new LinkedHashMap<C, V>());, +      }, +      Map<C, Map<R, V>> columns = Maps.newLinkedHashMap();, +      for (C col : columnSpace) {, +        columns.put(col, new LinkedHashMap<R, V>());, +      }, +      int[] iterationOrderRow = new int[cellList.size()];, +      int[] iterationOrderColumn = new int[cellList.size()];, +      for (int i = 0; i < cellList.size(); i++) {, +        Cell<R, C, V> cell = cellList.get(i);, +        , +        iterationOrderRow[i] = rowIndex.get(rowKey);, +        Map<C, V> thisRow = rows.get(rowKey);, +        iterationOrderColumn[i] = thisRow.size();, +        V oldValue = thisRow.put(columnKey, value);, +        if (oldValue != null) {, +          throw new IllegalArgumentException("Duplicate value for row=" + rowKey + ", column=", +              + columnKey + ": " + value + ", " + oldValue);, +        columns.get(columnKey).put(rowKey, value);, +      }, +      this.iterationOrderRow = iterationOrderRow;, +      this.iterationOrderColumn = iterationOrderColumn;, +      ImmutableMap.Builder<R, Map<C, V>> rowBuilder = ImmutableMap.builder();, +      for (Map.Entry<R, Map<C, V>> row : rows.entrySet()) {, +        rowBuilder.put(row.getKey(), ImmutableMap.copyOf(row.getValue()));, +      }, +      this.rowMap = rowBuilder.build();, +      , +      ImmutableMap.Builder<C, Map<R, V>> columnBuilder = ImmutableMap.builder();, +      for (Map.Entry<C, Map<R, V>> col : columns.entrySet()) {, +        columnBuilder.put(col.getKey(), ImmutableMap.copyOf(col.getValue()));, +      }, +      this.columnMap = columnBuilder.build();, +, +    @Override, +    ImmutableCollection<V> createValues() {, +      return new ImmutableList<V>() {, +        @Override, +        public int size() {, +          return iterationOrderRow.length;, +        }, +]