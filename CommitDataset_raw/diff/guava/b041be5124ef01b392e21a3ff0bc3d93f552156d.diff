[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Multimaps.java, +import com.google.common.base.Objects;, +import com.google.common.base.Predicate;, +import com.google.common.base.Predicates;, +, +  /**, +   * Support removal operations when filtering a filtered multimap. Since a, +   * filtered multimap has iterators that don't support remove, passing one to, +   * the FilteredMultimap constructor would lead to a multimap whose removal, +   * operations would fail. This method combines the predicates to avoid that, +   * problem., +   */, +  private static <K, V> Multimap<K, V> filterFiltered(FilteredMultimap<K, V> map,, +      Predicate<? super Entry<K, V>> entryPredicate) {, +    Predicate<Entry<K, V>> predicate, +        = Predicates.and(map.predicate, entryPredicate);, +    return new FilteredMultimap<K, V>(map.unfiltered, predicate);, +  }, +, +  private static class FilteredMultimap<K, V> implements Multimap<K, V> {, +    final Multimap<K, V> unfiltered;, +    final Predicate<? super Entry<K, V>> predicate;, +, +    FilteredMultimap(Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {, +      this.unfiltered = unfiltered;, +      this.predicate = predicate;, +    }, +, +    @Override public int size() {, +      return entries().size();, +    }, +, +    @Override public boolean isEmpty() {, +      return entries().isEmpty();, +    }, +, +    @Override public boolean containsKey(Object key) {, +      return asMap().containsKey(key);, +    }, +, +    @Override public boolean containsValue(Object value) {, +      return values().contains(value);, +    }, +, +    // This method should be called only when key is a K and value is a V., +    @SuppressWarnings("unchecked"), +    boolean satisfiesPredicate(Object key, Object value) {, +      return predicate.apply(Maps.immutableEntry((K) key, (V) value));, +    }, +, +    @Override public boolean containsEntry(Object key, Object value) {, +      return unfiltered.containsEntry(key, value) && satisfiesPredicate(key, value);, +    }, +, +    @Override public boolean put(K key, V value) {, +      checkArgument(satisfiesPredicate(key, value));, +      return unfiltered.put(key, value);, +    }, +, +    @Override public boolean remove(Object key, Object value) {, +      return containsEntry(key, value) ? unfiltered.remove(key, value) : false;, +    }, +, +    @Override public boolean putAll(K key, Iterable<? extends V> values) {, +      for (V value : values) {, +        checkArgument(satisfiesPredicate(key, value));, +      }, +      return unfiltered.putAll(key, values);, +    }, +, +    @Override public boolean putAll(Multimap<? extends K, ? extends V> multimap) {, +      for (Entry<? extends K, ? extends V> entry : multimap.entries()) {, +        checkArgument(satisfiesPredicate(entry.getKey(), entry.getValue()));, +      }, +      return unfiltered.putAll(multimap);, +    }, +, +    @Override public Collection<V> replaceValues(K key, Iterable<? extends V> values) {, +      for (V value : values) {, +        checkArgument(satisfiesPredicate(key, value));, +      }, +      // Not calling unfiltered.replaceValues() since values that don't satisify, +      // the filter should remain in the multimap., +      Collection<V> oldValues = removeAll(key);, +      unfiltered.putAll(key, values);, +      return oldValues;, +    }, +, +    @Override public Collection<V> removeAll(Object key) {, +      List<V> removed = Lists.newArrayList();, +      Collection<V> values = unfiltered.asMap().get(key);, +      if (values != null) {, +        Iterator<V> iterator = values.iterator();, +        while (iterator.hasNext()) {, +          V value = iterator.next();, +          if (satisfiesPredicate(key, value)) {, +            removed.add(value);, +            iterator.remove();, +          }, +        }]