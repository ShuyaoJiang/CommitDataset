[+++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +, +++ b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +, +++ b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  @GwtIncompatible // threads, +, +  public void testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction(), +      throws InterruptedException {, +    final AtomicBoolean functionCalled = new AtomicBoolean();, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override, +      public ListenableFuture<Integer> apply(String input) throws Exception {, +        functionCalled.set(true);, +        return Futures.immediateFuture(1);, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ExecutorService executor = newSingleThreadExecutor();, +    ListenableFuture<Integer> future = Futures.transformAsync(, +        inputFuture, function, executor);, +, +    // Pause the executor., +    final CountDownLatch beforeFunction = new CountDownLatch(1);, +    executor.submit(new Runnable() {, +      @Override, +      public void run() {, +        awaitUninterruptibly(beforeFunction);, +      }, +    });, +, +    // Cancel the future after making input available., +    inputFuture.set("value");, +    future.cancel(false);, +, +    // Unpause the executor., +    beforeFunction.countDown();, +    executor.awaitTermination(5, TimeUnit.SECONDS);, +, +    assertFalse(functionCalled.get());, +  }, +, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +, +++ b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  @GwtIncompatible // threads, +, +  public void testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction(), +      throws InterruptedException {, +    final AtomicBoolean functionCalled = new AtomicBoolean();, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override, +      public ListenableFuture<Integer> apply(String input) throws Exception {, +        functionCalled.set(true);, +        return Futures.immediateFuture(1);, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ExecutorService executor = newSingleThreadExecutor();, +    ListenableFuture<Integer> future = Futures.transformAsync(, +        inputFuture, function, executor);, +, +    // Pause the executor., +    final CountDownLatch beforeFunction = new CountDownLatch(1);, +    executor.submit(new Runnable() {, +      @Override, +      public void run() {, +        awaitUninterruptibly(beforeFunction);, +      }, +    });, +, +    // Cancel the future after making input available., +    inputFuture.set("value");, +    future.cancel(false);, +, +    // Unpause the executor., +    beforeFunction.countDown();, +    executor.awaitTermination(5, TimeUnit.SECONDS);, +, +    assertFalse(functionCalled.get());, +  }, +, +++ /dev/null, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +, +++ b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  @GwtIncompatible // threads, +]