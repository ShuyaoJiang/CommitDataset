[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ArrayTable.java, +public final class ArrayTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {, +    super.putAll(table);, +    return super.cellSet();, +  @Override, +  Iterator<Cell<R, C, V>> cellIterator() {, +    return super.values();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ArrayTable.java, +public final class ArrayTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {, +    super.putAll(table);, +    return super.cellSet();, +  @Override, +  Iterator<Cell<R, C, V>> cellIterator() {, +    return super.values();, +++ b/guava/src/com/google/common/collect/AbstractTable.java, +/*, + * Copyright (C) 2013 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package com.google.common.collect;, +, +import com.google.common.annotations.GwtCompatible;, +, +import java.util.AbstractCollection;, +import java.util.AbstractSet;, +import java.util.Collection;, +import java.util.Iterator;, +import java.util.Map;, +import java.util.Set;, +, +import javax.annotation.Nullable;, +, +/**, + * Skeletal, implementation-agnostic implementation of the {@link Table} interface., + * , + * @author Louis Wasserman, + */, +@GwtCompatible, +abstract class AbstractTable<R, C, V> implements Table<R, C, V> {, +, +  @Override, +  public boolean containsRow(@Nullable Object rowKey) {, +    return Maps.safeContainsKey(rowMap(), rowKey);, +  }, +, +  @Override, +  public boolean containsColumn(@Nullable Object columnKey) {, +    return Maps.safeContainsKey(columnMap(), columnKey);, +  }, +, +  @Override, +  public Set<R> rowKeySet() {, +    return rowMap().keySet();, +  }, +, +  @Override, +  public Set<C> columnKeySet() {, +    return columnMap().keySet();, +  }, +, +  @Override, +  public boolean containsValue(@Nullable Object value) {, +    for (Map<C, V> row : rowMap().values()) {, +      if (row.containsValue(value)) {, +        return true;, +      }, +    }, +    return false;, +  }, +, +  @Override, +  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {, +    Map<C, V> row = Maps.safeGet(rowMap(), rowKey);, +    return row != null && Maps.safeContainsKey(row, columnKey);, +  }, +, +  @Override, +  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {, +    Map<C, V> row = Maps.safeGet(rowMap(), rowKey);, +    return (row == null) ? null : Maps.safeGet(row, columnKey);, +  }, +, +  @Override, +  public boolean isEmpty() {, +    return size() == 0;, +  }, +, +  @Override, +  public void clear() {, +    Iterators.clear(cellSet().iterator());]