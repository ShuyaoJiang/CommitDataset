[+++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, +   * See {@link MapMaker#expireAfterWrite}., +   *, +   * @since 8, +  @Beta, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, +   * See {@link MapMaker#expireAfterWrite}., +   *, +   * @since 8, +  @Beta, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java, +    return expireAfterWrite(duration, unit);, +  public MapMaker expireAfterWrite(long duration, TimeUnit unit) {, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, +   * See {@link MapMaker#expireAfterWrite}., +   *, +   * @since 8, +  @Beta, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java, +    return expireAfterWrite(duration, unit);, +  public MapMaker expireAfterWrite(long duration, TimeUnit unit) {, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +            if (expires()) {, +      if (evictsBySize() || expires()) {, +  private static final long serialVersionUID = 2;, +        keyEquivalence, valueEquivalence, expireAfterWriteNanos,, +        expireAfterAccessNanos, maximumSize, concurrencyLevel, evictionListener,, +        this, computingFunction);, +        long expireAfterAccessNanos,, +          expireAfterWriteNanos, expireAfterAccessNanos, maximumSize,, +          concurrencyLevel, evictionListener, delegate);, +    private static final long serialVersionUID = 2;, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, +   * See {@link MapMaker#expireAfterWrite}., +   *, +   * @since 8, +  @Beta, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java, +    return expireAfterWrite(duration, unit);, +  public MapMaker expireAfterWrite(long duration, TimeUnit unit) {, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +            if (expires()) {, +      if (evictsBySize() || expires()) {, +  private static final long serialVersionUID = 2;, +        keyEquivalence, valueEquivalence, expireAfterWriteNanos,, +        expireAfterAccessNanos, maximumSize, concurrencyLevel, evictionListener,, +        this, computingFunction);, +        long expireAfterAccessNanos,, +          expireAfterWriteNanos, expireAfterAccessNanos, maximumSize,, +          concurrencyLevel, evictionListener, delegate);, +    private static final long serialVersionUID = 2;, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +  final long expireAfterAccessNanos;, +    expireAfterAccessNanos = builder.getExpireAfterAccessNanos();, +    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();, +        EntryFactory.getFactory(keyStrength, expires(), evictsBySize);, +  boolean expires() {, +    return expiresAfterWrite() || expiresAfterAccess();, +  }, +, +  boolean expiresAfterAccess() {, +    return expireAfterAccessNanos > 0;, +    return (expires() && isExpired(e)) ? null : value;, +      if (evictsBySize() || expires()) {, +      if (evictsBySize() || expires()) {, +      if (expiresAfterAccess()) {, +        recordExpirationTime((Expirable) entry, expireAfterAccessNanos);, +      }, +        // currently MapMaker ensures that expireAfterWrite and, +        // expireAfterAccess are mutually exclusive, +        long expiration = expiresAfterAccess(), +            ? expireAfterAccessNanos : expireAfterWriteNanos;, +        Expirable expirable = (Expirable) entry;, +        recordExpirationTime(expirable, expiration);, +        addExpirable(expirable);, +            addExpirable(expirable);, +    void addExpirable(Expirable expirable) {, +    void recordExpirationTime(Expirable expirable, long expirationNanos) {, +      // might overflow, but that's okay (see isExpired()), +      expirable.setExpirationTime(System.nanoTime() + expirationNanos);, +    }, +, +            if (expires() && isExpired(e)) {, +            if (evictsBySize() || expiresAfterAccess()) {, +        if (expires()) {, +              if (evictsBySize() || expires()) {, +        if (expires()) {, +        if (expires()) {, +              if (evictsBySize() || expires()) {, +        if (expires()) {, +      if (expires()) {, +    return segmentFor(hash).remove(key, hash, expires());, +  private static final long serialVersionUID = 4;, +        keyEquivalence, valueEquivalence, expireAfterWriteNanos,, +        expireAfterAccessNanos, maximumSize, concurrencyLevel, evictionListener,, +        this);]