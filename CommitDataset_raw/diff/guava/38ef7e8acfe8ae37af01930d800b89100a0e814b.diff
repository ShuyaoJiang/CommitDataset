[+++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java, +    for (int maxSize = 1; maxSize < 100; maxSize++) {, +    assertTrue("segments=" + map.segments.length + ", maxSize=" + maxSize,, +        map.segments.length <= Math.max(1, maxSize / 10));, +    assertTrue("segments=" + map.segments.length + ", maxSize=" + maxSize,, +        map.segments.length <= Math.max(1, maxSize / 10));, +++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java, +    for (int maxSize = 1; maxSize < 100; maxSize++) {, +    assertTrue("segments=" + map.segments.length + ", maxSize=" + maxSize,, +        map.segments.length <= Math.max(1, maxSize / 10));, +    assertTrue("segments=" + map.segments.length + ", maxSize=" + maxSize,, +        map.segments.length <= Math.max(1, maxSize / 10));, +++ b/guava/src/com/google/common/cache/LocalCache.java, +    // Find the lowest power-of-two segmentCount that exceeds concurrencyLevel, unless, +    // maximumSize/Weight is specified in which case ensure that each segment gets at least 10, +    // entries. The special casing for size-based eviction is only necessary because that eviction, +    // happens per segment instead of globally, so too many segments compared to the maximum size, +    // will result in random eviction behavior., +           && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {]