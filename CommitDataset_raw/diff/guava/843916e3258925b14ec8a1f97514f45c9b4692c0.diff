[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +  /**, +   * This tests for a bug where if {@link Service#stop()} was called while the service was, +   * {@link State#STARTING} more than once, the {@link Listener#stopping(State)} callback would get, +   * called multiple times., +   */, +  public void testManualServiceStopMultipleTimesWhileStarting() throws Exception {, +    ManualSwitchedService service = new ManualSwitchedService();, +    final AtomicInteger stopppingCount = new AtomicInteger();, +    service.addListener(new Listener() {, +      @Override public void starting() {}, +      @Override public void running() {}, +      @Override public void stopping(State from) {, +        stopppingCount.incrementAndGet();, +      }, +      @Override public void terminated(State from) {}, +      @Override public void failed(State from, Throwable failure) {}, +      }, MoreExecutors.sameThreadExecutor());, +, +    service.start();, +    service.stop();, +    assertEquals(1, stopppingCount.get());, +    service.stop();, +    assertEquals(1, stopppingCount.get());, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +  /**, +   * This tests for a bug where if {@link Service#stop()} was called while the service was, +   * {@link State#STARTING} more than once, the {@link Listener#stopping(State)} callback would get, +   * called multiple times., +   */, +  public void testManualServiceStopMultipleTimesWhileStarting() throws Exception {, +    ManualSwitchedService service = new ManualSwitchedService();, +    final AtomicInteger stopppingCount = new AtomicInteger();, +    service.addListener(new Listener() {, +      @Override public void starting() {}, +      @Override public void running() {}, +      @Override public void stopping(State from) {, +        stopppingCount.incrementAndGet();, +      }, +      @Override public void terminated(State from) {}, +      @Override public void failed(State from, Throwable failure) {}, +      }, MoreExecutors.sameThreadExecutor());, +, +    service.start();, +    service.stop();, +    assertEquals(1, stopppingCount.get());, +    service.stop();, +    assertEquals(1, stopppingCount.get());, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/AbstractService.java, +      if (state() == State.NEW) {, +      State previous = state();, +      switch (previous) {, +          throw new AssertionError("Unexpected state: " + previous);, +      // We have to examine the internal state of the snapshot here to properly handle the stop , +      // while starting case., +      // We check the internal state of the snapshot instead of state() directly so we don't allow, +      // notifyStopped() to be called while STARTING, even if stop() has already been called., +      State previous = snapshot.state;, +      if (previous != State.STOPPING && previous != State.RUNNING) {, +            "Cannot notifyStopped() when the service is " + previous);, +      State previous = state();, +      switch (previous) {, +          throw new IllegalStateException("Failed while in state:" + previous, cause);, +          throw new AssertionError("Unexpected state: " + previous);, +      State currentState = state();, +      if (currentState != State.TERMINATED && currentState != State.FAILED) {]