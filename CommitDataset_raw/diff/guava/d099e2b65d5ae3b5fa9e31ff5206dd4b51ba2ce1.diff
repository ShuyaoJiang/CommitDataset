[+++ b/guava-tests/test/com/google/common/math/BigIntegerMathTest.java, +    for (int i = 1; i <= 300; i++) {, +++ b/guava-tests/test/com/google/common/math/BigIntegerMathTest.java, +    for (int i = 1; i <= 300; i++) {, +++ b/guava/src/com/google/common/math/BigIntegerMath.java, +   * Returns {@code n!}, that is, the product of the first {@code n} positive, +   * integers, or {@code 1} if {@code n == 0}., +   * <p>This uses an efficient binary recursive algorithm to compute the factorial, +   * with balanced multiplies.  It also removes all the 2s from the intermediate, +   * products (shifting them back in at the end)., +   *, +, +    // If the factorial is small enough, just use LongMath to do it., +      return BigInteger.valueOf(LongMath.FACTORIALS[n]);, +    // Pre-allocate space for our list of intermediate BigIntegers., +    double approxSize = n * Math.log(n) / Math.log(2.0) / Long.SIZE;, +    ArrayList<BigInteger> bignums = new ArrayList<BigInteger>((int) Math.ceil(approxSize));, +, +    // Start from the pre-computed maximum long factorial., +    int startingNumber = LongMath.FACTORIALS.length;, +    long product = LongMath.FACTORIALS[startingNumber - 1];, +    // Strip off 2s from this value., +    int shift = Long.numberOfTrailingZeros(product);, +    product >>= shift;, +, +    // Use floor(log2(num)) + 1 to prevent overflow of multiplication., +    int productBits = Long.SIZE - Long.numberOfLeadingZeros(product);, +    int bits = Long.SIZE - Long.numberOfLeadingZeros(startingNumber);, +    // Check for the next power of two boundary, to save us a CLZ operation., +    int nextPowerOfTwo = 1 << (bits - 1);, +, +    // Iteratively multiply the longs as big as they can go., +    for (long num = startingNumber; num <= n; num++) {, +      // Check to see if the floor(log2(num)) + 1 has changed., +      if ((num & nextPowerOfTwo) != 0) {, +        nextPowerOfTwo <<= 1;, +        bits++;, +      // Get rid of the 2s in num., +      int tz = Long.numberOfTrailingZeros(num);, +      long normalizedNum = num >> tz;, +      shift += tz;, +      // Adjust floor(log2(num)) + 1., +      int normalizedBits = bits - tz;, +      // If it won't fit in a long, then we store off the intermediate product., +      if (normalizedBits + productBits >= Long.SIZE) {, +        bignums.add(BigInteger.valueOf(product));, +        product = 1;, +        productBits = 0;, +      }, +      product *= normalizedNum;, +      productBits = Long.SIZE - Long.numberOfLeadingZeros(product);, +    }, +    // Check for leftovers., +    if (product > 1) {, +      bignums.add(BigInteger.valueOf(product));, +    }, +    // Efficiently multiply all the intermediate products together., +    return listProduct(bignums).shiftLeft(shift);, +  static BigInteger listProduct(List<BigInteger> nums) {, +    return listProduct(nums, 0, nums.size());, +  }, +  static BigInteger listProduct(List<BigInteger> nums, int start, int end) {, +    if ((end - start) == 0) {, +      return BigInteger.ONE;, +    }, +    if ((end - start) == 1) {, +      return nums.get(start);, +    }, +    if ((end - start) == 2) {, +      return nums.get(start).multiply(nums.get(start + 1));, +    }, +    if ((end - start) == 3) {, +      return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));, +    }, +, +    // Otherwise, split the list in half and recursively do this., +    int m = (end + start) >>> 1;, +    return listProduct(nums, start, m).multiply(listProduct(nums, m, end));, +   * {@code k}, that is, {@code n! / (k! (n - k)!)}., +++ b/guava-tests/test/com/google/common/math/BigIntegerMathTest.java, +    for (int i = 1; i <= 300; i++) {, +++ b/guava/src/com/google/common/math/BigIntegerMath.java, +   * Returns {@code n!}, that is, the product of the first {@code n} positive, +   * integers, or {@code 1} if {@code n == 0}., +   * <p>This uses an efficient binary recursive algorithm to compute the factorial, +   * with balanced multiplies.  It also removes all the 2s from the intermediate, +   * products (shifting them back in at the end)., +   *, +, +    // If the factorial is small enough, just use LongMath to do it., +      return BigInteger.valueOf(LongMath.FACTORIALS[n]);, +    // Pre-allocate space for our list of intermediate BigIntegers., +    double approxSize = n * Math.log(n) / Math.log(2.0) / Long.SIZE;, +    ArrayList<BigInteger> bignums = new ArrayList<BigInteger>((int) Math.ceil(approxSize));, +, +    // Start from the pre-computed maximum long factorial., +    int startingNumber = LongMath.FACTORIALS.length;, +    long product = LongMath.FACTORIALS[startingNumber - 1];, +    // Strip off 2s from this value., +    int shift = Long.numberOfTrailingZeros(product);]