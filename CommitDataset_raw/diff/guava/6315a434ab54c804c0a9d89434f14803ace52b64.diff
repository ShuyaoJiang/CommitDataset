[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +import java.util.concurrent.BrokenBarrierException;, +    public void testCustomScheduler_deadlock() throws InterruptedException, BrokenBarrierException {, +      final CyclicBarrier inGetNextSchedule = new CyclicBarrier(2);, +      // This will flakily deadlock, so run it multiple times to increase the flake likelihood, +      for (int i = 0; i < 1000; i++) {, +        Service service = new AbstractScheduledService() {, +          @Override protected void runOneIteration() {}, +          @Override protected Scheduler scheduler() {, +            return new CustomScheduler() {, +              @Override protected Schedule getNextSchedule() throws Exception {, +                if (state() != State.STARTING) {, +                  inGetNextSchedule.await();, +                  Thread.yield();, +                  throw new RuntimeException("boom");, +                }, +                return new Schedule(0, TimeUnit.NANOSECONDS);, +              }, +            };, +          }, +        };, +        service.startAsync().awaitRunning();, +        inGetNextSchedule.await();, +        service.stopAsync();, +      }, +    }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +import java.util.concurrent.BrokenBarrierException;, +    public void testCustomScheduler_deadlock() throws InterruptedException, BrokenBarrierException {, +      final CyclicBarrier inGetNextSchedule = new CyclicBarrier(2);, +      // This will flakily deadlock, so run it multiple times to increase the flake likelihood, +      for (int i = 0; i < 1000; i++) {, +        Service service = new AbstractScheduledService() {, +          @Override protected void runOneIteration() {}, +          @Override protected Scheduler scheduler() {, +            return new CustomScheduler() {, +              @Override protected Schedule getNextSchedule() throws Exception {, +                if (state() != State.STARTING) {, +                  inGetNextSchedule.await();, +                  Thread.yield();, +                  throw new RuntimeException("boom");, +                }, +                return new Schedule(0, TimeUnit.NANOSECONDS);, +              }, +            };, +          }, +        };, +        service.startAsync().awaitRunning();, +        inGetNextSchedule.await();, +        service.stopAsync();, +      }, +    }, +, +++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java, +    }, +        // invoke the callback outside the lock, prevents some shenanigans., +        Schedule schedule;, +        try {, +          schedule = CustomScheduler.this.getNextSchedule();, +        } catch (Throwable t) {, +          service.notifyFailed(t);, +          return;, +        }, +        Throwable scheduleFailure = null;, +          // TODO(lukes): consider building everything in terms of ListenableScheduledFuture then, +          // the AbstractService could monitor the future directly.  Rescheduling is still hard..., +          // but it would help with some of these lock ordering issues., +          scheduleFailure = e;, +        // Call notifyFailed outside the lock to avoid lock ordering issues., +        if (scheduleFailure != null) {, +          service.notifyFailed(scheduleFailure);, +        }]