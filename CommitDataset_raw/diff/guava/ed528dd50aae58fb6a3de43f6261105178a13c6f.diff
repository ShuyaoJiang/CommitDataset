[+++ b/guava/src/com/google/common/collect/Range.java, +import com.google.common.base.Equivalence;, + * A range (or "interval") defines the <i>boundaries</i> around a contiguous span of values of some, + * {@code Comparable} type; for example, "integers from 1 to 100 inclusive." Note that it is not, + * possible to <i>iterate</i> over these contained values unless an appropriate {@link, + * DiscreteDomain} can be provided to the {@link #asSet asSet} method., + * <h3>Types of ranges</h3>, + *, + * <p>Each end of the range may be bounded or unbounded. If bounded, there is an associated, + * <i>endpoint</i> value, and the range is considered to be either <i>open</i> (does not include the, + * endpoint) or <i>closed</i> (includes the endpoint) on that side. With three possibilities on each, + * side, this yields nine basic types of ranges, enumerated below. (Notation: a square bracket, + * ({@code [ ]}) indicates that the range is closed on that side; a parenthesis ({@code ( )}) means, + * it is either open or unbounded. The construct {@code {x | statement}} is read "the set of all, + * <i>x</i> such that <i>statement</i>."), + *, + * <blockquote><table>, + * <tr><td><b>Notation</b> <td><b>Definition</b>        <td><b>Factory method</b>, + * <tr><td>{@code (a..b)}  <td>{@code {x | a < x < b}}  <td>{@link Ranges#open open}, + * <tr><td>{@code [a..b]}  <td>{@code {x | a <= x <= b}}<td>{@link Ranges#closed closed}, + * <tr><td>{@code (a..b]}  <td>{@code {x | a < x <= b}} <td>{@link Ranges#openClosed openClosed}, + * <tr><td>{@code [a..b)}  <td>{@code {x | a <= x < b}} <td>{@link Ranges#closedOpen closedOpen}, + * <tr><td>{@code (a..+∞)} <td>{@code {x | x > a}}      <td>{@link Ranges#greaterThan greaterThan}, + * <tr><td>{@code [a..+∞)} <td>{@code {x | x >= a}}     <td>{@link Ranges#atLeast atLeast}, + * <tr><td>{@code (-∞..b)} <td>{@code {x | x < b}}      <td>{@link Ranges#lessThan lessThan}, + * <tr><td>{@code (-∞..b]} <td>{@code {x | x <= b}}     <td>{@link Ranges#atMost atMost}, + * <tr><td>{@code (-∞..+∞)}<td>{@code {x}}              <td>{@link Ranges#all all}, + * </table></blockquote>, + *, + * <p>When both endpoints exist, the upper endpoint may not be less than the lower. The endpoints, + * may be equal only if at least one of the bounds is closed:, + * <li>{@code [a..a]} : a singleton range, + * <li>{@code [a..a); (a..a]} : {@linkplain #isEmpty empty} ranges; also valid, + * <li>{@code (a..a)} : <b>invalid</b>; an exception will be thrown, + * <h3>Warnings</h3>, + * <li>Use immutable value types only, if at all possible. If you must use a mutable type, <b>do, + *     not</b> allow the endpoint instances to mutate after the range is created!, + * <li>Your value type's comparison method should be {@linkplain Comparable consistent with equals}, + *     if at all possible. Otherwise, be aware that concepts used throughout this documentation such, + *     as "equal", "same", "unique" and so on actually refer to whether {@link Comparable#compareTo, + *     compareTo} returns zero, not whether {@link Object#equals equals} returns {@code true}., + * <li>A class which implements {@code Comparable<UnrelatedType>} is very broken, and will cause, + *     undefined horrible things to happen in {@code Range}. For now, the Range API does not prevent, + *     its use, because this would also rule out all ungenerified (pre-JDK1.5) data types. <b>This, + *     may change in the future.</b>, + * <h3>Other notes</h3>, + * <ul>, + * <li>Instances of this type are obtained using the static factory methods in the {@link Ranges}, + *     class., + * <li>Ranges are <i>convex</i>: whenever two values are contained, all values in between them must, + *     also be contained. More formally, for any {@code c1 <= c2 <= c3} of type {@code C}, {@code, + *     r.contains(c1) && r.contains(c3)} implies {@code r.contains(c2)}). This means that a {@code, + *     Range<Integer>} can never be used to represent, say, "all <i>prime</i> numbers from 1 to, + *     100.", + * <li>When evaluated as a {@link Predicate}, a range yields the same result as invoking {@link, + *     #contains}., + * <li>Terminology note: a range {@code a} is said to be the <i>maximal</i> range having property, + *     <i>P</i> if, for all ranges {@code b} also having property <i>P</i>, {@code a.encloses(b)}., + *     Likewise, {@code a} is <i>minimal</i> when {@code b.encloses(a)} for all {@code b} having, + *     property <i>P</i>. See, for example, the definition of {@link #intersection intersection}., + * </ul>, + * <h3>Further reading</h3>, + * <p>See the Guava User Guide article on, + * <a href="http://code.google.com/p/guava-libraries/wiki/RangesExplained">{@code Range}</a>., +public final class Range<C extends Comparable> implements Predicate<C>, Serializable {, +      throw new IllegalArgumentException("Invalid range: " + toString(lowerBound, upperBound));, +   * @throws IllegalStateException if this range is unbounded below (that is, {@link, +   *     #hasLowerBound()} returns {@code false}), +   * Returns the type of this range's lower bound: {@link BoundType#CLOSED} if the range includes, +   * its lower endpoint, {@link BoundType#OPEN} if it does not., +   * @throws IllegalStateException if this range is unbounded below (that is, {@link, +   *     #hasLowerBound()} returns {@code false}), +   * @throws IllegalStateException if this range is unbounded above (that is, {@link, +   *     #hasUpperBound()} returns {@code false}), +   * Returns the type of this range's upper bound: {@link BoundType#CLOSED} if the range includes, +   * its upper endpoint, {@link BoundType#OPEN} if it does not., +   * @throws IllegalStateException if this range is unbounded above (that is, {@link, +   *     #hasUpperBound()} returns {@code false}), +   * Returns {@code true} if this range is of the form {@code [v..v)} or {@code (v..v]}. (This does, +   * not encompass ranges of the form {@code (v..v)}, because such ranges are <i>invalid</i> and, +   * can't be constructed at all.), +   * <p>Note that certain discrete ranges such as the integer range {@code (3..4)} are <b>not</b>, +   * considered empty, even though they contain no actual values., +   * Returns {@code true} if {@code value} is within the bounds of this range. For example, on the, +   * range {@code [0..2)}, {@code contains(1)} returns {@code true}, while {@code contains(2)}, +   * returns {@code false}., +   * Equivalent to {@link #contains}; provided only to satisfy the {@link Predicate} interface. When, +   * using a reference of type {@code Range}, always invoke {@link #contains} directly instead., +   * Returns {@code true} if every element in {@code values} is {@linkplain #contains contained} in, +   * this range., +   * Returns {@code true} if the bounds of {@code other} do not extend outside the bounds of this, +   * range. Examples:, +   * <li>{@code [3..6]} encloses {@code [4..4)} (even though the latter is empty), +   * <li>{@code [4..5]} does not enclose {@code (3..6)} (even though it contains every value, +   *     contained by the latter range), +   * <li>{@code [3..6]} does not enclose {@code (1..1]} (even though it contains every value, +   *     contained by the latter range), +   * Note that if {@code a.encloses(b)}, then {@code b.contains(v)} implies {@code a.contains(v)},, +   * but as the last two examples illustrate, the converse is not always true., +   * <p>Being reflexive, antisymmetric and transitive, the {@code encloses} relation defines a]