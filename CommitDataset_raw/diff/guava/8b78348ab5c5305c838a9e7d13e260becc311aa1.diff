[+++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java, +, +    BigInteger accum = BigInteger.ONE;, +, +    long numeratorAccum = n;, +    long denominatorAccum = 1;, +, +    int bits = LongMath.log2(n, RoundingMode.CEILING);, +, +    int numeratorBits = bits;, +, +    for (int i = 1; i < k; i++) {, +      int p = n - i;, +      int q = i + 1;, +, +      // log2(p) >= bits - 1, because p >= n/2, +, +      if (numeratorBits + bits >= Long.SIZE - 1) {, +        // The numerator is as big as it can get without risking overflow., +        // Multiply numeratorAccum / denominatorAccum into accum., +        accum = accum, +            .multiply(BigInteger.valueOf(numeratorAccum)), +            .divide(BigInteger.valueOf(denominatorAccum));, +        numeratorAccum = p;, +        denominatorAccum = q;, +        numeratorBits = bits;, +      } else {, +        // We can definitely multiply into the long accumulators without overflowing them., +        numeratorAccum *= p;, +        denominatorAccum *= q;, +        numeratorBits += bits;, +    }, +    return accum, +        .multiply(BigInteger.valueOf(numeratorAccum)), +        .divide(BigInteger.valueOf(denominatorAccum));, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java, +, +    BigInteger accum = BigInteger.ONE;, +, +    long numeratorAccum = n;, +    long denominatorAccum = 1;, +, +    int bits = LongMath.log2(n, RoundingMode.CEILING);, +, +    int numeratorBits = bits;, +, +    for (int i = 1; i < k; i++) {, +      int p = n - i;, +      int q = i + 1;, +, +      // log2(p) >= bits - 1, because p >= n/2, +, +      if (numeratorBits + bits >= Long.SIZE - 1) {, +        // The numerator is as big as it can get without risking overflow., +        // Multiply numeratorAccum / denominatorAccum into accum., +        accum = accum, +            .multiply(BigInteger.valueOf(numeratorAccum)), +            .divide(BigInteger.valueOf(denominatorAccum));, +        numeratorAccum = p;, +        denominatorAccum = q;, +        numeratorBits = bits;, +      } else {, +        // We can definitely multiply into the long accumulators without overflowing them., +        numeratorAccum *= p;, +        denominatorAccum *= q;, +        numeratorBits += bits;, +    }, +    return accum, +        .multiply(BigInteger.valueOf(numeratorAccum)), +        .divide(BigInteger.valueOf(denominatorAccum));, +++ b/guava-tests/test/com/google/common/math/BigIntegerMathTest.java, +  public void testBinomialSmall() {, +    runBinomialTest(0, 30);, +  }, +, +  @GwtIncompatible("too slow"), +  public void testBinomialLarge() {, +    runBinomialTest(31, 100);, +  }, +, +  private static void runBinomialTest(int firstN, int lastN) {, +    for (int n = firstN; n <= lastN; n++) {, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java, +, +    BigInteger accum = BigInteger.ONE;, +, +    long numeratorAccum = n;, +    long denominatorAccum = 1;, +, +    int bits = LongMath.log2(n, RoundingMode.CEILING);, +, +    int numeratorBits = bits;, +, +    for (int i = 1; i < k; i++) {, +      int p = n - i;, +      int q = i + 1;, +, +      // log2(p) >= bits - 1, because p >= n/2, +, +      if (numeratorBits + bits >= Long.SIZE - 1) {]