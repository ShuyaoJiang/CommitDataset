[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +import static com.google.common.base.Preconditions.checkArgument;, +, +import com.google.common.base.Objects;, +import java.util.AbstractSet;, +import java.util.Arrays;, +import java.util.ConcurrentModificationException;, +import java.util.NoSuchElementException;, + * @author Louis Wasserman, +    return new LinkedHashMultimap<K, V>(DEFAULT_KEY_CAPACITY, DEFAULT_VALUE_SET_CAPACITY);, +    return new LinkedHashMultimap<K, V>(, +        Maps.capacity(expectedKeys),, +        Maps.capacity(expectedValuesPerKey));, +    LinkedHashMultimap<K, V> result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);, +    result.putAll(multimap);, +    return result;, +  private interface ValueSetLink<K, V> {, +    ValueSetLink<K, V> getPredecessorInValueSet();, +    ValueSetLink<K, V> getSuccessorInValueSet();, +, +    void setPredecessorInValueSet(ValueSetLink<K, V> entry);, +    void setSuccessorInValueSet(ValueSetLink<K, V> entry);, +  private static <K, V> void succeedsInValueSet(ValueSetLink<K, V> pred, ValueSetLink<K, V> succ) {, +    pred.setSuccessorInValueSet(succ);, +    succ.setPredecessorInValueSet(pred);, +  private static <K, V> void succeedsInMultimap(, +      ValueEntry<K, V> pred, ValueEntry<K, V> succ) {, +    pred.setSuccessorInMultimap(succ);, +    succ.setPredecessorInMultimap(pred);, +  }, +, +  private static <K, V> void deleteFromValueSet(ValueSetLink<K, V> entry) {, +    succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet());, +  }, +, +  private static <K, V> void deleteFromMultimap(ValueEntry<K, V> entry) {, +    succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap());, +  }, +, +  /**, +   * LinkedHashMultimap entries are in no less than three coexisting linked lists:, +   * a row in the hash table for a Set<V> associated with a key, the linked list, +   * of insertion-ordered entries in that Set<V>, and the linked list of entries, +   * in the LinkedHashMultimap as a whole., +   */, +  private static final class ValueEntry<K, V> extends AbstractMapEntry<K, V>, +      implements ValueSetLink<K, V> {, +    final K key;, +    final V value;, +    final int valueHash;, +, +    @Nullable ValueEntry<K, V> nextInValueSetHashRow;, +, +    ValueSetLink<K, V> predecessorInValueSet;, +    ValueSetLink<K, V> successorInValueSet;, +, +    ValueEntry<K, V> predecessorInMultimap;, +    ValueEntry<K, V> successorInMultimap;, +, +    ValueEntry(K key, V value, int valueHash, @Nullable ValueEntry<K, V> nextInValueSetHashRow) {, +      this.key = key;, +      this.value = value;, +      this.valueHash = valueHash;, +      this.nextInValueSetHashRow = nextInValueSetHashRow;, +    }, +, +    @Override, +    public K getKey() {, +      return key;, +    }, +, +    @Override, +    public V getValue() {, +      return value;, +    }, +, +    @Override, +    public ValueSetLink<K, V> getPredecessorInValueSet() {, +      return predecessorInValueSet;, +    }, +, +    @Override, +    public ValueSetLink<K, V> getSuccessorInValueSet() {, +      return successorInValueSet;, +    }, +, +    @Override, +    public void setPredecessorInValueSet(ValueSetLink<K, V> entry) {, +      predecessorInValueSet = entry;, +    }, +, +    @Override, +    public void setSuccessorInValueSet(ValueSetLink<K, V> entry) {, +      successorInValueSet = entry;, +    }, +, +    public ValueEntry<K, V> getPredecessorInMultimap() {, +      return predecessorInMultimap;, +    }, +]