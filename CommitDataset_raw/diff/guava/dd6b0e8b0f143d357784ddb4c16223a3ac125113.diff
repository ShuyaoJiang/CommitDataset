[+++ b/guava/src/com/google/common/graph/ConfigurableGraph.java, +    NodeAdjacencies<N> connections = nodeConnections.get(node);, +    if (connections == null) {, +    for (N successor : connections.successors()) {, +    for (N predecessor : connections.predecessors()) {, +    if (connectionsN1 == null || !connectionsN1.successors().contains(node2)) {, +    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);, +    connectionsN1.removeSuccessor(node2);, +    return true;, +++ b/guava/src/com/google/common/graph/ConfigurableGraph.java, +    NodeAdjacencies<N> connections = nodeConnections.get(node);, +    if (connections == null) {, +    for (N successor : connections.successors()) {, +    for (N predecessor : connections.predecessors()) {, +    if (connectionsN1 == null || !connectionsN1.successors().contains(node2)) {, +    NodeAdjacencies<N> connectionsN2 = nodeConnections.get(node2);, +    connectionsN1.removeSuccessor(node2);, +    return true;, +++ b/guava/src/com/google/common/graph/DirectedNodeAdjacencies.java, +import static com.google.common.graph.GraphConstants.EXPECTED_DEGREE;, +import com.google.common.base.Predicate;, +import com.google.common.collect.ImmutableMap;, +import com.google.common.collect.Iterators;, +import com.google.common.collect.Maps;, +import java.util.AbstractSet;, +import java.util.Iterator;, +import java.util.Map;, +  enum Adjacency {, +    PRED,, +    SUCC,, +    BOTH;, +  }, +  private final Map<N, Adjacency> adjacentNodes;, +, +  private int predecessorCount;, +  private int successorCount;, +, +  private DirectedNodeAdjacencies(, +      Map<N, Adjacency> adjacentNodes, int predecessorCount, int successorCount) {, +    this.adjacentNodes = checkNotNull(adjacentNodes, "adjacentNodes");, +    this.predecessorCount = predecessorCount;, +    this.successorCount = successorCount;, +    return new DirectedNodeAdjacencies<N>(, +        Maps.<N, Adjacency>newHashMapWithExpectedSize(EXPECTED_DEGREE), 0, 0);, +  static <N> DirectedNodeAdjacencies<N> ofImmutable(, +      Map<N, Adjacency> adjacentNodes, int predecessorCount, int successorCount) {, +        ImmutableMap.copyOf(adjacentNodes), predecessorCount, successorCount);, +    return Collections.unmodifiableSet(adjacentNodes.keySet());, +    // Don't simply use Sets.filter() or we'll end up with O(N) instead of O(1) size()., +    return new AbstractSet<N>() {, +      @Override, +      public Iterator<N> iterator() {, +        return Iterators.filter(adjacentNodes().iterator(), new Predicate<N>() {, +          @Override, +          public boolean apply(N node) {, +            return isPredecessor(node);, +          }, +        });, +      }, +, +      @Override, +      public int size() {, +        return predecessorCount;, +      }, +, +      @Override, +      public boolean contains(Object o) {, +        return isPredecessor(o);, +      }, +    };, +    // Don't simply use Sets.filter() or we'll end up with O(N) instead of O(1) size()., +    return new AbstractSet<N>() {, +      @Override, +      public Iterator<N> iterator() {, +        return Iterators.filter(adjacentNodes().iterator(), new Predicate<N>() {, +          @Override, +          public boolean apply(N node) {, +            return isSuccessor(node);, +          }, +        });, +      public int size() {, +        return successorCount;, +      }, +, +      @Override, +      public boolean contains(Object o) {, +        return isSuccessor(o);, +      }, +    };, +  }, +, +  @SuppressWarnings("unchecked") // Safe because we only cast if node is a key of Map<N, Adjacency>, +  @Override, +  public void removePredecessor(Object node) {, +    Adjacency adjacency = adjacentNodes.get(node);, +    if (adjacency == Adjacency.BOTH) {, +      adjacentNodes.put((N) node, Adjacency.SUCC);, +      predecessorCount--;, +    } else if (adjacency == Adjacency.PRED) {, +      adjacentNodes.remove(node);]