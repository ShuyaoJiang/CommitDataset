[+++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java, +import static com.google.common.base.Preconditions.checkNotNull;, +  /** Allocation-free implementation of {@code target.addAll(this)}. */, +  void addTo(Multiset<? super E> target) {, +    checkNotNull(target);, +    for (int i = backingMap.firstIndex(); i >= 0; i = backingMap.nextIndex(i)) {, +      target.add(backingMap.getKey(i), backingMap.getValue(i));, +    }, +  }, +, +++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java, +import static com.google.common.base.Preconditions.checkNotNull;, +  /** Allocation-free implementation of {@code target.addAll(this)}. */, +  void addTo(Multiset<? super E> target) {, +    checkNotNull(target);, +    for (int i = backingMap.firstIndex(); i >= 0; i = backingMap.nextIndex(i)) {, +      target.add(backingMap.getKey(i), backingMap.getValue(i));, +    }, +  }, +, +++ b/android/guava/src/com/google/common/collect/Multisets.java, +    checkNotNull(self);, +    checkNotNull(elements);, +    if (elements instanceof Multiset) {, +      return addAllImpl(self, cast(elements));, +    } else if (elements.isEmpty()) {, +      return false;, +    } else {, +      return Iterators.addAll(self, elements.iterator());, +    }, +  }, +, +  /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */, +  private static <E> boolean addAllImpl(Multiset<E> self, Multiset<? extends E> elements) {, +    // It'd be nice if we could specialize for ImmutableMultiset here without also retaining, +    // its code when it's not in scope..., +    if (elements instanceof AbstractMapBasedMultiset) {, +      return addAllImpl(self, (AbstractMapBasedMultiset<? extends E>) elements);, +    } else if (elements.isEmpty()) {, +      return false;, +    } else {, +      for (Multiset.Entry<? extends E> entry : elements.entrySet()) {, +        self.add(entry.getElement(), entry.getCount());, +      }, +      return true;, +    }, +  }, +, +  /**, +   * A specialization of {@code addAllImpl} for when {@code elements} is an, +   * AbstractMapBasedMultiset., +   */, +  private static <E> boolean addAllImpl(, +      Multiset<E> self, AbstractMapBasedMultiset<? extends E> elements) {, +    elements.addTo(self);, +++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java, +import static com.google.common.base.Preconditions.checkNotNull;, +  /** Allocation-free implementation of {@code target.addAll(this)}. */, +  void addTo(Multiset<? super E> target) {, +    checkNotNull(target);, +    for (int i = backingMap.firstIndex(); i >= 0; i = backingMap.nextIndex(i)) {, +      target.add(backingMap.getKey(i), backingMap.getValue(i));, +    }, +  }, +, +++ b/android/guava/src/com/google/common/collect/Multisets.java, +    checkNotNull(self);, +    checkNotNull(elements);, +    if (elements instanceof Multiset) {, +      return addAllImpl(self, cast(elements));, +    } else if (elements.isEmpty()) {, +      return false;, +    } else {, +      return Iterators.addAll(self, elements.iterator());, +    }, +  }, +, +  /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */, +  private static <E> boolean addAllImpl(Multiset<E> self, Multiset<? extends E> elements) {, +    // It'd be nice if we could specialize for ImmutableMultiset here without also retaining, +    // its code when it's not in scope..., +    if (elements instanceof AbstractMapBasedMultiset) {, +      return addAllImpl(self, (AbstractMapBasedMultiset<? extends E>) elements);, +    } else if (elements.isEmpty()) {, +      return false;, +    } else {, +      for (Multiset.Entry<? extends E> entry : elements.entrySet()) {, +        self.add(entry.getElement(), entry.getCount());, +      }, +      return true;, +    }, +  }, +, +  /**, +   * A specialization of {@code addAllImpl} for when {@code elements} is an, +   * AbstractMapBasedMultiset., +   */, +  private static <E> boolean addAllImpl(, +      Multiset<E> self, AbstractMapBasedMultiset<? extends E> elements) {, +    elements.addTo(self);]