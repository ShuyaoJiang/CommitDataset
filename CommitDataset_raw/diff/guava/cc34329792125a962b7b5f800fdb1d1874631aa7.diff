[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  static <K, V> Entry<K, V> unmodifiableEntry(final Entry<? extends K, ? extends V> entry) {, +    class Values extends Maps.Values<K, V> {, +      Values() {, +        super(AbstractFilteredMap.this);, +        return Iterables.removeIf(unfiltered.entrySet(), Predicates.<Entry<K, V>>and(, +            predicate, Predicates.compose(Predicates.in(collection), Maps.<V>valueFunction())));, +        return Iterables.removeIf(, +            unfiltered.entrySet(), Predicates.<Entry<K, V>>and(predicate, Predicates.compose(, +                Predicates.not(Predicates.in(collection)), Maps.<V>valueFunction())));, +      }, +, +      @Override public Object[] toArray() {, +        // creating an ArrayList so filtering happens once, +        return Lists.newArrayList(iterator()).toArray();, +      }, +, +      @Override public <T> T[] toArray(T[] array) {, +        return Lists.newArrayList(iterator()).toArray(array);, +  }, +, +  private static class FilteredKeyMap<K, V> extends AbstractFilteredMap<K, V> {, +    Predicate<? super K> keyPredicate;, +, +    FilteredKeyMap(Map<K, V> unfiltered, Predicate<? super K> keyPredicate,, +        Predicate<Entry<K, V>> entryPredicate) {, +      super(unfiltered, entryPredicate);, +      this.keyPredicate = keyPredicate;, +    }, +, +    Set<Entry<K, V>> entrySet;, +, +    @Override public Set<Entry<K, V>> entrySet() {, +      Set<Entry<K, V>> result = entrySet;, +      return (result == null), +          ? entrySet = Sets.filter(unfiltered.entrySet(), predicate), +          : result;, +    }, +, +    Set<K> keySet;, +, +    @Override public Set<K> keySet() {, +      Set<K> result = keySet;, +      return (result == null), +          ? keySet = Sets.filter(unfiltered.keySet(), keyPredicate), +          : result;, +    }, +, +    // The cast is called only when the key is in the unfiltered map, implying, +    // that key is a K., +    @Override, +    @SuppressWarnings("unchecked"), +    public boolean containsKey(Object key) {, +      return unfiltered.containsKey(key) && keyPredicate.apply((K) key);, +    }, +  }, +, +  static class FilteredEntryMap<K, V> extends AbstractFilteredMap<K, V> {, +    /**, +     * Entries in this set satisfy the predicate, but they don't validate the, +     * input to {@code Entry.setValue()}., +     */, +    final Set<Entry<K, V>> filteredEntrySet;, +, +    FilteredEntryMap(, +        Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {, +      super(unfiltered, entryPredicate);, +      filteredEntrySet = Sets.filter(unfiltered.entrySet(), predicate);, +    }, +, +    Set<Entry<K, V>> entrySet;, +, +    @Override public Set<Entry<K, V>> entrySet() {, +      Set<Entry<K, V>> result = entrySet;, +      return (result == null) ? entrySet = new EntrySet() : result;, +    }, +, +    private class EntrySet extends ForwardingSet<Entry<K, V>> {, +      @Override protected Set<Entry<K, V>> delegate() {, +        return filteredEntrySet;, +      }, +, +      @Override public Iterator<Entry<K, V>> iterator() {, +        final Iterator<Entry<K, V>> iterator = filteredEntrySet.iterator();, +        return new TransformedIterator<Entry<K, V>, Entry<K, V>>(iterator) {, +          @Override, +          Entry<K, V> transform(final Entry<K, V> entry) {, +            return new ForwardingMapEntry<K, V>() {, +              @Override protected Entry<K, V> delegate() {, +                return entry;, +              }, +, +              @Override public V setValue(V value) {, +                checkArgument(apply(entry.getKey(), value));, +                return super.setValue(value);, +              }, +            };, +          }, +        };, +      }]