[+++ b/guava/src/com/google/common/math/DoubleMath.java, +import static com.google.common.math.DoubleUtils.fastAbs;, +import static java.lang.Math.copySign;, +import static java.lang.Math.getExponent;, +import static java.lang.Math.log;, +import static java.lang.Math.rint;, +        if (x >= 0.0 || isMathematicalInteger(x)) {, +          return x;, +        } else {, +          return x - 1.0;, +        }, +        if (x <= 0.0 || isMathematicalInteger(x)) {, +          return x;, +        } else {, +          return x + 1.0;, +        }, +          return x + Math.copySign(1.0, x);, +      case HALF_EVEN:, +        return rint(x);, +, +      case HALF_UP: {, +        double z = rint(x);, +        if (fastAbs(x - z) == 0.5) {, +          return x + copySign(1.0, x);, +          return z;, +        }, +      }, +, +      case HALF_DOWN: {, +        double z = rint(x);, +        if (fastAbs(x - z) == 0.5) {, +          return x;, +        } else {, +          return z;, +        }, +    int exponent = getExponent(x);, +    return log(x) / LN_2; // surprisingly within 1 ulp according to tests, +  private static final double LN_2 = log(2);, +    int exponent = getExponent(x);, +        && (x == 0.0 ||, +            SIGNIFICAND_BITS - Long.numberOfTrailingZeros(getSignificand(x)) <= getExponent(x));, +++ b/guava/src/com/google/common/math/DoubleMath.java, +import static com.google.common.math.DoubleUtils.fastAbs;, +import static java.lang.Math.copySign;, +import static java.lang.Math.getExponent;, +import static java.lang.Math.log;, +import static java.lang.Math.rint;, +        if (x >= 0.0 || isMathematicalInteger(x)) {, +          return x;, +        } else {, +          return x - 1.0;, +        }, +        if (x <= 0.0 || isMathematicalInteger(x)) {, +          return x;, +        } else {, +          return x + 1.0;, +        }, +          return x + Math.copySign(1.0, x);, +      case HALF_EVEN:, +        return rint(x);, +, +      case HALF_UP: {, +        double z = rint(x);, +        if (fastAbs(x - z) == 0.5) {, +          return x + copySign(1.0, x);, +          return z;, +        }, +      }, +, +      case HALF_DOWN: {, +        double z = rint(x);, +        if (fastAbs(x - z) == 0.5) {, +          return x;, +        } else {, +          return z;, +        }, +    int exponent = getExponent(x);, +    return log(x) / LN_2; // surprisingly within 1 ulp according to tests, +  private static final double LN_2 = log(2);, +    int exponent = getExponent(x);, +        && (x == 0.0 ||, +            SIGNIFICAND_BITS - Long.numberOfTrailingZeros(getSignificand(x)) <= getExponent(x));, +++ b/guava/src/com/google/common/math/DoubleUtils.java, +import static java.lang.Double.MAX_EXPONENT;, +import static java.lang.Double.MIN_EXPONENT;, +import static java.lang.Double.POSITIVE_INFINITY;, +import static java.lang.Double.doubleToRawLongBits;, +import static java.lang.Double.isNaN;, +import static java.lang.Double.longBitsToDouble;, +import static java.lang.Math.getExponent;, +    int exponent = getExponent(d);, +    long bits = doubleToRawLongBits(d);, +    return (exponent == MIN_EXPONENT - 1), +    return getExponent(d) <= MAX_EXPONENT;, +    return getExponent(d) >= MIN_EXPONENT;, +  }, +, +  static double fastAbs(double d) {, +    return longBitsToDouble(doubleToRawLongBits(d) & ~SIGN_MASK);, +    long significand = doubleToRawLongBits(x) & SIGNIFICAND_MASK;]