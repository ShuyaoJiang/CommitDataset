[+++ b/guava-tests/test/com/google/common/util/concurrent/UninterruptibleFutureTest.java, +/*, + * Copyright (C) 2009 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static com.google.common.util.concurrent.InterruptionUtil.repeatedlyInterruptTestThread;, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +import static java.util.concurrent.TimeUnit.MINUTES;, +import static java.util.concurrent.TimeUnit.SECONDS;, +, +import com.google.common.testing.TearDown;, +import com.google.common.testing.TearDownStack;, +, +import junit.framework.TestCase;, +, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.FutureTask;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +, +// TODO(azana/cpovirk): Should this be merged into UninterruptiblesTest?, +/**, + * Unit test for {@link Uninterruptibles#getUninterruptibly}, + *, + * @author Kevin Bourrillion, + * @author Chris Povirk, + */, +public class UninterruptibleFutureTest extends TestCase {, +  private SleepingRunnable sleeper;, +  private Future<Boolean> delayedFuture;, +, +  private final TearDownStack tearDownStack = new TearDownStack();, +, +  @Override protected void setUp() {, +    final ExecutorService executor = Executors.newSingleThreadExecutor();, +    tearDownStack.addTearDown(new TearDown() {, +      @Override, +      public void tearDown() {, +        executor.shutdownNow();, +      }, +    });, +    sleeper = new SleepingRunnable(1000);, +    delayedFuture = executor.submit(sleeper, true);, +, +    tearDownStack.addTearDown(new TearDown() {, +      @Override, +      public void tearDown() {, +        Thread.interrupted();, +      }, +    });, +  }, +, +  @Override, +  protected void tearDown() {, +    tearDownStack.runTearDown();, +  }, +, +  /**, +   * This first test doesn't test anything in Uninterruptibles, just, +   * demonstrates some normal behavior of futures so that you can contrast, +   * the next test with it., +   */, +, +  public void testRegularFutureInterrupted() throws ExecutionException {, +, +    /*, +     * Here's the order of events that we want., +     *, +     * 1. The client thread begins to block on a get() call to a future., +     * 2. The client thread is interrupted sometime before the result would be, +     *   available., +     * 3. We expect the client's get() to throw an InterruptedException., +     * 4. We expect the client thread's interrupt state to be false., +     * 5. The client thread again makes a blocking call to get()., +     * 6. Now the result becomes available., +     * 7. We expect get() to return this result., +     * 8. We expect the test thread's interrupt state to be false., +     */, +    InterruptionUtil.requestInterruptIn(200, TimeUnit.MILLISECONDS);, +, +    assertFalse(Thread.interrupted());, +    try {]