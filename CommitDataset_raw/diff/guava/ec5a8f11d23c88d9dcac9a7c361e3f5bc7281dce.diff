[+++ b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java, +++ b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java, +++ b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java, +/*, + * Copyright (C) 2012 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.testing;, +, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import com.google.common.base.CharMatcher;, +import com.google.common.base.Charsets;, +import com.google.common.base.Equivalence;, +import com.google.common.base.Joiner;, +import com.google.common.base.Splitter;, +import com.google.common.base.Throwables;, +import com.google.common.base.Ticker;, +import com.google.common.collect.ArrayListMultimap;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Iterables;, +import com.google.common.collect.ListMultimap;, +import com.google.common.collect.Ordering;, +import com.google.common.collect.Sets;, +import com.google.common.primitives.Primitives;, +import com.google.common.primitives.UnsignedInteger;, +import com.google.common.primitives.UnsignedLong;, +import com.google.common.reflect.AbstractInvocationHandler;, +import com.google.common.reflect.Reflection;, +import com.google.common.reflect.TypeToken;, +, +import java.io.ByteArrayInputStream;, +import java.io.File;, +import java.io.StringReader;, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +import java.math.BigDecimal;, +import java.math.BigInteger;, +import java.nio.ByteBuffer;, +import java.nio.CharBuffer;, +import java.nio.DoubleBuffer;, +import java.nio.FloatBuffer;, +import java.nio.IntBuffer;, +import java.nio.LongBuffer;, +import java.nio.ShortBuffer;, +import java.nio.charset.Charset;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Currency;, +import java.util.List;, +import java.util.Locale;, +import java.util.Set;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.regex.Pattern;, +, +/**, + * Generates fresh instances of types that are different from each other (if possible)., + *, + * @author Ben Yu, + */, +class FreshValueGenerator {, +, +  private final AtomicInteger differentiator = new AtomicInteger(1);, +  private final ListMultimap<Class<?>, Object> sampleInstances = ArrayListMultimap.create();, +, +  <T> void addSampleInstances(Class<T> type, Iterable<? extends T> instances) {, +    sampleInstances.putAll(checkNotNull(type), checkNotNull(instances));, +  }, +, +  final <T> T generate(Class<T> type) {, +    List<Object> samples = sampleInstances.get(type);, +    @SuppressWarnings("unchecked") // sampleInstances is always registered by type., +    T sample = (T) nextInstance(samples, null);, +    if (sample != null) {, +      return sample;, +    }, +    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {, +      if (method.isAnnotationPresent(Generates.class)) {, +        if (Primitives.wrap(type).isAssignableFrom(Primitives.wrap(method.getReturnType()))) {, +          try {, +            @SuppressWarnings("unchecked") // protected by isAssignableFrom, +            T result = (T) method.invoke(this);, +            return result;, +          } catch (InvocationTargetException e) {]