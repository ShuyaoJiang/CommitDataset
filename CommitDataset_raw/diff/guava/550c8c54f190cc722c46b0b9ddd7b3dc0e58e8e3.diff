[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkState;, +import static com.google.common.collect.BstSide.LEFT;, +import static com.google.common.collect.BstSide.RIGHT;, +import java.io.Serializable;, +import java.util.ConcurrentModificationException;, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.primitives.Ints;, +, +public final class TreeMultiset<E> extends AbstractSortedMultiset<E>, +    implements Serializable {, +    return new TreeMultiset<E>(Ordering.natural());, +  @SuppressWarnings("unchecked"), +           ? new TreeMultiset<E>((Comparator) Ordering.natural()), +   * Returns an iterator over the elements contained in this collection., +  public Iterator<E> iterator() {, +    // Needed to avoid Javadoc bug., +    return super.iterator();, +  private TreeMultiset(Comparator<? super E> comparator) {, +    super(comparator);, +    this.range = GeneralRange.all(comparator);, +    this.rootReference = new Reference<Node<E>>();, +  private TreeMultiset(GeneralRange<E> range, Reference<Node<E>> root) {, +    super(range.comparator());, +    this.range = range;, +    this.rootReference = root;, +  }, +, +  @SuppressWarnings("unchecked"), +  E checkElement(Object o) {, +    return (E) o;, +  }, +, +  private transient final GeneralRange<E> range;, +, +  private transient final Reference<Node<E>> rootReference;, +, +  static final class Reference<T> {, +    T value;, +, +    public Reference() {}, +, +    public T get() {, +      return value;, +    }, +, +    public boolean compareAndSet(T expected, T newValue) {, +      if (value == expected) {, +        value = newValue;, +        return true;, +      }, +      return false;, +    }, +  }, +, +  @Override, +  int distinctElements() {, +    Node<E> root = rootReference.get();, +    return BstRangeOps.totalInRange(distinctAggregate(), range, root);, +  }, +, +  @Override, +  public int size() {, +    Node<E> root = rootReference.get();, +    return BstRangeOps.totalInRange(sizeAggregate(), range, root);, +  }, +, +  @Override, +  public int count(@Nullable Object element) {, +      E e = checkElement(element);, +      if (range.contains(e)) {, +        Node<E> node = BstOperations.seek(comparator(), rootReference.get(), e);, +        return (node == null) ? 0 : node.elemOccurrences;, +      }, +    } catch (NullPointerException e) {, +      return 0;, +  private int mutate(@Nullable E e, MultisetModifier modifier) {, +    BstMutationRule<E, Node<E>> mutationRule = BstMutationRule.createRule(, +        modifier,, +        BstCountBasedBalancePolicies., +          <E, Node<E>>singleRebalancePolicy(distinctAggregate()),, +        nodeFactory());, +    BstMutationResult<E, Node<E>> mutationResult =, +        BstOperations.mutate(comparator(), mutationRule, rootReference.get(), e);, +    if (!rootReference.compareAndSet(, +        mutationResult.getOriginalRoot(), mutationResult.getChangedRoot())) {, +      throw new ConcurrentModificationException();, +    }, +    Node<E> original = mutationResult.getOriginalTarget();, +    return (original == null) ? 0 : original.elemOccurrences;, +  }, +, +    checkElement(element);, +    if (occurrences == 0) {, +      return count(element);, +    }, +    checkArgument(range.contains(element));, +    return mutate(element, new AddModifier(occurrences));, +  }]