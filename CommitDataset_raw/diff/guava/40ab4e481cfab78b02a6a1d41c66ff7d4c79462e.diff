[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultimap.java, +      super(subMap);, +          = map().entrySet().iterator();, +      Collection<V> collection = map().remove(key);, +      return map().keySet().containsAll(c);, +      return this == object || this.map().keySet().equals(object);, +      return map().keySet().hashCode();, +      return (SortedMap<K, Collection<V>>) super.map();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultimap.java, +      super(subMap);, +          = map().entrySet().iterator();, +      Collection<V> collection = map().remove(key);, +      return map().keySet().containsAll(c);, +      return this == object || this.map().keySet().equals(object);, +      return map().keySet().hashCode();, +      return (SortedMap<K, Collection<V>>) super.map();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  @SuppressWarnings("unchecked"), +    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);, +    return new MapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);, +  }, +  private static <K, V> void doDifference(, +      Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right,, +      Equivalence<? super V> valueEquivalence,, +      Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth,, +      Map<K, MapDifference.ValueDifference<V>> differences) {, +  private static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {, +    if (map instanceof SortedMap) {, +      return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);, +    } else {, +      return Collections.unmodifiableMap(map);, +    }, +    MapDifferenceImpl(Map<K, V> onlyOnLeft,, +      this.onlyOnLeft = unmodifiableMap(onlyOnLeft);, +      this.onlyOnRight = unmodifiableMap(onlyOnRight);, +      this.onBoth = unmodifiableMap(onBoth);, +      this.differences = unmodifiableMap(differences);, +      return onlyOnLeft.isEmpty() && onlyOnRight.isEmpty() && differences.isEmpty();, +      if (areEqual()) {, +    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);, +    return new SortedMapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);, +    SortedMapDifferenceImpl(SortedMap<K, V> onlyOnLeft,, +      super(onlyOnLeft, onlyOnRight, onBoth, differences);, +      return (result == null) ? values = new Values<K, V2>(this) : result;, +        return keySet = new KeySet<K, V>(this);, +      return (result == null) ? values = new Values<K, V>(this) : result;, +  static class KeySet<K, V> extends Sets.ImprovedAbstractSet<K> {, +    final Map<K, V> map;, +, +    KeySet(Map<K, V> map) {, +      this.map = checkNotNull(map);, +    Map<K, V> map() {, +      return map;, +    }, +  static <K, V> Iterator<K> keyIterator(Iterator<Entry<K, V>> entryIterator) {, +    return Iterators.transform(entryIterator, Maps.<K>keyFunction());, +, +  static <K, V> Iterator<V> valueIterator(Iterator<Entry<K, V>> entryIterator) {, +    return Iterators.transform(entryIterator, Maps.<V>valueFunction());, +  static class Values<K, V> extends AbstractCollection<V> {, +    final Map<K, V> map;, +, +    Values(Map<K, V> map) {, +      this.map = checkNotNull(map);, +    }, +, +    final Map<K, V> map() {, +      return map;, +    }, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultimap.java, +      super(subMap);, +          = map().entrySet().iterator();, +      Collection<V> collection = map().remove(key);, +      return map().keySet().containsAll(c);, +      return this == object || this.map().keySet().equals(object);, +      return map().keySet().hashCode();, +      return (SortedMap<K, Collection<V>>) super.map();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  @SuppressWarnings("unchecked"), +    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);, +    return new MapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);, +  }, +  private static <K, V> void doDifference(, +      Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right,, +      Equivalence<? super V> valueEquivalence,, +      Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth,, +      Map<K, MapDifference.ValueDifference<V>> differences) {, +  private static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {, +    if (map instanceof SortedMap) {, +      return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);, +    } else {, +      return Collections.unmodifiableMap(map);, +    }, +    MapDifferenceImpl(Map<K, V> onlyOnLeft,, +      this.onlyOnLeft = unmodifiableMap(onlyOnLeft);, +      this.onlyOnRight = unmodifiableMap(onlyOnRight);, +      this.onBoth = unmodifiableMap(onBoth);, +      this.differences = unmodifiableMap(differences);, +      return onlyOnLeft.isEmpty() && onlyOnRight.isEmpty() && differences.isEmpty();, +      if (areEqual()) {]