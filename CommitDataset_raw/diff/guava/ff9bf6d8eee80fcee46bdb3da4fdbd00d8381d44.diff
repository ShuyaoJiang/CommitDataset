[+++ b/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java, +import static com.google.common.util.concurrent.MoreExecutors.shutdownAndAwaitTermination;, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +import static org.mockito.Mockito.times;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +  /* Half of a 1-second timeout in nanoseconds */, +  private static final long HALF_SECOND_NANOS = NANOSECONDS.convert(1L, SECONDS) / 2;, +, +  public void testShutdownAndAwaitTermination_immediateShutdown() throws Exception {, +    ExecutorService service = Executors.newSingleThreadExecutor();, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    assertTrue(service.isTerminated());, +  }, +, +  public void testShutdownAndAwaitTermination_immediateShutdownInternal() throws Exception {, +    ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)).thenReturn(true);, +    when(service.isTerminated()).thenReturn(true);, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    verify(service).shutdown();, +    verify(service).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);, +  }, +, +  public void testShutdownAndAwaitTermination_forcedShutDownInternal() throws Exception {, +    ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)), +        .thenReturn(false).thenReturn(true);, +    when(service.isTerminated()).thenReturn(true);, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    verify(service).shutdown();, +    verify(service, times(2)).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);, +    verify(service).shutdownNow();, +  }, +, +  public void testShutdownAndAwaitTermination_nonTerminationInternal() throws Exception {, +    ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)), +        .thenReturn(false).thenReturn(false);, +    assertFalse(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    verify(service).shutdown();, +    verify(service, times(2)).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);, +    verify(service).shutdownNow();, +  }, +, +  public void testShutdownAndAwaitTermination_interruptedInternal() throws Exception {, +    final ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)), +        .thenThrow(new InterruptedException());, +, +    final AtomicBoolean terminated = new AtomicBoolean();, +    // we need to keep this in a flag because t.isInterrupted() returns false after t.join(), +    final AtomicBoolean interrupted = new AtomicBoolean();, +    // we need to use another thread because it will be interrupted and thus using, +    // the current one, owned by JUnit, would make the test fail, +    Thread thread = new Thread(new Runnable() {, +      @Override, +      public void run() {, +        terminated.set(shutdownAndAwaitTermination(service, 1L, SECONDS));, +        interrupted.set(Thread.currentThread().isInterrupted());, +      }, +    });, +    thread.start();, +    thread.join();, +    verify(service).shutdown();, +    verify(service).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);, +    verify(service).shutdownNow();, +    assertTrue(interrupted.get());, +    assertFalse(terminated.get());, +  }, +++ b/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java, +import static com.google.common.util.concurrent.MoreExecutors.shutdownAndAwaitTermination;, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +import static org.mockito.Mockito.times;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +  /* Half of a 1-second timeout in nanoseconds */, +  private static final long HALF_SECOND_NANOS = NANOSECONDS.convert(1L, SECONDS) / 2;, +, +  public void testShutdownAndAwaitTermination_immediateShutdown() throws Exception {, +    ExecutorService service = Executors.newSingleThreadExecutor();, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    assertTrue(service.isTerminated());, +  }, +, +  public void testShutdownAndAwaitTermination_immediateShutdownInternal() throws Exception {, +    ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)).thenReturn(true);, +    when(service.isTerminated()).thenReturn(true);, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));, +    verify(service).shutdown();, +    verify(service).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);, +  }, +, +  public void testShutdownAndAwaitTermination_forcedShutDownInternal() throws Exception {, +    ExecutorService service = mock(ExecutorService.class);, +    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)), +        .thenReturn(false).thenReturn(true);, +    when(service.isTerminated()).thenReturn(true);, +    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));]