[+++ b/guava/src/com/google/common/collect/FluentIterable.java, +   * e}, use {@code Stream.generate(() -> e)}. Otherwise, collect your stream into a collection and, +   * use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}., +++ b/guava/src/com/google/common/collect/FluentIterable.java, +   * e}, use {@code Stream.generate(() -> e)}. Otherwise, collect your stream into a collection and, +   * use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}., +++ b/guava/src/com/google/common/collect/Iterables.java, + * An assortment of mainly legacy static utility methods that operate on or return objects of type, + * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method, + * in the {@link Iterators} class., + * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed, + * by the new {@link java.util.stream.Stream} library. Read the method documentation below for, + * comparisons. This class is not being deprecated, but we gently encourage you to migrate to, + * streams., + *, + * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class, + * are <i>lazy</i>, which means that their iterators only advance the backing iteration when, + * absolutely necessary., + * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"> {@code, + * Iterables}</a>., +   * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code, +   * stream.collect(MoreCollectors.onlyElement())}., +   *, +   * @throws IllegalArgumentException if the iterable contains multiple elements, +   * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the, +   * iterable is empty., +   * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code, +   * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}., +   *, +   * @throws IllegalArgumentException if the iterator contains multiple elements, +   * Returns the number of elements in the specified iterable that equal the specified object. This, +   * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}., +   *, +   * <p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code, +   * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code, +   * stream.filter(Predicate.isEqual(element)).count()} instead., +   * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}., +   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code, +   * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code, +   * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}, +   * is empty., +   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You, +   * should use an explicit {@code break} or be certain that you will eventually remove all the, +   * elements., +   * <p>To cycle over the iterable {@code n} times, use the following: {@code, +   * Iterables.concat(Collections.nCopies(n, iterable))}, +   *, +   * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code, +   * Stream.generate(() -> iterable).flatMap(Streams::stream)}., +   * Returns an iterable whose iterators cycle indefinitely over the provided elements., +   *, +   * <p>After {@code remove} is invoked on a generated iterator, the removed element will no longer, +   * appear in either that iterator or any other iterator created from the same source iterable., +   * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}., +   * The iterator's {@code hasNext} method returns {@code true} until all of the original elements, +   * have been removed., +   *, +   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You, +   * should use an explicit {@code break} or be certain that you will eventually remove all the, +   * <p>To cycle over the elements {@code n} times, use the following: {@code, +   * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}, +   * <p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of, +   * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection, +   * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}., +   * Combines two iterables into a single iterable. The returned iterable has an iterator that, +   * traverses the elements in {@code a}, followed by the elements in {@code b}. The source, +   * iterators are not polled until necessary., +   * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input, +   * iterator supports it., +   *, +   * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code, +   * Stream.concat(a, b)}., +   * Combines three iterables into a single iterable. The returned iterable has an iterator that, +   * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the, +   * elements in {@code c}. The source iterators are not polled until necessary., +   * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input, +   * iterator supports it., +   *, +   * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code, +   * Streams.concat(a, b, c)}., +   * Combines four iterables into a single iterable. The returned iterable has an iterator that, +   * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the, +   * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not, +   * polled until necessary., +   * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input, +   * iterator supports it., +   *, +   * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code, +   * Streams.concat(a, b, c, d)}., +   * Combines multiple iterables into a single iterable. The returned iterable has an iterator that, +   * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled, +   * until necessary., +   * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input, +   * iterator supports it., +   *, +   * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code, +   * Streams.concat(...)}., +   * Combines multiple iterables into a single iterable. The returned iterable has an iterator that, +   * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled, +   * until necessary.]