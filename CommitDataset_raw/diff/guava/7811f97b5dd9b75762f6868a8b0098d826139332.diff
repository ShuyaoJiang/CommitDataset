[+++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +  RateLimiter(SleepingStopwatch stopwatch) {, +++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +  RateLimiter(SleepingStopwatch stopwatch) {, +++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.Semaphore;, +  /**, +   * Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit), +   * tryAcquire(1, timeout, unit)} uninterruptibly., +   *, +   * @since 18.0, +   */, +  public static boolean tryAcquireUninterruptibly(, +      Semaphore semaphore, long timeout, TimeUnit unit) {, +    return tryAcquireUninterruptibly(semaphore, 1, timeout, unit);, +  }, +, +  /**, +   * Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit), +   * tryAcquire(permits, timeout, unit)} uninterruptibly., +   *, +   * @since 18.0, +   */, +  public static boolean tryAcquireUninterruptibly(, +      Semaphore semaphore, int permits, long timeout, TimeUnit unit) {, +    boolean interrupted = false;, +    try {, +      long remainingNanos = unit.toNanos(timeout);, +      long end = System.nanoTime() + remainingNanos;, +, +      while (true) {, +        try {, +          // Semaphore treats negative timeouts just like zero., +          return semaphore.tryAcquire(permits, remainingNanos, NANOSECONDS);, +        } catch (InterruptedException e) {, +          interrupted = true;, +          remainingNanos = end - System.nanoTime();, +        }, +      }, +    } finally {, +      if (interrupted) {, +        Thread.currentThread().interrupt();, +      }, +    }, +  }, +]