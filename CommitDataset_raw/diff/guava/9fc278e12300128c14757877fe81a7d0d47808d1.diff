[+++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java, +  @Override public boolean contains(@Nullable Object element) {, +    AtomicInteger frequency = backingMap.get(element);, +    return frequency != null && frequency.get() > 0;, +  }, +, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java, +  @Override public boolean contains(@Nullable Object element) {, +    AtomicInteger frequency = backingMap.get(element);, +    return frequency != null && frequency.get() > 0;, +  }, +, +++ b/src/com/google/common/base/Equivalence.java, +import javax.annotation.Nullable;, +, +  boolean equivalent(@Nullable T a, @Nullable T b);, +  int hash(@Nullable T t);, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java, +  @Override public boolean contains(@Nullable Object element) {, +    AtomicInteger frequency = backingMap.get(element);, +    return frequency != null && frequency.get() > 0;, +  }, +, +++ b/src/com/google/common/base/Equivalence.java, +import javax.annotation.Nullable;, +, +  boolean equivalent(@Nullable T a, @Nullable T b);, +  int hash(@Nullable T t);, +++ b/src/com/google/common/base/Equivalences.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import javax.annotation.Nullable;, +, +   * value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns, +   * {@code 0} if passed a null value., +      public boolean equivalent(Object a, @Nullable Object b) {, +      public boolean equivalent(Object a, @Nullable Object b) {, +        return checkNotNull(a) == b;, +      public int hash(@Nullable Object o) {, +      public boolean equivalent(@Nullable Object a, @Nullable Object b) {, +      public int hash(@Nullable Object o) {, +        return (o == null) ? 0 : o.hashCode();, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java, +  @Override public boolean contains(@Nullable Object element) {, +    AtomicInteger frequency = backingMap.get(element);, +    return frequency != null && frequency.get() > 0;, +  }, +, +++ b/src/com/google/common/base/Equivalence.java, +import javax.annotation.Nullable;, +, +  boolean equivalent(@Nullable T a, @Nullable T b);, +  int hash(@Nullable T t);, +++ b/src/com/google/common/base/Equivalences.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import javax.annotation.Nullable;, +, +   * value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns, +   * {@code 0} if passed a null value., +      public boolean equivalent(Object a, @Nullable Object b) {, +      public boolean equivalent(Object a, @Nullable Object b) {, +        return checkNotNull(a) == b;, +      public int hash(@Nullable Object o) {, +      public boolean equivalent(@Nullable Object a, @Nullable Object b) {, +      public int hash(@Nullable Object o) {, +        return (o == null) ? 0 : o.hashCode();, +++ b/src/com/google/common/base/Objects.java, +   * @since 7 (source-compatible since 2), +   * @since 7 (source-compatible since 2), +    // TODO(kevinb): why are we not just appending directly to a StringBuilder?, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java, +  @Override public boolean contains(@Nullable Object element) {, +    AtomicInteger frequency = backingMap.get(element);, +    return frequency != null && frequency.get() > 0;, +  }, +, +++ b/src/com/google/common/base/Equivalence.java, +import javax.annotation.Nullable;, +, +  boolean equivalent(@Nullable T a, @Nullable T b);, +  int hash(@Nullable T t);, +++ b/src/com/google/common/base/Equivalences.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import javax.annotation.Nullable;, +, +   * value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns, +   * {@code 0} if passed a null value., +      public boolean equivalent(Object a, @Nullable Object b) {, +      public boolean equivalent(Object a, @Nullable Object b) {, +        return checkNotNull(a) == b;, +      public int hash(@Nullable Object o) {, +      public boolean equivalent(@Nullable Object a, @Nullable Object b) {, +      public int hash(@Nullable Object o) {, +        return (o == null) ? 0 : o.hashCode();, +++ b/src/com/google/common/base/Objects.java, +   * @since 7 (source-compatible since 2), +   * @since 7 (source-compatible since 2), +    // TODO(kevinb): why are we not just appending directly to a StringBuilder?]