[+++ b/guava-tests/test/com/google/common/util/concurrent/SimpleTimeLimiterTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +, +import com.google.common.base.Stopwatch;, +import com.google.common.collect.Range;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeoutException;, + * @author Jens Nyman, +, +  private static final long DELAY_MS = 50;, +  private static final long ENOUGH_MS = 500;, +  private static final long NOT_ENOUGH_MS = 5;, +, +  private static final String GOOD_CALLABLE_RESULT = "good callable result";, +  private static final Callable<String> GOOD_CALLABLE =, +      new Callable<String>() {, +        @Override, +        public String call() throws InterruptedException {, +          MILLISECONDS.sleep(DELAY_MS);, +          return GOOD_CALLABLE_RESULT;, +        }, +      };, +  private static final Callable<String> BAD_CALLABLE =, +      new Callable<String>() {, +        @Override, +        public String call() throws InterruptedException, SampleException {, +          MILLISECONDS.sleep(DELAY_MS);, +          throw new SampleException();, +        }, +      };, +  private static final Runnable GOOD_RUNNABLE =, +      new Runnable() {, +        @Override, +        public void run() {, +          try {, +            MILLISECONDS.sleep(DELAY_MS);, +          } catch (InterruptedException e) {, +            throw new RuntimeException(e);, +          }, +        }, +      };, +  private static final Runnable BAD_RUNNABLE =, +      new Runnable() {, +        @Override, +        public void run() {, +          try {, +            MILLISECONDS.sleep(DELAY_MS);, +          } catch (InterruptedException e) {, +            throw new RuntimeException(e);, +          }, +          throw new SampleRuntimeException();, +        }, +      };, +  private static final ExecutorService executor = Executors.newFixedThreadPool(1);, +  @Override, +  protected void setUp() throws Exception {, +  public void testNewProxy_goodMethodWithEnoughTime() throws Exception {, +    Sample proxy = service.newProxy(target, Sample.class, ENOUGH_MS, MILLISECONDS);, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +    String result = proxy.sleepThenReturnInput("x");, +, +    assertThat(result).isEqualTo("x");, +    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(DELAY_MS, ENOUGH_MS));, +    assertThat(target.finished).isTrue();, +  public void testNewProxy_goodMethodWithNotEnoughTime() throws Exception {, +    Sample proxy = service.newProxy(target, Sample.class, NOT_ENOUGH_MS, MILLISECONDS);, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(NOT_ENOUGH_MS, DELAY_MS * 2));, +    assertThat(target.finished).isFalse();, +    MILLISECONDS.sleep(ENOUGH_MS);, +    assertThat(target.finished).isFalse();, +  public void testNewProxy_badMethodWithEnoughTime() throws Exception {, +    Sample proxy = service.newProxy(target, Sample.class, ENOUGH_MS, MILLISECONDS);, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +, +    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(DELAY_MS, ENOUGH_MS));, +  public void testNewProxy_badMethodWithNotEnoughTime() throws Exception {, +    Sample proxy = service.newProxy(target, Sample.class, NOT_ENOUGH_MS, MILLISECONDS);, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +, +    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(NOT_ENOUGH_MS, DELAY_MS * 2));, +  public void testOldCallWithTimeout_goodCallableWithEnoughTime() throws Exception {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +    String result =, +        service.callWithTimeout(GOOD_CALLABLE, ENOUGH_MS, MILLISECONDS, true /* interruptible */);, +, +    assertThat(result).isEqualTo(GOOD_CALLABLE_RESULT);, +    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(DELAY_MS, ENOUGH_MS));, +  public void testOldCallWithTimeout_goodCallableWithNotEnoughTime() throws Exception {, +    Stopwatch stopwatch = Stopwatch.createStarted();, +, +    try {, +      service.callWithTimeout(, +          GOOD_CALLABLE, NOT_ENOUGH_MS, MILLISECONDS, false /* interruptible */);]