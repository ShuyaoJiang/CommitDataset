[+++ b/guava/src/com/google/common/collect/ImmutableMap.java, +  static final Entry<?, ?>[] EMPTY_ENTRY_ARRAY = new Entry<?, ?>[0];, +++ b/guava/src/com/google/common/collect/ImmutableMap.java, +  static final Entry<?, ?>[] EMPTY_ENTRY_ARRAY = new Entry<?, ?>[0];, +++ b/guava/src/com/google/common/collect/ImmutableSortedMap.java, +import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;, +import com.google.common.collect.ImmutableMapEntry.TerminalEntry;, +import java.util.Collection;, +    return of(Ordering.natural(), k1, v1);, +  }, +, +  /**, +   * Returns an immutable map containing a single entry., +   */, +  private static <K, V> ImmutableSortedMap<K, V> of(Comparator<? super K> comparator, K k1, V v1) {, +    return new RegularImmutableSortedMap<K, V>(, +        new RegularImmutableSortedSet<K>(ImmutableList.of(k1), checkNotNull(comparator)),, +        ImmutableList.of(v1));, +  }, +  , +  private static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V>, +      ofEntries(TerminalEntry<K, V>... entries) {, +    return fromEntries(Ordering.natural(), false, entries, entries.length);, +    return ofEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return ofEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));, +    return ofEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4));, +    return ofEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), , +        entryOf(k5, v5));, +    if (map instanceof ImmutableSortedMap) {, +      // TODO(kevinb): Prove that this cast is safe, even though, +      // Collections.unmodifiableSortedMap requires the same key type., +      @SuppressWarnings("unchecked"), +      ImmutableSortedMap<K, V> kvMap = (ImmutableSortedMap<K, V>) map;, +      if (!kvMap.isPartialView()) {, +        return kvMap; , +      }, +    }, +    return fromEntries(comparator, true, map.entrySet());, +    return fromEntries(comparator, sameComparator, map.entrySet());, +  }, +  /**, +   * Accepts a collection of possibly-null entries.  If {@code sameComparator}, then it is assumed , +   * that they do not need to be sorted or checked for dupes., +   */, +  private static <K, V> ImmutableSortedMap<K, V> fromEntries(, +      Comparator<? super K> comparator, boolean sameComparator, , +      Collection<? extends Entry<? extends K, ? extends V>> entries) {, +    Entry<K, V>[] entryArray = (Entry[]) entries.toArray(ImmutableMap.EMPTY_ENTRY_ARRAY);, +    return fromEntries(comparator, sameComparator, entryArray, entryArray.length);, +  private static <K, V> ImmutableSortedMap<K, V> fromEntries(Comparator<? super K> comparator,, +      boolean sameComparator, Entry<K, V>[] entryArray, int size) {, +    switch (size) {, +      case 0:, +        return emptyMap(comparator);, +      case 1:, +        return ImmutableSortedMap.<K, V>of(, +            comparator, entryArray[0].getKey(), entryArray[0].getValue());, +      default:, +        Object[] keys = new Object[size];, +        Object[] values = new Object[size];, +        if (sameComparator) {, +          // Need to check for nulls, but don't need to sort or validate., +            Object key = entryArray[i].getKey();, +            Object value = entryArray[i].getValue();, +            checkEntryNotNull(key, value);, +            keys[i] = key;, +            values[i] = value;, +        } else {, +          // Need to sort and check for nulls and dupes., +          Arrays.sort(entryArray, 0, size, , +              Ordering.from(comparator).<K>onKeys());, +          K prevKey = entryArray[0].getKey();, +          keys[0] = prevKey;, +          values[0] = entryArray[0].getValue();, +            K key = entryArray[i].getKey();, +            V value = entryArray[i].getValue();, +            checkEntryNotNull(key, value);, +            keys[i] = key;, +            values[i] = value;, +            checkNoConflict(comparator.compare(prevKey, key) != 0, "key",, +                entryArray[i - 1], entryArray[i]);, +            prevKey = key;, +          }, +        }, +        return new RegularImmutableSortedMap<K, V>(, +            new RegularImmutableSortedSet<K>(new RegularImmutableList<K>(keys), comparator),, +            new RegularImmutableList<V>(values));, +      switch (size) {, +        case 0:, +          return emptyMap(comparator);, +        case 1:, +          return of(comparator, entries[0].getKey(), entries[0].getValue());, +        default:, +          return fromEntries(comparator, false, entries, size);, +      }, +++ b/guava/src/com/google/common/collect/ImmutableMap.java, +  static final Entry<?, ?>[] EMPTY_ENTRY_ARRAY = new Entry<?, ?>[0];, +++ b/guava/src/com/google/common/collect/ImmutableSortedMap.java, +import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;, +import com.google.common.collect.ImmutableMapEntry.TerminalEntry;]