[+++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java, +import static org.mockito.Mockito.eq;, +import static org.mockito.Mockito.isA;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +    backingMap = mock(ConcurrentMap.class);, +    when(backingMap.isEmpty()).thenReturn(true);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(initial);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    } catch (IllegalArgumentException expected) {, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existingZero);, +    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(existingZero);, +    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.remove(KEY, current)).thenReturn(false);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.remove(KEY, current)).thenReturn(true);, +    when(backingMap.get(KEY)).thenReturn(null);, +++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java, +import static org.mockito.Mockito.eq;, +import static org.mockito.Mockito.isA;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +    backingMap = mock(ConcurrentMap.class);, +    when(backingMap.isEmpty()).thenReturn(true);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(initial);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    } catch (IllegalArgumentException expected) {, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existingZero);, +    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(existingZero);, +    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);, +    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(existing);, +    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(null);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.remove(KEY, current)).thenReturn(false);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.get(KEY)).thenReturn(current);, +    when(backingMap.remove(KEY, current)).thenReturn(true);, +    when(backingMap.get(KEY)).thenReturn(null);, +++ b/guava-tests/test/com/google/common/collect/ForwardingMapTest.java, +, +import static org.mockito.Mockito.anyObject;, +import static org.mockito.Mockito.atLeast;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.verifyNoMoreInteractions;, +    final Map<String, Boolean> map = mock(Map.class);, +    Map<String, Boolean> forward =, +        new ForwardingMap<String, Boolean>() {, +          @Override, +          protected Map<String, Boolean> delegate() {, +          @Override, +          public Set<Entry<String, Boolean>> entrySet() {, +                return Iterators.emptyIterator();, +    // These are the methods specified by StandardEntrySet, +    verify(map, atLeast(0)).clear();, +    verify(map, atLeast(0)).containsKey(anyObject());, +    verify(map, atLeast(0)).get(anyObject());, +    verify(map, atLeast(0)).isEmpty();, +    verify(map, atLeast(0)).remove(anyObject());, +    verify(map, atLeast(0)).size();, +    verifyNoMoreInteractions(map);, +    final Map<String, Boolean> map = mock(Map.class);, +    // These are the methods specified by StandardKeySet, +    verify(map, atLeast(0)).clear();, +    verify(map, atLeast(0)).containsKey(anyObject());, +    verify(map, atLeast(0)).isEmpty();, +    verify(map, atLeast(0)).remove(anyObject());, +    verify(map, atLeast(0)).size();, +    verify(map, atLeast(0)).entrySet();, +    verifyNoMoreInteractions(map);, +    final Map<String, Boolean> map = mock(Map.class);, +    // These are the methods specified by StandardValues]