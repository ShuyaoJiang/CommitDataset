[+++ b/guava/src/com/google/common/graph/ConfigurableNetwork.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableNetwork.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableValueGraph.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableNetwork.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableValueGraph.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/Graph.java, + * added to the {@link Graph} that would affect the collection, the collection will be updated, + * automatically. This also means that you cannot mutate a {@link Graph} in a way that would affect, + * a collection while iterating over that collection. For example, you cannot remove either {@code, + * foo} or any successors of {@code foo} from the graph while iterating over {@code successors(foo)}, + * (unless you first make a copy of the successors), just as you could not remove keys from a {@link, + * Map} while iterating over its {@link Map#keySet()}. Behavior in such a case is undefined, and may, + * result in {@link ConcurrentModificationException}., +++ b/guava/src/com/google/common/graph/ConfigurableNetwork.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableValueGraph.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/Graph.java, + * added to the {@link Graph} that would affect the collection, the collection will be updated, + * automatically. This also means that you cannot mutate a {@link Graph} in a way that would affect, + * a collection while iterating over that collection. For example, you cannot remove either {@code, + * foo} or any successors of {@code foo} from the graph while iterating over {@code successors(foo)}, + * (unless you first make a copy of the successors), just as you could not remove keys from a {@link, + * Map} while iterating over its {@link Map#keySet()}. Behavior in such a case is undefined, and may, + * result in {@link ConcurrentModificationException}., +++ b/guava/src/com/google/common/graph/Network.java, + * element is added to the {@link Network} that would affect the collection, the collection will be, + * updated automatically. This also means that you cannot mutate a {@link Network} in a way that, + * either {@code foo} or any successors of {@code foo} from the network while iterating over {@code, + * successors(foo)} (unless you first make a copy of the successors), just as you could not remove, + * keys from a {@link Map} while iterating over its {@link Map#keySet()}. Behavior in such a case is, + * undefined, and may result in {@link ConcurrentModificationException}., +++ b/guava/src/com/google/common/graph/ConfigurableNetwork.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/ConfigurableValueGraph.java, + * <p>Collection-returning accessors return unmodifiable views: the view returned will reflect, + * <p>The time complexity of all collection-returning accessors is O(1), since views are returned., +++ b/guava/src/com/google/common/graph/Graph.java, + * added to the {@link Graph} that would affect the collection, the collection will be updated, + * automatically. This also means that you cannot mutate a {@link Graph} in a way that would affect, + * a collection while iterating over that collection. For example, you cannot remove either {@code, + * foo} or any successors of {@code foo} from the graph while iterating over {@code successors(foo)}, + * (unless you first make a copy of the successors), just as you could not remove keys from a {@link, + * Map} while iterating over its {@link Map#keySet()}. Behavior in such a case is undefined, and may, + * result in {@link ConcurrentModificationException}., +++ b/guava/src/com/google/common/graph/Network.java, + * element is added to the {@link Network} that would affect the collection, the collection will be, + * updated automatically. This also means that you cannot mutate a {@link Network} in a way that, + * either {@code foo} or any successors of {@code foo} from the network while iterating over {@code, + * successors(foo)} (unless you first make a copy of the successors), just as you could not remove, + * keys from a {@link Map} while iterating over its {@link Map#keySet()}. Behavior in such a case is, + * undefined, and may result in {@link ConcurrentModificationException}., +++ b/guava/src/com/google/common/graph/ValueGraph.java, + * element is added to the {@link ValueGraph} that would affect the collection, the collection will, + * be updated automatically. This also means that you cannot mutate a {@link ValueGraph} in a way, + * that would affect a collection while iterating over that collection. For example, you cannot, + * remove either {@code foo} or any successors of {@code foo} from the graph while iterating over, + * {@code successors(foo)} (unless you first make a copy of the successors), just as you could not, + * remove keys from a {@link Map} while iterating over its {@link Map#keySet()}. Behavior in such a, + * case is undefined, and may result in {@link ConcurrentModificationException}.]