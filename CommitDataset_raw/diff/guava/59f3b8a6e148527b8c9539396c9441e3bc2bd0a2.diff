[+++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +import static com.google.common.truth.Truth.assertWithMessage;, +  /**, +   * This test attempts to cause a future to wait for longer than it was requested to from a timed, +   * get() call. As measurements of time are prone to flakiness, it tries to assert based on ranges, +   * derived from observing how much time actually passed for various operations., +   */, +    // Sleep for enough time to add 1500 milliseconds of overwait to the get() call., +    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);, +    Thread.sleep(toWaitMillis);, +    // It's possible to race and suspend the thread just before the park call actually takes effect,, +    // causing the thread to be suspended for 3.5 seconds, and then park itself for 2 seconds after, +    // being resumed. To avoid a flake in this scenario, calculate how long that thread actually, +    // waited and assert based on that time. Empirically, the race where the thread ends up waiting, +    // for 5.5 seconds happens about 2% of the time., +    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) >= 5;, +    // Count how long it actually took to return; we'll accept any number between the expected delay, +    // and the approximate actual delay, to be robust to variance in thread scheduling., +    char overWaitNanosFirstDigit =, +        Long.toString(, +                thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000)), +            .charAt(0);, +    if (overWaitNanosFirstDigit < '4') {, +      overWaitNanosFirstDigit = '9';, +    }, +    String nanosRegex = "[4-" + overWaitNanosFirstDigit + "][0-9]+";, +    assertWithMessage(, +            "Spent " + thread.timeSpentBlocked + " ns blocked; slept for " + toWaitMillis + " ms"), +        .that(thread.exception), +        .matches(, +            "Waited 2 seconds \\(plus ", +                + (longWait ? "3" : "1"), +                + " seconds, ", +                + nanosRegex, +                + " nanoseconds delay\\).*");, +      return getState() == Thread.State.WAITING && LockSupport.getBlocker(this) == future;, +    private volatile long startTime;, +    private long timeSpentBlocked;, +      startTime = System.nanoTime();, +      } finally {, +        timeSpentBlocked = System.nanoTime() - startTime;, +      return getState() == Thread.State.TIMED_WAITING && LockSupport.getBlocker(this) == future;, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +import static com.google.common.truth.Truth.assertWithMessage;, +  /**, +   * This test attempts to cause a future to wait for longer than it was requested to from a timed, +   * get() call. As measurements of time are prone to flakiness, it tries to assert based on ranges, +   * derived from observing how much time actually passed for various operations., +   */, +    // Sleep for enough time to add 1500 milliseconds of overwait to the get() call., +    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);, +    Thread.sleep(toWaitMillis);, +    // It's possible to race and suspend the thread just before the park call actually takes effect,, +    // causing the thread to be suspended for 3.5 seconds, and then park itself for 2 seconds after, +    // being resumed. To avoid a flake in this scenario, calculate how long that thread actually, +    // waited and assert based on that time. Empirically, the race where the thread ends up waiting, +    // for 5.5 seconds happens about 2% of the time., +    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) >= 5;, +    // Count how long it actually took to return; we'll accept any number between the expected delay, +    // and the approximate actual delay, to be robust to variance in thread scheduling., +    char overWaitNanosFirstDigit =, +        Long.toString(, +                thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000)), +            .charAt(0);, +    if (overWaitNanosFirstDigit < '4') {, +      overWaitNanosFirstDigit = '9';, +    }, +    String nanosRegex = "[4-" + overWaitNanosFirstDigit + "][0-9]+";, +    assertWithMessage(, +            "Spent " + thread.timeSpentBlocked + " ns blocked; slept for " + toWaitMillis + " ms"), +        .that(thread.exception), +        .matches(, +            "Waited 2 seconds \\(plus ", +                + (longWait ? "3" : "1"), +                + " seconds, ", +                + nanosRegex, +                + " nanoseconds delay\\).*");, +      return getState() == Thread.State.WAITING && LockSupport.getBlocker(this) == future;, +    private volatile long startTime;, +    private long timeSpentBlocked;, +      startTime = System.nanoTime();, +      } finally {, +        timeSpentBlocked = System.nanoTime() - startTime;, +      return getState() == Thread.State.TIMED_WAITING && LockSupport.getBlocker(this) == future;, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +import static com.google.common.truth.Truth.assertWithMessage;, +  /**, +   * This test attempts to cause a future to wait for longer than it was requested to from a timed, +   * get() call. As measurements of time are prone to flakiness, it tries to assert based on ranges, +   * derived from observing how much time actually passed for various operations., +   */, +    // Sleep for enough time to add 1500 milliseconds of overwait to the get() call., +    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);, +    Thread.sleep(toWaitMillis);, +    // It's possible to race and suspend the thread just before the park call actually takes effect,, +    // causing the thread to be suspended for 3.5 seconds, and then park itself for 2 seconds after, +    // being resumed. To avoid a flake in this scenario, calculate how long that thread actually, +    // waited and assert based on that time. Empirically, the race where the thread ends up waiting, +    // for 5.5 seconds happens about 2% of the time., +    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) >= 5;]