[+++ b/guava/src/com/google/common/collect/BstRangeOps.java, +   * An integer-valued function on binary search tree nodes that adds between nodes., +  public interface BstAggregate<N extends BstNode<?, N>> {, +    /**, +     * The total value on an entire subtree. Must be equal to the sum of the {@link #entryValue, +     * entryValue} of this node and all its descendants., +     */, +    int treeValue(@Nullable N tree);, +, +    /**, +     * The value on a single entry, ignoring its descendants., +     */, +    int entryValue(N entry);, +  }, +, +  private enum CountAggregate implements BstAggregate {, +    INSTANCE {, +      @Override, +      public int entryValue(BstNode entry) {, +        return 1;, +      }, +, +      @SuppressWarnings("unchecked"), +      @Override, +      public int treeValue(@Nullable BstNode tree) {, +        return countOrZero(tree);, +      }, +    };, +  }, +, +  /**, +   * Returns a {@link BstAggregate} counting the number of nodes., +   */, +  @SuppressWarnings("unchecked"), +  public static <N extends BstNode<?, N>> BstAggregate<N> countAggregate() {, +    return CountAggregate.INSTANCE;, +  }, +, +  /**, +   * Returns the total value of the specified aggregation function on the specified tree restricted, +   * to the specified range. Assumes that the tree satisfies the binary search ordering property, +   * relative to {@code range.comparator()}., +   */, +  public static <K, N extends BstNode<K, N>> int totalInRange(, +      BstAggregate<? super N> aggregate, GeneralRange<K> range, @Nullable N root) {, +    checkNotNull(aggregate);, +    checkNotNull(range);, +    int total = aggregate.treeValue(root);, +      total -= totalTooLow(aggregate, range, root);, +      total -= totalTooHigh(aggregate, range, root);, +    return total;, +  // Returns total value strictly below the specified range., +  private static <K, N extends BstNode<K, N>> int totalTooLow(, +      BstAggregate<? super N> aggregate, GeneralRange<K> range, @Nullable N root) {, +    int accum = 0;, +    while (root != null) {, +      if (range.tooLow(root.getKey())) {, +        accum += aggregate.entryValue(root);, +        accum += aggregate.treeValue(root.childOrNull(LEFT));, +        root = root.childOrNull(RIGHT);, +        root = root.childOrNull(LEFT);, +    return accum;, +  }, +  private static <K, N extends BstNode<K, N>> int totalTooHigh(, +      BstAggregate<? super N> aggregate, GeneralRange<K> range, @Nullable N root) {, +    int accum = 0;, +    while (root != null) {, +      if (range.tooHigh(root.getKey())) {, +        accum += aggregate.entryValue(root);, +        accum += aggregate.treeValue(root.childOrNull(RIGHT));, +        root = root.childOrNull(LEFT);, +        root = root.childOrNull(RIGHT);, +    return accum;, +  }, +   * Returns the furthest path to the specified side in the specified tree that falls into the, +   * specified range., +  public static <K, N extends BstNode<K, N>, P extends BstPath<N, P>> P furthestPath(, +      GeneralRange<K> range, BstSide side, BstPathFactory<N, P> pathFactory, @Nullable N root) {, +    checkNotNull(side);, +    if (root == null) {, +      return null;, +    }, +    P path = pathFactory.initialPath(root);, +    return furthestPath(range, side, pathFactory, path);, +  }, +, +  private static <K, N extends BstNode<K, N>, P extends BstPath<N, P>> P furthestPath(, +      GeneralRange<K> range, BstSide side, BstPathFactory<N, P> pathFactory, P currentPath) {, +    N tip = currentPath.getTip();, +    K tipKey = tip.getKey();, +    if (beyond(range, tipKey, side)) {, +      if (tip.hasChild(side.other())) {, +        currentPath = pathFactory.extension(currentPath, side.other());, +        return furthestPath(range, side, pathFactory, currentPath);, +      } else {, +        return null;, +      }, +    } else if (tip.hasChild(side)) {, +      P alphaPath = pathFactory.extension(currentPath, side);, +      alphaPath = furthestPath(range, side, pathFactory, alphaPath);]