[+++ b/src/com/google/common/collect/MinMaxPriorityQueue.java, +    E actualLastElement = elementData(size);, +    int lastElementAt = heapForIndex(size), +        .getCorrectLastElement(actualLastElement);, +    MoveDesc<E> changes = fillHole(index, toTrickle);, +    if (lastElementAt < index) {, +      // Last element is moved to before index, swapped with trickled element., +      if (changes == null) {, +        // The trickled element is still after index., +        return new MoveDesc<E>(actualLastElement, toTrickle);, +      } else {, +        // The trickled element is back before index, but the replaced element, +        // has now been moved after index., +        return new MoveDesc<E>(actualLastElement, changes.replaced);, +      }, +    }, +    // Trickled element was after index to begin with, no adjustment needed., +    return changes;, +  }, +, +  private MoveDesc<E> fillHole(int index, E toTrickle) {, +        // This is a guard for the case of the childless uncle., +        // Since the end of the array is actually the middle of the heap,, +        // a smaller childless uncle can become a child of x when we, +        // bubble up alternate levels, violating the invariant., +        if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size) {, +     * Returns the conceptually correct last element of the heap., +     *, +     * <p>Since the last element of the array is actually in the, +     * middle of the sorted structure, a childless uncle node could be, +     * smaller, which would corrupt the invariant if this element, +     * becomes the new parent of the uncle. In that case, we first, +     * switch the last element with its uncle, before returning., +     */, +    int getCorrectLastElement(E actualLastElement) {, +      int parentIndex = getParentIndex(size);, +      if (parentIndex != 0) {, +        int grandparentIndex = getParentIndex(parentIndex);, +        int uncleIndex = getRightChildIndex(grandparentIndex);, +        if (uncleIndex != parentIndex, +            && getLeftChildIndex(uncleIndex) >= size) {, +          E uncleElement = elementData(uncleIndex);, +          if (ordering.compare(uncleElement, actualLastElement) < 0) {, +            queue[uncleIndex] = actualLastElement;, +            queue[size] = uncleElement;, +            return uncleIndex;, +          }, +        }, +      }, +      return size;, +    }, +, +    /**]