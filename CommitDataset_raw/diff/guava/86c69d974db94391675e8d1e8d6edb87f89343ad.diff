[+++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava/src/com/google/common/util/concurrent/Futures.java, +   * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation, +   * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future., +   * ListenableFuture<String> dereferenced = dereference(nested);, +   * }</pre>, +   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code, +   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and, +   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in, +   * the same thread (either the thread that called {@code dereference}, or the thread in which the, +   * dereferenced future completes)., +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava/src/com/google/common/util/concurrent/Futures.java, +   * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation, +   * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future., +   * ListenableFuture<String> dereferenced = dereference(nested);, +   * }</pre>, +   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code, +   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and, +   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in, +   * the same thread (either the thread that called {@code dereference}, or the thread in which the, +   * dereferenced future completes)., +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava/src/com/google/common/util/concurrent/Futures.java, +   * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation, +   * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future., +   * ListenableFuture<String> dereferenced = dereference(nested);, +   * }</pre>, +   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code, +   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and, +   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in, +   * the same thread (either the thread that called {@code dereference}, or the thread in which the, +   * dereferenced future completes)., +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/android/guava/src/com/google/common/util/concurrent/Futures.java, +   * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation, +   * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future., +   * ListenableFuture<String> dereferenced = dereference(nested);, +   * }</pre>, +   * #transformAsync(ListenableFuture, AsyncFunction, Executor)}, in that the returned {@code, +   * Future} attempts to keep its cancellation state in sync with both the input {@code Future} and, +   * the nested {@code Future}. The transformation is very lightweight and therefore takes place in, +   * the same thread (either the thread that called {@code dereference}, or the thread in which the, +   * dereferenced future completes)., +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTransformTest.java, + * Unit tests for {@link Futures#transform(ListenableFuture, Function, Executor)}., +public class FuturesTransformTest extends AbstractChainedListenableFutureTest<String> {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, + * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link, + * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,, + * java.util.concurrent.Executor) Futures.catching}., +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +   * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation, +   * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future., +   * ListenableFuture<String> dereferenced = dereference(nested);, +   * }</pre>]