[+++ b/guava/src/com/google/common/base/Converter.java, +   * Returns a representation of {@code a} as an instance of type {@code B}. If {@code a} cannot be, +   * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown., +   * Returns a representation of {@code b} as an instance of type {@code A}. If {@code b} cannot be, +   * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown., +   * @throws UnsupportedOperationException if backward conversion is not implemented; this should be, +   *     very rare. Note that if backward conversion is not only unimplemented but, +   *     unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),, +   *     then this is not logically a {@code Converter} at all, and should just implement {@link, +   *     Function}., +      // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?, +      // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?, +  // Static converters, +, +  private static final class FunctionBasedConverter<A, B>, +      extends Converter<A, B> implements Serializable {, +    private final Function<? super A, ? extends B> forwardFunction;, +    private final Function<? super B, ? extends A> backwardFunction;, +, +    private FunctionBasedConverter(, +        Function<? super A, ? extends B> forwardFunction,, +        Function<? super B, ? extends A> backwardFunction) {, +      this.forwardFunction = checkNotNull(forwardFunction);, +      this.backwardFunction = checkNotNull(backwardFunction);, +    }, +, +    @Override protected B doForward(A a) {, +      return forwardFunction.apply(a);, +    }, +, +    @Override protected A doBackward(B b) {, +      return backwardFunction.apply(b);, +    }, +, +    @Override public boolean equals(@Nullable Object object) {, +      if (object instanceof FunctionBasedConverter) {, +        FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;, +        return this.forwardFunction.equals(that.forwardFunction), +            && this.backwardFunction.equals(that.backwardFunction);, +      }, +      return false;, +    }, +, +    @Override public int hashCode() {, +      return forwardFunction.hashCode() * 31 + backwardFunction.hashCode();, +    }, +, +    @Override public String toString() {, +      return "Converter.from(" + forwardFunction + ", " + backwardFunction + ")";, +    }, +  }]