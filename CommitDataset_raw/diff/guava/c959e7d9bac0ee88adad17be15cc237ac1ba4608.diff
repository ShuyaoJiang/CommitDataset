[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  public void testBitSize() {, +          BloomFilter.create(Funnels.stringFunnel(), i, fpp).bitSize());, +  public void testPutAll() {, +    assertTrue(bf1.isCompatible(bf2));, +    bf1.putAll(bf2);, +  public void testPutAllDifferentSizes() {, +      assertFalse(bf1.isCompatible(bf2));, +      bf1.putAll(bf2);, +      assertFalse(bf2.isCompatible(bf1));, +      bf2.putAll(bf1);, +  public void testPutAllWithSelf() {, +      assertFalse(bf1.isCompatible(bf1));, +      bf1.putAll(bf1);, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  public void testBitSize() {, +          BloomFilter.create(Funnels.stringFunnel(), i, fpp).bitSize());, +  public void testPutAll() {, +    assertTrue(bf1.isCompatible(bf2));, +    bf1.putAll(bf2);, +  public void testPutAllDifferentSizes() {, +      assertFalse(bf1.isCompatible(bf2));, +      bf1.putAll(bf2);, +      assertFalse(bf2.isCompatible(bf1));, +      bf2.putAll(bf1);, +  public void testPutAllWithSelf() {, +      assertFalse(bf1.isCompatible(bf1));, +      bf1.putAll(bf1);, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +    return Math.pow((double) bits.bitCount() / bitSize(), numHashFunctions);, +  @VisibleForTesting long bitSize() {, +    return bits.bitSize();, +   * Determines whether a given bloom filter is compatible with this bloom filter. For two, +   * <li>have the same bit size, +   * @param that The bloom filter to check for compatibility., +  public boolean isCompatible(BloomFilter that) {, +        (this.bitSize() == that.bitSize()) &&, +   * Combines this bloom filter with another bloom filter by performing a bitwise OR of the, +   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the, +   * bloom filters are appropriately sized to avoid saturating them., +   * @param that The bloom filter to combine this bloom filter with. It is not mutated., +   * @throws IllegalArgumentException if {@code isCompatible(that) == false}, +  public void putAll(BloomFilter that) {, +    checkArgument(this != that, "Cannot combine a BloomFilter with itself.");, +    checkArgument(this.bitSize() == that.bitSize(),, +        this.bitSize(), that.bitSize());, +    this.bits.putAll(that.bits);, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  public void testBitSize() {, +          BloomFilter.create(Funnels.stringFunnel(), i, fpp).bitSize());, +  public void testPutAll() {, +    assertTrue(bf1.isCompatible(bf2));, +    bf1.putAll(bf2);, +  public void testPutAllDifferentSizes() {, +      assertFalse(bf1.isCompatible(bf2));, +      bf1.putAll(bf2);, +      assertFalse(bf2.isCompatible(bf1));, +      bf2.putAll(bf1);, +  public void testPutAllWithSelf() {, +      assertFalse(bf1.isCompatible(bf1));, +      bf1.putAll(bf1);, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +    return Math.pow((double) bits.bitCount() / bitSize(), numHashFunctions);, +  @VisibleForTesting long bitSize() {, +    return bits.bitSize();, +   * Determines whether a given bloom filter is compatible with this bloom filter. For two, +   * <li>have the same bit size, +   * @param that The bloom filter to check for compatibility., +  public boolean isCompatible(BloomFilter that) {, +        (this.bitSize() == that.bitSize()) &&, +   * Combines this bloom filter with another bloom filter by performing a bitwise OR of the, +   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the, +   * bloom filters are appropriately sized to avoid saturating them., +   * @param that The bloom filter to combine this bloom filter with. It is not mutated., +   * @throws IllegalArgumentException if {@code isCompatible(that) == false}, +  public void putAll(BloomFilter that) {, +    checkArgument(this != that, "Cannot combine a BloomFilter with itself.");, +    checkArgument(this.bitSize() == that.bitSize(),, +        this.bitSize(), that.bitSize());, +    this.bits.putAll(that.bits);, +++ b/guava/src/com/google/common/hash/BloomFilterStrategies.java, +        bitsChanged |= bits.set(nextHash % bits.bitSize());, +        if (!bits.get(nextHash % bits.bitSize())) {, +    int bitSize() {, +    /** Combines the two BitArrays using bitwise OR. */, +    void putAll(BitArray array) {]