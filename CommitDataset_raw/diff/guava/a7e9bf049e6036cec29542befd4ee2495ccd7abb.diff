[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +        /*, +         * If we're about to complete the TimeoutFuture, we want to release our reference to it., +         * Otherwise, we'll pin it (and its result) in memory until the timeout task is GCed. (The, +         * need to clear our reference to the TimeoutFuture is the reason we use a *static* nested, +         * class with a manual reference back to the "containing" class.), +         *, +         * This has the nice-ish side effect of limiting reentrancy: run() calls, +         * timeoutFuture.setException() calls run(). That reentrancy would already be harmless,, +         * since timeoutFuture can be set (and delegate cancelled) only once. (And "set only once", +         * is important for other reasons: run() can still be invoked concurrently in different, +         * threads, even with the above null checks.), +         */, +          } finally {, +            delegate.cancel(true);, +      maybePropagateCancellation(delegateRef);, +      Future<?> localTimer = timer;, +      // Try to cancel the timer as an optimization, +      // timer may be null if this call to run was by the timer task since there is no, +      // happens-before edge between the assignment to timer and an execution of the timer task., +, +      delegateRef = null;, +      timer = null;, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +        /*, +         * If we're about to complete the TimeoutFuture, we want to release our reference to it., +         * Otherwise, we'll pin it (and its result) in memory until the timeout task is GCed. (The, +         * need to clear our reference to the TimeoutFuture is the reason we use a *static* nested, +         * class with a manual reference back to the "containing" class.), +         *, +         * This has the nice-ish side effect of limiting reentrancy: run() calls, +         * timeoutFuture.setException() calls run(). That reentrancy would already be harmless,, +         * since timeoutFuture can be set (and delegate cancelled) only once. (And "set only once", +         * is important for other reasons: run() can still be invoked concurrently in different, +         * threads, even with the above null checks.), +         */, +          } finally {, +            delegate.cancel(true);, +      maybePropagateCancellation(delegateRef);, +      Future<?> localTimer = timer;, +      // Try to cancel the timer as an optimization, +      // timer may be null if this call to run was by the timer task since there is no, +      // happens-before edge between the assignment to timer and an execution of the timer task., +, +      delegateRef = null;, +      timer = null;, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +        /*, +         * If we're about to complete the TimeoutFuture, we want to release our reference to it., +         * Otherwise, we'll pin it (and its result) in memory until the timeout task is GCed. (The, +         * need to clear our reference to the TimeoutFuture is the reason we use a *static* nested, +         * class with a manual reference back to the "containing" class.), +         *, +         * This has the nice-ish side effect of limiting reentrancy: run() calls, +         * timeoutFuture.setException() calls run(). That reentrancy would already be harmless,, +         * since timeoutFuture can be set (and delegate cancelled) only once. (And "set only once", +         * is important for other reasons: run() can still be invoked concurrently in different, +         * threads, even with the above null checks.), +         */, +          } finally {, +            delegate.cancel(true);, +      maybePropagateCancellation(delegateRef);, +      Future<?> localTimer = timer;, +      // Try to cancel the timer as an optimization, +      // timer may be null if this call to run was by the timer task since there is no, +      // happens-before edge between the assignment to timer and an execution of the timer task., +, +      delegateRef = null;, +      timer = null;]