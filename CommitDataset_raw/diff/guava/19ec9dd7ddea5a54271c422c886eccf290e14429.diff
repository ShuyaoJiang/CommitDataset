[+++ b/guava/src/com/google/common/collect/ComputingCache.java, +import com.google.common.collect.CustomConcurrentHashMap.ReferenceEntry;, +    private final ComputingConcurrentHashMap<K, V> delegate;, +    CacheAsMap(ComputingConcurrentHashMap<K, V> delegate) {, +    public V get(@Nullable Object key) {, +      ReferenceEntry<K, V> e = delegate.getEntry(key);, +      return (e == null) ? null : e.getValueReference().get();, +    }, +, +    @Override, +++ b/guava/src/com/google/common/collect/ComputingCache.java, +import com.google.common.collect.CustomConcurrentHashMap.ReferenceEntry;, +    private final ComputingConcurrentHashMap<K, V> delegate;, +    CacheAsMap(ComputingConcurrentHashMap<K, V> delegate) {, +    public V get(@Nullable Object key) {, +      ReferenceEntry<K, V> e = delegate.getEntry(key);, +      return (e == null) ? null : e.getValueReference().get();, +    }, +, +    @Override, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          // don't call getLiveEntry, which would ignore computing values, +++ b/guava/src/com/google/common/collect/ComputingCache.java, +import com.google.common.collect.CustomConcurrentHashMap.ReferenceEntry;, +    private final ComputingConcurrentHashMap<K, V> delegate;, +    CacheAsMap(ComputingConcurrentHashMap<K, V> delegate) {, +    public V get(@Nullable Object key) {, +      ReferenceEntry<K, V> e = delegate.getEntry(key);, +      return (e == null) ? null : e.getValueReference().get();, +    }, +, +    @Override, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          // don't call getLiveEntry, which would ignore computing values, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +  /**, +   * Gets the value from an entry. Returns null if the entry is invalid, partially-collected,, +   * computing, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to, +   * cleanup stale entries., +   */, +  V getLiveValue(ReferenceEntry<K, V> entry) {, +    if (entry.getKey() == null) {, +      return null;, +    }, +    V value = entry.getValueReference().get();, +    if (value == null) {, +      return null;, +    }, +, +    if (expires() && isExpired(entry)) {, +      return null;, +    }, +    return value;, +  }, +, +            tryDrainReferenceQueues();, +    ReferenceEntry<K, V> getLiveEntry(Object key, int hash) {, +      ReferenceEntry<K, V> e = getEntry(key, hash);, +      if (e == null) {, +        return null;, +      } else if (map.expires() && map.isExpired(e)) {, +        tryExpireEntries();, +        return null;, +      }, +      return e;, +    }, +, +        ReferenceEntry<K, V> e = getLiveEntry(key, hash);, +        if (e == null) {, +          return null;, +        }, +, +        V value = e.getValueReference().get();, +        } else {, +          tryDrainReferenceQueues();, +          ReferenceEntry<K, V> e = getLiveEntry(key, hash);, +          if (e == null) {, +            return false;, +          return e.getValueReference().get() != null;, +   * Returns the internal entry for the specified key. The entry may be computing, expired, or, +   * partially collected. Does not impact recency ordering., +  ReferenceEntry<K, V> getEntry(@Nullable Object key) {, +    if (key == null) {, +      return null;, +    }, +  /**, +   * Returns the live internal entry for the specified key. Does not impact recency ordering., +   */, +  ReferenceEntry<K, V> getLiveEntry(@Nullable Object key) {, +    if (key == null) {, +      return null;, +    }, +    int hash = hash(key);, +    return segmentFor(hash).getLiveEntry(key, hash);, +  }, +, +        V value = getLiveValue(entry);, +        if (value != null) {, +          // Skip stale entry., +++ b/guava/src/com/google/common/collect/ComputingCache.java]