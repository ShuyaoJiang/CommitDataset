[+++ b/android/guava/src/com/google/common/collect/FluentIterable.java, +    return concatNoDefensiveCopy(a, b);, +    return concatNoDefensiveCopy(a, b, c);, +    return concatNoDefensiveCopy(a, b, c, d);, +    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));, +, +  /**, +   * Concatenates a varargs array of iterables without making a defensive copy of the array., +   */, +  private static <T> FluentIterable<T> concatNoDefensiveCopy(, +      final Iterable<? extends T>... inputs) {, +    for (Iterable<? extends T> input : inputs) {, +      checkNotNull(input);, +    }, +    return new FluentIterable<T>() {, +      @Override, +      public Iterator<T> iterator() {, +        @SuppressWarnings("unchecked"), +        Iterator<? extends T>[] iterators = new Iterator[inputs.length];, +        for (int i = 0; i < inputs.length; i++) {, +          iterators[i] = inputs[i].iterator();, +        }, +        return Iterators.concatNoDefensiveCopy(iterators);, +      }, +    };, +        return Iterators.concat(Iterators.transform(inputs.iterator(), Iterables.<T>toIterator()));, +++ b/android/guava/src/com/google/common/collect/FluentIterable.java, +    return concatNoDefensiveCopy(a, b);, +    return concatNoDefensiveCopy(a, b, c);, +    return concatNoDefensiveCopy(a, b, c, d);, +    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));, +, +  /**, +   * Concatenates a varargs array of iterables without making a defensive copy of the array., +   */, +  private static <T> FluentIterable<T> concatNoDefensiveCopy(, +      final Iterable<? extends T>... inputs) {, +    for (Iterable<? extends T> input : inputs) {, +      checkNotNull(input);, +    }, +    return new FluentIterable<T>() {, +      @Override, +      public Iterator<T> iterator() {, +        @SuppressWarnings("unchecked"), +        Iterator<? extends T>[] iterators = new Iterator[inputs.length];, +        for (int i = 0; i < inputs.length; i++) {, +          iterators[i] = inputs[i].iterator();, +        }, +        return Iterators.concatNoDefensiveCopy(iterators);, +      }, +    };, +        return Iterators.concat(Iterators.transform(inputs.iterator(), Iterables.<T>toIterator()));, +++ b/android/guava/src/com/google/common/collect/Iterators.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +   * Returns an Iterator that walks the specified array, nulling out elements behind it., +   * This can avoid memory leaks when an element is no longer necessary., +   *, +   * This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator., +   */, +  private static <T> Iterator<T> consumingForArray(final T... elements) {, +    return new UnmodifiableIterator<T>() {, +      int index = 0;, +, +      @Override, +      public boolean hasNext() {, +        return index < elements.length;, +      }, +, +      @Override, +      public T next() {, +        if (!hasNext()) {, +          throw new NoSuchElementException();, +        }, +        T result = elements[index];, +        elements[index] = null;, +        index++;, +        return result;, +      }, +    };, +  }, +, +  /**, +    return concat(consumingForArray(a, b));, +    return concat(consumingForArray(a, b, c));, +    return concat(consumingForArray(a, b, c, d));, +    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));, +  }, +, +  /**, +   * Concats a varargs array of iterators without making a defensive copy of the array., +   */, +  static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs) {, +    return concat(consumingForArray(inputs));, +  private static class ConcatenatedIterator<T> implements Iterator<T> {, +    private Iterator<? extends T> toRemove;, +    private Iterator<? extends T> iterator = emptyIterator();, +    private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;, +, +    ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {]