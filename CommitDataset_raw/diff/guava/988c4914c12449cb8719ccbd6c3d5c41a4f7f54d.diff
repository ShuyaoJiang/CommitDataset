[+++ b/guava/src/com/google/common/cache/CustomConcurrentHashMap.java, +                    V value = e.getValueReference().get();, +                    if (value == null) {, +                      enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    } else if (map.expires() && map.isExpired(e)) {, +                      // This is a duplicate check, as preWriteCleanup already purged expired, +                      // entries, but let's accomodate an incorrect expiration queue., +                      enqueueNotification(entryKey, hash, value, RemovalCause.EXPIRED);, +                    } else {, +, +                    // immediately reuse invalid entries, +++ b/guava/src/com/google/common/cache/CustomConcurrentHashMap.java, +                    V value = e.getValueReference().get();, +                    if (value == null) {, +                      enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    } else if (map.expires() && map.isExpired(e)) {, +                      // This is a duplicate check, as preWriteCleanup already purged expired, +                      // entries, but let's accomodate an incorrect expiration queue., +                      enqueueNotification(entryKey, hash, value, RemovalCause.EXPIRED);, +                    } else {, +, +                    // immediately reuse invalid entries, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                    V value = e.getValueReference().get();, +                    if (value == null) {, +                      enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    } else if (map.expires() && map.isExpired(e)) {, +                      // This is a duplicate check, as preWriteCleanup already purged expired, +                      // entries, but let's accomodate an incorrect expiration queue., +                      enqueueNotification(entryKey, hash, value, RemovalCause.EXPIRED);, +                    } else {, +, +                    // immediately reuse invalid entries]