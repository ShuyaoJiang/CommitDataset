[+++ /dev/null, +++ /dev/null, +++ b/guava/src/com/google/common/base/Equivalence.java, +public interface Equivalence<T> {, +  boolean equivalent(@Nullable T a, @Nullable T b);, +   * Returns a hash code for {@code object}. This function <b>must</b> return the same value for, +   * any two references which are {@link #equivalent}, and should as often as possible return a, +   * distinct value for references which are not equivalent. It should support null references., +   *, +   * @see Object#hashCode the same contractual obligations apply here, +  int hash(@Nullable T t);, +++ /dev/null, +++ b/guava/src/com/google/common/base/Equivalence.java, +public interface Equivalence<T> {, +  boolean equivalent(@Nullable T a, @Nullable T b);, +   * Returns a hash code for {@code object}. This function <b>must</b> return the same value for, +   * any two references which are {@link #equivalent}, and should as often as possible return a, +   * distinct value for references which are not equivalent. It should support null references., +   *, +   * @see Object#hashCode the same contractual obligations apply here, +  int hash(@Nullable T t);, +++ b/guava/src/com/google/common/base/EquivalenceWrapper.java, + *   Equivalences.wrap(equiv, "a").equals(Equivalences.wrap(equiv, "b")) // true, + *   Equivalences.wrap(equiv, "a").equals(Equivalences.wrap(equiv, "hello")) // false, + *   Equivalences.wrap(equiv, obj).equals(obj) // always false, +   * Returns the result of {@link Equivalence#hash(Object)} applied to the the wrapped reference., +   */, +  @Override public int hashCode() {, +    return equivalence.hash(reference);, +  }, +, +  /**, +    return Objects.toStringHelper(this), +        .add("equivalence", equivalence), +        .add("value", reference), +        .toString();, +++ /dev/null, +++ b/guava/src/com/google/common/base/Equivalence.java, +public interface Equivalence<T> {, +  boolean equivalent(@Nullable T a, @Nullable T b);, +   * Returns a hash code for {@code object}. This function <b>must</b> return the same value for, +   * any two references which are {@link #equivalent}, and should as often as possible return a, +   * distinct value for references which are not equivalent. It should support null references., +   *, +   * @see Object#hashCode the same contractual obligations apply here, +  int hash(@Nullable T t);, +++ b/guava/src/com/google/common/base/EquivalenceWrapper.java, + *   Equivalences.wrap(equiv, "a").equals(Equivalences.wrap(equiv, "b")) // true, + *   Equivalences.wrap(equiv, "a").equals(Equivalences.wrap(equiv, "hello")) // false, + *   Equivalences.wrap(equiv, obj).equals(obj) // always false, +   * Returns the result of {@link Equivalence#hash(Object)} applied to the the wrapped reference., +   */, +  @Override public int hashCode() {, +    return equivalence.hash(reference);, +  }, +, +  /**, +    return Objects.toStringHelper(this), +        .add("equivalence", equivalence), +        .add("value", reference), +        .toString();, +++ b/guava/src/com/google/common/base/Equivalences.java, +import javax.annotation.Nullable;, +    return Impl.EQUALS;, +    return Impl.IDENTITY;, +  private enum Impl implements Equivalence<Object> {, +    EQUALS {, +      @Override, +      public boolean equivalent(@Nullable Object a, @Nullable Object b) {, +        return (a == null) ? (b == null) : a.equals(b);, +      @Override, +      public int hash(@Nullable Object o) {, +        return (o == null) ? 0 : o.hashCode();, +      }, +    },, +    IDENTITY {, +      @Override, +      public boolean equivalent(@Nullable Object a, @Nullable Object b) {, +        return a == b;, +      @Override, +      public int hash(@Nullable Object o) {, +    },, +  }, +  /**, +   * Returns an equivalence over iterables based on the equivalence of their elements.  More, +   * specifically, two iterables are considered equivalent if they both contain the same number of, +   * elements, and each pair of corresponding elements is equivalent according to, +   * {@code elementEquivalence}.  Null iterables are equivalent to one another., +   *, +   * @since Guava release 09, +   */, +  @GwtCompatible(serializable = true), +  public static <T> Equivalence<Iterable<T>> pairwise(Equivalence<? super T> elementEquivalence) {, +    /*, +     * Ideally, the returned equivalence would support {@code Iterable<? extends T>}.  However, the, +     * need for this is so rare that it's not worth making callers deal with the ugly wildcard., +     */, +    return new PairwiseEquivalence<T>(elementEquivalence);, +++ /dev/null, +++ b/guava/src/com/google/common/base/Equivalence.java]