[+++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.lang.ref.WeakReference;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ScheduledExecutorService;, +  static final long CLEANUP_EXECUTOR_DELAY_SECS = 60;, +, +  /** Performs routine cleanup. */, +  final ScheduledExecutorService cleanupExecutor;, +   *, +   * @throws RejectedExecutionException if a cleanupExecutor was specified but rejects the cleanup, +   *     task, +      cleanupExecutor.scheduleWithFixedDelay(new CleanupMapTask(this),, +          CLEANUP_EXECUTOR_DELAY_SECS, CLEANUP_EXECUTOR_DELAY_SECS, TimeUnit.SECONDS);, +  }, +, +      for (ReferenceEntry<K, V> e = head.getNextEvictable(); e != head; e = e.getNextEvictable()) {, +      for (ReferenceEntry<K, V> e = head.getNextExpirable(); e != head; e = e.getNextExpirable()) {, +, +  static final class CleanupMapTask implements Runnable {, +    final WeakReference<CustomConcurrentHashMap<?, ?>> mapReference;, +, +    public CleanupMapTask(CustomConcurrentHashMap<?, ?> map) {, +      this.mapReference = new WeakReference<CustomConcurrentHashMap<?, ?>>(map);, +    }, +, +    @Override, +    public void run() {, +      CustomConcurrentHashMap<?, ?> map = mapReference.get();, +      if (map == null) {, +        throw new CancellationException();, +      }, +, +      for (Segment<?, ?> segment : map.segments) {, +        segment.runCleanup();, +      }, +    }, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.lang.ref.WeakReference;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ScheduledExecutorService;, +  static final long CLEANUP_EXECUTOR_DELAY_SECS = 60;, +, +  /** Performs routine cleanup. */, +  final ScheduledExecutorService cleanupExecutor;, +   *, +   * @throws RejectedExecutionException if a cleanupExecutor was specified but rejects the cleanup, +   *     task, +      cleanupExecutor.scheduleWithFixedDelay(new CleanupMapTask(this),, +          CLEANUP_EXECUTOR_DELAY_SECS, CLEANUP_EXECUTOR_DELAY_SECS, TimeUnit.SECONDS);, +  }, +, +      for (ReferenceEntry<K, V> e = head.getNextEvictable(); e != head; e = e.getNextEvictable()) {, +      for (ReferenceEntry<K, V> e = head.getNextExpirable(); e != head; e = e.getNextExpirable()) {, +, +  static final class CleanupMapTask implements Runnable {, +    final WeakReference<CustomConcurrentHashMap<?, ?>> mapReference;, +, +    public CleanupMapTask(CustomConcurrentHashMap<?, ?> map) {, +      this.mapReference = new WeakReference<CustomConcurrentHashMap<?, ?>>(map);, +    }, +, +    @Override, +    public void run() {, +      CustomConcurrentHashMap<?, ?> map = mapReference.get();, +      if (map == null) {, +        throw new CancellationException();, +      }, +, +      for (Segment<?, ?> segment : map.segments) {, +        segment.runCleanup();, +      }, +    }, +++ b/guava/src/com/google/common/collect/MapMaker.java, +import java.util.concurrent.ScheduledExecutorService;, +  ScheduledExecutorService cleanupExecutor;, +  ScheduledExecutorService getCleanupExecutor() {]