[+++ b/guava/src/com/google/common/cache/LongAdder.java, + * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/LongAdder.java?revision=1.17, + * methods such as {@code equals}, {@code hashCode} and {@code, + * compareTo} because instances are expected to be mutated, and so are, + * not useful as collection keys., + * java.util.concurrent.atomic.</em>, +        Cell[] as; long b, v; int[] hc; Cell a; int n;, +            if ((hc = threadHashCode.get()) == null ||, +                as == null || (n = as.length) < 1 ||, +                (a = as[(n - 1) & hc[0]]) == null ||, +     * atomic snapshot; invocation in the absence of concurrent, +    private void writeObject(ObjectOutputStream s) throws IOException {, +++ b/guava/src/com/google/common/cache/LongAdder.java, + * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/LongAdder.java?revision=1.17, + * methods such as {@code equals}, {@code hashCode} and {@code, + * compareTo} because instances are expected to be mutated, and so are, + * not useful as collection keys., + * java.util.concurrent.atomic.</em>, +        Cell[] as; long b, v; int[] hc; Cell a; int n;, +            if ((hc = threadHashCode.get()) == null ||, +                as == null || (n = as.length) < 1 ||, +                (a = as[(n - 1) & hc[0]]) == null ||, +     * atomic snapshot; invocation in the absence of concurrent, +    private void writeObject(ObjectOutputStream s) throws IOException {, +++ b/guava/src/com/google/common/cache/Striped64.java, + * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/Striped64.java?revision=1.9, +import javax.annotation.Nullable;, +, +     * There is no need for a blocking lock; when the lock is not, +     * ThreadLocal holding a single-slot int array holding hash code., +     * Unlike the JDK8 version of this class, we use a suboptimal, +     * int[] representation to avoid introducing a new type that can, +     * impede class-unloading when ThreadLocals are not removed., +    static final ThreadLocal<int[]> threadHashCode = new ThreadLocal<int[]>();, +, +    /**, +     * Generator of new random hash codes, +     */, +    final void retryUpdate(long x, @Nullable int[] hc, boolean wasUncontended) {, +        int h;, +        if (hc == null) {, +            threadHashCode.set(hc = new int[1]); // Initialize randomly, +            int r = rng.nextInt(); // Avoid zero to allow xorShift rehash, +            h = hc[0] = (r == 0) ? 1 : r;, +        }, +        else, +            h = hc[0];, +                hc[0] = h;                      // Record index for next time]