[+++ b/android/guava/src/com/google/common/io/CharSource.java, +import java.io.StringReader;, +    return charSequence instanceof String, +        ? new StringCharSource((String) charSequence), +        : new CharSequenceCharSource(charSequence);, +    protected final CharSequence seq;, +  /**, +   * Subclass specialized for string instances., +   *, +   * <p>Since Strings are immutable and built into the jdk we can optimize some operations, +   *, +   * <ul>, +   *   <li>use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can, +   *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by, +   *       one with {@link CharSequence#charAt(int)}., +   *   <li>use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link, +   *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length, +   *       can't change, and it is faster because many writers and appendables are optimized for, +   *       appending string instances., +   * </ul>, +   */, +  private static class StringCharSource extends CharSequenceCharSource {, +    protected StringCharSource(String seq) {, +      super(seq);, +    }, +, +    @Override, +    public Reader openStream() {, +      return new StringReader((String) seq);, +    }, +, +    @Override, +    public long copyTo(Appendable appendable) throws IOException {, +      appendable.append(seq);, +      return seq.length();, +    }, +, +    @Override, +    public long copyTo(CharSink sink) throws IOException {, +      checkNotNull(sink);, +      Closer closer = Closer.create();, +      try {, +        Writer writer = closer.register(sink.openStream());, +        writer.write((String) seq);, +        return seq.length();, +      } catch (Throwable e) {, +        throw closer.rethrow(e);, +      } finally {, +        closer.close();, +      }, +    }, +  }, +, +  private static final class EmptyCharSource extends StringCharSource {, +++ b/android/guava/src/com/google/common/io/CharSource.java, +import java.io.StringReader;, +    return charSequence instanceof String, +        ? new StringCharSource((String) charSequence), +        : new CharSequenceCharSource(charSequence);, +    protected final CharSequence seq;, +  /**, +   * Subclass specialized for string instances., +   *, +   * <p>Since Strings are immutable and built into the jdk we can optimize some operations, +   *, +   * <ul>, +   *   <li>use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can, +   *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by, +   *       one with {@link CharSequence#charAt(int)}., +   *   <li>use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link, +   *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length, +   *       can't change, and it is faster because many writers and appendables are optimized for, +   *       appending string instances., +   * </ul>, +   */, +  private static class StringCharSource extends CharSequenceCharSource {, +    protected StringCharSource(String seq) {, +      super(seq);, +    }, +, +    @Override, +    public Reader openStream() {, +      return new StringReader((String) seq);, +    }, +, +    @Override, +    public long copyTo(Appendable appendable) throws IOException {, +      appendable.append(seq);, +      return seq.length();, +    }, +, +    @Override, +    public long copyTo(CharSink sink) throws IOException {, +      checkNotNull(sink);, +      Closer closer = Closer.create();, +      try {, +        Writer writer = closer.register(sink.openStream());, +        writer.write((String) seq);, +        return seq.length();, +      } catch (Throwable e) {]