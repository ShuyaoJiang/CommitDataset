[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +import static com.google.common.base.Preconditions.checkArgument;, +import com.google.common.base.Objects;, +import com.google.common.base.Preconditions;, +public class LinkedListMultimap<K, V>, +  private static final class Node<K, V> {, +    @Override public String toString() {, +      return key + "=" + value;, +    for (Iterator<V> i = new ValueForKeyIterator(key); i.hasNext();) {, +      i.next();, +      i.remove();, +    }, +  private class NodeIterator implements ListIterator<Node<K, V>> {, +    NodeIterator() {, +      next = head;, +    }, +      Preconditions.checkPositionIndex(index, size);, +    public void set(Node<K, V> e) {, +    public void add(Node<K, V> e) {, +      Preconditions.checkPositionIndex(index, size);, +    for (Iterator<Node<K, V>> i = new NodeIterator(); i.hasNext();) {, +      if (Objects.equal(i.next().value, value)) {, +        return true;, +      }, +    }, +    return false;, +  }, +, +  @Override, +  public boolean containsEntry(@Nullable Object key, @Nullable Object value) {, +    for (Iterator<V> i = new ValueForKeyIterator(key); i.hasNext();) {, +      if (Objects.equal(i.next(), value)) {, +        return true;, +      }, +    }, +    return false;, +  @Override, +  public boolean remove(@Nullable Object key, @Nullable Object value) {, +    Iterator<V> values = new ValueForKeyIterator(key);, +    while (values.hasNext()) {, +      if (Objects.equal(values.next(), value)) {, +        values.remove();, +        return true;, +      }, +    }, +    return false;, +  }, +, +  @Override, +  public boolean putAll(@Nullable K key, Iterable<? extends V> values) {, +    boolean changed = false;, +    for (V value : values) {, +      changed |= put(key, value);, +    }, +    return changed;, +  }, +, +  @Override, +  public boolean putAll(Multimap<? extends K, ? extends V> multimap) {, +    boolean changed = false;, +    for (Entry<? extends K, ? extends V> entry : multimap.entries()) {, +      changed |= put(entry.getKey(), entry.getValue());, +    }, +    return changed;, +  }, +, +      @Override public boolean removeAll(Collection<?> c) {, +        return Iterators.removeAll(iterator(), c);, +      }, +      @Override public boolean retainAll(Collection<?> c) {, +        return Iterators.retainAll(iterator(), c);, +      }, +  private transient Set<K> keySet;, +, +  public Set<K> keySet() {, +    Set<K> result = keySet;, +    if (result == null) {, +      keySet = result = new Sets.ImprovedAbstractSet<K>() {, +    return result;, +  }, +, +  private transient Multiset<K> keys;, +, +  @Override, +  public Multiset<K> keys() {, +    Multiset<K> result = keys;, +    if (result == null) {, +      keys = result = new MultisetView();, +    }, +    return result;, +  }, +, +  private class MultisetView extends AbstractMultiset<K> {, +    @Override, +    public int size() {, +      return size;, +    }, +, +    @Override, +    public int count(Object element) {]