[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // In the constructor of FutureFallback, the delegate future is assigned to a field 'inputFuture'., +  // That field is non-final and non-volatile.  There are 2 places where the 'inputFuture' field is, +  // read and where we will have to consider visibility of the write operation in the constructor., +  // 1. In the listener that performs the callback.  In this case it is fine since inputFuture is, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible, +  //    to the listener., +  //    There is currently nothing that enforces that the write to inputFuture in the constructor is, +    @Nullable ListenableFuture<? extends V> inputFuture;, +        ListenableFuture<? extends V> inputFuture, Class<X> exceptionType, F fallback) {, +      this.inputFuture = checkNotNull(inputFuture);, +      ListenableFuture<? extends V> localInputFuture = inputFuture;, +      if (localInputFuture == null | localExceptionType == null | localFallback == null, +        set(getUninterruptibly(localInputFuture));, +      this.inputFuture = null;, +      ListenableFuture<?> localInputFuture = inputFuture;, +        if (localInputFuture != null) {, +          localInputFuture.cancel(mayInterruptIfRunning);, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // In the constructor of FutureFallback, the delegate future is assigned to a field 'inputFuture'., +  // That field is non-final and non-volatile.  There are 2 places where the 'inputFuture' field is, +  // read and where we will have to consider visibility of the write operation in the constructor., +  // 1. In the listener that performs the callback.  In this case it is fine since inputFuture is, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible, +  //    to the listener., +  //    There is currently nothing that enforces that the write to inputFuture in the constructor is, +    @Nullable ListenableFuture<? extends V> inputFuture;, +        ListenableFuture<? extends V> inputFuture, Class<X> exceptionType, F fallback) {, +      this.inputFuture = checkNotNull(inputFuture);, +      ListenableFuture<? extends V> localInputFuture = inputFuture;, +      if (localInputFuture == null | localExceptionType == null | localFallback == null, +        set(getUninterruptibly(localInputFuture));, +      this.inputFuture = null;, +      ListenableFuture<?> localInputFuture = inputFuture;, +        if (localInputFuture != null) {, +          localInputFuture.cancel(mayInterruptIfRunning);, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +  // In the constructor of FutureFallback, the delegate future is assigned to a field 'inputFuture'., +  // That field is non-final and non-volatile.  There are 2 places where the 'inputFuture' field is, +  // read and where we will have to consider visibility of the write operation in the constructor., +  // 1. In the listener that performs the callback.  In this case it is fine since inputFuture is, +  //    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible, +  //    to the listener., +  //    There is currently nothing that enforces that the write to inputFuture in the constructor is, +    @Nullable ListenableFuture<? extends V> inputFuture;, +        ListenableFuture<? extends V> inputFuture, Class<X> exceptionType, F fallback) {, +      this.inputFuture = checkNotNull(inputFuture);, +      ListenableFuture<? extends V> localInputFuture = inputFuture;, +      if (localInputFuture == null | localExceptionType == null | localFallback == null, +        set(getUninterruptibly(localInputFuture));, +      this.inputFuture = null;, +      ListenableFuture<?> localInputFuture = inputFuture;, +        if (localInputFuture != null) {, +          localInputFuture.cancel(mayInterruptIfRunning);]