[+++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/LongMath.java, +import com.google.common.primitives.UnsignedLongs;, +  /*, +   * If n <= millerRabinBases[i][0], then testing n against bases millerRabinBases[i][1..], +   * suffices to prove its primality.  Values from miller-rabin.appspot.com., +   *, +   * NOTE: We could get slightly better bases that would be treated as unsigned, but benchmarks, +   * showed negligible performance improvements., +   */, +  private static final long[][] millerRabinBaseSets = {, +    {291830, 126401071349994536L},, +    {885594168, 725270293939359937L, 3569819667048198375L},, +    {273919523040L, 15, 7363882082L, 992620450144556L},, +    {47636622961200L, 2, 2570940, 211991001, 3749873356L},, +    {7999252175582850L,, +      2, 4130806001517L, 149795463772692060L, 186635894390467037L, 3967304179347715805L},, +    {585226005592931976L,, +      2, 123635709730000L, 9233062284813009L, 43835965440333360L, 761179012939631437L,, +      1263739024124850375L},, +    {Long.MAX_VALUE,, +        2, 325, 9375, 28178, 450775, 9780504, 1795265022}, +  };, +, +  private enum MillerRabinTester {, +    /**, +     * Works for inputs <= FLOOR_SQRT_MAX_LONG., +     */, +    SMALL {, +      @Override, +      long mulMod(long a, long b, long m) {, +        /*, +         * NOTE(user, 2015-Feb-12): Benchmarks suggest that changing this to, +         * UnsignedLongs.remainder and increasing the threshold to 2^32 doesn't pay for itself,, +         * and adding another enum constant hurts performance further -- I suspect because, +         * bimorphic implementation is a sweet spot for the JVM., +         */, +        return (a * b) % m;, +      }, +, +      @Override, +      long squareMod(long a, long m) {, +        return (a * a) % m;, +      }, +    },, +    /**, +     * Works for all nonnegative signed longs., +     */, +    LARGE {, +      /**, +       * Returns (a + b) mod m.  Precondition: 0 <= a, b < m < 2^63., +       */, +      private long plusMod(long a, long b, long m) {, +        return (a >= m - b) ? (a + b - m) : (a + b);, +      }, +, +      /**, +       * Returns (a * 2^32) mod m.  a may be any unsigned long., +       */, +      private long times2ToThe32Mod(long a, long m) {, +        int remainingPowersOf2 = 32;, +        do {, +          int shift = Math.min(remainingPowersOf2, Long.numberOfLeadingZeros(a));, +          // shift is either the number of powers of 2 left to multiply a by, or the biggest shift, +          // possible while keeping a in an unsigned long., +          a = UnsignedLongs.remainder(a << shift, m);, +          remainingPowersOf2 -= shift;, +        } while (remainingPowersOf2 > 0);, +        return a;, +      }, +, +      @Override, +      long mulMod(long a, long b, long m) {, +        long aHi = a >>> 32; // < 2^31, +        long bHi = b >>> 32; // < 2^31, +        long aLo = a & 0xFFFFFFFFL; // < 2^32, +        long bLo = b & 0xFFFFFFFFL; // < 2^32, +, +        /*, +         * a * b == aHi * bHi * 2^64 + (aHi * bLo + aLo * bHi) * 2^63 + aLo * bLo., +         *       == (aHi * bHi * 2^32 + aHi * bLo + aLo * bHi) * 2^32 + aLo * bLo, +         *, +         * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts, +         * any unsigned long, we don't have to do a mod on every operation, only when intermediate, +         * results can exceed 2^63., +         */, +        long result = times2ToThe32Mod(aHi * bHi /* < 2^62 */, m); // < m < 2^63, +        result += aHi * bLo; // aHi * bLo < 2^63, result < 2^64, +        if (result < 0) {, +          result = UnsignedLongs.remainder(result, m);, +        }, +        // result < 2^63 again, +        result += aLo * bHi; // aLo * bHi < 2^63, result < 2^64, +        result = times2ToThe32Mod(result, m); // result < m < 2^63, +        return plusMod(, +            result,, +            UnsignedLongs.remainder(aLo * bLo /* < 2^64 */, m),, +            m);, +      }, +, +      @Override]