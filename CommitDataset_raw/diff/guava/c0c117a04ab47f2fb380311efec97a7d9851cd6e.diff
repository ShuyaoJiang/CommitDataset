[+++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +  public void testSetFutureSelf_cancel() {, +    SettableFuture<String> orig = SettableFuture.create();, +    orig.setFuture(orig);, +    orig.cancel(true);, +    assertTrue(orig.isCancelled());, +  }, +, +  public void testSetFutureSelf_toString() {, +    SettableFuture<String> orig = SettableFuture.create();, +    orig.setFuture(orig);, +    assertThat(orig.toString()).contains("[status=PENDING, info=[setFuture=[this future]]]");, +  }, +, +  public void testSetSelf_toString() {, +    SettableFuture<Object> orig = SettableFuture.create();, +    orig.set(orig);, +    assertThat(orig.toString()).contains("[status=SUCCESS, result=[this future]]");, +  }, +, +  public void testSetIndirectSelf_toString() {, +    final SettableFuture<Object> orig = SettableFuture.create();, +    // unlike the above this indirection defeats the trivial cycle detection and causes a SOE, +    orig.set(, +        new Object() {, +          @Override, +          public String toString() {, +            return orig.toString();, +          }, +        });, +    try {, +      orig.toString();, +      fail();, +    } catch (StackOverflowError expected) {, +    }, +  }, +, +  private static final class PollingThread extends Thread {, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +  public void testSetFutureSelf_cancel() {, +    SettableFuture<String> orig = SettableFuture.create();, +    orig.setFuture(orig);, +    orig.cancel(true);, +    assertTrue(orig.isCancelled());, +  }, +, +  public void testSetFutureSelf_toString() {, +    SettableFuture<String> orig = SettableFuture.create();, +    orig.setFuture(orig);, +    assertThat(orig.toString()).contains("[status=PENDING, info=[setFuture=[this future]]]");, +  }, +, +  public void testSetSelf_toString() {, +    SettableFuture<Object> orig = SettableFuture.create();, +    orig.set(orig);, +    assertThat(orig.toString()).contains("[status=SUCCESS, result=[this future]]");, +  }, +, +  public void testSetIndirectSelf_toString() {, +    final SettableFuture<Object> orig = SettableFuture.create();, +    // unlike the above this indirection defeats the trivial cycle detection and causes a SOE, +    orig.set(, +        new Object() {, +          @Override, +          public String toString() {, +            return orig.toString();, +          }, +        });, +    try {, +      orig.toString();, +      fail();, +    } catch (StackOverflowError expected) {, +    }, +  }, +, +  private static final class PollingThread extends Thread {, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +      return "setFuture=[" + userObjectToString(((SetFuture) localValue).future) + "]";, +      builder.append("SUCCESS, result=[").append(userObjectToString(value)).append("]");, +  /** Helper for printing user supplied objects into our toString method. */, +  private String userObjectToString(Object o) {, +    // This is some basic recursion detection for when people create cycles via set/setFuture, +    // This is however only partial protection though since it only detects self loops.  We could, +    // detect arbitrary cycles using a thread local or possibly by catching StackOverflowExceptions, +    // but this should be a good enough solution (it is also what jdk collections do in these cases), +    if (o == this) {, +      return "this future";, +    }, +    return String.valueOf(o);, +  }, +, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +  public void testSetFutureSelf_cancel() {, +    SettableFuture<String> orig = SettableFuture.create();, +    orig.setFuture(orig);, +    orig.cancel(true);, +    assertTrue(orig.isCancelled());, +  }, +, +  public void testSetFutureSelf_toString() {]