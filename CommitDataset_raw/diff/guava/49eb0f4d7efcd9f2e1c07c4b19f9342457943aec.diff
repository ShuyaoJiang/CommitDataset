[+++ b/guava-tests/test/com/google/common/base/FinalizableReferenceQueueClassLoaderUnloadingTest.java, +import java.io.Closeable;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +    assertNotSame(frqC, sepFrqC);, +, +  public static class FrqUser implements Callable<WeakReference<Object>> {, +    public static FinalizableReferenceQueue frq = new FinalizableReferenceQueue();, +    public static final Semaphore finalized = new Semaphore(0);, +, +    @Override, +    public WeakReference<Object> call() {, +      WeakReference<Object> wr = new FinalizableWeakReference<Object>(new Integer(23), frq) {, +        @Override, +        public void finalizeReferent() {, +          finalized.release();, +        }, +      };, +      return wr;, +    }, +  }, +, +  public void testUnloadableInStaticFieldIfClosed() throws Exception {, +    Policy oldPolicy = Policy.getPolicy();, +    SecurityManager oldSecurityManager = System.getSecurityManager();, +    try {, +      Policy.setPolicy(new PermissivePolicy());, +      System.setSecurityManager(new SecurityManager());, +      WeakReference<ClassLoader> loaderRef = doTestUnloadableInStaticFieldIfClosed();, +      GcFinalization.awaitClear(loaderRef);, +    } finally {, +      System.setSecurityManager(oldSecurityManager);, +      Policy.setPolicy(oldPolicy);, +    }, +  }, +, +  // If you have a FinalizableReferenceQueue that is a static field of one of the classes of your, +  // app (like the FrqUser class above), then the app's ClassLoader will never be gc'd. The reason, +  // is that we attempt to run a thread in a separate ClassLoader that will detect when the FRQ, +  // is no longer referenced, meaning that the app's ClassLoader has been gc'd, and when that, +  // happens. But the thread's supposedly separate ClassLoader actually has a reference to the app's, +  // ClasLoader via its AccessControlContext. It does not seem to be possible to make a, +  // URLClassLoader without capturing this reference, and it probably would not be desirable for, +  // security reasons anyway. Therefore, the FRQ.close() method provides a way to stop the thread, +  // explicitly. This test checks that calling that method does allow an app's ClassLoader to be, +  // gc'd even if there is a still a FinalizableReferenceQueue in a static field. (Setting the field, +  // to null would also work, but only if there are no references to the FRQ anywhere else.), +  private WeakReference<ClassLoader> doTestUnloadableInStaticFieldIfClosed() throws Exception {, +    final URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader();, +    final URL[] urls = myLoader.getURLs();, +    URLClassLoader sepLoader = new URLClassLoader(urls, myLoader.getParent());, +, +    Class<?> frqC = FinalizableReferenceQueue.class;, +    Class<?> sepFrqC = sepLoader.loadClass(frqC.getName());, +    assertNotSame(frqC, sepFrqC);, +, +    Class<?> sepFrqSystemLoaderC =, +        sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());, +    Field disabled = sepFrqSystemLoaderC.getDeclaredField("disabled");, +    disabled.setAccessible(true);, +    disabled.set(null, true);, +, +    Class<?> frqUserC = FrqUser.class;, +    Class<?> sepFrqUserC = sepLoader.loadClass(frqUserC.getName());, +    assertNotSame(frqUserC, sepFrqUserC);, +    assertSame(sepLoader, sepFrqUserC.getClassLoader());, +, +    @SuppressWarnings("unchecked"), +    Callable<WeakReference<Object>> sepFrqUser =, +        (Callable<WeakReference<Object>>) sepFrqUserC.newInstance();, +    WeakReference<Object> finalizableWeakReference = sepFrqUser.call();, +, +    GcFinalization.awaitClear(finalizableWeakReference);, +, +    Field sepFrqUserFinalizedF = sepFrqUserC.getField("finalized");, +    Semaphore finalizeCount = (Semaphore) sepFrqUserFinalizedF.get(null);, +    boolean finalized = finalizeCount.tryAcquire(5, TimeUnit.SECONDS);, +    assertTrue(finalized);, +, +    Field sepFrqUserFrqF = sepFrqUserC.getField("frq");, +    Closeable frq = (Closeable) sepFrqUserFrqF.get(null);, +    frq.close();, +, +    return new WeakReference<ClassLoader>(sepLoader);, +  }, +++ b/guava-tests/test/com/google/common/base/FinalizableReferenceQueueClassLoaderUnloadingTest.java, +import java.io.Closeable;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +    assertNotSame(frqC, sepFrqC);, +, +  public static class FrqUser implements Callable<WeakReference<Object>> {, +    public static FinalizableReferenceQueue frq = new FinalizableReferenceQueue();, +    public static final Semaphore finalized = new Semaphore(0);, +, +    @Override, +    public WeakReference<Object> call() {, +      WeakReference<Object> wr = new FinalizableWeakReference<Object>(new Integer(23), frq) {]