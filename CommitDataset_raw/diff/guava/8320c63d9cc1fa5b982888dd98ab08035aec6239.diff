[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        if (entry != null) {, +          // current entry is live, and read was already recorded, +          return entry.getValueReference().get();, +        }, +, +        // entry is absent, invalid, or computing, +          // TODO(user): reuse partially collected entries; otherwise we, +          // risk blocking on cleanup, +            // recursive computation is detected. This is not fool-proof, +                // this entry could be partially-collected, don't clearValue, +              recordRead(entry);, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +, +      // TODO(user): explore directly calling, +      // segmentFor(hash).put(key, hash, value, true);, +        segment.expireEntries();, +, +        int newCount = segment.count + 1;, +        if (newCount > segment.threshold) { // ensure capacity, +          segment.expand();, +        }, +, +              // putIfAbsent, +              ++segment.modCount;, +              if (segment.evictEntries()) {, +                newCount = segment.count + 1;, +              }, +, +              segment.count = newCount; // write-volatile, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        if (entry != null) {, +          // current entry is live, and read was already recorded, +          return entry.getValueReference().get();, +        }, +, +        // entry is absent, invalid, or computing, +          // TODO(user): reuse partially collected entries; otherwise we, +          // risk blocking on cleanup, +            // recursive computation is detected. This is not fool-proof, +                // this entry could be partially-collected, don't clearValue, +              recordRead(entry);, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {}, +, +      // TODO(user): explore directly calling, +      // segmentFor(hash).put(key, hash, value, true);, +        segment.expireEntries();, +, +        int newCount = segment.count + 1;, +        if (newCount > segment.threshold) { // ensure capacity, +          segment.expand();, +        }, +, +              // putIfAbsent, +              ++segment.modCount;, +              if (segment.evictEntries()) {, +                newCount = segment.count + 1;, +              }, +, +              segment.count = newCount; // write-volatile, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +, +    /**, +     * Invoked after the value has been garbage collected., +     */, +    void notifyValueReclaimed();, +    public void notifyValueReclaimed() {}, +    public void notifyValueReclaimed() {, +      finalizeReferent();, +    }, +, +    public void notifyValueReclaimed() {, +      finalizeReferent();, +    }, +, +    public void notifyValueReclaimed() {}, +, +    segmentFor(hash).invalidateValue(entry.getKey(), hash, valueReference);, +  // Entries in the map can be in the following states:, +  // - Live: valid value is set, +  // - Expired: time expired, but old value still set, +  // - Computing: computation is pending, +  // - Collected: value was collected but not yet cleaned up, +  // - Invalid: marked as invalid, awaiting cleanup or reuse, +  boolean isLive(ReferenceEntry<K, V> entry) {, +    return getLiveValue(entry) != null;, +  boolean isInvalid(ReferenceEntry<K, V> entry) {, +    return isInvalid(entry.getValueReference());, +  }, +, +  boolean isInvalid(ValueReference<K, V> valueReference) {, +    return valueReference == UNSET;, +  }, +]