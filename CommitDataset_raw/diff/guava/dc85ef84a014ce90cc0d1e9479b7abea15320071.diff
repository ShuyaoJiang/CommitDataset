[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +    if (!segment.isHeldByCurrentThread()) { // don't cleanup inside of put, +  }, +, +        if (isInlineCleanup()) {, +          // inline cleanup normally avoids taking the lock, but since no writes, +          // are happening we need to force some locked cleanup, +          runCleanup();, +        } else {, +    }, +        // this cleanup pattern is optimized for writes, where cleanup requiring, +        // the lock is performed when the lock is acquired, and cleanup not, +        // requiring the lock is performed when the lock is released, +        } else {, +          runUnlockedCleanup();, +        // non-default cleanup executors can ignore cleanup optimizations when, +        // the lock is held, as cleanup will always be called when the lock is, +        // released, +            runCleanup();, +          }, +        };, +, +    void runCleanup() {]