[+++ b/guava/src/com/google/common/net/InetAddresses.java, +    byte[] addr = ipStringToBytes(ipString);, +    return ipStringToBytes(ipString) != null;, +  }, +, +  private static byte[] ipStringToBytes(String ipString) {, +    // Make a first pass to categorize the characters in this string., +    boolean hasColon = false;, +    boolean hasDot = false;, +    for (int i = 0; i < ipString.length(); i++) {, +      char c = ipString.charAt(i);, +      if (c == '.') {, +        hasDot = true;, +      } else if (c == ':') {, +        if (hasDot) {, +          return null;  // Colons must not appear after dots., +        }, +        hasColon = true;, +      } else if (Character.digit(c, 16) == -1) {, +        return null;  // Everything else must be a decimal or hex digit., +    // Now decide which address family to parse., +    if (hasColon) {, +      if (hasDot) {, +        ipString = convertDottedQuadToHex(ipString);, +        if (ipString == null) {, +          return null;, +        }, +      }, +      return textToNumericFormatV6(ipString);, +    } else if (hasDot) {, +      return textToNumericFormatV4(ipString);, +    }, +  private static byte[] textToNumericFormatV4(String ipString) {, +    // An address can have [2..8] colons, and N colons make N+1 parts., +    String[] parts = ipString.split(":", IPV6_PART_COUNT + 2);, +    if (parts.length < 3 || parts.length > IPV6_PART_COUNT + 1) {, +    // Disregarding the endpoints, find "::" with nothing in between., +    // This indicates that a run of zeroes has been skipped., +    int skipIndex = -1;, +    for (int i = 1; i < parts.length - 1; i++) {, +      if (parts[i].length() == 0) {, +        if (skipIndex >= 0) {, +          return null;  // Can't have more than one ::, +        }, +        skipIndex = i;, +    // Now check the endpoints, and determine the number of parts to copy from, +    // above/before the "::" (partsHi), and below/after the "::" (partsLo)., +    int partsHi;, +    if (parts[0].length() == 0) {, +      if (!ipString.startsWith("::")) {, +        return null;  // ^: requires ^::, +      }, +      partsHi = 0;, +    } else {, +      // If a :: wasn't found, then partsHi includes everything., +      partsHi = skipIndex >= 0 ? skipIndex : parts.length;, +    }, +    int partsLo;, +    if (parts[parts.length - 1].length() == 0) {, +      if (!ipString.endsWith("::")) {, +        return null;  // :$ requires ::$, +      }, +      partsLo = 0;, +    } else {, +      // If a :: wasn't found, then partsLo includes nothing., +      partsLo = skipIndex >= 0 ? parts.length - skipIndex - 1 : 0;, +    }, +, +    // If we found a ::, then we must have skipped at least one part., +    // Otherwise, we must have exactly the right number of parts., +    int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);, +    if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0)) {, +      return null;, +    }, +, +    // Now parse the hextets into a byte array., +      for (int i = 0; i < partsHi; i++) {, +        rawBytes.putShort(parseHextet(parts[i]));, +      for (int i = 0; i < partsSkipped; i++) {, +        rawBytes.putShort((short) 0);, +      }, +      for (int i = partsLo; i > 0; i--) {, +        rawBytes.putShort(parseHextet(parts[parts.length - i]));, +      }, +    // Note: we already verified that this string contains only hex digits., +    // Disallow leading zeroes, because no clear standard exists on, +    if (octet > 255 || (ipPart.startsWith("0") && ipPart.length() > 1)) {, +    // Note: we already verified that this string contains only hex digits., +    if (hextet > 0xffff) {]