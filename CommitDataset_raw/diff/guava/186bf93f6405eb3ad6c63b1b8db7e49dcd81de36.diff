[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java, +import com.google.common.base.Optional;, +   * predicate; use this method only when such an element is known to exist. If, +   * it is possible that <i>no</i> element will match, use {@link, +   * #tryFind)} or {@link #find(Iterable, Predicate, T)} instead., +   * predicate, or {@code defaultValue} if none found. Note that this can, +   * usually be handled more naturally using {@code, +   * tryFind(iterable, predicate).or(defaultValue)}., +   * Returns an {@link Optional} containing the first element in {@code, +   * iterable} that satisfies the given predicate, if such an element exists., +   *, +   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code, +   * null}. If {@code null} is matched in {@code iterable}, a, +   * NullPointerException will be thrown., +   *, +   * @since 11.0, +   */, +  public static <T> Optional<T> tryFind(Iterable<T> iterable,, +      Predicate<? super T> predicate) {, +    return Iterators.tryFind(iterable.iterator(), predicate);, +  }, +, +  /**, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java, +import com.google.common.base.Optional;, +   * predicate; use this method only when such an element is known to exist. If, +   * it is possible that <i>no</i> element will match, use {@link, +   * #tryFind)} or {@link #find(Iterable, Predicate, T)} instead., +   * predicate, or {@code defaultValue} if none found. Note that this can, +   * usually be handled more naturally using {@code, +   * tryFind(iterable, predicate).or(defaultValue)}., +   * Returns an {@link Optional} containing the first element in {@code, +   * iterable} that satisfies the given predicate, if such an element exists., +   *, +   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code, +   * null}. If {@code null} is matched in {@code iterable}, a, +   * NullPointerException will be thrown., +   *, +   * @since 11.0, +   */, +  public static <T> Optional<T> tryFind(Iterable<T> iterable,, +      Predicate<? super T> predicate) {, +    return Iterators.tryFind(iterable.iterator(), predicate);, +  }, +, +  /**, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java, +import com.google.common.base.Optional;, +   * predicate; use this method only when such an element is known to exist. If, +   * no such element is found, the iterator will be left exhausted: its {@code, +   * hasNext()} method will return {@code false}. If it is possible that, +   * <i>no</i> element will match, use {@link #tryFind)} or {@link, +   * #find(Iterator, Predicate, T)} instead., +   * {@code hasNext()} method will return {@code false}. Note that this can, +   * usually be handled more naturally using {@code, +   * tryFind(iterator, predicate).or(defaultValue)}., +   * Returns an {@link Optional} containing the first element in {@code, +   * iterator} that satisfies the given predicate, if such an element exists. If, +   * no such element is found, an empty {@link Optional} will be returned from, +   * this method and the the iterator will be left exhausted: its {@code, +   * hasNext()} method will return {@code false}., +   *, +   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code, +   * null}. If {@code null} is matched in {@code iterator}, a, +   * NullPointerException will be thrown., +   *, +   * @since 11.0, +   */, +  public static <T> Optional<T> tryFind(, +      Iterator<T> iterator, Predicate<? super T> predicate) {, +    UnmodifiableIterator<T> filteredIterator = filter(iterator, predicate);, +    return filteredIterator.hasNext(), +        ? Optional.of(filteredIterator.next()), +        : Optional.<T>absent();, +  }, +, +  /**, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java, +import com.google.common.base.Optional;, +   * predicate; use this method only when such an element is known to exist. If, +   * it is possible that <i>no</i> element will match, use {@link, +   * #tryFind)} or {@link #find(Iterable, Predicate, T)} instead., +   * predicate, or {@code defaultValue} if none found. Note that this can, +   * usually be handled more naturally using {@code, +   * tryFind(iterable, predicate).or(defaultValue)}., +   * Returns an {@link Optional} containing the first element in {@code, +   * iterable} that satisfies the given predicate, if such an element exists., +   *, +   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code, +   * null}. If {@code null} is matched in {@code iterable}, a, +   * NullPointerException will be thrown., +   *, +   * @since 11.0, +   */, +  public static <T> Optional<T> tryFind(Iterable<T> iterable,, +      Predicate<? super T> predicate) {, +    return Iterators.tryFind(iterable.iterator(), predicate);, +  }, +, +  /**]