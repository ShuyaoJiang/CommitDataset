[+++ b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java, +import java.util.Random;, +  private static String unsafeComparatorClassName() {, +    return UnsignedBytes.LexicographicalComparatorHolder.class.getName(), +        + "$UnsafeComparator";, +  }, +, +  private static boolean unsafeComparatorAvailable() {, +    // See Java Puzzler #44, +    // Use reflection instead of catching NoClassDefFoundError, +    try {, +      Class.forName(unsafeComparatorClassName());, +      return true;, +    } catch (ExceptionInInitializerError | ClassNotFoundException tolerable) {, +      // probably running on Android, +      return false;, +    }, +  }, +, +  public void testLexicographicalComparatorChoice() throws Exception {, +    assertNotNull(defaultComparator);, +    assertSame(defaultComparator,, +        UnsignedBytes.lexicographicalComparator());, +    if (unsafeComparatorAvailable()) {, +      assertSame(defaultComparator.getClass(),, +          Class.forName(unsafeComparatorClassName()));, +    } else {, +      assertSame(defaultComparator,, +          UnsignedBytes.lexicographicalComparatorJavaImpl());, +    }, +    Random rnd = new Random();, +      for (int trials = 10; trials-- > 0; ) {, +        byte[] left = new byte[1 + rnd.nextInt(32)];, +        rnd.nextBytes(left);, +        byte[] right = left.clone();, +        int i = rnd.nextInt(left.length);, +        left[i] ^= (byte) (1 + rnd.nextInt(255));, +        assertTrue(comparator.compare(left, right) != 0);, +        assertEquals(, +            comparator.compare(left, right) > 0,, +            UnsignedBytes.compare(left[i], right[i]) > 0);, +++ b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java, +import java.util.Random;, +  private static String unsafeComparatorClassName() {, +    return UnsignedBytes.LexicographicalComparatorHolder.class.getName(), +        + "$UnsafeComparator";, +  }, +, +  private static boolean unsafeComparatorAvailable() {, +    // See Java Puzzler #44, +    // Use reflection instead of catching NoClassDefFoundError, +    try {, +      Class.forName(unsafeComparatorClassName());, +      return true;, +    } catch (ExceptionInInitializerError | ClassNotFoundException tolerable) {, +      // probably running on Android, +      return false;, +    }, +  }, +, +  public void testLexicographicalComparatorChoice() throws Exception {, +    assertNotNull(defaultComparator);, +    assertSame(defaultComparator,, +        UnsignedBytes.lexicographicalComparator());, +    if (unsafeComparatorAvailable()) {, +      assertSame(defaultComparator.getClass(),, +          Class.forName(unsafeComparatorClassName()));, +    } else {, +      assertSame(defaultComparator,, +          UnsignedBytes.lexicographicalComparatorJavaImpl());, +    }, +    Random rnd = new Random();, +      for (int trials = 10; trials-- > 0; ) {, +        byte[] left = new byte[1 + rnd.nextInt(32)];, +        rnd.nextBytes(left);, +        byte[] right = left.clone();, +        int i = rnd.nextInt(left.length);, +        left[i] ^= (byte) (1 + rnd.nextInt(255));, +        assertTrue(comparator.compare(left, right) != 0);, +        assertEquals(, +            comparator.compare(left, right) > 0,, +            UnsignedBytes.compare(left[i], right[i]) > 0);, +++ b/guava/src/com/google/common/primitives/UnsignedBytes.java, +      static final Unsafe theUnsafe = getUnsafe();, +      static final int BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);, +        // fall back to the safer pure java implementation unless we're in, +        // a 64-bit JVM with an 8-byte aligned field offset., +        if (!("64".equals(System.getProperty("sun.arch.data.model")), +              && (BYTE_ARRAY_BASE_OFFSET % 8) == 0, +              && theUnsafe.arrayIndexScale(byte[].class) == 1)) {, +          throw new Error();  // force fallback to PureJavaComparator, +        final int stride = 8;, +        int strideLimit = minLength & ~(stride - 1);, +        int i;, +         * Compare 8 bytes at a time. Benchmarking on x86 shows a stride of 8 bytes is no slower, +         * than 4 bytes even on 32-bit. On the other hand, it is substantially faster on 64-bit., +        for (i = 0; i < strideLimit; i += stride) {, +        // The epilogue to cover the last (minLength % stride) elements., +        for (; i < minLength; i++) {]