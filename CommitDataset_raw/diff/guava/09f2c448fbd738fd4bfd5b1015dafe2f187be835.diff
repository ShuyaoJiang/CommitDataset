[+++ b/guava-tests/benchmark/com/google/common/collect/SetContainsBenchmark.java, +  @Param({"HashSetImpl", "ImmutableSetImpl"}), +    this.setToTest = (Set<Element>)impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/benchmark/com/google/common/collect/SetContainsBenchmark.java, +  @Param({"HashSetImpl", "ImmutableSetImpl"}), +    this.setToTest = (Set<Element>)impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/benchmark/com/google/common/collect/SetCreationBenchmark.java, +  @Param({"ImmutableSetImpl", "HashSetImpl"}), +++ b/guava-tests/benchmark/com/google/common/collect/SetContainsBenchmark.java, +  @Param({"HashSetImpl", "ImmutableSetImpl"}), +    this.setToTest = (Set<Element>)impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/benchmark/com/google/common/collect/SetCreationBenchmark.java, +  @Param({"ImmutableSetImpl", "HashSetImpl"}), +++ b/guava-tests/benchmark/com/google/common/collect/SetIterationBenchmark.java, +  @Param({"ImmutableSetImpl", "HashSetImpl"}), +    setToTest = (Set<Element>) impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/benchmark/com/google/common/collect/SetContainsBenchmark.java, +  @Param({"HashSetImpl", "ImmutableSetImpl"}), +    this.setToTest = (Set<Element>)impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/benchmark/com/google/common/collect/SetCreationBenchmark.java, +  @Param({"ImmutableSetImpl", "HashSetImpl"}), +++ b/guava-tests/benchmark/com/google/common/collect/SetIterationBenchmark.java, +  @Param({"ImmutableSetImpl", "HashSetImpl"}), +    setToTest = (Set<Element>) impl.create(sampleData.getValuesInSet());, +++ b/guava-tests/test/com/google/common/collect/BenchmarkHelpers.java, +import java.util.Queue;, +  /** So far, this is the best way to test various implementations of {@link Set} subclasses. */, +  public interface CollectionsImplEnum {, +    <E extends Comparable<E>> Collection<E> create(Collection<E> contents);, +    String name();, +  }, +, +  public interface MapsImplEnum {, +    <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> contents);, +    String name();, +  }, +, +  public enum SetImpl implements CollectionsImplEnum {, +    HashSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    LinkedHashSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    TreeSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    UnmodifiableSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    SynchronizedSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    ImmutableSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    ImmutableSortedSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +    ContiguousSetImpl {, +      @Override, +      public <E extends Comparable<E>> Set<E> create(Collection<E> contents) {, +        return ContiguousSet.copyOf(contents);, +      }, +    },, +    ArrayListMultimapImpl {, +    LinkedListMultimapImpl {, +    ImmutableListMultimapImpl {, +  public enum RangeSetImpl {, +    TreeRangeSetImpl {, +      @Override, +      <K extends Comparable<K>> RangeSet<K> create(RangeSet<K> contents) {, +        return TreeRangeSet.create(contents);, +      }, +    },, +    ImmutableRangeSetImpl {, +      @Override, +      <K extends Comparable<K>> RangeSet<K> create(RangeSet<K> contents) {, +        return ImmutableRangeSet.copyOf(contents);, +      }, +    };, +, +    abstract <K extends Comparable<K>> RangeSet<K> create(RangeSet<K> contents);, +  }, +, +    HashMultimapImpl {, +    LinkedHashMultimapImpl {, +    TreeMultimapImpl {, +    ImmutableSetMultimapImpl {, +  public enum MapImpl implements MapsImplEnum {, +    HashMapImpl {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {, +    LinkedHashMapImpl {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {, +    ConcurrentHashMapImpl {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {, +    ImmutableMapImpl {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {, +      public <K extends Comparable<K>, V> Map<K, V> create(Map<K, V> map) {]