[+++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureCancellationCauseTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.Executor;, +import java.util.concurrent.TimeUnit;, +import javax.annotation.concurrent.GuardedBy;, +          @GuardedBy("loadedClasses"), +          final Map<String, Class<?>> loadedClasses = new HashMap<>();, +, +            if (name.startsWith(concurrentPackage), +                // Use other classloader for ListenableFuture, so that the objects can interact, +                && !ListenableFuture.class.getName().equals(name)) {, +              synchronized (loadedClasses) {, +                Class<?> toReturn = loadedClasses.get(name);, +                if (toReturn == null) {, +                  toReturn = super.findClass(name);, +                  loadedClasses.put(name, toReturn);, +                }, +                return toReturn;, +              }, +  public void testSetFuture_misbehavingFutureDoesNotThrow() throws Exception {, +    ListenableFuture<String> badFuture =, +        new ListenableFuture<String>() {, +          @Override, +          public boolean cancel(boolean interrupt) {, +            return false;, +          }, +, +          @Override, +          public boolean isDone() {, +            return true;, +          }, +, +          @Override, +          public boolean isCancelled() {, +            return true; // BAD!!, +          }, +, +          @Override, +          public String get() {, +            return "foo"; // BAD!!, +          }, +, +          @Override, +          public String get(long time, TimeUnit unit) {, +            return "foo"; // BAD!!, +          }, +, +          @Override, +          public void addListener(Runnable runnable, Executor executor) {, +            executor.execute(runnable);, +          }, +        };, +    Future<?> future = newFutureInstance();, +    future, +        .getClass(), +        .getMethod(, +            "setFuture",, +            future.getClass().getClassLoader().loadClass(ListenableFuture.class.getName())), +        .invoke(future, badFuture);, +    try {, +      future.get();, +      fail();, +    } catch (CancellationException expected) {, +      assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);, +      assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());, +    }, +  }, +, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureCancellationCauseTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.Executor;, +import java.util.concurrent.TimeUnit;, +import javax.annotation.concurrent.GuardedBy;, +          @GuardedBy("loadedClasses"), +          final Map<String, Class<?>> loadedClasses = new HashMap<>();, +, +            if (name.startsWith(concurrentPackage), +                // Use other classloader for ListenableFuture, so that the objects can interact, +                && !ListenableFuture.class.getName().equals(name)) {, +              synchronized (loadedClasses) {, +                Class<?> toReturn = loadedClasses.get(name);, +                if (toReturn == null) {, +                  toReturn = super.findClass(name);, +                  loadedClasses.put(name, toReturn);, +                }, +                return toReturn;, +              }, +  public void testSetFuture_misbehavingFutureDoesNotThrow() throws Exception {, +    ListenableFuture<String> badFuture =, +        new ListenableFuture<String>() {, +          @Override, +          public boolean cancel(boolean interrupt) {, +            return false;, +          }]