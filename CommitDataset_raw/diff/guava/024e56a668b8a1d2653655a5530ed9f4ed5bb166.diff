[+++ b/guava/src/com/google/common/util/concurrent/MoreExecutors.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},, + * and {@link ThreadFactory}., +   * Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application, +   * is complete. It does so by using daemon threads and adding a shutdown hook to wait for their, +   * completion., +   * <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}., +   * @param executor the executor to modify to make sure it exits when the application is finished, +   * @param terminationTimeout how long to wait for the executor to finish before terminating the, +   *     JVM, +    return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);, +   * Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when, +   * the application is complete. It does so by using daemon threads and adding a shutdown hook to, +   * wait for their completion., +   * <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}., +   * @param executor the executor to modify to make sure it exits when the application is finished, +   * @param terminationTimeout how long to wait for the executor to finish before terminating the, +   *     JVM, +   * Add a shutdown hook to wait for thread completion in the given {@link ExecutorService service}., +   * This is useful if the given service uses daemon threads, and we want to keep the JVM from, +   * exiting immediately on shutdown, instead giving these daemon threads a chance to terminate, +   *, +   * @param terminationTimeout how long to wait for the executor to finish before terminating the, +   *     JVM, +    new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);, +   * Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application, +   * is complete. It does so by using daemon threads and adding a shutdown hook to wait for their, +   * completion., +   * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor, +   * has not finished its work., +   * <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}., +   * @param executor the executor to modify to make sure it exits when the application is finished, +   * Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when, +   * the application is complete. It does so by using daemon threads and adding a shutdown hook to, +   * wait for their completion., +   * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor, +   * has not finished its work., +   * <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}., +   * @param executor the executor to modify to make sure it exits when the application is finished, +      addShutdownHook(, +          MoreExecutors.newThread(, +              "DelayedShutdownHook-for-" + service,, +              new Runnable() {, +    @VisibleForTesting, +    void addShutdownHook(Thread hook) {, +    executor.setThreadFactory(, +        new ThreadFactoryBuilder(), +   * Creates an executor service that runs each task in the thread that invokes, +   * {@code execute/submit}, as in {@link CallerRunsPolicy}. This applies both to individually, +   * submitted tasks and to collections of tasks submitted via {@code invokeAll} or, +   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are, +   * run to completion before a {@code Future} is returned to the caller (unless the executor has, +   * been shutdown)., +   * <p>Although all tasks are immediately executed in the thread that submitted the task, this, +   * {@code ExecutorService} imposes a small locking overhead on each task submission in order to, +   * implement shutdown and termination behavior., +   * <p>The implementation deviates from the {@code ExecutorService} specification with regards to, +   * the {@code shutdownNow} method. First, "best-effort" with regards to canceling running tasks is, +   * implemented as "no-effort". No interrupts or other attempts are made to stop threads executing, +   * tasks. Second, the returned list will always be empty, as any submitted task is considered to, +   * have started execution. This applies also to tasks given to {@code invokeAll} or, +   * {@code invokeAny} which are pending serial execution, even the subset of the tasks that have, +   * not yet started execution. It is unclear from the {@code ExecutorService} specification if, +   * these should be included, and it's much easier to implement the interpretation that they not, +   * be. Finally, a call to {@code shutdown} or {@code shutdownNow} may result in concurrent calls, +   * to {@code invokeAll/invokeAny} throwing RejectedExecutionException, although a subset of the, +   * tasks may already have been executed., +   * @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility">mostly, +   *     source-compatible</a> since 3.0), +  @GwtIncompatible, +     * Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor, +    @GuardedBy("lock"), +    private int runningTasks = 0;, +, +    @GuardedBy("lock"), +    private boolean shutdown = false;, +    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {, +        while (true) {, +     * Checks if the executor has been shut down and increments the running task count., +     * @throws RejectedExecutionException if the executor has been previously shutdown, +   * Creates an executor service that runs each task in the thread that invokes, +   * {@code execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually, +   * submitted tasks and to collections of tasks submitted via {@code invokeAll} or, +   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are, +   * run to completion before a {@code Future} is returned to the caller (unless the executor has, +   * been shutdown)., +   * <p>Although all tasks are immediately executed in the thread that submitted the task, this, +   * {@code ExecutorService} imposes a small locking overhead on each task submission in order to, +   * implement shutdown and termination behavior., +   * <p>The implementation deviates from the {@code ExecutorService} specification with regards to, +   * the {@code shutdownNow} method. First, "best-effort" with regards to canceling running tasks is, +   * implemented as "no-effort". No interrupts or other attempts are made to stop threads executing, +   * tasks. Second, the returned list will always be empty, as any submitted task is considered to, +   * have started execution. This applies also to tasks given to {@code invokeAll} or]