[+++ b/guava/src/com/google/common/collect/Ordering.java, + * A comparator, with additional methods to support common operations. This is, + * an "enriched" version of {@code Comparator}, in the same sense that {@link, + * FluentIterable} is an enriched {@link Iterable}). For example: <pre>   {@code, +  // Natural order, +  // Static factories, +, +  // Ordering<Object> singletons, +  /**, +   * Returns an ordering which treats all values as equal. This can be useful in conjunction with, +   * nullsFirst() or nullsLast() to treat all non-null objects as equal, or to make sorting a, +   * no-op., +   *, +   * <p>The returned comparator is serializable., +   */, +  @GwtCompatible(serializable = true), +  @SuppressWarnings("unchecked"), +  public static Ordering<Object> allEqual() {, +    return AllEqualOrdering.INSTANCE;, +  /**, +   * Returns an ordering that compares objects by the natural ordering of their, +   * string representations as returned by {@code toString()}. It does not, +   * support null values., +   *, +   * <p>The comparator is serializable., +   */, +  @GwtCompatible(serializable = true), +  public static Ordering<Object> usingToString() {, +    return UsingToStringOrdering.INSTANCE;, +  // Constructor, +, +   * Constructs a new instance of this class (only invokable by the subclass, +   * constructor, typically implicit)., +   */, +  protected Ordering() {}, +, +  // Instance-based factories (and any static equivalents), +, +  /**, +   * Returns the reverse of this ordering; the {@code Ordering} equivalent to, +   * {@link Collections#reverseOrder(Comparator)}., +   */, +  // type parameter <S> lets us avoid the extra <String> in statements like:, +  // Ordering<String> o = Ordering.<String>natural().reverse();, +  @GwtCompatible(serializable = true), +  public <S extends T> Ordering<S> reverse() {, +    return new ReverseOrdering<S>(this);, +  }, +, +  /**, +   * Returns an ordering that treats {@code null} as less than all other values, +   * and uses {@code this} to compare non-null values., +   */, +  // type parameter <S> lets us avoid the extra <String> in statements like:, +  // Ordering<String> o = Ordering.<String>natural().nullsFirst();, +  @GwtCompatible(serializable = true), +  public <S extends T> Ordering<S> nullsFirst() {, +    return new NullsFirstOrdering<S>(this);, +  }, +, +  /**, +   * Returns an ordering that treats {@code null} as greater than all other, +   * values and uses this ordering to compare non-null values., +   */, +  // type parameter <S> lets us avoid the extra <String> in statements like:, +  // Ordering<String> o = Ordering.<String>natural().nullsLast();, +  @GwtCompatible(serializable = true), +  public <S extends T> Ordering<S> nullsLast() {, +    return new NullsLastOrdering<S>(this);, +  }, +, +  /**, +   * Returns a new ordering on {@code F} which orders elements by first applying, +   * a function to them, then comparing those results using {@code this}. For, +   * example, to compare objects by their string forms, in a case-insensitive, +   * manner, use: <pre>   {@code, +   *   Ordering.from(String.CASE_INSENSITIVE_ORDER), +   *       .onResultOf(Functions.toStringFunction())}</pre>, +  public <F> Ordering<F> onResultOf(Function<F, ? extends T> function) {, +    return new ByFunctionOrdering<F, T>(function, this);, +  }, +, +  /**, +   * Returns an ordering which first uses the ordering {@code this}, but which, +   * in the event of a "tie", then delegates to {@code secondaryComparator}., +   * For example, to sort a bug list first by status and second by priority, you, +   * might use {@code byStatus.compound(byPriority)}. For a compound ordering, +   * with three or more components, simply chain multiple calls to this method., +   *, +   * <p>An ordering produced by this method, or a chain of calls to this method,, +   * is equivalent to one created using {@link Ordering#compound(Iterable)} on, +   * the same component comparators., +   */, +  @GwtCompatible(serializable = true), +  public <U extends T> Ordering<U> compound(, +      Comparator<? super U> secondaryComparator) {, +    return new CompoundOrdering<U>(this, checkNotNull(secondaryComparator));, +   * Returns the least of the specified values according to this ordering. If, +   * there are multiple least values, the first of those is returned. The, +   * iterator will be left exhausted: its {@code hasNext()} method will return]