[+++ b/android/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/Stats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new StatsAccumulator().addAll(first).snapshot()}, if both were, +   * obtained by calling {@code snapshot()} on the same {@link StatsAccumulator} without adding any, +   * values in between the two calls, or if one is obtained from the other after round-tripping, +   * through java serialization. However, floating point rounding errors mean that it may be false, +   * for some instances where the statistics are mathematically equal, including instances, +   * constructed from the same values in a different order... or (in the general case) even in the, +   * same order. (It is guaranteed to return true for instances constructed from the same values in, +   * the same order if {@code strictfp} is in effect, or if the system architecture guarantees, +   * {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/Stats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new StatsAccumulator().addAll(first).snapshot()}, if both were, +   * obtained by calling {@code snapshot()} on the same {@link StatsAccumulator} without adding any, +   * values in between the two calls, or if one is obtained from the other after round-tripping, +   * through java serialization. However, floating point rounding errors mean that it may be false, +   * for some instances where the statistics are mathematically equal, including instances, +   * constructed from the same values in a different order... or (in the general case) even in the, +   * same order. (It is guaranteed to return true for instances constructed from the same values in, +   * the same order if {@code strictfp} is in effect, or if the system architecture guarantees, +   * {@code strictfp}-like semantics.), +++ b/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/android/guava/src/com/google/common/math/Stats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new StatsAccumulator().addAll(first).snapshot()}, if both were, +   * obtained by calling {@code snapshot()} on the same {@link StatsAccumulator} without adding any, +   * values in between the two calls, or if one is obtained from the other after round-tripping, +   * through java serialization. However, floating point rounding errors mean that it may be false, +   * for some instances where the statistics are mathematically equal, including instances, +   * constructed from the same values in a different order... or (in the general case) even in the, +   * same order. (It is guaranteed to return true for instances constructed from the same values in, +   * the same order if {@code strictfp} is in effect, or if the system architecture guarantees, +   * {@code strictfp}-like semantics.), +++ b/guava/src/com/google/common/math/PairedStats.java, +   * point values. Two instances are guaranteed to be considered equal if one is copied from the, +   * other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both, +   * were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without, +   * adding any values in between the two calls, or if one is obtained from the other after, +   * round-tripping through java serialization. However, floating point rounding errors mean that it, +   * may be false for some instances where the statistics are mathematically equal, including, +   * instances constructed from the same values in a different order... or (in the general case), +   * even in the same order. (It is guaranteed to return true for instances constructed from the, +   * same values in the same order if {@code strictfp} is in effect, or if the system architecture, +   * guarantees {@code strictfp}-like semantics.), +++ b/guava/src/com/google/common/math/Stats.java]