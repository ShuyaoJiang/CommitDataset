[+++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +      "com.google.common.util.concurrent.Futures$CollectionFuture");, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +      "com.google.common.util.concurrent.Futures$CollectionFuture");, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +, +  /**, +   * A less abstract subclass of AbstractFuture.  This can be used to optimize setFuture by ensuring, +   * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}., +   */, +  abstract static class TrustedFuture<V> extends AbstractFuture<V> {, +    // N.B. cancel is not overridden to be final, because many future utilities need to override, +    // cancel in order to propagate cancellation to other futures., +, +    @Override public final V get() throws InterruptedException, ExecutionException {, +      return super.get();, +    }, +, +    @Override public final V get(long timeout, TimeUnit unit), +        throws InterruptedException, ExecutionException, TimeoutException {, +      return super.get(timeout, unit);, +    }, +, +    @Override public final boolean isDone() {, +      return super.isDone();, +    }, +, +    @Override public final boolean isCancelled() {, +      return super.isCancelled();, +    }, +, +    @Override public final void addListener(Runnable listener, Executor executor) {, +      super.addListener(listener, executor);, +    }, +  }, +, +    if (future instanceof TrustedFuture) {, +      // Break encapsulation for TrustedFuture instances since we know that subclasses cannot, +      // override .get() (since it is final) and therefore this is equivalent to calling .get(), +      // and unpacking the exceptions like we do below (just much faster because it is a single, +      // field read instead of a read, several branches and possibly creating exceptions)., +      valueToSet = ((AbstractFuture<?>) future).value;, +    } else {, +      // Otherwise calculate valueToSet by calling .get(), +    }, +    // We call this after the listeners on the theory that done() will only be used for 'cleanup', +    // oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be executing, +    // more important work.  A counter argument would be that done() is trusted code and therefore, +    // it would be safe to run before potentially slow or poorly behaved listeners.  Reevaluate this, +    // once we have more examples of done() implementations., +    done();, +  /**, +   * Callback method that is called immediately after the future is completed., +   *, +   * <p>This is called exactly once, after all listeners have executed.  By default it does nothing., +   */, +  void done() {}, +, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +      "com.google.common.util.concurrent.Futures$CollectionFuture");, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +, +  /**, +   * A less abstract subclass of AbstractFuture.  This can be used to optimize setFuture by ensuring, +   * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}., +   */, +  abstract static class TrustedFuture<V> extends AbstractFuture<V> {, +    // N.B. cancel is not overridden to be final, because many future utilities need to override, +    // cancel in order to propagate cancellation to other futures., +, +    @Override public final V get() throws InterruptedException, ExecutionException {, +      return super.get();, +    }, +, +    @Override public final V get(long timeout, TimeUnit unit), +        throws InterruptedException, ExecutionException, TimeoutException {, +      return super.get(timeout, unit);, +    }, +, +    @Override public final boolean isDone() {, +      return super.isDone();, +    }, +, +    @Override public final boolean isCancelled() {, +      return super.isCancelled();, +    }, +, +    @Override public final void addListener(Runnable listener, Executor executor) {, +      super.addListener(listener, executor);, +    }, +  }, +, +    if (future instanceof TrustedFuture) {, +      // Break encapsulation for TrustedFuture instances since we know that subclasses cannot, +      // override .get() (since it is final) and therefore this is equivalent to calling .get(), +      // and unpacking the exceptions like we do below (just much faster because it is a single, +      // field read instead of a read, several branches and possibly creating exceptions)., +      valueToSet = ((AbstractFuture<?>) future).value;, +    } else {, +      // Otherwise calculate valueToSet by calling .get()]