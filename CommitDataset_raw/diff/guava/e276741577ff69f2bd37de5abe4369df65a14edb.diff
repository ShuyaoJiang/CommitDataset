[+++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import java.util.concurrent.Executors;, +  public void testLazyTransform_exception() throws Exception {, +    final RuntimeException exception = new RuntimeException("deliberate");, +    Function<Integer, String> function = new Function<Integer, String>() {, +      @Override public String apply(Integer input) {, +        throw exception;, +      }, +    };, +    Future<String> transformed = Futures.lazyTransform(Futures.immediateFuture(1), function);, +    try {, +      transformed.get();, +      fail();, +    } catch (ExecutionException expected) {, +      assertSame(exception, expected.getCause());, +    }, +    try {, +      transformed.get(1, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertSame(exception, expected.getCause());, +    }, +  }, +, +  public void testTransform_asyncFunction_timeout(), +      throws InterruptedException, ExecutionException {, +    AsyncFunction<String, Integer> function = constantAsyncFunction(Futures.immediateFuture(1));, +    ListenableFuture<Integer> future = Futures.transform(, +        SettableFuture.<String>create(), function);, +    try {, +      future.get(1, TimeUnit.MILLISECONDS);, +      fail();, +    } catch (TimeoutException expected) {}, +  }, +, +  public void testTransform_asyncFunction_error() {, +    final Error error = new Error("deliberate");, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override public ListenableFuture<Integer> apply(String input) {, +        throw error;, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    Futures.transform(inputFuture, function);, +    try {, +      inputFuture.set("value");, +    } catch (Error expected) {, +      assertSame(error, expected);, +      return;, +    }, +    fail("should have thrown error");, +  }, +, +  public void testTransform_asyncFunction_cancelledWhileApplyingFunction(), +      throws InterruptedException, ExecutionException {, +    final CountDownLatch inFunction = new CountDownLatch(1);, +    final CountDownLatch functionDone = new CountDownLatch(1);, +    final SettableFuture<Integer> resultFuture = SettableFuture.create();, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override public ListenableFuture<Integer> apply(String input) throws Exception {, +        inFunction.countDown();, +        functionDone.await();, +        return resultFuture;, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ListenableFuture<Integer> future = Futures.transform(, +        inputFuture, function, Executors.newSingleThreadExecutor());, +    inputFuture.set("value");, +    inFunction.await();, +    future.cancel(false);, +    functionDone.countDown();, +    try {, +      future.get();, +      fail();, +    } catch (CancellationException expected) {}, +    try {, +      resultFuture.get();, +      fail();, +    } catch (CancellationException expected) {}, +  }, +, +  public void testAllAsList_error() throws Exception {, +    Error error = new Error("deliberate");, +    SettableFuture<String> future1 = SettableFuture.create();, +    ListenableFuture<String> future2 = Futures.immediateFuture("results");, +    ListenableFuture<List<String>> compound = Futures.allAsList(ImmutableList.of(future1, future2));, +, +    try {, +      future1.setException(error);, +    } catch (Error expected) {, +      assertSame(error, expected);, +      try {, +        compound.get();, +      } catch (ExecutionException ee) {, +        assertSame(error, ee.getCause());, +        return;, +      }, +      fail("Expected error not set in compound future.");, +    }]