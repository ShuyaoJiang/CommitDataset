[+++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/CharMatcher.java, +      new FastMatcher("CharMatcher.ANY") {, +      new FastMatcher("CharMatcher.NONE") {, +    return new FastMatcher(description) {, +    return new FastMatcher(description) {, +        return isEither(sequence.charAt(0), sequence.charAt(1));, +    // TODO(user): is it potentially worth just going ahead and building a precomputed matcher?, +  private static CharMatcher isEither(, +      final char match1,, +      final char match2) {, +    String toString = new StringBuilder("CharMatcher.anyOf(\""), +      .append(match1), +      .append(match2), +      .append("\")"), +      .toString();, +    return new FastMatcher(toString) {, +      @Override public boolean matches(char c) {, +        return c == match1 || c == match2;, +      }, +    };, +  }, +, +    return new FastMatcher(description) {, +    return new NegatedMatcher(this);, +  }, +, +  private static class NegatedMatcher extends CharMatcher {, +    final CharMatcher original;, +, +    NegatedMatcher(String toString, CharMatcher original) {, +      super(toString);, +      this.original = original;, +    }, +, +    NegatedMatcher(CharMatcher original) {, +      this(original + ".negate()", original);, +    }, +, +, +    @Override, +    CharMatcher withToString(String description) {, +      return new NegatedMatcher(description, original);, +    }, +  }, +  private static final int DISTINCT_CHARS = Character.MAX_VALUE - Character.MIN_VALUE + 1;, +, +  /**, +   * A matcher for which precomputation will not yield any significant benefit., +   */, +  abstract static class FastMatcher extends CharMatcher {, +    FastMatcher() {, +      super();, +    }, +, +    FastMatcher(String description) {, +      super(description);, +    }, +, +    @Override, +    public final CharMatcher precomputed() {, +      return this;, +    }, +, +    @Override, +    public CharMatcher negate() {, +      return new NegatedFastMatcher(this);, +    }, +  }, +, +  static final class NegatedFastMatcher extends NegatedMatcher {, +    NegatedFastMatcher(CharMatcher original) {, +      super(original);, +    }, +, +    NegatedFastMatcher(String toString, CharMatcher original) {, +      super(toString, original);, +    }, +, +    @Override, +    public final CharMatcher precomputed() {, +      return this;, +    }, +, +    @Override, +    CharMatcher withToString(String description) {, +      return new NegatedFastMatcher(description, original);, +    }, +  public static final CharMatcher WHITESPACE = new FastMatcher("CharMatcher.WHITESPACE") {, +++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/CharMatcher.java, +      new FastMatcher("CharMatcher.ANY") {, +      new FastMatcher("CharMatcher.NONE") {, +    return new FastMatcher(description) {, +    return new FastMatcher(description) {, +        return isEither(sequence.charAt(0), sequence.charAt(1));, +    // TODO(user): is it potentially worth just going ahead and building a precomputed matcher?, +  private static CharMatcher isEither(, +      final char match1,, +      final char match2) {, +    String toString = new StringBuilder("CharMatcher.anyOf(\""), +      .append(match1)]