[+++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +import org.truth0.subjects.CollectionSubject;, +, +import java.util.Collection;, +import java.util.Collections;, +  @SuppressWarnings("rawtypes") // Trying to test TypeToken.of(List.class), +    assertThat(types).has().allOf(, +    assertThat(types.interfaces()).has().allOf(, +    assertThat(types.classes()).has().allOf(, +    assertThat(types.rawTypes()).has().allOf(, +    assertThat(types.interfaces().rawTypes()).has().allOf(, +    assertThat(types.classes().rawTypes()).has().allOf(, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<B>() {}.capture()).getTypes();, +    assertThat(types).has().allOf(, +    assertThat(types.interfaces()), +        .has().allOf(TypeToken.of(Interface1.class)), +        .inOrder();, +    assertThat(types.classes()), +        .has().allOf(TypeToken.of(Class1.class), TypeToken.of(Object.class)), +        .inOrder();, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<B>() {}.capture()).getTypes();, +    assertThat(types.rawTypes()), +        .has().allOf(Interface1.class, Class1.class, Object.class);, +    assertThat(types.interfaces().rawTypes()), +        .has().allOf(Interface1.class), +        .inOrder();, +    assertThat(types.classes().rawTypes()), +        .has().allOf(Class1.class, Object.class), +        .inOrder();, +    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<A>() {}.capture()).getTypes();, +    assertThat(types.rawTypes()), +        .has().allOf(Interface1.class, Interface2.class, Interface3.class, Iterable.class);, +    assertThat(TypeToken.of(new TypeCapture<T>() {}.capture()).getGenericInterfaces()), +        .has().allOf(new TypeToken<Iterable<String>>() {});, +    assertThat(TypeToken.of(new TypeCapture<T>() {}.capture()).getGenericInterfaces()), +        .has().allOf(TypeToken.of(CharSequence.class), new TypeToken<Iterable<String>>() {});, +    assertThat(TypeToken.of(new TypeCapture<T>() {}.capture()).getGenericInterfaces()), +        .has().allOf(TypeToken.of(CharSequence.class), new TypeToken<Iterable<T>>() {});, +    assertThat(TypeToken.of(new TypeCapture<T>() {}.capture()).getGenericInterfaces()), +        .has().allOf(new TypeToken<Iterable<T>>() {});, +    assertThat(TypeToken.of(new TypeCapture<T2>() {}.capture()).getGenericInterfaces()), +        .has().allOf(TypeToken.of(new TypeCapture<T1>() {}.capture()));, +    assertThat(TypeToken.of(Types.subtypeOf(interfaceType.getType())).getGenericInterfaces()), +        .has().allOf(interfaceType);, +    @SuppressWarnings("rawtypes") // To test TypeToken<List>, +    @SuppressWarnings("rawtypes") // Trying to test raw class, +    @SuppressWarnings("rawtypes") // Trying to test raw class, +    @SuppressWarnings("rawtypes") // Trying to test raw class, +    @SuppressWarnings("rawtypes") // Trying to test raw class, +  @SuppressWarnings("rawtypes") // Trying to test raw class, +    @SuppressWarnings("rawtypes") // Iterable.class, +  @SuppressWarnings({"rawtypes", "unchecked"}) // purpose is to test raw type, +  public void testRejectTypeVariable_class() {, +    assertNoTypeVariable(String.class);, +    assertNoTypeVariable(String[].class);, +    assertNoTypeVariable(int[].class);, +  }, +, +  public void testRejectTypeVariable_parameterizedType() {, +    assertNoTypeVariable(new TypeCapture<Iterable<String>>() {}.capture());, +  }, +, +  public void testRejectTypeVariable_wildcardType() {, +    assertNoTypeVariable(, +        new TypeCapture<Iterable<? extends String>>() {}.capture());, +    assertNoTypeVariable(, +        new TypeCapture<Iterable<? super String>>() {}.capture());, +  }, +, +  public void testRejectTypeVariable_genericArrayType() {, +    assertNoTypeVariable(, +        new TypeCapture<Iterable<? extends String>[]>() {}.capture());, +  }, +, +  public <T> void testRejectTypeVariable_withTypeVariable() {, +    assertHasTypeVariable(new TypeCapture<T>() {}.capture());, +    assertHasTypeVariable(new TypeCapture<T[]>() {}.capture());, +    assertHasTypeVariable(new TypeCapture<Iterable<T>>() {}.capture());, +    assertHasTypeVariable(new TypeCapture<Map<String, T>>() {}.capture());, +    assertHasTypeVariable(, +        new TypeCapture<Map<String, ? extends T>>() {}.capture());, +    assertHasTypeVariable(, +        new TypeCapture<Map<String, ? super T[]>>() {}.capture());, +  }, +, +  private static class From<K> {, +    class To<V> {, +      Type type() {, +        return new TypeToken<To<V>>(getClass()) {}.getType();, +      }, +    }, +  }, +, +  public <T> void testRejectTypeVariable_withOwnerType() {, +    // Neither has subclass, +    assertHasTypeVariable(new From<Integer>().new To<String>().type());, +    assertHasTypeVariable(new From<T>().new To<String>().type());, +    assertHasTypeVariable(new From<Integer>().new To<T>().type());, +, +    // Owner is subclassed]