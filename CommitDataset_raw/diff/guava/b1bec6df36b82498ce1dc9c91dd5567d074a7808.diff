[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  private abstract static class AbstractCatchingFuture<V, X extends Throwable, F>, +      extends AbstractFuture.TrustedFuture<V> implements Runnable {, +    @Nullable ListenableFuture<? extends V> running;, +    @Nullable Class<X> exceptionType;, +    @Nullable F fallback;, +    AbstractCatchingFuture(, +        ListenableFuture<? extends V> input, Class<X> exceptionType, F fallback) {, +      this.exceptionType = checkNotNull(exceptionType);, +      this.running = checkNotNull(input);, +      this.fallback = checkNotNull(fallback);, +    }, +    @Override public final void run() {, +      Class<X> localExceptionType = exceptionType;, +      F localFallback = fallback;, +      if (localRunning == null | localExceptionType == null | localFallback == null, +          | isCancelled()) {, +        if (isInstanceOfThrowableClass(throwable, localExceptionType)) {, +          doFallback(localFallback, castThrowable);, +, +    /** Template method for subtypes to actually run the fallback. */, +    abstract void doFallback(F fallback, X throwable) throws Exception;, +, +    @Override final void done() {, +      this.running = null;, +      this.exceptionType = null;, +      this.fallback = null;, +    public final boolean cancel(boolean mayInterruptIfRunning) {, +      // we need to read this field prior to calling super.cancel() because cancel will null it out, +   * A {@link AbstractCatchingFuture} that delegates to an {@link AsyncFunction}, +   * and {@link #setFuture(ListenableFuture)} to implement {@link #doFallback}, +   */, +  static final class AsyncCatchingFuture<V, X extends Throwable>, +      extends AbstractCatchingFuture<V, X, AsyncFunction<? super X, ? extends V>> {, +, +    AsyncCatchingFuture(ListenableFuture<? extends V> input, Class<X> exceptionType,, +        AsyncFunction<? super X, ? extends V> fallback) {, +      super(input, exceptionType, fallback);, +    }, +, +    @Override void doFallback(, +        AsyncFunction<? super X, ? extends V> fallback, X cause) throws Exception {, +      ListenableFuture<? extends V> replacement = fallback.apply(cause);, +      checkNotNull(replacement, "AsyncFunction.apply returned null instead of a Future. ", +          + "Did you mean to return immediateFuture(null)?");, +      setFuture(replacement);, +    }, +  }, +, +  /**, +   * A {@link AbstractCatchingFuture} that delegates to a {@link Function}, +   * and {@link #set(Object)} to implement {@link #doFallback}, +   */, +  static final class CatchingFuture<V, X extends Throwable>, +      extends AbstractCatchingFuture<V, X, Function<? super X, ? extends V>> {, +    CatchingFuture(ListenableFuture<? extends V> input, Class<X> exceptionType,, +        Function<? super X, ? extends V> fallback) {, +      super(input, exceptionType, fallback);, +    }, +, +    @Override void doFallback(Function<? super X, ? extends V> fallback, X cause) throws Exception {, +      V replacement = fallback.apply(cause);, +      set(replacement);, +    }, +  }, +, +  /**, +    @Nullable ListenableFuture<V> delegateRef;, +    @Nullable Future<?> timer;, +      @Nullable TimeoutFuture<V> timeoutFutureRef;, +    AsyncChainingFuture<I, O> output = new AsyncChainingFuture<I, O>(input, function);, +    AsyncChainingFuture<I, O> output = new AsyncChainingFuture<I, O>(input, function);, +    input.addListener(output, rejectionPropagatingExecutor(executor, output));, +   * Returns an Executor that will propagate {@link RejectedExecutionException} from the delegate, +   * executor to the given {@code future}., +   *, +   * <p>Note, the returned executor can only be used once., +  private static Executor rejectionPropagatingExecutor(, +      final Executor delegate, final AbstractFuture<?> future) {, +    checkNotNull(delegate);, +    if (delegate == directExecutor()) {, +      // directExecutor() cannot throw RejectedExecutionException, +      return delegate;, +    }, +    return new Executor() {, +      volatile boolean thrownFromDelegate = true;, +      @Override public void execute(final Runnable command) {, +          delegate.execute(new Runnable() {, +              thrownFromDelegate = false;, +              command.run();, +          if (thrownFromDelegate) {, +            future.setException(e);, +    ChainingFuture<I, O> output = new ChainingFuture<I, O>(input, function);, +    ChainingFuture<I, O> output = new ChainingFuture<I, O>(input, function);, +    input.addListener(output, rejectionPropagatingExecutor(executor, output));, +    return output;, +  private abstract static class AbstractChainingFuture<I, O, F>, +    @Nullable ListenableFuture<? extends I> inputFuture;, +    @Nullable F function;, +    AbstractChainingFuture(ListenableFuture<? extends I> inputFuture, F function) {]