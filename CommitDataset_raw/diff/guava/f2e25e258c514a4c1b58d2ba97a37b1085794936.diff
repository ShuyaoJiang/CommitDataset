[+++ b/guava-testlib/src/com/google/common/testing/GcFinalization.java, +// Copyright 2011 Google Inc. All Rights Reserved., +, +package com.google.common.testing;, +, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, +, +import com.google.common.annotations.Beta;, +, +import java.lang.ref.WeakReference;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeoutException;, +, +/**, + * Testing utilities relating to garbage collection finalization., + *, + * <p>Use this class to test code triggered by <em>finalization</em>, that is, one of the, + * following actions taken by the java garbage collection system:, + *, + * <ul>, + * <li>invoking the {@code finalize} methods of unreachable objects, + * <li>clearing weak references to unreachable referents, + * <li>enqueuing weak references to unreachable referents in their reference queue, + * </ul>, + *, + * <p>This class uses (possibly repeated) invocations of {@link java.lang.System#gc()} to cause, + * finalization to happen.  However, a call to {@code System.gc()} is specified to be no more, + * than a hint, so this technique may fail at the whim of the JDK implementation, for example if, + * a user specified the JVM flag {@code -XX:+DisableExplicitGC}.  But in practice, it works very, + * well for ordinary tests., + *, + * <p>Failure of the expected event to occur within an implementation-defined "reasonable" time, + * period will result in a {@link TimeoutException}., + *, + * <p>Here's an example that tests a {@code finalize} method:, + *, + * <pre>   {@code, + *   final CountDownLatch latch = new CountDownLatch(1);, + *   Object x = new MyClass() {, + *     ..., + *     protected void finalize() { latch.countDown(); ... }, + *   };, + *   x = null;  // Hint to the JIT that x is unreachable, + *   GcFinalization.await(latch);, + * }</pre>, + *, + * <p>Here's an example that uses a user-defined finalization predicate:, + *, + * <pre>   {@code, + *   final WeakHashMap<Object, Object> map = new WeakHashMap<Object, Object>();, + *   map.put(new Object(), Boolean.TRUE);, + *   GcFinalization.awaitDone(new FinalizationPredicate() {, + *     public boolean isDone() {, + *       return map.isEmpty();, + *     }, + *   });, + * }</pre>, + *, + * <p>This class cannot currently be used to test soft references, since this class does not try to, + * create the memory pressure required to cause soft references to be cleared., + *, + * @author schmoe@google.com (mike nonemacher), + * @author martinrb@google.com (Martin Buchholz), + * @since 11.0, + */, +@Beta, +public final class GcFinalization {, +  private GcFinalization() {}, +, +  /**, +   * 10 seconds ought to be long enough for any object to be GC'ed and finalized.  Unless we have a, +   * gigantic heap, in which case we scale by heap size., +   */, +  private static long timeoutNanos() {, +    // This class can make no hard guarantees.  The methods in this class are inherently flaky, but, +    // we try hard to make them robust in practice.  We could additionally try to add in a system, +    // load timeout multiplier.  Or we could try to use a CPU time bound instead of wall clock time, +    // bound.  But these ideas are harder to implement.  We do not try to detect or handle a, +    // user-specified -XX:+DisableExplicitGC., +    //, +    // TODO: Consider using java/lang/management/OperatingSystemMXBean.html#getSystemLoadAverage(), +    //, +    // TODO: Consider scaling by number of mutator threads, e.g. using Thread#activeCount(), +    long seconds = Math.max(10L, Runtime.getRuntime().totalMemory() / (32L * 1024L * 1024L));, +    return NANOSECONDS.convert(seconds, SECONDS);, +  }, +, +  /**, +   * Waits until the given future {@linkplain Future#isDone is done}, invoking the garbage, +   * collector as necessary to try to ensure that this will happen., +   *, +   * @throws InterruptedException if interrupted while waiting, +   * @throws TimeoutException if timed out, +   */, +  public static void awaitDone(Future<?> future) throws InterruptedException, TimeoutException {, +    if (future.isDone()) {]