[+++ b/guava/src/com/google/common/util/concurrent/Monitor.java, + * @author Martin Buchholz, +  // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock., +  // TODO(user): "Port" jsr166 tests for ReentrantLock., +  // TODO(user): Change API to make it impossible to use a Guard with the "wrong" monitor,, +  //    by making the monitor implicit, and to eliminate other sources of IMSE., +  //    Imagine:, +  //    guard.lock();, +  //    try { /* monitor locked and guard satisfied here */ }, +  //    finally { guard.unlock(); }, +  // TODO(user): Implement ReentrantLock features:, +  //    - toString() method, +  //    - getOwner() method, +  //    - getQueuedThreads() method, +  //    - getWaitingThreads(Guard) method, +  //    - implement Serializable, +  //    - redo the API to be as close to identical to ReentrantLock as possible,, +  //      since, after all, this class is also a reentrant mutual exclusion lock!?, +, +  /*, +   * One of the key challenges of this class is to prevent lost signals, while trying hard to, +   * minimize unnecessary signals.  One simple and correct algorithm is to signal some other, +   * waiter with a satisfied guard (if one exists) whenever any thread occupying the monitor, +   * exits the monitor, either by unlocking all of its held locks, or by starting to wait for a, +   * guard.  This includes exceptional exits, so all control paths involving signalling must be, +   * protected by a finally block., +   *, +   * Further optimizations of this algorithm become increasingly subtle.  A wait that terminates, +   * without the guard being satisfied (due to timeout, but not interrupt) can then immediately, +   * exit the monitor without signalling.  If it timed out without being signalled, it does not, +   * need to "pass on" the signal to another thread.  If it *was* signalled, then its guard must, +   * have been satisfied at the time of signal, and has since been modified by some other thread, +   * to be non-satisfied before reacquiring the lock, and that other thread takes over the, +   * responsibility of signaling the next waiter., +   *, +   * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to, +   * be lost, because the signal may be sent to a condition whose sole waiter has just been, +   * interrupted., +   *, +   * Imagine a monitor with multiple guards.  A thread enters the monitor, satisfies all the, +   * guards, and leaves, calling signalNextWaiter.  With traditional locks and conditions, all, +   * the conditions need to be signalled because it is not known which if any of them have, +   * waiters (and hasWaiters can't be used reliably because of a check-then-act race).  With our, +   * Monitor guards, we only signal the first active guard that is satisfied.  But the, +   * corresponding thread may have already been interrupted and is waiting to reacquire the lock, +   * while still registered in activeGuards, in which case the signal is a no-op, and the, +   * bigger-picture signal is lost unless interrupted threads take special action by, +   * participating in the signal-passing game., +   */, +    /** The next active guard */, +    @GuardedBy("monitor.lock"), +    Guard next;, +, +   * A linked list threaded through the Guard.next field., +  private Guard activeGuards = null;, +    long deadline = System.nanoTime() + timeoutNanos;, +    boolean interrupted = Thread.interrupted();, +          return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);, +        } catch (InterruptedException interrupt) {, +          interrupted = true;, +          timeoutNanos = deadline - System.nanoTime();, +      if (interrupted) {, +    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();, +, +    boolean satisfied = false;, +      if (!guard.isSatisfied()) {, +        await(guard, signalBeforeWaiting);, +      }, +      satisfied = true;, +      if (!satisfied) {, +        leave();, +    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();, +, +    boolean satisfied = false;, +      if (!guard.isSatisfied()) {, +        awaitUninterruptibly(guard, signalBeforeWaiting);, +      }, +      satisfied = true;, +      if (!satisfied) {, +        leave();, +   * @return whether the monitor was entered with the guard satisfied, +    long timeoutNanos = unit.toNanos(time);, +    if (fair || !lock.tryLock()) {, +      long deadline = System.nanoTime() + timeoutNanos;, +      timeoutNanos = deadline - System.nanoTime();, +, +    boolean threw = true;, +      satisfied = guard.isSatisfied() || awaitNanos(guard, timeoutNanos, reentrant);, +      threw = false;, +      return satisfied;, +        try {, +          // Don't need to signal if timed out, but do if interrupted, +          if (threw && !reentrant) {, +            signalNextWaiter();, +          }, +        } finally {, +    }, +   * @return whether the monitor was entered with the guard satisfied, +    long timeoutNanos = unit.toNanos(time);, +    long deadline = System.nanoTime() + timeoutNanos;]