[+++ b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java, +      builder.expireAfterWrite(3600, SECONDS);, +      builder.expireAfterAccess(3600, SECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +  }, +, +  public void testTimeToIdleAndToLive() {, +    CacheBuilder<Object, Object> builder =, +        CacheBuilder.newBuilder().expireAfterAccess(1, NANOSECONDS);, +    try {, +      builder.expireAfterWrite(1, NANOSECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +, +    builder = CacheBuilder.newBuilder().expireAfterWrite(1, NANOSECONDS);, +    try {, +      builder.expireAfterAccess(1, NANOSECONDS);, +++ b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java, +      builder.expireAfterWrite(3600, SECONDS);, +      builder.expireAfterAccess(3600, SECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +  }, +, +  public void testTimeToIdleAndToLive() {, +    CacheBuilder<Object, Object> builder =, +        CacheBuilder.newBuilder().expireAfterAccess(1, NANOSECONDS);, +    try {, +      builder.expireAfterWrite(1, NANOSECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +, +    builder = CacheBuilder.newBuilder().expireAfterWrite(1, NANOSECONDS);, +    try {, +      builder.expireAfterAccess(1, NANOSECONDS);, +++ b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java, +    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));, +    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));, +++ b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java, +      builder.expireAfterWrite(3600, SECONDS);, +      builder.expireAfterAccess(3600, SECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +  }, +, +  public void testTimeToIdleAndToLive() {, +    CacheBuilder<Object, Object> builder =, +        CacheBuilder.newBuilder().expireAfterAccess(1, NANOSECONDS);, +    try {, +      builder.expireAfterWrite(1, NANOSECONDS);, +      fail();, +    } catch (IllegalStateException expected) {}, +, +    builder = CacheBuilder.newBuilder().expireAfterWrite(1, NANOSECONDS);, +    try {, +      builder.expireAfterAccess(1, NANOSECONDS);, +++ b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java, +    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));, +    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));, +++ b/guava-tests/test/com/google/common/cache/CacheTesting.java, +      if (cchm.usesWriteQueue()) {, +        Set<ReferenceEntry<?, ?>> entries = Sets.newIdentityHashSet();, +        for (ReferenceEntry<?, ?> current : segment.writeQueue) {, +          assertTrue(entries.add(current));, +            assertSame(prev, current.getPreviousInWriteQueue());, +            assertSame(prev.getNextInWriteQueue(), current);, +            assertTrue(prev.getWriteTime() <= current.getWriteTime());, +        assertEquals(segment.count, entries.size());, +        assertTrue(segment.writeQueue.isEmpty());, +      }, +, +      if (cchm.usesAccessQueue()) {, +        Set<ReferenceEntry<?, ?>> entries = Sets.newIdentityHashSet();, +, +        ReferenceEntry<?, ?> prev = null;, +        for (ReferenceEntry<?, ?> current : segment.accessQueue) {, +          assertTrue(entries.add(current));, +          if (prev != null) {, +            assertSame(prev, current.getPreviousInAccessQueue());, +            assertSame(prev.getNextInAccessQueue(), current);, +            assertTrue(prev.getAccessTime() <= current.getAccessTime());, +          }, +          assertSame(current, segment.getEntry(current.getKey(), current.getHash()));, +          prev = current;, +        }, +        assertEquals(segment.count, entries.size());, +      } else {, +        assertTrue(segment.accessQueue.isEmpty());, +        for (ReferenceEntry<?, ?> current : segment.accessQueue) {, +            assertSame(prev, current.getPreviousInAccessQueue());, +            assertSame(prev.getNextInAccessQueue(), current);, +  static int writeQueueSize(Cache<?, ?> cache) {, +    CustomConcurrentHashMap<?, ?> cchm = toCustomConcurrentHashMap(cache);, +, +    int size = 0;, +    for (Segment<?, ?> segment : cchm.segments) {, +      size += writeQueueSize(segment);, +    }, +    return size;]