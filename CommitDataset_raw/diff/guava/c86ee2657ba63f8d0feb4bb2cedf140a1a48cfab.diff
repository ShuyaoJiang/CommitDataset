[+++ b/android/guava/src/com/google/common/collect/CompactHashMap.java, +  private static final float LOAD_FACTOR = 1.0f;, +    init(DEFAULT_SIZE);, +  CompactHashMap(int expectedSize) {, +    init(expectedSize);, +  void init(int expectedSize) {, +    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays(), +    int expectedSize = modCount;, +    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);, +    this.entries = newEntries(expectedSize);, +    if (next == UNSET) { // uninitialized bucket, +    int oldCapacity = table.length;, +    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {, +      resizeTable(2 * oldCapacity);, +      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {, +    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);, +    init(elementCount);, +++ b/android/guava/src/com/google/common/collect/CompactHashMap.java, +  private static final float LOAD_FACTOR = 1.0f;, +    init(DEFAULT_SIZE);, +  CompactHashMap(int expectedSize) {, +    init(expectedSize);, +  void init(int expectedSize) {, +    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays(), +    int expectedSize = modCount;, +    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);, +    this.entries = newEntries(expectedSize);, +    if (next == UNSET) { // uninitialized bucket, +    int oldCapacity = table.length;, +    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {, +      resizeTable(2 * oldCapacity);, +      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {, +    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);, +    init(elementCount);, +++ b/android/guava/src/com/google/common/collect/CompactHashSet.java, +    return new CompactHashSet<>();, +    return new CompactHashSet<>(expectedSize);, +  private static final float LOAD_FACTOR = 1.0f;, +  // used to indicate blank table entries, +   * The hashtable. Its values are indexes to the elements and entries arrays., +  /**, +   * The elements contained in the set, in the range of [0, size()). The elements in [size(),, +   * elements.length) are all {@code null}., +   */, +    init(DEFAULT_SIZE);, +    init(expectedSize);, +  void init(int expectedSize) {, +    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays(), +    int expectedSize = modCount;, +    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);, +    this.elements = new Object[expectedSize];, +  private int hashTableMask() {, +    return table.length - 1;, +  }, +, +, +    int oldCapacity = table.length;, +    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {, +      resizeTable(2 * oldCapacity);, +    int oldCapacity = entries.length;, +    if (newCapacity > oldCapacity) {, +      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);, +        moveLastEntry(next);, +  void moveLastEntry(int dstIndex) {, +      int currentIndex = firstEntryIndex();, +        return currentIndex >= 0;, +        indexToRemove = currentIndex;, +        E result = (E) elements[currentIndex];, +        currentIndex = getSuccessor(currentIndex);, +        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);, +    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);, +    init(elementCount);, +++ b/android/guava/src/com/google/common/collect/CompactHashMap.java, +  private static final float LOAD_FACTOR = 1.0f;, +    init(DEFAULT_SIZE);, +  CompactHashMap(int expectedSize) {, +    init(expectedSize);, +  void init(int expectedSize) {, +    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays(), +    int expectedSize = modCount;, +    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);, +    this.entries = newEntries(expectedSize);, +    if (next == UNSET) { // uninitialized bucket, +    int oldCapacity = table.length;, +    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {, +      resizeTable(2 * oldCapacity);, +      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {, +    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);, +    init(elementCount);, +++ b/android/guava/src/com/google/common/collect/CompactHashSet.java, +    return new CompactHashSet<>();, +    return new CompactHashSet<>(expectedSize);, +  private static final float LOAD_FACTOR = 1.0f;, +  // used to indicate blank table entries, +   * The hashtable. Its values are indexes to the elements and entries arrays., +  /**, +   * The elements contained in the set, in the range of [0, size()). The elements in [size(),, +   * elements.length) are all {@code null}., +   */, +    init(DEFAULT_SIZE);]