[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/CollectionFuture.java, +/*, + * Copyright (C) 2006 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static com.google.common.base.Preconditions.checkState;, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +, +import com.google.common.base.Optional;, +import com.google.common.collect.ImmutableCollection;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Lists;, +import com.google.common.collect.Sets;, +, +import java.util.List;, +import java.util.Set;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +import java.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +, +/**, + * Emulation of CollectionFuture., + */, +public class CollectionFuture<V, C> extends AbstractFuture.TrustedFuture<C> {, +, +  private static final Logger logger =, +      Logger.getLogger(CollectionFuture.class.getName());, +, +  private ImmutableCollection<? extends ListenableFuture<? extends V>> futures;, +  private final boolean allMustSucceed;, +  private final AtomicInteger remaining;, +  private FutureCollector<V, C> combiner;, +  private List<Optional<V>> values;, +  private Set<Throwable> seenExceptions;, +, +  CollectionFuture(, +      ImmutableCollection<? extends ListenableFuture<? extends V>> futures,, +      boolean allMustSucceed, Executor listenerExecutor,, +      FutureCollector<V, C> combiner) {, +    this.futures = futures;, +    this.allMustSucceed = allMustSucceed;, +    this.remaining = new AtomicInteger(futures.size());, +    this.combiner = combiner;, +    this.values = Lists.newArrayListWithCapacity(futures.size());, +    this.seenExceptions = null; // Initialized once the first time we see an exception, +    init(listenerExecutor);, +  }, +, +  @Override, +  void done() {, +    // Let go of the memory held by other futures, +    this.futures = null;, +, +    // By now the values array has either been set as the Future's value,, +    // or (in case of failure) is no longer useful., +    this.values = null;, +, +    // The combiner may also hold state, so free that as well, +    this.combiner = null;, +  }, +, +  /**, +   * Must be called at the end of the constructor., +   */, +  protected void init(final Executor listenerExecutor) {, +    // Now begin the "real" initialization., +, +    // Corner case: List is empty., +    if (futures.isEmpty()) {, +      set(combiner.combine(ImmutableList.<Optional<V>>of()));, +      return;, +    }, +, +    // Populate the results list with null initially., +    for (int i = 0; i < futures.size(); ++i) {, +      values.add(null);, +    }, +, +    // Register a listener on each Future in the list to update, +    // the state of this future., +    // Note that if all the futures on the list are done prior to completing, +    // this loop, the last call to addListener() will callback to, +    // setOneValue(), transitively call our cleanup listener, and set]