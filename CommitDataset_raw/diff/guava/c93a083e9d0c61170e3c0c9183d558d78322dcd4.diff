[+++ b/guava/src/com/google/common/collect/FluentIterable.java, + * <p>Several lesser-used features are currently available only as static methods on the {@link, + * Iterables} class., + * <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},, + *     {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for, + *     parallelizing stream operations., + * as a {@code List}:, + * <pre>{@code, + * ImmutableList<String> results =, + *         .filter(Client::isActiveInLastMonth), + *         .transform(Object::toString), + *         .toList();, + * }</pre>, + * The approximate stream equivalent is:, + * <pre>{@code, + *         .filter(Client::isActiveInLastMonth), + *         .map(Object::toString), + *         .collect(Collectors.toList());, + * }</pre>, +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#of(T...)}., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#concat}., +   *, +   * <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the, +   * advice in {@link #concat(Iterable...)}., +   *, +   * <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the, +   * advice in {@link #concat(Iterable...)}., +   *, +   * <p><b>{@code Stream} equivalent:</b> to concatenate an arbitrary number of streams, use {@code, +   * Stream.of(stream1, stream2, ...).flatMap(s -> s)}. If the sources are iterables, after the next, +   * release of Guava you can use {@code Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}., +   * @throws NullPointerException if any of the provided iterables is {@code null}, +   * iterator supports it. The methods of the returned iterable may throw {@code, +   * NullPointerException} if any of the input iterators is {@code null}., +   *, +   * <p><b>{@code Stream} equivalent:</b> {@code streamOfStreams.flatMap(s -> s)} or {@code, +   * streamOfIterables.flatMap(Streams::stream)}. (See {@link Streams#stream}.), +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#of(T...)}., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#of(T...)}., +   * Returns a string representation of this fluent iterable, with the format {@code [e1, e2, ...,, +   * en]}., +   * or (less efficiently) {@code stream.collect(Collectors.toList()).toString()}., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#concat}., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter} (same)., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch} (same)., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch} (same)., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#flatMap} (using a function that produces, +   * streams, not iterables)., +   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@link, +   * Stream#findAny}; if it must specifically be the <i>first</i> element, {@code Stream#findFirst}., +   * @throws NullPointerException if the first element is null; if this is a possibility, use {@code, +   *     iterator().next()} or {@link Iterables#getFirst} instead., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip} (same)., +   * same behavior as this fluent iterable. The returned fluent iterable's iterator supports {@code, +   * remove()} if this fluent iterable's iterator does., +   * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit} (same)., +   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}, or after, +   * the next release of Guava, pass {@link ImmutableList#toImmutableList} to {@code, +   * stream.collect()}., +   * <p><b>{@code Stream} equivalent:</b> {@code, +   * ImmutableList.copyOf(stream.sorted(comparator).iterator())}, or after the next release of, +   * Guava, pass {@link ImmutableList#toImmutableList} to {@code, +   * stream.sorted(comparator).collect()}., +   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}, or after, +   * the next release of Guava, pass {@link ImmutableSet#toImmutableSet} to {@code, +   * stream.collect()}., +   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSortedSet.copyOf(comparator,, +   * stream.iterator())}, or after the next release of Guava, pass {@link, +   * ImmutableSortedSet#toImmutableSortedSet} to {@code stream.collect()}., +   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}, or, +   * after the next release of Guava, pass {@link ImmutableMultiset#toImmutableMultiset} to {@code, +   * stream.collect()}., +   * <p><b>{@code Stream} equivalent:</b> after the next release of Guava, use {@code, +   * stream.collect(ImmutableMap.toImmutableMap(k -> k, valueFunction))}. Before then you can use, +   * {@code ImmutableMap.copyOf(stream.collect(Collectors.toMap(k -> k, valueFunction)))}, but be, +   * aware that this may not preserve the order of entries., +   * <pre>{@code, +   * assertThat(colorForName).containsEntry("red", red);, +   * }</pre>, +   * <p><b>{@code Stream} equivalent:</b> after the next release of Guava, use {@code, +   * stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -> v))}. Before then you can use, +   * {@code ImmutableMap.copyOf(stream.collect(Collectors.toMap(keyFunction, v -> v)))}, but be, +   * aware that this may not preserve the order of entries., +   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value, +   *     in this fluent iterable to that value, +   * @throws NullPointerException if any elements of this fluent iterable is null, or if {@code, +   *     keyFunction} produces {@code null} for any value]