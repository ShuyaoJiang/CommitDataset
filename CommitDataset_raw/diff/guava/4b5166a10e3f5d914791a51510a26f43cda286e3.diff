[+++ b/src/com/google/common/base/Equivalences.java, +++ b/src/com/google/common/base/Equivalences.java, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +            if (newEntry != null) {, +          }, +++ b/src/com/google/common/base/Equivalences.java, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +            if (newEntry != null) {, +          }, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +      newEntry.setExpirationTime(original.getExpirationTime());, +      connectExpirables(original.getPreviousExpirable(), newEntry);, +      connectExpirables(newEntry, original.getNextExpirable());, +      nullifyExpirable(original);, +      connectEvictables(original.getPreviousEvictable(), newEntry);, +      connectEvictables(newEntry, original.getNextEvictable());, +      nullifyEvictable(original);, +    /*, +     * Used by entries that are expirable. Expirable entries are, +, +    ReferenceEntry<K, V> getNextExpirable();, +    void setNextExpirable(ReferenceEntry<K, V> next);, +    ReferenceEntry<K, V> getPreviousExpirable();, +    void setPreviousExpirable(ReferenceEntry<K, V> previous);, +, +    /*, +     * Implemented by entries that are evictable. Evictable entries are, +     * maintained in a doubly-linked list. New entries are added at the tail of, +     * the list at write time and stale entries are expired from the head of the, +     * list., +     */, +, +    /** Gets the next entry in the recency list. */, +    ReferenceEntry<K, V> getNextEvictable();, +, +    /** Sets the next entry in the recency list. */, +    void setNextEvictable(ReferenceEntry<K, V> next);, +, +    /** Gets the previous entry in the recency list. */, +    ReferenceEntry<K, V> getPreviousEvictable();, +, +    /** Sets the previous entry in the recency list. */, +    void setPreviousEvictable(ReferenceEntry<K, V> previous);, +  private enum NullEntry implements ReferenceEntry<Object, Object> {, +    public ValueReference<Object, Object> getValueReference() {, +      return null;, +    }, +    @Override, +    public void setValueReference(, +        ValueReference<Object, Object> valueReference) {}, +    @Override, +    public void valueReclaimed() {}, +    @Override, +    public ReferenceEntry<Object, Object> getNext() {, +      return null;, +    }, +    @Override, +    public int getHash() {, +      return 0;, +    }, +    @Override, +    public Object getKey() {, +      return null;, +    }, +, +    @Override, +    public ReferenceEntry<Object, Object> getNextExpirable() {, +    public void setNextExpirable(ReferenceEntry<Object, Object> next) {}, +    public ReferenceEntry<Object, Object> getPreviousExpirable() {, +    public void setPreviousExpirable(ReferenceEntry<Object, Object> previous) {}, +    public ReferenceEntry<Object, Object> getNextEvictable() {, +    public void setNextEvictable(ReferenceEntry<Object, Object> next) {}, +    public ReferenceEntry<Object, Object> getPreviousEvictable() {, +    public void setPreviousEvictable(ReferenceEntry<Object, Object> previous) {}, +  }, +, +  @SuppressWarnings("unchecked"), +  // Safe because impl never uses a parameter or returns any non-null value, +  private static <K, V> ReferenceEntry<K, V> nullEntry() {, +    return (ReferenceEntry<K, V>) NullEntry.INSTANCE;, +    // null expiration, +    @Override, +    public long getExpirationTime() {, +      throw new UnsupportedOperationException();, +    }, +    @Override, +    public void setExpirationTime(long time) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getNextExpirable() {, +      throw new UnsupportedOperationException();, +    }, +    @Override, +    public void setNextExpirable(ReferenceEntry<K, V> next) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override]