[+++ b/guava/src/com/google/common/base/Stopwatch.java, +// Copyright 2008 Google Inc. All Rights Reserved., +, +package com.google.common.base;, +, +import static com.google.common.base.Preconditions.checkNotNull;, +import static com.google.common.base.Preconditions.checkState;, +import static java.util.concurrent.TimeUnit.MICROSECONDS;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, +, +import java.util.concurrent.TimeUnit;, +, +/**, + * An object that measures elapsed time in nanoseconds. Note that measurement, + * overhead is typically on the order of a microsecond (1000 ns) or more., + *, + * <p>This class is not thread-safe., + *, + *<p> Basic usage:, + * <pre>, + *   Stopwatch stopwatch = new Stopwatch().{@link #start()};, + *, + *   long millis = stopwatch.{@link #elapsedMillis()};, + *   long nanos  = stopwatch.{@link #elapsedTime}(TimeUnit.NANOSECONDS);, + *      // Measurement accuracy is really only to millis, but if you want ..., + *, + *   String formatted = stopwatch.{@link #toString()};  // e.g. "1.234 ms" or "23.45 s", + *, + *   stopwatch.{@link #stop()};, + *   stopwatch.{@link #reset()}; // Resets the elapsed time to zero, stops the stopwatch., + * </pre>, + *, + * <p>Note that it is an error to start or stop a Stopwatch that is already, + * started or stopped respectively., + * , + * <p>When testing code that uses this class, use the, + * {@linkplain #Stopwatch(Ticker) alternate constructor} to supply a fake or, + * mock ticker, such as {@link com.google.common.testing.FakeTicker}. This, + * allows you to simulate any valid behavior of the stopwatch., + *, + * @author kevinb@google.com (Kevin Bourrillion), + */, +public final class Stopwatch {, +  private final Ticker ticker;, +  private boolean isRunning;, +  private long elapsedNanos;, +  private long startTick;, +, +  /**, +   * Creates (but does not start) a new stopwatch using {@link System#nanoTime}, +   * as its time source., +   */, +  public Stopwatch() {, +    this(Ticker.systemTicker());, +  }, +, +  /**, +   * Creates (but does not start) a new stopwatch, using the specified time, +   * source., +   */, +  public Stopwatch(Ticker ticker) {, +    this.ticker = checkNotNull(ticker);, +  }, +, +  /**, +   * Returns {@code true} if {@link #start()} has been called on this stopwatch,, +   * and {@link #stop()} has not been called since the last call to {@code, +   * start()}., +   */, +  public boolean isRunning() {, +    return isRunning;, +  }, +, +  /**, +   * Starts the stopwatch., +   *, +   * @throws IllegalStateException if the stopwatch is already running., +   */, +  public Stopwatch start() {, +    checkState(!isRunning);, +    isRunning = true;, +    startTick = ticker.read();, +    return this;, +  }, +, +  /**, +   * Stops the stopwatch. Future reads will return the fixed duration that had, +   * elapsed up to this point., +   *, +   * @throws IllegalStateException if the stopwatch is already stopped., +   */, +  public Stopwatch stop() {, +    long tick = ticker.read();, +    checkState(isRunning);, +    isRunning = false;, +    elapsedNanos += tick - startTick;, +    return this;, +  }]