[+++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java, + * Extracts non-overlapping substrings from an input string, typically by, + * recognizing appearances of a <i>separator</i> sequence. This separator can be, + * specified as a single {@linkplain #on(char) character}, fixed {@linkplain, + * #on(String) string}, {@linkplain #onPattern regular expression} or {@link, + * #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at, + * all, a splitter can extract adjacent substrings of a given {@linkplain, + * #fixedLength fixed length}., + * <p>For example, this expression: <pre>   {@code, + *   Splitter.on(',').split("foo,bar,qux")}</pre>, + * ... produces an {@code Iterable} containing {@code "foo"}, {@code "bar"} and, + * {@code "qux"}, in that order., + * <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The, + * following expression: <pre>   {@code, + *   Splitter.on(',').split(" foo,,,  bar ,")}</pre>, + * ... yields the substrings {@code [" foo", "", "", "  bar ", ""]}. If this, + * is not the desired behavior, use configuration methods to obtain a <i>new</i>, + * splitter instance with modified behavior: <pre>   {@code, + * Now {@code MY_SPLITTER.split("foo,,,  bar ,")} returns just {@code ["foo",, + * "bar"]}. Note that the order in which these configuration methods are called, + * is never significant., + * <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration, + * method has no effect on the receiving instance; you must store and use the, + * new splitter instance it returns instead. <pre>   {@code, + *   // Do NOT do this, + * <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an, + * input string containing {@code n} occurrences of the separator naturally, + * yields an iterable of size {@code n + 1}. So if the separator does not occur, + * anywhere in the input, a single substring is returned containing the entire, + * input. Consequently, all splitters split the empty string to {@code [""]}, + * (note: even fixed-length splitters)., + * <p>Splitter instances are thread-safe immutable, and are therefore safe to, + * store as {@code static final} constants., + *, + * <p>The {@link Joiner} class provides the inverse operation to splitting, but, + * note that a round-trip between the two should be assumed to be lossy., +   * example, {@code Splitter.on(", ").split("foo, bar,baz")} returns an, +   * iterable containing {@code ["foo", "bar,baz"]}., +   * <p><b>Exception:</b> for consistency with separator-based splitters, {@code, +   * split("")} does not yield an empty iterable, but an iterable containing, +   * {@code ""}. This is the only case in which {@code, +   * Iterables.size(split(input))} does not equal {@code, +   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior,, +   * use {@code omitEmptyStrings}., +   *, +   * @param length the desired length of pieces after splitting, a positive, +   *     integer, +   * @throws IllegalArgumentException if {@code length} is zero or negative, +++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java, + * Extracts non-overlapping substrings from an input string, typically by, + * recognizing appearances of a <i>separator</i> sequence. This separator can be, + * specified as a single {@linkplain #on(char) character}, fixed {@linkplain, + * #on(String) string}, {@linkplain #onPattern regular expression} or {@link, + * #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at, + * all, a splitter can extract adjacent substrings of a given {@linkplain, + * #fixedLength fixed length}., + * <p>For example, this expression: <pre>   {@code, + *   Splitter.on(',').split("foo,bar,qux")}</pre>, + * ... produces an {@code Iterable} containing {@code "foo"}, {@code "bar"} and, + * {@code "qux"}, in that order., + * <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The, + * following expression: <pre>   {@code, + *   Splitter.on(',').split(" foo,,,  bar ,")}</pre>, + * ... yields the substrings {@code [" foo", "", "", "  bar ", ""]}. If this, + * is not the desired behavior, use configuration methods to obtain a <i>new</i>, + * splitter instance with modified behavior: <pre>   {@code, + * Now {@code MY_SPLITTER.split("foo,,,  bar ,")} returns just {@code ["foo",, + * "bar"]}. Note that the order in which these configuration methods are called, + * is never significant., + * <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration, + * method has no effect on the receiving instance; you must store and use the, + * new splitter instance it returns instead. <pre>   {@code, + *   // Do NOT do this, + * <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an, + * input string containing {@code n} occurrences of the separator naturally, + * yields an iterable of size {@code n + 1}. So if the separator does not occur, + * anywhere in the input, a single substring is returned containing the entire, + * input. Consequently, all splitters split the empty string to {@code [""]}, + * (note: even fixed-length splitters)., + * <p>Splitter instances are thread-safe immutable, and are therefore safe to, + * store as {@code static final} constants., + *, + * <p>The {@link Joiner} class provides the inverse operation to splitting, but, + * note that a round-trip between the two should be assumed to be lossy., +   * example, {@code Splitter.on(", ").split("foo, bar,baz")} returns an, +   * iterable containing {@code ["foo", "bar,baz"]}., +   * <p><b>Exception:</b> for consistency with separator-based splitters, {@code, +   * split("")} does not yield an empty iterable, but an iterable containing, +   * {@code ""}. This is the only case in which {@code, +   * Iterables.size(split(input))} does not equal {@code, +   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior,, +   * use {@code omitEmptyStrings}., +   *, +   * @param length the desired length of pieces after splitting, a positive, +   *     integer, +   * @throws IllegalArgumentException if {@code length} is zero or negative, +++ b/guava-tests/test/com/google/common/base/SplitterTest.java, +  public void testFixedLengthSimpleSplit() {, +  public void testFixedLengthSplitEqualChunkLength() {, +  public void testFixedLengthSplitOnlyOneChunk() {]