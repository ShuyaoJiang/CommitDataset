[+++ b/guava/src/com/google/common/collect/AsynchronousComputationException.java, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/AsynchronousComputationException.java, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/ComputationException.java, + *, + * @author Bob Lee, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/AsynchronousComputationException.java, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/ComputationException.java, + *, + * @author Bob Lee, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, + * @author Charles Fry, +class ComputingConcurrentHashMap<K, V> extends CustomConcurrentHashMap<K, V> {, +  V compute(K key) {, +              // TODO(user): recordHit, +                      // TODO(user): recordHit, +            // TODO(user): recordMiss, +  /**, +   * Used to provide computation exceptions to other threads., +   */, +    public void clear(ValueReference<K, V> newValue) {}, +  /**, +   * Used to provide computation result to other threads., +   */, +    public void clear(ValueReference<K, V> newValue) {}, +    public void clear(ValueReference<K, V> newValue) {, +      setValueReference(newValue);, +      if (value != null) {, +        // Call setValueReference first to avoid put clearing us., +        // TODO(user): recordMiss, +        // TODO(user): recordCompute, +      }, +, +  // Serialization Support, +      delegate = mapMaker.makeComputingMap(computingFunction);, +++ b/guava/src/com/google/common/collect/AsynchronousComputationException.java, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/ComputationException.java, + *, + * @author Bob Lee, + * @since Guava release 02 (imported from Google Collections Library), +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, + * @author Charles Fry, +class ComputingConcurrentHashMap<K, V> extends CustomConcurrentHashMap<K, V> {, +  V compute(K key) {, +              // TODO(user): recordHit, +                      // TODO(user): recordHit, +            // TODO(user): recordMiss, +  /**, +   * Used to provide computation exceptions to other threads., +   */, +    public void clear(ValueReference<K, V> newValue) {}, +  /**, +   * Used to provide computation result to other threads., +   */, +    public void clear(ValueReference<K, V> newValue) {}, +    public void clear(ValueReference<K, V> newValue) {, +      setValueReference(newValue);, +      if (value != null) {, +        // Call setValueReference first to avoid put clearing us., +        // TODO(user): recordMiss, +        // TODO(user): recordCompute, +      }, +, +  // Serialization Support, +      delegate = mapMaker.makeComputingMap(computingFunction);, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, + * @author Charles Fry, +  // Constants, +  /** Number of (unsynchronized) retries in the containsValue method. */, +  // Fields, +  /**, +   * A reference to a value., +   */, +    /**, +     * Creates a copy of this reference for the given entry., +     */, +     * Clears this reference object., +     *, +     * @param newValue the new value reference which will replace this one; this is only used during, +     *     computation to immediately notify blocked threads of the new value, +    void clear(@Nullable ValueReference<K, V> newValue);, +    public void clear(ValueReference<Object, Object> newValue) {}, +    /**, +     * Gets the next entry in the chain., +     */, +    /**, +     * Gets the entry's hash., +     */, +    /**, +     * Gets the key for this entry., +     */, +    /**, +     * Gets the entry expiration time in ns., +     */, +    /**]