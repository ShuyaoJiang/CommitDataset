[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java, +    if (object == null) {, +      return false;, +    }, +    return Collections2.containsAllImpl(this, targets);, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java, +    if (object == null) {, +      return false;, +    }, +    return Collections2.containsAllImpl(this, targets);, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java, +    if (object == null) {, +      return false;, +    }, +    return Collections2.containsAllImpl(this, targets);, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java, +import com.google.common.base.Optional;, +    @SuppressWarnings("unchecked"), +    E cast = (E) o;, +    // Make sure the object is accepted by the comparator (e.g., the right type, possibly non-null)., +    comparator.compare(cast, cast);, +    return cast;, +    if (occurrences == 0) {, +    } catch (NullPointerException e) {, +      return 0;, +      ToRemove<E> toRemove = new ToRemove<E>();, +            toRemove.setAndGet(path.getTip().getKey()), path.getTip().elemCount());, +        setCount(toRemove.getAndClear(), 0);, +  // If we were ever to resurrect AbstractRemovableIterator, we could use it instead., +  private static final class ToRemove<E> {, +    @Nullable Optional<E> element;, +, +    E setAndGet(@Nullable E element) {, +      this.element = Optional.fromNullable(element);, +      return element;, +    }, +, +    E getAndClear() {, +      checkState(element != null);, +      E returnValue = element.orNull();, +      element = null;, +      return returnValue;, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java, +    if (object == null) {, +      return false;, +    }, +    return Collections2.containsAllImpl(this, targets);, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java, +import com.google.common.base.Optional;, +    @SuppressWarnings("unchecked"), +    E cast = (E) o;, +    // Make sure the object is accepted by the comparator (e.g., the right type, possibly non-null)., +    comparator.compare(cast, cast);, +    return cast;, +    if (occurrences == 0) {, +    } catch (NullPointerException e) {, +      return 0;, +      ToRemove<E> toRemove = new ToRemove<E>();, +            toRemove.setAndGet(path.getTip().getKey()), path.getTip().elemCount());, +        setCount(toRemove.getAndClear(), 0);, +  // If we were ever to resurrect AbstractRemovableIterator, we could use it instead., +  private static final class ToRemove<E> {, +    @Nullable Optional<E> element;, +, +    E setAndGet(@Nullable E element) {, +      this.element = Optional.fromNullable(element);, +      return element;, +    }, +, +    E getAndClear() {, +      checkState(element != null);, +      E returnValue = element.orNull();, +      element = null;, +      return returnValue;, +    }, +  }, +, +++ b/guava-testlib/src/com/google/common/collect/testing/CollectionTestSuiteBuilder.java, +          .suppressing(parentBuilder.getSuppressedTests()), +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java, +    if (object == null) {, +      return false;, +    }, +    return Collections2.containsAllImpl(this, targets);, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java, +import com.google.common.base.Optional;, +    @SuppressWarnings("unchecked"), +    E cast = (E) o;, +    // Make sure the object is accepted by the comparator (e.g., the right type, possibly non-null)., +    comparator.compare(cast, cast);, +    return cast;, +    if (occurrences == 0) {, +    } catch (NullPointerException e) {]