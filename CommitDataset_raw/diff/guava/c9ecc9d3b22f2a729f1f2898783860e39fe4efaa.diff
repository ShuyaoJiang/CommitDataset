[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +      // TODO(user): when we link values instead of entries this method can go, +      // away, as can connectExpirables, nullifyExpirable., +      // TODO(user): when we link values instead of entries this method can go, +      // away, as can connectEvictables, nullifyEvictable., +  static <K, V> ReferenceEntry<K, V> nullEntry() {, +    @Override, +    @Override, +    @Override, +  boolean isExpired(ReferenceEntry<K, V> entry, long now) {, +    return now - entry.getExpirationTime() > 0;, +  V getLiveValue(ReferenceEntry<K, V> entry) {, +    V value = entry.getValueReference().get();, +    return (expires() && isExpired(entry)) ? null : value;, +    /**, +     * A queue of elements currently in the map, ordered by access time., +     * Elements are added to the tail of the queue on access/write., +     */, +    final Queue<ReferenceEntry<K, V>> evictionQueue;, +, +    /**, +     * A queue of elements currently in the map, ordered by expiration time, +     * (either access or write time). Elements are added to the tail of the, +     * queue on access/write., +     */, +    final Queue<ReferenceEntry<K, V>> expirationQueue;, +, +      evictionQueue = evictsBySize(), +          ? new EvictionQueue(), +          : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();, +, +      expirationQueue = expires(), +          ? new ExpirationQueue(), +          : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();, +      evictionQueue.add(entry);, +        expirationQueue.add(entry);, +      ReferenceEntry<K, V> e;, +      while ((e = recencyQueue.poll()) != null) {, +        if (evictionQueue.contains(e)) {, +          evictionQueue.add(e);, +        if (expirationQueue.contains(e)) {, +          expirationQueue.add(e);, +    void recordExpirationTime(ReferenceEntry<K, V> entry,, +      entry.setExpirationTime(System.nanoTime() + expirationNanos);, +      if (expirationQueue.isEmpty()) {, +      ReferenceEntry<K, V> e;, +      while ((e = expirationQueue.peek()) != null && isExpired(e, now)) {, +        if (!unsetEntry(e, e.getHash())) {, +        drainRecencyQueue();, +, +        ReferenceEntry<K, V> e = evictionQueue.remove();, +        if (!unsetEntry(e, e.getHash())) {, +          throw new AssertionError();, +        }, +        ReferenceEntry<K, V> entry) {, +      evictionQueue.remove(entry);, +      expirationQueue.remove(entry);, +      ReferenceEntry<K, V> newFirst = entry.getNext();, +      for (ReferenceEntry<K, V> e = first; e != entry; e = e.getNext()) {, +      evictionQueue.remove(entry);, +      expirationQueue.remove(entry);, +          evictionQueue.clear();, +          expirationQueue.clear();, +, +    // Queues, +, +    /**, +     * A custom queue for managing eviction order. Note that this is tightly, +     * integrated with {@code ReferenceEntry}, upon which it reliese to perform, +     * its linking., +     *, +     * <p>Note that this entire implementation makes the assumption that all, +     * elements which are in the map are also in this queue, and that all, +     * elements not in the queue are not in the map., +     *, +     * <p>The benefits of creating our own queue are that (1) we can, +     * replace elements in the middle of the queue as part of, +     * copyEvictableEntry, and (2) the contains method is highly optimized for, +     * the current model., +     */, +    @VisibleForTesting class EvictionQueue, +        extends AbstractQueue<ReferenceEntry<K, V>> {, +      // TODO(user): create UnsupportedOperationException throwing base class, +      @VisibleForTesting final ReferenceEntry<K, V> head =, +          new ReferenceEntry<K, V>() {, +, +        ReferenceEntry<K, V> nextEvictable = this;, +        public ReferenceEntry<K, V> getNextEvictable() {, +          return nextEvictable;, +        }, +        public void setNextEvictable(ReferenceEntry<K, V> next) {, +          this.nextEvictable = next;, +        }, +, +        ReferenceEntry<K, V> previousEvictable = this;, +        public ReferenceEntry<K, V> getPreviousEvictable() {, +          return previousEvictable;, +        }, +        public void setPreviousEvictable(ReferenceEntry<K, V> previous) {, +          this.previousEvictable = previous;]