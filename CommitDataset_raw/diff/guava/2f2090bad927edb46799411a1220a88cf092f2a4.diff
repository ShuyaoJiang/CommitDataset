[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFuturesChainTest.java, +/*, + * Copyright (C) 2008 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +, +import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;, +, +import java.lang.reflect.UndeclaredThrowableException;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +, +/**, + * Base class for unit tests for {@code Futures.chain} and asynchronous {@code, + * Futures.transform}., + *, + * @author Nishant Thakkar, + */, +public abstract class AbstractFuturesChainTest, +    extends AbstractChainedListenableFutureTest<String> {, +  protected static final int SLOW_OUTPUT_VALID_INPUT_DATA = 2;, +  protected static final int SLOW_FUNC_VALID_INPUT_DATA = 3;, +  private static final String RESULT_DATA = "SUCCESS";, +, +  private SettableFuture<String> outputFuture;, +  // Signals that the function is waiting to complete, +  private CountDownLatch funcIsWaitingLatch;, +  // Signals the function so it will complete, +  private CountDownLatch funcCompletionLatch;, +, +  @Override protected final ListenableFuture<String> buildChainingFuture(, +      ListenableFuture<Integer> inputFuture) {, +    outputFuture = SettableFuture.create();, +    funcIsWaitingLatch = new CountDownLatch(1);, +    funcCompletionLatch = new CountDownLatch(1);, +    return chain(inputFuture);, +  }, +, +  /**, +   * Overridden by subclasses to return the result of {@code, +   * Futures.chain(inputFuture, f)} or {@code, +   * Futures.transform(inputFuture, f)}, where {@code f} is a {@code Function}, +   * or {@code AsyncFunction} that delegates to {@link #apply}., +   */, +  abstract ListenableFuture<String> chain(, +      ListenableFuture<Integer> inputFuture);, +, +  @Override protected String getSuccessfulResult() {, +    return RESULT_DATA;, +  }, +, +  /**, +   * Implements the {@code apply} method of the {@code Function} or {@code, +   * AsyncFunction} used in {@link #chain}., +   */, +  final ListenableFuture<String> apply(Integer input) {, +    switch (input) {, +      case VALID_INPUT_DATA:, +        outputFuture.set(RESULT_DATA);, +        break;, +      case SLOW_OUTPUT_VALID_INPUT_DATA:, +        break;  // do nothing to the result, +      case SLOW_FUNC_VALID_INPUT_DATA:, +        funcIsWaitingLatch.countDown();, +        awaitUninterruptibly(funcCompletionLatch);, +        break;, +      default:, +        throw new UndeclaredThrowableException(EXCEPTION);, +    }, +    return outputFuture;, +  }, +, +  public void testFutureGetThrowsFunctionException() throws Exception {, +    inputFuture.set(EXCEPTION_DATA);, +    listener.assertException(EXCEPTION);, +  }, +, +  public void testFutureGetThrowsCancellationIfInputCancelled(), +      throws Exception {, +    inputFuture.cancel(true); // argument is ignored, +    try {, +      resultFuture.get();, +      fail("Result future must throw CancellationException", +          + " if input future is cancelled.");]