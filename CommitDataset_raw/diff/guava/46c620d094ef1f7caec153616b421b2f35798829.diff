[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, + * <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate, + * added. The collections generated by {@link #entries()}, {@link #keys()}, and, + * <p>The {@link #values()} and {@link #entries()} methods both return a, + * {@code List}, instead of the {@code Collection} specified by the {@link, + * ListMultimap} interface., + *, + * <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()},, + * {@link #values}, {@link #entries()}, and {@link #asMap} return collections, + * that are views of the multimap. If the multimap is modified while an, + * iteration over any of those collections is in progress, except through the, + * iterator's methods, the results of the iteration are undefined., + *, +  private class NodeIterator implements ListIterator<Node<K, V>> {, +    int nextIndex;, +    Node<K, V> next;, +    Node<K, V> previous;, +    NodeIterator() {, +      next = head;, +    }, +    NodeIterator(int index) {, +      int size = size();, +      Preconditions.checkPositionIndex(index, size);, +      if (index >= (size / 2)) {, +        previous = tail;, +        nextIndex = size;, +        while (index++ < size) {, +          previous();, +        }, +      } else {, +        next = head;, +        while (index-- > 0) {, +          next();, +        }, +      }, +      current = null;, +    }, +      previous = current = next;, +      nextIndex++;, +      if (current != next) { // after call to next(), +        previous = current.previous;, +        nextIndex--;, +      } else { // after call to previous(), +        next = current.next;, +      }, +    @Override, +    public boolean hasPrevious() {, +      return previous != null;, +    }, +    @Override, +    public Node<K, V> previous() {, +      checkElement(previous);, +      next = current = previous;, +      previous = previous.previous;, +      nextIndex--;, +      return current;, +    }, +    @Override, +    public int nextIndex() {, +      return nextIndex;, +    }, +    @Override, +    public int previousIndex() {, +      return nextIndex - 1;, +    }, +    @Override, +    public void set(Node<K, V> e) {, +      throw new UnsupportedOperationException();, +    }, +    @Override, +    public void add(Node<K, V> e) {, +      throw new UnsupportedOperationException();, +    }, +    void setValue(V value) {, +      checkState(current != null);, +      current.value = value;, +    }, +      if (current != next) { // after call to next(), +      } else { // after call to previous(), +  private transient List<V> valuesList;, +   * in the order they were added to the multimap. Because the values may have, +   * duplicates and follow the insertion ordering, this method returns a {@link, +   * List}, instead of the {@link Collection} specified in the {@link, +   * ListMultimap} interface., +  public List<V> values() {, +    List<V> result = valuesList;, +      valuesList = result = new AbstractSequentialList<V>() {, +        @Override, +        public ListIterator<V> listIterator(int index) {, +          final NodeIterator nodes = new NodeIterator(index);, +          return new ListIterator<V>() {, +            public boolean hasPrevious() {, +              return nodes.hasPrevious();, +            }, +            @Override, +            public V previous() {, +              return nodes.previous().value;, +            }, +            @Override, +            public int nextIndex() {]