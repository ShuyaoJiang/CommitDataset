[+++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +   * Number of (unsynchronized) retries in the containsValue method., +   */, +  static final int CONTAINS_VALUE_RETRIES = 3;, +, +  /**, +    @VisibleForTesting, +              ++modCount;, +            ++modCount;, +            ++modCount;, +     * actually empty at any point., +    checkNotNull(value); // as does ConcurrentHashMap, +    // This implementation is patterned after ConcurrentHashMap, but without the locking. The only, +    // way for it to return a false negative would be for the target value to jump around in the map, +    // such that none of the subsequent iterations observed it, despite the fact that at every point, +    // in time it was present somewhere int the map. This becomes increasingly unlikely as, +    // CONTAINS_VALUE_RETRIES increases, though without locking it is theoretically possible., +    final Segment<K,V>[] segments = this.segments;, +    int last = -1;, +    for (int i = 0; i < CONTAINS_VALUE_RETRIES; i++) {, +      int sum = 0;, +      for (Segment<K, V> segment : segments) {, +        int c = segment.count; // read-volatile, +, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = segment.table;, +        for (int j = 0 ; j < table.length(); j++) {, +          for (ReferenceEntry<K, V> e = table.get(j); e != null; e = e.getNext()) {, +            V v = segment.getLiveValue(e);, +            if (v != null && valueEquivalence.equivalent(value, v)) {, +        }, +        sum += segment.modCount;, +      }, +      if (sum == last) {, +        break;, +      }, +      last = sum;, +    }]