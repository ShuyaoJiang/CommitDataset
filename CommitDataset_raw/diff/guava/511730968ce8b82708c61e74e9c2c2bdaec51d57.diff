[+++ b/android/guava/src/com/google/common/primitives/UnsignedLongs.java, +    int maxSafePos = ParseOverflowDetection.maxSafeDigits[radix] - 1;, +      if (pos > maxSafePos && ParseOverflowDetection.overflowInParse(value, digit, radix)) {, +  /*, +   * We move the static constants into this class so ProGuard can inline UnsignedLongs entirely, +   * unless the user is actually calling a parse method., +   */, +  private static final class ParseOverflowDetection {, +    private ParseOverflowDetection() {}, +    , +    // calculated as 0xffffffffffffffff / radix, +    static final long[] maxValueDivs = new long[Character.MAX_RADIX + 1];, +    static final int[] maxValueMods = new int[Character.MAX_RADIX + 1];, +    static final int[] maxSafeDigits = new int[Character.MAX_RADIX + 1];, +, +    static {, +      BigInteger overflow = new BigInteger("10000000000000000", 16);, +      for (int i = Character.MIN_RADIX; i <= Character.MAX_RADIX; i++) {, +        maxValueDivs[i] = divide(MAX_VALUE, i);, +        maxValueMods[i] = (int) remainder(MAX_VALUE, i);, +        maxSafeDigits[i] = overflow.toString(i).length() - 1;, +      }, +    }, +, +     * unsigned long. This is useful for detecting overflow while parsing a string representation of, +     * a number. Does not verify whether supplied radix is valid, passing an invalid radix will give, +    static boolean overflowInParse(long current, int digit, int radix) {, +  }, +++ b/android/guava/src/com/google/common/primitives/UnsignedLongs.java, +    int maxSafePos = ParseOverflowDetection.maxSafeDigits[radix] - 1;, +      if (pos > maxSafePos && ParseOverflowDetection.overflowInParse(value, digit, radix)) {, +  /*, +   * We move the static constants into this class so ProGuard can inline UnsignedLongs entirely, +   * unless the user is actually calling a parse method., +   */, +  private static final class ParseOverflowDetection {, +    private ParseOverflowDetection() {}, +    , +    // calculated as 0xffffffffffffffff / radix, +    static final long[] maxValueDivs = new long[Character.MAX_RADIX + 1];, +    static final int[] maxValueMods = new int[Character.MAX_RADIX + 1];, +    static final int[] maxSafeDigits = new int[Character.MAX_RADIX + 1];, +, +    static {, +      BigInteger overflow = new BigInteger("10000000000000000", 16);, +      for (int i = Character.MIN_RADIX; i <= Character.MAX_RADIX; i++) {, +        maxValueDivs[i] = divide(MAX_VALUE, i);, +        maxValueMods[i] = (int) remainder(MAX_VALUE, i);, +        maxSafeDigits[i] = overflow.toString(i).length() - 1;, +      }, +    }, +, +     * unsigned long. This is useful for detecting overflow while parsing a string representation of, +     * a number. Does not verify whether supplied radix is valid, passing an invalid radix will give, +    static boolean overflowInParse(long current, int digit, int radix) {, +  }, +++ b/guava/src/com/google/common/primitives/UnsignedLongs.java, +    int maxSafePos = ParseOverflowDetection.maxSafeDigits[radix] - 1;, +      if (pos > maxSafePos && ParseOverflowDetection.overflowInParse(value, digit, radix)) {, +  /*, +   * We move the static constants into this class so ProGuard can inline UnsignedLongs entirely, +   * unless the user is actually calling a parse method., +   */, +  private static final class ParseOverflowDetection {, +    private ParseOverflowDetection() {}, +    , +    // calculated as 0xffffffffffffffff / radix, +    static final long[] maxValueDivs = new long[Character.MAX_RADIX + 1];, +    static final int[] maxValueMods = new int[Character.MAX_RADIX + 1];, +    static final int[] maxSafeDigits = new int[Character.MAX_RADIX + 1];, +, +    static {, +      BigInteger overflow = new BigInteger("10000000000000000", 16);, +      for (int i = Character.MIN_RADIX; i <= Character.MAX_RADIX; i++) {, +        maxValueDivs[i] = divide(MAX_VALUE, i);, +        maxValueMods[i] = (int) remainder(MAX_VALUE, i);, +        maxSafeDigits[i] = overflow.toString(i).length() - 1;, +      }, +    }, +, +     * unsigned long. This is useful for detecting overflow while parsing a string representation of, +     * a number. Does not verify whether supplied radix is valid, passing an invalid radix will give, +    static boolean overflowInParse(long current, int digit, int radix) {, +  }]