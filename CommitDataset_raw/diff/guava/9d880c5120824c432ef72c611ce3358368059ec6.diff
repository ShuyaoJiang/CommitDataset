[+++ b/src/com/google/common/util/concurrent/Futures.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +   *, +   * <p>Successful cancellation of either the input future or the result of, +   * function application will cause the returned future to be cancelled., +   * Cancelling the returned future will succeed if it is currently running., +   * In this case, attempts will be made to cancel the input future and the, +   * result of the function, however there is no guarantee of success., +   *, +   * <p>Successful cancellation of either the input future or the result of, +   * function application will cause the returned future to be cancelled., +   * Cancelling the returned future will succeed if it is currently running., +   * In this case, attempts will be made to cancel the input future and the, +   * result of the function, however there is no guarantee of success., +   *, +   * <p>Successful cancellation of the input future will cause the returned, +   * future to be cancelled.  Cancelling the returned future will succeed if it, +   * is currently running.  In this case, an attempt will be made to cancel the, +   * input future, however there is no guarantee of success., +   *, +   * <p>Successful cancellation of the input future will cause the returned, +   * future to be cancelled.  Cancelling the returned future will succeed if it, +   * is currently running.  In this case, an attempt will be made to cancel the, +   * input future, however there is no guarantee of success., +    private volatile ListenableFuture<? extends O> outputFuture;, +    private final BlockingQueue<Boolean> mayInterruptIfRunningChannel =, +        new LinkedBlockingQueue<Boolean>(1);, +      if (cancel()) {, +        try {, +          // This should never block since only one thread is allowed to cancel, +          // this Future., +          mayInterruptIfRunningChannel.put(mayInterruptIfRunning);, +        } catch (InterruptedException ignored) {, +          Thread.currentThread().interrupt();, +        }, +        cancel(inputFuture, mayInterruptIfRunning);, +        cancel(outputFuture, mayInterruptIfRunning);, +        return true;, +    private void cancel(@Nullable Future<?> future,, +        boolean mayInterruptIfRunning) {, +      if (future != null) {, +        future.cancel(mayInterruptIfRunning);, +      }, +    }, +, +        final ListenableFuture<? extends O> outputFuture = this.outputFuture =, +        if (isCancelled()) {, +          // Handles the case where cancel was called while the function was, +          // being applied., +          try {, +            // There is a gap in cancel(boolean) between calling cancel() and, +            // storing the value of mayInterruptIfRunning, so this thread needs, +            // to block, waiting for that value., +            outputFuture.cancel(mayInterruptIfRunningChannel.take());, +          } catch (InterruptedException ignored) {, +            Thread.currentThread().interrupt();, +          }, +          this.outputFuture = null;, +          return;, +        }, +              } catch (CancellationException e) {, +                // Cancel this future and return., +                cancel();, +                return;, +              } finally {, +                // Don't pin inputs beyond completion, +                ChainingListenableFuture.this.outputFuture = null;]