[+++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +  private static abstract class AbstractReferenceEntry<K, V> implements ReferenceEntry<K, V> {, +    @Override, +    public ValueReference<K, V> getValueReference() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setValueReference(ValueReference<K, V> valueReference) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void notifyKeyReclaimed() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void notifyValueReclaimed(ValueReference<K, V> v) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getNext() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public int getHash() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public K getKey() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public long getExpirationTime() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setExpirationTime(long time) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getNextExpirable() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setNextExpirable(ReferenceEntry<K, V> next) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getPreviousExpirable() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setPreviousExpirable(ReferenceEntry<K, V> previous) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getNextEvictable() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setNextEvictable(ReferenceEntry<K, V> next) {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public ReferenceEntry<K, V> getPreviousEvictable() {, +      throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void setPreviousEvictable(ReferenceEntry<K, V> previous) {, +      throw new UnsupportedOperationException();, +    }, +  }, +, +      final ReferenceEntry<K, V> head = new AbstractReferenceEntry<K, V>() {, +      final ReferenceEntry<K, V> head = new AbstractReferenceEntry<K, V>() {]