[+++ b/android/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java, +++ b/android/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java, +++ b/android/guava-tests/test/com/google/common/collect/HashBiMapTest.java, +  public void testInverseInsertionOrderAfterInverseForcePutPresentKey() {, +    BiMap<String, Integer> map = HashBiMap.create();, +    map.put("foo", 1);, +    map.put("bar", 2);, +    map.put("quux", 3);, +    map.put("nab", 4);, +, +    map.inverse().forcePut(4, "bar");, +    assertThat(map.entrySet()), +        .containsExactly(, +            Maps.immutableEntry("foo", 1),, +            Maps.immutableEntry("bar", 4),, +            Maps.immutableEntry("quux", 3)), +        .inOrder();, +  }, +, +  public void testInverseEntrySetValueNewKey() {, +    map.put(1, "a");, +    map.put(2, "b");, +    Iterator<Entry<String, Integer>> inverseEntryItr = map.inverse().entrySet().iterator();, +    Entry<String, Integer> entry = inverseEntryItr.next();, +    entry.setValue(3);, +    assertEquals(Maps.immutableEntry("b", 2), inverseEntryItr.next());, +    assertFalse(inverseEntryItr.hasNext());, +    assertThat(map.entrySet()), +        .containsExactly(Maps.immutableEntry(2, "b"), Maps.immutableEntry(3, "a")), +        .inOrder();, +++ b/android/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java, +++ b/android/guava-tests/test/com/google/common/collect/HashBiMapTest.java, +  public void testInverseInsertionOrderAfterInverseForcePutPresentKey() {, +    BiMap<String, Integer> map = HashBiMap.create();, +    map.put("foo", 1);, +    map.put("bar", 2);, +    map.put("quux", 3);, +    map.put("nab", 4);, +, +    map.inverse().forcePut(4, "bar");, +    assertThat(map.entrySet()), +        .containsExactly(, +            Maps.immutableEntry("foo", 1),, +            Maps.immutableEntry("bar", 4),, +            Maps.immutableEntry("quux", 3)), +        .inOrder();, +  }, +, +  public void testInverseEntrySetValueNewKey() {, +    map.put(1, "a");, +    map.put(2, "b");, +    Iterator<Entry<String, Integer>> inverseEntryItr = map.inverse().entrySet().iterator();, +    Entry<String, Integer> entry = inverseEntryItr.next();, +    entry.setValue(3);, +    assertEquals(Maps.immutableEntry("b", 2), inverseEntryItr.next());, +    assertFalse(inverseEntryItr.hasNext());, +    assertThat(map.entrySet()), +        .containsExactly(Maps.immutableEntry(2, "b"), Maps.immutableEntry(3, "a")), +        .inOrder();, +++ b/android/guava/src/com/google/common/collect/HashBiMap.java, +import java.util.AbstractSet;, +@GwtCompatible, +public final class HashBiMap<K, V> extends AbstractMap<K, V> implements BiMap<K, V>, Serializable {, +  /** Returns a new, empty {@code HashBiMap} with the default initial capacity (16). */, +  private static final int ABSENT = -1;, +  private static final int ENDPOINT = -2;, +  /** Maps an "entry" to the key of that entry. */, +  transient K[] keys;, +  /** Maps an "entry" to the value of that entry. */, +  transient V[] values;, +  transient int size;, +  transient int modCount;, +  /** Maps a bucket to the "entry" of its first element. */, +  private transient int[] hashTableKToV;, +  /** Maps a bucket to the "entry" of its first element. */, +  private transient int[] hashTableVToK;, +  /** Maps an "entry" to the "entry" that follows it in its bucket. */, +  private transient int[] nextInBucketKToV;, +  /** Maps an "entry" to the "entry" that follows it in its bucket. */, +  private transient int[] nextInBucketVToK;, +  /** The "entry" of the first element in insertion order. */, +  private transient int firstInInsertionOrder;, +  /** The "entry" of the last element in insertion order. */, +  private transient int lastInInsertionOrder;, +  /** Maps an "entry" to the "entry" that precedes it in insertion order. */, +  private transient int[] prevInInsertionOrder;, +  /** Maps an "entry" to the "entry" that follows it in insertion order. */, +  private transient int[] nextInInsertionOrder;, +  void init(int expectedSize) {, +    CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");, +    int tableSize = Hashing.closedTableSize(expectedSize, 1.0);, +, +    keys = (K[]) new Object[expectedSize];, +    values = (V[]) new Object[expectedSize];, +, +    hashTableKToV = createFilledWithAbsent(tableSize);, +    hashTableVToK = createFilledWithAbsent(tableSize);, +    nextInBucketKToV = createFilledWithAbsent(expectedSize);, +    nextInBucketVToK = createFilledWithAbsent(expectedSize);, +]