[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +  public void testCustomSerialization() throws Exception {, +    Funnel<byte[]> funnel = Funnels.byteArrayFunnel();, +    BloomFilter<byte[]> bf = BloomFilter.create(funnel, 100);, +    for (int i = 0; i < 100; i++) {, +      bf.put(Ints.toByteArray(i));, +    }, +, +    ByteArrayOutputStream out = new ByteArrayOutputStream();, +    bf.writeTo(out);, +, +    assertEquals(bf, BloomFilter.readFrom(new ByteArrayInputStream(out.toByteArray()), funnel));, +  }, +, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +  public void testCustomSerialization() throws Exception {, +    Funnel<byte[]> funnel = Funnels.byteArrayFunnel();, +    BloomFilter<byte[]> bf = BloomFilter.create(funnel, 100);, +    for (int i = 0; i < 100; i++) {, +      bf.put(Ints.toByteArray(i));, +    }, +, +    ByteArrayOutputStream out = new ByteArrayOutputStream();, +    bf.writeTo(out);, +, +    assertEquals(bf, BloomFilter.readFrom(new ByteArrayInputStream(out.toByteArray()), funnel));, +  }, +, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +import com.google.common.primitives.SignedBytes;, +import com.google.common.primitives.UnsignedBytes;, +import java.io.DataInputStream;, +import java.io.DataOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, + * <p>Bloom filters are serializable. They also support a more compact serial representation via, + * the {@link #writeTo} and {@link #readFrom} methods. Both serialized forms will continue to be, + * supported by future versions of this library. However, serial forms generated by newer versions, + * of the code may not be readable by older versions of the code (e.g., a serialized bloom filter, + * generated today may <i>not</i> be readable by a binary that was compiled 6 months ago)., +, +  /**, +   * Writes this {@code BloomFilter} to an output stream, with a custom format (not Java, +   * serialization). This has been measured to save at least 400 bytes compared to regular, +   * serialization., +   *, +   * <p>Use {@linkplain #readFrom(InputStream, Funnel)} to reconstruct the written BloomFilter., +   */, +  public void writeTo(OutputStream out) throws IOException {, +    /*, +     * Serial form:, +     * 1 signed byte for the strategy, +     * 1 unsigned byte for the number of hash functions, +     * 1 big endian int, the number of longs in our bitset, +     * N big endian longs of our bitset, +     */, +    DataOutputStream dout = new DataOutputStream(out);, +    dout.writeByte(SignedBytes.checkedCast(strategy.ordinal()));, +    dout.writeByte(UnsignedBytes.checkedCast(numHashFunctions)); // note: checked at the c'tor, +    dout.writeInt(bits.data.length);, +    for (long value : bits.data) {, +      dout.writeLong(value);, +    }, +  }, +, +  /**, +   * Reads a byte stream, which was written by {@linkplain #writeTo(OutputStream)}, into, +   * a {@code BloomFilter<T>}., +   *, +   * The {@code Funnel} to be used is not encoded in the stream, so it must be provided here., +   * <b>Warning:</b> the funnel provided <b>must</b> behave identically to the one used to, +   * populate the original Bloom filter!, +   *, +   * @throws IOException if the InputStream throws an {@code IOException}, or if its data does, +   *     not appear to be a BloomFilter serialized using the, +   *     {@linkplain #writeTo(OutputStream)} method., +   */, +  public static <T> BloomFilter<T> readFrom(InputStream in, Funnel<T> funnel) throws IOException {, +    checkNotNull(in, "InputStream");, +    checkNotNull(funnel, "Funnel");, +    int strategyOrdinal = -1;, +    int numHashFunctions = -1;, +    int dataLength = -1;, +    try {, +      DataInputStream din = new DataInputStream(in);, +      // currently this assumes there is no negative ordinal; will have to be updated if we, +      // add non-stateless strategies (for which we've reserved negative ordinals; see, +      // Strategy.ordinal())., +      strategyOrdinal = din.readByte();, +      numHashFunctions = UnsignedBytes.toInt(din.readByte());, +      dataLength = din.readInt();, +, +      Strategy strategy = BloomFilterStrategies.values()[strategyOrdinal];, +      long[] data = new long[dataLength];, +      for (int i = 0; i < data.length; i++) {]