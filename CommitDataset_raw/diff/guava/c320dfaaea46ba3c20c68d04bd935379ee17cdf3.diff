[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new ComputingSegment<K, V>(this, initialCapacity, maxSegmentSize);, +  ComputingSegment<K, V> segmentFor(int hash) {, +    return (ComputingSegment<K, V>) super.segmentFor(hash);, +  static class ComputingSegment<K, V> extends Segment<K, V> {, +    ComputingSegment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      super(map, initialCapacity, maxSegmentSize);, +          ComputingValueReference<K, V> computingValueReference = null;, +                  && map.keyEquivalence.equivalent(key, entryKey)) {, +              ComputingConcurrentHashMap<K, V> computingMap =, +                  (ComputingConcurrentHashMap<K, V>) map;, +              computingValueReference = new ComputingValueReference<K, V>(computingMap);, +                e = computingMap.newEntry(key, hash, first);, +  private static class ComputingValueReference<K, V> implements ValueReference<K, V> {, +    final ComputingConcurrentHashMap<K, V> map;, +, +    public ComputingValueReference(ComputingConcurrentHashMap<K, V> map) {, +      this.map = map;, +    }, +, +        value = map.computingFunction.apply(key);, +        String message = map.computingFunction + " returned null for key " + key + ".";, +      map.segmentFor(hash).put(key, hash, value, true);, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new ComputingSegment<K, V>(this, initialCapacity, maxSegmentSize);, +  ComputingSegment<K, V> segmentFor(int hash) {, +    return (ComputingSegment<K, V>) super.segmentFor(hash);, +  static class ComputingSegment<K, V> extends Segment<K, V> {, +    ComputingSegment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      super(map, initialCapacity, maxSegmentSize);, +          ComputingValueReference<K, V> computingValueReference = null;, +                  && map.keyEquivalence.equivalent(key, entryKey)) {, +              ComputingConcurrentHashMap<K, V> computingMap =, +                  (ComputingConcurrentHashMap<K, V>) map;, +              computingValueReference = new ComputingValueReference<K, V>(computingMap);, +                e = computingMap.newEntry(key, hash, first);, +  private static class ComputingValueReference<K, V> implements ValueReference<K, V> {, +    final ComputingConcurrentHashMap<K, V> map;, +, +    public ComputingValueReference(ComputingConcurrentHashMap<K, V> map) {, +      this.map = map;, +    }, +, +        value = map.computingFunction.apply(key);, +        String message = map.computingFunction + " returned null for key " + key + ".";, +      map.segmentFor(hash).put(key, hash, value, true);, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +  final transient Segment<K, V>[] segments;, +   *, +   * Entries in the map can be in the following states:, +   *, +   * Valid:, +   * - Live: valid key/value are set, +   * - Computing: computation is pending, +   *, +   * Invalid:, +   * - Expired: time expired (key/value may still be set), +   * - Collected: key/value was partially collected, but not yet cleaned up, +   * - Unset: marked as unset, awaiting cleanup or reuse, +    Segment<K, V> segment = segmentFor(hash);, +  // expiration, +, +  final Segment<K, V>[] newSegmentArray(int ssize) {, +    return new Segment[ssize];, +  Segment<K, V> segmentFor(int hash) {, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new Segment<K, V>(this, initialCapacity, maxSegmentSize);, +  static class Segment<K, V> extends ReentrantLock {, +    final CustomConcurrentHashMap<K, V> map;, +, +    Segment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      this.map = map;, +      recencyQueue = (map.evictsBySize() || map.expiresAfterAccess()), +      evictionQueue = map.evictsBySize(), +      expirationQueue = map.expires(), +      ValueReference<K, V> valueReference = map.newValueReference(entry, value);, +      if (map.expiresAfterAccess()) {, +        recordExpirationTime(entry, map.expireAfterAccessNanos);, +      if (map.expiresAfterAccess()) {, +        recordExpirationTime(entry, map.expireAfterAccessNanos);, +      if (map.expires()) {, +        long expiration = map.expiresAfterAccess(), +            ? map.expireAfterAccessNanos, +            : map.expireAfterWriteNanos;, +        if (map.expiresAfterAccess() && expirationQueue.contains(e)) {, +      entry.setExpirationTime(map.ticker.read() + expirationNanos);, +      long now = map.ticker.read();, +      while ((e = expirationQueue.peek()) != null && map.isExpired(e, now)) {, +      if (map.evictsBySize() && count >= maxSegmentSize) {, +          if (map.keyEquivalence.equivalent(key, entryKey)) {, +          if (map.keyEquivalence.equivalent(key, entryKey)) {, +            if (map.valueEquivalence.equivalent(value, entryValue)) {, +              && map.keyEquivalence.equivalent(key, entryKey)) {, +            if (map.valueEquivalence.equivalent(oldValue, entryValue)) {, +              && map.keyEquivalence.equivalent(key, entryKey)) {, +              && map.keyEquivalence.equivalent(key, entryKey)) {, +        ReferenceEntry<K, V> newEntry = map.newEntry(key, hash, first);, +                newTable.set(newIndex, map.copyEntry(e, newNext));]