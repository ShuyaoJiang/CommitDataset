[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +      // TODO(user): Specialize this method in the case that future is an AbstractFuture.  Then, +      // instead of calling .get() and catching exception we can just copy the value field which, +      // should be much cheaper (a single cast and a volatile read, instead of at least 2 reads,, +      // dealing with InterruptedException and possibly throwing/catching exceptions).  The issue is, +      // that some subclasses override .get() and may expect/require it to be called and this would, +      // break those assumptions. Possible ideas for managing this:, +      // 1. limit the optimization to a trusted set of subclasses (subclasses in this package?, +      //    via a package private interface?), +      // 2. entirely change the subclassing interface e.g. make .get() final. Then users who want to, +      //    do fancy things in .get() will need to use ForwardingFuture., +      Object valueToSet;, +      try {, +        V v = Uninterruptibles.getUninterruptibly(future);, +        valueToSet = v == null ? NULL : v;, +      } catch (ExecutionException exception) {, +        valueToSet = new Failure(exception.getCause());, +      } catch (CancellationException cancellation) {, +        valueToSet = new Cancellation(false, cancellation);, +      } catch (Throwable t) {, +        valueToSet = new Failure(t);, +      }, +      // The only way this can fail is if we raced with another thread calling cancel(). If we lost, +      // that race then there is nothing to do., +      if (ATOMIC_HELPER.casValue(AbstractFuture.this, this, valueToSet)) {, +        complete();, +      }, +   * <p>When a call to this method returns, the {@code Future} is guaranteed to be, +   * {@linkplain #isDone done} <b>only if</b> (a) the call was accepted (in which case it returns, +   * {@code true}) <b>and</b> (b) the supplied {@code Future} was already done. Otherwise, the, +   * result may have been asynchronously set to a {@code Future} that is not yet done. Note that, +   * such a result, though not yet known, cannot by overridden by a call to a {@code set*} method,, +   * only by a call to {@link #cancel}., +   *     cancelled or set. However, there is no guarantee that the {@code Future} is done., +      // the listener is responsible for calling complete, directExecutor is appropriate since, +      // all we are doing is unpacking a completed future which should be fast., +    Object obj = value;, +    if (obj instanceof Cancellation) {, +      future.cancel(((Cancellation) obj).wasInterrupted);]