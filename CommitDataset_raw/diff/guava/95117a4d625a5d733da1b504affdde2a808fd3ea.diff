[+++ b/guava-tests/test/com/google/common/reflect/TypesTest.java, +import com.google.common.base.Throwables;, +import com.google.common.collect.ImmutableSet;, +import java.lang.reflect.ReflectPermission;, +import java.security.Permission;, +, +  private SecurityManager oldSecurityManager;, +, +  /**, +   * A SecurityManager that disallows {@link java.lang.reflect.Method#setAccessible(boolean)}, +   * except when it comes from one of a set of known classes. The purpose is to detect whether we, +   * do a setAccessible call that might fail in a context where a SecurityManager forbids it., +   */, +  private static class NoSetAccessibleSecurityManager extends SecurityManager {, +    private static final Permission DISALLOWED_PERMISSION =, +        new ReflectPermission("suppressAccessChecks");, +    private static final ImmutableSet<String> ALLOWED_CALLERS =, +        ImmutableSet.of("NullPointerTester", "EqualsTester", "ObjectStreamClass");, +, +    @Override, +    public void checkPermission(Permission p) {, +      if (p.equals(DISALLOWED_PERMISSION) && !allowedCaller()) {, +        super.checkPermission(p);, +      }, +    }, +, +    private static boolean allowedCaller() {, +      String stack = Throwables.getStackTraceAsString(new Throwable());, +      for (String allowed : ALLOWED_CALLERS) {, +        if (stack.contains(allowed)) {, +          return true;, +        }, +      }, +      return false;, +    }, +  }, +, +  @Override, +  protected void setUp() {, +    oldSecurityManager = System.getSecurityManager();, +    System.setSecurityManager(new NoSetAccessibleSecurityManager());, +  }, +, +  @Override, +  protected void tearDown() {, +    System.setSecurityManager(oldSecurityManager);, +  }, +++ b/guava-tests/test/com/google/common/reflect/TypesTest.java, +import com.google.common.base.Throwables;, +import com.google.common.collect.ImmutableSet;, +import java.lang.reflect.ReflectPermission;, +import java.security.Permission;, +, +  private SecurityManager oldSecurityManager;, +, +  /**, +   * A SecurityManager that disallows {@link java.lang.reflect.Method#setAccessible(boolean)}, +   * except when it comes from one of a set of known classes. The purpose is to detect whether we, +   * do a setAccessible call that might fail in a context where a SecurityManager forbids it., +   */, +  private static class NoSetAccessibleSecurityManager extends SecurityManager {, +    private static final Permission DISALLOWED_PERMISSION =, +        new ReflectPermission("suppressAccessChecks");, +    private static final ImmutableSet<String> ALLOWED_CALLERS =, +        ImmutableSet.of("NullPointerTester", "EqualsTester", "ObjectStreamClass");, +, +    @Override, +    public void checkPermission(Permission p) {, +      if (p.equals(DISALLOWED_PERMISSION) && !allowedCaller()) {, +        super.checkPermission(p);, +      }, +    }, +, +    private static boolean allowedCaller() {, +      String stack = Throwables.getStackTraceAsString(new Throwable());, +      for (String allowed : ALLOWED_CALLERS) {, +        if (stack.contains(allowed)) {, +          return true;, +        }, +      }, +      return false;, +    }, +  }, +, +  @Override, +  protected void setUp() {, +    oldSecurityManager = System.getSecurityManager();, +    System.setSecurityManager(new NoSetAccessibleSecurityManager());, +  }, +, +  @Override, +  protected void tearDown() {, +    System.setSecurityManager(oldSecurityManager);, +  }, +++ b/guava/src/com/google/common/reflect/Types.java, +import java.security.AccessControlException;, +          try {, +          } catch (AccessControlException e) {, +            // OK: the method is accessible to us anyway. The setAccessible call is only for, +            // unusual execution environments where that might not be true.]