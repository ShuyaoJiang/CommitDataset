[+++ b/guava/src/com/google/common/reflect/TypeResolver.java, +      return typeTable.resolve((TypeVariable<?>) type);, +  /** A TypeTable maintains mapping from {@link TypeVariable} to types. */, +    private TypeTable(ImmutableMap<TypeVariable<?>, Type> map) {, +      this.map = map;, +    final Type resolve(final TypeVariable<?> var) {, +      final TypeTable unguarded = this;, +      TypeTable guarded = new TypeTable() {, +        @Override public Type resolveInternal(, +            TypeVariable<?> intermediateVar, TypeTable forDependent) {, +          if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration())) {, +            return intermediateVar;, +          }, +          return unguarded.resolveInternal(intermediateVar, forDependent);, +        }, +      };, +      return resolveInternal(var, guarded);, +    }, +, +     * non-reified type or has bounds, {@code forDependants} is used to do further resolution, which, +     * doesn't try to resolve any type variable on generic declarations that are already being, +     * resolved., +     *, +     * <p>Should only be called and overridden by {@link #resolve(TypeVariable)}., +    Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {, +            new TypeResolver(forDependants).resolveTypes(bounds));, +      return new TypeResolver(forDependants).resolveType(type);]