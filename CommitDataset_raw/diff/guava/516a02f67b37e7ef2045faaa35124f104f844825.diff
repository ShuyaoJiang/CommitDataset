[+++ b/guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/FuturesTest.java, +import static com.google.common.util.concurrent.Futures.allAsList;, +import static com.google.common.util.concurrent.TestPlatform.clearInterrupt;, +import com.google.common.collect.Lists;, +import com.google.common.testing.TestLogHandler;, +import java.util.logging.LogRecord;, +import java.util.logging.Logger;, +  private static final Logger aggregateFutureLogger =, +      Logger.getLogger(AggregateFuture.class.getName());, +  private final TestLogHandler aggregateFutureLogHandler = new TestLogHandler();, +  @Override, +  protected void setUp() throws Exception {, +    super.setUp();, +    aggregateFutureLogger.addHandler(aggregateFutureLogHandler);, +  }, +, +  @Override, +  protected void tearDown() throws Exception {, +    /*, +     * Clear interrupt for future tests., +     *, +     * (Ideally we would perform interrupts only in threads that we create, but, +     * it's hard to imagine that anything will break in practice.), +     */, +    clearInterrupt();, +    aggregateFutureLogger.removeHandler(aggregateFutureLogHandler);, +    super.tearDown();, +  }, +, +  public void testImmediateFailedFuture() throws Exception {, +    Exception exception = new Exception();, +    ListenableFuture<String> future =, +        Futures.immediateFailedFuture(exception);, +, +    try {, +      future.get(0L, TimeUnit.MILLISECONDS);, +      fail("This call was supposed to throw an ExecutionException");, +    } catch (ExecutionException expected) {, +      // This is good and expected, +      assertSame(exception, expected.getCause());, +    }, +  }, +, +  public void testImmediateFailedFuture_cancellationException() throws Exception {, +    CancellationException exception = new CancellationException();, +    ListenableFuture<String> future =, +        Futures.immediateFailedFuture(exception);, +, +    try {, +      future.get(0L, TimeUnit.MILLISECONDS);, +      fail("This call was supposed to throw an ExecutionException");, +    } catch (ExecutionException expected) {, +      // This is good and expected, +      assertSame(exception, expected.getCause());, +      assertFalse(future.isCancelled());, +    }, +  }, +, +  /**, +   * A single non-error failure is not logged because it is reported via the output future., +   */, +  @SuppressWarnings("unchecked"), +  public void testAllAsList_logging_exception() throws Exception {, +    try {, +      Futures.allAsList(immediateFailedFuture(new MyException())).get();, +      fail();, +    } catch (ExecutionException e) {, +      assertTrue(e.getCause() instanceof MyException);, +      assertEquals("Nothing should be logged", 0,, +          aggregateFutureLogHandler.getStoredLogRecords().size());, +    }, +  }, +, +  /**, +   * Ensure that errors are always logged., +   */, +  @SuppressWarnings("unchecked"), +  public void testAllAsList_logging_error() throws Exception {, +    try {, +      Futures.allAsList(immediateFailedFuture(new MyError())).get();, +      fail();, +    } catch (ExecutionException e) {, +      assertTrue(e.getCause() instanceof MyError);, +      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();, +      assertEquals(1, logged.size());  // errors are always logged, +      assertTrue(logged.get(0).getThrown() instanceof MyError);, +    }, +  }, +, +  /**, +   * All as list will log extra exceptions that occur after failure., +   */, +  @SuppressWarnings("unchecked"), +  public void testAllAsList_logging_multipleExceptions() throws Exception {, +    try {, +      Futures.allAsList(immediateFailedFuture(new MyException()),, +          immediateFailedFuture(new MyException())).get();, +      fail();, +    } catch (ExecutionException e) {, +      assertTrue(e.getCause() instanceof MyException);]