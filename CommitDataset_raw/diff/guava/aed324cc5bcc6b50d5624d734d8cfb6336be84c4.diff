[+++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          V value = waitForValue(e);, +        }, +      } finally {, +        postReadCleanup();, +      }, +    }, +, +    private V waitForValue(ReferenceEntry<K, V> entry) {, +      // The entry already exists. Wait for the computation., +      boolean interrupted = false;, +      try {, +        while (true) {, +          try {, +            checkState(!Thread.holdsLock(entry), "Recursive computation");, +            return entry.getValueReference().waitForValue();, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          V value = waitForValue(e);, +        }, +      } finally {, +        postReadCleanup();, +      }, +    }, +, +    private V waitForValue(ReferenceEntry<K, V> entry) {, +      // The entry already exists. Wait for the computation., +      boolean interrupted = false;, +      try {, +        while (true) {, +          try {, +            checkState(!Thread.holdsLock(entry), "Recursive computation");, +            return entry.getValueReference().waitForValue();, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.util.LinkedList;, +    // TODO(user): switch to ArrayDeque if we ever require JDK 1.6, +    @GuardedBy("Segment.this"), +    final Queue<ReferenceEntry<K, V>> cleanupQueue = new LinkedList<ReferenceEntry<K, V>>();, +      try {, +      } finally {, +        postReadCleanup();, +      }, +      try {, +      } finally {, +        postReadCleanup();, +      }, +      cleanupQueue.offer(entry);, +      if (tryLock()) {, +    }, +    Segment<K, V> currentSegment;, +        currentSegment = segments[nextSegmentIndex--];, +        if (currentSegment.count != 0) {, +          currentTable = currentSegment.table;, +      try {, +      } finally {, +        currentSegment.postReadCleanup();, +      }, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          V value = waitForValue(e);, +        }, +      } finally {, +        postReadCleanup();, +      }, +    }, +, +    private V waitForValue(ReferenceEntry<K, V> entry) {, +      // The entry already exists. Wait for the computation., +      boolean interrupted = false;, +      try {, +        while (true) {, +          try {, +            checkState(!Thread.holdsLock(entry), "Recursive computation");, +            return entry.getValueReference().waitForValue();, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.util.LinkedList;, +    // TODO(user): switch to ArrayDeque if we ever require JDK 1.6, +    @GuardedBy("Segment.this"), +    final Queue<ReferenceEntry<K, V>> cleanupQueue = new LinkedList<ReferenceEntry<K, V>>();, +      try {, +      } finally {, +        postReadCleanup();, +      }, +      try {, +      } finally {, +        postReadCleanup();, +      }, +      cleanupQueue.offer(entry);, +      if (tryLock()) {, +    }, +    Segment<K, V> currentSegment;, +        currentSegment = segments[nextSegmentIndex--];, +        if (currentSegment.count != 0) {, +          currentTable = currentSegment.table;, +      try {, +      } finally {, +        currentSegment.postReadCleanup();, +      }, +++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java, + * @since Guava release 10]