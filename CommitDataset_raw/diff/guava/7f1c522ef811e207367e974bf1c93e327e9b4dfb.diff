[+++ b/guava-tests/test/com/google/common/hash/HashingTest.java, +import com.google.common.testing.EqualsTester;, +import java.lang.reflect.Modifier;, +    Random random = new Random(RANDOM_SEED);, +  public void testConcatenatedHashFunction_equals() {, +    assertEquals(, +        new ConcatenatedHashFunction(Hashing.md5()),, +        new ConcatenatedHashFunction(Hashing.md5()));, +    assertEquals(, +        new ConcatenatedHashFunction(Hashing.md5(), Hashing.murmur3_32()),, +        new ConcatenatedHashFunction(Hashing.md5(), Hashing.murmur3_32()));, +  }, +, +      if (method.getReturnType().equals(HashFunction.class) // must return HashFunction, +          && Modifier.isPublic(method.getModifiers()) // only the public methods, +          && method.getParameterTypes().length == 0) { // only the seed-less grapes^W hash functions, +, +  public void testSeedlessHashFunctionEquals() throws Exception {, +    assertSeedlessHashFunctionEquals(Hashing.class);, +  }, +, +  public void testSeededHashFunctionEquals() throws Exception {, +    assertSeededHashFunctionEquals(Hashing.class);, +  }, +, +  static void assertSeedlessHashFunctionEquals(Class<?> clazz) throws Exception {, +    for (Method method : clazz.getDeclaredMethods()) {, +      if (method.getReturnType().equals(HashFunction.class) // must return HashFunction, +          && Modifier.isPublic(method.getModifiers()) // only the public methods, +          && method.getParameterTypes().length == 0) { // only the seed-less hash functions, +        HashFunction hashFunction1a = (HashFunction) method.invoke(clazz);, +        HashFunction hashFunction1b = (HashFunction) method.invoke(clazz);, +, +        new EqualsTester(), +            .addEqualityGroup(hashFunction1a, hashFunction1b), +            .testEquals();, +, +        // Make sure we're returning not only equal instances, but constants., +        assertSame(hashFunction1a, hashFunction1b);, +, +        assertEquals(hashFunction1a.toString(), hashFunction1b.toString());, +      }, +    }, +  }, +, +  static void assertSeededHashFunctionEquals(Class<?> clazz) throws Exception {, +    Random random = new Random(RANDOM_SEED);, +    for (Method method : clazz.getDeclaredMethods()) {, +      if (method.getReturnType().equals(HashFunction.class) // must return HashFunction, +          && Modifier.isPublic(method.getModifiers()) // only the public methods, +          && method.getParameterTypes().length != 0) { // only the seeded hash functions, +        Object[] params1 = new Object[method.getParameterTypes().length];, +        Object[] params2 = new Object[method.getParameterTypes().length];, +        for (int i = 0; i < params1.length; i++) {, +          if (method.getParameterTypes()[i] == int.class) {, +            // These have to be positive because Hashing#goodFastHash needs a positive (bit) value, +            params1[i] = random.nextInt(1000) + 1;, +            params2[i] = random.nextInt(1000) + 1;, +          } else if (method.getParameterTypes()[i] == long.class) {, +            params1[i] = random.nextLong();, +            params2[i] = random.nextLong();, +          } else {, +            fail("Unable to create a random parameter for " + method.getParameterTypes()[i]);, +          }, +        }, +        HashFunction hashFunction1a = (HashFunction) method.invoke(clazz, params1);, +        HashFunction hashFunction1b = (HashFunction) method.invoke(clazz, params1);, +        HashFunction hashFunction2 = (HashFunction) method.invoke(clazz, params2);, +, +        new EqualsTester(), +            .addEqualityGroup(hashFunction1a, hashFunction1b), +            .addEqualityGroup(hashFunction2), +            .testEquals();, +, +        assertEquals(hashFunction1a.toString(), hashFunction1b.toString());, +      }, +    }, +  }, +++ b/guava-tests/test/com/google/common/hash/HashingTest.java, +import com.google.common.testing.EqualsTester;, +import java.lang.reflect.Modifier;, +    Random random = new Random(RANDOM_SEED);, +  public void testConcatenatedHashFunction_equals() {, +    assertEquals(, +        new ConcatenatedHashFunction(Hashing.md5()),, +        new ConcatenatedHashFunction(Hashing.md5()));, +    assertEquals(, +        new ConcatenatedHashFunction(Hashing.md5(), Hashing.murmur3_32()),, +        new ConcatenatedHashFunction(Hashing.md5(), Hashing.murmur3_32()));, +  }, +, +      if (method.getReturnType().equals(HashFunction.class) // must return HashFunction, +          && Modifier.isPublic(method.getModifiers()) // only the public methods, +          && method.getParameterTypes().length == 0) { // only the seed-less grapes^W hash functions, +, +  public void testSeedlessHashFunctionEquals() throws Exception {, +    assertSeedlessHashFunctionEquals(Hashing.class);, +  }, +, +  public void testSeededHashFunctionEquals() throws Exception {]