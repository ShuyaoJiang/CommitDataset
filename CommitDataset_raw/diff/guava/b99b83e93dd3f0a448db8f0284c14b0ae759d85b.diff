[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Multimaps.java, +   * Returns a multimap containing the mappings in {@code unfiltered} whose keys, +   * satisfy a predicate. The returned multimap is a live view of, +   * {@code unfiltered}; changes to one affect the other., +   *, +   * <p>The resulting multimap's views have iterators that don't support, +   * {@code remove()}, but all other methods are supported by the multimap and, +   * its views. When adding a key that doesn't satisfy the predicate, the, +   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}, +   * methods throw an {@link IllegalArgumentException}., +   *, +   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on, +   * the filtered multimap or its views, only mappings whose keys satisfy the, +   * filter will be removed from the underlying multimap., +   *, +   * <p>The returned multimap isn't threadsafe or serializable, even if, +   * {@code unfiltered} is., +   *, +   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate, +   * across every key/value mapping in the underlying multimap and determine, +   * which satisfy the filter. When a live view is <i>not</i> needed, it may be, +   * faster to copy the filtered multimap and use the copy., +   *, +   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,, +   * as documented at {@link Predicate#apply}. Do not provide a predicate such, +   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent, +   * with equals., +   *, +   * @since 11.0, +   */, +  public static <K, V> Multimap<K, V> filterKeys(, +      Multimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {, +    if (unfiltered instanceof SetMultimap) {, +      return filterKeys((SetMultimap<K, V>) unfiltered, keyPredicate);, +    } else if (unfiltered instanceof ListMultimap) {, +      return filterKeys((ListMultimap<K, V>) unfiltered, keyPredicate);, +    } else if (unfiltered instanceof FilteredKeyMultimap) {, +      FilteredKeyMultimap<K, V> prev = (FilteredKeyMultimap<K, V>) unfiltered;, +      return new FilteredKeyMultimap<K, V>(prev.unfiltered,, +          Predicates.and(prev.keyPredicate, keyPredicate));, +    } else if (unfiltered instanceof FilteredMultimap) {, +      FilteredMultimap<K, V> prev = (FilteredMultimap<K, V>) unfiltered;, +      return filterFiltered(prev, Predicates.compose(keyPredicate, Maps.<K>keyFunction()));, +    } else {, +      return new FilteredKeyMultimap<K, V>(unfiltered, keyPredicate);, +    }, +  }, +  , +  /**, +   * Returns a multimap containing the mappings in {@code unfiltered} whose keys, +   * satisfy a predicate. The returned multimap is a live view of, +   * {@code unfiltered}; changes to one affect the other., +   *, +   * <p>The resulting multimap's views have iterators that don't support, +   * {@code remove()}, but all other methods are supported by the multimap and, +   * its views. When adding a key that doesn't satisfy the predicate, the, +   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}, +   * methods throw an {@link IllegalArgumentException}., +   *, +   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on, +   * the filtered multimap or its views, only mappings whose keys satisfy the, +   * filter will be removed from the underlying multimap., +   *, +   * <p>The returned multimap isn't threadsafe or serializable, even if, +   * {@code unfiltered} is., +   *, +   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate, +   * across every key/value mapping in the underlying multimap and determine, +   * which satisfy the filter. When a live view is <i>not</i> needed, it may be, +   * faster to copy the filtered multimap and use the copy., +   *, +   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,, +   * as documented at {@link Predicate#apply}. Do not provide a predicate such, +   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent, +   * with equals., +   *, +   * @since 14.0, +   */, +  public static <K, V> SetMultimap<K, V> filterKeys(, +      SetMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {, +    if (unfiltered instanceof FilteredKeySetMultimap) {, +      FilteredKeySetMultimap<K, V> prev = (FilteredKeySetMultimap<K, V>) unfiltered;, +      return new FilteredKeySetMultimap<K, V>(prev.unfiltered(),, +          Predicates.and(prev.keyPredicate, keyPredicate));, +    } else if (unfiltered instanceof FilteredSetMultimap) {, +      FilteredSetMultimap<K, V> prev = (FilteredSetMultimap<K, V>) unfiltered;, +      return filterFiltered(prev, Predicates.compose(keyPredicate, Maps.<K>keyFunction()));, +    } else {, +      return new FilteredKeySetMultimap<K, V>(unfiltered, keyPredicate);, +    }, +  }, +  , +  /**, +   * Returns a multimap containing the mappings in {@code unfiltered} whose keys, +   * satisfy a predicate. The returned multimap is a live view of, +   * {@code unfiltered}; changes to one affect the other., +   *, +   * <p>The resulting multimap's views have iterators that don't support, +   * {@code remove()}, but all other methods are supported by the multimap and, +   * its views. When adding a key that doesn't satisfy the predicate, the]