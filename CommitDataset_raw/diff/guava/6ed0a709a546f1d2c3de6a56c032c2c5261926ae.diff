[+++ b/guava-tests/test/com/google/common/graph/GraphEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/GraphEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/NetworkEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/GraphEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/NetworkEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava/src/com/google/common/graph/Graph.java, +   * Returns {@code true} iff {@code object} is a graph that has the same structural relationships, +   * <li>A and B have the same {@link #isDirected() directedness}., +   * <li>A and B have the same node set., +   * <li>A and B have the same adjacency relationships, i.e., for each node, the sets of successor, +   *     and predecessor nodes are the same in both graphs., +   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances., +   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal to, +   * {@link Network}s., +   *, +   * of a map from each of the graph's nodes to its successor nodes., +++ b/guava-tests/test/com/google/common/graph/GraphEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/NetworkEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava/src/com/google/common/graph/Graph.java, +   * Returns {@code true} iff {@code object} is a graph that has the same structural relationships, +   * <li>A and B have the same {@link #isDirected() directedness}., +   * <li>A and B have the same node set., +   * <li>A and B have the same adjacency relationships, i.e., for each node, the sets of successor, +   *     and predecessor nodes are the same in both graphs., +   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances., +   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal to, +   * {@link Network}s., +   *, +   * of a map from each of the graph's nodes to its successor nodes., +++ b/guava/src/com/google/common/graph/Graphs.java, +   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by, +   * {@link Graph#equals(Object)}., +    if (graph1.isDirected() != graph2.isDirected()) {, +      return false;, +    }, +, +   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by, +   * {@link Network#equals(Object)}., +    if (graph1.isDirected() != graph2.isDirected()) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {, +   * Returns the hash code of {@code graph} as defined by {@link Graph#hashCode()}., +    return nodeToSuccessorNodes(graph).hashCode();, +   * Returns the hash code of {@code graph} as defined by {@link Network#hashCode()}., +    return nodeToOutEdges(graph).hashCode();, +   * and the set of outgoing edges as values., +  private static <N, E> Map<N, Set<E>> nodeToOutEdges(final Network<N, E> graph) {, +        return graph.outEdges(node);, +   * and the set of successor nodes as values., +  private static <N> Map<N, Set<N>> nodeToSuccessorNodes(final Graph<N> graph) {, +        return graph.successors(node);, +++ b/guava-tests/test/com/google/common/graph/GraphEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava-tests/test/com/google/common/graph/NetworkEqualsTest.java, +  // Node/edge sets and node/edge connections are the same, but directedness differs., +    new EqualsTester().addEqualityGroup(graph).addEqualityGroup(g2).testEquals();, +++ b/guava/src/com/google/common/graph/Graph.java, +   * Returns {@code true} iff {@code object} is a graph that has the same structural relationships, +   * <li>A and B have the same {@link #isDirected() directedness}., +   * <li>A and B have the same node set., +   * <li>A and B have the same adjacency relationships, i.e., for each node, the sets of successor, +   *     and predecessor nodes are the same in both graphs., +   * <p>Note: {@link Network} instances can only be equal to other {@link Network} instances., +   * In particular, {@link Graph}s that are not also {@link Network}s cannot be equal to, +   * {@link Network}s., +   *, +   * of a map from each of the graph's nodes to its successor nodes., +++ b/guava/src/com/google/common/graph/Graphs.java, +   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by, +   * {@link Graph#equals(Object)}., +    if (graph1.isDirected() != graph2.isDirected()) {, +      return false;, +    }, +, +   * Returns true iff {@code graph1} and {@code graph2} are equal as defined by, +   * {@link Network#equals(Object)}., +    if (graph1.isDirected() != graph2.isDirected()) {, +    if (!graph1.nodes().equals(graph2.nodes()) || !graph1.edges().equals(graph2.edges())) {, +    for (Object edge : graph1.edges()) {, +      if (!graph1.incidentNodes(edge).equals(graph2.incidentNodes(edge))) {, +   * Returns the hash code of {@code graph} as defined by {@link Graph#hashCode()}., +    return nodeToSuccessorNodes(graph).hashCode();, +   * Returns the hash code of {@code graph} as defined by {@link Network#hashCode()}., +    return nodeToOutEdges(graph).hashCode();]