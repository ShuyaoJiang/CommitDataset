[+++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java, +      /*, +       * The returned string will be from the end of the last match to the, +       * beginning of the next one. nextStart is the start position of the, +       * returned substring, while offset is the place to start looking for a, +       * separator., +       */, +      int nextStart = offset;, +        int start = nextStart;, +        if (offset == nextStart) {, +          /*, +           * This occurs when some pattern has an empty match, even if it, +           * doesn't match the empty string -- for example, if it requires, +           * lookahead or the like. The offset must be increased to look for, +           * separators beyond this point, without changing the start position, +           * of the next returned substring -- so nextStart stays the same., +           */, +          offset++;, +          if (offset >= toSplit.length()) {, +            offset = -1;, +          }, +          continue;, +        }, +          // Don't include the (unused) separator in next split string., +          nextStart = offset;, +++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java, +      /*, +       * The returned string will be from the end of the last match to the, +       * beginning of the next one. nextStart is the start position of the, +       * returned substring, while offset is the place to start looking for a, +       * separator., +       */, +      int nextStart = offset;, +        int start = nextStart;, +        if (offset == nextStart) {, +          /*, +           * This occurs when some pattern has an empty match, even if it, +           * doesn't match the empty string -- for example, if it requires, +           * lookahead or the like. The offset must be increased to look for, +           * separators beyond this point, without changing the start position, +           * of the next returned substring -- so nextStart stays the same., +           */, +          offset++;, +          if (offset >= toSplit.length()) {, +            offset = -1;, +          }, +          continue;, +        }, +          // Don't include the (unused) separator in next split string., +          nextStart = offset;, +++ b/guava-tests/test/com/google/common/base/SplitterTest.java, +  public void testPatternSplitLookBehind() {, +    String toSplit = ":foo::barbaz:";, +    String regexPattern = "(?<=:)";, +    Iterable<String> split = Splitter.onPattern(regexPattern).split(toSplit);, +    ASSERT.that(split).hasContentsInOrder(":", "foo:", ":", "barbaz:");, +    // splits into chunks ending in :, +  }, +, +  @GwtIncompatible("java.util.regex.Pattern"), +  public void testPatternSplitWordBoundary() {, +    String string = "foo<bar>bletch";, +    Iterable<String> words = Splitter.on(Pattern.compile("\\b")).split(string);, +    ASSERT.that(words).hasContentsInOrder("foo", "<", "bar", ">", "bletch");, +  }, +, +  @GwtIncompatible("java.util.regex.Pattern"), +++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java, +      /*, +       * The returned string will be from the end of the last match to the, +       * beginning of the next one. nextStart is the start position of the, +       * returned substring, while offset is the place to start looking for a, +       * separator., +       */, +      int nextStart = offset;, +        int start = nextStart;, +        if (offset == nextStart) {, +          /*, +           * This occurs when some pattern has an empty match, even if it, +           * doesn't match the empty string -- for example, if it requires, +           * lookahead or the like. The offset must be increased to look for, +           * separators beyond this point, without changing the start position, +           * of the next returned substring -- so nextStart stays the same., +           */, +          offset++;, +          if (offset >= toSplit.length()) {, +            offset = -1;, +          }, +          continue;, +        }, +          // Don't include the (unused) separator in next split string., +          nextStart = offset;, +++ b/guava-tests/test/com/google/common/base/SplitterTest.java, +  public void testPatternSplitLookBehind() {, +    String toSplit = ":foo::barbaz:";, +    String regexPattern = "(?<=:)";, +    Iterable<String> split = Splitter.onPattern(regexPattern).split(toSplit);, +    ASSERT.that(split).hasContentsInOrder(":", "foo:", ":", "barbaz:");, +    // splits into chunks ending in :, +  }]