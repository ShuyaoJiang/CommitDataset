[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        ReferenceEntry<K, V> e = getEntry(key, hash);, +        if (e != null) {, +          V value = getLiveValue(e);, +            recordRead(e);, +        }, +        // at this point e is either null, computing, or expired;, +        // avoid locking if it's already computing, +        if (e == null || !e.getValueReference().isComputingReference()) {, +            for (e = first; e != null; e = e.getNext()) {, +                  V value = getLiveValue(e);, +            if (e == null || isUnset(e)) {, +              if (e == null) {, +                e = newEntry(key, hash, first);, +                table.set(index, e);, +              e.setValueReference(computingValueReference);, +            V value = null;, +              synchronized (e) {, +        }, +              checkState(!Thread.holdsLock(e), "Recursive computation");, +              V value = e.getValueReference().waitForValue();, +                recordRead(e);, +                postReadCleanup();, +            } catch (InterruptedException ie) {, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        ReferenceEntry<K, V> e = getEntry(key, hash);, +        if (e != null) {, +          V value = getLiveValue(e);, +            recordRead(e);, +        }, +        // at this point e is either null, computing, or expired;, +        // avoid locking if it's already computing, +        if (e == null || !e.getValueReference().isComputingReference()) {, +            for (e = first; e != null; e = e.getNext()) {, +                  V value = getLiveValue(e);, +            if (e == null || isUnset(e)) {, +              if (e == null) {, +                e = newEntry(key, hash, first);, +                table.set(index, e);, +              e.setValueReference(computingValueReference);, +            V value = null;, +              synchronized (e) {, +        }, +              checkState(!Thread.holdsLock(e), "Recursive computation");, +              V value = e.getValueReference().waitForValue();, +                recordRead(e);, +                postReadCleanup();, +            } catch (InterruptedException ie) {, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +    ReferenceEntry<K, V> getEntry(Object key, int hash) {, +      if (count != 0) { // read-volatile, +      }, +        ReferenceEntry<K, V> e = getEntry(key, hash);, +        if (e != null) {]