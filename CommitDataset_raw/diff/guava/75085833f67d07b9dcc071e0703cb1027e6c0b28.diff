[+++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java, +    assertNull(segment.refresh(key, hash, identityLoader(), false));, +++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java, +    assertNull(segment.refresh(key, hash, identityLoader(), false));, +++ b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java, +++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java, +    assertNull(segment.refresh(key, hash, identityLoader(), false));, +++ b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java, +++ b/guava/src/com/google/common/cache/LocalCache.java, +      if (map.refreshes() && (now - entry.getWriteTime() > map.refreshNanos), +          && !entry.getValueReference().isLoading()) {, +        V newValue = refresh(key, hash, loader, true);, +    V refresh(K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime) {, +          insertLoadingValueReference(key, hash, checkTime);, +    LoadingValueReference<K, V> insertLoadingValueReference(final K key, final int hash,, +        boolean checkTime) {, +            if (valueReference.isLoading(), +                || (checkTime && (now - e.getWriteTime() < map.refreshNanos))) {, +              // if checkTime, we want to check *after* acquiring the lock if refresh still needs, +              // to be scheduled, +    segmentFor(hash).refresh(key, hash, defaultLoader, false);]