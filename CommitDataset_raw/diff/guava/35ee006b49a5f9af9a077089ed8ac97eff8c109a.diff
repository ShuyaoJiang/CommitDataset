[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          if (entry == null || isUnset(entry)) {, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          if (entry == null || isUnset(entry)) {, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +  // - Live: valid key/value are set, +  // - Expired: time expired (key/value may still be set), +  // - Collected: key/value was partially collected, but not yet cleaned up, +  // - Unset: marked as unset, awaiting cleanup or reuse, +  boolean isUnset(ReferenceEntry<K, V> entry) {, +    return isUnset(entry.getValueReference());, +  boolean isUnset(ValueReference<K, V> valueReference) {, +        if (!invalidateEntry(expirable, expirable.getHash())) {, +          throw new AssertionError();, +        }, +              if (isUnset(e)) {, +                // Entry was invalidated., +              } else if (key == null) {, +                // Key was reclaimed., +                invalidateLiveEntry(e, e.getHash());, +              } else {, +        if (isUnset(e)) {, +          // Entry was invalidated., +        } else if (e.getKey() == null) {, +          // Key was reclaimed., +          invalidateLiveEntry(e, e.getHash()); // decrements count, +        } else {, +        }, +      if (isUnset(entry)) {, +        // keep count consistent, +          invalidateLiveEntry(entry, hash);, +    @GuardedBy("Segment.this"), +    void invalidateLiveEntry(ReferenceEntry<K, V> entry, int hash) {, +      int newCount = this.count - 1;, +      ++modCount;, +      K key = entry.getKey();, +      ValueReference<K, V> valueReference = entry.getValueReference();, +      enqueueNotification(key, hash, valueReference);, +      enqueueCleanup(entry);, +      this.count = newCount; // write-volatile, +    }, +, +            if (isUnset(e)) {]