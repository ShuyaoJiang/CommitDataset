[+++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * A class exactly like {@link MapMaker}, except restricted in the types of maps it can build. This, + * type is returned by {@link MapMaker#evictionListener} to prevent the user from trying to build a, + * map that's incompatible with the key and value types of the listener., +  public abstract GenericMapMaker<K0, V0> concurrencyLevel(int concurrencyLevel);, +  public abstract GenericMapMaker<K0, V0> expiration(long duration, TimeUnit unit);, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(long duration, TimeUnit unit);, +   * Note that MapMaker's evictionListener() is not here, because once you're interacting with a, +   * GenericMapMaker you've already called that, and shouldn't be calling it again., +  public abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeComputingMap(, +      Function<? super K, ? extends V> computingFunction);, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * A class exactly like {@link MapMaker}, except restricted in the types of maps it can build. This, + * type is returned by {@link MapMaker#evictionListener} to prevent the user from trying to build a, + * map that's incompatible with the key and value types of the listener., +  public abstract GenericMapMaker<K0, V0> concurrencyLevel(int concurrencyLevel);, +  public abstract GenericMapMaker<K0, V0> expiration(long duration, TimeUnit unit);, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(long duration, TimeUnit unit);, +   * Note that MapMaker's evictionListener() is not here, because once you're interacting with a, +   * GenericMapMaker you've already called that, and shouldn't be calling it again., +  public abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeComputingMap(, +      Function<? super K, ? extends V> computingFunction);, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java, + * MapMaker emulation. Since Javascript is single-threaded and have no references, this reduces to, + * the creation of expiring and computing maps., +  // TODO(user,user): ConcurrentHashMap never throws a CME when mutating the map during iteration, but, +  // this implementation (based on a LHM) does. This will all be replaced soon anyways, so leaving, +  // it as is for now., +  private static class ExpiringComputingMap<K, V> extends LinkedHashMap<K, V>, +      implements ConcurrentMap<K, V> {, +    ExpiringComputingMap(long expirationMillis, int maximumSize, int initialCapacity,, +        float loadFactor) {, +    ExpiringComputingMap(long expirationMillis, Function<? super K, ? extends V> computer,, +        int maximumSize, int initialCapacity, float loadFactor) {, +       * TODO: Keep weak reference to map, too. Build a priority queue out of the entries themselves, +       * instead of creating a task per entry. Then, we could have one recurring task per map (which, +       * would clean the entire map and then reschedule itself depending upon when the next, +       * expiration comes). We also want to avoid removing an entry prematurely if the entry was set, +       * to the same value again., +        @Override, +        public void run() {, +         * This cast isn't safe, but we can rely on the fact that K is almost always passed to, +         * Map.get(), and tools like IDEs and Findbugs can catch situations where this isn't the, +         * case., +         * The alternative is to add an overloaded method, but the chances of a user calling get(), +         * instead of the new API and the risks inherent in adding a new API outweigh this little, +         * hole., +      throw new IllegalStateException(, +          "expiration time of " + expirationMillis + " ns was already set");, +      throw new IllegalStateException("maximum size of " + maximumSize + " was already set");, +      throw new IllegalArgumentException("invalid maximum size: " + maximumSize);, +      throw new IllegalArgumentException("GWT only supports a concurrency level of 1");, +        ? new ExpiringComputingMap<K, V>(expirationMillis, null, maximumSize, initialCapacity,, +            loadFactor), +  public <K, V> ConcurrentMap<K, V> makeComputingMap(Function<? super K, ? extends V> computer) {, +    return new ExpiringComputingMap<K, V>(expirationMillis, computer, maximumSize, initialCapacity,, +        loadFactor);, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * A class exactly like {@link MapMaker}, except restricted in the types of maps it can build. This, + * type is returned by {@link MapMaker#evictionListener} to prevent the user from trying to build a, + * map that's incompatible with the key and value types of the listener., +  public abstract GenericMapMaker<K0, V0> concurrencyLevel(int concurrencyLevel);, +  public abstract GenericMapMaker<K0, V0> expiration(long duration, TimeUnit unit);, +  public abstract GenericMapMaker<K0, V0> expireAfterWrite(long duration, TimeUnit unit);, +   * Note that MapMaker's evictionListener() is not here, because once you're interacting with a, +   * GenericMapMaker you've already called that, and shouldn't be calling it again., +  public abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeComputingMap(, +      Function<? super K, ? extends V> computingFunction);, +++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java, + * MapMaker emulation. Since Javascript is single-threaded and have no references, this reduces to, + * the creation of expiring and computing maps., +  // TODO(user,user): ConcurrentHashMap never throws a CME when mutating the map during iteration, but, +  // this implementation (based on a LHM) does. This will all be replaced soon anyways, so leaving, +  // it as is for now., +  private static class ExpiringComputingMap<K, V> extends LinkedHashMap<K, V>, +      implements ConcurrentMap<K, V> {, +    ExpiringComputingMap(long expirationMillis, int maximumSize, int initialCapacity,, +        float loadFactor) {, +    ExpiringComputingMap(long expirationMillis, Function<? super K, ? extends V> computer,, +        int maximumSize, int initialCapacity, float loadFactor) {, +       * TODO: Keep weak reference to map, too. Build a priority queue out of the entries themselves, +       * instead of creating a task per entry. Then, we could have one recurring task per map (which, +       * would clean the entire map and then reschedule itself depending upon when the next, +       * expiration comes). We also want to avoid removing an entry prematurely if the entry was set, +       * to the same value again., +        @Override, +        public void run() {, +         * This cast isn't safe, but we can rely on the fact that K is almost always passed to, +         * Map.get(), and tools like IDEs and Findbugs can catch situations where this isn't the, +         * case., +         * The alternative is to add an overloaded method, but the chances of a user calling get(), +         * instead of the new API and the risks inherent in adding a new API outweigh this little, +         * hole., +      throw new IllegalStateException(, +          "expiration time of " + expirationMillis + " ns was already set");, +      throw new IllegalStateException("maximum size of " + maximumSize + " was already set");, +      throw new IllegalArgumentException("invalid maximum size: " + maximumSize);, +      throw new IllegalArgumentException("GWT only supports a concurrency level of 1");, +        ? new ExpiringComputingMap<K, V>(expirationMillis, null, maximumSize, initialCapacity,, +            loadFactor)]