[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +     * Invoked after the key has been garbage collected., +     */, +    void notifyKeyReclaimed();, +, +    /**, +    void notifyValueReclaimed(ValueReference<K, V> valueReference);, +    public void notifyKeyReclaimed() {}, +    @Override, +    public void notifyValueReclaimed(ValueReference<Object, Object> v) {}, +  static final Queue<? extends ReferenceEntry<?, ?>> DISCARDING_QUEUE =, +      new AbstractQueue<ReferenceEntry<?, ?>>() {, +    public boolean offer(ReferenceEntry<?, ?> o) {, +    public ReferenceEntry<?, ?> peek() {, +    public ReferenceEntry<?, ?> poll() {, +    public Iterator<ReferenceEntry<?, ?>> iterator() {, +    @Override, +    public void notifyKeyReclaimed() {}, +, +    public void notifyValueReclaimed(ValueReference<K, V> v) {, +      notifyKeyReclaimed();, +, +    @Override, +    public void notifyKeyReclaimed() {, +      map.reclaimKey(this);, +    public void notifyValueReclaimed(ValueReference<K, V> v) {, +      notifyKeyReclaimed();, +, +    @Override, +    public void notifyKeyReclaimed() {, +      map.reclaimKey(this);, +    public void notifyValueReclaimed(ValueReference<K, V> v) {, +      entry.notifyValueReclaimed(this);, +    @Override, +    @Override, +    @Override, +    @Override, +      entry.notifyValueReclaimed(this);, +    @Override, +    @Override, +    @Override, +    @Override, +    @Override, +    @Override, +    @Override, +    @Override, +    @Override, +  void reclaimKey(ReferenceEntry<K, V> entry) {, +    segmentFor(hash).unsetKey(entry, hash);, +    if (evictionNotificationQueue == DISCARDING_QUEUE) {, +      return;, +    }, +, +    /**, +     * Cleanup expired entries when the lock is available., +     */, +    void tryExpireEntries() {, +      if (tryLock()) {, +        try {, +          expireEntries();, +        } finally {, +          unlock();, +        }, +      }, +    }, +, +     * Half-removes an entry from the map by moving it into the unset state,, +     * sending the removal notification, and enqueueing subsequent cleanup. This, +     * should be called when an entry's key has been garbage collected, and that, +     * entry is now invalid., +    boolean unsetKey(ReferenceEntry<K, V> entry, int hash) {, +      lock();, +        int newCount = count - 1;, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +        int index = hash & (table.length() - 1);, +        ReferenceEntry<K, V> first = table.get(index);, +, +        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +          if (e == entry) {, +            ++modCount;, +            enqueueNotification(e.getKey(), hash, e.getValueReference());, +            enqueueCleanup(e);, +            count = newCount; // write-volatile, +            return true;, +          }, +        }, +, +        return false;, +    /**, +     * Half-removes an entry from the map by moving it into the unset state,, +     * sending the removal notification, and enqueueing subsequent cleanup. This, +     * should be called when an entry's value has been garbage collected, and that, +     * entry is now invalid., +     */, +    boolean unsetEntry(ReferenceEntry<K, V> entry, int hash) {, +      for (ReferenceEntry<K, V> e = getFirst(hash); e != null;, +          e = e.getNext()) {, +        if (e == entry) {, +          return unsetLiveEntry(entry, hash);, +        }]