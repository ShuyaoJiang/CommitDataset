[+++ b/guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java, +            + "If the class is better tested explicitly, you can add %s() to %sTest",, +      return !cls.getDeclaredMethod("equals", Object.class).isSynthetic();, +++ b/guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java, +            + "If the class is better tested explicitly, you can add %s() to %sTest",, +      return !cls.getDeclaredMethod("equals", Object.class).isSynthetic();, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +    setDefault(Class.class, Class.class);, +    if (!Modifier.isAbstract(cls.getModifiers())) {, +    }, +    Object arg = generator.generate(param.getType());, +++ b/guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java, +            + "If the class is better tested explicitly, you can add %s() to %sTest",, +      return !cls.getDeclaredMethod("equals", Object.class).isSynthetic();, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +    setDefault(Class.class, Class.class);, +    if (!Modifier.isAbstract(cls.getModifiers())) {, +    }, +    Object arg = generator.generate(param.getType());, +++ b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java, +import com.google.common.collect.BiMap;, +import com.google.common.collect.HashBasedTable;, +import com.google.common.collect.HashBiMap;, +import com.google.common.collect.HashMultimap;, +import com.google.common.collect.HashMultiset;, +import com.google.common.collect.ImmutableBiMap;, +import com.google.common.collect.ImmutableCollection;, +import com.google.common.collect.ImmutableListMultimap;, +import com.google.common.collect.ImmutableMap;, +import com.google.common.collect.ImmutableMultimap;, +import com.google.common.collect.ImmutableMultiset;, +import com.google.common.collect.ImmutableSet;, +import com.google.common.collect.ImmutableSetMultimap;, +import com.google.common.collect.ImmutableSortedMap;, +import com.google.common.collect.ImmutableSortedMultiset;, +import com.google.common.collect.ImmutableSortedSet;, +import com.google.common.collect.ImmutableTable;, +import com.google.common.collect.LinkedHashMultimap;, +import com.google.common.collect.LinkedHashMultiset;, +import com.google.common.collect.Lists;, +import com.google.common.collect.Maps;, +import com.google.common.collect.Multimap;, +import com.google.common.collect.Multiset;, +import com.google.common.collect.RowSortedTable;, +import com.google.common.collect.SetMultimap;, +import com.google.common.collect.SortedMultiset;, +import com.google.common.collect.Table;, +import com.google.common.collect.TreeBasedTable;, +import com.google.common.collect.TreeMultiset;, +import com.google.common.reflect.Invokable;, +import com.google.common.reflect.Parameter;, +import java.io.InputStream;, +import java.io.Reader;, +import java.lang.reflect.Array;, +import java.lang.reflect.TypeVariable;, +import java.nio.Buffer;, +import java.util.ArrayList;, +import java.util.Comparator;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.LinkedList;, +import java.util.Map;, +import java.util.NavigableMap;, +import java.util.NavigableSet;, +import java.util.SortedMap;, +import java.util.SortedSet;, +import java.util.TreeMap;, +import java.util.TreeSet;, +import java.util.concurrent.ConcurrentMap;, +import javax.annotation.Nullable;, +, +  private static final ImmutableMap<Class<?>, Method> GENERATORS;, +  static {, +    ImmutableMap.Builder<Class<?>, Method> builder =, +        ImmutableMap.builder();, +    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {, +      if (method.isAnnotationPresent(Generates.class)) {, +        builder.put(method.getReturnType(), method);, +      }, +    }, +    GENERATORS = builder.build();, +  }, +, +  /**, +   * Returns a fresh instance for {@code type} if possible. The returned instance could be:, +   * <ul>, +   * <li>exactly of the given type, including generic type parameters, such as, +   *     {@code ImmutableList<String>};, +   * <li>of the raw type;, +   * <li>null if no fresh value can be generated., +   * </ul>, +   */, +  @Nullable final <T> T generate(TypeToken<T> type) {, +    // Not completely safe since sample instances are registered by raw types., +    // But we assume the generic type parameters are mostly unimportant for these dummy values,, +    // because what really matters are equals/hashCode., +    @SuppressWarnings("unchecked"), +    T result = (T) generateIfPossible(type);]