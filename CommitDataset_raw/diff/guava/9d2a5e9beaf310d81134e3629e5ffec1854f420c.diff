[+++ b/guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.collect.Iterables;, +import com.google.common.math.IntMath;, +import java.util.AbstractSet;, +import java.util.Iterator;, +  private int selfLoopCount;, +, +  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap,, +      int selfLoopCount) {, +    this.selfLoopCount = selfLoopCount;, +    return new AbstractSet<E>() {, +      @Override, +      public Iterator<E> iterator() {, +        return selfLoopCount == 0, +            ? Iterables.concat(inEdges(), outEdges()).iterator(), +            : Sets.union(inEdges(), outEdges()).iterator();, +      }, +, +      @Override, +      public int size() {, +        return IntMath.saturatedAdd(inEdgeMap.size() - selfLoopCount, outEdgeMap.size());, +      }, +, +      @Override, +      public boolean contains(Object obj) {, +        return inEdgeMap.containsKey(obj) || outEdgeMap.containsKey(obj);, +      }, +    };, +  public N removeInEdge(Object edge, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      selfLoopCount--;, +      checkState(selfLoopCount >= 0);, +    }, +  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      selfLoopCount++;, +      checkState(selfLoopCount >= 1);, +    }, +      checkState(node.equals(previousNode));, +      checkState(node.equals(previousNode));, +++ b/guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.collect.Iterables;, +import com.google.common.math.IntMath;, +import java.util.AbstractSet;, +import java.util.Iterator;, +  private int selfLoopCount;, +, +  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap,, +      int selfLoopCount) {, +    this.selfLoopCount = selfLoopCount;, +    return new AbstractSet<E>() {, +      @Override, +      public Iterator<E> iterator() {, +        return selfLoopCount == 0, +            ? Iterables.concat(inEdges(), outEdges()).iterator(), +            : Sets.union(inEdges(), outEdges()).iterator();, +      }, +, +      @Override, +      public int size() {, +        return IntMath.saturatedAdd(inEdgeMap.size() - selfLoopCount, outEdgeMap.size());, +      }, +, +      @Override, +      public boolean contains(Object obj) {, +        return inEdgeMap.containsKey(obj) || outEdgeMap.containsKey(obj);, +      }, +    };, +  public N removeInEdge(Object edge, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      selfLoopCount--;, +      checkState(selfLoopCount >= 0);, +    }, +  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      selfLoopCount++;, +      checkState(selfLoopCount >= 1);, +    }, +      checkState(node.equals(previousNode));, +      checkState(node.equals(previousNode));, +++ b/guava/src/com/google/common/graph/AbstractUndirectedNodeConnections.java, +  public N removeInEdge(Object edge, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      return null;, +    }, +  public boolean addInEdge(E edge, N node, boolean isSelfLoop) {, +    if (isSelfLoop) {, +      return false;, +    }, +++ b/guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.collect.Iterables;, +import com.google.common.math.IntMath;, +import java.util.AbstractSet;, +import java.util.Iterator;, +  private int selfLoopCount;, +, +  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap,]