[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +   * Creates a {@code LinkedHashSet} instance, with a high enough "initial, +   * capacity" that it <i>should</i> hold {@code expectedSize} elements without, +   * growth. This behavior cannot be broadly guaranteed, but it is observed to, +   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't, +   * inadvertently <i>oversizing</i> the returned set., +   *, +   * @param expectedSize the number of elements you expect to add to the, +   *        returned set, +   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold, +   *         {@code expectedSize} elements without resizing, +   * @throws IllegalArgumentException if {@code expectedSize} is negative, +   * @since 11.0, +   */, +  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(, +      int expectedSize) {, +    return new LinkedHashSet<E>(Maps.capacity(expectedSize));, +  }, +, +  /**, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +   * Creates a {@code LinkedHashSet} instance, with a high enough "initial, +   * capacity" that it <i>should</i> hold {@code expectedSize} elements without, +   * growth. This behavior cannot be broadly guaranteed, but it is observed to, +   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't, +   * inadvertently <i>oversizing</i> the returned set., +   *, +   * @param expectedSize the number of elements you expect to add to the, +   *        returned set, +   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold, +   *         {@code expectedSize} elements without resizing, +   * @throws IllegalArgumentException if {@code expectedSize} is negative, +   * @since 11.0, +   */, +  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(, +      int expectedSize) {, +    return new LinkedHashSet<E>(Maps.capacity(expectedSize));, +  }, +, +  /**, +++ b/guava-tests/test/com/google/common/collect/SetsTest.java, +  public void testNewLinkedHashSetWithExpectedSizeSmall() {, +    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(0);, +    verifySetContents(set, EMPTY_COLLECTION);, +  }, +, +  public void testNewLinkedHashSetWithExpectedSizeLarge() {, +    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(1000);, +    verifySetContents(set, EMPTY_COLLECTION);, +  }, +, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java, +   * Creates a {@code LinkedHashSet} instance, with a high enough "initial, +   * capacity" that it <i>should</i> hold {@code expectedSize} elements without, +   * growth. This behavior cannot be broadly guaranteed, but it is observed to, +   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't, +   * inadvertently <i>oversizing</i> the returned set., +   *, +   * @param expectedSize the number of elements you expect to add to the, +   *        returned set, +   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold, +   *         {@code expectedSize} elements without resizing, +   * @throws IllegalArgumentException if {@code expectedSize} is negative, +   * @since 11.0, +   */, +  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(, +      int expectedSize) {, +    return new LinkedHashSet<E>(Maps.capacity(expectedSize));, +  }, +, +  /**, +++ b/guava-tests/test/com/google/common/collect/SetsTest.java, +  public void testNewLinkedHashSetWithExpectedSizeSmall() {, +    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(0);, +    verifySetContents(set, EMPTY_COLLECTION);, +  }, +, +  public void testNewLinkedHashSetWithExpectedSizeLarge() {, +    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(1000);, +    verifySetContents(set, EMPTY_COLLECTION);, +  }, +, +++ b/guava/src/com/google/common/collect/Sets.java, +   * Creates a {@code LinkedHashSet} instance, with a high enough "initial, +   * capacity" that it <i>should</i> hold {@code expectedSize} elements without, +   * growth. This behavior cannot be broadly guaranteed, but it is observed to, +   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't, +   * inadvertently <i>oversizing</i> the returned set., +   *, +   * @param expectedSize the number of elements you expect to add to the, +   *        returned set, +   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold, +   *         {@code expectedSize} elements without resizing, +   * @throws IllegalArgumentException if {@code expectedSize} is negative, +   * @since 11.0, +   */, +  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(, +      int expectedSize) {, +    return new LinkedHashSet<E>(Maps.capacity(expectedSize));, +  }]