[+++ b/guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java, +  // TODO(user): consider making encodeTo(Appendable, byte[], int, int) public., +    StringBuilder result = new StringBuilder(maxEncodedSize(len));, +      encodeTo(result, bytes, off, len);, +      throw new AssertionError(impossible);, +    int len = decodeTo(tmp, chars);, +    return extract(tmp, len);, +  abstract void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException;, +  abstract int decodeTo(byte[] target, CharSequence chars) throws DecodingException;, +  private static final BaseEncoding BASE64 = new Base64Encoding(, +  private static final BaseEncoding BASE64_URL = new Base64Encoding(, +  private static final BaseEncoding BASE16 = new Base16Encoding("base16()", "0123456789ABCDEF");, +    int decode(char ch) throws DecodingException {, +  static class StandardBaseEncoding extends BaseEncoding {, +    final Alphabet alphabet;, +    final Character paddingChar;, +    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      for (int i = 0; i < len; i += alphabet.bytesPerChunk) {, +        encodeChunkTo(target, bytes, off + i, Math.min(alphabet.bytesPerChunk, len - i));, +    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len), +        throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      checkArgument(len <= alphabet.bytesPerChunk);, +      long bitBuffer = 0;, +      for (int i = 0; i < len; ++i) {, +        bitBuffer |= bytes[off + i] & 0xFF;, +        bitBuffer <<= 8; // Add additional zero byte in the end., +      // Position of first character is length of bitBuffer minus bitsPerChar., +      final int bitOffset = (len + 1) * 8 - alphabet.bitsPerChar;, +      int bitsProcessed = 0;, +      while (bitsProcessed < len * 8) {, +        int charIndex = (int) (bitBuffer >>> (bitOffset - bitsProcessed)) & alphabet.mask;, +        target.append(alphabet.encode(charIndex));, +        bitsProcessed += alphabet.bitsPerChar;, +      }, +        while (bitsProcessed < alphabet.bytesPerChunk * 8) {, +          target.append(paddingChar.charValue());, +          bitsProcessed += alphabet.bitsPerChar;, +    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {, +      checkNotNull(target);, +      checkNotNull(chars);, +      chars = padding().trimTrailingFrom(chars);, +      if (!alphabet.isValidPaddingStartPosition(chars.length())) {, +        throw new DecodingException("Invalid input length " + chars.length());, +      int bytesWritten = 0;, +      for (int charIdx = 0; charIdx < chars.length(); charIdx += alphabet.charsPerChunk) {, +        long chunk = 0;, +        int charsProcessed = 0;, +        for (int i = 0; i < alphabet.charsPerChunk; i++) {, +          chunk <<= alphabet.bitsPerChar;, +          if (charIdx + i < chars.length()) {, +            chunk |= alphabet.decode(chars.charAt(charIdx + charsProcessed++));, +        final int minOffset = alphabet.bytesPerChunk * 8 - charsProcessed * alphabet.bitsPerChar;, +        for (int offset = (alphabet.bytesPerChunk - 1) * 8; offset >= minOffset; offset -= 8) {, +          target[bytesWritten++] = (byte) ((chunk >>> offset) & 0xFF);, +      return bytesWritten;, +      return (paddingChar == null) ? this : newInstance(alphabet, null);, +        return newInstance(alphabet, padChar);, +            (upper == alphabet) ? this : newInstance(upper, paddingChar);, +            (lower == alphabet) ? this : newInstance(lower, paddingChar);, +    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {, +      return new StandardBaseEncoding(alphabet, paddingChar);, +    }, +, +  static final class Base16Encoding extends StandardBaseEncoding {, +    final char[] encoding = new char[512];, +, +    Base16Encoding(String name, String alphabetChars) {, +      this(new Alphabet(name, alphabetChars.toCharArray()));, +    }, +, +    private Base16Encoding(Alphabet alphabet) {, +      super(alphabet, null);, +      checkArgument(alphabet.chars.length == 16);, +      for (int i = 0; i < 256; ++i) {, +        encoding[i] = alphabet.encode(i >>> 4);, +        encoding[i | 0x100] = alphabet.encode(i & 0xF);, +      }, +    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      for (int i = 0; i < len; ++i) {, +        int b = bytes[off + i] & 0xFF;, +        target.append(encoding[b]);, +        target.append(encoding[b | 0x100]);, +    @Override, +    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {, +      checkNotNull(target);, +      checkNotNull(chars);, +      if (chars.length() % 2 == 1) {, +        throw new DecodingException("Invalid input length " + chars.length());, +      }, +      int bytesWritten = 0;, +      for (int i = 0; i < chars.length(); i += 2) {, +        int decoded = alphabet.decode(chars.charAt(i)) << 4 | alphabet.decode(chars.charAt(i + 1));, +        target[bytesWritten++] = (byte) decoded;, +      }]