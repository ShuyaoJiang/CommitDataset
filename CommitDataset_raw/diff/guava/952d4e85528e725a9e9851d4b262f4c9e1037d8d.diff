[+++ b/guava-tests/test/com/google/common/collect/SynchronizedDequeTest.java, +/*, + * Copyright (C) 2013 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.collect;, +, +import junit.framework.TestCase;, +, +import java.util.Collection;, +import java.util.Deque;, +import java.util.Iterator;, +, +/**, + * Tests for {@link Synchronized#deque} and {@link Queues#synchronizedDeque}., + *, + * @author Kurt Alfred Kluever, + */, +public class SynchronizedDequeTest extends TestCase {, +, +  protected Deque<String> create() {, +    TestDeque<String> inner = new TestDeque<String>();, +    Deque<String> outer = Synchronized.deque(inner, inner.mutex);, +    outer.add("foo");  // necessary because we try to remove elements later on, +    return outer;, +  }, +, +  private static final class TestDeque<E> implements Deque<E> {, +    private final Deque<E> delegate = Lists.newLinkedList();, +    public final Object mutex = new Integer(1); // something Serializable, +, +    @Override, +    public boolean offer(E o) {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.offer(o);, +    }, +, +    @Override, +    public E poll() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.poll();, +    }, +, +    @Override, +    public E remove() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.remove();, +    }, +, +    @Override, +    public E peek() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.peek();, +    }, +, +    @Override, +    public E element() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.element();, +    }, +, +    @Override, +    public Iterator<E> iterator() {, +      // We explicitly don't lock for iterator(), +      assertFalse(Thread.holdsLock(mutex));, +      return delegate.iterator();, +    }, +, +    @Override, +    public int size() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.size();, +    }, +, +    @Override, +    public boolean removeAll(Collection<?> collection) {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.removeAll(collection);, +    }, +, +    @Override, +    public boolean isEmpty() {, +      assertTrue(Thread.holdsLock(mutex));, +      return delegate.isEmpty();, +    }, +, +    @Override, +    public boolean contains(Object object) {]