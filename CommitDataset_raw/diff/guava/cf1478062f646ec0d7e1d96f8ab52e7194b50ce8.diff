[+++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  public void testSubmitAsync_asyncCallable_returnsInterruptedFuture() throws InterruptedException {, +    assertThat(Thread.interrupted()).isFalse();, +    SettableFuture<Integer> cancelledFuture = SettableFuture.create();, +    cancelledFuture.cancel(true);, +    assertThat(Thread.interrupted()).isFalse();, +    ListenableFuture<Integer> future =, +        submitAsync(constantAsyncCallable(cancelledFuture), directExecutor());, +    assertThat(future.isDone()).isTrue();, +    assertThat(Thread.interrupted()).isFalse();, +  }, +, +  @GwtIncompatible // threads, +, +  @GwtIncompatible // threads, +, +  public void testWhenAllComplete_noLeakInterruption() throws Exception {, +    final SettableFuture<String> stringFuture = SettableFuture.create();, +    AsyncCallable<String> combiner =, +        new AsyncCallable<String>() {, +          @Override, +          public ListenableFuture<String> call() throws Exception {, +            return stringFuture;, +          }, +        };, +, +    ListenableFuture<String> futureResult = whenAllComplete().callAsync(combiner, directExecutor());, +, +    assertThat(Thread.interrupted()).isFalse();, +    futureResult.cancel(true);, +    assertThat(Thread.interrupted()).isFalse();, +  }, +, +++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  public void testSubmitAsync_asyncCallable_returnsInterruptedFuture() throws InterruptedException {, +    assertThat(Thread.interrupted()).isFalse();, +    SettableFuture<Integer> cancelledFuture = SettableFuture.create();, +    cancelledFuture.cancel(true);, +    assertThat(Thread.interrupted()).isFalse();, +    ListenableFuture<Integer> future =, +        submitAsync(constantAsyncCallable(cancelledFuture), directExecutor());, +    assertThat(future.isDone()).isTrue();, +    assertThat(Thread.interrupted()).isFalse();, +  }, +, +  @GwtIncompatible // threads, +, +  @GwtIncompatible // threads, +, +  public void testWhenAllComplete_noLeakInterruption() throws Exception {, +    final SettableFuture<String> stringFuture = SettableFuture.create();, +    AsyncCallable<String> combiner =, +        new AsyncCallable<String>() {, +          @Override, +          public ListenableFuture<String> call() throws Exception {, +            return stringFuture;, +          }, +        };, +, +    ListenableFuture<String> futureResult = whenAllComplete().callAsync(combiner, directExecutor());, +, +    assertThat(Thread.interrupted()).isFalse();, +    futureResult.cancel(true);, +    assertThat(Thread.interrupted()).isFalse();, +  }, +, +++ b/android/guava/src/com/google/common/util/concurrent/CombinedFuture.java, +  private abstract class CombinedFutureInterruptibleTask<T> extends InterruptibleTask<T> {, +    final boolean isDone() {, +      return CombinedFuture.this.isDone();, +    @Override, +    final void afterRanInterruptibly(T result, Throwable error) {, +      if (error != null) {, +        if (error instanceof ExecutionException) {, +          setException(error.getCause());, +        } else if (error instanceof CancellationException) {, +          cancel(false);, +        } else {, +          setException(error);, +        }, +      } else {, +        setValue(result);, +      }, +    }, +, +    abstract void setValue(T value);, +  private final class AsyncCallableInterruptibleTask, +      extends CombinedFutureInterruptibleTask<ListenableFuture<V>> {, +    ListenableFuture<V> runInterruptibly() throws Exception {, +      thrownByExecute = false;, +      ListenableFuture<V> result = callable.call();, +      return checkNotNull(, +          result,, +          "AsyncCallable.call returned null instead of a Future. ", +              + "Did you mean to return immediateFuture(null)?");, +    }, +, +    @Override, +    void setValue(ListenableFuture<V> value) {, +      setFuture(value);]