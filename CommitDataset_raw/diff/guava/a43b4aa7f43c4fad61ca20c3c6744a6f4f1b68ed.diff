[+++ b/android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +    assertEquals(1, numCalls.get());, +, +  public void testRejectedExecutionThrownWithMultipleCalls() throws Exception {, +    final CountDownLatch latch = new CountDownLatch(1);, +    final SettableFuture<?> future = SettableFuture.create();, +    final Executor delegate =, +        new Executor() {, +          @Override, +          public void execute(Runnable task) {, +            if (future.set(null)) {, +              awaitUninterruptibly(latch);, +            }, +            throw new RejectedExecutionException();, +          }, +        };, +    final SequentialExecutor executor = new SequentialExecutor(delegate);, +    final ExecutorService blocked = Executors.newCachedThreadPool();, +    Future<?> first =, +        blocked.submit(, +            new Runnable() {, +              @Override, +              public void run() {, +                executor.execute(Runnables.doNothing());, +              }, +            });, +    future.get(10, TimeUnit.SECONDS);, +    try {, +      executor.execute(Runnables.doNothing());, +      fail();, +    } catch (RejectedExecutionException expected) {, +    }, +    latch.countDown();, +    try {, +      first.get(10, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected).hasCauseThat().isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +++ b/android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +    assertEquals(1, numCalls.get());, +, +  public void testRejectedExecutionThrownWithMultipleCalls() throws Exception {, +    final CountDownLatch latch = new CountDownLatch(1);, +    final SettableFuture<?> future = SettableFuture.create();, +    final Executor delegate =, +        new Executor() {, +          @Override, +          public void execute(Runnable task) {, +            if (future.set(null)) {, +              awaitUninterruptibly(latch);, +            }, +            throw new RejectedExecutionException();, +          }, +        };, +    final SequentialExecutor executor = new SequentialExecutor(delegate);, +    final ExecutorService blocked = Executors.newCachedThreadPool();, +    Future<?> first =, +        blocked.submit(, +            new Runnable() {, +              @Override, +              public void run() {, +                executor.execute(Runnables.doNothing());, +              }, +            });, +    future.get(10, TimeUnit.SECONDS);, +    try {, +      executor.execute(Runnables.doNothing());, +      fail();, +    } catch (RejectedExecutionException expected) {, +    }, +    latch.countDown();, +    try {, +      first.get(10, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected).hasCauseThat().isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +++ b/android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java, +import static com.google.common.base.Preconditions.checkNotNull;, +import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.IDLE;, +import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUED;, +import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUING;, +import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.RUNNING;, +, +import java.util.Deque;, +import java.util.concurrent.RejectedExecutionException;, +  enum WorkerRunningState {, +    /** Runnable is not running and not queued for execution */, +    IDLE,]