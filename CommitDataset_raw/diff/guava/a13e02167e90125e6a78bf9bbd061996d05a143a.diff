[+++ b/guava/src/com/google/common/collect/ComputingCache.java, +++ b/guava/src/com/google/common/collect/ComputingCache.java, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import java.lang.ref.ReferenceQueue;, +                  e = newEntry(key, hash, first);, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +++ b/guava/src/com/google/common/collect/ComputingCache.java, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import java.lang.ref.ReferenceQueue;, +                  e = newEntry(key, hash, first);, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +    public ReferenceEntry<K, V> getEntry() {, +      return null;, +    }, +, +    @Override, +    public ValueReference<K, V> copyFor(ReferenceQueue<V> queue, ReferenceEntry<K, V> entry) {, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.lang.ref.Reference;, +import java.lang.ref.ReferenceQueue;, +import java.lang.ref.SoftReference;, +   * Maximum number of entries to be drained in a single cleanup run. This applies independently to, +   * the cleanup queue and both reference queues., +  static final int DRAIN_MAX = 16;, +  boolean usesKeyReferences() {, +    return keyStrength != Strength.STRONG;, +  }, +, +  boolean usesValueReferences() {, +    return valueStrength != Strength.STRONG;, +  }, +, +      <K, V> ValueReference<K, V> referenceValue(, +          Segment<K, V> segment, ReferenceEntry<K, V> entry, V value) {, +      <K, V> ValueReference<K, V> referenceValue(, +          Segment<K, V> segment, ReferenceEntry<K, V> entry, V value) {, +        return new SoftValueReference<K, V>(segment.valueReferenceQueue, value, entry);, +      <K, V> ValueReference<K, V> referenceValue(, +          Segment<K, V> segment, ReferenceEntry<K, V> entry, V value) {, +        return new WeakValueReference<K, V>(segment.valueReferenceQueue, value, entry);, +    abstract <K, V> ValueReference<K, V> referenceValue(, +        Segment<K, V> segment, ReferenceEntry<K, V> entry, V value);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new StrongEntry<K, V>(key, hash, next);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new StrongExpirableEntry<K, V>(key, hash, next);, +      <K, V> ReferenceEntry<K, V> copyEntry(, +          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {, +        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new StrongEvictableEntry<K, V>(key, hash, next);, +      <K, V> ReferenceEntry<K, V> copyEntry(, +          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {, +        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new StrongExpirableEvictableEntry<K, V>(key, hash, next);, +      <K, V> ReferenceEntry<K, V> copyEntry(, +          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {, +        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new SoftEntry<K, V>(segment.keyReferenceQueue, key, hash, next);, +      <K, V> ReferenceEntry<K, V> newEntry(, +          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {, +        return new SoftExpirableEntry<K, V>(segment.keyReferenceQueue, key, hash, next);, +      <K, V> ReferenceEntry<K, V> copyEntry(, +          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {, +        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);]