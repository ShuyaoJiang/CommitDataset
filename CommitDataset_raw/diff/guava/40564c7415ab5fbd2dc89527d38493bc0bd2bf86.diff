[+++ b/android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +, +, +    @Override, +    public void execute(Runnable command) {, +, +    Runnable intCounter =, +        new Runnable() {, +    Runnable runMe =, +        new Runnable() {, +  public void testInterrupt_beforeRunRestoresInterruption() throws Exception {, +    // Run a task on the composed Executor that interrupts its thread (i.e. this thread)., +    fakePool.execute(, +        new Runnable() {, +          @Override, +          public void run() {, +            Thread.currentThread().interrupt();, +          }, +        });, +    // Run a task that expects that it is not interrupted while it is running., +    e.execute(, +        new Runnable() {, +          @Override, +          public void run() {, +            assertThat(Thread.currentThread().isInterrupted()).isFalse();, +          }, +        });, +, +    // Run these together., +    fakePool.runAll();, +, +    // Check that this thread has been marked as interrupted again now that the thread has been, +    // returned by SequentialExecutor. Clear the bit while checking so that the test doesn't hose, +    // JUnit or some other test case., +    assertThat(Thread.currentThread().interrupted()).isTrue();, +  }, +, +  public void testInterrupt_doesNotInterruptSubsequentTask() throws Exception {, +    // Run a task that interrupts its thread (i.e. this thread)., +    e.execute(, +        new Runnable() {, +          @Override, +          public void run() {, +            Thread.currentThread().interrupt();, +          }, +        });, +    // Run a task that expects that it is not interrupted while it is running., +    e.execute(, +        new Runnable() {, +          @Override, +          public void run() {, +            assertThat(Thread.currentThread().isInterrupted()).isFalse();, +          }, +        });, +, +    // Run those tasks together., +    fakePool.runAll();, +, +    // Check that the interruption of a SequentialExecutor's task is restored to the thread once, +    // it is yielded., +    assertThat(Thread.currentThread().isInterrupted()).isTrue();, +  }, +, +    Runnable runMe =, +        new Runnable() {, +, +    final SequentialExecutor executor =, +        new SequentialExecutor(, +              @Override, +              public void execute(Runnable r) {, +    Runnable task =, +        new Runnable() {, +    } catch (RejectedExecutionException expected) {, +    }, +      Runnable errorTask =, +          new Runnable() {, +      Runnable barrierTask =, +          new Runnable() {, +      barrier.await(1, TimeUnit.SECONDS);, +      barrier.await(1, TimeUnit.SECONDS);, +++ b/android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +, +, +    @Override, +    public void execute(Runnable command) {, +, +    Runnable intCounter =, +        new Runnable() {, +    Runnable runMe =, +        new Runnable() {, +  public void testInterrupt_beforeRunRestoresInterruption() throws Exception {, +    // Run a task on the composed Executor that interrupts its thread (i.e. this thread)., +    fakePool.execute(, +        new Runnable() {, +          @Override, +          public void run() {]