[+++ b/guava-tests/test/com/google/common/collect/ImmutableSortedMapTest.java, +import com.google.common.collect.testing.NavigableMapTestSuiteBuilder;, +    suite.addTest(NavigableMapTestSuiteBuilder.using(, +            CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS,, +            MapFeature.ALLOWS_NULL_QUERIES), +++ b/guava-tests/test/com/google/common/collect/ImmutableSortedMapTest.java, +import com.google.common.collect.testing.NavigableMapTestSuiteBuilder;, +    suite.addTest(NavigableMapTestSuiteBuilder.using(, +            CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS,, +            MapFeature.ALLOWS_NULL_QUERIES), +++ b/guava/src/com/google/common/collect/ImmutableSortedMap.java, +import static com.google.common.collect.Maps.keyOrNull;, +import java.util.NavigableMap;, +    extends ImmutableSortedMapFauxverideShim<K, V> implements NavigableMap<K, V> {, +  /**, +   * This method returns a {@code ImmutableSortedMap}, consisting of the entries, +   * whose keys are less than (or equal to, if {@code inclusive}) {@code toKey}., +   *, +   * <p>The {@link SortedMap#headMap} documentation states that a submap of a, +   * submap throws an {@link IllegalArgumentException} if passed a {@code toKey}, +   * greater than an earlier {@code toKey}. However, this method doesn't throw, +   * an exception in that situation, but instead keeps the original {@code, +   * toKey}., +   */, +  @Override, +  public ImmutableSortedMap<K, V> headMap(K toKey, boolean inclusive) {, +  /**, +   * This method returns a {@code ImmutableSortedMap}, consisting of the entries, +   * whose keys ranges from {@code fromKey} to {@code toKey}, inclusive or, +   * exclusive as indicated by the boolean flags., +   *, +   * <p>The {@link SortedMap#subMap} documentation states that a submap of a, +   * submap throws an {@link IllegalArgumentException} if passed a {@code, +   * fromKey} less than an earlier {@code fromKey}. However, this method doesn't, +   * throw an exception in that situation, but instead keeps the original {@code, +   * fromKey}. Similarly, this method keeps the original {@code toKey}, instead, +   * of throwing an exception, if passed a {@code toKey} greater than an earlier, +   * {@code toKey}., +   */, +  @Override, +  public ImmutableSortedMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey,, +  /**, +   * This method returns a {@code ImmutableSortedMap}, consisting of the entries, +   * whose keys are greater than (or equal to, if {@code inclusive}), +   * {@code fromKey}., +   *, +   * <p>The {@link SortedMap#tailMap} documentation states that a submap of a, +   * submap throws an {@link IllegalArgumentException} if passed a {@code, +   * fromKey} less than an earlier {@code fromKey}. However, this method doesn't, +   * throw an exception in that situation, but instead keeps the original {@code, +   * fromKey}., +   */, +  @Override, +  public ImmutableSortedMap<K, V> tailMap(K fromKey, boolean inclusive) {, +  @Override, +  public Entry<K, V> lowerEntry(K key) {, +    return headMap(key, false).lastEntry();, +  }, +, +  @Override, +  public K lowerKey(K key) {, +    return keyOrNull(lowerEntry(key));, +  }, +, +  @Override, +  public Entry<K, V> floorEntry(K key) {, +    return headMap(key, true).lastEntry();, +  }, +, +  @Override, +  public K floorKey(K key) {, +    return keyOrNull(floorEntry(key));, +  }, +, +  @Override, +  public Entry<K, V> ceilingEntry(K key) {, +    return tailMap(key, true).firstEntry();, +  }, +, +  @Override, +  public K ceilingKey(K key) {, +    return keyOrNull(ceilingEntry(key));, +  }, +, +  @Override, +  public Entry<K, V> higherEntry(K key) {, +    return tailMap(key, false).firstEntry();, +  }, +, +  @Override, +  public K higherKey(K key) {, +    return keyOrNull(higherEntry(key));, +  }, +, +  @Override, +  public Entry<K, V> firstEntry() {, +    return isEmpty() ? null : entries.get(0);, +  }, +, +  @Override]