[+++ b/guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java, +import java.util.ArrayDeque;, +import java.util.Collections;, +import java.util.Queue;, +  private static Map<AnnotatedElement, List<Annotation>> annotationCache =, +      new HashMap<AnnotatedElement, List<Annotation>>();, +  private static final Map<Method, TesterRequirements>, +      methodTesterRequirementsCache = new HashMap<Method, TesterRequirements>();, +, +    Queue<Feature<?>> queue = new ArrayDeque<Feature<?>>(features);, +    while (!queue.isEmpty()) {, +      Feature<?> feature = queue.remove();, +      for (Feature<?> implied : feature.getImpliedFeatures()) {, +        if (features.add(implied)) {, +          queue.add(implied);, +        }, +      }, +    Set<Feature<?>> impliedSet = new LinkedHashSet<Feature<?>>();, +    Queue<Feature<?>> queue = new ArrayDeque<Feature<?>>(features);, +    while (!queue.isEmpty()) {, +      Feature<?> feature = queue.remove();, +      for (Feature<?> implied : feature.getImpliedFeatures()) {, +        if (!features.contains(implied) && impliedSet.add(implied)) {, +          queue.add(implied);, +      }, +    }, +    return impliedSet;, +    synchronized (methodTesterRequirementsCache) {, +      TesterRequirements requirements = methodTesterRequirementsCache.get(testerMethod);, +      if (requirements == null) {, +        requirements = buildTesterRequirements(testerMethod);, +        methodTesterRequirementsCache.put(testerMethod, requirements);, +      }, +      return requirements;, +    }, +      List<Annotation> annotations = annotationCache.get(classOrMethod);, +        annotations = new ArrayList<Annotation>();, +        for (Annotation a : classOrMethod.getDeclaredAnnotations()) {, +          if (a.annotationType().isAnnotationPresent(TesterAnnotation.class)) {, +            annotations.add(a);, +          }, +        }, +        annotations = Collections.unmodifiableList(annotations);, +      return annotations;, +    if (!Collections.disjoint(allPresentFeatures, allAbsentFeatures)) {, +      throw new ConflictingRequirementsException(, +          "Annotation explicitly or ", +          intersection(allPresentFeatures, allAbsentFeatures),, +          testerAnnotation);, +    if (!Collections.disjoint(newFeatures, earlierFeatures)) {, +          intersection(newFeatures, earlierFeatures), source);, +    Set<T> result = Helpers.<T>copyToSet(set1);, +    result.retainAll(set2);, +    return result;]