[+++ b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java, +import com.google.common.cache.TestingRemovalListeners.QueuingRemovalListener;, +import java.util.concurrent.TimeUnit;, +  public void testExpiration_invalidateAll() {, +    FakeTicker ticker = new FakeTicker();, +    QueuingRemovalListener<Integer, Integer> listener =, +        TestingRemovalListeners.queuingRemovalListener();, +    Cache<Integer, Integer> cache = CacheBuilder.newBuilder(), +        .expireAfterAccess(1, TimeUnit.MINUTES), +        .removalListener(listener), +        .ticker(ticker), +        .build();, +    cache.put(1, 1);, +    ticker.advance(10, TimeUnit.MINUTES);, +    cache.invalidateAll();, +, +    assertThat(listener.poll().getCause()).isEqualTo(RemovalCause.EXPIRED);, +  }, +, +++ b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java, +import com.google.common.cache.TestingRemovalListeners.QueuingRemovalListener;, +import java.util.concurrent.TimeUnit;, +  public void testExpiration_invalidateAll() {, +    FakeTicker ticker = new FakeTicker();, +    QueuingRemovalListener<Integer, Integer> listener =, +        TestingRemovalListeners.queuingRemovalListener();, +    Cache<Integer, Integer> cache = CacheBuilder.newBuilder(), +        .expireAfterAccess(1, TimeUnit.MINUTES), +        .removalListener(listener), +        .ticker(ticker), +        .build();, +    cache.put(1, 1);, +    ticker.advance(10, TimeUnit.MINUTES);, +    cache.invalidateAll();, +, +    assertThat(listener.poll().getCause()).isEqualTo(RemovalCause.EXPIRED);, +  }, +, +++ b/guava/src/com/google/common/cache/LocalCache.java, +                enqueueNotification(entryKey, hash, value,, +                    valueReference.getWeight(), RemovalCause.COLLECTED);, +                enqueueNotification(entryKey, hash, value,, +                    valueReference.getWeight(), RemovalCause.EXPIRED);, +                getAndRecordStats(key, hash, loadingValueReference, loadingFuture);, +    void enqueueNotification(@Nullable K key, int hash, @Nullable V value, int weight,, +      totalWeight -= weight;, +                enqueueNotification(key, hash, entryValue,, +                    valueReference.getWeight(), RemovalCause.COLLECTED);, +              enqueueNotification(key, hash, entryValue,, +                  valueReference.getWeight(), RemovalCause.REPLACED);, +                    first, e, entryKey, hash, entryValue, valueReference, RemovalCause.COLLECTED);, +              enqueueNotification(key, hash, entryValue,, +                  valueReference.getWeight(), RemovalCause.REPLACED);, +                    first, e, entryKey, hash, entryValue, valueReference, RemovalCause.COLLECTED);, +            enqueueNotification(key, hash, entryValue,, +                valueReference.getWeight(), RemovalCause.REPLACED);, +                first, e, entryKey, hash, entryValue, valueReference, cause);, +                enqueueNotification(key, hash, entryValue, oldValueReference.getWeight(), cause);, +            enqueueNotification(key, hash, newValue, 0, RemovalCause.REPLACED);, +                first, e, entryKey, hash, entryValue, valueReference, cause);, +          long now = map.ticker.read();, +          preWriteCleanup(now);, +, +                K key = e.getKey();, +                V value = e.getValueReference().get();, +                RemovalCause cause = (key == null || value == null), +                    ? RemovalCause.COLLECTED, +                    : RemovalCause.EXPLICIT;, +                enqueueNotification(key, e.getHash(), value,, +                    e.getValueReference().getWeight(), cause);, +        ReferenceEntry<K, V> entry, @Nullable K key, int hash, V value,, +        ValueReference<K, V> valueReference, RemovalCause cause) {, +      enqueueNotification(key, hash, value, valueReference.getWeight(), cause);, +      enqueueNotification(entry.getKey(), entry.getHash(), entry.getValueReference().get(),, +          entry.getValueReference().getWeight(), RemovalCause.COLLECTED);, +            ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, e.getKey(), hash,, +                e.getValueReference().get(), e.getValueReference(), RemovalCause.COLLECTED);, +              ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, entryKey, hash,, +                  valueReference.get(), valueReference, RemovalCause.COLLECTED);, +    @VisibleForTesting, +          ReferenceEntry<K, V> newFirst = removeValueFromChain(first, e, e.getKey(), hash,, +              e.getValueReference().get(), e.getValueReference(), cause);]