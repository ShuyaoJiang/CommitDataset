[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +  private transient Multiset<K> keyCount; // the number of values for each key, +  private transient Map<K, Node<K, V>> keyToKeyHead; // the head for a given key, +  private transient Map<K, Node<K, V>> keyToKeyTail; // the tail for a given key, +    keyCount = LinkedHashMultiset.create();, +    keyToKeyHead = Maps.newHashMap();, +    keyToKeyTail = Maps.newHashMap();, +    keyCount = LinkedHashMultiset.create(expectedKeys);, +    keyToKeyHead = Maps.newHashMapWithExpectedSize(expectedKeys);, +    keyToKeyTail = Maps.newHashMapWithExpectedSize(expectedKeys);, +      keyToKeyHead.put(key, node);, +      keyToKeyTail.put(key, node);, +      Node<K, V> keyTail = keyToKeyTail.get(key);, +      if (keyTail == null) { // first for this key, +        keyToKeyHead.put(key, node);, +      keyToKeyTail.put(key, node);, +      tail = node;, +        keyToKeyHead.put(key, node);, +    keyCount.add(key);, +    if (node.previousSibling != null) {, +    } else if (node.nextSibling != null) { // node was key head, +      keyToKeyHead.put(node.key, node.nextSibling);, +      keyToKeyHead.remove(node.key); // don't leak a key-null entry, +    }, +    if (node.nextSibling != null) {, +    } else if (node.previousSibling != null) { // node was key tail, +      keyToKeyTail.put(node.key, node.previousSibling);, +    } else {, +      keyToKeyTail.remove(node.key); // don't leak a key-null entry, +    keyCount.remove(node.key);, +      next = keyToKeyHead.get(key);, +      int size = keyCount.count(key);, +        previous = keyToKeyTail.get(key);, +        next = keyToKeyHead.get(key);, +    return keyCount.size();, +    return keyToKeyHead.containsKey(key);, +    keyCount.clear();, +    keyToKeyHead.clear();, +    keyToKeyTail.clear();, +        return keyCount.count(key);, +          return keyCount.elementSet().size();, +      return keyCount.size();, +      return keyCount.count(element);, +              return keyCount.count(key);, +, +    @Override public boolean equals(@Nullable Object object) {, +      return keyCount.equals(object);, +    }, +, +    @Override public int hashCode() {, +      return keyCount.hashCode();, +    }, +, +    @Override public String toString() {, +      return keyCount.toString(); // XXX observe order?, +    }, +          return keyCount.size();, +          return keyCount.size();, +          return keyCount.elementSet().size();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +  private transient Multiset<K> keyCount; // the number of values for each key, +  private transient Map<K, Node<K, V>> keyToKeyHead; // the head for a given key, +  private transient Map<K, Node<K, V>> keyToKeyTail; // the tail for a given key, +    keyCount = LinkedHashMultiset.create();, +    keyToKeyHead = Maps.newHashMap();, +    keyToKeyTail = Maps.newHashMap();, +    keyCount = LinkedHashMultiset.create(expectedKeys);, +    keyToKeyHead = Maps.newHashMapWithExpectedSize(expectedKeys);, +    keyToKeyTail = Maps.newHashMapWithExpectedSize(expectedKeys);, +      keyToKeyHead.put(key, node);, +      keyToKeyTail.put(key, node);, +      Node<K, V> keyTail = keyToKeyTail.get(key);, +      if (keyTail == null) { // first for this key, +        keyToKeyHead.put(key, node);, +      keyToKeyTail.put(key, node);, +      tail = node;, +        keyToKeyHead.put(key, node);, +    keyCount.add(key);, +    if (node.previousSibling != null) {, +    } else if (node.nextSibling != null) { // node was key head, +      keyToKeyHead.put(node.key, node.nextSibling);, +      keyToKeyHead.remove(node.key); // don't leak a key-null entry, +    }, +    if (node.nextSibling != null) {, +    } else if (node.previousSibling != null) { // node was key tail, +      keyToKeyTail.put(node.key, node.previousSibling);, +    } else {, +      keyToKeyTail.remove(node.key); // don't leak a key-null entry, +    keyCount.remove(node.key);, +      next = keyToKeyHead.get(key);, +      int size = keyCount.count(key);, +        previous = keyToKeyTail.get(key);, +        next = keyToKeyHead.get(key);, +    return keyCount.size();, +    return keyToKeyHead.containsKey(key);, +    keyCount.clear();, +    keyToKeyHead.clear();, +    keyToKeyTail.clear();, +        return keyCount.count(key);, +          return keyCount.elementSet().size();]