[+++ b/guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java, +import com.google.common.collect.Lists;, +import java.util.List;, +import java.util.concurrent.Executor;, +  /**, +   * Catches a bug where when constructing a service manager failed, later interactions with the, +   * service could cause IllegalStateExceptions inside the partially constructed ServiceManager., +   * This ISE wouldn't actually bubble up but would get logged by ExecutionQueue.  This obfuscated, +   * the original error (which was not constructing ServiceManager correctly)., +   */, +  public void testPartiallyConstructedManager() {, +    Logger logger = Logger.getGlobal();, +    logger.setLevel(Level.FINEST);, +    TestLogHandler logHandler = new TestLogHandler();, +    logger.addHandler(logHandler);, +    NoOpService service = new NoOpService();, +    service.startAsync();, +    try {, +      new ServiceManager(Arrays.asList(service));, +      fail();, +    } catch (IllegalArgumentException expected) {}, +    service.stopAsync();, +    // Nothing was logged!, +    assertEquals(0, logHandler.getStoredLogRecords().size());, +  }, +, +  public void testPartiallyConstructedManager_transitionAfterAddListenerBeforeStateIsReady() {, +    // The implementation of this test is pretty sensitive to the implementation :( but we want to, +    // ensure that if weird things happen during construction then we get exceptions., +    final NoOpService service1 = new NoOpService();, +    // This service will start service1 when addListener is called.  This simulates service1 being, +    // started asynchronously., +    Service service2 = new Service() {, +      final NoOpService delegate = new NoOpService();, +      @Override public final void addListener(Listener listener, Executor executor) {, +        service1.startAsync();, +        delegate.addListener(listener, executor);, +      }, +      // Delegates from here on down, +      @Override public final Service startAsync() {, +        return delegate.startAsync();, +      }, +, +      @Override public final ListenableFuture<State> start() {, +        return delegate.start();, +      }, +, +      @Override public final Service stopAsync() {, +        return delegate.stopAsync();, +      }, +, +      @Override public final ListenableFuture<State> stop() {, +        return delegate.stop();, +      }, +, +      @Override public State startAndWait() {, +        return delegate.startAndWait();, +      }, +, +      @Override public State stopAndWait() {, +        return delegate.stopAndWait();, +      }, +, +      @Override public final void awaitRunning() {, +        delegate.awaitRunning();, +      }, +, +      @Override public final void awaitRunning(long timeout, TimeUnit unit), +          throws TimeoutException {, +        delegate.awaitRunning(timeout, unit);, +      }, +, +      @Override public final void awaitTerminated() {, +        delegate.awaitTerminated();, +      }, +, +      @Override public final void awaitTerminated(long timeout, TimeUnit unit), +          throws TimeoutException {, +        delegate.awaitTerminated(timeout, unit);, +      }, +, +      @Override public final boolean isRunning() {, +        return delegate.isRunning();, +      }, +, +      @Override public final State state() {, +        return delegate.state();, +      }, +, +      @Override public final Throwable failureCause() {, +        return delegate.failureCause();, +      }, +    };, +    try {, +      new ServiceManager(Arrays.asList(service1, service2));, +      fail();, +    } catch (IllegalArgumentException expected) {, +      assertTrue(expected.getMessage().contains("started transitioning asynchronously"));, +    }, +  }]