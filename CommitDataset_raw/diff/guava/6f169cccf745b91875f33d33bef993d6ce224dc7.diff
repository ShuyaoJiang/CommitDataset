[+++ b/guava/src/com/google/common/collect/Range.java, +   * considered empty, even though they contain no actual values.  In these cases, it may be , +   * helpful to preprocess ranges with {@link #canonical(DiscreteDomain)}., +   * , +   * <p>Note that certain discrete ranges are not considered connected, even though there are no, +   * elements "between them."  For example, {@code [3, 5]} is not considered connected to {@code , +   * [6, 10]}.  In these cases, it may be desirable for both input ranges to be preprocessed with, +   * {@link #canonical(DiscreteDomain)} before testing for connectedness., +++ b/guava/src/com/google/common/collect/Range.java, +   * considered empty, even though they contain no actual values.  In these cases, it may be , +   * helpful to preprocess ranges with {@link #canonical(DiscreteDomain)}., +   * , +   * <p>Note that certain discrete ranges are not considered connected, even though there are no, +   * elements "between them."  For example, {@code [3, 5]} is not considered connected to {@code , +   * [6, 10]}.  In these cases, it may be desirable for both input ranges to be preprocessed with, +   * {@link #canonical(DiscreteDomain)} before testing for connectedness., +++ b/guava/src/com/google/common/collect/RangeSet.java, + * A set comprising zero or more {@linkplain Range#isEmpty nonempty}, , + * {@linkplain Range#isConnected(Range) disconnected} ranges of type {@code C}., + * <p>Implementations that choose to support the {@link #add(Range)} operation are required to, + * ignore empty ranges and coalesce connected ranges.  For example:  <pre>   {@code, + *, + *   RangeSet<Integer> rangeSet = TreeRangeSet.create();, + *   rangeSet.add(Range.closed(1, 10)); // {[1, 10]}, + *   rangeSet.add(Range.closedOpen(11, 15)); // {[1, 10], [11, 15)} , + *   rangeSet.add(Range.open(15, 20)); // disconnected range; {[1, 10], [11, 20)}, + *   rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}, + *   rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}}</pre>, + *   , + * <p>Note that the behavior of {@link Range#isEmpty()} and {@link Range#isConnected(Range)} may, + * not be as expected on discrete ranges.  See the Javadoc of those methods for details., + */, +public interface RangeSet<C extends Comparable> {, +  , +  // Query methods, +   * Returns {@code true} if there exists a member range in this range set which, +   * {@linkplain Range#encloses encloses} the specified range., +  boolean encloses(Range<C> otherRange);, +, +  /**, +   * Returns {@code true} if for each member range in {@code other} there exists a member range in, +   * this range set which {@linkplain Range#encloses encloses} it. It follows that, +   * {@code this.contains(value)} whenever {@code other.contains(value)}. Returns {@code true} if, +   * {@code other} is empty., +   *, +   * <p>This is equivalent to checking if this range set {@link #encloses} each of the ranges in, +   * {@code other}., +   */, +  boolean enclosesAll(RangeSet<C> other);, +, +  /**, +   * Returns {@code true} if this range set contains no ranges., +   */, +  boolean isEmpty();, +  // Views, +  , +   * Returns a view of the {@linkplain Range#isConnected disconnected} ranges that make up this, +   * range set.  The returned set may be empty. The iterators returned by its, +   * {@link Iterable#iterator} method return the ranges in increasing order of lower bound, +   * (equivalently, of upper bound)., +  Set<Range<C>> asRanges();, +  // Modification, +, +  // Object methods, +, +   * Returns {@code asRanges().hashCode()}., +   */, +  @Override, +  int hashCode();, +, +  /**]