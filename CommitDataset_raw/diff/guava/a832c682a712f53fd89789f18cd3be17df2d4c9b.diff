[+++ b/guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java, +  /**, +   * Sets two distinct values for {@code type}. These values can be used for both null pointer, +   * testing and equals testing., +   *, +   * @since 17.0, +   */, +  protected final <T> void setDistinctValues(Class<T> type, T value1, T value2) {, +    tester.setDistinctValues(type, value1, value2);, +  }, +, +++ b/guava-testlib/src/com/google/common/testing/AbstractPackageSanityTests.java, +  /**, +   * Sets two distinct values for {@code type}. These values can be used for both null pointer, +   * testing and equals testing., +   *, +   * @since 17.0, +   */, +  protected final <T> void setDistinctValues(Class<T> type, T value1, T value2) {, +    tester.setDistinctValues(type, value1, value2);, +  }, +, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +import static com.google.common.base.Preconditions.checkArgument;, +  private final ListMultimap<Class<?>, Object> distinctValues = ArrayListMultimap.create();, +    distinctValues.putAll(checkNotNull(type), samples);, +   * Sets distinct values for {@code type}, so that when a class {@code Foo} is tested for {@link, +   * Object#equals} and {@link Object#hashCode}, and its construction requires a parameter of {@code, +   * type}, the distinct values of {@code type} can be passed as parametrs to create {@code Foo}, +   * instances that are unequal., +   *, +   * <p>Only necessary for types that {@link ClassSanityTester} doesn't already know how to create, +   * distinct values., +   *, +   * @return this tester instance, +   * @since 17.0, +   */, +  public <T> ClassSanityTester setDistinctValues(Class<T> type, T value1, T value2) {, +    checkNotNull(type);, +    checkNotNull(value1);, +    checkNotNull(value2);, +    checkArgument(!Objects.equal(value1, value2), "Duplicate value provided.");, +    distinctValues.replaceValues(type, ImmutableList.of(value1, value2));, +    setDefault(type, value1);, +    return this;, +  }, +, +  /**, +  // distinctValues is a type-safe class-values mapping, but we don't have a type-safe data, +    for (Map.Entry<Class<?>, Collection<Object>> entry : distinctValues.asMap().entrySet()) {]