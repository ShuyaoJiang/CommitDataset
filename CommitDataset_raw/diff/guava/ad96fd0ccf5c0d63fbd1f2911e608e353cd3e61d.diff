[+++ b/guava-tests/test/com/google/common/primitives/UnsignedIntsTest.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the, + * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either, + * express or implied. See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.primitives;, +, +import junit.framework.TestCase;, +, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.annotations.GwtIncompatible;, +import com.google.common.testing.NullPointerTester;, +, +/**, + * Tests for UnsignedInts, + *, + * @author Louis Wasserman, + */, +@GwtCompatible(emulated = true), +public class UnsignedIntsTest extends TestCase {, +  private static final long[] UNSIGNED_INTS = {, +      0L,, +      1L,, +      2L,, +      3L,, +      0x12345678L,, +      0x5a4316b8L,, +      0x6cf78a4bL,, +      0xff1a618bL,, +      0xfffffffdL,, +      0xfffffffeL,, +      0xffffffffL};, +, +  public void testToLong() {, +    for (long a : UNSIGNED_INTS) {, +      assertEquals(a, UnsignedInts.toLong((int) a));, +    }, +  }, +, +  public void testCompare() {, +    for (long a : UNSIGNED_INTS) {, +      for (long b : UNSIGNED_INTS) {, +        int cmpAsLongs = Longs.compare(a, b);, +        int cmpAsUInt = UnsignedInts.compare((int) a, (int) b);, +        assertEquals(Integer.signum(cmpAsLongs), Integer.signum(cmpAsUInt));, +      }, +    }, +  }, +, +  public void testDivide() {, +    for (long a : UNSIGNED_INTS) {, +      for (long b : UNSIGNED_INTS) {, +        try {, +          assertEquals((int) (a / b), UnsignedInts.divide((int) a, (int) b));, +          assertFalse(b == 0);, +        } catch (ArithmeticException e) {, +          assertEquals(0, b);, +        }, +      }, +    }, +  }, +, +  public void testParseInt() {, +    try {, +      for (long a : UNSIGNED_INTS) {, +        assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a)));, +      }, +    } catch (NumberFormatException e) {, +      fail(e.getMessage());, +    }, +, +    try {, +      UnsignedInts.parseUnsignedInt(Long.toString(1L << 32));, +      fail("Expected NumberFormatException");, +    } catch (NumberFormatException expected) {}, +  }, +, +  public void testParseLongWithRadix() throws NumberFormatException {, +    for (long a : UNSIGNED_INTS) {, +      for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {, +        assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a, radix), radix));, +      }, +    }, +, +    // loops through all legal radix values., +    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {, +      // tests can successfully parse a number string with this radix., +      String maxAsString = Long.toString((1L << 32) - 1, radix);, +      assertEquals(-1, UnsignedInts.parseUnsignedInt(maxAsString, radix));, +]