[+++ b/guava-gwt/src-super/com/google/common/cache/super/com/google/common/cache/CacheBuilder.java, + * Copyright (C) 2011 The Guava Authors, +import com.google.common.cache.CacheLoader.InvalidCacheLoadException;, +import com.google.common.collect.ImmutableMap;, +import com.google.common.util.concurrent.ExecutionError;, +import com.google.common.util.concurrent.UncheckedExecutionException;, +import com.google.gwt.user.client.Timer;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.ExecutionException;, +import javax.annotation.Nullable;, + * CacheBuilder emulation., +// TODO(fry): eventually we should emmulate LocalCache instead of CacheBuilder, +public class CacheBuilder<K, V> {, +  private static final int UNSET_INT = -1;, +  private int initialCapacity = -1;, +  private int concurrencyLevel = -1;, +  private long expirationMillis = -1;, +  private int maximumSize = -1;, +  private int getInitialCapacity() {, +    // GWT technically only supports concurrencyLevel == 1, but we silently, +    // ignore other positive values., +    checkState(expirationMillis == UNSET_INT, "expireAfterWrite was already set to %s ms",, +        expirationMillis);, +    this.expirationMillis = unit.toMillis(duration);, +  private long getExpirationMillis() {, +    return (expirationMillis == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expirationMillis;, +  public CacheBuilder<K, V> maximumSize(int maximumSize) {, +    if (this.maximumSize != -1) {, +      throw new IllegalStateException("maximum size of " + maximumSize + " was already set");, +    }, +    if (maximumSize < 0) {, +      throw new IllegalArgumentException("invalid maximum size: " + maximumSize);, +    }, +    this.maximumSize = maximumSize;, +  public <K1 extends K, V1 extends V> Cache<K1, V1> build() {, +    return new LocalManualCache<K1, V1>(this);, +    return new LocalLoadingCache<K1, V1>(this, loader);, +  private static class LocalManualCache<K, V> extends AbstractCache<K, V> {, +    final LocalCache<K, V> localCache;, +, +    LocalManualCache(CacheBuilder<? super K, ? super V> builder) {, +      this(builder, null);, +    protected LocalManualCache(CacheBuilder<? super K, ? super V> builder,, +        CacheLoader<? super K, V> loader) {, +      this.localCache = new LocalCache<K, V>(builder, loader);, +    // Cache methods, +    @Nullable, +    public V getIfPresent(Object key) {, +      return localCache.get(key);, +, +    @Override, +    public void put(K key, V value) {, +      localCache.put(key, value);, +, +    @Override, +    public void invalidate(Object key) {, +      checkNotNull(key);, +      localCache.remove(key);, +, +    @Override, +    public void invalidateAll() {, +      localCache.clear();, +, +    @Override, +    public long size() {, +      return localCache.size();, +, +    @Override, +    public ConcurrentMap<K, V> asMap() {, +      return localCache;, +  private static class LocalLoadingCache<K, V>, +      extends LocalManualCache<K, V> implements LoadingCache<K, V> {, +, +    LocalLoadingCache(CacheBuilder<? super K, ? super V> builder,, +        CacheLoader<? super K, V> loader) {, +      super(builder, checkNotNull(loader));, +    }, +, +    // Cache methods, +, +    @Override, +    public V get(K key) throws ExecutionException {, +      return localCache.getOrLoad(key);, +    }, +, +    @Override, +    public V getUnchecked(K key) {, +      try {, +        return get(key);, +      } catch (ExecutionException e) {, +        throw new UncheckedExecutionException(e.getCause());, +      }, +    }, +, +    @Override, +    public final V apply(K key) {, +      return getUnchecked(key);]