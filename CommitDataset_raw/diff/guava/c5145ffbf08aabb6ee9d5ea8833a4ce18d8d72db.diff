[+++ b/guava/src/com/google/common/util/concurrent/ExecutionList.java, + * <p>A list of listeners, each with an associated {@code Executor}, that, + * guarantees that every {@code Runnable} that is {@linkplain #add added} will, + * be executed after {@link #run()} is called. Any {@code Runnable} added after, + * the call to {@code run} is still guaranteed to execute. There is no, + * guarantee, however, that listeners will be executed in the order that they, + * are added., + *, + * <p>Exceptions thrown by a listener will be propagated up to the executor., + * Any exception thrown during {@code Executor.execute} (e.g., a {@code, + * RejectedExecutionException} or an exception thrown by {@linkplain, + * MoreExecutors#sameThreadExecutor inline execution}) will be caught and, + * logged., +   * Adds the {@code Runnable} and accompanying {@code Executor} to the list of, +   * listeners to execute. If execution has already begun, the listener is, +   * executed immediately., +   *, +   * <p>Note: For fast, lightweight listeners that would be safe to execute in, +   * any thread, consider {@link MoreExecutors#sameThreadExecutor}. For heavier, +   * listeners, {@code sameThreadExecutor()} carries some caveats: First, the, +   * thread that the listener runs in depends on whether the {@code Future} is, +   * done at the time it is added. In particular, if added late, listeners will, +   * run in the thread that calls {@code addListener}. Second, listeners may, +   * run in an internal thread of the system responsible for the input {@code, +   * Future}, such as an RPC network thread. Finally, during the execution of a, +   * listener, the thread cannot submit any additional listeners for execution,, +   * even if those listeners are to run in other executors., +    // OK with that.  If we want to change the contract to guarantee ordering, +      new RunnableExecutorPair(runnable, executor).execute();, +   * Runs this execution list, executing all existing pairs in the order they, +   * were added. However, note that listeners added after this point may be, +   * executed before those previously added, and note that the execution order, +   * of all listeners is ultimately chosen by the implementations of the, +   * supplied executors., +++ b/guava/src/com/google/common/util/concurrent/ExecutionList.java, + * <p>A list of listeners, each with an associated {@code Executor}, that, + * guarantees that every {@code Runnable} that is {@linkplain #add added} will, + * be executed after {@link #run()} is called. Any {@code Runnable} added after, + * the call to {@code run} is still guaranteed to execute. There is no, + * guarantee, however, that listeners will be executed in the order that they, + * are added., + *, + * <p>Exceptions thrown by a listener will be propagated up to the executor., + * Any exception thrown during {@code Executor.execute} (e.g., a {@code, + * RejectedExecutionException} or an exception thrown by {@linkplain, + * MoreExecutors#sameThreadExecutor inline execution}) will be caught and, + * logged., +   * Adds the {@code Runnable} and accompanying {@code Executor} to the list of, +   * listeners to execute. If execution has already begun, the listener is, +   * executed immediately., +   *, +   * <p>Note: For fast, lightweight listeners that would be safe to execute in, +   * any thread, consider {@link MoreExecutors#sameThreadExecutor}. For heavier, +   * listeners, {@code sameThreadExecutor()} carries some caveats: First, the, +   * thread that the listener runs in depends on whether the {@code Future} is, +   * done at the time it is added. In particular, if added late, listeners will, +   * run in the thread that calls {@code addListener}. Second, listeners may, +   * run in an internal thread of the system responsible for the input {@code, +   * Future}, such as an RPC network thread. Finally, during the execution of a, +   * listener, the thread cannot submit any additional listeners for execution,, +   * even if those listeners are to run in other executors., +    // OK with that.  If we want to change the contract to guarantee ordering, +      new RunnableExecutorPair(runnable, executor).execute();, +   * Runs this execution list, executing all existing pairs in the order they, +   * were added. However, note that listeners added after this point may be, +   * executed before those previously added, and note that the execution order, +   * of all listeners is ultimately chosen by the implementations of the, +   * supplied executors., +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +   * <p>Note: This overload of {@code chain} is designed for cases in which the, +   * work of creating the derived future is fast and lightweight, as the method, +   * does not accept an {@code Executor} to perform the the work in. For heavier, +   * derivations, this overload carries some caveats: First, the thread that the, +   * derivation runs in depends on whether the input {@code Future} is done at, +   * the time {@code chain} is called. In particular, if called late, {@code, +   * chain} will run the derivation in the thread that calls {@code chain}., +   * Second, derivations may run in an internal thread of the system responsible, +   * for the input {@code Future}, such as an RPC network thread. Finally,, +   * during the execution of a derivation, the thread cannot submit any, +   * listeners for execution, even if those listeners are to run in other, +   * executors., +   * <p>Note: For cases in which the work of creating the derived future is fast, +   * and lightweight, consider {@linkplain Futures#chain(ListenableFuture,, +   * Function) the other overload} or explicit use of {@link, +   * MoreExecutors#sameThreadExecutor}. For heavier derivations, this choice, +   * carries some caveats: First, the thread that the derivation runs in depends, +   * on whether the input {@code Future} is done at the time {@code chain} is, +   * called. In particular, if called late, {@code chain} will run the, +   * derivation in the thread that calls {@code chain}. Second, derivations may, +   * run in an internal thread of the system responsible for the input {@code, +   * Future}, such as an RPC network thread. Finally, during the execution of a, +   * derivation, the thread cannot submit any listeners for execution, even if, +   * those listeners are to run in other executors., +   *, +   * <p>Note: This overload of {@code transform} is designed for cases in which, +   * the transformation is fast and lightweight, as the method does not accept, +   * an {@code Executor} to perform the the work in. For heavier, +   * transformations, this overload carries some caveats: First, the thread that, +   * the transformation runs in depends on whether the input {@code Future} is, +   * done at the time {@code transform} is called. In particular, if called]