[+++ b/guava/src/com/google/common/base/AbstractEquivalence.java, +// Copyright 2011 Google Inc. All Rights Reserved., +, +package com.google.common.base;, +, +import com.google.common.annotations.GwtCompatible;, +, +import javax.annotation.Nullable;, +, +/**, + * Helper class to implement the contract around nulls., + * , + * @author benyu@google.com (Jige Yu), + */, +// TODO(benyu): Pull up into Equivalence and expose it as SPI., +@GwtCompatible, +abstract class AbstractEquivalence<T> extends Equivalence<T> {, +, +  @Override public final boolean equivalent(@Nullable T a, @Nullable T b) {, +    if (a == b) {, +      return true;, +    }, +    if (a == null || b == null) {, +      return false;, +    }, +    return equivalentNonNull(a, b);, +  }, +, +  @Override public final int hash(@Nullable T t) {, +    if (t == null) {, +      return 0;, +    }, +    return hashNonNull(t);, +  }, +, +  protected abstract boolean equivalentNonNull(T a, T b);, +  protected abstract int hashNonNull(T t);, +}, +++ b/guava/src/com/google/common/base/AbstractEquivalence.java, +// Copyright 2011 Google Inc. All Rights Reserved., +, +package com.google.common.base;, +, +import com.google.common.annotations.GwtCompatible;, +, +import javax.annotation.Nullable;, +, +/**, + * Helper class to implement the contract around nulls., + * , + * @author benyu@google.com (Jige Yu), + */, +// TODO(benyu): Pull up into Equivalence and expose it as SPI., +@GwtCompatible, +abstract class AbstractEquivalence<T> extends Equivalence<T> {, +, +  @Override public final boolean equivalent(@Nullable T a, @Nullable T b) {, +    if (a == b) {, +      return true;, +    }, +    if (a == null || b == null) {, +      return false;, +    }, +    return equivalentNonNull(a, b);, +  }, +, +  @Override public final int hash(@Nullable T t) {, +    if (t == null) {, +      return 0;, +    }, +    return hashNonNull(t);, +  }, +, +  protected abstract boolean equivalentNonNull(T a, T b);, +  protected abstract int hashNonNull(T t);, +}, +++ b/guava/src/com/google/common/base/Equivalence.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import java.io.Serializable;, +, +public abstract class Equivalence<T> {, +  public abstract boolean equivalent(@Nullable T a, @Nullable T b);, +   * Returns a hash code for {@code object}., +   * <p>The {@code hash} must have the following properties:, +   * <ul>, +   * <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of, +   *     {@code hash(x}} consistently return the same value provided {@code x} remains unchanged, +   *     according to the definition of the equivalence. The hash need not remain consistent from, +   *     one execution of an application to another execution of the same application., +   * <li>It is <i>distributable accross equivalence</i>: for any references {@code x} and {@code y},, +   *     if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i> necessary, +   *     that the hash be distributable accorss <i>inequivalence</i>. If {@code equivalence(x, y)}, +   *     is false, {@code hash(x) == hash(y)} may still be true., +   * <li>{@code hash(null)} is {@code 0}., +   * </ul>, +  public abstract int hash(@Nullable T t);, +, +  /**, +   * Returns a new equivalence relation for {@code F} which evaluates equivalence by first applying]