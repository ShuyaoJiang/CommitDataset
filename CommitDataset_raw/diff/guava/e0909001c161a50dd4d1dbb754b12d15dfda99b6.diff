[+++ b/guava-tests/test/com/google/common/io/ByteSourceTest.java, +import com.google.common.collect.Iterables;, +  public void testConcat_infiniteIterable() throws IOException {, +    ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});, +    Iterable<ByteSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    ByteSource concatenated = ByteSource.concat(cycle);, +, +    byte[] expected = {0, 1, 2, 3, 0, 1, 2, 3};, +    assertArrayEquals(expected, concatenated.slice(0, 8).read());, +  }, +, +++ b/guava-tests/test/com/google/common/io/ByteSourceTest.java, +import com.google.common.collect.Iterables;, +  public void testConcat_infiniteIterable() throws IOException {, +    ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});, +    Iterable<ByteSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    ByteSource concatenated = ByteSource.concat(cycle);, +, +    byte[] expected = {0, 1, 2, 3, 0, 1, 2, 3};, +    assertArrayEquals(expected, concatenated.slice(0, 8).read());, +  }, +, +++ b/guava-tests/test/com/google/common/io/CharSourceTest.java, +import com.google.common.collect.Iterables;, +import java.io.Reader;, +  public void testConcat_infiniteIterable() throws IOException {, +    CharSource source = CharSource.wrap("abcd");, +    Iterable<CharSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    CharSource concatenated = CharSource.concat(cycle);, +, +    String expected = "abcdabcd";, +, +    // read the first 8 chars manually, since there's no equivalent to ByteSource.slice, +    // TODO(user): Add CharSource.slice?, +    StringBuilder builder = new StringBuilder();, +    Reader reader = concatenated.openStream(); // no need to worry about closing, +    for (int i = 0; i < 8; i++) {, +      builder.append((char) reader.read());, +    }, +    assertEquals(expected, builder.toString());, +  }, +, +++ b/guava-tests/test/com/google/common/io/ByteSourceTest.java, +import com.google.common.collect.Iterables;, +  public void testConcat_infiniteIterable() throws IOException {, +    ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});, +    Iterable<ByteSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    ByteSource concatenated = ByteSource.concat(cycle);, +, +    byte[] expected = {0, 1, 2, 3, 0, 1, 2, 3};, +    assertArrayEquals(expected, concatenated.slice(0, 8).read());, +  }, +, +++ b/guava-tests/test/com/google/common/io/CharSourceTest.java, +import com.google.common.collect.Iterables;, +import java.io.Reader;, +  public void testConcat_infiniteIterable() throws IOException {, +    CharSource source = CharSource.wrap("abcd");, +    Iterable<CharSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    CharSource concatenated = CharSource.concat(cycle);, +, +    String expected = "abcdabcd";, +, +    // read the first 8 chars manually, since there's no equivalent to ByteSource.slice, +    // TODO(user): Add CharSource.slice?, +    StringBuilder builder = new StringBuilder();, +    Reader reader = concatenated.openStream(); // no need to worry about closing, +    for (int i = 0; i < 8; i++) {, +      builder.append((char) reader.read());, +    }, +    assertEquals(expected, builder.toString());, +  }, +, +++ b/guava/src/com/google/common/io/ByteSource.java, +   * Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from, +   * the source will contain the concatenated data from the streams of the underlying sources., +   * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will, +   * close the open underlying stream., +   * Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from, +   * the source will contain the concatenated data from the streams of the underlying sources., +   * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will, +   * close the open underlying stream., +   *, +   * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this, +   * method is called. This will fail if the iterator is infinite and may cause problems if the, +   * iterator eagerly fetches data for each source when iterated (rather than producing sources, +   * that only load data through their streams). Prefer using the {@link #concat(Iterable)}, +   * overload if possible., +   * Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from, +   * the source will contain the concatenated data from the streams of the underlying sources., +   * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will, +   * close the open underlying stream., +    private final Iterable<? extends ByteSource> sources;, +      this.sources = checkNotNull(sources);, +++ b/guava-tests/test/com/google/common/io/ByteSourceTest.java, +import com.google.common.collect.Iterables;, +  public void testConcat_infiniteIterable() throws IOException {, +    ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});, +    Iterable<ByteSource> cycle = Iterables.cycle(ImmutableList.of(source));, +    ByteSource concatenated = ByteSource.concat(cycle);]