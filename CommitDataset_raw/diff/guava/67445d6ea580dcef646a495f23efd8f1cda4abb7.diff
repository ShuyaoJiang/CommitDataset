[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import javax.annotation.concurrent.GuardedBy;, +          ComputingValueReference computingValueReference = null;, +              computingValueReference = new ComputingValueReference();, +              entry.setValueReference(computingValueReference);, +              V value = computingValueReference.compute(key, hash);, +                // TODO(user): don't incorrectly clobber put entries, +              V value = entry.getValueReference().waitForValue();, +                // TODO(user): don't incorrectly clobber put entries, +    public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {, +    public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {, +  private class ComputingValueReference implements ValueReference<K, V> {, +    @GuardedBy("ComputingValueReference.this") // writes, +    ValueReference<K, V> computedReference = unset();, +      return computedReference.get();, +      return this;, +     * Waits for a computation to complete. Returns the result of the, +     * computation., +    public V waitForValue() throws InterruptedException {, +      if (computedReference == UNSET) {, +        synchronized (this) {, +          if (computedReference == UNSET) {, +            wait();, +          }, +        }, +      }, +      return get();, +    }, +, +    public void clear() {, +      // The pending computation was clobbered by a manual write. Unblock all, +      // pending gets, and have them return the new value., +      // TODO(user): could also cancel computation if we had a thread handle, +      synchronized (this) {, +        notifyAll();, +      }, +    }, +, +    V compute(K key, int hash) {, +      V value;, +      try {, +        value = computingFunction.apply(key);, +      } catch (ComputationException e) {, +        // if computingFunction has thrown a computation exception,, +        // propagate rather than wrap, +        setValueReference(, +            new ComputationExceptionReference<K, V>(e.getCause()));, +        throw e;, +      } catch (Throwable t) {, +        setValueReference(new ComputationExceptionReference<K, V>(t));, +        throw new ComputationException(t);, +      }, +, +      if (value == null) {, +        String message =, +            computingFunction + " returned null for key " + key + ".";, +        setValueReference(new NullPointerExceptionReference<K, V>(message));, +        throw new NullPointerException(message);, +      }, +      setComputedValue(key, hash, value);, +      return value;, +    }, +, +    /**, +     * Sets the value of a newly computed entry. Adds newly created entries at, +     * the end of the expiration queue., +     */, +    void setComputedValue(K key, int hash, V value) {, +      Segment segment = segmentFor(hash);, +      segment.lock();, +      try {, +        for (ReferenceEntry<K, V> e = segment.getFirst(hash); e != null;, +            e = e.getNext()) {, +          K entryKey = e.getKey();, +          if (e.getHash() == hash && entryKey != null, +              && keyEquivalence.equivalent(key, entryKey)) {, +            ValueReference<K, V> liveValueReference = e.getValueReference();, +            if (liveValueReference == this) {, +              if (evictsBySize() || expires()) {, +                // "entry" currently points to the original entry created when, +                // computation began, but by now that entry may have been, +                // replaced. Find the current entry, and pass it to, +                // recordWrite to ensure that the eviction lists are, +                // consistent with the current map entries., +                segment.recordWrite(e);, +              }, +              setValueReference(valueStrength.referenceValue(e, value));, +            } else {, +              // avoid creating a new value reference pointing back to a, +              // disconnected entry, +              setValueReference(liveValueReference);, +            }, +            return;, +          }, +        }, +      } finally {, +        segment.unlock();, +      }, +    }, +]