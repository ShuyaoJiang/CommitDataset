[+++ b/guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java, +import static com.google.common.io.GwtWorkarounds.stringBuilderOutput;, +import com.google.common.io.GwtWorkarounds.ByteOutput;, +import com.google.common.io.GwtWorkarounds.CharOutput;, +  // TODO(user): consider adding encodeTo(Appendable, byte[], [int, int]), +    CharOutput result = stringBuilderOutput(maxEncodedSize(len));, +    ByteOutput byteOutput = encodingStream(result);, +      for (int i = 0; i < len; i++) {, +        byteOutput.write(bytes[off + i]);, +      }, +      byteOutput.close();, +      throw new AssertionError("impossible");, +  abstract ByteOutput encodingStream(CharOutput charOutput);, +  private static final BaseEncoding BASE64 = new StandardBaseEncoding(, +  private static final BaseEncoding BASE64_URL = new StandardBaseEncoding(, +  private static final BaseEncoding BASE16 =, +      new StandardBaseEncoding("base16()", "0123456789ABCDEF", null);, +  static final class StandardBaseEncoding extends BaseEncoding {, +    private final Alphabet alphabet;, +    private final Character paddingChar;, +    ByteOutput encodingStream(final CharOutput out) {, +      checkNotNull(out);, +      return new ByteOutput() {, +        int bitBuffer = 0;, +        int bitBufferLength = 0;, +        int writtenChars = 0;, +, +        @Override, +        public void write(byte b) throws IOException {, +          bitBuffer <<= 8;, +          bitBuffer |= b & 0xFF;, +          bitBufferLength += 8;, +          while (bitBufferLength >= alphabet.bitsPerChar) {, +            int charIndex = (bitBuffer >> (bitBufferLength - alphabet.bitsPerChar)), +                & alphabet.mask;, +            out.write(alphabet.encode(charIndex));, +            writtenChars++;, +            bitBufferLength -= alphabet.bitsPerChar;, +        @Override, +        public void flush() throws IOException {, +          out.flush();, +, +        @Override, +        public void close() throws IOException {, +          if (bitBufferLength > 0) {, +            int charIndex = (bitBuffer << (alphabet.bitsPerChar - bitBufferLength)), +                & alphabet.mask;, +            out.write(alphabet.encode(charIndex));, +            writtenChars++;, +              while (writtenChars % alphabet.charsPerChunk != 0) {, +                out.write(paddingChar.charValue());, +                writtenChars++;, +          out.close();, +        }, +      };, +    }, +      return (paddingChar == null) ? this : new StandardBaseEncoding(alphabet, null);, +        return new StandardBaseEncoding(alphabet, padChar);, +            (upper == alphabet) ? this : new StandardBaseEncoding(upper, paddingChar);, +            (lower == alphabet) ? this : new StandardBaseEncoding(lower, paddingChar);, +  static CharOutput separatingOutput(, +      final CharOutput delegate, final String separator, final int afterEveryChars) {, +    return new CharOutput() {, +      public void write(char c) throws IOException {, +          for (int i = 0; i < separator.length(); i++) {, +            delegate.write(separator.charAt(i));, +          }, +        delegate.write(c);, +      public void flush() throws IOException {, +        delegate.flush();, +      public void close() throws IOException {, +        delegate.close();, +    ByteOutput encodingStream(final CharOutput output) {, +      return delegate.encodingStream(separatingOutput(output, separator, afterEveryChars));, +++ b/guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java, +import static com.google.common.io.GwtWorkarounds.stringBuilderOutput;, +import com.google.common.io.GwtWorkarounds.ByteOutput;, +import com.google.common.io.GwtWorkarounds.CharOutput;, +  // TODO(user): consider adding encodeTo(Appendable, byte[], [int, int]), +    CharOutput result = stringBuilderOutput(maxEncodedSize(len));, +    ByteOutput byteOutput = encodingStream(result);, +      for (int i = 0; i < len; i++) {, +        byteOutput.write(bytes[off + i]);, +      }, +      byteOutput.close();, +      throw new AssertionError("impossible");, +  abstract ByteOutput encodingStream(CharOutput charOutput);, +  private static final BaseEncoding BASE64 = new StandardBaseEncoding(, +  private static final BaseEncoding BASE64_URL = new StandardBaseEncoding(, +  private static final BaseEncoding BASE16 =, +      new StandardBaseEncoding("base16()", "0123456789ABCDEF", null);, +  static final class StandardBaseEncoding extends BaseEncoding {, +    private final Alphabet alphabet;, +    private final Character paddingChar;, +    ByteOutput encodingStream(final CharOutput out) {, +      checkNotNull(out);, +      return new ByteOutput() {, +        int bitBuffer = 0;, +        int bitBufferLength = 0;, +        int writtenChars = 0;]