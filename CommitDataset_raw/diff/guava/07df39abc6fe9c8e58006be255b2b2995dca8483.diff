[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +/*, + * Copyright (C) 2015 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static com.google.common.util.concurrent.MoreExecutors.directExecutor;, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +, +/**, + * Emulation for AbstractFuture in GWT., + */, +public abstract class AbstractFuture<V> implements ListenableFuture<V> {, +, +  abstract static class TrustedFuture<V> extends AbstractFuture<V> {, +    @Override public final V get() throws InterruptedException, ExecutionException {, +      return super.get();, +    }, +, +    @Override public final V get(long timeout, TimeUnit unit), +        throws InterruptedException, ExecutionException, TimeoutException {, +      return super.get(timeout, unit);, +    }, +, +    @Override public final boolean isDone() {, +      return super.isDone();, +    }, +, +    @Override public final boolean isCancelled() {, +      return super.isCancelled();, +    }, +, +    @Override public final void addListener(Runnable listener, Executor executor) {, +      super.addListener(listener, executor);, +    }, +  }, +, +  private static final Logger log = Logger.getLogger(AbstractFuture.class.getName());, +, +  private State state;, +  private V value;, +  private Future<? extends V> delegate;, +  private Throwable throwable;, +  private boolean mayInterruptIfRunning;, +  private List<Listener> listeners;, +, +  protected AbstractFuture() {, +    state = State.PENDING;, +    listeners = new ArrayList<Listener>();, +  }, +  , +  @Override, +  public boolean cancel(boolean mayInterruptIfRunning) {, +    if (!state.permitsPublicUserToTransitionTo(State.CANCELLED)) {, +      return false;, +    }, +    , +    this.mayInterruptIfRunning = mayInterruptIfRunning;, +    state = State.CANCELLED;, +    notifyAndClearListeners();, +, +    if (delegate != null) {, +      delegate.cancel(mayInterruptIfRunning);, +    }, +, +    return true;, +  }, +, +  @Override, +  public boolean isCancelled() {, +    return state.isCancelled();, +  }, +, +  @Override, +  public boolean isDone() {, +    return state.isDone();]