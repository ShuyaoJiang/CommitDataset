[+++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +import java.util.concurrent.Executor;, + * An abstract implementation of the {@link ListenableFuture} interface. This, + * class is preferable to {@link java.util.concurrent.FutureTask} for two, + * reasons: It implements {@code ListenableFuture}, and it does not implement, + * {@code Runnable}. (If you want a {@code Runnable} implementation of {@code, + * ListenableFuture}, create a {@link ListenableFutureTask}, or submit your, + * tasks to a {@link ListeningExecutorService}.), + * <p>This class implements all methods in {@code ListenableFuture}., + * Subclasses should provide a way to set the result of the computation through, + * the protected methods {@link #set(Object)}, {@link #setException(Throwable)},, + * or {@link #cancel()}.  If subclasses want to implement cancellation, they can, + * override the {@link #cancel(boolean)} method with a real implementation; the, + * <p>{@code AbstractFuture} uses an {@link AbstractQueuedSynchronizer} to deal, + * with concurrency issues and guarantee thread safety., + *, + * <p>This class uses an {@link ExecutionList} to guarantee that all registered, + * listeners will be executed, either when the future finishes or, for listeners, + * that are added after the future completes, immediately., + * {@code Runnable}-{@code Executor} pairs are stored in the execution list but, + * are not necessarily executed in the order in which they were added.  (If a, + * listener is added after the Future is complete, it will be executed, + * immediately, even if earlier listeners have not been executed. Additionally,, + * executors need not guarantee FIFO execution, or different listeners may run, + * in different executors.), + *, +public abstract class AbstractFuture<V> implements ListenableFuture<V> {, +  // The execution list to hold our executors., +  private final ExecutionList executionList = new ExecutionList();, +, +  /*, +   * Adds a listener/executor pair to execution list to execute when this task, +   * is completed., +   */, +  @Override, +  public void addListener(Runnable listener, Executor exec) {, +    executionList.add(listener, exec);, +  }, +, +   * value is now available and the latch can be released., +  private void done() {, +    executionList.run();, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +import java.util.concurrent.Executor;, + * An abstract implementation of the {@link ListenableFuture} interface. This, + * class is preferable to {@link java.util.concurrent.FutureTask} for two, + * reasons: It implements {@code ListenableFuture}, and it does not implement, + * {@code Runnable}. (If you want a {@code Runnable} implementation of {@code, + * ListenableFuture}, create a {@link ListenableFutureTask}, or submit your, + * tasks to a {@link ListeningExecutorService}.), + * <p>This class implements all methods in {@code ListenableFuture}., + * Subclasses should provide a way to set the result of the computation through, + * the protected methods {@link #set(Object)}, {@link #setException(Throwable)},, + * or {@link #cancel()}.  If subclasses want to implement cancellation, they can, + * override the {@link #cancel(boolean)} method with a real implementation; the, + * <p>{@code AbstractFuture} uses an {@link AbstractQueuedSynchronizer} to deal, + * with concurrency issues and guarantee thread safety., + *, + * <p>This class uses an {@link ExecutionList} to guarantee that all registered, + * listeners will be executed, either when the future finishes or, for listeners, + * that are added after the future completes, immediately., + * {@code Runnable}-{@code Executor} pairs are stored in the execution list but, + * are not necessarily executed in the order in which they were added.  (If a, + * listener is added after the Future is complete, it will be executed, + * immediately, even if earlier listeners have not been executed. Additionally,, + * executors need not guarantee FIFO execution, or different listeners may run, + * in different executors.), + *, +public abstract class AbstractFuture<V> implements ListenableFuture<V> {, +  // The execution list to hold our executors., +  private final ExecutionList executionList = new ExecutionList();, +, +  /*, +   * Adds a listener/executor pair to execution list to execute when this task, +   * is completed., +   */, +  @Override, +  public void addListener(Runnable listener, Executor exec) {, +    executionList.add(listener, exec);, +  }, +, +   * value is now available and the latch can be released., +  private void done() {, +    executionList.run();, +++ b/guava/src/com/google/common/util/concurrent/AbstractListenableFuture.java, + * Legacy location of {@link AbstractFuture}. Prefer {@code AbstractFuture} in, + * new code., +public abstract class AbstractListenableFuture<V> extends AbstractFuture<V> {]