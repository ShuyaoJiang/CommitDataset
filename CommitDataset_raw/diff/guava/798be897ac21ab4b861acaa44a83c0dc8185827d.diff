[+++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +          newCount = this.count + 1;, +              if (isCollected(valueReference)) {, +              } else if (evictEntries()) { // evictEntries after setting new value, +                newCount = this.count + 1;, +      int newCount = count;, +              if (isCollected(e)) {, +                removeCollectedEntry(e);, +                newCount--;, +              } else {, +      }, +      this.count = newCount;, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +        int index = hash & (table.length() - 1);, +        ReferenceEntry<K, V> first = table.get(index);, +, +        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +            ValueReference<K, V> valueReference = e.getValueReference();, +            V entryValue = valueReference.get();, +              if (isCollected(valueReference)) {, +                int newCount = this.count - 1;, +                ++modCount;, +                enqueueNotification(entryKey, hash, entryValue, RemovalCause.COLLECTED);, +                ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +                newCount = this.count - 1;, +                table.set(index, newFirst);, +                this.count = newCount; // write-volatile, +              }, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +        int index = hash & (table.length() - 1);, +        ReferenceEntry<K, V> first = table.get(index);, +, +        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +            ValueReference<K, V> valueReference = e.getValueReference();, +            V entryValue = valueReference.get();, +              if (isCollected(valueReference)) {, +                int newCount = this.count - 1;, +                ++modCount;, +                enqueueNotification(entryKey, hash, entryValue, RemovalCause.COLLECTED);, +                ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +                newCount = this.count - 1;, +                table.set(index, newFirst);, +                this.count = newCount; // write-volatile, +              }, +            ValueReference<K, V> valueReference = e.getValueReference();, +            V entryValue = valueReference.get();, +, +            RemovalCause cause;, +              cause = RemovalCause.EXPLICIT;, +            } else if (isCollected(valueReference)) {, +              cause = RemovalCause.COLLECTED;, +            } else {, +              return null;, +            }, +, +            enqueueNotification(entryKey, hash, entryValue, cause);, +            newCount = this.count - 1;, +            ValueReference<K, V> valueReference = e.getValueReference();, +            V entryValue = valueReference.get();, +, +            RemovalCause cause;, +              cause = RemovalCause.EXPLICIT;, +            } else if (isCollected(valueReference)) {, +              cause = RemovalCause.COLLECTED;, +            } else {, +              return false;, +            }, +, +            enqueueNotification(entryKey, hash, entryValue, cause);, +            newCount = this.count - 1;, +            return (cause == RemovalCause.EXPLICIT);, +     * <p>This method does not decrement count for the removed entry, but does decrement count for, +     * all partially collected entries which are skipped. As such callers which are modifying count, +     * must re-read it after calling removeFromChain., +      int newCount = count;, +        if (isCollected(e)) {, +          removeCollectedEntry(e);, +          newCount--;, +        } else {, +      }, +      this.count = newCount;, +    void removeCollectedEntry(ReferenceEntry<K, V> entry) {, +      enqueueNotification(entry, RemovalCause.COLLECTED);, +      evictionQueue.remove(entry);, +      expirationQueue.remove(entry);, +    }, +, +            newCount = this.count - 1;, +              newCount = this.count - 1;, +          newCount = this.count - 1;, +     * Returns true if the entry has been partially collected, meaning that either the key is null,, +     * or the value is null and it is not computing., +     */, +    boolean isCollected(ReferenceEntry<K, V> entry) {, +      if (entry.getKey() == null) {, +        return true;, +      }, +      return isCollected(entry.getValueReference());, +    }, +]