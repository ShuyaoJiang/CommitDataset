[+++ b/guava/src/com/google/common/collect/UncheckedExecutionException.java, + * Unchecked version of {@link java.util.concurrent.ExecutionException}. As with, + * {@code ExecutionException}, the exception's {@linkplain #getCause() cause}, + * comes from a failed task, possibly run in another thread., + *, + * <p>{@code UncheckedExecutionException} is intended for users of {@code, + * Future} and similar classes who know that their tasks will never throw a, + * checked exception. They have the option of removing {@code throws, + * ExecutionException} from their signatures, wrapping any exceptions that do, + * occur in an {@code UncheckedExecutionException}., + * @since Guava release 10, +   * Creates a new instance with {@code null} as its detail message., +  protected UncheckedExecutionException() {}, +, +  /**, +   * Creates a new instance with the given detail message., +   */, +  protected UncheckedExecutionException(String message) {, +    super(message);, +  }, +, +  /**, +   * Creates a new instance with the given detail message and cause., +   */, +  public UncheckedExecutionException(String message, Throwable cause) {, +    super(message, cause);, +  public UncheckedExecutionException(Throwable cause) {, +    super(cause);, +++ b/guava/src/com/google/common/collect/UncheckedExecutionException.java, + * Unchecked version of {@link java.util.concurrent.ExecutionException}. As with, + * {@code ExecutionException}, the exception's {@linkplain #getCause() cause}, + * comes from a failed task, possibly run in another thread., + *, + * <p>{@code UncheckedExecutionException} is intended for users of {@code, + * Future} and similar classes who know that their tasks will never throw a, + * checked exception. They have the option of removing {@code throws, + * ExecutionException} from their signatures, wrapping any exceptions that do, + * occur in an {@code UncheckedExecutionException}., + * @since Guava release 10, +   * Creates a new instance with {@code null} as its detail message., +  protected UncheckedExecutionException() {}, +, +  /**, +   * Creates a new instance with the given detail message., +   */, +  protected UncheckedExecutionException(String message) {, +    super(message);, +  }, +, +  /**, +   * Creates a new instance with the given detail message and cause., +   */, +  public UncheckedExecutionException(String message, Throwable cause) {, +    super(message, cause);, +  public UncheckedExecutionException(Throwable cause) {, +    super(cause);, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +import static com.google.common.base.Preconditions.checkArgument;, +import static java.lang.Thread.currentThread;, +import static java.util.Arrays.asList;, +import com.google.common.collect.Ordering;, +import com.google.common.collect.UncheckedExecutionException;, +import java.lang.reflect.Constructor;, +import java.lang.reflect.InvocationTargetException;, +import java.util.Arrays;, +   * the system responsible for the input {@code Future}, such as an RPC network, +   * responsible for the input {@code Future}, such as an RPC network thread., +  public static <V> ListenableFuture<List<V>> allAsList(, +      ListenableFuture<? extends V>... futures) {, +    return new ListFuture<V>(ImmutableList.copyOf(futures), true,, +  public static <V> ListenableFuture<List<V>> allAsList(, +      Iterable<? extends ListenableFuture<? extends V>> futures) {, +    return new ListFuture<V>(ImmutableList.copyOf(futures), true,, +  public static <V> ListenableFuture<List<V>> successfulAsList(, +      ListenableFuture<? extends V>... futures) {, +    return new ListFuture<V>(ImmutableList.copyOf(futures), false,, +  public static <V> ListenableFuture<List<V>> successfulAsList(, +      Iterable<? extends ListenableFuture<? extends V>> futures) {, +    return new ListFuture<V>(ImmutableList.copyOf(futures), false,, +   * Returns the result of {@link Future#get()}, converting most exceptions to a, +   * new instance of the given checked exception type. This reduces boilerplate, +   * for a common use of {@code Future} in which it is unnecessary to, +   * programmatically distinguish between exception types or to extract other, +   * information from the exception instance., +   *, +   * <p>Exceptions from {@code Future.get} are treated as follows:, +   * <ul>, +   * <li>Any {@link InterruptedException} is wrapped in an {@code X} (after, +   *     restoring the interrupt)., +   * <li>Any {@link CancellationException} is propagated untouched., +   * <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an, +   *     {@code X}., +   * <li>Any {@link RuntimeException} other than {@code CancellationException}, +   *     ({@code get} implementations are discouraged from throwing such, +   *     exceptions) is wrapped in an {@code X}., +   * </ul>, +   *, +   * The overall principle is to wrap any checked exception (or its cause) in a, +   * checked exception, to pass through {@code CancellationException}, and to, +   * treat any other {@code RuntimeException} as a checked exception. (Throwing]