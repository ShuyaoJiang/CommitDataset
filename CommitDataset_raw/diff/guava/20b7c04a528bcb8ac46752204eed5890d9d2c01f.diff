[+++ b/guava-tests/test/com/google/common/io/ByteStreamsTest.java, +import java.io.File;, +import java.io.FileOutputStream;, +import java.io.RandomAccessFile;, +  public void testCopyFileChannel() throws IOException {, +    final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size, +    ByteArrayOutputStream out = new ByteArrayOutputStream();, +    WritableByteChannel outChannel = Channels.newChannel(out);, +, +    File testFile = createTempFile();, +    FileOutputStream fos = new FileOutputStream(testFile);, +    byte[] dummyData = newPreFilledByteArray(chunkSize);, +    try {, +      for (int i = 0; i < 500; i++) {, +        fos.write(dummyData);, +      }, +    } finally {, +      fos.close();, +    }, +    ReadableByteChannel inChannel = new RandomAccessFile(testFile, "r").getChannel();, +    try {, +      ByteStreams.copy(inChannel, outChannel);, +    } finally {, +      inChannel.close();, +    }, +    byte[] actual = out.toByteArray();, +    for (int i = 0; i < 500 * chunkSize; i += chunkSize) {, +      assertEquals(dummyData, Arrays.copyOfRange(actual, i, i + chunkSize));, +    }, +  }, +, +    assertEquals("Arrays differed in size", expected.length, actual.length);, +    assertTrue("Array contents were different", Arrays.equals(expected, actual));, +++ b/guava-tests/test/com/google/common/io/ByteStreamsTest.java, +import java.io.File;, +import java.io.FileOutputStream;, +import java.io.RandomAccessFile;, +  public void testCopyFileChannel() throws IOException {, +    final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size, +    ByteArrayOutputStream out = new ByteArrayOutputStream();, +    WritableByteChannel outChannel = Channels.newChannel(out);, +, +    File testFile = createTempFile();, +    FileOutputStream fos = new FileOutputStream(testFile);, +    byte[] dummyData = newPreFilledByteArray(chunkSize);, +    try {, +      for (int i = 0; i < 500; i++) {, +        fos.write(dummyData);, +      }, +    } finally {, +      fos.close();, +    }, +    ReadableByteChannel inChannel = new RandomAccessFile(testFile, "r").getChannel();, +    try {, +      ByteStreams.copy(inChannel, outChannel);, +    } finally {, +      inChannel.close();, +    }, +    byte[] actual = out.toByteArray();, +    for (int i = 0; i < 500 * chunkSize; i += chunkSize) {, +      assertEquals(dummyData, Arrays.copyOfRange(actual, i, i + chunkSize));, +    }, +  }, +, +    assertEquals("Arrays differed in size", expected.length, actual.length);, +    assertTrue("Array contents were different", Arrays.equals(expected, actual));, +++ b/guava/src/com/google/common/io/ByteStreams.java, +import java.nio.channels.FileChannel;, +  /**, +   * There are three methods to implement {@link FileChannel#transferTo(long, long,, +   *  WritableByteChannel)}:, +   *, +   * <ol>, +   * <li> Use sendfile(2) or equivalent. Requires that both the input channel and the output channel, +   *    have their own file descriptors. Generally this only happens when both channels are files or, +   *    sockets. This performs zero copies - the bytes never enter userspace.</li>, +   * <li> Use mmap(2) or equivalent. Requires that either the input channel or the output channel, +   *    have file descriptors. Bytes are copied from the file into a kernel buffer, then directly, +   *    into the other buffer (userspace). Note that if the file is very large, a naive, +   *    implementation will effectively put the whole file in memory. On many systems with paging, +   *    and virtual memory, this is not a problem - because it is mapped read-only, the kernel can, +   *    always page it to disk "for free". However, on systems where killing processes happens all, +   *    the time in normal conditions (i.e., android) the OS must make a tradeoff between paging, +   *    memory and killing other processes - so allocating a gigantic buffer and then sequentially, +   *    accessing it could result in other processes dying. This is solvable via madvise(2), but, +   *    that obviously doesn't exist in java.</li>, +   * <li> Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a, +   *    userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the, +   *    destination channel.</li>, +   * </ol>, +   *, +   * This value is intended to be large enough to make the overhead of system calls negligible,, +   * without being so large that it causes problems for systems with atypical memory management if, +   * approaches 2 or 3 are used., +   */, +  private static final int ZERO_COPY_CHUNK_SIZE = 512 * 1024;, +    if (from instanceof FileChannel) {, +      FileChannel sourceChannel = (FileChannel) from;, +      long oldPosition = sourceChannel.position();, +      long position = oldPosition;]