[+++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture(), +      throws Exception {, +    SettableFuture<String> future1 = SettableFuture.create();, +    SettableFuture<String> future2 = SettableFuture.create();, +    ListenableFuture<List<String>> compound =, +        Futures.allAsList(future1, future2);, +    // There was a bug where the event listener for the combined future would, +    // result in the sub-futures being cancelled without being interrupted., +    ListenableFuture<List<String>> otherCompound =, +        Futures.allAsList(future1, future2);, +, +    assertTrue(compound.cancel(true));, +    assertTrue(future1.isCancelled());, +    assertTrue(future1.wasInterrupted());, +    assertTrue(future2.isCancelled());, +    assertTrue(future2.wasInterrupted());, +    assertTrue(otherCompound.isCancelled());, +  }, +, +  public void testAllAsList_resultCancelled_withSecondaryListFuture(), +      throws Exception {, +    SettableFuture<String> future1 = SettableFuture.create();, +    SettableFuture<String> future2 = SettableFuture.create();, +    ListenableFuture<List<String>> compound =, +        Futures.allAsList(future1, future2);, +    ListenableFuture<List<String>> otherCompound =, +        Futures.allAsList(future1, future2);, +, +    assertTrue(compound.cancel(false));, +    assertTrue(future1.isCancelled());, +    assertFalse(future1.wasInterrupted());, +    assertTrue(future2.isCancelled());, +    assertFalse(future2.wasInterrupted());, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture(), +      throws Exception {, +    SettableFuture<String> future1 = SettableFuture.create();, +    SettableFuture<String> future2 = SettableFuture.create();, +    ListenableFuture<List<String>> compound =, +        Futures.allAsList(future1, future2);, +    // There was a bug where the event listener for the combined future would, +    // result in the sub-futures being cancelled without being interrupted., +    ListenableFuture<List<String>> otherCompound =, +        Futures.allAsList(future1, future2);, +, +    assertTrue(compound.cancel(true));, +    assertTrue(future1.isCancelled());, +    assertTrue(future1.wasInterrupted());, +    assertTrue(future2.isCancelled());, +    assertTrue(future2.wasInterrupted());, +    assertTrue(otherCompound.isCancelled());, +  }, +, +  public void testAllAsList_resultCancelled_withSecondaryListFuture(), +      throws Exception {, +    SettableFuture<String> future1 = SettableFuture.create();, +    SettableFuture<String> future2 = SettableFuture.create();, +    ListenableFuture<List<String>> compound =, +        Futures.allAsList(future1, future2);, +    ListenableFuture<List<String>> otherCompound =, +        Futures.allAsList(future1, future2);, +, +    assertTrue(compound.cancel(false));, +    assertTrue(future1.isCancelled());, +    assertFalse(future1.wasInterrupted());, +    assertTrue(future2.isCancelled());, +    assertFalse(future2.wasInterrupted());, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +    @Override, +    public boolean cancel(boolean mayInterruptIfRunning) {, +      // Cancel all the component futures., +      ImmutableCollection<? extends ListenableFuture<?>> futuresToCancel = futures;, +      boolean cancelled = super.cancel(mayInterruptIfRunning);, +      if (cancelled) {, +        for (ListenableFuture<?> future : futuresToCancel) {, +          future.cancel(mayInterruptIfRunning);, +        }, +      }, +      return cancelled;, +    }, +, +        if (future.isCancelled()) {, +          if (allMustSucceed) {, +            // this.cancel propagates the cancellation to children; we use super.cancel, +            // to set our own state but let the input futures keep running, +            // as some of them may be used elsewhere., +            super.cancel(false);, +          }, +        } else {]