[+++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Stopwatch.java, +        return "\u03bcs"; // μs, +++ b/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Stopwatch.java, +        return "\u03bcs"; // μs, +++ b/guava/src/com/google/common/cache/CustomConcurrentHashMap.java, +     * existing value. It is assumed that the return value of this method is constant for any given, +     * ValueReference instance., +    V getOrLoad(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionException {, +          ReferenceEntry<K, V> e = getEntry(key, hash);, +            ValueReference<K, V> valueReference = e.getValueReference();, +            if (valueReference.isLoading()) {, +              return waitForLoadingValue(e, valueReference);, +            }, +        // at this point e is either null or expired;, +        return lockedGetOrLoad(key, hash, loader);, +      } finally {, +        postReadCleanup();, +      }, +    }, +, +    V lockedGetOrLoad(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionException {, +      ReferenceEntry<K, V> e;, +      ValueReference<K, V> valueReference = null;, +      boolean createNewEntry = true;, +, +            valueReference = e.getValueReference();, +      } else {, +        // The entry already exists. Wait for loading., +        return waitForLoadingValue(e, valueReference);, +    V waitForLoadingValue(ReferenceEntry<K, V> e, ValueReference<K, V> valueReference), +        throws ExecutionException {, +      if (!valueReference.isLoading()) {, +        throw new AssertionError();, +      }, +, +        V value = valueReference.waitForValue();]