[+++ b/guava/src/com/google/common/primitives/UnsignedBytes.java, +              return UnsignedLongs.compare(lw, rw);, +, +++ b/guava/src/com/google/common/primitives/UnsignedBytes.java, +              return UnsignedLongs.compare(lw, rw);, +, +++ b/guava/src/com/google/common/primitives/UnsignedLongs.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.primitives;, +, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import java.math.BigInteger;, +import java.util.Arrays;, +import java.util.Comparator;, +, +/**, + * Static utility methods pertaining to {@code long} primitives that interpret values as, + * <i>unsigned</i> (that is, any negative value {@code x} is treated as the positive value, + * {@code 2^64 + x}). The methods for which signedness is not an issue are in {@link Longs}, as well, + * as signed versions of methods for which signedness is an issue., + *, + * <p>In addition, this class provides several static methods for converting a {@code long} to a, + * {@code String} and a {@code String} to a {@code long} that treat the long as an unsigned number., + *, + * @author Brian Milch, + * @author Peter Epstein, + * @author Louis Wasserman, + */, +public final class UnsignedLongs {, +  // TODO(user): verify GWT compatibility, +  private UnsignedLongs() {}, +, +  public static final long MAX_VALUE = -1L; // Equivalent to 0xffffffffffffffffL, +, +  public static BigInteger toBigInteger(long unsigned) {, +    BigInteger result = BigInteger.valueOf(unsigned & Long.MAX_VALUE);, +    if (unsigned < 0) {, +      result = result.setBit(63);, +    }, +    return result;, +  }, +, +  /**, +   * Returns the {@code long} value that, when treated as unsigned, is equal to {@code value}, if, +   * possible., +   *, +   * @param value a value between 0 inclusive and 2^64 exclusive, +   * @return the {@code long} value that, when treated as unsigned, equals {@code value}, +   * @throws IllegalArgumentException if {@code value} is negative or greater than or equal to 2^64, +   */, +  public static long checkedCast(BigInteger value) {, +    checkNotNull(value);, +    checkArgument(value.signum() >= 0 && value.bitLength() <= 64, "out of range: %s", value);, +    return value.longValue();, +  }, +, +  /**, +   * Returns the {@code long} value that, when treated as unsigned, is nearest in value to, +   * {@code value}., +   *, +   * @param value any {@code BigInteger} value, +   * @return {@link #MAX_VALUE} if {@code value >= 2^64}, {@code 0} if {@code value <= 0}, and, +   *         {@code value.longValue()} otherwise, +   */, +  public static long saturatedCast(BigInteger value) {, +    checkNotNull(value);, +    if (value.signum() < 0) {, +      return 0;, +    } else if (value.bitLength() > 64) {, +      return MAX_VALUE;, +    } else {, +      return value.longValue();, +    }, +  }, +, +  /**, +   * Compares the two specified {@code long} values, treating them as unsigned values between, +   * {@code 0} and {@code 2^64 - 1} inclusive., +   *, +   * @param a the first unsigned {@code long} to compare, +   * @param b the second unsigned {@code long} to compare, +   * @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is, +   *         greater than {@code b}; or zero if they are equal]