[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    @Override public final boolean cancel(boolean mayInterruptIfRunning) {, +      return super.cancel(mayInterruptIfRunning);, +    }, +    // Most other methods are already final in AbstractFuture itself under GWT., +      // TODO(lukes): consider adding the StackOverflowError protection from the server version, +    afterDone();, +    // TODO(lukes): consider adding the StackOverflowError protection from the server version, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    @Override public final boolean cancel(boolean mayInterruptIfRunning) {, +      return super.cancel(mayInterruptIfRunning);, +    }, +    // Most other methods are already final in AbstractFuture itself under GWT., +      // TODO(lukes): consider adding the StackOverflowError protection from the server version, +    afterDone();, +    // TODO(lukes): consider adding the StackOverflowError protection from the server version, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +    final int size = 50;, +        + size // for the listeners, +        + size // for the get threads,, +    Runnable cancelRunnable = new Runnable() {, +      @Override public void run() {, +    Runnable setFutureCompleteSucessFullyRunnable = new Runnable() {, +      @Override public void run() {, +    List<Runnable> allTasks = new ArrayList<Runnable>();, +    for (int k = 0; k < size; k++) {, +      allTasks.add(listener);, +      allTasks.add(new Runnable() {, +        @Override public void run() {, +      for (Runnable task : allTasks) {, +        executor.execute(task);, +  // In a previous implementation this would cause a stack overflow after ~2000 futures chained, +  // together.  Now it should only be limited by available memory (and time), +  public void testSetFuture_stackOverflow() {, +    SettableFuture<String> orig = SettableFuture.create();, +    SettableFuture<String> prev = orig;, +    for (int i = 0; i < 100000; i++) {, +      SettableFuture<String> curr = SettableFuture.create();, +      prev.setFuture(curr);, +      prev = curr;, +    }, +    // prev represents the 'innermost' future, +    prev.set("done");, +    assertTrue(orig.isDone());, +  }, +, +  public void testCancel_stackOverflow() {, +    SettableFuture<String> orig = SettableFuture.create();, +    SettableFuture<String> prev = orig;, +    for (int i = 0; i < 100000; i++) {, +      SettableFuture<String> curr = SettableFuture.create();, +      prev.setFuture(curr);, +      prev = curr;, +    }, +    // orig is the 'outermost future', this should propagate fully down the stack of futures., +    orig.cancel(true);, +    assertTrue(orig.isCancelled());, +    assertTrue(prev.isCancelled());, +    assertTrue(prev.wasInterrupted());, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    @Override public final boolean cancel(boolean mayInterruptIfRunning) {, +      return super.cancel(mayInterruptIfRunning);, +    }, +    // Most other methods are already final in AbstractFuture itself under GWT., +      // TODO(lukes): consider adding the StackOverflowError protection from the server version, +    afterDone();, +    // TODO(lukes): consider adding the StackOverflowError protection from the server version, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +    final int size = 50;, +        + size // for the listeners, +        + size // for the get threads,, +    Runnable cancelRunnable = new Runnable() {, +      @Override public void run() {, +    Runnable setFutureCompleteSucessFullyRunnable = new Runnable() {, +      @Override public void run() {, +    List<Runnable> allTasks = new ArrayList<Runnable>();, +    for (int k = 0; k < size; k++) {, +      allTasks.add(listener);, +      allTasks.add(new Runnable() {, +        @Override public void run() {, +      for (Runnable task : allTasks) {, +        executor.execute(task);, +  // In a previous implementation this would cause a stack overflow after ~2000 futures chained, +  // together.  Now it should only be limited by available memory (and time), +  public void testSetFuture_stackOverflow() {, +    SettableFuture<String> orig = SettableFuture.create();, +    SettableFuture<String> prev = orig;, +    for (int i = 0; i < 100000; i++) {, +      SettableFuture<String> curr = SettableFuture.create();, +      prev.setFuture(curr);, +      prev = curr;, +    }, +    // prev represents the 'innermost' future, +    prev.set("done");, +    assertTrue(orig.isDone());, +  }, +, +  public void testCancel_stackOverflow() {]