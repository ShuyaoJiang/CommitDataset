[+++ b/guava-tests/test/com/google/common/util/concurrent/RateLimiterTest.java, +  public void testSimpleAcquireEarliestAvailableIsInPast() {, +    RateLimiter limiter = RateLimiter.create(stopwatch, 5.0);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    stopwatch.sleepMillis(400);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    assertEquals(0.2, limiter.acquire(), EPSILON);, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/RateLimiterTest.java, +  public void testSimpleAcquireEarliestAvailableIsInPast() {, +    RateLimiter limiter = RateLimiter.create(stopwatch, 5.0);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    stopwatch.sleepMillis(400);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    assertEquals(0.0, limiter.acquire(), EPSILON);, +    assertEquals(0.2, limiter.acquire(), EPSILON);, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +   * @return time in microseconds to wait until the resource can be acquired, never negative, +      return reserveAndGetWaitLength(permits, stopwatch.readMicros());, +        microsToWait = reserveAndGetWaitLength(permits, nowMicros);, +    return queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;, +  /**, +   * Reserves next ticket and returns the wait time that the caller must wait for., +   *, +   * @return the required wait time, never negative, +   */, +  final long reserveAndGetWaitLength(int permits, long nowMicros) {, +    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);, +    return max(momentAvailable - nowMicros, 0);, +  }, +  /**, +   * Returns the earliest time that permits are available (with one caveat)., +   *, +   * @return the time that permits are available, or, if permits are available immediately, an, +   *     arbitrary past or present time, +   */, +  abstract long queryEarliestAvailable(long nowMicros);, +, +  /**, +   * Reserves the requested number of permits and returns the time that those permits can be used, +   * (with one caveat)., +   *, +   * @return the time that the permits may be used, or, if the permits may be used immediately, an, +   *     arbitrary past or present time, +   */, +  abstract long reserveEarliestAvailable(int permits, long nowMicros);, +    final long queryEarliestAvailable(long nowMicros) {, +    final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {, +      long returnValue = nextFreeTicketMicros;, +      return returnValue;, +     * to guarantee that each call to reserveEarliestAvailable, etc. sees a value >= the previous?, +     * Also, is it OK that we don't hold the mutex when sleeping?]