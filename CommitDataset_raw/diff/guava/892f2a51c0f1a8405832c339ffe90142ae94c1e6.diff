[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * type is returned by {@link MapMaker#removalListener} to prevent the user from trying to build a, +, +   * Note that MapMaker's removalListener() is not here, because once you're interacting with a, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * type is returned by {@link MapMaker#removalListener} to prevent the user from trying to build a, +, +   * Note that MapMaker's removalListener() is not here, because once you're interacting with a, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import com.google.common.collect.MapMaker.RemovalListener;, +import com.google.common.collect.MapMaker.RemovalListener.RemovalCause;, +                    removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +  private static final long serialVersionUID = 3;, +        concurrencyLevel, removalListener, this, computingFunction);, +        int concurrencyLevel, RemovalListener<? super K, ? super V> removalListener,, +          expireAfterAccessNanos, maximumSize, concurrencyLevel, removalListener, delegate);, +    private static final long serialVersionUID = 3;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java, + * type is returned by {@link MapMaker#removalListener} to prevent the user from trying to build a, +, +   * Note that MapMaker's removalListener() is not here, because once you're interacting with a, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import com.google.common.collect.MapMaker.RemovalListener;, +import com.google.common.collect.MapMaker.RemovalListener.RemovalCause;, +                    removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +  private static final long serialVersionUID = 3;, +        concurrencyLevel, removalListener, this, computingFunction);, +        int concurrencyLevel, RemovalListener<? super K, ? super V> removalListener,, +          expireAfterAccessNanos, maximumSize, concurrencyLevel, removalListener, delegate);, +    private static final long serialVersionUID = 3;, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +import com.google.common.collect.GenericMapMaker.NullListener;, +import com.google.common.collect.MapMaker.RemovalListener;, +import com.google.common.collect.MapMaker.RemovalListener.RemovalCause;, +  /** Entries waiting to be consumed by the removal listener. */, +  // TODO(user): define a new type which creates event objects and automates the clear logic, +  final Queue<RemovalNotification<K, V>> removalNotificationQueue;, +  final RemovalListener<? super K, ? super V> removalListener;, +    removalListener = builder.getRemovalListener();, +    removalNotificationQueue = (removalListener == NullListener.INSTANCE), +        ? CustomConcurrentHashMap.<RemovalNotification<K, V>>discardingQueue(), +        : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();, +  @VisibleForTesting, +  static class RemovalNotification<K, V> {, +    @Nullable, +    @VisibleForTesting, +    final K key;, +, +    @Nullable, +    @VisibleForTesting, +    final V value;, +, +    @VisibleForTesting, +    final RemovalCause cause;, +, +    public RemovalNotification(K key, V value, RemovalCause cause) {, +      this.key = key;, +      this.value = value;, +      this.cause = cause;, +    }, +, +    public void notify(RemovalListener<? super K, ? super V> listener) {, +      listener.onRemoval(key, value, cause);, +    }, +  }, +, +  static final Queue<? extends Object> DISCARDING_QUEUE = new AbstractQueue<Object>() {, +    public boolean offer(Object o) {, +    public Object peek() {, +    public Object poll() {, +    public Iterator<Object> iterator() {, +    return (Queue) DISCARDING_QUEUE;, +  void enqueueNotification(K key, int hash, ValueReference<K, V> valueReference,, +      RemovalCause cause) {, +    if (removalNotificationQueue == DISCARDING_QUEUE) {, +    RemovalNotification<K, V> notification =, +        new RemovalNotification<K, V>(key, valueReference.get(), cause);, +    removalNotificationQueue.offer(notification);, +    RemovalNotification<K, V> notification;, +    while ((notification = removalNotificationQueue.poll()) != null) {, +      notification.notify(removalListener);, +        if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {, +        if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) {, +              map.enqueueNotification(key, hash, valueReference, RemovalCause.REPLACED);, +                removeLiveEntry(e, e.getHash(), RemovalCause.COLLECTED);, +              removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +              removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +              removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +              ValueReference<K, V> valueReference = e.getValueReference();, +              map.enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPLICIT);, +            return null;, +          }, +              removeLiveEntry(e, hash, RemovalCause.COLLECTED);, +              ValueReference<K, V> valueReference = e.getValueReference();, +              map.enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPLICIT);, +          if (map.removalNotificationQueue != DISCARDING_QUEUE) {, +            for (int i = 0; i < table.length(); ++i) {, +              for (ReferenceEntry<K, V> e = table.get(i); e != null; e = e.getNext()) {, +                map.enqueueNotification(, +                    e.getKey(), e.getHash(), e.getValueReference(), RemovalCause.EXPLICIT);]