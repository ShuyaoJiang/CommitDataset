[+++ b/guava-tests/test/com/google/common/reflect/ClassPathTest.java, +import com.google.common.io.Closeables;, +import com.google.common.io.Resources;, +import java.io.FileOutputStream;, +import java.util.jar.Attributes;, +import java.util.jar.JarOutputStream;, +import java.util.zip.ZipEntry;, +  public void testScan_classPathCycle() throws IOException {, +    File jarFile = File.createTempFile("with_circular_class_path", ".jar");, +    try {, +      writeSelfReferencingJarFile(jarFile, "test.txt");, +      ClassPath.Scanner scanner = new ClassPath.Scanner();, +      scanner.scan(jarFile.toURI(), ClassPathTest.class.getClassLoader());, +      assertEquals(1, scanner.getResources().size());, +    } finally {, +      jarFile.delete();, +    }, +  public void testScanFromFile_fileNotExists() throws IOException {, +    ClassPath.Scanner scanner = new ClassPath.Scanner();, +    scanner.scanFrom(new File("no/such/file/anywhere"), classLoader);, +    ASSERT.that(scanner.getResources()).isEmpty();, +  }, +, +  public void testScanFromFile_notJarFile() throws IOException {, +    ClassLoader classLoader = ClassPathTest.class.getClassLoader();, +    ClassPath.Scanner scanner = new ClassPath.Scanner();, +      scanner.scanFrom(notJar, classLoader);, +    ASSERT.that(scanner.getResources()).isEmpty();, +        ClassPath.Scanner.getClassPathEntry(, +            new File("/home/build/outer.jar"), "file:/usr/test/dep.jar"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "a.jar"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "x/y/z"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "x/y/z.jar"));, +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(new File("some.jar"), null)).isEmpty();, +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest(""))), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifestClasspath(""))), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest)), +  private static void writeSelfReferencingJarFile(File jarFile, String... entries), +      throws IOException {, +    Manifest manifest = new Manifest();, +    // Without version, the manifest is silently ignored. Ugh!, +    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");, +    manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH, jarFile.getName());, +    JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(jarFile), manifest);, +    try {, +      for (String entry : entries) {, +        jarOut.putNextEntry(new ZipEntry(entry));, +        Resources.copy(ClassPathTest.class.getResource(entry), jarOut);, +        jarOut.closeEntry();, +      }, +    } finally {, +      Closeables.closeQuietly(jarOut);, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/reflect/ClassPathTest.java, +import com.google.common.io.Closeables;, +import com.google.common.io.Resources;, +import java.io.FileOutputStream;, +import java.util.jar.Attributes;, +import java.util.jar.JarOutputStream;, +import java.util.zip.ZipEntry;, +  public void testScan_classPathCycle() throws IOException {, +    File jarFile = File.createTempFile("with_circular_class_path", ".jar");, +    try {, +      writeSelfReferencingJarFile(jarFile, "test.txt");, +      ClassPath.Scanner scanner = new ClassPath.Scanner();, +      scanner.scan(jarFile.toURI(), ClassPathTest.class.getClassLoader());, +      assertEquals(1, scanner.getResources().size());, +    } finally {, +      jarFile.delete();, +    }, +  public void testScanFromFile_fileNotExists() throws IOException {, +    ClassPath.Scanner scanner = new ClassPath.Scanner();, +    scanner.scanFrom(new File("no/such/file/anywhere"), classLoader);, +    ASSERT.that(scanner.getResources()).isEmpty();, +  }, +, +  public void testScanFromFile_notJarFile() throws IOException {, +    ClassLoader classLoader = ClassPathTest.class.getClassLoader();, +    ClassPath.Scanner scanner = new ClassPath.Scanner();, +      scanner.scanFrom(notJar, classLoader);, +    ASSERT.that(scanner.getResources()).isEmpty();, +        ClassPath.Scanner.getClassPathEntry(, +            new File("/home/build/outer.jar"), "file:/usr/test/dep.jar"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "a.jar"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "x/y/z"));, +        ClassPath.Scanner.getClassPathEntry(new File("/home/build/outer.jar"), "x/y/z.jar"));, +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(new File("some.jar"), null)).isEmpty();, +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest(""))), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifestClasspath(""))), +    ASSERT.that(ClassPath.Scanner.getClassPathFromManifest(jarFile, manifest))]