[+++ b/guava-tests/test/com/google/common/hash/AbstractByteHasherTest.java, +      return HashCode.fromBytesNoCopy(bytes());, +++ b/guava-tests/test/com/google/common/hash/AbstractByteHasherTest.java, +      return HashCode.fromBytesNoCopy(bytes());, +++ b/guava-tests/test/com/google/common/hash/AbstractNonStreamingHashFunctionTest.java, +          return HashCode.fromBytes(out.toByteArray());, +      return HashCode.fromBytes(input);, +      return HashCode.fromBytes(Arrays.copyOfRange(input, off, off + len));, +++ b/guava-tests/test/com/google/common/hash/AbstractByteHasherTest.java, +      return HashCode.fromBytesNoCopy(bytes());, +++ b/guava-tests/test/com/google/common/hash/AbstractNonStreamingHashFunctionTest.java, +          return HashCode.fromBytes(out.toByteArray());, +      return HashCode.fromBytes(input);, +      return HashCode.fromBytes(Arrays.copyOfRange(input, off, off + len));, +++ b/guava-tests/test/com/google/common/hash/AbstractStreamingHasherTest.java, +      return HashCode.fromBytes(out.toByteArray());, +      return HashCode.fromBytes(input);, +++ b/guava-tests/test/com/google/common/hash/AbstractByteHasherTest.java, +      return HashCode.fromBytesNoCopy(bytes());, +++ b/guava-tests/test/com/google/common/hash/AbstractNonStreamingHashFunctionTest.java, +          return HashCode.fromBytes(out.toByteArray());, +      return HashCode.fromBytes(input);, +      return HashCode.fromBytes(Arrays.copyOfRange(input, off, off + len));, +++ b/guava-tests/test/com/google/common/hash/AbstractStreamingHasherTest.java, +      return HashCode.fromBytes(out.toByteArray());, +      return HashCode.fromBytes(input);, +++ b/guava-tests/test/com/google/common/hash/HashCodeTest.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.hash;, +, +import static com.google.common.io.BaseEncoding.base16;, +, +import com.google.common.collect.ImmutableList;, +import com.google.common.io.BaseEncoding;, +import com.google.common.testing.ClassSanityTester;, +, +import junit.framework.TestCase;, +, +import java.util.Arrays;, +, +/**, + * Unit tests for {@link HashCode}., + *, + * @author Dimitris Andreou, + * @author Kurt Alfred Kluever, + */, +public class HashCodeTest extends TestCase {, +  // note: asInt(), asLong() are in little endian, +  private static final ImmutableList<ExpectedHashCode> expectedHashCodes = ImmutableList.of(, +      new ExpectedHashCode(new byte[] {, +        (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,, +        (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01},, +        0x89abcdef, 0x0123456789abcdefL, "efcdab8967452301"),, +, +      new ExpectedHashCode(new byte[] {, +        (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,, +        (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01, // up to here, same bytes as above, +        (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,, +        (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08},, +        0x89abcdef, 0x0123456789abcdefL, // asInt/asLong as above, due to equal eight first bytes, +        "efcdab89674523010102030405060708"),, +, +      new ExpectedHashCode(new byte[] { (byte) 0xdf, (byte) 0x9b, (byte) 0x57, (byte) 0x13 },, +        0x13579bdf, null, "df9b5713"),, +, +      new ExpectedHashCode(new byte[] {, +          (byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00},, +          0x0000abcd, null, "cdab0000"),, +, +      new ExpectedHashCode(new byte[] {, +          (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x00,, +          (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00},, +          0x00abcdef, 0x0000000000abcdefL, "efcdab0000000000"), +    );, +, +  // expectedHashCodes must contain at least one hash code with 4 bytes, +  public void testFromInt() {, +    for (ExpectedHashCode expected : expectedHashCodes) {, +      if (expected.bytes.length == 4) {, +        HashCode fromInt = HashCode.fromInt(expected.asInt);, +        assertExpectedHashCode(expected, fromInt);, +      }, +    }, +  }, +]