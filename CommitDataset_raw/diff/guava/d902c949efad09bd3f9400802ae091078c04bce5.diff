[+++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +import com.google.common.reflect.AbstractInvocationHandler;, +import com.google.common.reflect.TypeToken;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Proxy;, +import java.lang.reflect.Type;, +import java.util.Set;, +        @Override public Type[] getParameterTypes() {, +          return method.getGenericParameterTypes();, +        @Override public void invoke(Object object, Object[] params), +          method.invoke(object, params);, +        @Override public Type[] getParameterTypes() {, +          return ctor.getGenericParameterTypes();, +    if (TypeToken.of(func.getParameterTypes()[paramIndex]).getRawType(), +        .isPrimitive()) {, +    Type[] types = func.getParameterTypes();, +        TypeToken<?> type = TypeToken.of(types[i]);, +          Assert.assertTrue("No default value found for " + type,, +  private <T> T getDefaultValue(TypeToken<T> type) {, +    // We assume that all defaults are generics-safe, even if they aren't,, +    // we take the risk., +    @SuppressWarnings("unchecked"), +    T defaultValue = (T) defaults.getInstance(type.getRawType());, +    if (defaultValue != null) {, +      return defaultValue;, +    @SuppressWarnings("unchecked") // All null values are generics-safe, +    T nullValue = (T) NullValues.get(type.getRawType());, +    if (nullValue != null) {, +      return nullValue;, +    }, +    if (type.getRawType() == Class.class) {, +      // If parameter is Class<? extends Foo>, we return Foo.class, +      @SuppressWarnings("unchecked"), +      T defaultClass = (T) getFirstTypeParameter(type.getType()).getRawType();, +      return defaultClass;, +    }, +    if (type.getRawType() == TypeToken.class) {, +      // If parameter is TypeToken<? extends Foo>, we return TypeToken<Foo>., +      @SuppressWarnings("unchecked"), +      T defaultType = (T) getFirstTypeParameter(type.getType());, +      return defaultType;, +    }, +    if (type.getRawType().isInterface()) {, +      return newDefaultReturningProxy(type);, +    }, +    return null;, +  }, +, +  private static TypeToken<?> getFirstTypeParameter(Type type) {, +    if (type instanceof ParameterizedType) {, +      return TypeToken.of(, +          ((ParameterizedType) type).getActualTypeArguments()[0]);, +    } else {, +      return TypeToken.of(Object.class);, +    }, +  }, +, +  @SuppressWarnings("unchecked") // T implemented with dynamic proxy., +  private <T> T newDefaultReturningProxy(final TypeToken<T> type) {, +    Set<Class<? super T>> interfaceClasses =, +        type.getTypes().interfaces().rawTypes();, +    return (T) Proxy.newProxyInstance(, +        interfaceClasses.iterator().next().getClassLoader(),, +        interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]),, +        new AbstractInvocationHandler() {, +          @Override protected Object handleInvocation(, +              Object proxy, Method method, Object[] args) {, +            return getDefaultValue(, +                type.resolveType(method.getGenericReturnType()));, +          }, +          @Override public String toString() {, +            return "NullPointerTester proxy for " + type;, +          }, +        });, +    Type[] getParameterTypes();, +++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +import com.google.common.reflect.AbstractInvocationHandler;, +import com.google.common.reflect.TypeToken;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Proxy;, +import java.lang.reflect.Type;, +import java.util.Set;, +        @Override public Type[] getParameterTypes() {, +          return method.getGenericParameterTypes();, +        @Override public void invoke(Object object, Object[] params), +          method.invoke(object, params);, +        @Override public Type[] getParameterTypes() {, +          return ctor.getGenericParameterTypes();, +    if (TypeToken.of(func.getParameterTypes()[paramIndex]).getRawType(), +        .isPrimitive()) {, +    Type[] types = func.getParameterTypes();, +        TypeToken<?> type = TypeToken.of(types[i]);, +          Assert.assertTrue("No default value found for " + type,, +  private <T> T getDefaultValue(TypeToken<T> type) {, +    // We assume that all defaults are generics-safe, even if they aren't,, +    // we take the risk., +    @SuppressWarnings("unchecked"), +    T defaultValue = (T) defaults.getInstance(type.getRawType());, +    if (defaultValue != null) {, +      return defaultValue;]