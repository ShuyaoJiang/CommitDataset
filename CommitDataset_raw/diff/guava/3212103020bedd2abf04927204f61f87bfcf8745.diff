[+++ b/guava/src/com/google/common/reflect/TypeResolver.java, +import com.google.common.annotations.Beta;, + * @since 15.0, +@Beta, +public final class TypeResolver {, +  private final TypeTable typeTable;, +    this.typeTable = new TypeTable();, +  private TypeResolver(TypeTable typeTable) {, +  public TypeResolver where(Type formal, Type actual) {, +  TypeResolver where(Map<? extends TypeVariable<?>, ? extends Type> mappings) {, +    return new TypeResolver(typeTable.where(mappings));, +  public Type resolveType(Type type) {, +    TypeResolver guarded = new TypeResolver(new TypeTable(typeTable) {, +      @Override public Type resolveTypeVariable(, +        return typeTable.resolveTypeVariable(intermediateVar, guardedResolver);, +    });, +    return typeTable.resolveTypeVariable(var, guarded);, +  private static class TypeTable {, +    private final ImmutableMap<TypeVariable<?>, Type> map;, +    , +    TypeTable(ImmutableMap<TypeVariable<?>, Type> map) {, +      this.map = map;, +    }, +  , +    TypeTable() {, +      this.map = ImmutableMap.of();, +    }, +  , +    TypeTable(TypeTable copy) {, +      this.map = copy.map;, +    }, +, +    /** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */, +    final TypeTable where(Map<? extends TypeVariable<?>, ? extends Type> mappings) {, +      ImmutableMap.Builder<TypeVariable<?>, Type> builder = ImmutableMap.builder();, +      builder.putAll(map);, +      for (Map.Entry<? extends TypeVariable<?>, ? extends Type> mapping : mappings.entrySet()) {, +        TypeVariable<?> variable = mapping.getKey();, +        Type type = mapping.getValue();, +        checkArgument(!variable.equals(type), "Type variable %s bound to itself", variable);, +        builder.put(variable, type);, +      }, +      return new TypeTable(builder.build());, +    }, +, +    /**, +     * Resolves {@code var} using the encapsulated type mapping. If it maps to yet another, +     * non-reified type, {@code guardedResolver} is used to do further resolution, which doesn't, +     * try to resolve any type variable on generic declarations that are already being resolved., +     */, +    Type resolveTypeVariable(TypeVariable<?> var, TypeResolver guardedResolver) {, +        checkNotNull(guardedResolver);, +        Type type = map.get(var);, +        if (type == null) {, +          Type[] bounds = var.getBounds();, +          if (bounds.length == 0) {, +            return var;, +          }, +          return Types.newTypeVariable(, +              var.getGenericDeclaration(),, +              var.getName(),, +              guardedResolver.resolveTypes(bounds));, +        }, +        // in case the type is yet another type variable., +        return guardedResolver.resolveType(type);, +    }, +  }, +]