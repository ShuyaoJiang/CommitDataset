[+++ b/guava-tests/test/com/google/common/util/concurrent/CycleDetectingLockFactoryTest.java, +// Copyright 2011 Google Inc. All Rights Reserved., +package com.google.common.util.concurrent;, +, +import static com.google.testing.util.MoreAsserts.assertContainsRegex;, +, +import com.google.common.base.Joiner;, +import com.google.common.util.concurrent.CycleDetectingLockFactory.Policy;, +import com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException;, +, +import junit.framework.TestCase;, +, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +, +/**, + * Unittests for {@link CycleDetectingLockFactory}., + *, + * @author Darick Tong (darick@google.com), + */, +public class CycleDetectingLockFactoryTest extends TestCase {, +, +  private ReentrantLock lockA;, +  private ReentrantLock lockB;, +  private ReentrantLock lockC;, +  private ReentrantReadWriteLock.ReadLock readLockA;, +  private ReentrantReadWriteLock.ReadLock readLockB;, +  private ReentrantReadWriteLock.ReadLock readLockC;, +  private ReentrantReadWriteLock.WriteLock writeLockA;, +  private ReentrantReadWriteLock.WriteLock writeLockB;, +  private ReentrantReadWriteLock.WriteLock writeLockC;, +, +  @Override, +  protected void setUp() throws Exception {, +    super.setUp();, +    CycleDetectingLockFactory factory =, +        CycleDetectingLockFactory.newInstance(Policy.THROW);, +    lockA = factory.newReentrantLock("LockA");, +    lockB = factory.newReentrantLock("LockB");, +    lockC = factory.newReentrantLock("LockC");, +    ReentrantReadWriteLock readWriteLockA =, +        factory.newReentrantReadWriteLock("ReadWriteA");, +    ReentrantReadWriteLock readWriteLockB =, +        factory.newReentrantReadWriteLock("ReadWriteB");, +    ReentrantReadWriteLock readWriteLockC =, +        factory.newReentrantReadWriteLock("ReadWriteC");, +    readLockA = readWriteLockA.readLock();, +    readLockB = readWriteLockB.readLock();, +    readLockC = readWriteLockC.readLock();, +    writeLockA = readWriteLockA.writeLock();, +    writeLockB = readWriteLockB.writeLock();, +    writeLockC = readWriteLockC.writeLock();, +  }, +, +  public void testDeadlock_twoLocks() {, +    // Establish an acquisition order of lockA -> lockB., +    lockA.lock();, +    lockB.lock();, +    lockA.unlock();, +    lockB.unlock();, +, +    // The opposite order should fail (Policy.THROW)., +    PotentialDeadlockException firstException = null;, +    lockB.lock();, +    try {, +      lockA.lock();, +      fail("Expected PotentialDeadlockException");, +    } catch (PotentialDeadlockException expected) {, +      checkMessage(expected, "LockB -> LockA", "LockA -> LockB");, +      firstException = expected;, +    }, +, +    // Second time should also fail, with a cached causal chain., +    try {, +      lockA.lock();, +      fail("Expected PotentialDeadlockException");, +    } catch (PotentialDeadlockException expected) {, +      checkMessage(expected, "LockB -> LockA", "LockA -> LockB");, +      // The causal chain should be cached., +      assertSame(firstException.getCause(), expected.getCause());, +    }, +, +    // lockA should work after lockB is released., +    lockB.unlock();, +    lockA.lock();, +  }, +, +  // Tests transitive deadlock detection., +  public void testDeadlock_threeLocks() {, +    // Establish an ordering from lockA -> lockB., +    lockA.lock();, +    lockB.lock();, +    lockB.unlock();, +    lockA.unlock();, +, +    // Establish an ordering from lockB -> lockC., +    lockB.lock();]