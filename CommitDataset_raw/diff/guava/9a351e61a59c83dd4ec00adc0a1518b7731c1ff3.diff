[+++ b/guava/src/com/google/common/util/concurrent/Futures.java, +   * Note: If the derived {@code Future} is slow or heavyweight to create, +   * (whether the {@code Future} itself is slow or heavyweight to complete is, +   * irrelevant), consider {@linkplain #transform(ListenableFuture,, +   * AsyncFunction, Executor) supplying an executor}. If you do not supply an, +   * executor, {@code transform} will use {@link, +   * MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries some, +   * caveats for heavier operations. For example, the call to {@code, +   * function.apply} may run on an unpredictable or undesirable thread:, +   *, +   * <ul>, +   * <li>If the input {@code Future} is done at the time {@code transform} is, +   * called, {@code transform} will call {@code function.apply} inline., +   * <li>If the input {@code Future} is not yet done, {@code transform} will, +   * schedule {@code function.apply} to be run by the thread that completes the, +   * input {@code Future}, which may be an internal system thread such as an, +   * RPC network thread., +   * </ul>, +   *, +   * Also note that, regardless of which thread executes {@code, +   * function.apply}, all other registered but unexecuted listeners are, +   * prevented from running during its execution, even if those listeners are, +   * to run in other executors., +   * <p>When the execution of {@code function.apply} is fast and lightweight, +   * (though the {@code Future} it returns need not meet these criteria),, +   * consider {@linkplain #transform(ListenableFuture, AsyncFunction) omitting, +   * the executor} or explicitly specifying {@code sameThreadExecutor}., +   * However, be aware of the caveats documented in the link above., +   * Note: If the transformation is slow or heavyweight, consider {@linkplain, +   * #transform(ListenableFuture, Function, Executor) supplying an executor}., +   * If you do not supply an executor, {@code transform} will use {@link, +   * MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries some, +   * caveats for heavier operations.  For example, the call to {@code, +   * function.apply} may run on an unpredictable or undesirable thread:, +   *, +   * <ul>, +   * <li>If the input {@code Future} is done at the time {@code transform} is, +   * called, {@code transform} will call {@code function.apply} inline., +   * <li>If the input {@code Future} is not yet done, {@code transform} will, +   * schedule {@code function.apply} to be run by the thread that completes the, +   * input {@code Future}, which may be an internal system thread such as an, +   * RPC network thread., +   * </ul>, +   *, +   * Also note that, regardless of which thread executes {@code, +   * function.apply}, all other registered but unexecuted listeners are, +   * prevented from running during its execution, even if those listeners are, +   * to run in other executors., +   * <p>When the transformation is fast and lightweight, consider {@linkplain, +   * #transform(ListenableFuture, Function) omitting the executor} or, +   * explicitly specifying {@code sameThreadExecutor}. However, be aware of the, +   * caveats documented in the link above., +   * @param nested The nested future to transform., +   * Note: If the callback is slow or heavyweight, consider {@linkplain, +   * #addCallback(ListenableFuture, FutureCallback, Executor) supplying an, +   * executor}. If you do not supply an executor, {@code addCallback} will use, +   * {@link MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries, +   * some caveats for heavier operations. For example, the callback may run on, +   * an unpredictable or undesirable thread:, +   *, +   * <ul>, +   * <li>If the input {@code Future} is done at the time {@code addCallback} is, +   * called, {@code addCallback} will execute the callback inline., +   * <li>If the input {@code Future} is not yet done, {@code addCallback} will, +   * schedule the callback to be run by the thread that completes the input, +   * {@code Future}, which may be an internal system thread such as an RPC, +   * network thread., +   * </ul>, +   *, +   * Also note that, regardless of which thread executes the callback, all, +   * other registered but unexecuted listeners are prevented from running, +   * during its execution, even if those listeners are to run in other, +   * executors., +   * When the callback is fast and lightweight, consider {@linkplain, +   * #addCallback(ListenableFuture, FutureCallback) omitting the executor} or, +   * explicitly specifying {@code sameThreadExecutor}. However, be aware of the, +   * caveats documented in the link above., +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +   * Note: If the derived {@code Future} is slow or heavyweight to create, +   * (whether the {@code Future} itself is slow or heavyweight to complete is, +   * irrelevant), consider {@linkplain #transform(ListenableFuture,, +   * AsyncFunction, Executor) supplying an executor}. If you do not supply an, +   * executor, {@code transform} will use {@link, +   * MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries some, +   * caveats for heavier operations. For example, the call to {@code, +   * function.apply} may run on an unpredictable or undesirable thread:, +   *, +   * <ul>, +   * <li>If the input {@code Future} is done at the time {@code transform} is, +   * called, {@code transform} will call {@code function.apply} inline., +   * <li>If the input {@code Future} is not yet done, {@code transform} will, +   * schedule {@code function.apply} to be run by the thread that completes the, +   * input {@code Future}, which may be an internal system thread such as an, +   * RPC network thread., +   * </ul>, +   *, +   * Also note that, regardless of which thread executes {@code, +   * function.apply}, all other registered but unexecuted listeners are, +   * prevented from running during its execution, even if those listeners are, +   * to run in other executors.]