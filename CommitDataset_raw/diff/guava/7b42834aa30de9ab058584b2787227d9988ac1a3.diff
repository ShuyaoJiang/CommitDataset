[+++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +    return segmentFor(hash).compute(key, hash);, +    V compute(K key, int hash) {, +                  if (!e.getValueReference().isComputingReference()) {, +                    // clobber invalid entries, +                    unsetLiveEntry(e, hash);, +              if (e == null || isUnset(e)) {, +                // Create a new entry., +                ComputingConcurrentHashMap<K, V> computingMap =, +                    (ComputingConcurrentHashMap<K, V>) map;, +                computingValueReference = new ComputingValueReference<K, V>(computingMap);, +                  e = computingMap.newEntry(key, hash, first);, +                // Synchronizes on the entry to allow failing fast when a, +                // recursive computation is detected. This is not fool-proof, +                // since the entry may be copied when the segment is written to., +    final ComputingConcurrentHashMap<K, V> map;, +    public ComputingValueReference(ComputingConcurrentHashMap<K, V> map) {, +      this.map = map;, +        value = map.computingFunction.apply(key);, +      if (value != null) {, +        // Call setValueReference first to avoid put clearing us., +        // TODO(user): recordMiss, +        // TODO(user): recordCompute, +        // putIfAbsent, +        map.segmentFor(hash).put(key, hash, value, true);, +      }, +, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +    return segmentFor(hash).compute(key, hash);, +    V compute(K key, int hash) {, +                  if (!e.getValueReference().isComputingReference()) {, +                    // clobber invalid entries, +                    unsetLiveEntry(e, hash);, +              if (e == null || isUnset(e)) {, +                // Create a new entry., +                ComputingConcurrentHashMap<K, V> computingMap =, +                    (ComputingConcurrentHashMap<K, V>) map;, +                computingValueReference = new ComputingValueReference<K, V>(computingMap);, +                  e = computingMap.newEntry(key, hash, first);, +                // Synchronizes on the entry to allow failing fast when a, +                // recursive computation is detected. This is not fool-proof, +                // since the entry may be copied when the segment is written to., +    final ComputingConcurrentHashMap<K, V> map;, +    public ComputingValueReference(ComputingConcurrentHashMap<K, V> map) {, +      this.map = map;, +        value = map.computingFunction.apply(key);, +      if (value != null) {, +        // Call setValueReference first to avoid put clearing us., +        // TODO(user): recordMiss, +        // TODO(user): recordCompute, +        // putIfAbsent, +        map.segmentFor(hash).put(key, hash, value, true);, +      }, +, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +    return cleanupExecutor == MapMaker.DEFAULT_CLEANUP_EXECUTOR;, +    Segment<K, V> segment = segmentFor(hash);, +    segment.unsetValue(entry.getKey(), hash, valueReference);, +    if (!segment.isHeldByCurrentThread()) { // don't cleanup inside of put, +      segment.postWriteCleanup();, +    }, +    segmentFor(hash).unsetKey(entry, hash);, +        if (!unsetEntry(e, e.getHash())) {, +        if (!unsetEntry(e, e.getHash())) {, +    boolean replace(K key, int hash, V oldValue, V newValue) {, +      checkNotNull(oldValue);, +      checkNotNull(newValue);, +      lock();, +      try {, +        preWriteCleanup();, +, +        for (ReferenceEntry<K, V> e = getFirst(hash); e != null; e = e.getNext()) {, +          K entryKey = e.getKey();, +          if (e.getHash() == hash && entryKey != null, +              && map.keyEquivalence.equivalent(key, entryKey)) {, +            // If the value disappeared, this entry is partially collected,, +            // and we should pretend like it doesn't exist., +            V entryValue = e.getValueReference().get();, +            if (entryValue == null) {, +              unsetLiveEntry(e, hash);, +              return false;, +            }, +, +            if (map.valueEquivalence.equivalent(oldValue, entryValue)) {, +              ++modCount;, +              setValue(e, newValue);, +              return true;, +            } else {, +              // Mimic, +              // "if (map.containsKey(key) && map.get(key).equals(oldValue))...", +              recordLockedRead(e);, +              return false;, +            }, +          }, +        }, +, +        return false;, +      } finally {, +        unlock();, +        postWriteCleanup();]