[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +        if (isCancelled()) {, +          return;, +        }, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +        if (isCancelled()) {, +          return;, +        }, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +import java.util.concurrent.atomic.AtomicBoolean;, +  @GwtIncompatible("threads"), +, +  public void testTransform_asyncFunction_cancelledBeforeApplyingFunction(), +      throws InterruptedException, ExecutionException {, +    final AtomicBoolean functionCalled = new AtomicBoolean();, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override, +      public ListenableFuture<Integer> apply(String input) throws Exception {, +        functionCalled.set(true);, +        return Futures.immediateFuture(1);, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ExecutorService executor = newSingleThreadExecutor();, +    ListenableFuture<Integer> future = Futures.transform(, +        inputFuture, function, executor);, +, +    // Pause the executor., +    final CountDownLatch beforeFunction = new CountDownLatch(1);, +    executor.submit(new Runnable() {, +      @Override, +      public void run() {, +        awaitUninterruptibly(beforeFunction);, +      }, +    });, +, +    // Cancel the future after making input available., +    inputFuture.set("value");, +    future.cancel(false);, +, +    // Unpause the executor., +    beforeFunction.countDown();, +    executor.awaitTermination(5, TimeUnit.SECONDS);, +, +    assertFalse(functionCalled.get());, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +        if (isCancelled()) {, +          return;, +        }, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +import java.util.concurrent.atomic.AtomicBoolean;, +  @GwtIncompatible("threads"), +, +  public void testTransform_asyncFunction_cancelledBeforeApplyingFunction(), +      throws InterruptedException, ExecutionException {, +    final AtomicBoolean functionCalled = new AtomicBoolean();, +    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {, +      @Override, +      public ListenableFuture<Integer> apply(String input) throws Exception {, +        functionCalled.set(true);, +        return Futures.immediateFuture(1);, +      }, +    };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ExecutorService executor = newSingleThreadExecutor();, +    ListenableFuture<Integer> future = Futures.transform(, +        inputFuture, function, executor);, +, +    // Pause the executor., +    final CountDownLatch beforeFunction = new CountDownLatch(1);, +    executor.submit(new Runnable() {, +      @Override, +      public void run() {, +        awaitUninterruptibly(beforeFunction);, +      }, +    });, +, +    // Cancel the future after making input available., +    inputFuture.set("value");, +    future.cancel(false);, +, +    // Unpause the executor., +    beforeFunction.countDown();, +    executor.awaitTermination(5, TimeUnit.SECONDS);, +, +    assertFalse(functionCalled.get());, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +        if (isCancelled()) {, +          return;, +        }]