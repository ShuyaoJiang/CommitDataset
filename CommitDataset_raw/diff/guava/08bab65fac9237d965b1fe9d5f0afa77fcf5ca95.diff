[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import com.google.common.util.concurrent.AbstractScheduledService.Scheduler;, +, +import junit.framework.TestCase;, +, +import java.util.concurrent.Callable;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.ScheduledThreadPoolExecutor;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +/**, + * Unit test for {@link AbstractScheduledService}., + *, + * @author Luke Sandberg, + */, +, +public class AbstractScheduledServiceTest extends TestCase {, +, +  volatile Scheduler configuration = Scheduler.newFixedDelaySchedule(0, 10, TimeUnit.MILLISECONDS);, +  volatile ScheduledFuture<?> future = null;, +, +  volatile boolean atFixedRateCalled = false;, +  volatile boolean withFixedDelayCalled = false;, +  volatile boolean scheduleCalled = false;, +, +  final ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(10) {, +    @Override, +    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,, +        long delay, TimeUnit unit) {, +      return future = super.scheduleWithFixedDelay(command, initialDelay, delay, unit);, +    }, +  };, +, +  public void testServiceStartStop() throws Exception {, +    NullService service = new NullService();, +    service.startAndWait();, +    assertFalse(future.isDone());, +    service.stopAndWait();, +    assertTrue(future.isCancelled());, +  }, +, +  private class NullService extends AbstractScheduledService {, +    @Override protected void runOneIteration() throws Exception { }, +    @Override protected void startUp() throws Exception { }, +    @Override protected void shutDown() throws Exception { }, +    @Override protected Scheduler scheduler() { return configuration; }, +    @Override protected ScheduledExecutorService executor() { return executor; }, +  }, +, +  public void testFailOnExceptionFromRun() throws Exception {, +    TestService service = new TestService();, +    service.runException = new Exception();, +    service.startAndWait();, +    service.runFirstBarrier.await();, +    service.runSecondBarrier.await();, +    try {, +      future.get();, +      fail();, +    } catch (ExecutionException e) {, +      // An execution exception holds a runtime exception (from throwables.propogate) that holds our, +      // original exception., +      assertEquals(service.runException, e.getCause().getCause());, +    }, +    assertEquals(service.state(), Service.State.FAILED);, +  }, +, +  public void testFailOnExceptionFromStartUp() {, +    TestService service = new TestService();, +    service.startUpException = new Exception();, +    try {, +      service.startAndWait();, +      fail();, +    } catch (UncheckedExecutionException e) {, +      assertEquals(service.startUpException, e.getCause());, +    }]