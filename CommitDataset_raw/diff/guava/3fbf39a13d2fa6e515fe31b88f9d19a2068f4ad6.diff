[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +import java.util.concurrent.atomic.AtomicInteger;, +   * The basic strategy is to subdivide the table among Segments, each of which, +   * itself is a concurrently readable hash table. The map supports, +   * non-blocking reads and concurrent writes across different segments., +   *, +   * If a maximum size is specified, a best-effort bounding is performed per, +   * segment, using a page-replacement algorithm to determine which entries to, +   * evict when the capacity has been exceeded., +   *, +   * The page replacement algorithm's data structures are kept casually, +   * consistent with the map. The ordering of writes to a segment is, +   * sequentially consistent. An update to the map and recording of reads may, +   * not be immediately reflected on the algorithm's data structures. These, +   * structures are guarded by a lock and operations are applied in batches to, +   * avoid lock contention. The penalty of applying the batches is spread across, +   * threads so that the amortized cost is slightly higher than performing just, +   * the operation without enforcing the capacity constraint., +   *, +   * This implementation uses a per-segment queue to record a memento of the, +   * additions, removals, and accesses that were performed on the map. The queue, +   * is drained on writes and when it exceeds its capacity threshold., +   *, +   * The Least Recently Used page replacement algorithm was chosen due to its, +   * simplicity, high hit rate, and ability to be implemented with O(1) time, +   * complexity. The initial LRU implementation operates per-segment rather, +   * than globally for increased implementation simplicity. We expect the cache, +   * hit rate to be similar to that of a global LRU algorithm., +  /**, +   * Number of cache access operations that can be buffered per segment before, +   * the cache's recency ordering information is updated. This is used to avoid, +   * lock contention by recording a memento of reads and delaying a lock, +   * acquisition until the threshold is crossed or a mutation occurs., +   */, +  static final int RECENCY_THRESHOLD = 64;, +, +      connectExpirables(originalExpirable.getPreviousExpirable(), newExpirable);, +      connectExpirables(newExpirable, originalExpirable.getNextExpirable());, +    @GuardedBy("Segment.this"), +, +      connectEvictables(originalEvictable.getPreviousEvictable(), newEvictable);, +      connectEvictables(newEvictable, originalEvictable.getNextEvictable());, +, +      nullifyEvictable(originalEvictable);, +  /**, +   * Implemented by entries that are evictable. Evictable entries are, +   * maintained in a doubly-linked list. New entries are added at the tail of, +   * the list at write time and stale entries are expired from the head of the, +   * list., +   */, +    /** Gets the next entry in the recency list. */, +    Evictable getNextEvictable();, +    /** Sets the next entry in the recency list. */, +    void setNextEvictable(Evictable next);, +, +    /** Gets the previous entry in the recency list. */, +    Evictable getPreviousEvictable();, +, +    /** Sets the previous entry in the recency list. */, +    void setPreviousEvictable(Evictable previous);, +    Expirable nextExpirable = NullExpirable.INSTANCE;, +      return nextExpirable;, +      this.nextExpirable = next;, +    Expirable previousExpirable = NullExpirable.INSTANCE;, +      return previousExpirable;, +      this.previousExpirable = previous;, +    @GuardedBy("Segment.this"), +    Evictable nextEvictable;, +    public Evictable getNextEvictable() {, +      return nextEvictable;, +    public void setNextEvictable(Evictable next) {, +      this.nextEvictable = next;, +    }, +, +    @GuardedBy("Segment.this"), +    Evictable previousEvictable;, +    public Evictable getPreviousEvictable() {, +      return previousEvictable;, +    }, +    public void setPreviousEvictable(Evictable previous) {, +      this.previousEvictable = previous;, +    Expirable nextExpirable = NullExpirable.INSTANCE;, +      return nextExpirable;, +      this.nextExpirable = next;, +    Expirable previousExpirable = NullExpirable.INSTANCE;, +      return previousExpirable;, +      this.previousExpirable = previous;, +    @GuardedBy("Segment.this"), +    Evictable nextEvictable;, +    public Evictable getNextEvictable() {, +      return nextEvictable;, +    public void setNextEvictable(Evictable next) {, +      this.nextEvictable = next;, +    }, +, +    @GuardedBy("Segment.this"), +    Evictable previousEvictable;, +    public Evictable getPreviousEvictable() {, +      return previousEvictable;, +    }]