[+++ b/src/com/google/common/collect/RegularImmutableMap.java, +import static com.google.common.base.Preconditions.checkArgument;, +, +import javax.annotation.Nullable;, +import javax.annotation.concurrent.Immutable;, +, + * @author Gregory Kick, +  // entries in insertion order, +  private final transient LinkedEntry<K, V>[] entries;, +  // array of linked lists of entries, +  private final transient LinkedEntry<K, V>[] table;, +  // 'and' with an int to get a table index, +  // TODO: investigate avoiding the creation of ImmutableEntries since we, +  // re-copy them anyway., +    int size = immutableEntries.length;, +    entries = createEntryArray(size);, +    // TODO: try smaller table sizes, +    int tableSize = Hashing.chooseTableSize(size);, +    table = createEntryArray(tableSize);, +    for (int entryIndex = 0; entryIndex < size; entryIndex++) {, +      // each of our 6 callers carefully put only Entry<K, V>s into the array!, +      @SuppressWarnings("unchecked"), +      Entry<K, V> entry = (Entry<K, V>) immutableEntries[entryIndex];, +      int tableIndex = Hashing.smear(keyHashCode) & mask;, +      @Nullable LinkedEntry<K, V> existing = table[tableIndex];, +      // prepend, not append, so the entries can be immutable, +      LinkedEntry<K, V> linkedEntry =, +          new LinkedEntry<K, V>(key, entry.getValue(), existing);, +      table[tableIndex] = linkedEntry;, +      entries[entryIndex] = linkedEntry;, +      while (existing != null) {, +        checkArgument(!key.equals(existing.getKey()), "duplicate key: %s", key);, +        existing = existing.next;, +  /**, +   * Creates a {@link LinkedEntry} array to hold parameterized entries. The, +   * result must never be upcast back to LinkedEntry[] (or Object[], etc.), or, +   * allowed to escape the class., +   */, +  @SuppressWarnings("unchecked") // Safe as long as the javadocs are followed, +  private LinkedEntry<K, V>[] createEntryArray(int size) {, +    return new LinkedEntry[size];, +  }, +, +  @Immutable, +  @SuppressWarnings("serial") // this class is never serialized, +  private static final class LinkedEntry<K, V> extends ImmutableEntry<K, V> {, +    @Nullable final LinkedEntry<K, V> next;, +, +    LinkedEntry(K key, V value, @Nullable LinkedEntry<K, V> next) {, +      super(key, value);, +      this.next = next;, +    }, +  }, +, +    int index = Hashing.smear(key.hashCode()) & mask;, +    for (LinkedEntry<K, V> entry = table[index];, +        entry != null;, +        entry = entry.next) {, +      K candidateKey = entry.getKey();, +      // assume that equals uses the == optimization when appropriate, +      if (key.equals(candidateKey)) {, +        return entry.getValue();, +      }, +    }]