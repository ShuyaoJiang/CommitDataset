[+++ b/guava-tests/test/com/google/common/hash/HashingTest.java, +import static com.google.testing.util.MoreAsserts.assertGreaterThan;, +import static com.google.testing.util.MoreAsserts.assertLessThan;, +  /**, +   * Tests that the linear congruential generator is actually compatible with the c++, +   * implementation., +   *, +   * This test was added to help refactoring, it is not a strict requirement, it can be removed if, +   * functionality changes in the future., +   */, +  public void testConsistentHash_linearCongruentialGeneratorCompatibility() {, +    assertEquals(55, Hashing.consistentHash(1, 100));, +    assertEquals(62, Hashing.consistentHash(2, 100));, +    assertEquals(8, Hashing.consistentHash(3, 100));, +    assertEquals(45, Hashing.consistentHash(4, 100));, +    assertEquals(59, Hashing.consistentHash(5, 100));, +  }, +, +  public void testWeightedConsistentHash_wrongInput_emptyWeights() {, +    try {, +      Hashing.weightedConsistentHash(123, new double[] {});, +      fail("Should have failed with IllegalArgumentException.");, +    } catch (IllegalArgumentException expected) {}, +  }, +, +  public void testWeightedConsistentHash_wrongInput_zeroOnlyWeights() {, +    try {, +      Hashing.weightedConsistentHash(123, new double[] {0, 0, 0});, +      fail("Should have failed with IllegalArgumentException.");, +    } catch (IllegalArgumentException expected) {}, +  }, +, +  public void testWeightedConsistentHash_wrongInput_negativeWeight() {, +    try {, +      double[] l = {1.0, -0.1, 0.8};, +      Hashing.weightedConsistentHash(123, new double[]  {1.0, -0.1, 0.8});, +      fail("Should have failed with IllegalArgumentException.");, +    } catch (IllegalArgumentException expected) {}, +  }, +, +  private static final double MAX_PERCENT_SPREAD = 0.5;, +  private static final long RANDOM_SEED = 177L;, +, +  /**, +   * Test that consistent weighted hashing distributes approximately according to the weights., +   */, +  public void testWeightedConsistentHash_weightsObserved() {, +    final int numHashes = 10000;, +    final int numBuckets = 30;, +, +    double sumWeights = 0.0;, +    double[] w = new double[numBuckets];, +    for (int i = 0; i < numBuckets; i++) {, +      double weight = numBuckets / 5 + i;, +      w[i] = weight;, +      sumWeights += weight;, +    }, +, +    int[] count = new int[numBuckets];, +    Random valueGenerator = new Random(RANDOM_SEED);, +    for (int i = 0; i < numHashes; i++) {, +      int bucket = Hashing.weightedConsistentHash(valueGenerator.nextInt(), w);, +      assertGreaterThan(-1, bucket);, +      assertLessThan(numBuckets, bucket);, +      count[bucket]++;, +    }, +, +    // Testing buckets observerd and expected fill., +    for (int i = 0; i < numBuckets; i++) {, +      double observedPercent = 100.0 * count[i] / numHashes;, +      double expectedPercent = 100.0 * w[i] / sumWeights;, +      String message = new StringBuilder(), +          .append("bucket: ").append(i).append(", "), +          .append("count: ").append(count[i]).append(", "), +          .append("weight: ").append(w[i]), +          .toString();, +      assertGreaterThan(message, expectedPercent - MAX_PERCENT_SPREAD, observedPercent);, +      assertLessThan(message, expectedPercent + MAX_PERCENT_SPREAD, observedPercent);, +    }, +  }, +, +  /**, +   * Test that consistent weighted hashing is consistent., +   * If some weights are decreased, items that didn't belong to that bucket don't get reassigned., +   */, +  public void testWeightedConsistentHash_consistencyWeightChange() {, +    final int numHashes = 10000;, +    final int numBuckets = 30;, +, +    double[] w1 = new double[numBuckets];, +    double[] w2 = new double[numBuckets];, +    for (int i = 0; i < numBuckets; i++) {, +      double weight = numBuckets / 5 + i;, +      w1[i] = weight;, +      // Decrease weight for every 7th bucket., +      w2[i] = (i % 7 != 0) ? weight : weight / (i + 1);, +    }, +, +    Random valueGenerator = new Random(RANDOM_SEED);, +    for (int i = 0; i < numHashes; i++) {]