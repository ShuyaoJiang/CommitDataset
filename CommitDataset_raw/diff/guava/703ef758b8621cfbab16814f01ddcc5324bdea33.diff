[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java, +      Iterator<T> iterator = emptyModifiableIterator();, +        /*, +         * Don't store a new Iterator until we know the user can't remove() the last returned, +         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating, +         * the new one. The result is a ConcurrentModificationException or other bad behavior., +         *, +         * (If we decide that we really, really hate allocating two Iterators per cycle instead of, +         * one, we can optimistically store the new Iterator and then be willing to throw it out if, +         * the user calls remove().), +         */, +        return iterator.hasNext() || iterable.iterator().hasNext();, +        if (!iterator.hasNext()) {, +          iterator = iterable.iterator();, +          if (!iterator.hasNext()) {, +        }, +        iterator.remove();, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java, +      Iterator<T> iterator = emptyModifiableIterator();, +        /*, +         * Don't store a new Iterator until we know the user can't remove() the last returned, +         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating, +         * the new one. The result is a ConcurrentModificationException or other bad behavior., +         *, +         * (If we decide that we really, really hate allocating two Iterators per cycle instead of, +         * one, we can optimistically store the new Iterator and then be willing to throw it out if, +         * the user calls remove().), +         */, +        return iterator.hasNext() || iterable.iterator().hasNext();, +        if (!iterator.hasNext()) {, +          iterator = iterable.iterator();, +          if (!iterator.hasNext()) {, +        }, +        iterator.remove();, +++ b/guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/IteratorsTest.java, +import static com.google.common.collect.CollectPreconditions.checkRemove;, +import java.util.ArrayList;, +import java.util.ConcurrentModificationException;, +  /** An Iterable whose Iterator is rigorous in checking for concurrent modification. */, +  private static final class PickyIterable<E> implements Iterable<E> {, +    final List<E> elements;, +    int modCount = 0;, +, +    PickyIterable(E... elements) {, +      this.elements = new ArrayList<E>(asList(elements));, +    }, +, +    @Override, +    public Iterator<E> iterator() {, +      return new PickyIterator();, +    }, +, +    final class PickyIterator implements Iterator<E> {, +      int expectedModCount = modCount;, +      int index = 0;, +      boolean canRemove;, +, +      @Override, +      public boolean hasNext() {, +        checkConcurrentModification();, +        return index < elements.size();, +      }, +, +      @Override, +      public E next() {, +        checkConcurrentModification();, +        if (!hasNext()) {, +          throw new NoSuchElementException();, +        }, +        canRemove = true;, +        return elements.get(index++);, +      }, +, +      @Override, +      public void remove() {, +        checkConcurrentModification();, +        checkRemove(canRemove);, +        elements.remove(--index);, +        expectedModCount = ++modCount;, +        canRemove = false;, +      }, +, +      void checkConcurrentModification() {, +        if (expectedModCount != modCount) {, +          throw new ConcurrentModificationException();, +        }, +      }, +    }, +  }, +, +  public void testCycleRemoveAfterHasNextExtraPicky() {, +    PickyIterable<String> iterable = new PickyIterable("a");, +    Iterator<String> cycle = Iterators.cycle(iterable);, +    assertTrue(cycle.hasNext());, +    assertEquals("a", cycle.next());, +    assertTrue(cycle.hasNext());, +    cycle.remove();, +    assertTrue(iterable.elements.isEmpty());, +    assertFalse(cycle.hasNext());, +  }]