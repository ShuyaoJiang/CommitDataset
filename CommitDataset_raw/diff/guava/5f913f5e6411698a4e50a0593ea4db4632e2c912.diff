[+++ b/guava-tests/test/com/google/common/reflect/TypeTokenResolutionTest.java, +, +  public void testTwoStageResolution() {, +    class ForTwoStageResolution<A extends Number> {, +      <B extends A> void verifyTwoStageResolution() {, +        @SuppressWarnings({"unchecked", "rawtypes"}), +        Type type = new TypeToken<B>(getClass()) {}, +            // B's bound may have already resolved to something., +            // Make sure it can still further resolve when given a context., +            .where(new TypeParameter<B>() {}, (Class) Integer.class), +            .getType();, +        assertEquals(Integer.class, type);, +      }, +    }, +    new ForTwoStageResolution<Integer>().verifyTwoStageResolution();, +    new ForTwoStageResolution<Integer>() {}.verifyTwoStageResolution();, +  }, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenResolutionTest.java, +, +  public void testTwoStageResolution() {, +    class ForTwoStageResolution<A extends Number> {, +      <B extends A> void verifyTwoStageResolution() {, +        @SuppressWarnings({"unchecked", "rawtypes"}), +        Type type = new TypeToken<B>(getClass()) {}, +            // B's bound may have already resolved to something., +            // Make sure it can still further resolve when given a context., +            .where(new TypeParameter<B>() {}, (Class) Integer.class), +            .getType();, +        assertEquals(Integer.class, type);, +      }, +    }, +    new ForTwoStageResolution<Integer>().verifyTwoStageResolution();, +    new ForTwoStageResolution<Integer>() {}.verifyTwoStageResolution();, +  }, +++ b/guava-tests/test/com/google/common/reflect/TypesTest.java, +import com.google.common.collect.Lists;, +    new TypeVariableEqualsTester(), +        .addEqualityGroup(upperBoundJvmType, upperBound), +      Types.newArtificialTypeVariable(List.class, "E", int.class);, +      SerializableTester.reserialize(Types.newArtificialTypeVariable(List.class, "E"));, +    return Types.newArtificialTypeVariable(, +  private static class TypeVariableEqualsTester {, +    private final EqualsTester tester = new EqualsTester();, +, +    TypeVariableEqualsTester addEqualityGroup(Type jvmType, Type... types) {, +      if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY) {, +        tester.addEqualityGroup(jvmType);, +        tester.addEqualityGroup((Object[]) types);, +      } else {, +        tester.addEqualityGroup(Lists.asList(jvmType, types).toArray());, +      }, +      return this;, +    }, +, +    void testEquals() {, +      tester.testEquals();, +    }, +  }, +, +    if (!Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY) {, +    }, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenResolutionTest.java, +, +  public void testTwoStageResolution() {, +    class ForTwoStageResolution<A extends Number> {, +      <B extends A> void verifyTwoStageResolution() {, +        @SuppressWarnings({"unchecked", "rawtypes"}), +        Type type = new TypeToken<B>(getClass()) {}, +            // B's bound may have already resolved to something., +            // Make sure it can still further resolve when given a context., +            .where(new TypeParameter<B>() {}, (Class) Integer.class), +            .getType();, +        assertEquals(Integer.class, type);, +      }, +    }, +    new ForTwoStageResolution<Integer>().verifyTwoStageResolution();, +    new ForTwoStageResolution<Integer>() {}.verifyTwoStageResolution();, +  }, +++ b/guava-tests/test/com/google/common/reflect/TypesTest.java, +import com.google.common.collect.Lists;, +    new TypeVariableEqualsTester(), +        .addEqualityGroup(upperBoundJvmType, upperBound), +      Types.newArtificialTypeVariable(List.class, "E", int.class);, +      SerializableTester.reserialize(Types.newArtificialTypeVariable(List.class, "E"));, +    return Types.newArtificialTypeVariable(, +  private static class TypeVariableEqualsTester {, +    private final EqualsTester tester = new EqualsTester();, +, +    TypeVariableEqualsTester addEqualityGroup(Type jvmType, Type... types) {, +      if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY) {, +        tester.addEqualityGroup(jvmType);, +        tester.addEqualityGroup((Object[]) types);, +      } else {, +        tester.addEqualityGroup(Lists.asList(jvmType, types).toArray());, +      }, +      return this;, +    }, +, +    void testEquals() {, +      tester.testEquals();]