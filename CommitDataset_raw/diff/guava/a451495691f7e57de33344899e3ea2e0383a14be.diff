[+++ b/guava-tests/test/com/google/common/util/concurrent/SerializingExecutorTest.java, +    void runAll() {, +      while (hasNext()) {, +        runNext();, +      }, +    }, +        // Make sure that no other tasks are scheduled to run while this is running., +        assertFalse(fakePool.hasNext());, +    // A task should have been scheduled, +    // Our executor hasn't run any tasks yet., +    fakePool.runAll();, +    // Queue is empty so no runner should be scheduled., +    // No change yet., +    fakePool.runAll();, +  public void testSuspend() {, +    final AtomicInteger totalCalls = new AtomicInteger();, +    Runnable suspender = new Runnable() {, +      @Override, +      public void run() {, +        totalCalls.incrementAndGet();, +        // Suspend the queue so no other calls run., +        e.suspend();, +      }, +    };, +, +    assertFalse(fakePool.hasNext());, +    e.execute(suspender);, +    // A task should have been scheduled, +    assertTrue(fakePool.hasNext());, +    e.execute(suspender);, +    fakePool.runAll();, +    // Only the first call that was already scheduled before suspension should have run., +    assertEquals(1, totalCalls.get());, +    // Queue is suspended so no runner should be scheduled., +    assertFalse(fakePool.hasNext());, +, +    e.execute(suspender);, +    // Queue is suspended so no runner should be scheduled., +    assertFalse(fakePool.hasNext());, +    e.resume();, +    // A task should have been scheduled, +    assertTrue(fakePool.hasNext());, +    fakePool.runAll();, +    // Another call should have been run, but that suspended the queue again., +    assertEquals(2, totalCalls.get());, +    assertFalse(fakePool.hasNext());, +, +    // Suspend the queue from here as well, making the count two., +    e.suspend();, +    e.resume();, +    // Queue is still suspended, with count one, so no runner should be scheduled., +    assertFalse(fakePool.hasNext());, +    e.resume();, +    // A task should have been scheduled, +    assertTrue(fakePool.hasNext());, +    fakePool.runAll();, +    // Another call should have been run, but that suspended the queue again., +    assertEquals(3, totalCalls.get());, +  }, +, +    fakePool.runAll();, +  public void testPrependContinuation() {, +    final List<Integer> callOrder = Lists.newArrayList();, +, +    class FakeOp implements Runnable {, +      final int op;, +, +      FakeOp(int op) {, +        this.op = op;, +      }, +, +      @Override, +      public void run() {, +        callOrder.add(op);, +      }, +    }, +, +    e.execute(new FakeOp(1));, +    e.execute(new FakeOp(2));, +    e.executeFirst(new FakeOp(0));, +    fakePool.runAll();, +, +    assertEquals(ImmutableList.of(0, 1, 2), callOrder);, +  }, +, +  public void testRuntimeException_doesNotStopExecution() {, +    fakePool.runAll();, +  public void testInterrupt_doesNotStopExecution() {, +, +    final AtomicInteger numCalls = new AtomicInteger();, +, +    Runnable runMe = new Runnable() {, +      @Override, +      public void run() {, +        numCalls.incrementAndGet();, +      }, +    };, +, +    Thread.currentThread().interrupt();, +]