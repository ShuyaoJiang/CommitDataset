[+++ b/guava/src/com/google/common/collect/RegularImmutableBiMap.java, +import static com.google.common.collect.RegularImmutableMap.checkNoConflictInKeyBucket;, +      checkNoConflictInKeyBucket(key, entry, nextInKeyBucket);, +      checkNoConflictInValueBucket(value, entry, nextInValueBucket);, +      checkNoConflictInKeyBucket(key, entry, nextInKeyBucket);, +      checkNoConflictInValueBucket(value, entry, nextInValueBucket);, +  // checkNoConflictInKeyBucket is static imported from RegularImmutableMap, +, +  private static void checkNoConflictInValueBucket(Object value, Entry<?, ?> entry,, +      @Nullable ImmutableMapEntry<?, ?> valueBucketHead) {, +    for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {, +      checkNoConflict(!value.equals(valueBucketHead.getValue()), "value", entry, valueBucketHead);, +    }, +  }, +  , +    return RegularImmutableMap.get(key, keyTable, mask);, +++ b/guava/src/com/google/common/collect/RegularImmutableBiMap.java, +import static com.google.common.collect.RegularImmutableMap.checkNoConflictInKeyBucket;, +      checkNoConflictInKeyBucket(key, entry, nextInKeyBucket);, +      checkNoConflictInValueBucket(value, entry, nextInValueBucket);, +      checkNoConflictInKeyBucket(key, entry, nextInKeyBucket);, +      checkNoConflictInValueBucket(value, entry, nextInValueBucket);, +  // checkNoConflictInKeyBucket is static imported from RegularImmutableMap, +, +  private static void checkNoConflictInValueBucket(Object value, Entry<?, ?> entry,, +      @Nullable ImmutableMapEntry<?, ?> valueBucketHead) {, +    for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {, +      checkNoConflict(!value.equals(valueBucketHead.getValue()), "value", entry, valueBucketHead);, +    }, +  }, +  , +    return RegularImmutableMap.get(key, keyTable, mask);, +++ b/guava/src/com/google/common/collect/RegularImmutableMap.java, +      checkNoConflictInKeyBucket(key, newEntry, existing);, +      checkNoConflictInKeyBucket(key, newEntry, existing);, +  static void checkNoConflictInKeyBucket(, +      Object key, Entry<?, ?> entry, @Nullable ImmutableMapEntry<?, ?> keyBucketHead) {, +    for (; keyBucketHead != null; keyBucketHead = keyBucketHead.getNextInKeyBucket()) {, +      checkNoConflict(!key.equals(keyBucketHead.getKey()), "key", entry, keyBucketHead);, +    return get(key, table, mask);, +  }, +  , +  @Nullable , +  static <V> V get(@Nullable Object key, ImmutableMapEntry<?, V>[] keyTable, int mask) {, +    for (ImmutableMapEntry<?, V> entry = keyTable[index];, +      Object candidateKey = entry.getKey();]