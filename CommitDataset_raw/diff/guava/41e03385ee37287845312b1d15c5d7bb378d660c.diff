[+++ b/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Graph} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Graph} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Network} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +        assertThat(node.equals(adjacentNode) || Collections.disjoint(edges, antiParallelEdges)), +            .isTrue();, +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Graph} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Network} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +        assertThat(node.equals(adjacentNode) || Collections.disjoint(edges, antiParallelEdges)), +            .isTrue();, +++ b/guava-tests/test/com/google/common/graph/AbstractGraphTest.java, + * Abstract base class for testing implementations of {@link Graph} interface. Graph instances, + * created for testing should have Integer node and String edge objects., + * <p>Test cases that should be handled similarly in any graph implementation are included in this, + * class. For example, testing that {@code nodes()} method returns the set of the nodes in the, + * graph. The following test cases are left for the subclasses to handle:, + *, + * <li>Test cases related to whether the graph is directed, undirected, mutable, or immutable., +  /** Creates and returns an instance of the graph to be tested. */, +   * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable, +   * graph implementations, this method should add {@code n} to the graph builder and build a new, +   * graph with the current builder state., +  protected boolean addNode(Integer n) {, +   * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable, +   * graph implementations, this method should add {@code e} to the graph builder and build a new, +   * graph with the current builder state., +   * <p>This method should be used in tests of specific implementations if you want to ensure, +   * uniform behavior (including side effects) with how edges are added elsewhere in the tests. For, +   * example, the existing implementations of this method explicitly add the supplied nodes to the, +   * graph, and then call {@code graph.addEdge()} to connect the edge to the nodes; this is not part, +   * of the contract of {@code graph.addEdge()} and is done for convenience. In cases where you want, +   * to avoid such side effects (e.g., if you're testing what happens in your implementation if you, +   * add an edge whose end-points don't already exist in the graph), you should <b>not</b> use this, +  protected boolean putEdge(Integer n1, Integer n2) {, +        assertThat(graph.degree(node)), +            .isEqualTo(graph.predecessors(node).size() + graph.successors(node).size());, +        assertThat(graph.degree(node)), +            .isEqualTo(neighbors.size() + (neighbors.contains(node) ? 1 : 0));, +        assertThat(, +                graph.predecessors(node).contains(adjacentNode), +                    || graph.successors(node).contains(adjacentNode)), +            .isTrue();, +   * Verifies that the {@code Set} returned by {@code adjacentNodes} has the expected mutability, +   * property (see the {@code Graph} documentation for more information)., +   * Verifies that the {@code Set} returned by {@code predecessors} has the expected mutability, +   * property (see the {@code Graph} documentation for more information)., +   * Verifies that the {@code Set} returned by {@code successors} has the expected mutability, +   * property (see the {@code Graph} documentation for more information)., +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedGraphTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Graph} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +++ b/guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java, + * <p>This class is responsible for testing that a directed implementation of {@link Network} is, + * correctly handling directed edges. Implementation-dependent test cases are left to subclasses., + * Test cases that do not require the graph to be directed are found in superclasses., +        assertThat(node.equals(adjacentNode) || Collections.disjoint(edges, antiParallelEdges)), +            .isTrue();, +++ b/guava-tests/test/com/google/common/graph/AbstractGraphTest.java, + * Abstract base class for testing implementations of {@link Graph} interface. Graph instances, + * created for testing should have Integer node and String edge objects., + * <p>Test cases that should be handled similarly in any graph implementation are included in this, + * class. For example, testing that {@code nodes()} method returns the set of the nodes in the, + * graph. The following test cases are left for the subclasses to handle:, + *, + * <li>Test cases related to whether the graph is directed, undirected, mutable, or immutable., +  /** Creates and returns an instance of the graph to be tested. */, +   * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable, +   * graph implementations, this method should add {@code n} to the graph builder and build a new, +   * graph with the current builder state., +  protected boolean addNode(Integer n) {, +   * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable, +   * graph implementations, this method should add {@code e} to the graph builder and build a new, +   * graph with the current builder state., +   * <p>This method should be used in tests of specific implementations if you want to ensure, +   * uniform behavior (including side effects) with how edges are added elsewhere in the tests. For, +   * example, the existing implementations of this method explicitly add the supplied nodes to the, +   * graph, and then call {@code graph.addEdge()} to connect the edge to the nodes; this is not part, +   * of the contract of {@code graph.addEdge()} and is done for convenience. In cases where you want, +   * to avoid such side effects (e.g., if you're testing what happens in your implementation if you, +   * add an edge whose end-points don't already exist in the graph), you should <b>not</b> use this, +  protected boolean putEdge(Integer n1, Integer n2) {, +        assertThat(graph.degree(node)), +            .isEqualTo(graph.predecessors(node).size() + graph.successors(node).size());, +        assertThat(graph.degree(node)), +            .isEqualTo(neighbors.size() + (neighbors.contains(node) ? 1 : 0));]