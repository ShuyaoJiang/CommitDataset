[+++ b/src/com/google/common/collect/ImmutableSet.java, +    return construct(e1, e2);, +    return construct(e1, e2, e3);, +    return construct(e1, e2, e3, e4);, +    return construct(e1, e2, e3, e4, e5);, +    final int paramCount = 6;, +    Object[] elements = new Object[paramCount + others.length];, +    elements[0] = e1;, +    elements[1] = e2;, +    elements[2] = e3;, +    elements[3] = e4;, +    elements[4] = e5;, +    elements[5] = e6;, +    for (int i = paramCount; i < elements.length; i++) {, +      elements[i] = others[i - paramCount];, +    }, +    return construct(elements);, +  }, +  , +  /** {@code elements} has to be internally created array. */, +  private static <E> ImmutableSet<E> construct(Object... elements) {, +    int tableSize = Hashing.chooseTableSize(elements.length);, +    Object[] table = new Object[tableSize];, +    int mask = tableSize - 1;, +    ArrayList<Object> uniqueElementsList = null;, +    int hashCode = 0;, +    for (int i = 0; i < elements.length; i++) {, +      Object element = elements[i];, +      int hash = element.hashCode();, +      for (int j = Hashing.smear(hash); ; j++) {, +        int index = j & mask;, +        Object value = table[index];, +        if (value == null) {, +          if (uniqueElementsList != null) {, +            uniqueElementsList.add(element);, +          }, +          // Came to an empty slot. Put the element here., +          table[index] = element;, +          hashCode += hash;, +          break;, +        } else if (value.equals(element)) {, +          if (uniqueElementsList == null) {, +            // first dup, +            uniqueElementsList = new ArrayList<Object>(elements.length);, +            for (int k = 0; k < i; k++) {, +              Object previous = elements[k];, +              uniqueElementsList.add(previous);, +            }, +          }, +          break;, +        }, +      }, +    }, +    Object[] uniqueElements = uniqueElementsList == null, +        ? elements, +        : uniqueElementsList.toArray();, +    if (uniqueElements.length == 1) {, +      // There is only one element or elements are all duplicates, +      @SuppressWarnings("unchecked") // we are careful to only pass in E, +      E element = (E) uniqueElements[0];, +      return new SingletonImmutableSet<E>(element, hashCode);, +    } else if (tableSize > 2 * Hashing.chooseTableSize(uniqueElements.length)) {, +      // Resize the table when the array includes too many duplicates., +      // when this happens, we have already made a copy, +      return construct(uniqueElements);, +    } else {, +      return new RegularImmutableSet<E>(uniqueElements, hashCode, table, mask);, +    }, +    // TODO(benyu): could we delegate to, +    // copyFromCollection(Arrays.asList(elements))?, +        return construct(elements.clone());, +    if (elements instanceof Collection) {, +      Collection<? extends E> collection = (Collection<? extends E>) elements;, +      return copyOf(collection);, +    return copyOf(elements.iterator());, +    // TODO(benyu): here we could avoid toArray() for 0 or 1-element list,, +    // worth it?, +    return copyFromCollection(Lists.newArrayList(elements));, +  /**, +   * Returns an immutable set containing the given elements, in order. Repeated, +   * occurrences of an element (according to {@link Object#equals}) after the, +   * first are ignored. This method iterates over {@code elements} at most, +   * once., +   *, +   * <p>Note that if {@code s} is a {@code Set<String>}, then {@code, +   * ImmutableSet.copyOf(s)} returns an {@code ImmutableSet<String>} containing, +   * each of the strings in {@code s}, while {@code ImmutableSet.of(s)} returns, +   * a {@code ImmutableSet<Set<String>>} containing one element (the given set, +   * itself)., +   *, +   * <p><b>Note:</b> Despite what the method name suggests, if {@code elements}, +   * is an {@code ImmutableSet} (but not an {@code ImmutableSortedSet}), no copy, +   * will actually be performed, and the given set itself will be returned., +   *, +   * <p>This method is safe to use even when {@code elements} is a synchronized, +   * or concurrent collection that is currently being modified by another, +   * thread., +   *, +   * @throws NullPointerException if any of {@code elements} is null, +   */]