[+++ b/guava/src/com/google/common/collect/AbstractCache.java, +     * Records the successful creation of a new value. This should be called when a cache request, +     * triggers the creation of a new value, and that creation completes succesfully. In contrast to, +     * {@link #recordConcurrentMiss}, this method should only be called by the creating thread., +    public void recordCreateSuccess(long createTime);, +, +    /**, +     * Records the failed creation of a new value. This should be called when a cache request, +     * triggers the creation of a new value, but that creation throws an exception. In contrast to, +     * {@link #recordConcurrentMiss}, this method should only be called by the creating thread., +     *, +     * @param createTime the number of nanoseconds the cache spent creating the new value prior to, +     *     an exception being thrown, +     */, +    public void recordCreateException(long createTime);, +, +    /**, +     * Records a single concurrent miss. This should be called when a cache request returns a, +     * value which was created by a different thread. In contrast to {@link #recordCreateSuccess}, +     * and {@link #recordCreateException}, this method should never be called by the creating, +     * thread. Multiple concurrent calls to {@link Cache} lookup methods with the same key on an, +     * absent value should result in a single call to either {@code recordCreateSuccess} or, +     * {@code recordCreateException} and multiple calls to this method, despite all being served by, +     * the results of a single creation., +     */, +    public void recordConcurrentMiss();, +    private final AtomicLong createSuccessCount = new AtomicLong();, +    private final AtomicLong createExceptionCount = new AtomicLong();, +    public void recordCreateSuccess(long createTime) {, +      createSuccessCount.incrementAndGet();, +      totalCreateTime.addAndGet(createTime);, +    public void recordCreateException(long createTime) {, +      missCount.incrementAndGet();, +      createExceptionCount.incrementAndGet();, +    public void recordConcurrentMiss() {, +      missCount.incrementAndGet();, +    }, +, +    @Override, +          createSuccessCount.get(),, +          createExceptionCount.get(),, +      createSuccessCount.addAndGet(otherStats.createSuccessCount());, +      createExceptionCount.addAndGet(otherStats.createExceptionCount());, +++ b/guava/src/com/google/common/collect/AbstractCache.java, +     * Records the successful creation of a new value. This should be called when a cache request, +     * triggers the creation of a new value, and that creation completes succesfully. In contrast to, +     * {@link #recordConcurrentMiss}, this method should only be called by the creating thread., +    public void recordCreateSuccess(long createTime);, +, +    /**, +     * Records the failed creation of a new value. This should be called when a cache request, +     * triggers the creation of a new value, but that creation throws an exception. In contrast to, +     * {@link #recordConcurrentMiss}, this method should only be called by the creating thread., +     *, +     * @param createTime the number of nanoseconds the cache spent creating the new value prior to, +     *     an exception being thrown, +     */, +    public void recordCreateException(long createTime);, +, +    /**, +     * Records a single concurrent miss. This should be called when a cache request returns a, +     * value which was created by a different thread. In contrast to {@link #recordCreateSuccess}, +     * and {@link #recordCreateException}, this method should never be called by the creating, +     * thread. Multiple concurrent calls to {@link Cache} lookup methods with the same key on an, +     * absent value should result in a single call to either {@code recordCreateSuccess} or, +     * {@code recordCreateException} and multiple calls to this method, despite all being served by, +     * the results of a single creation., +     */, +    public void recordConcurrentMiss();, +    private final AtomicLong createSuccessCount = new AtomicLong();, +    private final AtomicLong createExceptionCount = new AtomicLong();, +    public void recordCreateSuccess(long createTime) {, +      createSuccessCount.incrementAndGet();, +      totalCreateTime.addAndGet(createTime);, +    public void recordCreateException(long createTime) {, +      missCount.incrementAndGet();, +      createExceptionCount.incrementAndGet();, +    public void recordConcurrentMiss() {, +      missCount.incrementAndGet();, +    }, +, +    @Override, +          createSuccessCount.get(),, +          createExceptionCount.get(),, +      createSuccessCount.addAndGet(otherStats.createSuccessCount());, +      createExceptionCount.addAndGet(otherStats.createExceptionCount());, +++ b/guava/src/com/google/common/collect/CacheStats.java, + * <li>When a cache lookup encounters an existing cache entry {@code hitCount} is incremented., + * <li>When a cache lookup first encounters a missing cache entry, a new entry is created., + * <ul>, + * <li>After successful creation {@code missCount} and {@code createSuccessCount} are, + *     incremented, and the total creation time, in nanoseconds, is added to, + *     {@code totalCreateTime}., + * <li>When an exception is thrown during creation {@code missCount} and {@code, + *     createExceptionCount} are incremented, and the total creation time, in nanoseconds, is, + *     added to {@code totalCreateTime}., + *     creation (whether successful or not) and then increment {@code missCount}., + * </ul>, +  private final long createSuccessCount;, +  private final long createExceptionCount;]