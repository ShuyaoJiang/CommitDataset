[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  /**, +   * Asserts that {@link BloomFilter#approximateCount} is within 1 percent of the expected value., +   */, +  private static void assertApproximateCountGuess(BloomFilter<?> bf, int sizeGuess) {, +    assertThat(bf.approximateCount()).isAtLeast((long) (sizeGuess * 0.99));, +    assertThat(bf.approximateCount()).isAtMost((long) (sizeGuess * 1.01));, +  }, +, +    assertApproximateCountGuess(bf, numInsertions);, +    assertApproximateCountGuess(bf, numInsertions);, +    assertApproximateCountGuess(bf, numInsertions);, +  private static void checkSanity(BloomFilter<Object> bf) {, +  public void testApproximateCount() {, +    int numInsertions = 1000;, +    BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), numInsertions);, +    bf.put(-1);, +    for (int i = 0; i < numInsertions; i++) {, +      bf.put(i);, +    }, +    assertApproximateCountGuess(bf, numInsertions);, +  }, +, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  /**, +   * Asserts that {@link BloomFilter#approximateCount} is within 1 percent of the expected value., +   */, +  private static void assertApproximateCountGuess(BloomFilter<?> bf, int sizeGuess) {, +    assertThat(bf.approximateCount()).isAtLeast((long) (sizeGuess * 0.99));, +    assertThat(bf.approximateCount()).isAtMost((long) (sizeGuess * 1.01));, +  }, +, +    assertApproximateCountGuess(bf, numInsertions);, +    assertApproximateCountGuess(bf, numInsertions);, +    assertApproximateCountGuess(bf, numInsertions);, +  private static void checkSanity(BloomFilter<Object> bf) {, +  public void testApproximateCount() {, +    int numInsertions = 1000;, +    BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), numInsertions);, +    bf.put(-1);, +    for (int i = 0; i < numInsertions; i++) {, +      bf.put(i);, +    }, +    assertApproximateCountGuess(bf, numInsertions);, +  }, +, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +import com.google.common.math.DoubleMath;, +import java.math.RoundingMode;, + * <p>If you are unfamiliar with Bloom filters, this nice <a, + * href="http://llimllib.github.com/bloomfilter-tutorial/">tutorial</a> may help you understand how, + * they work., + * <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability, + * of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter, +   * @return true if the Bloom filter's bits changed as a result of this operation. If the bits, +   * Returns an estimate for the total number of distinct elements that have been added to this, +   * Bloom filter. This approximation is reasonably accurate if it does not exceed the value of, +   * {@code expectedInsertions} that was used when constructing the filter., +   *, +   * @since 22.0, +   */, +  public long approximateCount() {, +    long bitSize = bits.bitSize();, +    long bitCount = bits.bitCount();, +, +    /**, +     * Each insertion is expected to reduce the # of clear bits by a factor of, +     * `numHashFunctions/bitSize`. So, after n insertions, expected bitCount is `bitSize * (1 - (1 -, +     * numHashFunctions/bitSize)^n)`. Solving that for n, and approximating `ln x` as `x - 1` when x, +     * is close to 1 (why?), gives the following formula., +     */, +    double fractionOfBitsSet = (double) bitCount / bitSize;, +    return DoubleMath.roundToLong(, +        -Math.log1p(-fractionOfBitsSet) * bitSize / numHashFunctions, RoundingMode.HALF_UP);, +  }, +, +  /**, +   * Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom, +   * @param that The Bloom filter to check for compatibility., +   * Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the, +   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom, +   * @param that The Bloom filter to combine this Bloom filter with. It is not mutated.]