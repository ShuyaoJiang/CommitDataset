[+++ b/guava/src/com/google/common/util/concurrent/ListenableFuture.java, + * <p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of, + * asynchronous operations. You can chain them together manually with calls to methods like, + * {@link Futures#transform(ListenableFuture, Function, Executor) Futures.transform}, but you will, + * often find it easier to use a framework. Frameworks automate the process, often adding features, + * like monitoring, debugging, and cancellation. Examples of frameworks include:, + * <ul>, + * <li><a href="http://google.github.io/dagger/producers.html">Dagger Producers</a>, + * </ul>, + *, + * <p>The main purpose of {@link #addListener addListener} is to support this chaining. You will, + * rarely use it directly, in part because it does not provide direct access to the {@code Future}, + * result. (If you want such access, you may prefer {@link Futures#addCallback, + * Futures.addCallback}.) Still, direct {@code addListener} calls are occasionally useful:, + *, + * <pre>   {@code, + * <p>We encourage you to return {@code ListenableFuture} from your methods so that your users can, + * take advantage of the {@linkplain Futures utilities built atop the class}. The way that you will, + * create {@code ListenableFuture} instances depends on how you currently create {@code Future}, + * instances:, + * <li>If you receive them from an {@code ExecutorService}, convert that service to a, + * <li>If you manually call {@link FutureTask#set} or a similar method, create a, + *     {@link SettableFuture} instead. (If your needs are more complex, you may prefer]