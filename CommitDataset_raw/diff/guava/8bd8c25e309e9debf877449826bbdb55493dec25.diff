[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +    void valueReclaimed(ValueReference<K, V> valueReference);, +    public void valueReclaimed(ValueReference<Object, Object> v) {}, +    public void valueReclaimed(ValueReference<K, V> v) {, +      map.reclaimValue(this, v);, +    public void valueReclaimed(ValueReference<K, V> v) {, +      map.reclaimValue(this, v);, +    public void valueReclaimed(ValueReference<K, V> v) {, +      map.reclaimValue(this, v);, +      entry.valueReclaimed(this);, +      entry.valueReclaimed(this);, +  void reclaimValue(ReferenceEntry<K, V> entry,, +      ValueReference<K, V> valueReference) {, +    Segment segment = segmentFor(hash);, +    if (segment.clearValue(entry.getKey(), hash, valueReference)) {, +, +    // TODO(user): move cleanup to an executor, +    segment.lock();, +    try {, +      segment.cleanup();, +    } finally {, +      segment.unlock();, +    }, +  void enqueueNotification(K key, int hash) {, +    ReferenceEntry<K, V> notifyEntry = entryFactory.newEntry(, +        CustomConcurrentHashMap.this, key, hash, null);, +    evictionNotificationQueue.offer(notifyEntry);, +  }, +, +      public void valueReclaimed(ValueReference<K, V> valueReference) {, +      public void valueReclaimed(ValueReference<K, V> valueReference) {, +            } else if (absent) {, +              // value was garbage collected, +              enqueueNotification(key, hash);]