[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +import java.util.Arrays;, +  public void testCopy() {, +  public void testEquals_empty() {, +  public void testEquals() {, +  public void testPutReturnValue() {, +    for (int i = 0; i < 10; i++) {, +      for (int j = 0; j < 10; j++) {, +        String value = new Object().toString();, +        boolean mightContain = bf.mightContain(value);, +        boolean put = bf.put(value);, +        assertTrue(mightContain != put);, +      }, +    }, +  }, +, +  public void testJavaSerialization() {, +    BloomFilter<byte[]> bf = BloomFilter.create(Funnels.byteArrayFunnel(), 100);, +    for (int i = 0; i < 10; i++) {, +      bf.put(Ints.toByteArray(i));, +    }, +, +    bf = SerializableTester.reserialize(bf);, +    for (int i = 0; i < 10; i++) {, +      assertTrue(bf.mightContain(Ints.toByteArray(i)));, +    }, +  }, +, +  /**, +   * This test will fail whenever someone updates/reorders the BloomFilterStrategies constants., +   * Only appending a new constant is allowed., +   */, +  public void testBloomFilterStrategies() {, +    assertEquals(Arrays.asList(BloomFilterStrategies.values()),, +        Arrays.asList(new BloomFilterStrategies[] {BloomFilterStrategies.MURMUR128_MITZ_32}));, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +import java.util.Arrays;, +  public void testCopy() {, +  public void testEquals_empty() {, +  public void testEquals() {, +  public void testPutReturnValue() {, +    for (int i = 0; i < 10; i++) {, +      for (int j = 0; j < 10; j++) {, +        String value = new Object().toString();, +        boolean mightContain = bf.mightContain(value);, +        boolean put = bf.put(value);, +        assertTrue(mightContain != put);, +      }, +    }, +  }, +, +  public void testJavaSerialization() {, +    BloomFilter<byte[]> bf = BloomFilter.create(Funnels.byteArrayFunnel(), 100);, +    for (int i = 0; i < 10; i++) {, +      bf.put(Ints.toByteArray(i));, +    }, +, +    bf = SerializableTester.reserialize(bf);, +    for (int i = 0; i < 10; i++) {, +      assertTrue(bf.mightContain(Ints.toByteArray(i)));, +    }, +  }, +, +  /**, +   * This test will fail whenever someone updates/reorders the BloomFilterStrategies constants., +   * Only appending a new constant is allowed., +   */, +  public void testBloomFilterStrategies() {, +    assertEquals(Arrays.asList(BloomFilterStrategies.values()),, +        Arrays.asList(new BloomFilterStrategies[] {BloomFilterStrategies.MURMUR128_MITZ_32}));, +++ b/guava/src/com/google/common/hash/BloomFilter.java, + * @author Kevin Bourrillion, +  /*, +   * TODO(user): add this above (when the other serial form is published):, +   * <p>Bloom filters are serializable, but also support a more compact serial, +   * representation via the {} and {} methods. Both serialized forms will continue to, +   * be supported by future versions of this library., +   */, +, +    /**, +     * Identifier used to encode this strategy, when marshalled as part of a BloomFilter., +     * Only values in the [-128, 127] range are valid for the compact serial form., +     * Non-negative values are reserved for enums defined in BloomFilterStrategies;, +     * negative values are reserved for any custom, stateful strategy we may define, +     * (e.g. any kind of strategy that would depend on user input)., +     */, +    int ordinal();, +, +    /*, +     * This only exists to forbid BFs that cannot use the compact persistent representation., +     * If it ever throws, at a user who was not intending to use that representation, we should, +     * reconsider, +     */, +    if (numHashFunctions > 255) {, +      throw new AssertionError("Currently we don't allow BloomFilters that would use more than" +, +          "255 hash functions, please contact the guava team");, +    }, +      BloomFilter<?> that = (BloomFilter<?>) o;, +   * @return a {@code BloomFilter}, +   * @return a {@code BloomFilter}]