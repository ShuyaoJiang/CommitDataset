[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  protected final void afterDone() {, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +    // We call this after the listeners on the theory that afterDone() will only be used for, +    // 'cleanup' oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be, +    // executing more important work.  A counter argument would be that done() is trusted code and, +    // therefore it would be safe to run before potentially slow or poorly behaved listeners., +    // Reevaluate this once we have more examples of afterDone() implementations., +    afterDone();, +   * Callback method that is called exactly once after the future is completed., +   * <p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it., +   *, +   * <p>The default implementation of this method in {@code AbstractFuture} does nothing., +   *, +   * @since 20.0, +  @Beta, +  protected void afterDone() {}, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +    // We call this after the listeners on the theory that afterDone() will only be used for, +    // 'cleanup' oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be, +    // executing more important work.  A counter argument would be that done() is trusted code and, +    // therefore it would be safe to run before potentially slow or poorly behaved listeners., +    // Reevaluate this once we have more examples of afterDone() implementations., +    afterDone();, +   * Callback method that is called exactly once after the future is completed., +   * <p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it., +   *, +   * <p>The default implementation of this method in {@code AbstractFuture} does nothing., +   *, +   * @since 20.0, +  @Beta, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java, +  protected final void afterDone() {, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +    // We call this after the listeners on the theory that afterDone() will only be used for, +    // 'cleanup' oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be, +    // executing more important work.  A counter argument would be that done() is trusted code and, +    // therefore it would be safe to run before potentially slow or poorly behaved listeners., +    // Reevaluate this once we have more examples of afterDone() implementations., +    afterDone();, +   * Callback method that is called exactly once after the future is completed., +   * <p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it., +   *, +   * <p>The default implementation of this method in {@code AbstractFuture} does nothing., +   *, +   * @since 20.0, +  @Beta, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AggregateFuture.java, +  protected final void afterDone() {, +    super.afterDone();, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +    afterDone();, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +    // We call this after the listeners on the theory that afterDone() will only be used for, +    // 'cleanup' oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be, +    // executing more important work.  A counter argument would be that done() is trusted code and, +    // therefore it would be safe to run before potentially slow or poorly behaved listeners., +    // Reevaluate this once we have more examples of afterDone() implementations., +    afterDone();, +   * Callback method that is called exactly once after the future is completed., +   * <p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it., +   *, +   * <p>The default implementation of this method in {@code AbstractFuture} does nothing., +   *, +   * @since 20.0, +  @Beta, +  protected void afterDone() {}, +++ b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java, +  protected final void afterDone() {, +++ b/guava/src/com/google/common/util/concurrent/AggregateFuture.java, +  protected final void afterDone() {, +    super.afterDone();]