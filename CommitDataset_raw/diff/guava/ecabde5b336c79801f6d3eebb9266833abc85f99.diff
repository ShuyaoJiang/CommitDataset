[+++ b/guava/src/com/google/common/graph/DirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedNodeAdjacencies.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +    // We store predecessors and successors in the same map, so double the initial capacity., +    int initialCapacity = INNER_CAPACITY * 2;, +        new HashMap<N, Adjacency>(initialCapacity, INNER_LOAD_FACTOR), 0, 0);, +++ b/guava/src/com/google/common/graph/DirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedNodeAdjacencies.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +    // We store predecessors and successors in the same map, so double the initial capacity., +    int initialCapacity = INNER_CAPACITY * 2;, +        new HashMap<N, Adjacency>(initialCapacity, INNER_LOAD_FACTOR), 0, 0);, +++ b/guava/src/com/google/common/graph/GraphConstants.java, +import com.google.common.math.DoubleMath;, +, +import java.math.RoundingMode;, +, +  // Load factor and capacity for "inner" (i.e. per node/edge element) hash sets or maps, +  static final float INNER_LOAD_FACTOR = 1.0f;, +  static final int INNER_CAPACITY = DoubleMath.roundToInt(, +      (double) EXPECTED_DEGREE / INNER_LOAD_FACTOR, RoundingMode.CEILING);, +, +++ b/guava/src/com/google/common/graph/DirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedNodeAdjacencies.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +    // We store predecessors and successors in the same map, so double the initial capacity., +    int initialCapacity = INNER_CAPACITY * 2;, +        new HashMap<N, Adjacency>(initialCapacity, INNER_LOAD_FACTOR), 0, 0);, +++ b/guava/src/com/google/common/graph/GraphConstants.java, +import com.google.common.math.DoubleMath;, +, +import java.math.RoundingMode;, +, +  // Load factor and capacity for "inner" (i.e. per node/edge element) hash sets or maps, +  static final float INNER_LOAD_FACTOR = 1.0f;, +  static final int INNER_CAPACITY = DoubleMath.roundToInt(, +      (double) EXPECTED_DEGREE / INNER_LOAD_FACTOR, RoundingMode.CEILING);, +, +++ b/guava/src/com/google/common/graph/UndirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR));, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedMultiNodeConnections.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +        new HashMap<E, N>(INNER_CAPACITY, INNER_LOAD_FACTOR),, +    return (reference == null) ? null : reference.get();, +++ b/guava/src/com/google/common/graph/DirectedNodeAdjacencies.java, +import static com.google.common.graph.GraphConstants.INNER_CAPACITY;, +import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;, +import java.util.HashMap;, +    // We store predecessors and successors in the same map, so double the initial capacity., +    int initialCapacity = INNER_CAPACITY * 2;, +        new HashMap<N, Adjacency>(initialCapacity, INNER_LOAD_FACTOR), 0, 0);, +++ b/guava/src/com/google/common/graph/GraphConstants.java, +import com.google.common.math.DoubleMath;, +, +import java.math.RoundingMode;, +, +  // Load factor and capacity for "inner" (i.e. per node/edge element) hash sets or maps, +  static final float INNER_LOAD_FACTOR = 1.0f;, +  static final int INNER_CAPACITY = DoubleMath.roundToInt(, +      (double) EXPECTED_DEGREE / INNER_LOAD_FACTOR, RoundingMode.CEILING);, +, +++ b/guava/src/com/google/common/graph/UndirectedMultiNodeConnections.java]