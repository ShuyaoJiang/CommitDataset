[+++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +import com.google.common.base.Objects;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Maps;, +import com.google.common.reflect.Reflection;, +import java.util.concurrent.ConcurrentMap;, +   * Runs {@link #testMethod} on every static method of class {@code c} that has, +   * at least {@code minimalVisibility}, including those "inherited" from, +   * superclasses of the same package., +    for (Method method : minimalVisibility.getStaticMethods(c)) {, +      if (!isIgnored(method)) {, +   * Runs {@link #testMethod} on every public static method of class {@code c},, +   * including those "inherited" from superclasses of the same package., +   * Runs {@link #testMethod} on every instance method of the class of, +   * {@code instance} with at least {@code minimalVisibility}, including those, +   * inherited from superclasses of the same package., +    for (Method method : minimalVisibility.getInstanceMethods(c)) {, +      if (!isIgnored(method)) {, +   * Runs {@link #testMethod} on every public instance method of the class of, +   * {@code instance}, including those inherited from superclasses of the same, +   * package., +  public void testMethodParameter(, +      final Object instance, final Method method, int paramIndex) {, +          Type[] unresolved = method.getGenericParameterTypes();, +          if (isStatic(method)) {, +            return unresolved;, +          } else {, +            TypeToken<?> type = TypeToken.of(instance.getClass());, +            Type[] resolved = new Type[unresolved.length];, +            for (int i = 0; i < unresolved.length; i++) {, +              resolved[i] = type.resolveType(unresolved[i]).getType();, +            }, +            return resolved;, +          }, +          return method.toString();, +  public void testConstructorParameter(, +      final Constructor<?> ctor, int paramIndex) {, +, +    final Iterable<Method> getStaticMethods(Class<?> cls) {, +      ImmutableList.Builder<Method> builder = ImmutableList.builder();, +      for (Method method : getVisibleMethods(cls)) {, +        if (isStatic(method)) {, +          builder.add(method);, +        }, +      }, +      return builder.build();, +    }, +, +    final Iterable<Method> getInstanceMethods(Class<?> cls) {, +      ConcurrentMap<Signature, Method> map = Maps.newConcurrentMap();, +      for (Method method : getVisibleMethods(cls)) {, +        if (!isStatic(method)) {, +          map.putIfAbsent(new Signature(method), method);, +        }, +      }, +      return map.values();, +    }, +, +    private ImmutableList<Method> getVisibleMethods(Class<?> cls) {, +      // Don't use cls.getPackage() because it does nasty things like reading, +      // a file., +      String visiblePackage = Reflection.getPackageName(cls);, +      ImmutableList.Builder<Method> builder = ImmutableList.builder();, +      for (Class<?> type : TypeToken.of(cls).getTypes().classes().rawTypes()) {, +        if (!Reflection.getPackageName(type).equals(visiblePackage)) {, +          break;, +        }, +        for (Method method : type.getDeclaredMethods()) {, +          if (!method.isSynthetic() && isVisible(method)) {, +            builder.add(method);, +          }, +        }, +      }, +      return builder.build();, +    }, +  }, +, +  // TODO(benyu): Use labs/reflect/Signature if it graduates., +  private static final class Signature {, +    private final String name;, +    private final ImmutableList<Class<?>> parameterTypes;, +, +    Signature(Method method) {, +      this(method.getName(), ImmutableList.copyOf(method.getParameterTypes()));, +    }, +, +    Signature(String name, ImmutableList<Class<?>> parameterTypes) {, +      this.name = name;, +      this.parameterTypes = parameterTypes;, +    }, +, +    @Override public boolean equals(Object obj) {, +      if (obj instanceof Signature) {, +        Signature that = (Signature) obj;, +        return name.equals(that.name), +            && parameterTypes.equals(that.parameterTypes);, +      }, +      return false;, +    }, +]