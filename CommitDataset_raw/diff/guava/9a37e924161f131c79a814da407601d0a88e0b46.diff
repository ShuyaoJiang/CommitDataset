[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +    assertTrue(bf1.canMergeWith(bf2));, +      assertFalse(bf1.canMergeWith(bf2));, +      assertFalse(bf2.canMergeWith(bf1));, +      assertFalse(bf1.canMergeWith(bf1));, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +    assertTrue(bf1.canMergeWith(bf2));, +      assertFalse(bf1.canMergeWith(bf2));, +      assertFalse(bf2.canMergeWith(bf1));, +      assertFalse(bf1.canMergeWith(bf1));, +++ b/guava/src/com/google/common/hash/BloomFilter.java, +  /**, +   * Determines whether a given bloom filter is able to be merged with this bloom filter. For two, +   * bloom filters to be compatible, they must:, +   * <ul>, +   * <li>not be the same instance, +   * <li>have the same number of hash functions, +   * <li>have the same size, +   * <li>have the same strategy, +   * <li>have equal funnels, +   * <ul>, +   *, +   * @param that The bloom filter to check for merge compatability., +   *, +   * @since 15.0, +   */, +  public boolean canMergeWith(BloomFilter that) {, +    checkNotNull(that);, +    return (this != that) &&, +        (this.numHashFunctions == that.numHashFunctions) &&, +        (this.size() == that.size()) &&, +        (this.strategy.equals(that.strategy)) &&, +        (this.funnel.equals(that.funnel));, +   * @throws IllegalArgumentException if {@code canMergeWith(that) == false}, +  @Override, +  public boolean equals(@Nullable Object object) {, +    if (object == this) {, +      return true;, +    }, +    if (object instanceof BloomFilter) {, +      BloomFilter<?> that = (BloomFilter<?>) object;, +      return this.numHashFunctions == that.numHashFunctions, +          && this.funnel.equals(that.funnel), +          && this.bits.equals(that.bits), +          && this.strategy.equals(that.strategy);, +    }, +    return false;, +  }, +, +  @Override, +  public int hashCode() {, +    return Objects.hashCode(numHashFunctions, funnel, strategy, bits);, +  }, +]