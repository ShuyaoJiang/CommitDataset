[+++ b/android/guava-tests/benchmark/com/google/common/collect/ConcurrentHashMultisetBenchmark.java, +    @Override, +    Iterator<E> elementIterator() {, +      throw new AssertionError("should never be called");, +    }, +, +++ b/android/guava-tests/benchmark/com/google/common/collect/ConcurrentHashMultisetBenchmark.java, +    @Override, +    Iterator<E> elementIterator() {, +      throw new AssertionError("should never be called");, +    }, +, +++ b/android/guava-tests/test/com/google/common/collect/SimpleAbstractMultisetTest.java, +    Iterator<E> elementIterator() {, +      return Multisets.elementIterator(entryIterator());, +    }, +, +    @Override, +++ b/android/guava-tests/benchmark/com/google/common/collect/ConcurrentHashMultisetBenchmark.java, +    @Override, +    Iterator<E> elementIterator() {, +      throw new AssertionError("should never be called");, +    }, +, +++ b/android/guava-tests/test/com/google/common/collect/SimpleAbstractMultisetTest.java, +    Iterator<E> elementIterator() {, +      return Multisets.elementIterator(entryIterator());, +    }, +, +    @Override, +++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java, +import java.io.IOException;, +import java.io.ObjectInputStream;, +import java.io.ObjectOutputStream;, +import java.util.NoSuchElementException;, +  transient ObjectCountHashMap<E> backingMap;, +  transient long size;, +  AbstractMapBasedMultiset(int distinctElements) {, +    init(distinctElements);, +  abstract void init(int distinctElements);, +  public final int count(@NullableDecl Object element) {, +  public final int add(@NullableDecl E element, int occurrences) {, +    int entryIndex = backingMap.indexOf(element);, +    if (entryIndex == -1) {, +      backingMap.put(element, occurrences);, +      size += occurrences;, +      return 0;, +    }, +    int oldCount = backingMap.getValue(entryIndex);, +    backingMap.setValue(entryIndex, (int) newCount);, +  public final int remove(@NullableDecl Object element, int occurrences) {, +    int entryIndex = backingMap.indexOf(element);, +    if (entryIndex == -1) {, +      return 0;, +    }, +    int oldCount = backingMap.getValue(entryIndex);, +      backingMap.setValue(entryIndex, oldCount - occurrences);, +      backingMap.removeEntry(entryIndex);, +  public final int setCount(@NullableDecl E element, int count) {, +  @Override, +  public final boolean setCount(@NullableDecl E element, int oldCount, int newCount) {, +    checkNonnegative(oldCount, "oldCount");, +    checkNonnegative(newCount, "newCount");, +    int entryIndex = backingMap.indexOf(element);, +    if (entryIndex == -1) {, +      if (oldCount != 0) {, +        return false;, +      }, +      if (newCount > 0) {, +        backingMap.put(element, newCount);, +        size += newCount;, +      }, +      return true;, +    }, +    int actualOldCount = backingMap.getValue(entryIndex);, +    if (actualOldCount != oldCount) {, +      return false;, +    }, +    if (newCount == 0) {, +      backingMap.removeEntry(entryIndex);, +      size -= oldCount;, +    } else {, +      backingMap.setValue(entryIndex, newCount);, +      size += newCount - oldCount;, +    }, +    return true;, +  @Override, +  public final void clear() {, +    backingMap.clear();, +    size = 0;, +  }, +, +  /**, +   * Skeleton of per-entry iterators. We could push this down and win a few bytes, but it's complex, +   * enough it's not especially worth it., +   */, +  abstract class Itr<T> implements Iterator<T> {, +    int entryIndex = backingMap.firstIndex();, +    int toRemove = -1;, +    int expectedModCount = backingMap.modCount;]