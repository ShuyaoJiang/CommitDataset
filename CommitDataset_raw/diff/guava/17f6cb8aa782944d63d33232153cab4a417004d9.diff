[+++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +    // mutable types, +    // The following 4 aren't really safe generically, +    // For example, Comparable<String> can't be 0., +    setDefault(Class.class, Class.class);, +    return NullValues.get(type);, +++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +    // mutable types, +    // The following 4 aren't really safe generically, +    // For example, Comparable<String> can't be 0., +    setDefault(Class.class, Class.class);, +    return NullValues.get(type);, +++ b/guava-testlib/src/com/google/common/testing/NullValues.java, +// Copyright 2012 Google Inc. All Rights Reserved., +, +package com.google.common.testing;, +, +import com.google.common.annotations.Beta;, +import com.google.common.base.Defaults;, +import com.google.common.base.Predicate;, +import com.google.common.base.Predicates;, +import com.google.common.collect.ClassToInstanceMap;, +import com.google.common.collect.ImmutableClassToInstanceMap;, +import com.google.common.collect.ImmutableCollection;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.ImmutableMap;, +import com.google.common.collect.ImmutableMultimap;, +import com.google.common.collect.ImmutableMultiset;, +import com.google.common.collect.ImmutableSet;, +import com.google.common.collect.ImmutableSortedMap;, +import com.google.common.collect.ImmutableSortedSet;, +import com.google.common.collect.ImmutableTable;, +import com.google.common.collect.Iterators;, +import com.google.common.collect.Multimap;, +import com.google.common.collect.Multiset;, +import com.google.common.collect.Ordering;, +import com.google.common.collect.Table;, +import com.google.common.primitives.Primitives;, +, +import java.lang.reflect.Array;, +import java.lang.reflect.Constructor;, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Modifier;, +import java.util.Collection;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +import java.util.ListIterator;, +import java.util.Map;, +import java.util.Set;, +import java.util.SortedMap;, +import java.util.SortedSet;, +import java.util.concurrent.TimeUnit;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +import java.util.regex.Pattern;, +, +import javax.annotation.Nullable;, +, +/**, + * Can provide an appropriate "null value" for a wide variety of types., + *, + * @author kevinb@google.com (Kevin Bourrilllion), + * @author benyu@google.com (Jige Yu), + * @since 12.0, + */, +@Beta, +public final class NullValues {, +, +  // Compare by toString() to satisfy 2 properties:, +  // 1. compareTo(null) should throw NullPointerException, +  // 2. the order is deterministic and easy to understand, for debugging purpose., +  private static final Comparable<Object> BY_TO_STRING = new Comparable<Object>() {, +    @Override public int compareTo(Object o) {, +      return toString().compareTo(o.toString());, +    }, +    @Override public String toString() {, +      return "BY_TO_STRING";, +    }, +  };, +, +  // Always equal is a valid total ordering. And it works for any Object., +  private static final Ordering<Object> ALWAYS_EQUAL = new Ordering<Object>() {, +    @Override public int compare(Object o1, Object o2) {, +      return 0;, +    }, +    @Override public String toString() {, +      return "ALWAYS_EQUAL";, +    }, +  };, +, +  private static final ClassToInstanceMap<Object> DEFAULTS = ImmutableClassToInstanceMap.builder(), +      .put(Object.class, new Object()), +      .put(CharSequence.class, ""), +      .put(String.class, ""), +      .put(Number.class, 0), +      .put(Pattern.class, Pattern.compile("")), +      .put(TimeUnit.class, TimeUnit.SECONDS), +      // All collections are immutable empty. So safe for any type parameter., +      .put(Collection.class, ImmutableList.of())]