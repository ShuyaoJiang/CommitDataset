[+++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +    List<Object> equalArgs = generateEqualFactoryArguments(factory, params, args);, +    argGroups.add(ImmutableList.of(args, equalArgs));, +    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));, +  /**, +   * Returns dummy factory arguments that are equal to {@code args} but may be different instances,, +   * to be used to construct a second instance of the same equality group., +   */, +  private List<Object> generateEqualFactoryArguments(, +      Invokable<?, ?> factory, List<Parameter> params, List<Object> args), +      throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,, +      InvocationTargetException, IllegalAccessException {, +    List<Object> equalArgs = Lists.newArrayList(args);, +    for (int i = 0; i < args.size(); i++) {, +      Parameter param = params.get(i);, +      Object arg = args.get(i);, +      // Use new fresh value generator because 'args' were populated with new fresh generator each., +      // Two newFreshValueGenerator() instances should normally generate equal value sequence., +      Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());, +      if (arg != shouldBeEqualArg, +          && Objects.equal(arg, shouldBeEqualArg), +          && hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg), +          && hashCodeInsensitiveToArgReference(, +              factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {, +        // If the implementation uses identityHashCode(), referential equality is, +        // probably intended. So no point in using an equal-but-different factory argument., +        // We check twice to avoid confusion caused by accidental hash collision., +        equalArgs.set(i, shouldBeEqualArg);, +      }, +    }, +    return equalArgs;, +  }, +, +  private static boolean hashCodeInsensitiveToArgReference(, +      Invokable<?, ?> factory, List<Object> args, int i, Object alternateArg), +      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {, +    List<Object> tentativeArgs = Lists.newArrayList(args);, +    tentativeArgs.set(i, alternateArg);, +    return createInstance(factory, tentativeArgs).hashCode(), +        == createInstance(factory, args).hashCode();, +  }, +, +++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java, +    List<Object> equalArgs = generateEqualFactoryArguments(factory, params, args);, +    argGroups.add(ImmutableList.of(args, equalArgs));, +    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));, +  /**, +   * Returns dummy factory arguments that are equal to {@code args} but may be different instances,, +   * to be used to construct a second instance of the same equality group., +   */, +  private List<Object> generateEqualFactoryArguments(, +      Invokable<?, ?> factory, List<Parameter> params, List<Object> args), +      throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,, +      InvocationTargetException, IllegalAccessException {, +    List<Object> equalArgs = Lists.newArrayList(args);, +    for (int i = 0; i < args.size(); i++) {, +      Parameter param = params.get(i);, +      Object arg = args.get(i);, +      // Use new fresh value generator because 'args' were populated with new fresh generator each., +      // Two newFreshValueGenerator() instances should normally generate equal value sequence., +      Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());, +      if (arg != shouldBeEqualArg, +          && Objects.equal(arg, shouldBeEqualArg), +          && hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg), +          && hashCodeInsensitiveToArgReference(, +              factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {, +        // If the implementation uses identityHashCode(), referential equality is, +        // probably intended. So no point in using an equal-but-different factory argument., +        // We check twice to avoid confusion caused by accidental hash collision., +        equalArgs.set(i, shouldBeEqualArg);, +      }, +    }, +    return equalArgs;, +  }, +, +  private static boolean hashCodeInsensitiveToArgReference(, +      Invokable<?, ?> factory, List<Object> args, int i, Object alternateArg), +      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {, +    List<Object> tentativeArgs = Lists.newArrayList(args);, +    tentativeArgs.set(i, alternateArg);, +    return createInstance(factory, tentativeArgs).hashCode(), +        == createInstance(factory, args).hashCode();, +  }, +, +++ b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java, +    Method generator = GENERATORS.get(rawType);, +    return Reflection.newProxy(interfaceType, new FreshInvocationHandler(interfaceType));, +  }, +, +  private final class FreshInvocationHandler extends AbstractInvocationHandler {, +    private final int identity = freshInt();, +    private final Class<?> interfaceType;, +    , +    FreshInvocationHandler(Class<?> interfaceType) {, +      this.interfaceType = interfaceType;, +    }, +, +, +    @Override public int hashCode() {, +      return identity;]