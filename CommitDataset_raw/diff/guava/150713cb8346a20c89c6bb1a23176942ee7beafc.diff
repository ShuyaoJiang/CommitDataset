[+++ b/guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java, +import static com.google.common.truth.Truth.assertThat;, +    assertThat(startupTimes.get(a)).isInclusivelyInRange(150, Long.MAX_VALUE);, +    assertThat(startupTimes.get(b)).isInclusivelyInRange(353, Long.MAX_VALUE);, +  }, +, +  public void testServiceStartupTimes_selfStartingServices() {, +    // This tests to ensure that:, +    // 1. service times are accurate when the service is started by the manager, +    // 2. service times are recorded when the service is not started by the manager (but they may, +    // not be accurate)., +    final Service b = new NoOpDelayedSerivce(353) {, +      @Override protected void doStart() {, +        super.doStart();, +        // This will delay service listener execution, +        Uninterruptibles.sleepUninterruptibly(150, TimeUnit.MILLISECONDS);, +      }, +    };, +    Service a = new NoOpDelayedSerivce(150) {, +      @Override protected void doStart() {, +        b.startAsync();, +        super.doStart();, +      }, +    };, +    ServiceManager serviceManager = new ServiceManager(asList(a, b));, +    serviceManager.startAsync().awaitHealthy();, +    ImmutableMap<Service, Long> startupTimes = serviceManager.startupTimes();, +    assertEquals(2, startupTimes.size());, +    assertThat(startupTimes.get(a)).isInclusivelyInRange(150, Long.MAX_VALUE);, +    assertThat(startupTimes.get(b)).isInclusivelyInRange(0, 353 - 150);, +++ b/guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java, +import static com.google.common.truth.Truth.assertThat;, +    assertThat(startupTimes.get(a)).isInclusivelyInRange(150, Long.MAX_VALUE);, +    assertThat(startupTimes.get(b)).isInclusivelyInRange(353, Long.MAX_VALUE);, +  }, +, +  public void testServiceStartupTimes_selfStartingServices() {, +    // This tests to ensure that:, +    // 1. service times are accurate when the service is started by the manager, +    // 2. service times are recorded when the service is not started by the manager (but they may, +    // not be accurate)., +    final Service b = new NoOpDelayedSerivce(353) {, +      @Override protected void doStart() {, +        super.doStart();, +        // This will delay service listener execution, +        Uninterruptibles.sleepUninterruptibly(150, TimeUnit.MILLISECONDS);, +      }, +    };, +    Service a = new NoOpDelayedSerivce(150) {, +      @Override protected void doStart() {, +        b.startAsync();, +        super.doStart();, +      }, +    };, +    ServiceManager serviceManager = new ServiceManager(asList(a, b));, +    serviceManager.startAsync().awaitHealthy();, +    ImmutableMap<Service, Long> startupTimes = serviceManager.startupTimes();, +    assertEquals(2, startupTimes.size());, +    assertThat(startupTimes.get(a)).isInclusivelyInRange(150, Long.MAX_VALUE);, +    assertThat(startupTimes.get(b)).isInclusivelyInRange(0, 353 - 150);, +++ b/guava/src/com/google/common/util/concurrent/ServiceManager.java, +        state.tryStartTiming(service);, +    }, +, +    /**, +     * Attempts to start the timer immediately prior to the service being started via , +     * {@link Service#startAsync()}., +     */, +    void tryStartTiming(Service service) {, +      monitor.enter();, +      try {, +        Stopwatch stopwatch = startupTimers.get(service);, +        if (stopwatch == null) {, +          startupTimers.put(service, Stopwatch.createStarted());, +        }, +      } finally {, +        monitor.leave();, +        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());, +        // N.B. There will only be an entry in the map if the service has started, +          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {, +        if (stopwatch == null) {, +          // This means the service was started by some means other than ServiceManager.startAsync, +          stopwatch = Stopwatch.createStarted();, +          startupTimers.put(service, stopwatch);, +          // N.B. if we miss the STARTING event then we may never record a startup time.]