[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                value = valueReference.get();, +                boolean absent = (value == null);, +                if (absent) {, +                } else {, +                  recordRead(entry);, +                  return value;, +                }, +      // All computation lookups go through waitForValue. This method thus is, +      // only used by put, to whom we always want to appear absent., +      return null;, +, +      // Call setValueReference first to avoid put clearing us., +      segmentFor(hash).put(key, hash, value, true);, +      return value;, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                value = valueReference.get();, +                boolean absent = (value == null);, +                if (absent) {, +                } else {, +                  recordRead(entry);, +                  return value;, +                }, +      // All computation lookups go through waitForValue. This method thus is, +      // only used by put, to whom we always want to appear absent., +      return null;, +, +      // Call setValueReference first to avoid put clearing us., +      segmentFor(hash).put(key, hash, value, true);, +      return value;, +++ b/src/com/google/common/collect/Constraints.java, +    return (Constraint<E>) NotNullConstraint.INSTANCE;, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                value = valueReference.get();, +                boolean absent = (value == null);, +                if (absent) {, +                } else {, +                  recordRead(entry);, +                  return value;, +                }, +      // All computation lookups go through waitForValue. This method thus is, +      // only used by put, to whom we always want to appear absent., +      return null;, +, +      // Call setValueReference first to avoid put clearing us., +      segmentFor(hash).put(key, hash, value, true);, +      return value;, +++ b/src/com/google/common/collect/Constraints.java, +    return (Constraint<E>) NotNullConstraint.INSTANCE;, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +              // two cases en entry must be evicted. This entry could be both, +              // partially-collected and next on the eviction list, which is why, +              // notifyValueReclaimed must be called prior to evictEntries., +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                value = valueReference.get();, +                boolean absent = (value == null);, +                if (absent) {, +                } else {, +                  recordRead(entry);, +                  return value;, +                }, +      // All computation lookups go through waitForValue. This method thus is, +      // only used by put, to whom we always want to appear absent., +      return null;, +, +      // Call setValueReference first to avoid put clearing us., +      segmentFor(hash).put(key, hash, value, true);, +      return value;, +++ b/src/com/google/common/collect/Constraints.java, +    return (Constraint<E>) NotNullConstraint.INSTANCE;, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +              // two cases en entry must be evicted. This entry could be both, +              // partially-collected and next on the eviction list, which is why, +              // notifyValueReclaimed must be called prior to evictEntries., +++ b/src/com/google/common/collect/ExplicitOrderedImmutableSortedSet.java, +    ExplicitOrdering<E> eo = (ExplicitOrdering<E>) comparator();, +    return eo.rankMap;, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +                value = valueReference.get();, +                boolean absent = (value == null);, +                if (absent) {, +                } else {, +                  recordRead(entry);, +                  return value;, +                }, +      // All computation lookups go through waitForValue. This method thus is, +      // only used by put, to whom we always want to appear absent., +      return null;, +, +      // Call setValueReference first to avoid put clearing us., +      segmentFor(hash).put(key, hash, value, true);, +      return value;, +++ b/src/com/google/common/collect/Constraints.java, +    return (Constraint<E>) NotNullConstraint.INSTANCE;, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +              // two cases en entry must be evicted. This entry could be both, +              // partially-collected and next on the eviction list, which is why, +              // notifyValueReclaimed must be called prior to evictEntries., +++ b/src/com/google/common/collect/ExplicitOrderedImmutableSortedSet.java, +    ExplicitOrdering<E> eo = (ExplicitOrdering<E>) comparator();]