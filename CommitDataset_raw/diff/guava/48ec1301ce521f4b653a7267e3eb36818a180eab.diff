[+++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +import com.google.common.collect.MapMaker.NullListener;, +import java.util.concurrent.Executor;, +    evictionListener = builder.getEvictionListener();, +    evictionNotificationQueue = (evictionListener == NullListener.INSTANCE), +        ? CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue(), +        : new ConcurrentLinkedQueue<ReferenceEntry<K, V>>();, +      recencyQueue = (evictsBySize() || expires()), +          ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>(), +          : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();, +    checkNotNull(value);, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +import com.google.common.collect.MapMaker.NullListener;, +import java.util.concurrent.Executor;, +    evictionListener = builder.getEvictionListener();, +    evictionNotificationQueue = (evictionListener == NullListener.INSTANCE), +        ? CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue(), +        : new ConcurrentLinkedQueue<ReferenceEntry<K, V>>();, +      recencyQueue = (evictsBySize() || expires()), +          ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>(), +          : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();, +    checkNotNull(value);, +++ b/src/com/google/common/collect/MapMaker.java, +import java.util.AbstractMap;, +import java.util.Collections;, +import java.util.Set;, +  @SuppressWarnings("unchecked"), +  enum NullListener implements MapEvictionListener {, +    INSTANCE;, +    @Override public void onEviction(Object key, Object value) {}, +  }, +, +  boolean useNullMap;, +   * <p>When {@code size} is zero, elements can be successfully added to the, +   * map, but are evicted immediately., +   *, +   * @throws IllegalArgumentException if {@code size} is negative, +    checkArgument(size >= 0, "maximum size must not be negative");, +    this.useNullMap |= (maximumSize == 0);, +   * <p>When {@code duration} is zero, elements can be successfully added to the, +   * map, but are evicted immediately., +   *, +   * @throws IllegalArgumentException if {@code duration} is negative, +    useNullMap |= (duration == 0);, +    checkArgument(duration >= 0, "duration cannot be negative: %s %s",, +   * <p>When {@code duration} is zero, elements can be successfully added to the, +   * map, but are evicted immediately., +   *, +   * @throws IllegalArgumentException if {@code duration} is negative, +    useNullMap |= (duration == 0);, +  // TODO(kevinb): should this go in GenericMapMaker to avoid casts?, +  @SuppressWarnings("unchecked"), +  <K, V> MapEvictionListener<K, V> getEvictionListener() {, +    return evictionListener == null, +        ? (MapEvictionListener<K, V>) NullListener.INSTANCE, +        : (MapEvictionListener<K, V>) evictionListener;, +  }, +, +    if (!useCustomMap) {, +      return new ConcurrentHashMap<K, V>(getInitialCapacity(),, +    return useNullMap, +        ? new NullConcurrentMap<K, V>(this), +        : new CustomConcurrentHashMap<K, V>(this);, +  }, +    return useNullMap, +        ? new NullComputingConcurrentMap<K, V>(this, computingFunction), +        : new ComputingConcurrentHashMap<K, V>(this, computingFunction);, +  /** A map that is always empty and evicts on insertion. */, +  static class NullConcurrentMap<K, V> extends AbstractMap<K, V>, +      implements ConcurrentMap<K, V>, Serializable {, +    private static final long serialVersionUID = 0;, +, +    final MapEvictionListener<K, V> evictionListener;, +, +    NullConcurrentMap(MapMaker mapMaker) {, +      evictionListener = mapMaker.getEvictionListener();, +    }, +, +    @Override, +    public boolean containsKey(Object key) {, +      checkNotNull(key);, +      return false;, +    }, +, +    @Override, +    public boolean containsValue(Object value) {, +      checkNotNull(value);, +      return false;, +    }, +, +    @Override, +    public V get(Object key) {, +      checkNotNull(key);, +      return null;, +    }, +, +    @Override, +    public V put(K key, V value) {, +      checkNotNull(key);, +      checkNotNull(value);]