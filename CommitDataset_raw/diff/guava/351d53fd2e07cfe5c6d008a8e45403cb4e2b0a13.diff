[+++ b/guava-tests/test/com/google/common/util/concurrent/PackageSanityTests.java, +import com.google.common.util.concurrent.RateLimiter.SleepingStopwatch;, +  private static final SleepingStopwatch NO_OP_STOPWATCH = new SleepingStopwatch() {, +    @Override, +    long readMicros() {, +      return 0;, +    }, +, +    @Override, +    void sleepMicrosUninterruptibly(long micros) {, +    }, +  };, +, +    setDefault(SleepingStopwatch.class, NO_OP_STOPWATCH);, +    setDefault(long.class, 0L);, +++ b/guava-tests/test/com/google/common/util/concurrent/PackageSanityTests.java, +import com.google.common.util.concurrent.RateLimiter.SleepingStopwatch;, +  private static final SleepingStopwatch NO_OP_STOPWATCH = new SleepingStopwatch() {, +    @Override, +    long readMicros() {, +      return 0;, +    }, +, +    @Override, +    void sleepMicrosUninterruptibly(long micros) {, +    }, +  };, +, +    setDefault(SleepingStopwatch.class, NO_OP_STOPWATCH);, +    setDefault(long.class, 0L);, +++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +import com.google.common.util.concurrent.SmoothRateLimiter.SmoothBursty;, +import com.google.common.util.concurrent.SmoothRateLimiter.SmoothWarmingUp;, +++ b/guava-tests/test/com/google/common/util/concurrent/PackageSanityTests.java, +import com.google.common.util.concurrent.RateLimiter.SleepingStopwatch;, +  private static final SleepingStopwatch NO_OP_STOPWATCH = new SleepingStopwatch() {, +    @Override, +    long readMicros() {, +      return 0;, +    }, +, +    @Override, +    void sleepMicrosUninterruptibly(long micros) {, +    }, +  };, +, +    setDefault(SleepingStopwatch.class, NO_OP_STOPWATCH);, +    setDefault(long.class, 0L);, +++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +import com.google.common.util.concurrent.SmoothRateLimiter.SmoothBursty;, +import com.google.common.util.concurrent.SmoothRateLimiter.SmoothWarmingUp;, +++ b/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java, +/*, + * Copyright (C) 2012 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static java.lang.Math.min;, +import static java.util.concurrent.TimeUnit.SECONDS;, +, +import java.util.concurrent.TimeUnit;, +, +abstract class SmoothRateLimiter extends RateLimiter {, +  /*, +   * How is the RateLimiter designed, and why?, +   *, +   * The primary feature of a RateLimiter is its "stable rate", the maximum rate that, +   * is should allow at normal conditions. This is enforced by "throttling" incoming, +   * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time,, +   * and make the calling thread wait as much., +   *, +   * The simplest way to maintain a rate of QPS is to keep the timestamp of the last, +   * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example,, +   * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted, +   * earlier than 200ms after the last one, then we achieve the intended rate., +   * If a request comes and the last request was granted only 100ms ago, then we wait for, +   * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request), +   * naturally takes 3 seconds., +   *, +   * It is important to realize that such a RateLimiter has a very superficial memory, +   * of the past: it only remembers the last request. What if the RateLimiter was unused for, +   * a long period of time, then a request arrived and was immediately granted?, +   * This RateLimiter would immediately forget about that past underutilization. This may, +   * result in either underutilization or overflow, depending on the real world consequences, +   * of not using the expected rate., +   *, +   * Past underutilization could mean that excess resources are available. Then, the RateLimiter]