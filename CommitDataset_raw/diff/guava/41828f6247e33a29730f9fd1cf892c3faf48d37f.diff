[+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  public void testCreateAndCheckBloomFilterWithKnownFalsePositives64() {, +    int numInsertions = 1000000;, +    BloomFilter<CharSequence> bf = BloomFilter.create(, +        Funnels.unencodedCharsFunnel(), numInsertions, 0.03,, +        BloomFilterStrategies.MURMUR128_MITZ_64);, +, +    // Insert "numInsertions" even numbers into the BF., +    for (int i = 0; i < numInsertions * 2; i += 2) {, +      bf.put(Integer.toString(i));, +    }, +, +    // Assert that the BF "might" have all of the even numbers., +    for (int i = 0; i < numInsertions * 2; i += 2) {, +      assertTrue(bf.mightContain(Integer.toString(i)));, +    }, +, +    // Now we check for known false positives using a set of known false positives., +    // (These are all of the false positives under 900.), +    ImmutableSet<Integer> falsePositives = ImmutableSet.of(, +        1, 143, 231, 287, 311, 319, 331, 421, 457, 547, 599, 659, 723);, +    for (int i = 1; i < 900; i += 2) {, +      if (!falsePositives.contains(i)) {, +        assertFalse("BF should not contain " + i, bf.mightContain(Integer.toString(i)));, +      }, +    }, +, +    // Check that there are exactly 29651 false positives for this BF., +    int knownNumberOfFalsePositives = 29651;, +    int numFpp = 0;, +    for (int i = 1; i < numInsertions * 2; i += 2) {, +      if (bf.mightContain(Integer.toString(i))) {, +        numFpp++;, +      }, +    }, +    assertEquals(knownNumberOfFalsePositives, numFpp);, +    double actualFpp = (double) knownNumberOfFalsePositives / numInsertions;, +    double expectedFpp = bf.expectedFpp();, +    // The normal order of (expected, actual) is reversed here on purpose., +    assertEquals(actualFpp, expectedFpp, 0.00033);, +  }, +, +    assertEquals(2, BloomFilterStrategies.values().length);, +    assertEquals(BloomFilterStrategies.MURMUR128_MITZ_64, BloomFilterStrategies.values()[1]);, +++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java, +  public void testCreateAndCheckBloomFilterWithKnownFalsePositives64() {, +    int numInsertions = 1000000;, +    BloomFilter<CharSequence> bf = BloomFilter.create(, +        Funnels.unencodedCharsFunnel(), numInsertions, 0.03,, +        BloomFilterStrategies.MURMUR128_MITZ_64);, +, +    // Insert "numInsertions" even numbers into the BF., +    for (int i = 0; i < numInsertions * 2; i += 2) {, +      bf.put(Integer.toString(i));, +    }, +, +    // Assert that the BF "might" have all of the even numbers., +    for (int i = 0; i < numInsertions * 2; i += 2) {, +      assertTrue(bf.mightContain(Integer.toString(i)));, +    }, +, +    // Now we check for known false positives using a set of known false positives., +    // (These are all of the false positives under 900.), +    ImmutableSet<Integer> falsePositives = ImmutableSet.of(, +        1, 143, 231, 287, 311, 319, 331, 421, 457, 547, 599, 659, 723);, +    for (int i = 1; i < 900; i += 2) {, +      if (!falsePositives.contains(i)) {, +        assertFalse("BF should not contain " + i, bf.mightContain(Integer.toString(i)));, +      }, +    }, +, +    // Check that there are exactly 29651 false positives for this BF., +    int knownNumberOfFalsePositives = 29651;, +    int numFpp = 0;, +    for (int i = 1; i < numInsertions * 2; i += 2) {, +      if (bf.mightContain(Integer.toString(i))) {, +        numFpp++;, +      }, +    }, +    assertEquals(knownNumberOfFalsePositives, numFpp);, +    double actualFpp = (double) knownNumberOfFalsePositives / numInsertions;, +    double expectedFpp = bf.expectedFpp();, +    // The normal order of (expected, actual) is reversed here on purpose., +    assertEquals(actualFpp, expectedFpp, 0.00033);, +  }, +, +    assertEquals(2, BloomFilterStrategies.values().length);, +    assertEquals(BloomFilterStrategies.MURMUR128_MITZ_64, BloomFilterStrategies.values()[1]);, +++ b/guava/src/com/google/common/hash/BloomFilterStrategies.java, +import com.google.common.primitives.Longs;, + * @author Kurt Alfred Kluever, +      long bitSize = bits.bitSize();, +, +        int combinedHash = hash1 + (i * hash2);, +        // Flip all the bits if it's negative (guaranteed positive number), +        if (combinedHash < 0) {, +          combinedHash = ~combinedHash;, +        bitsChanged |= bits.set(combinedHash % bitSize);, +      long bitSize = bits.bitSize();, +]