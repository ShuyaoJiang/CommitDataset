[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +import static com.google.common.util.concurrent.Platform.isInstanceOfThrowableClass;, +public final class Futures extends GwtFuturesCatchingSpecialization {, +   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,, +   * Class, AsyncFunction) catchingAsync(input, Throwable.class,, +   * fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code, +   * Throwable.class} with the specific type you want to handle., +   *, +   * <p>Returns a {@code Future} whose result is taken from the given primary, +   * <p>Also note that, regardless of which thread executes {@code, +   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,, +   * Class, AsyncFunction, Executor) catchingAsync(input, Throwable.class,, +   * fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing {@code, +   * Throwable.class} with the specific type you want to handle., +   *, +   * <p>Returns a {@code Future} whose result is taken from the given primary, +    return catchingAsync(, +        input, Throwable.class, asAsyncFunction(fallback), executor);, +  static <V> AsyncFunction<Throwable, V> asAsyncFunction(final FutureFallback<V> fallback) {, +    checkNotNull(fallback);, +    return new AsyncFunction<Throwable, V>() {, +      @Override, +      public ListenableFuture<V> apply(Throwable t) throws Exception {, +        return checkNotNull(fallback.create(t), "FutureFallback.create returned null instead of a ", +            + "Future. Did you mean to return immediateFuture(null)?");, +      }, +    };, +  }, +, +  static class CatchingFuture<V, X extends Throwable> extends AbstractFuture.TrustedFuture<V> {, +    CatchingFuture(ListenableFuture<? extends V> input,, +        final Class<X> exceptionType,, +        final AsyncFunction<? super X, ? extends V> fallback,, +      checkNotNull(exceptionType);, +      checkNotNull(fallback);, +, +            if (isInstanceOfThrowableClass(throwable, exceptionType)) {, +              @SuppressWarnings("unchecked") // verified safe by isInstance, +              X castThrowable = (X) throwable;, +              ListenableFuture<? extends V> replacement = fallback.apply(castThrowable);, +              checkNotNull(replacement, "AsyncFunction.apply returned null instead of a Future. ", +            } else {, +              setException(throwable);, +            }, +   * <p>Also note that, regardless of which thread executes {@code, +   * <p>Also note that, regardless of which thread executes {@code, +  static <I, O> AsyncFunction<I, O> asAsyncFunction(, +    checkNotNull(function);, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +import static com.google.common.util.concurrent.Platform.isInstanceOfThrowableClass;, +public final class Futures extends GwtFuturesCatchingSpecialization {, +   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,, +   * Class, AsyncFunction) catchingAsync(input, Throwable.class,, +   * fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code, +   * Throwable.class} with the specific type you want to handle., +   *, +   * <p>Returns a {@code Future} whose result is taken from the given primary, +   * <p>Also note that, regardless of which thread executes {@code, +   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,, +   * Class, AsyncFunction, Executor) catchingAsync(input, Throwable.class,, +   * fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing {@code, +   * Throwable.class} with the specific type you want to handle., +   *, +   * <p>Returns a {@code Future} whose result is taken from the given primary, +    return catchingAsync(, +        input, Throwable.class, asAsyncFunction(fallback), executor);, +  static <V> AsyncFunction<Throwable, V> asAsyncFunction(final FutureFallback<V> fallback) {, +    checkNotNull(fallback);, +    return new AsyncFunction<Throwable, V>() {, +      @Override, +      public ListenableFuture<V> apply(Throwable t) throws Exception {, +        return checkNotNull(fallback.create(t), "FutureFallback.create returned null instead of a ", +            + "Future. Did you mean to return immediateFuture(null)?");, +      }, +    };, +  }, +, +  static class CatchingFuture<V, X extends Throwable> extends AbstractFuture.TrustedFuture<V> {, +    CatchingFuture(ListenableFuture<? extends V> input,, +        final Class<X> exceptionType,, +        final AsyncFunction<? super X, ? extends V> fallback,, +      checkNotNull(exceptionType);, +      checkNotNull(fallback);, +, +            if (isInstanceOfThrowableClass(throwable, exceptionType)) {, +              @SuppressWarnings("unchecked") // verified safe by isInstance, +              X castThrowable = (X) throwable;, +              ListenableFuture<? extends V> replacement = fallback.apply(castThrowable);, +              checkNotNull(replacement, "AsyncFunction.apply returned null instead of a Future. ", +            } else {, +              setException(throwable);, +            }, +   * <p>Also note that, regardless of which thread executes {@code, +   * <p>Also note that, regardless of which thread executes {@code, +  static <I, O> AsyncFunction<I, O> asAsyncFunction(, +    checkNotNull(function);, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/GwtFuturesCatchingSpecialization.java, +/*, + * Copyright (C) 2006 The Guava Authors, + *]