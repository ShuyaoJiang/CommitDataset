[+++ b/guava-tests/test/com/google/common/graph/GraphsTest.java, +import java.util.Collection;, +  private static final Integer N0 = 0;, +, +  private static void containsExactlySanityCheck(Collection<?> collection, Object... varargs) {, +    assertThat(collection).hasSize(varargs.length);, +    for (Object obj : varargs) {, +      assertThat(collection).contains(obj);, +    }, +    assertThat(collection).containsExactly(varargs);, +  }, +++ b/guava-tests/test/com/google/common/graph/GraphsTest.java, +import java.util.Collection;, +  private static final Integer N0 = 0;, +, +  private static void containsExactlySanityCheck(Collection<?> collection, Object... varargs) {, +    assertThat(collection).hasSize(varargs.length);, +    for (Object obj : varargs) {, +      assertThat(collection).contains(obj);, +    }, +    assertThat(collection).containsExactly(varargs);, +  }, +++ b/guava/src/com/google/common/graph/AbstractGraph.java, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +++ b/guava-tests/test/com/google/common/graph/GraphsTest.java, +import java.util.Collection;, +  private static final Integer N0 = 0;, +, +  private static void containsExactlySanityCheck(Collection<?> collection, Object... varargs) {, +    assertThat(collection).hasSize(varargs.length);, +    for (Object obj : varargs) {, +      assertThat(collection).contains(obj);, +    }, +    assertThat(collection).containsExactly(varargs);, +  }, +++ b/guava/src/com/google/common/graph/AbstractGraph.java, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +    // TODO(b/28087289): only works for non-multigraphs; multigraphs not yet supported, +++ b/guava/src/com/google/common/graph/Graphs.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.collect.AbstractIterator;, +import com.google.common.collect.Iterators;, +import com.google.common.primitives.Ints;, +import java.util.AbstractSet;, +import java.util.Iterator;, +  private static <N> Set<Endpoints<N>> endpointsInternal(final Graph<N> graph) {, +    if (graph instanceof Network && !allowsParallelEdges(graph)) {, +      // Use an optimized implementation for networks without parallel edges., +      return endpointsSimpleNetwork(castToNetwork(graph));, +    }, +, +    return new AbstractSet<Endpoints<N>>() {, +      @Override, +      public Iterator<Endpoints<N>> iterator() {, +        return graph.isDirected(), +            ? new DirectedEndpointsIterator<N>(graph), +            : new UndirectedEndpointsIterator<N>(graph);, +      }, +, +      @Override, +      public int size() {, +        boolean directed = graph.isDirected();, +        long endpointsCount = 0L;, +        for (N node : graph.nodes()) {, +          Set<N> successors = graph.successors(node);, +          endpointsCount += successors.size();, +          if (!directed && successors.contains(node)) {, +            endpointsCount++; // count self-loops twice in the undirected case, +          }, +        }, +        if (!directed) {, +          // In undirected graphs, every pair of adjacent nodes has been counted twice., +          checkState((endpointsCount & 1) == 0);, +          endpointsCount >>>= 1;, +        }, +        return Ints.saturatedCast(endpointsCount);, +      }, +, +      @Override, +      public boolean contains(Object obj) {, +        if (!(obj instanceof Endpoints)) {, +          return false;, +        }, +        return containsEndpoints(graph, (Endpoints<?>) obj);, +      }, +    };, +  }, +, +  private static <N> Set<Endpoints<N>> endpointsSimpleNetwork(final Network<N, ?> graph) {, +    checkState(!graph.allowsParallelEdges());, +    return new AbstractSet<Endpoints<N>>() {, +      @Override, +      public Iterator<Endpoints<N>> iterator() {, +        return Iterators.transform(, +            graph.edges().iterator(),, +            new Function<Object, Endpoints<N>>() {, +              @Override]