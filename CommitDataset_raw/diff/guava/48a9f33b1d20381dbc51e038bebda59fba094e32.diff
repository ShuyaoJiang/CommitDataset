[+++ b/guava/src/com/google/common/io/Files.java, +   , + /**, +  * Returns the lexically cleaned form of the path name:, +  * , +  * <ul>, +  * <li>empty string becomes ., +  * <li>fold out ../ when possible, +  * <li>fold out ./ when possible, +  * <li>collapse multiple slashes, +  * </li>delete trailing slashes (unless the path is just "/"), +  * </ul>, +  */, +  public static String simplifyPath(String pathname) {, +    if (pathname.length() == 0) {, +      return ".";, +    }, +    char[] name = pathname.toCharArray();, +    // In place, rewrite name to compress multiple /, eliminate ., and process .., +, +    boolean rooted = (name[0] == '/');, +, +    // invariants:, +    //  p points at beginning of path element we're considering., +    //  q points just past the last path element we wrote (no slash)., +    //  dotdot points just past the point where .. cannot backtrack, +    //    any further (no slash)., +    int firstNonSlash = rooted ? 1 : 0;, +    int p = firstNonSlash;, +    int q = firstNonSlash;, +    int dotdot = firstNonSlash;, +    while (p < name.length) {, +      if (name[p] == '/') {, +        /* null element */, +        p++;, +      } else if (name[p] == '.' && sep(name, p + 1)) {, +        /* don't count the separator in case it is null */, +        p += 1;, +      } else if (name[p] == '.', +          && ((p + 1) < name.length  && name[p + 1] == '.'), +          && sep(name, p + 2)) {, +        p += 2;, +        if (q > dotdot) {, +          /* can backtrack */, +          while (--q > dotdot && name[q] != '/') {, +, +          }, +        } else if (!rooted) {, +          /* /.. is / but ./../ is .. */, +          if (name[q] != name[0] || , +              (name.length >= q+3 && name[0] == '.' && name[name.length - 1] != '/')) {, +            name[q++] = '/';, +          }, +          name[q++] = '.';, +          name[q++] = '.';, +          dotdot = q;, +        }, +      } else {, +        /* real path element */, +        if (name[q] != name[firstNonSlash]) {, +          name[q++] = '/';, +        }, +        while ((q < name.length && p < name.length) &&, +            (name[q] = name[p]) != '/') {, +          p++;, +          q++;, +        }, +      }, +    }, +    return new String(name, 0, q);, +  }, +, +  private static boolean sep(char[] a, int pos) {, +    return (pos == a.length) || (a[pos] == '/');, +  }, +  ]