[+++ b/android/guava-tests/test/com/google/common/collect/ForwardingMapTest.java, +import com.google.common.reflect.Parameter;, +import com.google.common.reflect.TypeToken;, +    callAllPublicMethods(new TypeToken<Set<Entry<String, Boolean>>>() {}, forward.entrySet());, +    callAllPublicMethods(new TypeToken<Set<String>>() {}, forward.keySet());, +    callAllPublicMethods(new TypeToken<Collection<Boolean>>() {}, forward.values());, +  private static final ImmutableMap<String, String> JUF_METHODS = ImmutableMap.of(, +      "java.util.function.Predicate", "test",, +      "java.util.function.Consumer", "accept",, +      "java.util.function.IntFunction", "apply");, +, +  private static Object getDefaultValue(final TypeToken<?> type) {, +    Class<?> rawType = type.getRawType();, +    Object defaultValue = ArbitraryInstances.get(rawType);, +, +    final String typeName = rawType.getCanonicalName();, +    if (JUF_METHODS.containsKey(typeName)) {, +          rawType,, +              if (method.getName().equals(JUF_METHODS.get(typeName))) {, +                return getDefaultValue(type.method(method).getReturnType());, +  private static <T> void callAllPublicMethods(TypeToken<T> type, T object), +    for (Method method : type.getRawType().getMethods()) {, +      ImmutableList<Parameter> parameters = type.method(method).getParameters();, +      Object[] args = new Object[parameters.size()];, +      for (int i = 0; i < parameters.size(); i++) {, +        args[i] = getDefaultValue(parameters.get(i).getType());, +          method.invoke(object, args);, +            cause, method + " with args: " + Arrays.toString(args));, +++ b/android/guava-tests/test/com/google/common/collect/ForwardingMapTest.java, +import com.google.common.reflect.Parameter;, +import com.google.common.reflect.TypeToken;, +    callAllPublicMethods(new TypeToken<Set<Entry<String, Boolean>>>() {}, forward.entrySet());, +    callAllPublicMethods(new TypeToken<Set<String>>() {}, forward.keySet());, +    callAllPublicMethods(new TypeToken<Collection<Boolean>>() {}, forward.values());, +  private static final ImmutableMap<String, String> JUF_METHODS = ImmutableMap.of(, +      "java.util.function.Predicate", "test",, +      "java.util.function.Consumer", "accept",, +      "java.util.function.IntFunction", "apply");, +, +  private static Object getDefaultValue(final TypeToken<?> type) {, +    Class<?> rawType = type.getRawType();, +    Object defaultValue = ArbitraryInstances.get(rawType);, +, +    final String typeName = rawType.getCanonicalName();, +    if (JUF_METHODS.containsKey(typeName)) {, +          rawType,, +              if (method.getName().equals(JUF_METHODS.get(typeName))) {, +                return getDefaultValue(type.method(method).getReturnType());, +  private static <T> void callAllPublicMethods(TypeToken<T> type, T object), +    for (Method method : type.getRawType().getMethods()) {, +      ImmutableList<Parameter> parameters = type.method(method).getParameters();, +      Object[] args = new Object[parameters.size()];, +      for (int i = 0; i < parameters.size(); i++) {, +        args[i] = getDefaultValue(parameters.get(i).getType());, +          method.invoke(object, args);, +            cause, method + " with args: " + Arrays.toString(args));, +++ b/guava-tests/test/com/google/common/collect/ForwardingMapTest.java, +import com.google.common.reflect.Parameter;, +import com.google.common.reflect.TypeToken;, +    callAllPublicMethods(new TypeToken<Set<Entry<String, Boolean>>>() {}, forward.entrySet());, +    callAllPublicMethods(new TypeToken<Set<String>>() {}, forward.keySet());, +    callAllPublicMethods(new TypeToken<Collection<Boolean>>() {}, forward.values());, +  private static final ImmutableMap<String, String> JUF_METHODS = ImmutableMap.of(, +      "java.util.function.Predicate", "test",, +      "java.util.function.Consumer", "accept",, +      "java.util.function.IntFunction", "apply");, +, +  private static Object getDefaultValue(final TypeToken<?> type) {, +    Class<?> rawType = type.getRawType();, +    Object defaultValue = ArbitraryInstances.get(rawType);, +, +    final String typeName = rawType.getCanonicalName();, +    if (JUF_METHODS.containsKey(typeName)) {, +          rawType,, +              if (method.getName().equals(JUF_METHODS.get(typeName))) {, +                return getDefaultValue(type.method(method).getReturnType());, +  private static <T> void callAllPublicMethods(TypeToken<T> type, T object), +    for (Method method : type.getRawType().getMethods()) {, +      ImmutableList<Parameter> parameters = type.method(method).getParameters();, +      Object[] args = new Object[parameters.size()];, +      for (int i = 0; i < parameters.size(); i++) {, +        args[i] = getDefaultValue(parameters.get(i).getType());, +          method.invoke(object, args);, +            cause, method + " with args: " + Arrays.toString(args));]