[+++ b/guava/src/com/google/common/util/concurrent/AbstractService.java, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkState;, +import javax.annotation.concurrent.Immutable;, + * Base class for implementing services that can handle {@link #doStart} and {@link #doStop}, + * requests, responding to them with {@link #notifyStarted()} and {@link #notifyStopped()}, + * callbacks. Its subclasses must manage threads manually; consider, + * {@link AbstractExecutionThreadService} if you need only a single execution thread., +  private static final Logger logger = Logger.getLogger(AbstractService.class.getName());, +   * <p>Enqueue operations should be protected by {@link #lock} while dequeue operations should be, +   * protected by the implicit lock on this object. Dequeue operations should be executed atomically, +   * with the execution of the {@link Runnable} and additionally the {@link #lock} should not be, +   * held when the listeners are being executed. Use {@link #executeListeners} for this operation., +   * This is necessary to ensure that elements on the queue are executed in the correct order., +   * Enqueue operations should be protected so that listeners are added in the correct order. We use, +   * a concurrent queue implementation so that enqueues can be executed concurrently with dequeues., +  private final Queue<Runnable> queuedListeners = Queues.newConcurrentLinkedQueue();, +   * The current state of the service.  This should be written with the lock held but can be read, +   * without it because it is an immutable object in a volatile field.  This is desirable so that, +   * methods like {@link #state}, {@link #failureCause} and notably {@link #toString} can be run, +   * without grabbing the lock., +   *, +   * <p>To update this field correctly the lock must be held to guarantee that the state is, +   * consistent., +  private volatile StateSnapshot snapshot = new StateSnapshot(State.NEW);, +    // Add a listener to update the futures. This needs to be added first so that it is executed, +    // before the other listeners. This way the other listeners can access the completed futures., +                shutdown.setException(new Exception("Service failed to start.", failure));, +                shutdown.setException(new Exception("Service failed while running", failure));, +   * This method is called by {@link #start} to initiate service startup. The invocation of this, +   * method should cause a call to {@link #notifyStarted()}, either during this method's run, or, +   * after it has returned. If startup fails, the invocation should cause a call to, +   * {@link #notifyFailed(Throwable)} instead., +   * <p>This method should return promptly; prefer to do work on a different thread where it is, +   * convenient. It is invoked exactly once on service startup, even when {@link #start} is called, +   * multiple times., +   * This method should be used to initiate service shutdown. The invocation of this method should, +   * cause a call to {@link #notifyStopped()}, either during this method's run, or after it has, +   * returned. If shutdown fails, the invocation should cause a call to, +   * {@link #notifyFailed(Throwable)} instead., +   * <p> This method should return promptly; prefer to do work on a different thread where it is, +   * convenient. It is invoked exactly once on service shutdown, even when {@link #stop} is called, +   * multiple times., +      if (snapshot.state == State.NEW) {, +        snapshot = new StateSnapshot(State.STARTING);, +      switch (snapshot.state) {, +          snapshot = new StateSnapshot(State.TERMINATED);, +          snapshot = new StateSnapshot(State.STARTING, true, null);, +          snapshot = new StateSnapshot(State.STOPPING);, +          throw new AssertionError("Unexpected state: " + snapshot.state);, +   * Implementing classes should invoke this method once their service has started. It will cause, +   * the service to transition from {@link State#STARTING} to {@link State#RUNNING}., +   * @throws IllegalStateException if the service is not {@link State#STARTING}., +      if (snapshot.state != State.STARTING) {, +            "Cannot notifyStarted() when the service is " + snapshot.state);, +      if (snapshot.shutdownWhenStartupFinishes) {, +        snapshot = new StateSnapshot(State.STOPPING);, +        snapshot = new StateSnapshot(State.RUNNING);, +   * Implementing classes should invoke this method once their service has stopped. It will cause, +   * the service to transition from {@link State#STOPPING} to {@link State#TERMINATED}., +   * @throws IllegalStateException if the service is neither {@link State#STOPPING} nor, +   *         {@link State#RUNNING}., +      if (snapshot.state != State.STOPPING && snapshot.state != State.RUNNING) {, +            "Cannot notifyStopped() when the service is " + snapshot.state);, +      State previous = snapshot.state;, +      snapshot = new StateSnapshot(State.TERMINATED);, +   * Invoke this method to transition the service to the {@link State#FAILED}. The service will, +   * <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically, +   * or otherwise cannot be started nor stopped., +      switch (snapshot.state) {, +        case NEW:, +          throw new IllegalStateException("Failed while in state:" + snapshot.state, cause);, +        case RUNNING:, +        case STARTING:, +          State previous = snapshot.state;, +          snapshot = new StateSnapshot(State.FAILED, false, cause);, +          throw new AssertionError("Unexpected state: " + snapshot.state);, +    return snapshot.externalState();, +      if (snapshot.state != State.TERMINATED && snapshot.state != State.FAILED) {, +  /** A simple holder for a listener and its executor. */, +, +  /**, +   * An immutable snapshot of the current state of the service. This class represents a consistent, +   * snapshot of the state and therefore it can be used to answer simple queries without needing to, +   * grab a lock., +   */, +  @Immutable, +  private static final class StateSnapshot {, +    /**, +     * The internal state, which equals external state unless, +     * shutdownWhenStartupFinishes is true., +     */, +    final State state;, +, +    /**, +     * If true, the user requested a shutdown while the service was still starting, +     * up., +     */, +    final boolean shutdownWhenStartupFinishes;, +]