[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +import java.util.List;, +import java.util.SortedSet;, +    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE, +, +    // TODO(kevinb): Support a concurrently modified collection?, +    if (iterable instanceof List) {, +      List<E> list = (List<E>) iterable;, +      if (list.isEmpty()) {, +      return Optional.of(list.get(list.size() - 1));, +    }, +    Iterator<E> iterator = iterable.iterator();, +    if (!iterator.hasNext()) {, +      return Optional.absent();, +    }, +, +    /*, +     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users, +     * with SortedSets tend to know they are SortedSets and probably would not, +     * call this method., +     */, +    if (iterable instanceof SortedSet) {, +      SortedSet<E> sortedSet = (SortedSet<E>) iterable;, +      return Optional.of(sortedSet.last());, +    }, +, +    while (true) {, +      E current = iterator.next();, +      if (!iterator.hasNext()) {, +        return Optional.of(current);, +      }, +    }, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java, +import java.util.List;, +import java.util.SortedSet;, +    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE, +, +    // TODO(kevinb): Support a concurrently modified collection?, +    if (iterable instanceof List) {, +      List<E> list = (List<E>) iterable;, +      if (list.isEmpty()) {, +      return Optional.of(list.get(list.size() - 1));, +    }, +    Iterator<E> iterator = iterable.iterator();, +    if (!iterator.hasNext()) {, +      return Optional.absent();, +    }, +, +    /*, +     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users, +     * with SortedSets tend to know they are SortedSets and probably would not, +     * call this method., +     */, +    if (iterable instanceof SortedSet) {, +      SortedSet<E> sortedSet = (SortedSet<E>) iterable;, +      return Optional.of(sortedSet.last());, +    }, +, +    while (true) {, +      E current = iterator.next();, +      if (!iterator.hasNext()) {, +        return Optional.of(current);, +      }, +    }, +++ b/guava/src/com/google/common/collect/FluentIterable.java, +import java.util.List;, +import java.util.SortedSet;, +    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE, +, +    // TODO(kevinb): Support a concurrently modified collection?, +    if (iterable instanceof List) {, +      List<E> list = (List<E>) iterable;, +      if (list.isEmpty()) {, +      return Optional.of(list.get(list.size() - 1));, +    }, +    Iterator<E> iterator = iterable.iterator();, +    if (!iterator.hasNext()) {, +      return Optional.absent();, +    }, +, +    /*, +     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users, +     * with SortedSets tend to know they are SortedSets and probably would not, +     * call this method., +     */, +    if (iterable instanceof SortedSet) {, +      SortedSet<E> sortedSet = (SortedSet<E>) iterable;, +      return Optional.of(sortedSet.last());, +    }, +, +    while (true) {, +      E current = iterator.next();, +      if (!iterator.hasNext()) {, +        return Optional.of(current);, +      }, +    }]