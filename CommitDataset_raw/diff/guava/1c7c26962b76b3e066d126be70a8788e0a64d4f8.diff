[+++ b/guava/src/com/google/common/cache/CacheBuilder.java, +++ b/guava/src/com/google/common/cache/CacheBuilder.java, +++ b/guava/src/com/google/common/cache/ComputingCache.java, + * Exposes a {@link CustomConcurrentHashMap} as a {@code Cache}., +  final CustomConcurrentHashMap<K, V> map;, +    this.map = new CustomConcurrentHashMap<K, V>(builder, statsCounterSupplier, loader);, +    private final CustomConcurrentHashMap<K, V> delegate;, +    CacheAsMap(CustomConcurrentHashMap<K, V> delegate) {, +++ b/guava/src/com/google/common/cache/CacheBuilder.java, +++ b/guava/src/com/google/common/cache/ComputingCache.java, + * Exposes a {@link CustomConcurrentHashMap} as a {@code Cache}., +  final CustomConcurrentHashMap<K, V> map;, +    this.map = new CustomConcurrentHashMap<K, V>(builder, statsCounterSupplier, loader);, +    private final CustomConcurrentHashMap<K, V> delegate;, +    CacheAsMap(CustomConcurrentHashMap<K, V> delegate) {, +++ /dev/null, +++ b/guava/src/com/google/common/cache/CacheBuilder.java, +++ b/guava/src/com/google/common/cache/ComputingCache.java, + * Exposes a {@link CustomConcurrentHashMap} as a {@code Cache}., +  final CustomConcurrentHashMap<K, V> map;, +    this.map = new CustomConcurrentHashMap<K, V>(builder, statsCounterSupplier, loader);, +    private final CustomConcurrentHashMap<K, V> delegate;, +    CacheAsMap(CustomConcurrentHashMap<K, V> delegate) {, +++ /dev/null, +++ b/guava/src/com/google/common/cache/CustomConcurrentHashMap.java, +  final CacheLoader<? super K, ? extends V> loader;, +, +      Supplier<? extends StatsCounter> statsCounterSupplier,, +      CacheLoader<? super K, ? extends V> loader) {, +    this.loader = checkNotNull(loader);, +, +    // computation, +, +    V getOrCompute(K key, int hash, CacheLoader<? super K, ? extends V> loader), +        throws ExecutionException {, +      try {, +        outer: while (true) {, +          // don't call getLiveEntry, which would ignore computing values, +          ReferenceEntry<K, V> e = getEntry(key, hash);, +          if (e != null) {, +            V value = getLiveValue(e);, +            if (value != null) {, +              recordRead(e);, +              statsCounter.recordHit();, +              return value;, +            }, +          }, +, +          // at this point e is either null, computing, or expired;, +          // avoid locking if it's already computing, +          if (e == null || !e.getValueReference().isComputingReference()) {, +            ComputingValueReference<K, V> computingValueReference = null;, +            lock();, +            try {, +              preWriteCleanup();, +, +              int newCount = this.count - 1;, +              AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +              int index = hash & (table.length() - 1);, +              ReferenceEntry<K, V> first = table.get(index);, +, +              boolean createNewEntry = true;, +              for (e = first; e != null; e = e.getNext()) {, +                K entryKey = e.getKey();, +                if (e.getHash() == hash && entryKey != null, +                    && map.keyEquivalence.equivalent(key, entryKey)) {, +                  ValueReference<K, V> valueReference = e.getValueReference();, +                  if (valueReference.isComputingReference()) {, +                    createNewEntry = false;, +                  } else {, +                    // never return expired entries, +                    V value = getLiveValue(e);, +                    if (value != null) {, +                      recordLockedRead(e);, +                      statsCounter.recordHit();, +                      return value;, +                    }, +                    // immediately reuse partially collected entries, +                    enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    evictionQueue.remove(e);, +                    expirationQueue.remove(e);, +                    this.count = newCount; // write-volatile, +                  }, +                  break;, +                }, +              }, +, +              if (createNewEntry) {, +                computingValueReference = new ComputingValueReference<K, V>(loader);, +, +                if (e == null) {, +                  e = newEntry(key, hash, first);, +                  table.set(index, e);, +                }, +                e.setValueReference(computingValueReference);, +              }, +            } finally {, +              unlock();, +              postWriteCleanup();, +            }]