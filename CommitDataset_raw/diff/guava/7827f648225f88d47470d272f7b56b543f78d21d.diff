[+++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/IntMath.java, +    /*, +     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation., +     *, +     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),, +     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x)), +     * is 6, then 64 <= x < 128, so floor(log10(x)) is either 1 or 2., +     */, +    int y = MAX_LOG10_FOR_LEADING_ZEROS[Integer.numberOfLeadingZeros(x)];, +    // y is the higher of the two possible values of floor(log10(x)), +, +    int sgn = (x - POWERS_OF_10[y]) >>> (Integer.SIZE - 1);, +    /*, +     * sgn is the sign bit of x - 10^y; it is 1 if x < 10^y, and 0 otherwise. If x < 10^y, then we, +     * want the lower of the two possible values, or y - 1, otherwise, we want y., +     */, +    return y - sgn;, +  // MAX_LOG10_FOR_LEADING_ZEROS[i] == floor(log10(2^(Long.SIZE - i))), +  @VisibleForTesting static final byte[] MAX_LOG10_FOR_LEADING_ZEROS = {9, 9, 9, 8, 8, 8,, +    7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0};, +, +  @VisibleForTesting static final int[] POWERS_OF_10 = {1, 10, 100, 1000, 10000,, +    100000, 1000000, 10000000, 100000000, 1000000000};, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/IntMath.java, +    /*, +     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation., +     *, +     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),, +     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x)), +     * is 6, then 64 <= x < 128, so floor(log10(x)) is either 1 or 2., +     */, +    int y = MAX_LOG10_FOR_LEADING_ZEROS[Integer.numberOfLeadingZeros(x)];, +    // y is the higher of the two possible values of floor(log10(x)), +, +    int sgn = (x - POWERS_OF_10[y]) >>> (Integer.SIZE - 1);, +    /*, +     * sgn is the sign bit of x - 10^y; it is 1 if x < 10^y, and 0 otherwise. If x < 10^y, then we, +     * want the lower of the two possible values, or y - 1, otherwise, we want y., +     */, +    return y - sgn;, +  // MAX_LOG10_FOR_LEADING_ZEROS[i] == floor(log10(2^(Long.SIZE - i))), +  @VisibleForTesting static final byte[] MAX_LOG10_FOR_LEADING_ZEROS = {9, 9, 9, 8, 8, 8,, +    7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0};, +, +  @VisibleForTesting static final int[] POWERS_OF_10 = {1, 10, 100, 1000, 10000,, +    100000, 1000000, 10000000, 100000000, 1000000000};, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/LongMath.java, +  // MAX_LOG10_FOR_LEADING_ZEROS[i] == floor(log10(2^(Long.SIZE - i))), +  @VisibleForTesting static final byte[] MAX_LOG10_FOR_LEADING_ZEROS = {, +      19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12,, +      12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4,, +      3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0 };, +, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/IntMath.java, +    /*, +     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation., +     *, +     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),, +     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x)), +     * is 6, then 64 <= x < 128, so floor(log10(x)) is either 1 or 2., +     */, +    int y = MAX_LOG10_FOR_LEADING_ZEROS[Integer.numberOfLeadingZeros(x)];, +    // y is the higher of the two possible values of floor(log10(x)), +, +    int sgn = (x - POWERS_OF_10[y]) >>> (Integer.SIZE - 1);, +    /*, +     * sgn is the sign bit of x - 10^y; it is 1 if x < 10^y, and 0 otherwise. If x < 10^y, then we, +     * want the lower of the two possible values, or y - 1, otherwise, we want y., +     */, +    return y - sgn;, +  // MAX_LOG10_FOR_LEADING_ZEROS[i] == floor(log10(2^(Long.SIZE - i))), +  @VisibleForTesting static final byte[] MAX_LOG10_FOR_LEADING_ZEROS = {9, 9, 9, 8, 8, 8,, +    7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0};, +, +  @VisibleForTesting static final int[] POWERS_OF_10 = {1, 10, 100, 1000, 10000,, +    100000, 1000000, 10000000, 100000000, 1000000000};, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/LongMath.java, +  // MAX_LOG10_FOR_LEADING_ZEROS[i] == floor(log10(2^(Long.SIZE - i))), +  @VisibleForTesting static final byte[] MAX_LOG10_FOR_LEADING_ZEROS = {, +      19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12,, +      12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4,, +      3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0 };, +, +++ b/guava-tests/test/com/google/common/math/IntMathTest.java, +    for (int i = 0; i < IntMath.POWERS_OF_10.length - 1; i++) {, +  public void testMaxLog10ForLeadingZeros() {, +    for (int i = 0; i < Integer.SIZE; i++) {, +      assertEquals(, +          BigIntegerMath.log10(BigInteger.ONE.shiftLeft(Integer.SIZE - i), FLOOR),, +          IntMath.MAX_LOG10_FOR_LEADING_ZEROS[i]);, +    }, +  }, +, +  @GwtIncompatible("BigIntegerMath") // TODO(cpovirk): GWT-enable BigIntegerMath, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/IntMath.java, +    /*, +     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation., +     *, +     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),, +     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x))]