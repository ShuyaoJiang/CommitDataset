[+++ b/guava-tests/test/com/google/common/io/ByteSourceTest.java, +import com.google.common.collect.ImmutableSet;, +import com.google.common.testing.TestLogHandler;, +, +  private static final ByteSource BROKEN_CLOSE_SOURCE, +      = new TestByteSource(new byte[10], CLOSE_THROWS);, +  private static final ByteSource BROKEN_OPEN_SOURCE, +      = new TestByteSource(new byte[10], OPEN_THROWS);, +  private static final ByteSource BROKEN_READ_SOURCE, +      = new TestByteSource(new byte[10], READ_THROWS);, +  private static final ByteSink BROKEN_CLOSE_SINK, +      = new TestByteSink(CLOSE_THROWS);, +  private static final ByteSink BROKEN_OPEN_SINK, +      = new TestByteSink(OPEN_THROWS);, +  private static final ByteSink BROKEN_WRITE_SINK, +      = new TestByteSink(WRITE_THROWS);, +, +  private static final ImmutableSet<ByteSource> BROKEN_SOURCES, +      = ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);, +  private static final ImmutableSet<ByteSink> BROKEN_SINKS, +      = ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);, +, +  public void testCopyExceptions() {, +    if (!Closer.SuppressingSuppressor.isAvailable()) {, +      // test that exceptions are logged, +, +      TestLogHandler logHandler = new TestLogHandler();, +      Closeables.logger.addHandler(logHandler);, +      try {, +        for (ByteSource in : BROKEN_SOURCES) {, +          runFailureTest(in, newNormalByteSink());, +          assertTrue(logHandler.getStoredLogRecords().isEmpty());, +, +          runFailureTest(in, BROKEN_CLOSE_SINK);, +          assertEquals((in == BROKEN_OPEN_SOURCE) ? 0 : 1, getAndResetRecords(logHandler));, +        }, +, +        for (ByteSink out : BROKEN_SINKS) {, +          runFailureTest(newNormalByteSource(), out);, +          assertTrue(logHandler.getStoredLogRecords().isEmpty());, +, +          runFailureTest(BROKEN_CLOSE_SOURCE, out);, +          assertEquals(1, getAndResetRecords(logHandler));, +        }, +, +        for (ByteSource in : BROKEN_SOURCES) {, +          for (ByteSink out : BROKEN_SINKS) {, +            runFailureTest(in, out);, +            assertTrue(getAndResetRecords(logHandler) <= 1);, +          }, +        }, +      } finally {, +        Closeables.logger.removeHandler(logHandler);, +      }, +    } else {, +      // test that exceptions are suppressed, +, +      for (ByteSource in : BROKEN_SOURCES) {, +        int suppressed = runSuppressionFailureTest(in, newNormalByteSink());, +        assertEquals(0, suppressed);, +, +        suppressed = runSuppressionFailureTest(in, BROKEN_CLOSE_SINK);, +        assertEquals((in == BROKEN_OPEN_SOURCE) ? 0 : 1, suppressed);, +      }, +, +      for (ByteSink out : BROKEN_SINKS) {, +        int suppressed = runSuppressionFailureTest(newNormalByteSource(), out);, +        assertEquals(0, suppressed);, +, +        suppressed = runSuppressionFailureTest(BROKEN_CLOSE_SOURCE, out);, +        assertEquals(1, suppressed);, +      }, +, +      for (ByteSource in : BROKEN_SOURCES) {, +        for (ByteSink out : BROKEN_SINKS) {, +          int suppressed = runSuppressionFailureTest(in, out);, +          assertTrue(suppressed <= 1);, +        }, +      }, +    }, +  }, +, +  private static int getAndResetRecords(TestLogHandler logHandler) {, +    int records = logHandler.getStoredLogRecords().size();, +    logHandler.clear();, +    return records;, +  }, +, +  private static void runFailureTest(ByteSource in, ByteSink out) {, +    try {, +      in.copyTo(out);, +      fail();, +    } catch (IOException expected) {, +    }, +  }, +, +  /**, +   * @return the number of exceptions that were suppressed on the expected thrown exception, +   */, +  private static int runSuppressionFailureTest(ByteSource in, ByteSink out) {]