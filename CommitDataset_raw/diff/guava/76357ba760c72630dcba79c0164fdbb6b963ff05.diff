[+++ b/guava-tests/test/com/google/common/reflect/AbstractInvocationHandlerTest.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import java.lang.reflect.Proxy;, +  private static final ImmutableList<String> LIST1 = ImmutableList.of("one", "two");, +  private static final ImmutableList<String> LIST2 = ImmutableList.of("three");, +    assertEquals(LIST1, ImmutableList.copyOf(newDelegatingList(LIST1)));, +    assertEquals(LIST1, ImmutableList.copyOf(newDelegatingListWithEquals(LIST1)));, +    List<String> proxy = newDelegatingList(LIST1);, +    assertEquals(Proxy.getInvocationHandler(proxy).toString(), proxy.toString());, +        .addEqualityGroup(newDelegatingList(LIST1)), +        .addEqualityGroup(newDelegatingList(LIST1)), +        .addEqualityGroup(newDelegatingList(LIST2)), +        .addEqualityGroup(newDelegatingListWithEquals(LIST1), newDelegatingListWithEquals(LIST1)), +        .addEqualityGroup(, +            newDelegatingListWithEquals(LIST2),, +            newProxyWithSubHandler1(LIST2), // Makes sure type of handler doesn't affect equality, +            newProxyWithSubHandler2(LIST2)), +        .addEqualityGroup(newDelegatingIterableWithEquals(LIST2)) // different interface, +  private static List<String> newDelegatingList(List<String> delegate) {, +    return Reflection.newProxy(List.class, new DelegatingInvocationHandler(delegate));, +  }, +, +  @SuppressWarnings("unchecked") // proxy of List<String>, +  private static List<String> newDelegatingListWithEquals(List<String> delegate) {, +    return Reflection.newProxy(List.class, new DelegatingInvocationHandlerWithEquals(delegate));, +  }, +, +  @SuppressWarnings("unchecked") // proxy of Iterable<String>, +  private static Iterable<String> newDelegatingIterableWithEquals(Iterable<String> delegate) {, +    return Reflection.newProxy(Iterable.class, new DelegatingInvocationHandlerWithEquals(delegate));, +  }, +, +  @SuppressWarnings("unchecked") // proxy of List<String>, +  private static List<String> newProxyWithSubHandler1(List<String> delegate) {, +    return Reflection.newProxy(List.class, new SubHandler1(delegate));, +  }, +, +  @SuppressWarnings("unchecked") // proxy of List<String>, +  private static List<String> newProxyWithSubHandler2(List<String> delegate) {, +    return Reflection.newProxy(List.class, new SubHandler2(delegate));, +    final Object delegate;, +    DelegatingInvocationHandler(Object delegate) {, +      this.delegate = checkNotNull(delegate);, +, +  private static class DelegatingInvocationHandlerWithEquals extends DelegatingInvocationHandler {, +, +    DelegatingInvocationHandlerWithEquals(Object delegate) {, +      super(delegate);, +    }, +, +    @Override public boolean equals(Object obj) {, +      if (obj instanceof DelegatingInvocationHandlerWithEquals) {, +        DelegatingInvocationHandlerWithEquals that = (DelegatingInvocationHandlerWithEquals) obj;, +        return delegate.equals(that.delegate);, +      } else {, +        return false;, +      }, +    }, +, +    @Override public int hashCode() {, +      return delegate.hashCode();, +    }, +  }, +, +  private static class SubHandler1 extends DelegatingInvocationHandlerWithEquals {, +    SubHandler1(Object delegate) {, +      super(delegate);, +    }, +  }, +, +  private static class SubHandler2 extends DelegatingInvocationHandlerWithEquals {, +    SubHandler2(Object delegate) {, +      super(delegate);, +    }, +  }, +++ b/guava-tests/test/com/google/common/reflect/AbstractInvocationHandlerTest.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import java.lang.reflect.Proxy;, +  private static final ImmutableList<String> LIST1 = ImmutableList.of("one", "two");, +  private static final ImmutableList<String> LIST2 = ImmutableList.of("three");, +    assertEquals(LIST1, ImmutableList.copyOf(newDelegatingList(LIST1)));, +    assertEquals(LIST1, ImmutableList.copyOf(newDelegatingListWithEquals(LIST1)));, +    List<String> proxy = newDelegatingList(LIST1);, +    assertEquals(Proxy.getInvocationHandler(proxy).toString(), proxy.toString());, +        .addEqualityGroup(newDelegatingList(LIST1)), +        .addEqualityGroup(newDelegatingList(LIST1)), +        .addEqualityGroup(newDelegatingList(LIST2)), +        .addEqualityGroup(newDelegatingListWithEquals(LIST1), newDelegatingListWithEquals(LIST1)), +        .addEqualityGroup(, +            newDelegatingListWithEquals(LIST2),, +            newProxyWithSubHandler1(LIST2), // Makes sure type of handler doesn't affect equality, +            newProxyWithSubHandler2(LIST2)), +        .addEqualityGroup(newDelegatingIterableWithEquals(LIST2)) // different interface, +  private static List<String> newDelegatingList(List<String> delegate) {, +    return Reflection.newProxy(List.class, new DelegatingInvocationHandler(delegate));, +  }, +, +  @SuppressWarnings("unchecked") // proxy of List<String>]