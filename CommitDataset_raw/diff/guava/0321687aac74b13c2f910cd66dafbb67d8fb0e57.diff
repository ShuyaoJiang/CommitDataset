[+++ b/guava/src/com/google/common/collect/ImmutableBiMap.java, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +          /*, +           * If entries is full, then this implementation may end up using the entries array, +           * directly and writing over the entry objects with non-terminal entries, but this is, +           * safe; if this Builder is used further, it will grow the entries array (so it can't, +           * affect the original array), and future build() calls will always copy any entry, +           * objects that cannot be safely reused., +           */, +          return RegularImmutableBiMap.fromEntryArray(size, entries);, +    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant, +    Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);, +        Entry<K, V> entry = entryArray[0];, +        /*, +         * The current implementation will end up using entryArray directly, though it will write, +         * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray., +         */, +        return RegularImmutableBiMap.fromEntries(entryArray);, +++ b/guava/src/com/google/common/collect/ImmutableBiMap.java, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +          /*, +           * If entries is full, then this implementation may end up using the entries array, +           * directly and writing over the entry objects with non-terminal entries, but this is, +           * safe; if this Builder is used further, it will grow the entries array (so it can't, +           * affect the original array), and future build() calls will always copy any entry, +           * objects that cannot be safely reused., +           */, +          return RegularImmutableBiMap.fromEntryArray(size, entries);, +    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant, +    Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);, +        Entry<K, V> entry = entryArray[0];, +        /*, +         * The current implementation will end up using entryArray directly, though it will write, +         * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray., +         */, +        return RegularImmutableBiMap.fromEntries(entryArray);, +++ b/guava/src/com/google/common/collect/ImmutableMap.java, +import java.util.Map.Entry;, +    return RegularImmutableMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return RegularImmutableMap.fromEntries(, +    return RegularImmutableMap.fromEntries(, +    return RegularImmutableMap.fromEntries(entryOf(k1, v1),, +          /*, +           * If entries is full, then this implementation may end up using the entries array, +           * directly and writing over the entry objects with non-terminal entries, but this is, +           * safe; if this Builder is used further, it will grow the entries array (so it can't, +           * affect the original array), and future build() calls will always copy any entry, +           * objects that cannot be safely reused., +           */, +          return RegularImmutableMap.fromEntryArray(size, entries);, +    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant, +    Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);, +        Entry<K, V> onlyEntry = entryArray[0];, +        /*, +         * The current implementation will end up using entryArray directly, though it will write, +         * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray., +         */, +        return RegularImmutableMap.fromEntries(entryArray);, +++ b/guava/src/com/google/common/collect/ImmutableBiMap.java, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +    return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3),, +          /*, +           * If entries is full, then this implementation may end up using the entries array, +           * directly and writing over the entry objects with non-terminal entries, but this is, +           * safe; if this Builder is used further, it will grow the entries array (so it can't, +           * affect the original array), and future build() calls will always copy any entry, +           * objects that cannot be safely reused., +           */, +          return RegularImmutableBiMap.fromEntryArray(size, entries);, +    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant, +    Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);, +        Entry<K, V> entry = entryArray[0];, +        /*, +         * The current implementation will end up using entryArray directly, though it will write, +         * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray., +         */, +        return RegularImmutableBiMap.fromEntries(entryArray);, +++ b/guava/src/com/google/common/collect/ImmutableMap.java, +import java.util.Map.Entry;, +    return RegularImmutableMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));, +    return RegularImmutableMap.fromEntries(, +    return RegularImmutableMap.fromEntries(, +    return RegularImmutableMap.fromEntries(entryOf(k1, v1),, +          /*, +           * If entries is full, then this implementation may end up using the entries array, +           * directly and writing over the entry objects with non-terminal entries, but this is, +           * safe; if this Builder is used further, it will grow the entries array (so it can't, +           * affect the original array), and future build() calls will always copy any entry, +           * objects that cannot be safely reused., +           */, +          return RegularImmutableMap.fromEntryArray(size, entries);, +    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant]