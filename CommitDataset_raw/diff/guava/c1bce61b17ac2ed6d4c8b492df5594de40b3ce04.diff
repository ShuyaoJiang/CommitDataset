[+++ b/guava/src/com/google/common/collect/ListMultimap.java, + * the insertion ordering of values for a given key. See the {@link Multimap}, + * documentation for information common to all multimaps., +++ b/guava/src/com/google/common/collect/ListMultimap.java, + * the insertion ordering of values for a given key. See the {@link Multimap}, + * documentation for information common to all multimaps., +++ b/guava/src/com/google/common/collect/Multimap.java, +import java.util.List;, + * A collection that maps keys to values, similar to {@link Map}, but in which, + * each key may be associated with <i>multiple</i> values. You can visualize the, + * contents of a multimap either as a map from keys to collections of values:, + * <ul>, + * <li>a → 1, 2, + * <li>b → 3, + * </ul>, + * ... or as a single "flattened" collection of key-value pairs:, + * <ul>, + * <li>a → 1, + * <li>a → 2, + * <li>b → 3, + * </ul>, + *, + * <p><b>Important:</b> although the first interpretation resembles how most, + * multimaps are <i>implemented</i>, the design of the {@code Multimap} API is, + * based on the <i>second</i> form. So, using the multimap shown above as an, + * example, the {@link #size} is {@code 3}, not {@code 2}, and the {@link, + * #values} collection is {@code [1, 2, 3]}, not {@code [[1, 2], [3]]}. For, + * those times when the first style is more useful, use the multimap's {@link, + * #asMap} view., + *, + * <h3>Example</h3>, + *, + * <p>The following code: <pre>   {@code, + *, + *   ListMultimap<String, String> multimap = ArrayListMultimap.create();, + *   for (President pres : US_PRESIDENTS_IN_ORDER) {, + *     multimap.put(pres.firstName(), pres.lastName());, + *   }, + *   for (String firstName : multimap.keySet()) {, + *     List<String> lastNames = multimap.get(firstName);, + *     out.println(firstName + ": " + lastNames);, + *   }}</pre>, + *, + * ... produces output such as: <pre>   {@code, + *, + *   Zachary: [Taylor], + *   John: [Adams, Adams, Tyler, Kennedy], + *   George: [Washington, Bush, Bush], + *   Grover: [Cleveland], + *   ...}</pre>, + *, + * <h3>Views</h3>, + *, + * <p>Much of the power of the multimap API comes from the <i>view, + * collections</i> it provides. These always reflect the latest state of the, + * multimap itself. When they support modification, the changes are, + * <i>write-through</i> (they automatically update the backing multimap). These, + * view collections are:, + *, + * <ul>, + * <li>{@link #asMap}, mentioned above</li>, + * <li>{@link #keys}, {@link #keySet}, {@link #values}, {@link #entries}, which, + *     are similar to the corresponding view collections of {@link Map}, + * <li>and, notably, even the collection returned by {@link #get get(key)} is an, + *     active view of the values corresponding to {@code key}, + * </ul>, + *, + * <p>The collections returned by the {@link #replaceValues replaceValues} and, + * {@link #removeAll removeAll} methods, which contain values that have just, + * been removed from the multimap, are naturally <i>not</i> views., + *, + * <h3>Subinterfaces</h3>, + *, + * <p>Instead of using the {@code Multimap} interface directly, prefer the, + * subinterfaces {@link ListMultimap} and {@link SetMultimap}. These take their, + * names from the fact that the collections they return from {@code get} behave, + * like (and, of course, implement) {@link List} and {@link Set}, respectively., + *, + * <p>For example, the "presidents" code snippet above used a {@code, + * ListMultimap}; if it had used a {@code SetMultimap} instead, two presidents, + * would have vanished, and last names might or might not appear in, + * chronological order., + *, + * <h3>Uses</h3>, + *, + * <p>Multimaps are commonly used anywhere a {@code Map<K, Collection<V>>} would, + * otherwise have appeared. The advantages include:, + *, + * <ul>, + * <li>There is no need to populate an empty collection before adding an entry, + *     with {@link #put put}., + * <li>{@code get} never returns {@code null}, only an empty collection., + * <li>It will not retain empty collections after the last value for a key is, + *     removed. As a result, {@link #containsKey} behaves logically, and the, + *     multimap won't leak memory., + * <li>The total entry count is available as {@link #size}., + * <li>Many complex operations become easier; for example, {@code, + *     Collections.min(multimap.values())} finds the smallest value across all, + *     keys., + * </ul>]