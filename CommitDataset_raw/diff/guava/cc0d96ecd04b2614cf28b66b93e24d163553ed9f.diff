[+++ b/guava/src/com/google/common/collect/Cache.java, + * <p>When evaluated as a {@link Function}, a cache yields the same result as invoking {@link #get}., +   * necessary. No state associated with this cache is modified until computation completes., +   *, +   * <p>The implementation may support {@code null} as a valid cached value, or may return {@code, +   * null} without caching it, or may not permit null results at all., +   * necessary. No state associated with this cache is modified until computation completes., +   *, +   * <p>The implementation may support {@code null} as a valid cached value, or may return {@code, +   * null} without caching it, or may not permit null results at all., +   * <p>Operations on the returned map will never trigger a computation. So, unlike {@link, +   * Cache#get}, this map's {@link Map#get get} method will just return {@code null} immediately for, +   * a key that is not already cached., +++ b/guava/src/com/google/common/collect/Cache.java, + * <p>When evaluated as a {@link Function}, a cache yields the same result as invoking {@link #get}., +   * necessary. No state associated with this cache is modified until computation completes., +   *, +   * <p>The implementation may support {@code null} as a valid cached value, or may return {@code, +   * null} without caching it, or may not permit null results at all., +   * necessary. No state associated with this cache is modified until computation completes., +   *, +   * <p>The implementation may support {@code null} as a valid cached value, or may return {@code, +   * null} without caching it, or may not permit null results at all., +   * <p>Operations on the returned map will never trigger a computation. So, unlike {@link, +   * Cache#get}, this map's {@link Map#get get} method will just return {@code null} immediately for, +   * a key that is not already cached., +++ b/guava/src/com/google/common/collect/MapMaker.java, +import com.google.common.collect.AbstractCache.StatsCounter;, + * <p>A builder of {@link ConcurrentMap} or {@link Cache} instances having any combination of the, + * following features:, + *, + * <ul>, + * <li>keys or values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain, + *     SoftReference soft} references, + * <li>least-recently-used eviction when a maximum size is exceeded, + * <li>time-based expiration of entries, measured since last access or last write, + * <li>notification of evicted (or otherwise removed) entries, + * <li>on-demand computation of values for keys not already present, + * </ul>, + *, + * <p>Usage example: <pre>   {@code, + *       .weakKeys(), + *, + * that behaves similarly to a {@link ConcurrentHashMap}., + * <p><b>Note:</b> by default, the returned map uses equality comparisons (the {@link Object#equals, + * equals} method) to determine equality for keys or values. However, if {@link #weakKeys} or {@link, + * #softKeys} was specified, the map uses identity ({@code ==}) comparisons instead for keys., + * Likewise, if {@link #weakValues} or {@link #softValues} was specified, the map uses identity, + * comparisons for values., + * <p>The view collections of the returned map have <i>weakly consistent iterators</i>. This means, + * that they are safe for concurrent use, but if other threads modify the map after the iterator is, + * created, it is undefined which of these changes, if any, are reflected in that iterator. These, + * iterators never throw {@link ConcurrentModificationException}., + * <p>If strong or weak references were requested, it is possible for a key or value present in the, + * the map to be reclaimed by the garbage collector. If this happens, the entry automatically, + * disappears from the map. A partially-reclaimed entry is never exposed to the user. Any {@link, + * java.util.Map.Entry} instance retrieved from the map's {@linkplain Map#entrySet entry set} is a, + * java.util.Map.Entry#setValue}, which simply calls {@link Map#put} on the entry's key., + * the configuration properties of the original map. During deserialization, if the original map had, + * used soft or weak references, the entries are reconstructed as they were, but it's not unlikely, + * they'll be quickly garbage-collected before they are ever accessed., + * <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link, + * java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code, + * WeakHashMap} uses {@link Object#equals}., +   * values, and no automatic eviction of any kind., +   * Sets the minimum total size for the internal hash tables. For example, if the initial capacity, +   * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each, +   * having a hash table of size eight. Providing a large enough estimate at construction time, +   * avoids the need for expensive resizing operations later, but setting this value unnecessarily, +   * high wastes memory., +   * Specifies the maximum number of entries the map may contain. Note that the map <b>may evict an, +   * entry before this limit is exceeded</b>. As the map size grows close to the maximum, the map, +   * evicts entries that are less likely to be used again. For example, the map may evict an entry, +   * because it hasn't been used recently or very often., +   * immediately. This has the same effect as invoking {@link #expireAfterWrite, +   * expireAfterWrite}{@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0,, +   * unit)}. It can be useful in testing, or to disable caching temporarily without a code change., +   * without contention. Because assignment of entries to these partitions is not necessarily, +   * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to, +   * accommodate as many threads as will ever concurrently modify the table. Using a significantly, +   * higher value than you need can waste space and time, and a significantly lower value can lead, +   * to thread contention. But overestimates and underestimates within an order of magnitude do not, +   * usually have much noticeable impact. A value of one permits only one thread to modify the map, +   * at a time, but since read operations can proceed concurrently, this still yields higher, +   * concurrency than full synchronization. Defaults to 4., +   * Specifies that each key (not value) stored in the map should be wrapped in a {@link, +   * WeakReference} (by default, strong references are used)., +   * <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==}), +   * comparison to determine equality of keys, which is a technical violation of the {@link Map}, +   * specification, and may not be what you expect., +   * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will, +   * be garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory, +   * demand., +   * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain, +   * #maximumSize maximum size} instead of using soft references. You should only use this method if, +   * you are well familiar with the practical consequences of soft references., +   *, +   * <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==}), +   * comparison to determine equality of keys, which is a technical violation of the {@link Map}, +   * specification, and may not be what you expect.]