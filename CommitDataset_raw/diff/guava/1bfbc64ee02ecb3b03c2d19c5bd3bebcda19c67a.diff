[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +import java.util.ConcurrentModificationException;, +import java.util.HashMap;, +  private static class KeyList<K, V> {, +    Node<K, V> head;, +    Node<K, V> tail;, +    int count;, +    , +    KeyList(Node<K, V> firstNode) {, +      this.head = firstNode;, +      this.tail = firstNode;, +      firstNode.previousSibling = null;, +      firstNode.nextSibling = null;, +      this.count = 1;, +    }, +  }, +, +  private transient Map<K, KeyList<K, V>> keyToKeyList;, +  private transient int size;, +  , +  /*, +   * Tracks modifications to keyToKeyList so that addition or removal of keys invalidates, +   * preexisting iterators. This does *not* track simple additions and removals of values, +   * that are not the first to be added or last to be removed for their key., +   */, +  private transient int modCount;, +    keyToKeyList = Maps.newHashMap();, +    keyToKeyList = new HashMap<K, KeyList<K, V>>(expectedKeys);, +      keyToKeyList.put(key, new KeyList<K, V>(node));, +      modCount++;, +      tail = node;, +      KeyList<K, V> keyList = keyToKeyList.get(key);, +      if (keyList == null) {, +        keyToKeyList.put(key, keyList = new KeyList<K, V>(node));, +        modCount++;, +        keyList.count++;, +        Node<K, V> keyTail = keyList.tail;, +        keyList.tail = node;, +      KeyList<K, V> keyList = keyToKeyList.get(key);, +      keyList.count++;, +        keyToKeyList.get(key).head = node;, +    size++;, +    if (node.previousSibling == null && node.nextSibling == null) {, +      KeyList<K, V> keyList = keyToKeyList.remove(node.key);, +      keyList.count = 0;, +      modCount++;, +    } else {, +      KeyList<K, V> keyList = keyToKeyList.get(node.key);, +      keyList.count--;, +, +      if (node.previousSibling == null) {, +        keyList.head = node.nextSibling;, +      } else {, +      , +      if (node.nextSibling == null) {, +        keyList.tail = node.previousSibling;, +      } else {, +    }, +    size--;, +    int expectedModCount = modCount;, +    private void checkForConcurrentModification() {, +      if (modCount != expectedModCount) {, +        throw new ConcurrentModificationException();, +      }, +    }, +      checkForConcurrentModification();, +      checkForConcurrentModification();, +      checkForConcurrentModification();, +      expectedModCount = modCount;, +      checkForConcurrentModification();, +      checkForConcurrentModification();, +    int expectedModCount = modCount;, +    private void checkForConcurrentModification() {, +      if (modCount != expectedModCount) {, +        throw new ConcurrentModificationException();, +      }, +    }, +      checkForConcurrentModification();, +      checkForConcurrentModification();, +      checkForConcurrentModification();, +      expectedModCount = modCount;, +      KeyList<K, V> keyList = keyToKeyList.get(key);, +      next = (keyList == null) ? null : keyList.head;, +      KeyList<K, V> keyList = keyToKeyList.get(key);, +      int size = (keyList == null) ? 0 : keyList.count;, +        previous = (keyList == null) ? null : keyList.tail;, +        next = (keyList == null) ? null : keyList.head;, +    return size;, +    return keyToKeyList.containsKey(key);, +    keyToKeyList.clear();, +    size = 0;, +    modCount++;, +        KeyList<K, V> keyList = keyToKeyList.get(key);, +        return (keyList == null) ? 0 : keyList.count;, +          return keyToKeyList.size();, +      return size;, +      KeyList<K, V> keyList = keyToKeyList.get(element);, +      return (keyList == null) ? 0 : keyList.count;, +              return keyToKeyList.get(key).count;, +          return size;]