[+++ b/guava-tests/benchmark/com/google/common/math/IntMathBenchmark.java, +      positive[i] = randomPositiveBigInteger(Integer.SIZE - 1).intValue();, +      nonnegative[i] = randomNonNegativeBigInteger(Integer.SIZE - 1).intValue();, +  , +  @Benchmark int isPrime(int reps) {, +    int tmp = 0;, +    for (int i = 0; i < reps; i++) {, +      int j = i & ARRAY_MASK;, +      if (IntMath.isPrime(positive[j])) {, +        tmp++;, +      }, +    }, +    return tmp;, +  }, +++ b/guava-tests/benchmark/com/google/common/math/IntMathBenchmark.java, +      positive[i] = randomPositiveBigInteger(Integer.SIZE - 1).intValue();, +      nonnegative[i] = randomNonNegativeBigInteger(Integer.SIZE - 1).intValue();, +  , +  @Benchmark int isPrime(int reps) {, +    int tmp = 0;, +    for (int i = 0; i < reps; i++) {, +      int j = i & ARRAY_MASK;, +      if (IntMath.isPrime(positive[j])) {, +        tmp++;, +      }, +    }, +    return tmp;, +  }, +++ b/guava-tests/benchmark/com/google/common/math/LongMathBenchmark.java, +      positive[i] = randomPositiveBigInteger(Long.SIZE - 1).longValue();, +      nonnegative[i] = randomNonNegativeBigInteger(Long.SIZE - 1).longValue();, +  , +  @Benchmark int isPrime(int reps) {, +    int tmp = 0;, +    for (int i = 0; i < reps; i++) {, +      int j = i & ARRAY_MASK;, +      if (LongMath.isPrime(positive[j])) {, +        tmp++;, +      }, +    }, +    return tmp;, +  }, +++ b/guava-tests/benchmark/com/google/common/math/IntMathBenchmark.java, +      positive[i] = randomPositiveBigInteger(Integer.SIZE - 1).intValue();, +      nonnegative[i] = randomNonNegativeBigInteger(Integer.SIZE - 1).intValue();, +  , +  @Benchmark int isPrime(int reps) {, +    int tmp = 0;, +    for (int i = 0; i < reps; i++) {, +      int j = i & ARRAY_MASK;, +      if (IntMath.isPrime(positive[j])) {, +        tmp++;, +      }, +    }, +    return tmp;, +  }, +++ b/guava-tests/benchmark/com/google/common/math/LongMathBenchmark.java, +      positive[i] = randomPositiveBigInteger(Long.SIZE - 1).longValue();, +      nonnegative[i] = randomNonNegativeBigInteger(Long.SIZE - 1).longValue();, +  , +  @Benchmark int isPrime(int reps) {, +    int tmp = 0;, +    for (int i = 0; i < reps; i++) {, +      int j = i & ARRAY_MASK;, +      if (LongMath.isPrime(positive[j])) {, +        tmp++;, +      }, +    }, +    return tmp;, +  }, +++ b/guava-tests/test/com/google/common/math/MathBenchmarking.java, + * In many cases, we wish to vary the order of magnitude of the input as much as we, + * want to vary the input itself, so most methods which generate values use, + * an exponential distribution varying the order of magnitude of the generated values, + * uniformly at random., + *, +  /**, +   * Generates values in a distribution equivalent to randomNonNegativeBigInteger, +   * but omitting zero., +   */, +    BigInteger result;, +    do {, +      result = randomNonNegativeBigInteger(numBits);, +    } while (result.signum() == 0);, +    return result;, +  /**, +   * Generates a number in [0, 2^numBits) with an exponential distribution., +   * The floor of the log2 of the result is chosen uniformly at random in, +   * [0, numBits), and then the result is chosen in that range uniformly at random., +   * Zero is treated as having log2 == 0., +   */, +    int digits = RANDOM_SOURCE.nextInt(numBits);, +    if (digits == 0) {, +      return new BigInteger(1, RANDOM_SOURCE);, +    } else {, +      return new BigInteger(digits, RANDOM_SOURCE), +          .setBit(digits);, +    }, +  /**, +   * Equivalent to calling randomPositiveBigInteger(numBits) and then flipping]