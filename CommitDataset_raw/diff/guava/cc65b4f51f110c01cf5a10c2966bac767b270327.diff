[+++ b/guava-tests/test/com/google/common/reflect/TypesTest.java, +import java.security.AccessControlException;, +  // This must be static because the point where it is needed may be earlier than the execution, +  // of the specific test case that uses it. Currently we need it to operate in the static, +  // initializer of TypeVariableInvocationHandler., +  private static final NoSetAccessibleSecurityManager securityManager =, +      new NoSetAccessibleSecurityManager();, +, +   * when it comes from a specific place. The idea is to ensure that, +   * {@code Types.newTypeVariableImpl}, which calls {@code setAccessible}, can still work if that, +   * call is refused. We also record whether the refusal happened, so that we can test that we are, +   * indeed refusing access where we expect., +    volatile boolean setAccessibleWasRefused;, +      if (p.equals(DISALLOWED_PERMISSION), +          && callStackContainsMethod("TypeVariableInvocationHandler", "<clinit>")) {, +        try {, +          fail("Did not get expected AccessControlException");, +        } catch (AccessControlException expected) {, +          setAccessibleWasRefused = true;, +          throw expected;, +        }, +    private static boolean callStackContainsMethod(String classNameFragment, String methodName) {, +      for (StackTraceElement stackTraceElement : new Throwable().getStackTrace()) {, +        if (stackTraceElement.getClassName().contains(classNameFragment), +            && stackTraceElement.getMethodName().equals(methodName)) {, +    System.setSecurityManager(securityManager);, +, +    // At some point before now we should have hit the permission check that prevents us from, +    // calling setAccessible. We check that that is indeed true because we want to make sure, +    // that creating a TypeVariable instance works even when that is not allowed., +    assertTrue(securityManager.setAccessibleWasRefused);]