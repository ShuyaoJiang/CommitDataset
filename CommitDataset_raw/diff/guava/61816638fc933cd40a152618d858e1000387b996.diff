[+++ b/guava-tests/test/com/google/common/primitives/UnsignedLongsTest.java, +++ b/guava-tests/test/com/google/common/primitives/UnsignedLongsTest.java, +++ b/guava/src/com/google/common/primitives/UnsignedLongs.java, + * <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned, + * long values. When possible, it is recommended that the {@link UnsignedLong} wrapper class be, + * used, at a small efficiency penalty, to enforce the distinction in the type system., + *, + * @author Colin Evans, +   * A (self-inverse) bijection which converts the ordering on unsigned longs, +   * to the ordering on longs, that is, {@code a <= b} as unsigned longs if and, +   * only if {@code rotate(a) <= rotate(b)} as signed longs., +  private static long flip(long a) {, +    return a ^ Long.MIN_VALUE;, +   * Compares the two specified {@code long} values, treating them as unsigned, +   * values between {@code 0} and {@code 2^64 - 1} inclusive., +   * @return a negative value if {@code a} is less than {@code b}; a positive, +   *         value if {@code a} is greater than {@code b}; or zero if they are, +   *         equal, +    return Longs.compare(flip(a), flip(b));, +   * @return the value present in {@code array} that is less than or equal to, +   *         every other value in the array according to {@link #compare}, +    long min = flip(array[0]);, +      long next = flip(array[i]);, +    return flip(min);, +   * @return the value present in {@code array} that is greater than or equal, +   *         to every other value in the array according to {@link #compare}, +    long max = flip(array[0]);, +      long next = flip(array[i]);, +    return flip(max);, +   * Returns a string containing the supplied unsigned {@code long} values, +   * separated by {@code separator}. For example, {@code join("-", 1, 2, 3)}, +   * returns the string {@code "1-2-3"}., +   */, +  public static long divide(long dividend, long divisor) {, +      if (compare(dividend, divisor) < 0) {, +    return quotient + (compare(rem, divisor) >= 0 ? 1 : 0);, +      if (compare(dividend, divisor) < 0) {, +    return rem - (compare(rem, divisor) >= 0 ? divisor : 0);, +   * Returns true if (current * radix) + digit is a number too large to be, +   * represented by an unsigned long. This is useful for detecting overflow, +   * while parsing a string representation of a number. Does not verify whether, +   * supplied radix is valid, passing an invalid radix will give undefined, +   * results or an ArrayIndexOutOfBoundsException., +   * Returns a string representation of {@code x} for the given radix, where, +   * {@code x} is treated as unsigned., +   * @param radix the radix to use while working with {@code x}, +   * @throws IllegalArgumentException if {@code radix} is not between, +   *         {@link Character#MIN_RADIX} and {@link Character#MAX_RADIX}., +    checkArgument(radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX,, +        "radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX",, +        radix);]