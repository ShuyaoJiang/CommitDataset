[+++ b/cycle_whitelist.txt, +FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor.$, +++ b/cycle_whitelist.txt, +FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor.$, +++ b/guava-gwt/test/com/google/common/collect/MinMaxPriorityQueueTest_gwt.java, +public void testRandomAddsAndRemoves() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRandomAddsAndRemoves();, +}, +, +public void testRandomRemoves() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRandomRemoves();, +}, +, +public void testRemoveRegression() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRemoveRegression();, +}, +, +++ b/cycle_whitelist.txt, +FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor.$, +++ b/guava-gwt/test/com/google/common/collect/MinMaxPriorityQueueTest_gwt.java, +public void testRandomAddsAndRemoves() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRandomAddsAndRemoves();, +}, +, +public void testRandomRemoves() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRandomRemoves();, +}, +, +public void testRemoveRegression() throws Exception {, +  com.google.common.collect.MinMaxPriorityQueueTest testCase = new com.google.common.collect.MinMaxPriorityQueueTest();, +  testCase.testRemoveRegression();, +}, +, +++ b/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java, +import com.google.common.collect.testing.QueueTestSuiteBuilder;, +import com.google.common.collect.testing.TestStringQueueGenerator;, +import com.google.common.collect.testing.features.CollectionFeature;, +import com.google.common.collect.testing.features.CollectionSize;, +import java.util.Queue;, +import junit.framework.Test;, +import junit.framework.TestSuite;, +  private static final Ordering<Integer> SOME_COMPARATOR = Ordering.natural().reverse();, +, +  @GwtIncompatible // suite, +  public static Test suite() {, +    TestSuite suite = new TestSuite();, +    suite.addTestSuite(MinMaxPriorityQueueTest.class);, +    suite.addTest(QueueTestSuiteBuilder, +        .using(new TestStringQueueGenerator() {, +          @Override protected Queue<String> create(String[] elements) {, +            return MinMaxPriorityQueue.create(Arrays.asList(elements));, +          }, +        }), +        .named("MinMaxPriorityQueue"), +        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE), +        .createTestSuite());, +    return suite;, +  }, +    assertTrue("Heap not intact after " + numberOfModifications, +        + " random mixture of operations", mmHeap.isIntact());, +   * Regression test for https://github.com/google/guava/issues/2658, +   */, +  public void testRemoveRegression() {, +    MinMaxPriorityQueue<Long> queue =, +        MinMaxPriorityQueue.create(ImmutableList.of(2L, 3L, 0L, 4L, 1L));, +    queue.remove(4L);, +    queue.remove(1L);, +    assertThat(queue).doesNotContain(1L);, +  }, +, +  public void testRandomRemoves() {, +    Random random = new Random(0);, +    for (int attempts = 0; attempts < 1000; attempts++) {, +      ArrayList<Integer> elements = createOrderedList(10);, +      Collections.shuffle(elements, random);, +      MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create(elements);, +      Collections.shuffle(elements, random);, +      for (Integer element : elements) {, +        assertThat(queue.remove(element)).isTrue();, +        assertThat(queue.isIntact()).isTrue();, +        assertThat(queue).doesNotContain(element);, +      }, +      assertThat(queue).isEmpty();, +    }, +  }, +, +  public void testRandomAddsAndRemoves() {, +    Random random = new Random(0);, +    Multiset<Integer> elements = HashMultiset.create();, +    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create();, +    int range = 10_000; // range should be small enough that equal elements occur semi-frequently, +    for (int iter = 0; iter < 1000; iter++) {, +      for (int i = 0; i < 100; i++) {, +        Integer element = random.nextInt(range);, +        elements.add(element);]