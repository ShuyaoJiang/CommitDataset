[+++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +import com.google.common.base.Preconditions;, +    testFunctorParameter(, +        instance, Functor.from(instance, method), paramIndex, method.getDeclaringClass());, +    testFunctorParameter(null, Functor.from(ctor), paramIndex, ctor.getDeclaringClass());, +    if (func.parameterIsPrimitiveOrNullable(paramIndex)) {, +        if (!func.parameterIsPrimitiveOrNullable(i)) {, +            // TODO(benyu): Use Invokable API once it graduates from labs., +            Functor functor = Functor.from(proxy, method);, +            for (int i = 0; i < args.length; i++) {, +              if (!functor.parameterIsPrimitiveOrNullable(i)) {, +                Preconditions.checkNotNull(args[i]);, +              }, +            }, +  private static abstract class Functor {, +    abstract Type[] getParameterTypes();, +    abstract Annotation[][] getParameterAnnotations();, +    abstract void invoke(Object o, Object[] params), +        throws InvocationTargetException, IllegalAccessException, InstantiationException;, +, +    boolean parameterIsPrimitiveOrNullable(int paramIndex) {, +      if (TypeToken.of(getParameterTypes()[paramIndex]).getRawType(), +          .isPrimitive()) {, +        return true;, +      }, +      Annotation[] annotations = getParameterAnnotations()[paramIndex];, +      for (Annotation annotation : annotations) {, +        if (annotation instanceof Nullable) {, +          return true;, +        }, +      }, +      return false;, +    }, +, +    private static Functor from(@Nullable final Object instance, final Method method) {, +      return new Functor() {, +          @Override Type[] getParameterTypes() {, +            Type[] unresolved = method.getGenericParameterTypes();, +            if (isStatic(method)) {, +              return unresolved;, +            } else {, +              TypeToken<?> type = TypeToken.of(instance.getClass());, +              Type[] resolved = new Type[unresolved.length];, +              for (int i = 0; i < unresolved.length; i++) {, +                resolved[i] = type.resolveType(unresolved[i]).getType();, +              }, +              return resolved;, +            }, +          }, +          @Override Annotation[][] getParameterAnnotations() {, +            return method.getParameterAnnotations();, +          }, +          @Override void invoke(Object object, Object[] params), +              throws InvocationTargetException, IllegalAccessException {, +            method.invoke(object, params);, +          }, +          @Override public String toString() {, +            return method.toString();, +          }, +        };, +    }, +, +    private static Functor from(final Constructor<?> ctor) {, +      return new Functor() {, +          @Override Type[] getParameterTypes() {, +            return ctor.getGenericParameterTypes();, +          }, +          @Override Annotation[][] getParameterAnnotations() {, +            return ctor.getParameterAnnotations();, +          }, +          @Override void invoke(Object instance, Object[] params), +              InstantiationException {, +            ctor.newInstance(params);, +          }, +        };, +    }, +++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java, +import com.google.common.base.Preconditions;, +    testFunctorParameter(, +        instance, Functor.from(instance, method), paramIndex, method.getDeclaringClass());, +    testFunctorParameter(null, Functor.from(ctor), paramIndex, ctor.getDeclaringClass());, +    if (func.parameterIsPrimitiveOrNullable(paramIndex)) {, +        if (!func.parameterIsPrimitiveOrNullable(i)) {, +            // TODO(benyu): Use Invokable API once it graduates from labs., +            Functor functor = Functor.from(proxy, method);, +            for (int i = 0; i < args.length; i++) {, +              if (!functor.parameterIsPrimitiveOrNullable(i)) {, +                Preconditions.checkNotNull(args[i]);, +              }, +            }, +  private static abstract class Functor {, +    abstract Type[] getParameterTypes();, +    abstract Annotation[][] getParameterAnnotations();, +    abstract void invoke(Object o, Object[] params), +        throws InvocationTargetException, IllegalAccessException, InstantiationException;, +, +    boolean parameterIsPrimitiveOrNullable(int paramIndex) {, +      if (TypeToken.of(getParameterTypes()[paramIndex]).getRawType(), +          .isPrimitive()) {, +        return true;]