[+++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              int newCount = this.count - 1;, +                    // immediately reuse partially collected entries, +                    enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    evictionQueue.remove(e);, +                    expirationQueue.remove(e);, +                    this.count = newCount; // write-volatile, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              int newCount = this.count - 1;, +                    // immediately reuse partially collected entries, +                    enqueueNotification(entryKey, hash, value, RemovalCause.COLLECTED);, +                    evictionQueue.remove(e);, +                    expirationQueue.remove(e);, +                    this.count = newCount; // write-volatile, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +    void enqueueNotification(ReferenceEntry<K, V> entry, RemovalCause cause) {, +      enqueueNotification(entry.getKey(), entry.getHash(), entry.getValueReference().get(), cause);, +    }, +, +              if (valueReference.isComputingReference()) {, +                if (evictEntries()) { // evictEntries after setting new value, +                  newCount = this.count + 1;, +                }, +              } else {, +                enqueueNotification(key, hash, entryValue, RemovalCause.COLLECTED);, +                newCount = this.count; // count remains unchanged, +              }, +        if (evictEntries()) { // evictEntries after setting new value, +          newCount = this.count + 1;, +        }, +              ReferenceEntry<K, V> newFirst = map.copyEntry(e, newNext);, +              newTable.set(newIndex, newFirst);, +            if (entryValue != null) {, +              enqueueNotification(entryKey, hash, entryValue, RemovalCause.EXPLICIT);, +              ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +            if (map.valueEquivalence.equivalent(value, entryValue)) {, +              enqueueNotification(entryKey, hash, entryValue, RemovalCause.EXPLICIT);, +              ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +                enqueueNotification(e, RemovalCause.EXPLICIT);, +     * <p>This method does not decrement count., +     *, +            ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +            table.set(index, newFirst);, +            this.count = newCount; // write-volatile, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +        int index = hash & (table.length() - 1);, +        ReferenceEntry<K, V> first = table.get(index);, +, +        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +              ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +              table.set(index, newFirst);, +    /**, +     * Clears a value that has not yet been set, and thus does not require count to be modified., +     */, +        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +        int index = hash & (table.length() - 1);, +        ReferenceEntry<K, V> first = table.get(index);, +, +        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +              ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +              table.set(index, newFirst);, +      AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;, +      int index = hash & (table.length() - 1);, +      ReferenceEntry<K, V> first = table.get(index);, +      for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {, +        if (e == entry) {, +          ++modCount;, +          enqueueNotification(e.getKey(), hash, e.getValueReference().get(), cause);, +          ReferenceEntry<K, V> newFirst = removeFromChain(first, e);, +          table.set(index, newFirst);]