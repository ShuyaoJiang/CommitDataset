[+++ b/android/guava-tests/test/com/google/common/io/ByteStreamsTest.java, +  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);, +, +  public void testToByteArray() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    byte[] b = ByteStreams.toByteArray(in);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_emptyStream() throws IOException {, +    InputStream in = newTestStream(0);, +    byte[] b = ByteStreams.toByteArray(in);, +    assertEquals(b, new byte[0]);, +  }, +, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    // this results in toByteArrayInternal being called when the stream is actually exhausted, +    byte[] b = ByteStreams.toByteArray(in, 99);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    byte[] b = ByteStreams.toByteArray(in, 98);, +    assertEquals(b, PRE_FILLED_100);, +++ b/android/guava-tests/test/com/google/common/io/ByteStreamsTest.java, +  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);, +, +  public void testToByteArray() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    byte[] b = ByteStreams.toByteArray(in);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_emptyStream() throws IOException {, +    InputStream in = newTestStream(0);, +    byte[] b = ByteStreams.toByteArray(in);, +    assertEquals(b, new byte[0]);, +  }, +, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    // this results in toByteArrayInternal being called when the stream is actually exhausted, +    byte[] b = ByteStreams.toByteArray(in, 99);, +    assertEquals(b, PRE_FILLED_100);, +  }, +, +  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {, +    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);, +    byte[] b = ByteStreams.toByteArray(in, 98);, +    assertEquals(b, PRE_FILLED_100);, +++ b/android/guava/src/com/google/common/io/ByteStreams.java, +import com.google.common.math.IntMath;, +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.Iterator;, +  /** Max array length on JVM */, +  private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;, +, +  /**, +   * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have, +   * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given, +   * input stream., +   */, +  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen), +      throws IOException {, +    // ByteArrayOutputStream uses a single byte array as a buffer and copies it to a new, larger, +    // buffer each time it needs more space. By contrast, this method just allocates a new buffer, +    // each time it needs more space and then copies all the buffers to a single array at the end., +    // Like ByteArrayOutputStream, the size of each successive buffer is larger than the previous, +    // one (doubling each time, in this case), to reduce the number of allocations and potentially, +    // the number of calls to read() needed., +    if (totalLen == MAX_ARRAY_LEN) {, +      // true iff called from toByteArray(in, MAX_ARRAY_LEN - 1), +      return toByteArrayAtMaxLength(in, bufs);, +    }, +    byte[] buf = new byte[Math.min(BUFFER_SIZE, MAX_ARRAY_LEN - totalLen)];, +    bufs.add(buf);, +    int off = 0;]