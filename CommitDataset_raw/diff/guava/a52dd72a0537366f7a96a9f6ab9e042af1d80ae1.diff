[+++ b/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java, +import java.util.LinkedHashSet;, +  private Set<Feature<?>> features = new LinkedHashSet<Feature<?>>();, +   * features.  This method may be called more than once to add features, +   * in multiple groups., +    for (Feature<?> feature : features) {, +      this.features.add(feature);, +    }, +++ b/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java, +import java.util.LinkedHashSet;, +  private Set<Feature<?>> features = new LinkedHashSet<Feature<?>>();, +   * features.  This method may be called more than once to add features, +   * in multiple groups., +    for (Feature<?> feature : features) {, +      this.features.add(feature);, +    }, +++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java, +      /*, +       * This is nasty and complicated, but it's the only way to make sure keys get mapped to enough, +       * distinct values., +       */, +      Map.Entry[] entries = new Map.Entry[elements.length];, +      Map<K, Iterator<V>> valueIterators = new HashMap<K, Iterator<V>>();, +        @SuppressWarnings("unchecked"), +        K key = (K) elements[i];, +, +        Iterator<V> valueItr = valueIterators.get(key);, +        if (valueItr == null) {, +          valueIterators.put(key, valueItr = sampleValuesIterator());, +        }, +        entries[i] = mapEntry((K) elements[i], valueItr.next());, +    private Iterator<V> sampleValuesIterator() {, +      return ((TestMultimapGenerator<K, V, M>) multimapGenerator, +          .getInnerGenerator()).sampleValues().iterator();, +    }, +, +      Iterator<V> valueIter = sampleValuesIterator();, +++ b/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java, +import java.util.LinkedHashSet;, +  private Set<Feature<?>> features = new LinkedHashSet<Feature<?>>();, +   * features.  This method may be called more than once to add features, +   * in multiple groups., +    for (Feature<?> feature : features) {, +      this.features.add(feature);, +    }, +++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java, +      /*, +       * This is nasty and complicated, but it's the only way to make sure keys get mapped to enough, +       * distinct values., +       */, +      Map.Entry[] entries = new Map.Entry[elements.length];, +      Map<K, Iterator<V>> valueIterators = new HashMap<K, Iterator<V>>();, +        @SuppressWarnings("unchecked"), +        K key = (K) elements[i];, +, +        Iterator<V> valueItr = valueIterators.get(key);, +        if (valueItr == null) {, +          valueIterators.put(key, valueItr = sampleValuesIterator());, +        }, +        entries[i] = mapEntry((K) elements[i], valueItr.next());, +    private Iterator<V> sampleValuesIterator() {, +      return ((TestMultimapGenerator<K, V, M>) multimapGenerator, +          .getInnerGenerator()).sampleValues().iterator();, +    }, +, +      Iterator<V> valueIter = sampleValuesIterator();, +++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java, +import static com.google.common.base.Preconditions.checkArgument;, +, +import com.google.common.collect.Multiset.Entry;, +import com.google.common.collect.Multisets;, +import com.google.common.collect.testing.SetTestSuiteBuilder;, +import com.google.common.collect.testing.TestSetGenerator;, +import java.util.Collections;, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.Map;, +  public enum NoRecurse implements Feature<Void> {, +    NO_ENTRY_SET;, +, +    @Override, +    public Set<Feature<? super Void>> getImpliedFeatures() {, +      return Collections.emptySet();, +    }, +  }, +, +  private static Set<Feature<?>> computeEntrySetFeatures(, +      Set<Feature<?>> features) {, +    Set<Feature<?>> derivedFeatures = new HashSet<Feature<?>>();, +    derivedFeatures.addAll(features);, +    derivedFeatures.remove(CollectionFeature.GENERAL_PURPOSE);, +    derivedFeatures.remove(CollectionFeature.SUPPORTS_ADD);, +    derivedFeatures.remove(CollectionFeature.ALLOWS_NULL_VALUES);, +    derivedFeatures.add(CollectionFeature.REJECTS_DUPLICATES_AT_CREATION);, +    if (!derivedFeatures.remove(CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)) {, +      derivedFeatures.remove(CollectionFeature.SERIALIZABLE);, +    }, +    return derivedFeatures;, +  }, +]