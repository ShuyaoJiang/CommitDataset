[+++ b/guava/src/com/google/common/eventbus/AsyncEventBus.java, +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/AsyncEventBus.java, +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/EventBus.java, + * <p>The EventBus allows publish-subscribe-style communication between, + * components without requiring the components to explicitly register with one, + * another (and thus be aware of each other). It is designed exclusively to, + * replace traditional Java in-process event distribution using explicit, + * registration. It is <em>not</em> a general-purpose publish-subscribe system,, + * nor is it intended for interprocess communication., + * <p>To receive events, an object should:, + * <p>To post an event, simply provide the event object to the {@link, + * #post(Object)} method. The EventBus instance will determine the type of event, + * and route it to all registered listeners., + * <p>Events are routed based on their type &mdash; an event will be delivered, + * to any handler for any type to which the event is <em>assignable.</em> This, + * <p>When {@code post} is called, all registered handlers for an event are run, + * in sequence, so handlers should be reasonably quick. If an event may trigger, + * an extended process (such as a database load), spawn a thread or queue it for, + * <p>Event handler methods must accept only one argument: the event., + * <p>The EventBus guarantees that it will not call a handler method from, + * multiple threads simultaneously, unless the method explicitly allows it by, + * bearing the {@link AllowConcurrentEvents} annotation. If this annotation is, + * not present, handler methods need not worry about being reentrant, unless, + * also called from outside the EventBus., + * <p>If an event is posted, but no registered handlers can accept it, it is, + * <p>If a handler for a supertype of all events (such as Object) is registered,, + * no event will ever be considered dead, and no DeadEvents will be generated., + * <p>When a subscriber throws an exception while handling event, the {@link, + * SubscriberExceptionHandler} is called., + * <p>This class is safe for concurrent use., + * <p>See the Guava User Guide article on <a href=, + * "http://code.google.com/p/guava-libraries/wiki/EventBusExplained">{@code, + * EventBus}</a>., +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/AsyncEventBus.java, +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/EventBus.java, + * <p>The EventBus allows publish-subscribe-style communication between, + * components without requiring the components to explicitly register with one, + * another (and thus be aware of each other). It is designed exclusively to, + * replace traditional Java in-process event distribution using explicit, + * registration. It is <em>not</em> a general-purpose publish-subscribe system,, + * nor is it intended for interprocess communication., + * <p>To receive events, an object should:, + * <p>To post an event, simply provide the event object to the {@link, + * #post(Object)} method. The EventBus instance will determine the type of event, + * and route it to all registered listeners., + * <p>Events are routed based on their type &mdash; an event will be delivered, + * to any handler for any type to which the event is <em>assignable.</em> This, + * <p>When {@code post} is called, all registered handlers for an event are run, + * in sequence, so handlers should be reasonably quick. If an event may trigger, + * an extended process (such as a database load), spawn a thread or queue it for, + * <p>Event handler methods must accept only one argument: the event., + * <p>The EventBus guarantees that it will not call a handler method from, + * multiple threads simultaneously, unless the method explicitly allows it by, + * bearing the {@link AllowConcurrentEvents} annotation. If this annotation is, + * not present, handler methods need not worry about being reentrant, unless, + * also called from outside the EventBus., + * <p>If an event is posted, but no registered handlers can accept it, it is, + * <p>If a handler for a supertype of all events (such as Object) is registered,, + * no event will ever be considered dead, and no DeadEvents will be generated., + * <p>When a subscriber throws an exception while handling event, the {@link, + * SubscriberExceptionHandler} is called., + * <p>This class is safe for concurrent use., + * <p>See the Guava User Guide article on <a href=, + * "http://code.google.com/p/guava-libraries/wiki/EventBusExplained">{@code, + * EventBus}</a>., +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java, + *, + * @since 16.0, +   *     subscriber. Useful for broadcasting a a new event based on the error., +   * @return The {@link EventBus} that handled the event and the subscriber., +   *     Useful for broadcasting a a new event based on the error., +++ b/guava/src/com/google/common/eventbus/AsyncEventBus.java, +   * @since 16.0, +++ b/guava/src/com/google/common/eventbus/EventBus.java, + * <p>The EventBus allows publish-subscribe-style communication between, + * components without requiring the components to explicitly register with one, + * another (and thus be aware of each other). It is designed exclusively to, + * replace traditional Java in-process event distribution using explicit, + * registration. It is <em>not</em> a general-purpose publish-subscribe system,, + * nor is it intended for interprocess communication., + * <p>To receive events, an object should:, + * <p>To post an event, simply provide the event object to the {@link, + * #post(Object)} method. The EventBus instance will determine the type of event, + * and route it to all registered listeners., + * <p>Events are routed based on their type &mdash; an event will be delivered, + * to any handler for any type to which the event is <em>assignable.</em> This, + * <p>When {@code post} is called, all registered handlers for an event are run, + * in sequence, so handlers should be reasonably quick. If an event may trigger, + * an extended process (such as a database load), spawn a thread or queue it for, + * <p>Event handler methods must accept only one argument: the event., + * <p>The EventBus guarantees that it will not call a handler method from, + * multiple threads simultaneously, unless the method explicitly allows it by, + * bearing the {@link AllowConcurrentEvents} annotation. If this annotation is, + * not present, handler methods need not worry about being reentrant, unless, + * also called from outside the EventBus.]