[+++ b/android/guava-tests/test/com/google/common/reflect/TypeTokenResolutionTest.java, +    TypeResolver typeResolver = TypeResolver.covariantly(parameterized.getClass());, +++ b/android/guava-tests/test/com/google/common/reflect/TypeTokenResolutionTest.java, +    TypeResolver typeResolver = TypeResolver.covariantly(parameterized.getClass());, +++ b/android/guava-tests/test/com/google/common/reflect/TypeTokenSubtypeTest.java, +import static com.google.common.truth.Truth.assertThat;, +, +  /**, +   * This test reproduces the bug in canonicalizeWildcardType() when the type variable is, +   * recursively bounded., +   */, +  public void testRecursiveWildcardSubtypeBug() throws Exception {, +    try {, +      new RecursiveTypeBoundBugExample<>().testAllDeclarations();, +      fail();, +    } catch (Exception e) {, +      assertThat(e).hasCauseThat().isInstanceOf(AssertionError.class);, +    }, +  }, +, +  private static class RecursiveTypeBoundBugExample<T extends RecursiveTypeBoundBugExample<T>>, +      extends SubtypeTester {, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public List<RecursiveTypeBoundBugExample<?>> ifYouUseTheTypeVariableOnTheClassAndItIsRecursive(, +        List<RecursiveTypeBoundBugExample<? extends RecursiveTypeBoundBugExample<T>>> arg) {, +      return notSubtype(arg);  // isSubtype() currently incorectly considers it a subtype., +    }, +  }, +, +    public Iterable<?> noBounds(List<?> list) {, +      return isSubtype(list);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<List<?>> listOfListOfWildcard(List<List<?>> listOfList) {, +      return isSubtype(listOfList);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<? extends List<?>> listOfWildcardListOfWildcard(, +        List<? extends List<?>> listOfList) {, +      return isSubtype(listOfList);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Enum<? extends Enum<?>> implicitlyBoundedEnumIsSubtypeOfExplicitlyBoundedEnum(, +        Enum<?> e) {, +      return isSubtype(e);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Enum<?> implicitlyBoundedEnum(Enum<?> e) {, +      return isSubtype(e);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Enum<?> explicitlyBoundedEnumIsSubtypeOfImplicitlyBoundedEnum(, +        Enum<? extends Enum<?>> obj) {, +      return isSubtype(obj);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<Enum<?>> listOfEnums(List<Enum<?>> listOfEnums) {, +      return isSubtype(listOfEnums);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public UseList<? extends List<Enum<? extends Enum<?>>>>, +    wildcardBoundUsesImplicitlyRecursiveBoundedWildcard(, +        UseList<? extends List<Enum<?>>> arg) {, +      return isSubtype(arg);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public UseList<? extends List<Enum<? extends Enum<?>>>>, +    wildcardBoundHasImplicitBoundAtsInvariantPosition(, +        UseList<? extends List<Enum<?>>> arg) {, +      return isSubtype(arg);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<Enum<?>> listOfEnumsWithExplicitBoundIsSubtypeOfIterableOfEnumWithImplicitBound(, +        List<Enum<? extends Enum<?>>> listOfEnums) {, +      return isSubtype(listOfEnums);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<Enum<?>> nestedExplicitEnumBoundIsSubtypeOfImplicitEnumBound(, +        List<Enum<? extends Enum<? extends Enum<?>>>> listOfEnums) {, +      return isSubtype(listOfEnums);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<Enum<? extends Enum<? extends Enum<?>>>>, +    implicitEnumBoundIsSubtypeOfNestedExplicitEnumBound(List<Enum<?>> listOfEnums) {, +      return isSubtype(listOfEnums);, +    }, +, +    @TestSubtype(suppressGetSupertype = true, suppressGetSubtype = true), +    public Iterable<Enum<? extends Enum<?>>>]