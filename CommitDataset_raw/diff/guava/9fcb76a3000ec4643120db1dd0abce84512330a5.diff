[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          if (entry == null || isInvalid(entry)) {, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          if (entry == null || isInvalid(entry)) {, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +  // - Live: valid value is set, +  // - Expired: time expired, but old value still set, +  // - Collected: value was collected but not yet cleaned up, +  // - Invalid: marked as invalid, awaiting cleanup or reuse, +  boolean isInvalid(ReferenceEntry<K, V> entry) {, +    return isInvalid(entry.getValueReference());, +  boolean isInvalid(ValueReference<K, V> valueReference) {, +        invalidateEntry(expirable, expirable.getHash());, +              if (key != null) {, +              } else {, +                // Key was reclaimed., +                evictionNotificationQueue.offer(e);, +        if (e.getKey() == null) {, +          // TODO(user): do we need to modify count?, +          evictionNotificationQueue.offer(e);, +        } else if (e.getValueReference() != UNSET) {, +        } // else entry was invalidated, +      ValueReference<K, V> valueReference = entry.getValueReference();, +      if (isInvalid(valueReference)) {, +        // short-circuit to ensure that notifications are only sent once, +      int newCount = this.count - 1;, +          ++modCount;, +          K key = entry.getKey();, +          enqueueNotification(key, hash, valueReference);, +          enqueueCleanup(entry);, +          this.count = newCount; // write-volatile, +            if (isInvalid(e)) {]