[+++ b/guava-tests/test/com/google/common/io/BaseEncodingTest.java, +/*, + * Copyright (C) 2012 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package com.google.common.io;, +, +import static com.google.common.io.BaseEncoding.base16;, +import static com.google.common.io.BaseEncoding.base32;, +import static com.google.common.io.BaseEncoding.base32Hex;, +import static com.google.common.io.BaseEncoding.base64;, +, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.base.Ascii;, +import com.google.common.base.Charsets;, +import com.google.common.base.Joiner;, +import com.google.common.base.Splitter;, +import com.google.common.collect.ImmutableList;, +, +import junit.framework.TestCase;, +, +/**, + * Tests for {@code BaseEncoding}., + *, + * @author Louis Wasserman, + */, +@GwtCompatible, +public class BaseEncodingTest extends TestCase {, +  public void assertEquals(byte[] expected, byte[] actual) {, +    assertEquals(expected.length, actual.length);, +    for (int i = 0; i < expected.length; i++) {, +      assertEquals(expected[i], actual[i]);, +    }, +  }, +, +  public void testSeparatorsExplicitly() {, +    testEncodes(base64().withSeparator("\n", 3), "foobar", "Zm9\nvYm\nFy");, +    testEncodes(base64().withSeparator("$", 4), "foobar", "Zm9v$YmFy");, +    testEncodes(base32().withSeparator("*", 4), "foobar", "MZXW*6YTB*OI==*====");, +  }, +, +  public void testSeparatorSameAsPadChar() {, +    try {, +      base64().withSeparator("=", 3);, +      fail("Expected IllegalArgumentException");, +    } catch (IllegalArgumentException expected) {}, +, +    try {, +      base64().withPadChar('#').withSeparator("!#!", 3);, +      fail("Expected IllegalArgumentException");, +    } catch (IllegalArgumentException expected) {}, +  }, +, +  public void testAtMostOneSeparator() {, +    BaseEncoding separated = base64().withSeparator("\n", 3);, +    try {, +      separated.withSeparator("$", 4);, +      fail("Expected UnsupportedOperationException");, +    } catch (UnsupportedOperationException expected) {}, +  }, +, +  public void testBase64() {, +    // The following test vectors are specified in RFC 4648 itself, +    testEncodingWithSeparators(base64(), "", "");, +    testEncodingWithSeparators(base64(), "f", "Zg==");, +    testEncodingWithSeparators(base64(), "fo", "Zm8=");, +    testEncodingWithSeparators(base64(), "foo", "Zm9v");, +    testEncodingWithSeparators(base64(), "foob", "Zm9vYg==");, +    testEncodingWithSeparators(base64(), "fooba", "Zm9vYmE=");, +    testEncodingWithSeparators(base64(), "foobar", "Zm9vYmFy");, +  }, +, +  public void testBase64LenientPadding() {, +    testDecodes(base64(), "Zg", "f");, +    testDecodes(base64(), "Zg=", "f");, +    testDecodes(base64(), "Zg==", "f"); // proper padding length, +    testDecodes(base64(), "Zg===", "f");, +    testDecodes(base64(), "Zg====", "f");, +  }, +, +  public void testBase64InvalidDecodings() {, +    // These contain bytes not in the decodabet., +    assertFailsToDecode(base64(), "\u007f");, +    assertFailsToDecode(base64(), "Wf2!");, +    // This sentence just isn't base64() encoded., +    assertFailsToDecode(base64(), "let's not talk of love or chains!");, +    // A 4n+1 length string is never legal base64()., +    assertFailsToDecode(base64(), "12345");, +  }, +]