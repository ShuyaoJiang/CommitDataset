[+++ b/guava-tests/test/com/google/common/graph/GraphsTest.java, +import static com.google.common.graph.Graphs.oppositeNode;, +import com.google.common.collect.ImmutableList;, +import java.util.List;, +, +  private static final String E13 = "1-3";, +  public void oppositeNode_basic() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E12, N1, N2);, +      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_parallelEdge() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(MULTIGRAPH),, +        Graphs.<Integer, String>createUndirected(MULTIGRAPH));, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E12, N1, N2);, +      graph.addEdge(E12_A, N1, N2);, +      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);, +      assertThat(oppositeNode(graph, E12_A, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12_A, N2)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_selfLoop() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E11, N1, N1);, +      assertThat(oppositeNode(graph, E11, N1)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_nodeNotIncident() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E12, N1, N2);, +      graph.addEdge(E13, N1, N3);, +      try {, +        Integer unused = oppositeNode(graph, E12, N3);, +        fail("Should have rejected oppositeNode() called without a node incident to edge");, +      } catch (IllegalArgumentException expected) {, +      }, +    }, +  }, +, +  @Test, +++ b/guava-tests/test/com/google/common/graph/GraphsTest.java, +import static com.google.common.graph.Graphs.oppositeNode;, +import com.google.common.collect.ImmutableList;, +import java.util.List;, +, +  private static final String E13 = "1-3";, +  public void oppositeNode_basic() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E12, N1, N2);, +      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_parallelEdge() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(MULTIGRAPH),, +        Graphs.<Integer, String>createUndirected(MULTIGRAPH));, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E12, N1, N2);, +      graph.addEdge(E12_A, N1, N2);, +      assertThat(oppositeNode(graph, E12, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12, N2)).isEqualTo(N1);, +      assertThat(oppositeNode(graph, E12_A, N1)).isEqualTo(N2);, +      assertThat(oppositeNode(graph, E12_A, N2)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_selfLoop() {, +    List<Graph<Integer, String>> testGraphs = ImmutableList.of(, +        Graphs.<Integer, String>createDirected(), Graphs.<Integer, String>createUndirected());, +    for (Graph<Integer, String> graph : testGraphs) {, +      graph.addEdge(E11, N1, N1);, +      assertThat(oppositeNode(graph, E11, N1)).isEqualTo(N1);, +    }, +  }, +, +  @Test, +  public void oppositeNode_nodeNotIncident() {]