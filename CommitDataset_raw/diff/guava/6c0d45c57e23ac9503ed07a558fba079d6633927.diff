[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        V value = get(key, hash);, +        ReferenceEntry<K, V> entry = null;, +              ValueReference<K, V> valueReference = entry.getValueReference();, +              value = valueReference.get();, +              if (value != null) {, +                return value;, +              }, +, +              if (!valueReference.isComputingReference()) {, +                // clobber invalid entries, +                unsetLiveEntry(entry, hash);, +              }, +            if (value == null) {, +              value = entry.getValueReference().waitForValue();, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +        V value = get(key, hash);, +        ReferenceEntry<K, V> entry = null;, +              ValueReference<K, V> valueReference = entry.getValueReference();, +              value = valueReference.get();, +              if (value != null) {, +                return value;, +              }, +, +              if (!valueReference.isComputingReference()) {, +                // clobber invalid entries, +                unsetLiveEntry(entry, hash);, +              }, +            if (value == null) {, +              value = entry.getValueReference().waitForValue();, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +import com.google.common.annotations.VisibleForTesting;, +   *, +   * <p>This must be a power of two as it is used as a mask., +  static final int DRAIN_THRESHOLD = 64;, +      evictionNotificationQueue = discardingQueue();, +      this.evictionListener = nullListener();, +  /**, +   * Queue that discards all elements., +   */, +  @SuppressWarnings("unchecked"), +  // Safe because impl never uses a parameter or returns any non-null value, +  static <K, V> MapEvictionListener<K, V> nullListener() {, +    return (MapEvictionListener<K, V>) NullListener.INSTANCE;, +  }, +, +  static final Queue<Object> DISCARDING_QUEUE = new AbstractQueue<Object>() {, +  /**, +   * Queue that discards all elements., +   */, +  @SuppressWarnings("unchecked"), +  // Safe because impl never uses a parameter or returns any non-null value, +  static <E> Queue<E> discardingQueue() {, +    return (Queue<E>) DISCARDING_QUEUE;, +  }, +, +    segment.unsetValue(entry.getKey(), hash, valueReference);, +  // Valid:, +  // Invalid:, +  // - Expired: time expired (key/value may still be set), +     * include unset elements which are awaiting cleanup., +     * The cleanup queue is used to record entries which have been unset, +     * as a batch operation when either the DRAIN_THRESHOLD is crossed or, +    /**, +     * A counter of the number of reads since the last write, used to drain, +     * queues on a small fraction of read operations., +     */, +    final AtomicInteger readCount = new AtomicInteger();, +        recencyQueue = discardingQueue();, +      // we are not under lock, so only drain a small fraction of the time, +      if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {, +        scheduleCleanup();, +        if (!unsetEntry(expirable, expirable.getHash())) {, +      if (!unsetEntry(evictable, evictable.getHash())) {, +     * Returns the entry for a given key. Note that the entry may not be live., +     * This is only used for testing., +    @VisibleForTesting ReferenceEntry<K, V> getEntry(Object key, int hash) {, +      if (count != 0) { // read-volatile, +        for (ReferenceEntry<K, V> e = getFirst(hash); e != null;, +            e = e.getNext()) {, +          if (e.getHash() != hash) {, +            continue;, +          K entryKey = e.getKey();, +          if (entryKey == null) {, +            continue;, +          }, +, +          if (keyEquivalence.equivalent(key, entryKey)) {, +            V value = getLiveValue(e);, +            if (value != null) {, +              recordRead(e);, +            }, +            return value;, +          }, +        }, +      }, +, +      return null;, +          newCount = this.count + 1;, +              // Value could be partially-collected, unset, or computing.]