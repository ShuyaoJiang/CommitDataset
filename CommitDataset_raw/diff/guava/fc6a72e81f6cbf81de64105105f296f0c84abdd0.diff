[+++ b/guava-testlib/src/com/google/common/util/concurrent/testing/TestingExecutors.java, +import com.google.common.util.concurrent.ListenableScheduledFuture;, +    @Override public <V> ListenableScheduledFuture<V> schedule(, +    @Override public ListenableScheduledFuture<?> schedule(, +        Runnable command, long delay, TimeUnit unit) {, +    @Override public ListenableScheduledFuture<?> scheduleAtFixedRate(, +    @Override public ListenableScheduledFuture<?> scheduleWithFixedDelay(, +        extends AbstractFuture<V> implements ListenableScheduledFuture<V> {, +++ b/guava-testlib/src/com/google/common/util/concurrent/testing/TestingExecutors.java, +import com.google.common.util.concurrent.ListenableScheduledFuture;, +    @Override public <V> ListenableScheduledFuture<V> schedule(, +    @Override public ListenableScheduledFuture<?> schedule(, +        Runnable command, long delay, TimeUnit unit) {, +    @Override public ListenableScheduledFuture<?> scheduleAtFixedRate(, +    @Override public ListenableScheduledFuture<?> scheduleWithFixedDelay(, +        extends AbstractFuture<V> implements ListenableScheduledFuture<V> {, +++ b/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.ScheduledFuture;, +  public void testListeningDecorator_scheduleSuccess() throws Exception {, +    ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1);, +    ListeningScheduledExecutorService service = listeningDecorator(delegate);, +    ListenableFuture<?> future =, +        service.schedule(Callables.returning(null), 1, TimeUnit.MILLISECONDS);, +, +    future.get(); // wait until done, +    assertTrue(future.isDone());, +    assertListenerRunImmediately(future);, +    assertEquals(0, delegate.getQueue().size());, +  }, +, +  public void testListeningDecorator_scheduleFailure() throws Exception {, +    ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1);, +    ListeningScheduledExecutorService service = listeningDecorator(delegate);, +    RuntimeException ex = new RuntimeException();, +    ListenableFuture<?> future =, +        service.schedule(new ThrowingRunnable(0, ex), 1, TimeUnit.MILLISECONDS);, +    assertExecutionException(future, ex);, +    assertEquals(0, delegate.getQueue().size());, +  }, +, +  public void testListeningDecorator_schedulePeriodic() throws Exception {, +    ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1);, +    ListeningScheduledExecutorService service = listeningDecorator(delegate);, +    RuntimeException ex = new RuntimeException();, +, +    ListenableFuture<?> future;, +, +    ThrowingRunnable runnable = new ThrowingRunnable(5, ex);, +    future = service.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.MILLISECONDS);, +    assertExecutionException(future, ex);, +    assertEquals(5, runnable.count);, +    assertEquals(0, delegate.getQueue().size());, +, +    runnable = new ThrowingRunnable(5, ex);, +    future = service.scheduleWithFixedDelay(runnable, 1, 1, TimeUnit.MILLISECONDS);, +    assertExecutionException(future, ex);, +    assertEquals(5, runnable.count);, +    assertEquals(0, delegate.getQueue().size());, +  }, +, +  public void testListeningDecorator_cancelled() throws Exception {, +    ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1);, +    BlockingQueue<?> delegateQueue = delegate.getQueue();, +    ListeningScheduledExecutorService service = listeningDecorator(delegate);, +    ListenableFuture<?> future;, +    ScheduledFuture<?> delegateFuture;, +, +    Runnable runnable = new Runnable() {, +      @Override public void run() {}, +    };, +, +    future = service.schedule(runnable, 5, TimeUnit.MINUTES);, +    future.cancel(true);, +    assertTrue(future.isCancelled());, +    delegateFuture = (ScheduledFuture<?>) delegateQueue.element();, +    assertTrue(delegateFuture.isCancelled());, +, +    delegateQueue.clear();, +, +    future = service.scheduleAtFixedRate(runnable, 5, 5, TimeUnit.MINUTES);, +    future.cancel(true);, +    assertTrue(future.isCancelled());, +    delegateFuture = (ScheduledFuture<?>) delegateQueue.element();, +    assertTrue(delegateFuture.isCancelled());, +, +    delegateQueue.clear();, +, +    future = service.scheduleWithFixedDelay(runnable, 5, 5, TimeUnit.MINUTES);, +    future.cancel(true);, +    assertTrue(future.isCancelled());, +    delegateFuture = (ScheduledFuture<?>) delegateQueue.element();, +    assertTrue(delegateFuture.isCancelled());, +  }, +, +  private static final class ThrowingRunnable implements Runnable {, +    final int throwAfterCount;, +    final RuntimeException thrown;, +    int count;, +]