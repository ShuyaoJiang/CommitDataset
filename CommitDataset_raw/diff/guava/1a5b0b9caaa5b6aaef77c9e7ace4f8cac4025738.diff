[+++ b/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java, +import java.lang.Thread.State;, +  /**, +   * Test for a bug where threads weren't getting signaled when shutdown was called, only when, +   * tasks completed., +   */, +, +  public void testDirectExecutorService_awaitTermination_missedSignal() {, +    final ExecutorService service = MoreExecutors.newDirectExecutorService();, +    Thread waiter = new Thread() {, +      @Override public void run() {, +        try {, +          service.awaitTermination(1, TimeUnit.DAYS);, +        } catch (InterruptedException e) {, +          return;, +        }, +      }, +    };, +    waiter.start();, +    awaitTimedWaiting(waiter);, +    service.shutdown();, +    Uninterruptibles.joinUninterruptibly(waiter, 10, TimeUnit.SECONDS);, +    if (waiter.isAlive()) {, +      waiter.interrupt();, +      fail("awaitTermination failed to trigger after shutdown()");, +    }, +  }, +, +  /** Wait for the given thread to reach the {@link State#TIMED_WAITING} thread state. */, +  void awaitTimedWaiting(Thread thread) {, +    while (true) {, +      switch (thread.getState()) {, +        case BLOCKED:, +        case NEW:, +        case RUNNABLE:, +        case WAITING:, +          Thread.yield();, +          break;, +        case TIMED_WAITING:, +          return;, +        case TERMINATED:, +        default:, +          throw new AssertionError();, +      }, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java, +import java.lang.Thread.State;, +  /**, +   * Test for a bug where threads weren't getting signaled when shutdown was called, only when, +   * tasks completed., +   */, +, +  public void testDirectExecutorService_awaitTermination_missedSignal() {, +    final ExecutorService service = MoreExecutors.newDirectExecutorService();, +    Thread waiter = new Thread() {, +      @Override public void run() {, +        try {, +          service.awaitTermination(1, TimeUnit.DAYS);, +        } catch (InterruptedException e) {, +          return;, +        }, +      }, +    };, +    waiter.start();, +    awaitTimedWaiting(waiter);, +    service.shutdown();, +    Uninterruptibles.joinUninterruptibly(waiter, 10, TimeUnit.SECONDS);, +    if (waiter.isAlive()) {, +      waiter.interrupt();, +      fail("awaitTermination failed to trigger after shutdown()");, +    }, +  }, +, +  /** Wait for the given thread to reach the {@link State#TIMED_WAITING} thread state. */, +  void awaitTimedWaiting(Thread thread) {, +    while (true) {, +      switch (thread.getState()) {, +        case BLOCKED:, +        case NEW:, +        case RUNNABLE:, +        case WAITING:, +          Thread.yield();, +          break;, +        case TIMED_WAITING:, +          return;, +        case TERMINATED:, +        default:, +          throw new AssertionError();, +      }, +    }, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/MoreExecutors.java, +, +import javax.annotation.concurrent.GuardedBy;, +     * (runningTasks, shutdown) of the executor, +    private final Object lock = new Object();, +    @GuardedBy("lock") private int runningTasks = 0;]