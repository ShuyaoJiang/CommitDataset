[+++ b/guava-tests/test/com/google/common/util/concurrent/JdkFutureAdaptersTest.java, +import java.util.concurrent.SynchronousQueue;, +import java.util.concurrent.ThreadPoolExecutor;, +  public void testListenInPoolThreadCustomExecutorInterrupted(), +      throws Exception {, +    final CountDownLatch submitSuccessful = new CountDownLatch(1);, +    ExecutorService executorService = new ThreadPoolExecutor(, +        0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,, +        new SynchronousQueue<Runnable>(),, +        new ThreadFactoryBuilder().setDaemon(true).build()) {, +      @Override, +      protected void beforeExecute(Thread t, Runnable r) {, +        submitSuccessful.countDown();, +      }, +    };, +    NonListenableSettableFuture<String> abstractFuture =, +        NonListenableSettableFuture.create();, +    ListenableFuture<String> listenableFuture =, +        listenInPoolThread(abstractFuture, executorService);, +, +    SingleCallListener singleCallListener = new SingleCallListener();, +    singleCallListener.expectCall();, +, +    assertFalse(singleCallListener.wasCalled());, +    assertFalse(listenableFuture.isDone());, +, +    listenableFuture.addListener(singleCallListener, sameThreadExecutor());, +    /*, +     * Don't shut down until the listenInPoolThread task has been accepted to, +     * run. We want to see what happens when it's interrupted, not when it's, +     * rejected., +     */, +    submitSuccessful.await();, +    executorService.shutdownNow();, +    abstractFuture.set(DATA1);, +    assertEquals(DATA1, listenableFuture.get());, +    singleCallListener.waitForCall();, +, +    assertTrue(singleCallListener.wasCalled());, +    assertTrue(listenableFuture.isDone());, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/JdkFutureAdaptersTest.java, +import java.util.concurrent.SynchronousQueue;, +import java.util.concurrent.ThreadPoolExecutor;, +  public void testListenInPoolThreadCustomExecutorInterrupted(), +      throws Exception {, +    final CountDownLatch submitSuccessful = new CountDownLatch(1);, +    ExecutorService executorService = new ThreadPoolExecutor(, +        0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,, +        new SynchronousQueue<Runnable>(),, +        new ThreadFactoryBuilder().setDaemon(true).build()) {, +      @Override, +      protected void beforeExecute(Thread t, Runnable r) {, +        submitSuccessful.countDown();, +      }, +    };, +    NonListenableSettableFuture<String> abstractFuture =, +        NonListenableSettableFuture.create();, +    ListenableFuture<String> listenableFuture =, +        listenInPoolThread(abstractFuture, executorService);, +, +    SingleCallListener singleCallListener = new SingleCallListener();, +    singleCallListener.expectCall();, +, +    assertFalse(singleCallListener.wasCalled());, +    assertFalse(listenableFuture.isDone());, +, +    listenableFuture.addListener(singleCallListener, sameThreadExecutor());, +    /*, +     * Don't shut down until the listenInPoolThread task has been accepted to, +     * run. We want to see what happens when it's interrupted, not when it's, +     * rejected., +     */, +    submitSuccessful.await();, +    executorService.shutdownNow();, +    abstractFuture.set(DATA1);, +    assertEquals(DATA1, listenableFuture.get());, +    singleCallListener.waitForCall();, +, +    assertTrue(singleCallListener.wasCalled());, +    assertTrue(listenableFuture.isDone());, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +              /*, +               * Threads from our private pool are never interrupted. Threads, +               * from a user-supplied executor might be, but... what can we do?, +               * This is another reason to return a proper ListenableFuture, +               * instead of using listenInPoolThread., +               */, +              getUninterruptibly(delegate);]