[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              computingValueReference = new ComputingValueReference();, +, +, +                clearValue(key, hash, computingValueReference);, +                clearValue(key, hash, valueReference);, +  /** Used to provide computation result to other threads. */, +  private static class ComputedReference<K, V> implements ValueReference<K, V> {, +    final V value;, +    ComputedReference(V value) {, +      this.value = value;, +    }, +    public V get() {, +      return value;, +    }, +    public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {, +      return this;, +    }, +    public V waitForValue() {, +      return get();, +    }, +    public void clear() {}, +  }, +, +      return computedReference.waitForValue();, +      setValueReference(new ComputedReference<K, V>(value));, +              segment.setValue(e, value);, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              computingValueReference = new ComputingValueReference();, +, +, +                clearValue(key, hash, computingValueReference);, +                clearValue(key, hash, valueReference);, +  /** Used to provide computation result to other threads. */, +  private static class ComputedReference<K, V> implements ValueReference<K, V> {, +    final V value;, +    ComputedReference(V value) {, +      this.value = value;, +    }, +    public V get() {, +      return value;, +    }, +    public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {, +      return this;, +    }, +    public V waitForValue() {, +      return get();, +    }, +    public void clear() {}, +  }, +, +      return computedReference.waitForValue();, +      setValueReference(new ComputedReference<K, V>(value));, +              segment.setValue(e, value);, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +              ++modCount;, +          ++modCount;, +    boolean clearValue(K key, int hash, ValueReference<K, V> valueReference) {, +          K entryKey = e.getKey();, +          if (e.getHash() == hash && entryKey != null, +              && keyEquivalence.equivalent(key, entryKey)) {, +            ValueReference<K, V> v = e.getValueReference();, +              ++modCount;, +              enqueueCleanup(e);, +              this.count = newCount;]