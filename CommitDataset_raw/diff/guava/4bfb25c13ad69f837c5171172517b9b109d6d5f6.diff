[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/HashBiMap.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.base.Objects;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.Map.Entry;, + * GWT emulation of {@code HashBiMap} that just delegates to a LinkedHashMap and a HashMap., +    // we only care about the forward-direction order, so only that direction needs to be an LHM, +    super(new LinkedHashMap<K, V>(), new HashMap<V, K>());, +    // we only care about the forward-direction order, so only that direction needs to be an LHM, +        Maps.<K, V>newLinkedHashMapWithExpectedSize(expectedSize),, +  @Override, +  AbstractBiMap<V, K> makeInverse(Map<V, K> backward) {, +    return new Inverse<V, K>(backward, this) {, +      @Override, +      Iterator<Entry<V, K>> entrySetIterator() {, +        return new TransformedIterator<Entry<K, V>, Entry<V, K>>(, +            HashBiMap.this.delegate().entrySet().iterator()) {, +          @Override, +          public Entry<V, K> transform(final Entry<K, V> forwardEntry) {, +            return new AbstractMapEntry<V, K>() {, +              final V value = forwardEntry.getValue();, +, +              @Override, +              public V getKey() {, +                return value;, +              }, +, +              @Override, +              public K getValue() {, +                return delegate().get(value);, +              }, +, +              @Override, +              public K setValue(K newKey) {, +                // Preconditions keep the map and inverse consistent., +                checkState(entrySet().contains(this), "entry no longer in map");, +                K oldKey = getValue();, +                if (Objects.equal(newKey, oldKey)) {, +                  return newKey;, +                }, +                forcePut(value, newKey);, +                return oldKey;, +              }, +            };, +          }, +        };, +      }, +    };, +  }, +, +  @Override, +  public V put(@Nullable K key, @Nullable V value) {, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/HashBiMap.java, +import static com.google.common.base.Preconditions.checkState;, +import com.google.common.base.Objects;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.Map.Entry;, + * GWT emulation of {@code HashBiMap} that just delegates to a LinkedHashMap and a HashMap., +    // we only care about the forward-direction order, so only that direction needs to be an LHM, +    super(new LinkedHashMap<K, V>(), new HashMap<V, K>());, +    // we only care about the forward-direction order, so only that direction needs to be an LHM, +        Maps.<K, V>newLinkedHashMapWithExpectedSize(expectedSize),, +  @Override, +  AbstractBiMap<V, K> makeInverse(Map<V, K> backward) {, +    return new Inverse<V, K>(backward, this) {, +      @Override, +      Iterator<Entry<V, K>> entrySetIterator() {, +        return new TransformedIterator<Entry<K, V>, Entry<V, K>>(, +            HashBiMap.this.delegate().entrySet().iterator()) {, +          @Override, +          public Entry<V, K> transform(final Entry<K, V> forwardEntry) {, +            return new AbstractMapEntry<V, K>() {, +              final V value = forwardEntry.getValue();, +, +              @Override, +              public V getKey() {, +                return value;, +              }, +, +              @Override, +              public K getValue() {, +                return delegate().get(value);, +              }, +, +              @Override, +              public K setValue(K newKey) {, +                // Preconditions keep the map and inverse consistent., +                checkState(entrySet().contains(this), "entry no longer in map");, +                K oldKey = getValue();, +                if (Objects.equal(newKey, oldKey)) {, +                  return newKey;, +                }, +                forcePut(value, newKey);, +                return oldKey;]