[+++ b/guava-tests/test/com/google/common/io/FilesTest.java, +/*, + * Copyright (C) 2007 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.io;, +, +import static com.google.common.io.Files.createTempDir;, +import static com.google.common.io.Files.touch;, +import static org.truth0.Truth.ASSERT;, +, +import com.google.common.base.Charsets;, +import com.google.common.collect.ImmutableList;, +import com.google.common.hash.Hashing;, +import com.google.common.primitives.Bytes;, +, +import junit.framework.TestSuite;, +, +import java.io.BufferedReader;, +import java.io.BufferedWriter;, +import java.io.ByteArrayOutputStream;, +import java.io.File;, +import java.io.FileNotFoundException;, +import java.io.IOException;, +import java.io.PrintWriter;, +import java.io.RandomAccessFile;, +import java.nio.ByteBuffer;, +import java.nio.MappedByteBuffer;, +import java.nio.channels.FileChannel.MapMode;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +import java.util.Random;, +, +/**, + * Unit test for {@link Files}., + *, + * @author Chris Nokleberg, + */, +public class FilesTest extends IoTestCase {, +, +  public static TestSuite suite() {, +    TestSuite suite = new TestSuite();, +    suite.addTest(ByteSourceTester.tests("Files.asByteSource[File]",, +        SourceSinkFactories.fileByteSourceFactory(), true));, +    suite.addTest(ByteSinkTester.tests("Files.asByteSink[File]",, +        SourceSinkFactories.fileByteSinkFactory()));, +    suite.addTest(ByteSinkTester.tests("Files.asByteSink[File, APPEND]",, +        SourceSinkFactories.appendingFileByteSinkFactory()));, +    suite.addTest(CharSourceTester.tests("Files.asCharSource[File, Charset]",, +        SourceSinkFactories.fileCharSourceFactory()));, +    suite.addTest(CharSinkTester.tests("Files.asCharSink[File, Charset]",, +        SourceSinkFactories.fileCharSinkFactory()));, +    suite.addTest(CharSinkTester.tests("Files.asCharSink[File, Charset, APPEND]",, +        SourceSinkFactories.appendingFileCharSinkFactory()));, +    suite.addTestSuite(FilesTest.class);, +    return suite;, +  }, +, +  public void testToByteArray() throws IOException {, +    File asciiFile = getTestFile("ascii.txt");, +    File i18nFile = getTestFile("i18n.txt");, +    assertTrue(Arrays.equals(ASCII.getBytes(Charsets.US_ASCII),, +        Files.toByteArray(asciiFile)));, +    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8),, +        Files.toByteArray(i18nFile)));, +    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8),, +        Files.asByteSource(i18nFile).read()));, +, +    assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8),, +        Files.toByteArray(new BadLengthFile(i18nFile, 0))));, +, +    try {, +      Files.toByteArray(new BadLengthFile(asciiFile, 1L + Integer.MAX_VALUE));, +      fail("expected exception");, +    } catch (OutOfMemoryError expected) {, +    }, +  }, +, +  /**, +   * A {@link File} that provides a specialized value for {link File#length()}., +   */, +  private static class BadLengthFile extends File {, +, +    private final long badLength;, +, +    public BadLengthFile(File delegate, long badLength) {, +      super(delegate.getPath());]