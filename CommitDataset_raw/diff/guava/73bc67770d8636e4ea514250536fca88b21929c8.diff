[+++ b/guava-tests/test/com/google/common/collect/RangeTest.java, +  public void testIsConnected() {, +    assertTrue(Ranges.closed(3, 5).isConnected(Ranges.open(5, 6)));, +    assertTrue(Ranges.closed(3, 5).isConnected(Ranges.openClosed(5, 5)));, +    assertTrue(Ranges.open(3, 5).isConnected(Ranges.closed(5, 6)));, +    assertTrue(Ranges.closed(3, 7).isConnected(Ranges.open(6, 8)));, +    assertTrue(Ranges.open(3, 7).isConnected(Ranges.closed(5, 6)));, +    assertFalse(Ranges.closed(3, 5).isConnected(Ranges.closed(7, 8)));, +    assertFalse(Ranges.closed(3, 5).isConnected(Ranges.closedOpen(7, 7)));, +  }, +, +, +    range = Ranges.closed(3, 4);, +    assertEquals(Ranges.openClosed(4, 4),, +        range.intersection(Ranges.greaterThan(4)));, +++ b/guava-tests/test/com/google/common/collect/RangeTest.java, +  public void testIsConnected() {, +    assertTrue(Ranges.closed(3, 5).isConnected(Ranges.open(5, 6)));, +    assertTrue(Ranges.closed(3, 5).isConnected(Ranges.openClosed(5, 5)));, +    assertTrue(Ranges.open(3, 5).isConnected(Ranges.closed(5, 6)));, +    assertTrue(Ranges.closed(3, 7).isConnected(Ranges.open(6, 8)));, +    assertTrue(Ranges.open(3, 7).isConnected(Ranges.closed(5, 6)));, +    assertFalse(Ranges.closed(3, 5).isConnected(Ranges.closed(7, 8)));, +    assertFalse(Ranges.closed(3, 5).isConnected(Ranges.closedOpen(7, 7)));, +  }, +, +, +    range = Ranges.closed(3, 4);, +    assertEquals(Ranges.openClosed(4, 4),, +        range.intersection(Ranges.greaterThan(4)));, +++ b/guava/src/com/google/common/collect/Range.java, +   * <li>if {@code a.encloses(b)}, then {@link #isConnected a.isConnected(b)}, +   *     is {@code true}. , +   * range and {@code other}, if such a range exists., +   * , +   * <p>For example, the intersection of {@code [1..5]} and {@code (3..7)} is, +   * {@code (3..5]}. The resulting range may be empty; for example, , +   * {@code [1..5)} intersected with {@code [5..7)} yields the empty range, +   * {@code [5..5)}., +   * , +   * <p>Generally, the intersection exists if and only if this range and , +   * {@code other} are {@linkplain #isConnected connected}., +   * Returns {@code true} if there exists a (possibly empty) range which is, +   * {@linkplain #encloses enclosed} by both this range and {@code other}., +   * , +   * <p>For example,, +   * <ul>, +   * <li>{@code [2, 4)} and {@code [5, 7)} are not connected, +   * <li>{@code [2, 4)} and {@code [3, 5)} are connected, because both enclose, +   *     {@code [3, 4)}, +   * <li>{@code [2, 4)} and {@code [4, 6)} are connected, because both enclose, +   *     the empty range {@code [4, 4)}, +   * </ul>, +   * , +   * <p>Note that this range and {@code other} have a well-defined {@linkplain, +   * #span union} and {@linkplain #intersection intersection} (as a single,, +   * possibly-empty range) if and only if this method returns {@code true}., +   * , +   * <p>The connectedness relation has the following properties:, +   *, +   * <ul>, +   * <li>symmetric: {@code a.isConnected(b)} produces the same result as, +   *     {@code b.isConnected(a)}, +   * <li>reflexive: {@code a.isConnected(a)} returns {@code true}, +   * </ul>, +   */, +  public boolean isConnected(Range<C> other) {, +    return lowerBound.compareTo(other.upperBound) <= 0, +        && other.lowerBound.compareTo(upperBound) <= 0;, +  }, +, +  /**, +   * , +   * <p>Note that the returned range is also called the <i>union</i> of this, +   * range and {@code other} if and only if the ranges are , +   * {@linkplain #isConnected connected}.]