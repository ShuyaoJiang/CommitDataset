[+++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java, +    assertCancelled(future, /* expectWasCancelled= */ false);, +    assertCancelled(future, /* expectWasCancelled= */ false);, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java, +    assertCancelled(future, /* expectWasCancelled= */ false);, +    assertCancelled(future, /* expectWasCancelled= */ false);, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +@SuppressWarnings("ShortCircuitBoolean") // we use non-short circuiting comparisons intentionally, +    // constants to use when GENERATE_CANCELLATION_CAUSES = false, +    static final Cancellation CAUSELESS_INTERRUPTED;, +    static final Cancellation CAUSELESS_CANCELLED;, +, +    static {, +      if (GENERATE_CANCELLATION_CAUSES) {, +        CAUSELESS_CANCELLED = null;, +        CAUSELESS_INTERRUPTED = null;, +      } else {, +        CAUSELESS_CANCELLED = new Cancellation(false, null);, +        CAUSELESS_INTERRUPTED = new Cancellation(true, null);, +      }, +    }, +, +      Object valueToSet =, +              ? new Cancellation(, +                  mayInterruptIfRunning, new CancellationException("Future.cancel() was called.")), +              : (mayInterruptIfRunning, +                  ? Cancellation.CAUSELESS_INTERRUPTED, +                  : Cancellation.CAUSELESS_CANCELLED);, +   * <p>Note that, even if the supplied future is cancelled and it causes this future to complete,, +   * it will never trigger interruption behavior. In particular, it will not cause this future to, +   * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not, +   * return {@code true}., +   *, +   * Returns a value that satisfies the contract of the {@link #value} field based on the state of, +   * given future., +      Object v = ((AbstractFuture<?>) future).value;, +      if (v instanceof Cancellation) {, +        // If the other future was interrupted, clear the interrupted bit while preserving the cause, +        // this will make it consistent with how non-trustedfutures work which cannot propagate the, +        // wasInterrupted bit, +        Cancellation c = (Cancellation) v;, +        if (c.wasInterrupted) {, +          v =, +              c.cause != null, +                  ? new Cancellation(/* wasInterrupted= */ false, c.cause), +                  : Cancellation.CAUSELESS_CANCELLED;, +        }, +      }, +      return v;, +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java, +    assertCancelled(future, /* expectWasCancelled= */ false);, +    assertCancelled(future, /* expectWasCancelled= */ false);, +++ b/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +@SuppressWarnings("ShortCircuitBoolean") // we use non-short circuiting comparisons intentionally, +    // constants to use when GENERATE_CANCELLATION_CAUSES = false, +    static final Cancellation CAUSELESS_INTERRUPTED;, +    static final Cancellation CAUSELESS_CANCELLED;, +, +    static {, +      if (GENERATE_CANCELLATION_CAUSES) {, +        CAUSELESS_CANCELLED = null;, +        CAUSELESS_INTERRUPTED = null;, +      } else {, +        CAUSELESS_CANCELLED = new Cancellation(false, null);, +        CAUSELESS_INTERRUPTED = new Cancellation(true, null);, +      }, +    }, +, +      Object valueToSet =, +              ? new Cancellation(, +                  mayInterruptIfRunning, new CancellationException("Future.cancel() was called.")), +              : (mayInterruptIfRunning, +                  ? Cancellation.CAUSELESS_INTERRUPTED, +                  : Cancellation.CAUSELESS_CANCELLED);, +   * <p>Note that, even if the supplied future is cancelled and it causes this future to complete,, +   * it will never trigger interruption behavior. In particular, it will not cause this future to, +   * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not, +   * return {@code true}., +   *, +   * Returns a value that satisfies the contract of the {@link #value} field based on the state of, +   * given future., +      Object v = ((AbstractFuture<?>) future).value;, +      if (v instanceof Cancellation) {, +        // If the other future was interrupted, clear the interrupted bit while preserving the cause, +        // this will make it consistent with how non-trustedfutures work which cannot propagate the, +        // wasInterrupted bit, +        Cancellation c = (Cancellation) v;, +        if (c.wasInterrupted) {, +          v =, +              c.cause != null, +                  ? new Cancellation(/* wasInterrupted= */ false, c.cause), +                  : Cancellation.CAUSELESS_CANCELLED;, +        }, +      }, +      return v;, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +        // don't copy the mayInterruptIfRunning bit, for consistency with the server, to ensure that, +        // interruptTask() is called if and only if the bit is true and because we cannot infer the, +        // interrupt status from non AbstractFuture futures., +++ b/android/guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java]