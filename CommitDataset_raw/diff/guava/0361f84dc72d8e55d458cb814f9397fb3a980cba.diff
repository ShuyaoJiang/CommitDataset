[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java, +import com.google.testing.util.MoreAsserts;, +      MoreAsserts.assertNotEqual(State.NEW, service.state());, +      MoreAsserts.assertNotEqual(State.STARTING, service.state());, +      MoreAsserts.assertNotEqual(from, service.state());, +      if (from == State.STARTING) {, +        try {, +          service.startAndWait();, +        } catch (UncheckedExecutionException e) {, +          assertEquals(failure, e.getCause());, +        }, +      }, +      try {, +        service.stopAndWait();, +      } catch (UncheckedExecutionException e) {, +        if (from == State.STOPPING) {, +          assertEquals(failure, e.getCause());, +        } else {, +          assertEquals(failure, e.getCause().getCause());, +        }, +      }, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java, +import com.google.testing.util.MoreAsserts;, +      MoreAsserts.assertNotEqual(State.NEW, service.state());, +      MoreAsserts.assertNotEqual(State.STARTING, service.state());, +      MoreAsserts.assertNotEqual(from, service.state());, +      if (from == State.STARTING) {, +        try {, +          service.startAndWait();, +        } catch (UncheckedExecutionException e) {, +          assertEquals(failure, e.getCause());, +        }, +      }, +      try {, +        service.stopAndWait();, +      } catch (UncheckedExecutionException e) {, +        if (from == State.STOPPING) {, +          assertEquals(failure, e.getCause());, +        } else {, +          assertEquals(failure, e.getCause().getCause());, +        }, +      }, +++ b/guava/src/com/google/common/util/concurrent/AbstractService.java, +import com.google.common.collect.Queues;, +import java.util.Queue;, + * @author Luke Sandberg, +  private static final Logger logger = Logger.getLogger(, +      AbstractService.class.getName());, +   * The queue of listeners that are waiting to be executed., +   *, +   * <p>Enqueue operations should be protected by {@link #lock} while dequeue, +   * operations should be protected by the implicit lock on this object. Dequeue, +   * operations should be executed atomically with the execution of the, +   * {@link Runnable} and additionally the {@link #lock} should not be held when, +   * the listeners are being executed. Use {@link #executeListeners} for this, +   * operation.  This is necessary to ensure that elements on the queue are, +   * executed in the correct order.  Enqueue operations should be protected so, +   * that listeners are added in the correct order. We use a concurrent queue, +   * implementation so that enqueues can be executed concurrently with dequeues., +   */, +  @GuardedBy("queuedListeners"), +  private final Queue<Runnable> queuedListeners =, +      Queues.newConcurrentLinkedQueue();, +, +  /**, +                shutdown.setException(, +                    new Exception("Service failed to start.", failure));, +      executeListeners();, +        case STOPPING:, +        case TERMINATED:, +      executeListeners();, +      executeListeners();, +      executeListeners();, +      executeListeners();, +  /**, +   * Attempts to execute all the listeners in {@link #queuedListeners} while not holding the, +   * {@link #lock}., +   */, +  private void executeListeners() {, +    if (!lock.isHeldByCurrentThread()) {, +      synchronized (queuedListeners) {, +        Runnable listener;, +        while ((listener = queuedListeners.poll()) != null) {, +          listener.run();, +        }, +      }, +    }, +  }, +, +    for (final ListenerExecutorPair pair : listeners) {, +      queuedListeners.add(new Runnable() {, +        @Override public void run() {, +          pair.execute(new Runnable() {, +            @Override public void run() {, +              pair.listener.starting();, +            }, +          });, +        }, +      });, +    for (final ListenerExecutorPair pair : listeners) {]