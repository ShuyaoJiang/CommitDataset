[+++ b/guava-tests/test/com/google/common/primitives/UnsignedLongsTest.java, +  public void testDecodeLong() {, +    assertEquals(0xffffffffffffffffL, UnsignedLongs.decode("0xffffffffffffffff"));, +    assertEquals(01234567, UnsignedLongs.decode("01234567")); //octal, +    assertEquals(0x1234567890abcdefL, UnsignedLongs.decode("#1234567890abcdef"));, +    assertEquals(987654321012345678L, UnsignedLongs.decode("987654321012345678"));, +    assertEquals(0x135791357913579L, UnsignedLongs.decode("0x135791357913579"));, +    assertEquals(0x135791357913579L, UnsignedLongs.decode("0X135791357913579"));, +    assertEquals(0L, UnsignedLongs.decode("0"));, +, +    boolean overflowCaught = false;, +    try {, +      // One more than maximum value, +      UnsignedLongs.parseUnsignedLong("0xfffffffffffffffff");, +      fail();, +    } catch (NumberFormatException e) {, +      // Expected, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/primitives/UnsignedLongsTest.java, +  public void testDecodeLong() {, +    assertEquals(0xffffffffffffffffL, UnsignedLongs.decode("0xffffffffffffffff"));, +    assertEquals(01234567, UnsignedLongs.decode("01234567")); //octal, +    assertEquals(0x1234567890abcdefL, UnsignedLongs.decode("#1234567890abcdef"));, +    assertEquals(987654321012345678L, UnsignedLongs.decode("987654321012345678"));, +    assertEquals(0x135791357913579L, UnsignedLongs.decode("0x135791357913579"));, +    assertEquals(0x135791357913579L, UnsignedLongs.decode("0X135791357913579"));, +    assertEquals(0L, UnsignedLongs.decode("0"));, +, +    boolean overflowCaught = false;, +    try {, +      // One more than maximum value, +      UnsignedLongs.parseUnsignedLong("0xfffffffffffffffff");, +      fail();, +    } catch (NumberFormatException e) {, +      // Expected, +    }, +  }, +, +++ b/guava/src/com/google/common/primitives/UnsignedLongs.java, +   * Returns the {@code unsigned long} value represented by the given string., +   * , +   * Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:, +   * , +   * <ul>, +   * <li>{@code 0x}<i>HexDigits</i>, +   * <li>{@code 0X}<i>HexDigits</i>, +   * <li>{@code #}<i>HexDigits</i>, +   * <li>{@code 0}<i>OctalDigits</i>, +   * </ul>, +   * , +   * @throws NumberFormatException if the string does not contain a valid {@code unsigned long}, +   *         value, +   * @since 13.0, +   */, +  public static long decode(String stringValue) {, +    if (stringValue.length() == 0) {, +      throw new NumberFormatException("empty string");, +    }, +, +    // Handle radix specifier if present, +    String rawValue;, +    int radix;, +    char firstChar = stringValue.charAt(0);, +    if (stringValue.startsWith("0x") || stringValue.startsWith("0X")) {, +      rawValue = stringValue.substring(2);, +      radix = 16;, +    } else if (firstChar == '#') {, +      rawValue = stringValue.substring(1);, +      radix = 16;, +    } else if (firstChar == '0' && stringValue.length() > 1) {, +      rawValue = stringValue.substring(1);, +      radix = 8;, +    } else {, +      rawValue = stringValue;, +      radix = 10;, +    }, +, +    try {, +      return parseUnsignedLong(rawValue, radix);, +    } catch (NumberFormatException e) {, +      NumberFormatException decodeException =, +          new NumberFormatException("Error parsing value: " + stringValue);, +      decodeException.initCause(e);, +      throw decodeException;, +    }, +  }, +, +  /**]