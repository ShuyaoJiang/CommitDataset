[+++ b/guava/src/com/google/common/base/Optional.java, +public abstract class Optional<T> {, +  private static final Optional<Object> ABSENT = new Absent();, +    return new Present<T>(checkNotNull(reference));, +        : new Present<T>(nullableReference);, +  private Optional() {}, +  public abstract boolean isPresent();, +  public abstract T get();, +, +  /**, +   * Returns the contained non-null reference if it is present; {@code defaultValue} otherwise., +   *, +   * @deprecated use {@link #orNull} for {@code get(null)}; {@link #or(Object)} otherwise, +   */, +  // TODO(kevinb): remove, +  @Deprecated @Nullable public abstract T get(@Nullable T defaultValue);, +  public abstract T or(T defaultValue);, +  /**, +   * Returns this {@code Optional} if it has a value present; {@code secondChoice} otherwise., +   */, +  // ? extends T is the best we can do; if it doesn't fit you'll have to do some creative casting, +  public abstract Optional<T> or(Optional<? extends T> secondChoice);, +, +  /**, +   * Returns the contained non-null reference if it is present; {@code null} otherwise., +   */, +  @Nullable public abstract T orNull();, +  @Override public abstract boolean equals(@Nullable Object object);, +  @Override public abstract int hashCode();, +  @Override public abstract String toString();, +, +  private static final class Present<T> extends Optional<T> {, +    private final T reference;, +, +    Present(T reference) {, +      this.reference = reference;, +    }, +, +    @Override public boolean isPresent() {, +      return true;, +    }, +, +    @Override public T get() {, +      return reference;, +    }, +, +    @Override @Nullable public T get(@Nullable T defaultValue) {, +      return reference;, +    }, +, +    @Override public T or(T defaultValue) {, +      checkNotNull(defaultValue);, +      return reference;, +    }, +, +    @Override public Optional<T> or(Optional<? extends T> secondChoice) {, +      checkNotNull(secondChoice);, +      return this;, +    }, +, +    @Override public T orNull() {, +      return reference;, +    }, +, +    @Override public boolean equals(@Nullable Object object) {, +      if (object instanceof Present) {, +        Present<?> other = (Present<?>) object;, +        return reference.equals(other.reference);, +      }, +      return false;, +    }, +, +    @Override public int hashCode() {, +      return 0x598df91c + reference.hashCode();, +    }, +, +      return "Optional.of(" + reference + ")";, +    }, +  }, +, +  private static final class Absent extends Optional<Object> {, +    @Override public boolean isPresent() {, +      return false;, +    }, +, +    @Override public Object get() {, +      throw new IllegalStateException("value is absent");, +    }, +, +    @Override @Nullable public Object get(@Nullable Object defaultValue) {, +      return defaultValue;, +    }, +, +    @Override public Object or(Object defaultValue) {, +      return checkNotNull(defaultValue);, +    }, +, +    @SuppressWarnings("unchecked") // safe covariant cast, +    @Override public Optional<Object> or(Optional<?> secondChoice) {, +      return (Optional) checkNotNull(secondChoice);]