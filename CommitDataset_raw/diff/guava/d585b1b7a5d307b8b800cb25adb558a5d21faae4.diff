[+++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +    for (TypeToken<?> interfaceType, +        : new TypeToken<Implementation<Integer, String>>() {}.getGenericInterfaces()) {, +  public <T, T1 extends T> void testAssignableGenericArrayToClass() {, +    assertTrue(TypeToken.of(Object[].class.getSuperclass()), +        .isAssignableFrom(new TypeToken<T[]>() {}));, +    for (Class<?> interfaceType : Object[].class.getInterfaces()) {, +      assertTrue(TypeToken.of(interfaceType), +          .isAssignableFrom(new TypeToken<T[]>() {}));, +    }, +    assertTrue(TypeToken.of(Object.class).isAssignableFrom(new TypeToken<T[]>() {}));, +    assertFalse(TypeToken.of(String.class).isAssignableFrom(new TypeToken<T[]>() {}));, +  }, +, +        assertEquals(method.getReturnType(),, +            TypeToken.of(method.getGenericReturnType()).getRawType());, +              TypeToken.of(method.getGenericParameterTypes()[i]).getRawType());, +    assertEquals(Object.class, TypeToken.of(Types.subtypeOf(Object.class)).getRawType());, +    assertEquals(CharSequence.class,, +        TypeToken.of(Types.subtypeOf(CharSequence.class)).getRawType());, +    assertEquals(Object.class, TypeToken.of(Types.supertypeOf(CharSequence.class)).getRawType());, +++ b/guava-tests/test/com/google/common/reflect/TypeTokenTest.java, +    for (TypeToken<?> interfaceType, +        : new TypeToken<Implementation<Integer, String>>() {}.getGenericInterfaces()) {, +  public <T, T1 extends T> void testAssignableGenericArrayToClass() {, +    assertTrue(TypeToken.of(Object[].class.getSuperclass()), +        .isAssignableFrom(new TypeToken<T[]>() {}));, +    for (Class<?> interfaceType : Object[].class.getInterfaces()) {, +      assertTrue(TypeToken.of(interfaceType), +          .isAssignableFrom(new TypeToken<T[]>() {}));, +    }, +    assertTrue(TypeToken.of(Object.class).isAssignableFrom(new TypeToken<T[]>() {}));, +    assertFalse(TypeToken.of(String.class).isAssignableFrom(new TypeToken<T[]>() {}));, +  }, +, +        assertEquals(method.getReturnType(),, +            TypeToken.of(method.getGenericReturnType()).getRawType());, +              TypeToken.of(method.getGenericParameterTypes()[i]).getRawType());, +    assertEquals(Object.class, TypeToken.of(Types.subtypeOf(Object.class)).getRawType());, +    assertEquals(CharSequence.class,, +        TypeToken.of(Types.subtypeOf(CharSequence.class)).getRawType());, +    assertEquals(Object.class, TypeToken.of(Types.supertypeOf(CharSequence.class)).getRawType());, +++ b/guava/src/com/google/common/reflect/TypeToken.java, +        "Cannot construct a TypeToken for a type variable.\n", +        + "You probably meant to call new TypeToken<%s>(getClass()) ", +        + "that can resolve the type variable for you.\n", +        + "If you do need to create a TypeToken of a type variable, ", +        + "please use TypeToken.of() instead.", runtimeType);, +    // For wildcard or type variable, the first bound determines the runtime type., +    Class<?> rawType = getRawTypes().iterator().next();, +    checkArgument(this.extendsFromClass(superclass),, +    return type.extendsFrom(runtimeType);, +    return isAssignableFrom(of(type));, +      return of(Primitives.wrap(type));, +      return of(Primitives.unwrap(type));, +          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());, +    private final transient TypeSet allTypes;, +          TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());, +          TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());, +  private boolean extendsFrom(Type supertype) {, +    if (supertype instanceof WildcardType) {, +      // if 'supertype' is <? super Foo>, 'this' can be:, +      // if 'supertype' is <? extends Foo>, nothing assignable., +      return any(((WildcardType) supertype).getLowerBounds()).isSupertypeOf(runtimeType);, +    // if 'this' is wildcard, it's assignable to 'supertype' if any of its "extends", +    // bounds is assignable to 'supertype'., +    if (runtimeType instanceof WildcardType) {, +      return any(((WildcardType) runtimeType).getUpperBounds()).extendsFrom(supertype);, +    // if 'this' is type variable, it's assignable if any of its "extends", +    // bounds is assignable to 'supertype'., +    if (runtimeType instanceof TypeVariable) {, +      return runtimeType.equals(supertype), +          || any(((TypeVariable<?>) runtimeType).getBounds()).extendsFrom(supertype);, +    if (runtimeType instanceof GenericArrayType) {, +      return of(supertype).isSuperTypeOfArray((GenericArrayType) runtimeType);, +    if (supertype instanceof Class) {, +      return this.extendsFromClass((Class<?>) supertype);, +    } else if (supertype instanceof ParameterizedType) {, +      return this.extendsFromParameterizedType((ParameterizedType) supertype);, +    } else if (supertype instanceof GenericArrayType) {, +      return this.extendsFromArrayType((GenericArrayType) supertype);, +  private boolean extendsFromClass(Class<?> superclass) {, +    return superclass.isAssignableFrom(getRawType());, +  private boolean extendsFromParameterizedType(ParameterizedType supertype) {, +    Class<?> matchedClass = of(supertype).getRawType();, +    if (!this.extendsFromClass(matchedClass)) {, +    Type[] toTypeArgs = supertype.getActualTypeArguments();, +      // If 'supertype' is "List<? extends CharSequence>", +      // and 'this' is StringArrayList,, +      if (!resolveType(typeParams[i]).is(toTypeArgs[i])) {, +  private boolean extendsFromArrayType(GenericArrayType supertype) {, +    if (runtimeType instanceof Class) {, +      Class<?> fromClass = (Class<?>) runtimeType;, +      return of(fromClass.getComponentType()).extendsFrom(supertype.getGenericComponentType());, +    } else if (runtimeType instanceof GenericArrayType) {, +      GenericArrayType fromArrayType = (GenericArrayType) runtimeType;, +      return of(fromArrayType.getGenericComponentType()), +          .extendsFrom(supertype.getGenericComponentType());, +  private boolean isSuperTypeOfArray(GenericArrayType subtype) {, +    if (runtimeType instanceof Class) {]