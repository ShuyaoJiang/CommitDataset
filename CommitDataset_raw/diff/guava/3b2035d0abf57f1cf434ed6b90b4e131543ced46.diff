[+++ b/guava/src/com/google/common/util/concurrent/ExecutionQueue.java, + * A thread-safe queue of listeners, each with an associated {@code Executor}, that guarantees, + * {@link Executor#execute(Runnable) executed} in the same order that it was added., + * <p>While similar in structure and API to {@link ExecutionList}, this class differs in several, + * ways:, + * <ul>, + *    <li>This class makes strict ordering guarantees. ExecutionList makes no ordering guarantees., + *    <li>{@link ExecutionQueue#execute} executes all currently pending listeners. Later calls, + *        to {@link ExecutionQueue#add} are delayed until the <em>next</em> call to execute., + *        {@link ExecutionList#execute()} executes all current listeners and also causes immediate, + *        execution on subsequent calls to {@link ExecutionList#add}., + * </ul>, + *, + * <p>These differences make {@link ExecutionQueue} suitable for when you need to execute callbacks, + * multiple times in response to different events. ExecutionList is suitable for when you have a, + * single event., + *, + * <p>For example, this implements a simple atomic data structure that lets a listener, + * asynchronously listen to changes to a value: <pre>   {@code, + *   interface CountListener {, + *     void update(int v);, + *   }, + *, + *   class AtomicListenableCounter {, + *     private int value;, + *     private final ExecutionQueue queue = new ExecutionQueue();, + *     private final CountListener listener;, + *     private final Executor executor;, + *, + *     AtomicListenableCounter(CountListener listener, Executor executor) {, + *       this.listener = listener;, + *       this.exeucutor = executor;, + *     }, + *, + *     void add(int amt) {, + *       synchronized (this) {, + *         v += amt;, + *         final int currentValue = v;, + *         queue.add(new Runnable() {, + *           public void run() {, + *             listener.update(currentValue);, + *           }, + *         }, executor);, + *       }, + *       queue.execute();, + *   }, + * }}</pre>, + *, + * <p>This AtomicListenableCounter allows a listener to be run asynchronously on every update and, + * the ExecutionQueue enforces that:, + *, + * <ul>, + *   <li>The listener is never run with the lock held (even if the executor is the, + *       {@link MoreExecutors#sameThreadExecutor()}), + *   <li>The listeners are never run out of order, + *   <li>Each added listener is called only once., + * </ul>, +@ThreadSafe, +final class ExecutionQueue {, +   *, +   * <p>Note: This method will never directly invoke {@code executor.execute(runnable)}, though your, +   * runnable may be executed before it returns if another thread has concurrently called, +   * {@link #execute}., +  public void add(Runnable runnable, Executor executor) {, +   * Executes all listeners in the queue., +   *, +   * <p>Note that there is no guarantee that concurrently {@linkplain #add added} listeners will be, +   * executed prior to the return of this method, only that all calls to {@link #add} that, +   * happen-before this call will be executed., +  public void execute() {, +    // TODO(user): we are relying on an underdocumented feature of ConcurrentLinkedQueue, the, +    // general strategy in other JDK libraries appears to be bring-your-own-queue :(  Consider doing, +    // that.]