[+++ b/guava/src/com/google/common/graph/Graph.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/Graph.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/Network.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/Graph.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/Network.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/PredecessorsFunction.java, + * <p>This interface is meant to be used as the type of a parameter to graph algorithms (such as, + * topological sort) that only need a way of accessing the predecessors of a node in a graph., + * Given an algorithm, for example:, + * <pre>{@code, + *   public <N> someGraphAlgorithm(N startNode, PredecessorsFunction<N> predecessorsFunction);, + * }</pre>, + *, + * you will invoke it depending on the graph representation you're using., + *, + * <p>If you have an instance of one of the primary {@code common.graph} types ({@link Graph},, + * {@link ValueGraph}, and {@link Network}):, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, graph);, + * }</pre>, + *, + * This works because those types each implement {@code PredecessorsFunction}. It will also work, + * with any other implementation of this interface., + *, + * <p>If you have your own graph implementation based around a custom node type {@code MyNode},, + * which has a method {@code getParents()} that retrieves its predecessors in a graph:, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, MyNode::getParents);, + * }</pre>, + *, + * <p>If you have some other mechanism for returning the predecessors of a node, or one that doesn't, + * return a {@code Set<N>}, then you can use a lambda to perform a more general transformation:, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, node -> ImmutableSet.copyOf(node.getParents());, + * }</pre>, + *, + * <p>Graph algorithms that need additional capabilities (accessing both predecessors and, + * successors, iterating over the edges, etc.) should declare their input to be of a type that, + * provides those capabilities, such as {@link Graph}, {@link ValueGraph}, or {@link Network}., +++ b/guava/src/com/google/common/graph/Graph.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/Network.java, + * <p>There are three primary interfaces provided to represent graphs. In order of increasing, +++ b/guava/src/com/google/common/graph/PredecessorsFunction.java, + * <p>This interface is meant to be used as the type of a parameter to graph algorithms (such as, + * topological sort) that only need a way of accessing the predecessors of a node in a graph., + * Given an algorithm, for example:, + * <pre>{@code, + *   public <N> someGraphAlgorithm(N startNode, PredecessorsFunction<N> predecessorsFunction);, + * }</pre>, + *, + * you will invoke it depending on the graph representation you're using., + *, + * <p>If you have an instance of one of the primary {@code common.graph} types ({@link Graph},, + * {@link ValueGraph}, and {@link Network}):, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, graph);, + * }</pre>, + *, + * This works because those types each implement {@code PredecessorsFunction}. It will also work, + * with any other implementation of this interface., + *, + * <p>If you have your own graph implementation based around a custom node type {@code MyNode},, + * which has a method {@code getParents()} that retrieves its predecessors in a graph:, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, MyNode::getParents);, + * }</pre>, + *, + * <p>If you have some other mechanism for returning the predecessors of a node, or one that doesn't, + * return a {@code Set<N>}, then you can use a lambda to perform a more general transformation:, + *, + * <pre>{@code, + *   someGraphAlgorithm(startNode, node -> ImmutableSet.copyOf(node.getParents());, + * }</pre>, + *, + * <p>Graph algorithms that need additional capabilities (accessing both predecessors and, + * successors, iterating over the edges, etc.) should declare their input to be of a type that, + * provides those capabilities, such as {@link Graph}, {@link ValueGraph}, or {@link Network}., +++ b/guava/src/com/google/common/graph/SuccessorsFunction.java, + * <p>This interface is meant to be used as the type of a parameter to graph algorithms (such as, + * breadth first traversal) that only need a way of accessing the successors of a node in a graph., + * Given an algorithm, for example:, + * <pre>{@code, + *   public <N> someGraphAlgorithm(N startNode, SuccessorsFunction<N> successorsFunction);, + * }</pre>, + *, + * you will invoke it depending on the graph representation you're using., + *, + * <p>If you have an instance of one of the primary {@code common.graph} types ({@link Graph},, + * {@link ValueGraph}, and {@link Network}):]