[+++ b/guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java, +  // TODO(user): consider making encodeTo(Appendable, byte[], int, int) public., +    StringBuilder result = new StringBuilder(maxEncodedSize(len));, +      encodeTo(result, bytes, off, len);, +      throw new AssertionError(impossible);, +  abstract void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException;, +  private static final BaseEncoding BASE64 = new Base64Encoding(, +  private static final BaseEncoding BASE64_URL = new Base64Encoding(, +  private static final BaseEncoding BASE16 = new Base16Encoding("base16()", "0123456789ABCDEF");, +  static class StandardBaseEncoding extends BaseEncoding {, +    final Alphabet alphabet;, +    final Character paddingChar;, +    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      for (int i = 0; i < len; i += alphabet.bytesPerChunk) {, +        encodeChunkTo(target, bytes, off + i, Math.min(alphabet.bytesPerChunk, len - i));, +    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len), +        throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      checkArgument(len <= alphabet.bytesPerChunk);, +      long bitBuffer = 0;, +      for (int i = 0; i < len; ++i) {, +        bitBuffer |= bytes[off + i] & 0xFF;, +        bitBuffer <<= 8; // Add additional zero byte in the end., +      // Position of first character is length of bitBuffer minus bitsPerChar., +      final int bitOffset = (len + 1) * 8 - alphabet.bitsPerChar;, +      int bitsProcessed = 0;, +      while (bitsProcessed < len * 8) {, +        int charIndex = (int) (bitBuffer >>> (bitOffset - bitsProcessed)) & alphabet.mask;, +        target.append(alphabet.encode(charIndex));, +        bitsProcessed += alphabet.bitsPerChar;, +      }, +        while (bitsProcessed < alphabet.bytesPerChunk * 8) {, +          target.append(paddingChar.charValue());, +          bitsProcessed += alphabet.bitsPerChar;, +      return (paddingChar == null) ? this : newInstance(alphabet, null);, +        return newInstance(alphabet, padChar);, +            (upper == alphabet) ? this : newInstance(upper, paddingChar);, +            (lower == alphabet) ? this : newInstance(lower, paddingChar);, +    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {, +      return new StandardBaseEncoding(alphabet, paddingChar);, +    }, +, +  static final class Base16Encoding extends StandardBaseEncoding {, +    final char[] encoding = new char[512];, +, +    Base16Encoding(String name, String alphabetChars) {, +      this(new Alphabet(name, alphabetChars.toCharArray()));, +    }, +, +    private Base16Encoding(Alphabet alphabet) {, +      super(alphabet, null);, +      checkArgument(alphabet.chars.length == 16);, +      for (int i = 0; i < 256; ++i) {, +        encoding[i] = alphabet.encode(i >>> 4);, +        encoding[i | 0x100] = alphabet.encode(i & 0xF);, +      }, +    }, +, +    @Override, +    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      for (int i = 0; i < len; ++i) {, +        int b = bytes[off + i] & 0xFF;, +        target.append(encoding[b]);, +        target.append(encoding[b | 0x100]);, +      }, +    }, +, +    @Override, +    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {, +      return new Base16Encoding(alphabet);, +    }, +  }, +, +  static final class Base64Encoding extends StandardBaseEncoding {, +    Base64Encoding(String name, String alphabetChars, @Nullable Character paddingChar) {, +      this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);, +    }, +, +    private Base64Encoding(Alphabet alphabet, @Nullable Character paddingChar) {, +      super(alphabet, paddingChar);, +      checkArgument(alphabet.chars.length == 64);, +    }, +, +    @Override, +    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {, +      checkNotNull(target);, +      checkPositionIndexes(off, off + len, bytes.length);, +      int i = off;, +      for (int remaining = len; remaining >= 3; remaining -= 3) {, +        int chunk = (bytes[i++] & 0xFF) << 16 | (bytes[i++] & 0xFF) << 8 | bytes[i++] & 0xFF;, +        target.append(alphabet.encode(chunk >>> 18));, +        target.append(alphabet.encode((chunk >>> 12) & 0x3F));, +        target.append(alphabet.encode((chunk >>> 6) & 0x3F));, +        target.append(alphabet.encode(chunk & 0x3F));, +      }]