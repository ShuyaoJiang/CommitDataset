[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  @Nullable, +  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {, +    return (entry == null) ? null : entry.getValue();, +  }, +, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  @Nullable, +  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {, +    return (entry == null) ? null : entry.getValue();, +  }, +, +++ b/guava-tests/test/com/google/common/collect/TreeRangeSetTest.java, +import java.util.List;, +import java.util.NavigableMap;, +, +  private static final int MIN_BOUND = -1;, +  private static final int MAX_BOUND = 1;, +, +    for (int i = MIN_BOUND; i <= MAX_BOUND; i++) {, +        for (int j = i + 1; j <= MAX_BOUND; j++) {, +  void testViewAgainstExpected(RangeSet<Integer> expected, RangeSet<Integer> view) {, +    assertEquals(expected, view);, +    assertEquals(expected.asRanges(), view.asRanges());, +    assertEquals(expected.isEmpty(), view.isEmpty());, +, +    if (!expected.isEmpty()) {, +      assertEquals(expected.span(), view.span());, +    }, +, +    for (int i = MIN_BOUND - 1; i <= MAX_BOUND + 1; i++) {, +      assertEquals(expected.contains(i), view.contains(i));, +      assertEquals(expected.rangeContaining(i), view.rangeContaining(i));, +    }, +    testEnclosing(view);, +    if (view instanceof TreeRangeSet) {, +      testRangesByLowerBounds((TreeRangeSet<Integer>) view, expected.asRanges());, +    }, +  }, +, +  private static final ImmutableList<Cut<Integer>> CUTS_TO_TEST;, +, +  static {, +    List<Cut<Integer>> cutsToTest = Lists.newArrayList();, +    for (int i = MIN_BOUND - 1; i <= MAX_BOUND + 1; i++) {, +      cutsToTest.add(Cut.belowValue(i));, +      cutsToTest.add(Cut.aboveValue(i));, +    }, +    cutsToTest.add(Cut.<Integer>aboveAll());, +    cutsToTest.add(Cut.<Integer>belowAll());, +    CUTS_TO_TEST = ImmutableList.copyOf(cutsToTest);, +  }, +, +  private void testRangesByLowerBounds(, +      TreeRangeSet<Integer> rangeSet, Iterable<Range<Integer>> expectedRanges) {, +    NavigableMap<Cut<Integer>, Range<Integer>> expectedRangesByLowerBound = Maps.newTreeMap();, +    for (Range<Integer> range : expectedRanges) {, +      expectedRangesByLowerBound.put(range.lowerBound, range);, +    }, +, +    NavigableMap<Cut<Integer>, Range<Integer>> rangesByLowerBound = rangeSet.rangesByLowerBound;, +    testNavigationAgainstExpected(expectedRangesByLowerBound, rangesByLowerBound, CUTS_TO_TEST);, +  }, +, +  <K, V> void testNavigationAgainstExpected(, +      NavigableMap<K, V> expected, NavigableMap<K, V> navigableMap, Iterable<K> keysToTest) {, +    for (K key : keysToTest) {, +      assertEquals(expected.lowerEntry(key), navigableMap.lowerEntry(key));, +      assertEquals(expected.floorEntry(key), navigableMap.floorEntry(key));, +      assertEquals(expected.ceilingEntry(key), navigableMap.ceilingEntry(key));, +      assertEquals(expected.higherEntry(key), navigableMap.higherEntry(key));, +      for (boolean inclusive : new boolean[] {false, true}) {, +        ASSERT.that(navigableMap.headMap(key, inclusive).entrySet()), +            .has().allFrom(expected.headMap(key, inclusive).entrySet()).inOrder();, +        ASSERT.that(navigableMap.tailMap(key, inclusive).entrySet()), +            .has().allFrom(expected.tailMap(key, inclusive).entrySet()).inOrder();, +        ASSERT.that(navigableMap.headMap(key, inclusive).descendingMap().entrySet()), +            .has().allFrom(expected.headMap(key, inclusive).descendingMap().entrySet()).inOrder();, +        ASSERT.that(navigableMap.tailMap(key, inclusive).descendingMap().entrySet()), +            .has().allFrom(expected.tailMap(key, inclusive).descendingMap().entrySet()).inOrder();, +      }, +    }, +  }, +, +  private RangeSet<Integer> expectedSubRangeSet(, +      RangeSet<Integer> rangeSet, Range<Integer> subRange) {, +    RangeSet<Integer> expected = TreeRangeSet.create();, +    for (Range<Integer> range : rangeSet.asRanges()) {, +      if (range.isConnected(subRange)) {, +        expected.add(range.intersection(subRange));, +      }, +    }, +    return expected;, +  }, +, +  private RangeSet<Integer> expectedComplement(RangeSet<Integer> rangeSet) {, +    RangeSet<Integer> expected = TreeRangeSet.create();, +    expected.add(Range.<Integer>all());, +    expected.removeAll(rangeSet);, +    return expected;]