[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          postWriteCleanup();, +        segment.postWriteCleanup();, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          postWriteCleanup();, +        segment.postWriteCleanup();, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +      segment.postWriteCleanup();, +      try {, +      } finally {, +        postReadCleanup();, +      }, +        postWriteCleanup();, +        postWriteCleanup();, +        postWriteCleanup();, +        postWriteCleanup();, +        postWriteCleanup();, +    void postReadCleanup() {, +      // we are not under lock, so only drain a small fraction of the time, +      if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {, +        if (isInlineCleanup()) {, +          // inline cleanup normally avoids taking the lock, but since no, +          // writes are happening we need to force some locked cleanup, +          runCleanup();, +        } else if (!isHeldByCurrentThread()) {, +          cleanupExecutor.execute(cleanupRunnable);, +        }, +      }, +    }, +, +    /**, +     * Performs routine cleanup prior to executing a write. This should be, +     * called every time a write thread acquires the segment lock, immediately, +     * after acquiring the lock., +     */, +    @GuardedBy("Segment.this"), +    void preWriteCleanup() {, +      if (isInlineCleanup()) {, +        runLockedCleanup();, +      } else {, +        expireEntries();, +      }, +    }, +, +    void postWriteCleanup() {, +      // locked cleanup may generate notifications we can send unlocked, +      runUnlockedCleanup();, +        expireEntries(); // calls drainRecencyQueue]