[+++ b/guava/src/com/google/common/base/Function.java, +  @CanIgnoreReturnValue // TODO(kevinb): remove this, +   * <i>May</i> return {@code true} if {@object} is a {@code Function} that behaves identically to, +   * this function., +   * <p><b>Warning: do not depend</b> on the behavior of this method., +   *, +   * <p>Historically, {@code Function} instances in this library have implemented this method to, +   * recognize certain cases where distinct {@code Function} instances would in fact behave, +   * identically. However, as code migrates to {@code java.util.function}, that behavior will, +   * disappear. It is best not to depend on it., +++ b/guava/src/com/google/common/base/Function.java, +  @CanIgnoreReturnValue // TODO(kevinb): remove this, +   * <i>May</i> return {@code true} if {@object} is a {@code Function} that behaves identically to, +   * this function., +   * <p><b>Warning: do not depend</b> on the behavior of this method., +   *, +   * <p>Historically, {@code Function} instances in this library have implemented this method to, +   * recognize certain cases where distinct {@code Function} instances would in fact behave, +   * identically. However, as code migrates to {@code java.util.function}, that behavior will, +   * disappear. It is best not to depend on it., +++ b/guava/src/com/google/common/base/Functions.java, + * Static utility methods pertaining to {@code com.google.common.base.Function} instances; see that, + * class for information about migrating to {@code java.util.function}., +   * A function equivalent to the method reference {@code Object::toString}, for users not yet using, +   * Java 8. The function simply invokes {@code toString} on its argument and returns the result. It, +   * throws a {@link NullPointerException} on null input., +   *, +   * <p><b>Java 8 users:</b> if you are okay with {@code null} being returned for an unrecognized, +   * key (instead of an exception being thrown), you can use the method reference {@code map::get}, +   * instead., +   * <p><b>Java 8 users:</b> you can just write the lambda expression {@code k ->, +   * map.getWithDefault(k, defaultValue)} instead., +   *, +   * <p><b>Java 8 users:</b> use {@code g.compose(f)} or (probably clearer) {@code f.andThen(g)}, +   * instead., +   *, +   *, +   * <p><b>Java 8 users:</b> use the method reference {@code predicate::test} instead., +   * Returns a function that ignores its input and always returns {@code value}., +   *, +   * <p><b>Java 8 users:</b> use the lambda expression {@code o -> value} instead., +   * Returns a function that ignores its input and returns the result of {@code supplier.get()}., +   *, +   * <p><b>Java 8 users:</b> use the lambda expression {@code o -> supplier.get()} instead.]