[+++ b/guava/src/com/google/common/collect/ContiguousSet.java, +import java.util.NoSuchElementException;, +public abstract class ContiguousSet<C extends Comparable> extends ImmutableSortedSet<C> {, +  final DiscreteDomain<C> domain;, +  ContiguousSet(DiscreteDomain<C> domain) {, +  @Override public ContiguousSet<C> headSet(C toElement) {, +    return headSet(checkNotNull(toElement), false);, +  @Override ContiguousSet<C> headSet(C toElement, boolean inclusive) {, +  @Override public ContiguousSet<C> subSet(C fromElement, C toElement) {, +    checkNotNull(fromElement);, +    checkNotNull(toElement);, +    checkArgument(comparator().compare(fromElement, toElement) <= 0);, +  @Override ContiguousSet<C> subSet(C fromElement, boolean fromInclusive, C toElement,, +  @Override public ContiguousSet<C> tailSet(C fromElement) {, +    return tailSet(checkNotNull(fromElement), true);, +  @Override ContiguousSet<C> tailSet(C fromElement, boolean inclusive){, +  /*, +   * These methods perform most headSet, subSet, and tailSet logic, besides parameter validation., +   */, +  /*@Override*/ abstract ContiguousSet<C> headSetImpl(C toElement, boolean inclusive);, +  /*@Override*/ abstract ContiguousSet<C> subSetImpl(C fromElement, boolean fromInclusive,, +      C toElement, boolean toInclusive);, +  /*@Override*/ abstract ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive);, +   * Returns the set of values that are contained in both this set and the other., +   *, +   * <p>This method should always be used instead of, +   * {@link Sets#intersection} for {@link ContiguousSet} instances., +  public abstract ContiguousSet<C> intersection(ContiguousSet<C> other);, +  /**, +   * Returns a range, closed on both ends, whose endpoints are the minimum and maximum values, +   * contained in this set.  This is equivalent to {@code range(CLOSED, CLOSED)}., +   *, +   * @throws NoSuchElementException if this set is empty, +   */, +  public abstract Range<C> range();, +, +  /**, +   * Returns the minimal range with the given boundary types for which all values in this set are, +   * {@linkplain Range#contains(Comparable) contained} within the range., +   *, +   * @throws NoSuchElementException if this set is empty, +   */, +  public abstract Range<C> range(BoundType lowerBoundType, BoundType upperBoundType);, +++ b/guava/src/com/google/common/collect/ContiguousSet.java, +import java.util.NoSuchElementException;, +public abstract class ContiguousSet<C extends Comparable> extends ImmutableSortedSet<C> {, +  final DiscreteDomain<C> domain;, +  ContiguousSet(DiscreteDomain<C> domain) {, +  @Override public ContiguousSet<C> headSet(C toElement) {, +    return headSet(checkNotNull(toElement), false);, +  @Override ContiguousSet<C> headSet(C toElement, boolean inclusive) {, +  @Override public ContiguousSet<C> subSet(C fromElement, C toElement) {, +    checkNotNull(fromElement);, +    checkNotNull(toElement);, +    checkArgument(comparator().compare(fromElement, toElement) <= 0);, +  @Override ContiguousSet<C> subSet(C fromElement, boolean fromInclusive, C toElement,, +  @Override public ContiguousSet<C> tailSet(C fromElement) {, +    return tailSet(checkNotNull(fromElement), true);, +  @Override ContiguousSet<C> tailSet(C fromElement, boolean inclusive){, +  /*, +   * These methods perform most headSet, subSet, and tailSet logic, besides parameter validation., +   */, +  /*@Override*/ abstract ContiguousSet<C> headSetImpl(C toElement, boolean inclusive);, +  /*@Override*/ abstract ContiguousSet<C> subSetImpl(C fromElement, boolean fromInclusive,, +      C toElement, boolean toInclusive);, +  /*@Override*/ abstract ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive);, +   * Returns the set of values that are contained in both this set and the other., +   *, +   * <p>This method should always be used instead of, +   * {@link Sets#intersection} for {@link ContiguousSet} instances., +  public abstract ContiguousSet<C> intersection(ContiguousSet<C> other);, +  /**, +   * Returns a range, closed on both ends, whose endpoints are the minimum and maximum values, +   * contained in this set.  This is equivalent to {@code range(CLOSED, CLOSED)}., +   *, +   * @throws NoSuchElementException if this set is empty, +   */, +  public abstract Range<C> range();, +, +  /**, +   * Returns the minimal range with the given boundary types for which all values in this set are, +   * {@linkplain Range#contains(Comparable) contained} within the range., +   *, +   * @throws NoSuchElementException if this set is empty, +   */, +  public abstract Range<C> range(BoundType lowerBoundType, BoundType upperBoundType);, +++ b/guava/src/com/google/common/collect/Cut.java, +import javax.annotation.Nullable;, +, +  abstract Cut<C> withLowerBoundType(BoundType boundType, DiscreteDomain<C> domain);, +  abstract Cut<C> withUpperBoundType(BoundType boundType, DiscreteDomain<C> domain);, +, +        @Override Cut<Comparable<?>> withLowerBoundType(BoundType boundType,, +            DiscreteDomain<Comparable<?>> domain) {, +          throw new IllegalStateException();, +        }, +        @Override Cut<Comparable<?>> withUpperBoundType(BoundType boundType,, +            DiscreteDomain<Comparable<?>> domain) {, +          throw new AssertionError("this statement should be unreachable");, +        }]