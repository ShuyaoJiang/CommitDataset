[+++ /dev/null, +++ /dev/null, +++ b/guava-tests/test/com/google/common/hash/HashTestUtils.java, +import com.google.common.collect.ImmutableSet;, +import com.google.common.collect.Sets;, +import java.util.Set;, + * Various utilities for testing {@link HashFunction}s., + *, + * @author kak@google.com (Kurt Alfred Kluever), +final class HashTestUtils {, +, +  /**, +   * Test that the hash function contains no funnels. A funnel is a situation where a set of input, +   * (key) bits 'affects' a strictly smaller set of output bits. Funneling is bad because it can, +   * result in more-than-ideal collisions for a non-uniformly distributed key space. In practice,, +   * most key spaces are ANYTHING BUT uniformly distributed. A bit(i) in the input is said to, +   * 'affect' a bit(j) in the output if two inputs, identical but for bit(i), will differ at output, +   * bit(j) about half the time, +   *, +   * <p>Funneling is pretty simple to detect. The key idea is to find example keys which, +   * unequivocably demonstrate that funneling cannot be occuring. This is done bit-by-bit. For, +   * each input bit(i) and output bit(j), two pairs of keys must be found with all bits identical, +   * except bit(i). One pair must differ in output bit(j), and one pair must not. This proves that, +   * input bit(i) can alter output bit(j)., +   */, +  static void checkNoFunnels(HashFunction function) {, +    Random rand = new Random(0);, +    int keyBits = 32;, +    int hashBits = function.bits();, +, +    // output loop tests input bit, +    for (int i = 0; i < keyBits; i++) {, +      int same = 0x0; // bitset for output bits with same values, +      int diff = 0x0; // bitset for output bits with different values, +      int count = 0;, +      int maxCount = (int) (2 * Math.log(2 * keyBits * hashBits) + 0.999);, +      while (same != 0xffffffff || diff != 0xffffffff) {, +        int key1 = rand.nextInt();, +        // flip input bit for key2, +        int key2 = key1 ^ (1 << i);, +        // get hashes, +        int hash1 = function.newHasher().putInt(key1).hash().asInt();, +        int hash2 = function.newHasher().putInt(key2).hash().asInt();, +        // test whether the hash values have same output bits, +        same |= ~(hash1 ^ hash2);, +        // test whether the hash values have different output bits, +        diff |= (hash1 ^ hash2);, +, +        count++;, +        // check whether we've exceeded the probabilistically, +        // likely number of trials to have proven no funneling, +        if (count > maxCount) {, +          Assert.fail("input bit(" + i + ") was found not to affect all " +, +               hashBits + " output bits; The unaffected bits are " +, +               "as follows: " + ~(same & diff) + ". This was " +, +               "determined after " + count + " trials.");, +        }, +      }, +    }, +  }, +, +  /**, +   * Test for avalanche. Avalanche means that output bits differ with roughly 1/2 probability on, +   * different input keys. This test verifies that each possible 1-bit key delta achieves avalanche., +   *, +   * <p>For more information: http://burtleburtle.net/bob/hash/avalanche.html, +   */, +  static void checkAvalanche(HashFunction function, int trials, double epsilon) {, +    Random rand = new Random(0);, +    int keyBits = 32;, +    int hashBits = function.bits();, +    for (int i = 0; i < keyBits; i++) {, +      int[] same = new int[hashBits];, +      int[] diff = new int[hashBits];, +      // go through trials to compute probability, +      for (int j = 0; j < trials; j++) {, +        int key1 = rand.nextInt();, +        // flip input bit for key2, +        int key2 = key1 ^ (1 << i);, +        // compute hash values, +        int hash1 = function.newHasher().putInt(key1).hash().asInt();, +        int hash2 = function.newHasher().putInt(key2).hash().asInt();, +        for (int k = 0; k < hashBits; k++) {, +          if ((hash1 & (1 << k)) == (hash2 & (1 << k))) {, +            same[k] += 1;, +          } else {, +            diff[k] += 1;, +          }, +        }, +      }, +      // measure probability and assert it's within margin of error, +      for (int j = 0; j < hashBits; j++) {, +        double prob = (double) diff[j] / (double) (diff[j] + same[j]);, +        Assert.assertEquals(0.50d, prob, epsilon);, +      }, +    }, +  }, +, +  /**, +   * Test for 2-bit characteristics. A characteristic is a delta in the input which is repeated in]