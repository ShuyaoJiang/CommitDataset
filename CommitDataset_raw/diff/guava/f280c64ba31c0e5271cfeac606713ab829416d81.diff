[+++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java, +  private static final double LN_10 = Math.log(10);, +  private static final double LN_2 = Math.log(2);, +, +++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java, +  private static final double LN_10 = Math.log(10);, +  private static final double LN_2 = Math.log(2);, +, +++ b/guava/src/com/google/common/math/BigIntegerMath.java, +    int approxLog10 = (int) (log2(x, FLOOR) * LN_2 / LN_10);, +    BigInteger approxPow = BigInteger.TEN.pow(approxLog10);, +    int approxCmp = approxPow.compareTo(x);, +, +    /*, +     * We adjust approxLog10 and approxPow until they're equal to floor(log10(x)) and, +     * 10^floor(log10(x))., +     */, +, +    if (approxCmp > 0) {, +      /*, +       * The code is written so that even completely incorrect approximations will still yield the, +       * correct answer eventually, but in practice this branch should almost never be entered,, +       * and even then the loop should not run more than once., +       */, +      do {, +        approxLog10--;, +        approxPow = approxPow.divide(BigInteger.TEN);, +        approxCmp = approxPow.compareTo(x);, +      } while (approxCmp > 0);, +    } else {, +      BigInteger nextPow = BigInteger.TEN.multiply(approxPow);, +      int nextCmp = nextPow.compareTo(x);, +      while (nextCmp <= 0) {, +        approxLog10++;, +        approxPow = nextPow;, +        approxCmp = nextCmp;, +        nextPow = BigInteger.TEN.multiply(approxPow);, +        nextCmp = nextPow.compareTo(x);, +, +    int floorLog = approxLog10;, +    BigInteger floorPow = approxPow;, +    int floorCmp = approxCmp;, +, +        checkRoundingUnnecessary(floorCmp == 0);, +  private static final double LN_10 = Math.log(10);, +  private static final double LN_2 = Math.log(2);, +]