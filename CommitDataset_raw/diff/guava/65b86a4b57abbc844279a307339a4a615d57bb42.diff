[+++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import java.io.Serializable;, +  /**, +   * Overrides get() to compute on demand. Also throws an exception when null is returned from a, +   * computation., +   */, +  static class ComputingMapAdapter<K, V>, +      extends ComputingConcurrentHashMap<K, V> implements Serializable {, +    private static final long serialVersionUID = 0;, +, +    ComputingMapAdapter(MapMaker mapMaker, Function<? super K, ? extends V> computingFunction) {, +      super(mapMaker, computingFunction);, +    }, +, +    @SuppressWarnings("unchecked") // unsafe, which is why this is deprecated, +    @Override, +    public V get(Object key) {, +      V value = compute((K) key);, +      if (value == null) {, +        throw new NullPointerException(computingFunction + " returned null for key " + key + ".");, +      }, +      return value;, +    }, +  }, +, +          // The entry already exists. Wait for the computation., +          checkState(!Thread.holdsLock(e), "Recursive computation");, +          V value = e.getValueReference().waitForValue();, +    volatile ValueReference<K, V> computedReference = unset();, +    public V waitForValue() {, +        boolean interrupted = false;, +        try {, +            while (computedReference == UNSET) {, +              try {, +              } catch (InterruptedException ie) {, +                interrupted = true;, +              }, +            }, +          }, +        } finally {, +          if (interrupted) {, +            Thread.currentThread().interrupt();, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import java.io.Serializable;, +  /**, +   * Overrides get() to compute on demand. Also throws an exception when null is returned from a, +   * computation., +   */, +  static class ComputingMapAdapter<K, V>, +      extends ComputingConcurrentHashMap<K, V> implements Serializable {, +    private static final long serialVersionUID = 0;, +, +    ComputingMapAdapter(MapMaker mapMaker, Function<? super K, ? extends V> computingFunction) {, +      super(mapMaker, computingFunction);, +    }, +, +    @SuppressWarnings("unchecked") // unsafe, which is why this is deprecated, +    @Override, +    public V get(Object key) {, +      V value = compute((K) key);, +      if (value == null) {, +        throw new NullPointerException(computingFunction + " returned null for key " + key + ".");, +      }, +      return value;, +    }, +  }, +, +          // The entry already exists. Wait for the computation., +          checkState(!Thread.holdsLock(e), "Recursive computation");, +          V value = e.getValueReference().waitForValue();, +    volatile ValueReference<K, V> computedReference = unset();, +    public V waitForValue() {, +        boolean interrupted = false;, +        try {, +            while (computedReference == UNSET) {, +              try {, +              } catch (InterruptedException ie) {, +                interrupted = true;, +              }, +            }, +          }, +        } finally {, +          if (interrupted) {, +            Thread.currentThread().interrupt();, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +     * case of FutureValueReference)., +     *, +     * @throws AsynchronousComputationException if the computing thread throws an exception, +    V waitForValue();, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import java.io.Serializable;, +  /**, +   * Overrides get() to compute on demand. Also throws an exception when null is returned from a, +   * computation., +   */, +  static class ComputingMapAdapter<K, V>, +      extends ComputingConcurrentHashMap<K, V> implements Serializable {, +    private static final long serialVersionUID = 0;, +, +    ComputingMapAdapter(MapMaker mapMaker, Function<? super K, ? extends V> computingFunction) {]