[+++ b/guava/src/com/google/common/cache/Cache.java, + * <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed, + * by multiple concurrent threads., + *, +   * until loading completes. This method provides a simple substitute for the conventional, +   * "if cached, return; otherwise create, cache and return" pattern., +   * Discards any cached value for key {@code key}., +   * Discards any cached values for keys {@code keys}., +   * Discards all entries in the cache., +   * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to, +   * the map directly affect the cache., +++ b/guava/src/com/google/common/cache/Cache.java, + * <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed, + * by multiple concurrent threads., + *, +   * until loading completes. This method provides a simple substitute for the conventional, +   * "if cached, return; otherwise create, cache and return" pattern., +   * Discards any cached value for key {@code key}., +   * Discards any cached values for keys {@code keys}., +   * Discards all entries in the cache., +   * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to, +   * the map directly affect the cache., +++ b/guava/src/com/google/common/cache/CacheBuilder.java, + * <p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the, + * following features:, + * <li>automatic loading of entries into the cache, + *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder(), + * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and, + * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly, + * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads, + * modify the cache after the iterator is created, it is undefined which of these changes, if any,, + * are reflected in that iterator. These iterators never throw {@link, + * ConcurrentModificationException}., + * <p>Entries are automatically evicted from the cache when any of, + * {@linkplain #maximumSize maximumSize}, {@linkplain #maximumWeight maximumWeight},, + * {@linkplain #expireAfterWrite expireAfterWrite},, + * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},, + * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested., + *, + * <p>If {@linkplain #maximumSize maximumSize} or {@linkplain #maximumWeight maximumWeight} is, + * requested entries may be evicted on each cache modification., + *, + * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or, + * {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each, + * cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired, + * entries may be counted in {@link Cache#size}, but will never be visible to read or write, + * operations., + *, + * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or, + * {@linkplain #softValues softValues} are requested, it is possible for a key or value present in, + * the cache to be reclaimed by the garbage collector. Reclaimed entries may be removed from the, + * cache on each cache modification, on occasional cache accesses, or on calls to, + * {@link Cache#cleanUp}. Reclaimed entries may be counted in {@link Cache#size}, but will never be, + * visible to read or write operations., + * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},, + * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},, + * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic, + * maintenance., +   * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size},, +   * but will never be visible to read or write operations. Entries with garbage collected keys are, +   * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},, +   * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},, +   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or, +   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or, +   * elapsed after the entry's creation, or the most recent replacement of its value. The semantics, +   * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling, +   * {@link CacheLoader.reload}., +   * <p>Refreshes will only be asynchronous if the implementation of {@link CacheLoader.reload} is, +   * asynchronous., +   *, +   * <p>Currently automatic refreshes are performed when the first stale request for an entry, +   * occurs. If the refresh completes immediately then the new value will be returned; otherwise the, +   * old value will continue to be returned until the refresh completes., +    checkNonLoadingCache();, +  private void checkNonLoadingCache() {, +    checkState(refreshNanos == UNSET_INT, "refreshInterval requires a LoadingCache");, +  }, +, +++ b/guava/src/com/google/common/cache/Cache.java, + * <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed, + * by multiple concurrent threads., + *, +   * until loading completes. This method provides a simple substitute for the conventional, +   * "if cached, return; otherwise create, cache and return" pattern., +   * Discards any cached value for key {@code key}., +   * Discards any cached values for keys {@code keys}., +   * Discards all entries in the cache., +   * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to, +   * the map directly affect the cache., +++ b/guava/src/com/google/common/cache/CacheBuilder.java, + * <p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the, + * following features:, + * <li>automatic loading of entries into the cache, + *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder(), + * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and, + * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly, + * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads, + * modify the cache after the iterator is created, it is undefined which of these changes, if any,, + * are reflected in that iterator. These iterators never throw {@link, + * ConcurrentModificationException}.]