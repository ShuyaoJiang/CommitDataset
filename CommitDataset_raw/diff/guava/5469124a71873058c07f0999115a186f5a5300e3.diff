[+++ b/guava/src/com/google/common/util/concurrent/Futures.java, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +   *    * <b> Soon to be removed, use, +   * {@link Uninterruptibles#getUninterruptibly(Future) getUninterruptibly}</b>, +          sourceResult = getUninterruptibly(inputFuture);, +                set(getUninterruptibly(outputFuture));, +      return getUninterruptibly(future);, +        localValues.set(index, getUninterruptibly(future));, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;, +   *    * <b> Soon to be removed, use, +   * {@link Uninterruptibles#getUninterruptibly(Future) getUninterruptibly}</b>, +          sourceResult = getUninterruptibly(inputFuture);, +                set(getUninterruptibly(outputFuture));, +      return getUninterruptibly(future);, +        localValues.set(index, getUninterruptibly(future));, +++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeoutException;, +   * Invokes {@code future.}{@link Future#get() get()} uninterruptibly., +   * To get uninterruptibility and remove checked exceptions, see, +   * {@link Futures#getUnchecked}., +   *, +   * <p>If instead, you wish to treat {@link InterruptedException} uniformly, +   * with other exceptions, see {@link Futures#get(Future, Class) Futures.get}, +   * or {@link Futures#makeChecked}., +   */, +  public static <V> V getUninterruptibly(Future<V> future), +      throws ExecutionException {, +    boolean interrupted = false;, +    try {, +      while (true) {, +        try {, +          return future.get();, +        } catch (InterruptedException ignored) {, +          interrupted = true;, +        }, +      }, +    } finally {, +      if (interrupted) {, +        Thread.currentThread().interrupt();, +      }, +    }, +  }, +, +  /**, +   * Invokes, +   * {@code future.}{@link Future#get(long, TimeUnit) get(timeout, unit)}, +   * uninterruptibly., +   *, +   * <p>If instead, you wish to treat {@link InterruptedException} uniformly, +   * with other exceptions, see {@link Futures#get(Future, Class) Futures.get}, +   * or {@link Futures#makeChecked}., +   */, +  public static <V> V getUninterruptibly(, +      Future<V> future, long timeout,  TimeUnit unit), +          throws ExecutionException, TimeoutException {, +    boolean interrupted = false;, +    try {, +      long remainingNanos = unit.toNanos(timeout);, +      long end = System.nanoTime() + remainingNanos;, +, +      while (true) {, +        try {, +          // Future treats negative timeouts just like zero., +          return future.get(remainingNanos, NANOSECONDS);, +        } catch (InterruptedException e) {, +          interrupted = true;, +          remainingNanos = end - System.nanoTime();, +        }, +      }, +    } finally {, +      if (interrupted) {, +        Thread.currentThread().interrupt();, +      }, +    }, +  }, +, +  /**]