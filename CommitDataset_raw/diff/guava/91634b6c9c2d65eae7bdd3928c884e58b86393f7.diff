[+++ b/guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java, +/*, + * Copyright (C) 2012 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package com.google.common.io;, +, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkNotNull;, +import static com.google.common.base.Preconditions.checkPositionIndexes;, +import static com.google.common.io.GwtWorkarounds.asCharInput;, +import static com.google.common.io.GwtWorkarounds.stringBuilderOutput;, +import static com.google.common.math.IntMath.divide;, +import static com.google.common.math.IntMath.log2;, +import static java.math.RoundingMode.CEILING;, +import static java.math.RoundingMode.FLOOR;, +import static java.math.RoundingMode.UNNECESSARY;, +, +import com.google.common.annotations.Beta;, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.base.Ascii;, +import com.google.common.base.CharMatcher;, +import com.google.common.io.GwtWorkarounds.ByteInput;, +import com.google.common.io.GwtWorkarounds.ByteOutput;, +import com.google.common.io.GwtWorkarounds.CharInput;, +import com.google.common.io.GwtWorkarounds.CharOutput;, +, +import java.io.IOException;, +import java.util.Arrays;, +, +import javax.annotation.CheckReturnValue;, +import javax.annotation.Nullable;, +, +/**, + * A binary encoding scheme for translating between byte sequences and ASCII strings. This class, + * includes several constants for encoding schemes specified by <a, + * href="http://tools.ietf.org/html/rfc4648">RFC 4648</a>., + *, + * <p>All instances of this class are immutable, so they may be stored safely as static constants., + *, + * @author Louis Wasserman, + * @since 14.0, + */, +@Beta, +@GwtCompatible(emulated = true), +public abstract class BaseEncoding {, +  BaseEncoding() {}, +, +  /**, +   * Encodes the specified byte array, and returns the encoded {@code String}., +   */, +  public String encode(byte[] bytes) {, +    return encode(checkNotNull(bytes), 0, bytes.length);, +  }, +, +  /**, +   * Encodes the specified range of the specified byte array, and returns the encoded, +   * {@code String}., +   */, +  public final String encode(byte[] bytes, int off, int len) {, +    checkNotNull(bytes);, +    checkPositionIndexes(off, off + len, bytes.length);, +    CharOutput result = stringBuilderOutput(maxEncodedSize(len));, +    ByteOutput byteOutput = encodingStream(result);, +    try {, +      for (int i = 0; i < len; i++) {, +        byteOutput.write(bytes[off + i]);, +      }, +      byteOutput.close();, +    } catch (IOException impossible) {, +      throw new AssertionError("impossible");, +    }, +    return result.toString();, +  }, +, +  // TODO(user): document the extent of leniency, probably after adding ignore(CharMatcher), +, +  private static byte[] extract(byte[] result, int length) {, +    if (length == result.length) {, +      return result;, +    } else {, +      byte[] trunc = new byte[length];, +      System.arraycopy(result, 0, trunc, 0, length);, +      return trunc;, +    }, +  }, +, +  /**, +   * Decodes the specified character sequence, and returns the resulting {@code byte[]}., +   * This is the inverse operation to {@link #encode(byte[])}.]