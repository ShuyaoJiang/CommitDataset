[+++ b/guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/FuturesTest.java, +import java.util.concurrent.RejectedExecutionException;, +  public void testTransform_rejectionPropagatesToOutput(), +      throws Exception {, +    SettableFuture<Foo> input = SettableFuture.create();, +    ListenableFuture<String> transformed =, +        Futures.transform(input, Functions.toStringFunction(), REJECTING_EXECUTOR);, +    input.set(new Foo());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +, +  public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {, +    SettableFuture<String> input = SettableFuture.create();, +    ListenableFuture<String> transformed =, +        Futures.catching(input, Throwable.class, Functions.toStringFunction(), REJECTING_EXECUTOR);, +    input.setException(new Exception());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +, +, +  private static final Executor REJECTING_EXECUTOR =, +      new Executor() {, +        @Override, +        public void execute(Runnable runnable) {, +          throw new RejectedExecutionException();, +        }, +      };, +++ b/guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/FuturesTest.java, +import java.util.concurrent.RejectedExecutionException;, +  public void testTransform_rejectionPropagatesToOutput(), +      throws Exception {, +    SettableFuture<Foo> input = SettableFuture.create();, +    ListenableFuture<String> transformed =, +        Futures.transform(input, Functions.toStringFunction(), REJECTING_EXECUTOR);, +    input.set(new Foo());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +, +  public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {, +    SettableFuture<String> input = SettableFuture.create();, +    ListenableFuture<String> transformed =, +        Futures.catching(input, Throwable.class, Functions.toStringFunction(), REJECTING_EXECUTOR);, +    input.setException(new Exception());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);, +    }, +  }, +, +, +  private static final Executor REJECTING_EXECUTOR =, +      new Executor() {, +        @Override, +        public void execute(Runnable runnable) {, +          throw new RejectedExecutionException();, +        }, +      };, +++ b/guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java, +public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {, +  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();, +  testCase.setUp();, +  Throwable failure = null;, +  try {, +    testCase.testCatchingAsync_rejectionPropagatesToOutput();, +  } catch (Throwable t) {, +    failure = t;, +  }, +  try {, +    testCase.tearDown();, +  } catch (Throwable t) {, +    if (failure == null) {, +      failure = t;, +    }, +  }, +  if (failure instanceof Exception) {, +    throw (Exception) failure;, +  }, +  if (failure instanceof Error) {, +    throw (Error) failure;, +  }, +  if (failure != null) {, +    throw new RuntimeException(failure);, +  }]