[+++ b/guava/src/com/google/common/collect/FluentIterable.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + * <p>Several lesser-used features are currently available only as static methods on the, + * {@link Iterables} class., + *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually do, + *     so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is, +   * Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it is, +   * already a {@code FluentIterable}., +   * Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of this, +   * fluent iterable., +   * this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this, +   * fluent iterable is empty., +   * element}, use {@code Stream.generate(() -> element)}. Otherwise, if the source iterable has a, +   * {@code stream} method (for example, if it is a {@link Collection}), use, +   * Returns the elements from this fluent iterable that satisfy a predicate. The resulting fluent, +   * iterable's iterator does not support {@code remove()}., +   *, +   * @param type the type of elements desired, +   * Returns {@code true} if every element in this fluent iterable satisfies the predicate. If this, +   * fluent iterable is empty, {@code true} is returned., +   * Returns an {@link Optional} containing the first element in this fluent iterable that satisfies, +   * the given predicate, if such an element exists., +   * Returns a fluent iterable that applies {@code function} to each element of this fluent, +   * iterable., +   * Applies {@code function} to each element of this fluent iterable and returns a fluent iterable, +   * with the concatenated combination of results. {@code function} returns an Iterable of results., +   * <p>The returned fluent iterable's iterator supports {@code remove()} if this function-returned, +   * iterables' iterator does. After a successful {@code remove()} call, the returned fluent, +   * iterable no longer contains the corresponding element., +   * Returns an {@link Optional} containing the first element in this fluent iterable. If the, +   * iterable is empty, {@code Optional.absent()} is returned., +   * Returns an {@link Optional} containing the last element in this fluent iterable. If the, +   * iterable is empty, {@code Optional.absent()} is returned., +     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users with SortedSets tend, +     * to know they are SortedSets and probably would not call this method., +   * Returns a view of this fluent iterable that skips its first {@code numberToSkip} elements. If, +   * this fluent iterable contains fewer than {@code numberToSkip} elements, the returned fluent, +   * iterable skips all of its elements., +   * <p>Modifications to this fluent iterable before a call to {@code iterator()} are reflected in, +   * the returned fluent iterable. That is, the its iterator skips the first {@code numberToSkip}, +   * elements that exist when the iterator is created, not when {@code skip()} is called., +   * <p>The returned fluent iterable's iterator supports {@code remove()} if the {@code Iterator} of, +   * this fluent iterable supports it. Note that it is <i>not</i> possible to delete the last, +   * skipped element by immediately calling {@code remove()} on the returned fluent iterable's, +   * iterator, as the {@code Iterator} contract states that a call to {@code * remove()} before a, +   * call to {@code next()} will throw an {@link IllegalStateException}., +   * Creates a fluent iterable with the first {@code size} elements of this fluent iterable. If this, +   * fluent iterable does not contain that many elements, the returned fluent iterable will have the, +   * same behavior as this fluent iterable. The returned fluent iterable's iterator supports, +   * {@code remove()} if this fluent iterable's iterator does., +   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}, +   * behaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve, +   * the order of entries)., +   *, +   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one, +   *     value in this fluent iterable, +   * @throws NullPointerException if any elements of this fluent iterable is null, or if, +   *     {@code keyFunction} produces {@code null} for any value, +   * @return a newly-allocated array into which all the elements of this fluent iterable have been, +   *     copied]