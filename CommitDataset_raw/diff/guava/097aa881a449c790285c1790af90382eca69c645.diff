[+++ b/guava-gwt/src-super/com/google/common/cache/super/com/google/common/cache/CacheBuilder.java, +/*, + * Copyright (C) 2011 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.cache;, +, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkNotNull;, +import static com.google.common.base.Preconditions.checkState;, +, +import com.google.common.cache.CacheLoader.InvalidCacheLoadException;, +import com.google.common.collect.ImmutableMap;, +import com.google.common.util.concurrent.ExecutionError;, +import com.google.common.util.concurrent.UncheckedExecutionException;, +import com.google.gwt.user.client.Timer;, +, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +, +import javax.annotation.Nullable;, +, +/**, + * CacheBuilder emulation., + *, + * @author Charles Fry, + */, +// TODO(fry): eventually we should emmulate LocalCache instead of CacheBuilder, +public class CacheBuilder<K, V> {, +  private static final int UNSET_INT = -1;, +  private static final int DEFAULT_INITIAL_CAPACITY = 16;, +  private static final int DEFAULT_EXPIRATION_NANOS = 0;, +, +  private int initialCapacity = -1;, +  private int concurrencyLevel = -1;, +  private long expirationMillis = -1;, +  private int maximumSize = -1;, +, +  CacheBuilder() {}, +, +  public static CacheBuilder<Object, Object> newBuilder() {, +    return new CacheBuilder<Object, Object>();, +  }, +, +  public CacheBuilder<K, V> initialCapacity(int initialCapacity) {, +    checkState(this.initialCapacity == UNSET_INT, "initial capacity was already set to %s",, +        this.initialCapacity);, +    checkArgument(initialCapacity >= 0);, +    this.initialCapacity = initialCapacity;, +    return this;, +  }, +, +  private int getInitialCapacity() {, +    return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;, +  }, +, +  public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {, +    checkState(this.concurrencyLevel == UNSET_INT, "concurrency level was already set to %s",, +        this.concurrencyLevel);, +    checkArgument(concurrencyLevel > 0);, +    // GWT technically only supports concurrencyLevel == 1, but we silently, +    // ignore other positive values., +    this.concurrencyLevel = concurrencyLevel;, +    return this;, +  }, +, +  public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {, +    checkState(expirationMillis == UNSET_INT, "expireAfterWrite was already set to %s ms",, +        expirationMillis);, +    checkArgument(duration >= 0, "duration cannot be negative: %s %s", duration, unit);, +    this.expirationMillis = unit.toMillis(duration);, +    return this;, +  }, +, +  private long getExpirationMillis() {, +    return (expirationMillis == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expirationMillis;, +  }, +, +  public CacheBuilder<K, V> maximumSize(int maximumSize) {, +    if (this.maximumSize != -1) {, +      throw new IllegalStateException("maximum size of " + maximumSize + " was already set");, +    }, +    if (maximumSize < 0) {, +      throw new IllegalArgumentException("invalid maximum size: " + maximumSize);]