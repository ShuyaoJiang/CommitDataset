[+++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +import javax.annotation.Nullable;, +, +  final void maybePropagateCancellation(@Nullable Future<?> related) {, +    if (related != null && isCancelled()) {, +      related.cancel(wasInterrupted());, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +import javax.annotation.Nullable;, +, +  final void maybePropagateCancellation(@Nullable Future<?> related) {, +    if (related != null && isCancelled()) {, +      related.cancel(wasInterrupted());, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // For simplicity the rest of this description will discuss Futures.catching since it is the, +  // In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field, +  // 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the, +  // 'inputFuture' field is read and where we will have to consider visibility of the write, +  // operation in the constructor., +  // 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine., +  //    visible to done().  This is because there is no happens before edge between the write and a, +  //    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,, +  //    it would just add an edge such that if done() observed non-null, then it would also, +  //    definitely observe all earlier writes, but we still have no guarantee that done() would see, +  //    the inital write (just stronger guarantees if it does)., +      maybePropagateCancellation(inputFuture);, +          // TODO(cpovirk): fix those callers, and simplify this code, including relying on done(), +          // for most/all of the cleanup above, +    @Override void done() {, +, +        // TODO(cpovirk): use maybePropagateCancellation?, +        delegate.cancel(wasInterrupted());, +      maybePropagateCancellation(inputFuture);, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +import javax.annotation.Nullable;, +, +  final void maybePropagateCancellation(@Nullable Future<?> related) {, +    if (related != null && isCancelled()) {, +      related.cancel(wasInterrupted());, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // For simplicity the rest of this description will discuss Futures.catching since it is the, +  // In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field, +  // 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the, +  // 'inputFuture' field is read and where we will have to consider visibility of the write, +  // operation in the constructor., +  // 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine., +  //    visible to done().  This is because there is no happens before edge between the write and a, +  //    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,, +  //    it would just add an edge such that if done() observed non-null, then it would also, +  //    definitely observe all earlier writes, but we still have no guarantee that done() would see, +  //    the inital write (just stronger guarantees if it does)., +      maybePropagateCancellation(inputFuture);, +          // TODO(cpovirk): fix those callers, and simplify this code, including relying on done(), +          // for most/all of the cleanup above, +    @Override void done() {, +, +        // TODO(cpovirk): use maybePropagateCancellation?, +        delegate.cancel(wasInterrupted());, +      maybePropagateCancellation(inputFuture);, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +import com.google.errorprone.annotations.ForOverride;, +import java.util.concurrent.Future;, +  // TODO(cpovirk): @ForOverride if https://github.com/google/error-prone/issues/342 permits, +  /**, +   * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts), +   * the given future (if available)., +   *, +   * <p>This method should be used only when this future is completed. It is designed to be called, +   * from {@code done}., +   */, +  final void maybePropagateCancellation(@Nullable Future<?> related) {, +    if (related != null && isCancelled()) {, +      related.cancel(wasInterrupted());, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java, +import javax.annotation.Nullable;, +, +  final void maybePropagateCancellation(@Nullable Future<?> related) {, +    if (related != null && isCancelled()) {, +      related.cancel(wasInterrupted());, +    }, +  }, +, +++ b/guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java, +  // For simplicity the rest of this description will discuss Futures.catching since it is the, +  // In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field, +  // 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the, +  // 'inputFuture' field is read and where we will have to consider visibility of the write, +  // operation in the constructor., +  // 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine.]