[+++ b/guava-tests/test/com/google/common/util/concurrent/RateLimiterTest.java, +    RateLimiter limiter = RateLimiter.createBursty(ticker, 1.0, 10, TimeUnit.SECONDS);, +++ b/guava-tests/test/com/google/common/util/concurrent/RateLimiterTest.java, +    RateLimiter limiter = RateLimiter.createBursty(ticker, 1.0, 10, TimeUnit.SECONDS);, +++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java, +  // TODO(user): "This is equivalent to, +  //                 {@code createBursty(permitsPerSecond, 1, TimeUnit.SECONDS)}"., +    /*, +       * The default RateLimiter configuration can save the unused permits of up to one second., +       * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps,, +       * and 4 threads, all calling acquire() at these moments:, +       *, +       * T0 at 0 seconds, +       * T1 at 1.05 seconds, +       * T2 at 2 seconds, +       * T3 at 3 seconds, +       *, +       * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds,, +       * and T3 would also have to sleep till 3.05 seconds., +     */, +    RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */);, +   * fulfills the requests (e.g., a remote server) needs "warmup" time, rather than, +      SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) {, +    RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit);, +  /**, +   * Creates a {@code RateLimiter} with the specified stable throughput, given as, +   * "permits per second" (commonly referred to as <i>QPS</i>, queries per second),, +   * and the specified bursty behavior., +   *, +   * <p>The returned {@code RateLimiter} ensures that on average no more than {@code, +   * permitsPerSecond} are issued during any given second, with sustained requests, +   * being smoothly spread over each second. When the incoming request rate exceeds, +   * {@code permitsPerSecond} the rate limiter will release one permit every {@code, +   * (1.0 / permitsPerSecond)} seconds., +   *, +   * <p>When the rate limiter is unused, permits of up to {@code maxBurstBuildup} time, +   * period can be accumulated, and then produced upon request with no wait (in a burst)., +   * For example, {@code createBursty(2.0, 30, TimeUnit.SECONDS)} constructs a {@code RateLimiter}, +   * with a max rate of 2 qps, but if it is unused, it can save up permits that would have been, +   * produced in 30 seconds (at 2 qps rate, that's 60 permits), and give them to callers with no, +   * throttling. If the rate is changed to, say, 4 qps, then similarly the max saved permits, +   * will be {@code 4 * 30 = 120}., +   *, +   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in, +   *        how many permits become available per second., +   * @param maxBurstBuildup, +   * @param unit, +   */, +, +  /* public */ static RateLimiter createBursty(, +      double permitsPerSecond, long maxBurstBuildup, TimeUnit unit) {, +    return createBursty(SleepingTicker.SYSTEM_TICKER, permitsPerSecond, maxBurstBuildup, unit);, +  }, +, +      SleepingTicker ticker, double permitsPerSecond, long maxBurstBuildup, TimeUnit unit) {, +    double maxBurstSeconds = unit.toNanos(maxBurstBuildup) / 1E+9;, +    Bursty rateLimiter = new Bursty(ticker, maxBurstSeconds);, +   * This implements a "bursty" RateLimiter, where storedPermits are translated to, +   * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is, +   * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this, +   * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits., +    /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */, +    final double maxBurstSeconds;, +, +    Bursty(SleepingTicker ticker, double maxBurstSeconds) {, +      this.maxBurstSeconds = maxBurstSeconds;, +      maxPermits = maxBurstSeconds * permitsPerSecond;]