[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              if (!e.getValueReference().isComputingReference()) {, +                // never return expired entries, +                value = getLiveValue(e);, +                  recordLockedRead(e);, +              // don't consider expiration as we're concurrent with computation, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +              if (!e.getValueReference().isComputingReference()) {, +                // never return expired entries, +                value = getLiveValue(e);, +                  recordLockedRead(e);, +              // don't consider expiration as we're concurrent with computation, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +     *, +     * <p>Note: locked reads should use {@link #recordLockedRead}., +     * Updates the eviction metadata that {@code entry} was just read. This, +     * currently amounts to adding {@code entry} to relevant eviction lists., +     *, +     * <p>Note: this method should only be called under lock, as it directly, +     * manipulates the eviction queues. Unlocked reads should use {@link, +     * #recordRead}., +     */, +    @GuardedBy("Segment.this"), +    void recordLockedRead(ReferenceEntry<K, V> entry) {, +      evictionQueue.add(entry);, +      if (expiresAfterAccess()) {, +        recordExpirationTime(entry, expireAfterAccessNanos);, +        expirationQueue.add(entry);, +      }, +    }, +, +    /**, +              recordLockedRead(e);, +              recordLockedRead(e);, +      } else if (tryLock()) {, +        // TODO(user): only do this when a read encounters an expired entry, +        try {, +          // inexpensive read cleanup when the lock is available, +          expireEntries();, +        } finally {, +          unlock();, +        }, +     *, +     * <p>Post-condition: expireEntries has been run., +        // this is the only time we have the lock, so do everything we can]