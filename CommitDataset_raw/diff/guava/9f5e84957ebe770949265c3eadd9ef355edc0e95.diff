[+++ b/guava-tests/test/com/google/common/io/ByteSourceTester.java, +  // Test that you can not expand the readable data in a previously sliced ByteSource., +  public void testSlice_constrainedRange() throws IOException {, +    long size = source.read().length;, +    if (size >= 2) {, +      ByteSource sliced = source.slice(1, size - 2);, +      assertEquals(size - 2, sliced.read().length);, +      ByteSource resliced = sliced.slice(0, size - 1);, +      assertTrue(sliced.contentEquals(resliced));, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/io/ByteSourceTester.java, +  // Test that you can not expand the readable data in a previously sliced ByteSource., +  public void testSlice_constrainedRange() throws IOException {, +    long size = source.read().length;, +    if (size >= 2) {, +      ByteSource sliced = source.slice(1, size - 2);, +      assertEquals(size - 2, sliced.read().length);, +      ByteSource resliced = sliced.slice(0, size - 1);, +      assertTrue(sliced.contentEquals(resliced));, +    }, +  }, +, +++ b/guava/src/com/google/common/io/ByteSource.java, +    final long offset;, +    final long length;, +    SlicedByteSource(long offset, long length) {, +    final byte[] bytes;, +    final int offset;, +    final int length;, +    ByteArrayByteSource(byte[] bytes) {, +      this(bytes, 0, bytes.length);, +    }, +, +    // NOTE: Preconditions are enforced by slice, the only non-trivial caller., +    ByteArrayByteSource(byte[] bytes, int offset, int length) {, +      this.bytes = bytes;, +      this.offset = offset;, +      this.length = length;, +      return new ByteArrayInputStream(bytes, offset, length);, +      return length == 0;, +      return length;, +      return Arrays.copyOfRange(bytes, offset, offset + length);, +      output.write(bytes, offset, length);, +      return length;, +      processor.processBytes(bytes, offset, length);, +      return hashFunction.hashBytes(bytes, offset, length);, +    @Override, +    public ByteSource slice(long offset, long length) {, +      checkArgument(offset >= 0, "offset (%s) may not be negative", offset);, +      checkArgument(length >= 0, "length (%s) may not be negative", length);, +, +      int newOffset = this.offset + (int) Math.min(this.length, offset);, +      int endOffset = this.offset + (int) Math.min(this.length, offset + length);, +      return new ByteArrayByteSource(bytes, newOffset, endOffset - newOffset);, +    }, +          + truncate(BaseEncoding.base16().encode(bytes, offset, length), 30, "...") + ")";, +    static final EmptyByteSource INSTANCE = new EmptyByteSource();, +    EmptyByteSource() {, +    final Iterable<? extends ByteSource> sources;]