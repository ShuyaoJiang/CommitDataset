[+++ b/guava-gwt/src-super/com/google/common/math/super/com/google/common/math/LongMath.java, +import static java.lang.Math.min;, +  /**, +   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if, +   * {@code a == 0 && b == 0}., +   *, +   * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}, +   */, +  public static long gcd(long a, long b) {, +    /*, +     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on, +     * gcd(0, Long.MIN_VALUE)? BigInteger.gcd would return positive 2^63, but positive 2^63 isn't, +     * an int., +     */, +    checkNonNegative("a", a);, +    checkNonNegative("b", b);, +    if (a == 0) {, +      // 0 % b == 0, so b divides a, but the converse doesn't hold., +      // BigInteger.gcd is consistent with this decision., +      return b;, +    } else if (b == 0) {, +      return a; // similar logic, +    }, +    /*, +     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm., +     * This is >60% faster than the Euclidean algorithm in benchmarks., +     */, +    int aTwos = Long.numberOfTrailingZeros(a);, +    a >>= aTwos; // divide out all 2s, +    int bTwos = Long.numberOfTrailingZeros(b);, +    b >>= bTwos; // divide out all 2s, +    while (a != b) { // both a, b are odd, +      // The key to the binary GCD algorithm is as follows:, +      // Both a and b are odd.  Assume a > b; then gcd(a - b, b) = gcd(a, b)., +      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two., +, +      // We bend over backwards to avoid branching, adapting a technique from, +      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax, +, +      long delta = a - b; // can't overflow, since a and b are nonnegative, +, +      long minDeltaOrZero = delta & (delta >> (Long.SIZE - 1));, +      // equivalent to Math.min(delta, 0), +, +      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b), +      // a is now nonnegative and even, +, +      b += minDeltaOrZero; // sets b to min(old a, b), +      a >>= Long.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b, +    }, +    return a << min(aTwos, bTwos);, +  }, +, +    switch (k) {, +      case 0:, +        return 1;, +      case 1:, +        return n;, +      default:, +        if (n < factorials.length) {, +          return factorials[n] / (factorials[k] * factorials[n - k]);, +        } else if (k >= biggestBinomials.length || n > biggestBinomials[k]) {, +        } else if (k < biggestSimpleBinomials.length && n <= biggestSimpleBinomials[k]) {, +          long result = n--;, +          for (int i = 2; i <= k; n--, i++) {, +            result *= n;, +            result /= i;, +        } else {, +          int nBits = LongMath.log2(n, RoundingMode.CEILING);, +, +          long result = 1;, +          long numerator = n--;, +          long denominator = 1;, +, +          int numeratorBits = nBits;, +          // This is an upper bound on log2(numerator, ceiling)., +, +          /*, +           * We want to do this in long math for speed, but want to avoid overflow. We adapt the, +           * technique previously used by BigIntegerMath: maintain separate numerator and, +           * denominator accumulators, multiplying the fraction into result when near overflow., +           */, +          for (int i = 2; i <= k; i++, n--) {, +            if (numeratorBits + nBits < Long.SIZE - 1) {, +              // It's definitely safe to multiply into numerator and denominator., +              numerator *= n;, +              denominator *= i;, +              numeratorBits += nBits;, +            } else {, +              // It might not be safe to multiply into numerator and denominator,, +              // so multiply (numerator / denominator) into result., +              result = multiplyFraction(result, numerator, denominator);, +              numerator = n;, +              denominator = i;, +              numeratorBits = nBits;, +            }, +          }, +          return multiplyFraction(result, numerator, denominator);, +        }, +    }]