[+++ b/gwt-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +import com.google.common.base.Supplier;, + * @author Louis Wasserman, +        keySet = result = new ForwardingSet<K>() {, +, +          @Override public boolean remove(Object object) {, +            if (contains(object)) {, +              ImprovedAbstractMap.this.remove(object);, +              return true;, +            }, +            return false;, +          }, +        values = result = new ForwardingCollection<V>() {, +, +  /**, +   * An implementation of {@link Map#entrySet}., +   */, +  static <K, V> Set<Entry<K, V>> entrySetImpl(, +      Map<K, V> map, Supplier<Iterator<Entry<K, V>>> entryIteratorSupplier) {, +    return new EntrySetImpl<K, V>(map, entryIteratorSupplier);, +  }, +, +  private static class EntrySetImpl<K, V> extends AbstractSet<Entry<K, V>> {, +    private final Map<K, V> map;, +    private final Supplier<Iterator<Entry<K, V>>> entryIteratorSupplier;, +, +    EntrySetImpl(, +        Map<K, V> map, Supplier<Iterator<Entry<K, V>>> entryIteratorSupplier) {, +      this.map = checkNotNull(map);, +      this.entryIteratorSupplier = checkNotNull(entryIteratorSupplier);, +    }, +, +    @Override public Iterator<Entry<K, V>> iterator() {, +      return entryIteratorSupplier.get();, +    }, +, +    @Override public int size() {, +      return map.size();, +    }, +, +    @Override public void clear() {, +      map.clear();, +    }, +, +    @Override public boolean contains(Object o) {, +      if (o instanceof Entry) {, +        Entry<?, ?> entry = (Entry<?, ?>) o;, +        Object key = entry.getKey();, +        if (map.containsKey(key)) {, +          V value = map.get(entry.getKey());, +          return Objects.equal(value, entry.getValue());, +        }, +      }, +      return false;, +    }, +, +    @Override public boolean isEmpty() {, +      return map.isEmpty();, +    }, +, +    @Override public boolean remove(Object o) {, +      if (contains(o)) {, +        Entry<?, ?> entry = (Entry<?, ?>) o;, +        map.remove(entry.getKey());, +        return true;, +      }, +      return false;, +    }, +, +    @Override public int hashCode() {, +      return map.hashCode();, +    }, +  }, +, +  /**, +   * Implements {@code Collection.contains} safely for forwarding collections of, +   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is, +   * wrapped using {@link #unmodifiableEntry} to protect against a possible, +   * nefarious equals method., +   *, +   * <p>Note that {@code c} is the backing (delegate) collection, rather than, +   * the forwarding collection., +   *, +   * @param c the delegate (unwrapped) collection of map entries, +   * @param o the object that might be contained in {@code c}, +   * @return {@code true} if {@code c} contains {@code o}, +   */, +  static <K, V> boolean containsEntryImpl(Collection<Entry<K, V>> c, Object o) {, +    if (!(o instanceof Entry)) {, +      return false;, +    }, +    return c.contains(unmodifiableEntry((Entry<?, ?>) o));, +  }, +, +  /**, +   * Implements {@code Collection.remove} safely for forwarding collections of, +   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is, +   * wrapped using {@link #unmodifiableEntry} to protect against a possible, +   * nefarious equals method., +   *]