[+++ b/guava/src/com/google/common/base/AbstractEquivalence.java, +// Copyright 2011 Google Inc. All Rights Reserved., +, +package com.google.common.base;, +, +import com.google.common.annotations.GwtCompatible;, +, +import javax.annotation.Nullable;, +, +/**, + * Helper class to implement the contract around nulls., + * , + * @author benyu@google.com (Jige Yu), + */, +// TODO(benyu): Pull up into Equivalence and expose it as SPI., +@GwtCompatible, +abstract class AbstractEquivalence<T> extends Equivalence<T> {, +, +  @Override public final boolean equivalent(@Nullable T a, @Nullable T b) {, +    if (a == b) {, +      return true;, +    }, +    if (a == null || b == null) {, +      return false;, +    }, +    return equivalentNonNull(a, b);, +  }, +, +  @Override public final int hash(@Nullable T t) {, +    if (t == null) {, +      return 0;, +    }, +    return hashNonNull(t);, +  }, +, +  protected abstract boolean equivalentNonNull(T a, T b);, +  protected abstract int hashNonNull(T t);, +}, +++ b/guava/src/com/google/common/base/AbstractEquivalence.java, +// Copyright 2011 Google Inc. All Rights Reserved., +, +package com.google.common.base;, +, +import com.google.common.annotations.GwtCompatible;, +, +import javax.annotation.Nullable;, +, +/**, + * Helper class to implement the contract around nulls., + * , + * @author benyu@google.com (Jige Yu), + */, +// TODO(benyu): Pull up into Equivalence and expose it as SPI., +@GwtCompatible, +abstract class AbstractEquivalence<T> extends Equivalence<T> {, +, +  @Override public final boolean equivalent(@Nullable T a, @Nullable T b) {, +    if (a == b) {, +      return true;, +    }, +    if (a == null || b == null) {, +      return false;, +    }, +    return equivalentNonNull(a, b);, +  }, +, +  @Override public final int hash(@Nullable T t) {, +    if (t == null) {, +      return 0;, +    }, +    return hashNonNull(t);, +  }, +, +  protected abstract boolean equivalentNonNull(T a, T b);, +  protected abstract int hashNonNull(T t);, +}, +++ b/guava/src/com/google/common/base/Equivalence.java, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import java.io.Serializable;, +, +public abstract class Equivalence<T> {, +  public abstract boolean equivalent(@Nullable T a, @Nullable T b);, +   * Returns a hash code for {@code object}. The general contract of {@code hash} is:, +   * <ul>, +   * <li>Whenever it is invoked on the same object more than once during an execution of a Java, +   *     application, the {@code hash} method must consistently return the same integer, provided, +   *     no information used in {@link #equivalent} comparisons on the object is modified., +   *     This integer need not remain consistent from one execution of an application to another, +   *     execution of the same application., +   * <li>If two objects are equivalent according to {@link #equivalent} method, then calling the, +   *     {@code hash} method on each of the two objects must produce the same integer result., +   * <li>It is <b>not</b> required that if two objects are not equivalent according to, +   *     {@link #equivalent} method, then calling {@code hash()} on each of the two objects must, +   *     produce distinct integer results.  However, the programmer should be aware that producing, +   *     distinct integer results for non-equivalent objects may improve the performance of, +   *     hashtables., +   * <li>{@code 0} is returned for {@code null}., +   * </ul>, +  public abstract int hash(@Nullable T t);]