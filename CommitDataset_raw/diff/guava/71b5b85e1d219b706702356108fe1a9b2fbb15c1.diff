[+++ b/android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import static com.google.common.util.concurrent.Futures.scheduleAsync;, +import static com.google.common.util.concurrent.Futures.submitAsync;, +import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;, +import java.util.concurrent.ScheduledExecutorService;, +    executor.execute(, +    executor.shutdown();, +    assertTrue(executor.awaitTermination(5, SECONDS));, +  public void testSubmitAsync_asyncCallable_error() throws InterruptedException {, +    final Error error = new Error("deliberate");, +    AsyncCallable<Integer> callable =, +        new AsyncCallable<Integer>() {, +          @Override, +          public ListenableFuture<Integer> call() {, +            throw error;, +          }, +        };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());, +    inputFuture.set("value");, +    try {, +      getDone(outputFuture);, +      fail();, +    } catch (ExecutionException expected) {, +      assertSame(error, expected.getCause());, +    }, +  }, +, +  public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {, +    ListenableFuture<?> chainedFuture = submitAsync(constantAsyncCallable(null), directExecutor());, +    try {, +      getDone(chainedFuture);, +      fail();, +    } catch (ExecutionException expected) {, +      NullPointerException cause = (NullPointerException) expected.getCause();, +      assertThat(cause), +          .hasMessage(, +              "AsyncCallable.call returned null instead of a Future. ", +                  + "Did you mean to return immediateFuture(null)?");, +    }, +  }, +, +  @GwtIncompatible // threads, +, +  public void testSubmitAsync_asyncCallable_cancelledWhileApplyingFunction(), +      throws InterruptedException, ExecutionException {, +    final CountDownLatch inFunction = new CountDownLatch(1);, +    final CountDownLatch callableDone = new CountDownLatch(1);, +    final SettableFuture<Integer> resultFuture = SettableFuture.create();, +    AsyncCallable<Integer> callable =, +        new AsyncCallable<Integer>() {, +          @Override, +          public ListenableFuture<Integer> call() throws InterruptedException {, +            inFunction.countDown();, +            callableDone.await();, +            return resultFuture;, +          }, +        };, +    SettableFuture<String> inputFuture = SettableFuture.create();, +    ListenableFuture<Integer> future = submitAsync(callable, newSingleThreadExecutor());, +    inputFuture.set("value");, +    inFunction.await();, +    future.cancel(false);, +    callableDone.countDown();, +    try {, +      future.get();, +      fail();, +    } catch (CancellationException expected) {, +    }, +    try {, +      resultFuture.get();, +      fail();, +    } catch (CancellationException expected) {, +    }, +  }, +, +  @GwtIncompatible // threads, +, +  public void testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction(), +      throws InterruptedException {, +    final AtomicBoolean callableCalled = new AtomicBoolean();, +    AsyncCallable<Integer> callable =, +        new AsyncCallable<Integer>() {, +          @Override, +          public ListenableFuture<Integer> call() {, +            callableCalled.set(true);, +            return immediateFuture(1);, +          }, +        };, +    ExecutorService executor = newSingleThreadExecutor();, +    // Pause the executor., +    final CountDownLatch beforeFunction = new CountDownLatch(1);, +    executor.execute(, +        new Runnable() {, +          @Override, +          public void run() {, +            awaitUninterruptibly(beforeFunction);, +          }, +        });, +    ListenableFuture<Integer> future = submitAsync(callable, executor);]