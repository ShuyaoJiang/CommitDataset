[+++ /dev/null, +++ /dev/null, +++ b/guava/src/com/google/common/graph/AbstractConfigurableNetwork.java, + * and a reference node for every edge., +  protected final Map<E, N> edgeToReferenceNode; // reference node == source on directed networks, +        Maps.<E, N>newLinkedHashMapWithExpectedSize(, +      Map<E, N> edgeToReferenceNode) {, +    this.edgeToReferenceNode = checkNotNull(edgeToReferenceNode);, +    return Collections.unmodifiableSet(edgeToReferenceNode.keySet());, +    N node1 = checkedReferenceNode(edge);, +    N node2 = nodeConnections.get(node1).oppositeNode(edge);, +    return ImmutableSet.of(node1, node2);, +    NodeConnections<N, E> connectionsN1 = checkedConnections(node1);, +    if (!allowsSelfLoops && node1.equals(node2)) {, +    checkArgument(nodeConnections.get(node2) != null, NODE_NOT_IN_GRAPH, node2);, +    return connectionsN1.edgesConnecting(node2);, +    return checkedReferenceNode(edge);, +    N source = source(edge);, +    return nodeConnections.get(source).oppositeNode(edge);, +  protected N checkedReferenceNode(Object edge) {, +    N referenceNode = edgeToReferenceNode.get(edge);, +    checkArgument(referenceNode != null, EDGE_NOT_IN_GRAPH, edge);, +    return referenceNode;, +++ /dev/null, +++ b/guava/src/com/google/common/graph/AbstractConfigurableNetwork.java, + * and a reference node for every edge., +  protected final Map<E, N> edgeToReferenceNode; // reference node == source on directed networks, +        Maps.<E, N>newLinkedHashMapWithExpectedSize(, +      Map<E, N> edgeToReferenceNode) {, +    this.edgeToReferenceNode = checkNotNull(edgeToReferenceNode);, +    return Collections.unmodifiableSet(edgeToReferenceNode.keySet());, +    N node1 = checkedReferenceNode(edge);, +    N node2 = nodeConnections.get(node1).oppositeNode(edge);, +    return ImmutableSet.of(node1, node2);, +    NodeConnections<N, E> connectionsN1 = checkedConnections(node1);, +    if (!allowsSelfLoops && node1.equals(node2)) {, +    checkArgument(nodeConnections.get(node2) != null, NODE_NOT_IN_GRAPH, node2);, +    return connectionsN1.edgesConnecting(node2);, +    return checkedReferenceNode(edge);, +    N source = source(edge);, +    return nodeConnections.get(source).oppositeNode(edge);, +  protected N checkedReferenceNode(Object edge) {, +    N referenceNode = edgeToReferenceNode.get(edge);, +    checkArgument(referenceNode != null, EDGE_NOT_IN_GRAPH, edge);, +    return referenceNode;, +++ b/guava/src/com/google/common/graph/AbstractDirectedNodeConnections.java, +/*, + * Copyright (C) 2016 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.graph;, +, +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkNotNull;, +, +import com.google.common.collect.Sets;, +, +import java.util.Collections;, +import java.util.Map;, +import java.util.Set;, +, +/**, + * A base implementation of {@link NodeConnections} for directed networks., + *, + * @author James Sexton, + * @param <N> Node parameter type, + * @param <E> Edge parameter type, + */, +abstract class AbstractDirectedNodeConnections<N, E> implements NodeConnections<N, E> {, +  /**, +   * Keys are edges incoming to the origin node, values are the source node., +   */, +  protected final Map<E, N> inEdgeMap;, +, +  /**, +   * Keys are edges outgoing from the origin node, values are the target node., +   */, +  protected final Map<E, N> outEdgeMap;, +, +  protected AbstractDirectedNodeConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap) {, +    this.inEdgeMap = checkNotNull(inEdgeMap, "inEdgeMap");, +    this.outEdgeMap = checkNotNull(outEdgeMap, "outEdgeMap");, +  }, +, +  @Override, +  public Set<N> adjacentNodes() {, +    return Sets.union(predecessors(), successors());, +  }]