[+++ b/guava/src/com/google/common/util/concurrent/Futures.java, +import com.google.common.base.Optional;, +import com.google.common.collect.ImmutableCollection;, +import com.google.common.collect.Sets;, +    return listFuture(ImmutableList.copyOf(futures), true,, +    return listFuture(ImmutableList.copyOf(futures), true,, +    return listFuture(ImmutableList.copyOf(futures), false,, +    return listFuture(ImmutableList.copyOf(futures), false,, +  private interface FutureCombiner<V, C> {, +    C combine(List<Optional<V>> values);, +  }, +, +  private static class CombinedFuture<V, C> extends AbstractFuture<C> {, +    ImmutableCollection<? extends ListenableFuture<? extends V>> futures;, +    FutureCombiner<V, C> combiner;, +    List<Optional<V>> values;, +    CombinedFuture(, +        ImmutableCollection<? extends ListenableFuture<? extends V>> futures,, +        boolean allMustSucceed, Executor listenerExecutor,, +        FutureCombiner<V, C> combiner) {, +      this.combiner = combiner;, +      this.values = Lists.newArrayListWithCapacity(futures.size());, +    /**, +     * Must be called at the end of the constructor., +     */, +    protected void init(final Executor listenerExecutor) {, +          CombinedFuture.this.futures = null;, +          CombinedFuture.this.values = null;, +, +          // The combiner may also hold state, so free that as well, +          CombinedFuture.this.combiner = null;, +        set(combiner.combine(ImmutableList.<Optional<V>>of()));, +      // This is not actually a problem, since the foreach only needs, +      // this.futures to be non-null at the beginning of the loop., +      int i = 0;, +      for (final ListenableFuture<? extends V> listenable : futures) {, +        final int index = i++;, +      List<Optional<V>> localValues = values;, +        localValues.set(index,, +            Optional.fromNullable(getUninterruptibly(future)));, +          FutureCombiner<V, C> localCombiner = combiner;, +          if (localCombiner != null) {, +            set(localCombiner.combine(localValues));, +  /** Used for {@link #allAsList} and {@link #successfulAsList}. */, +  private static <V> ListenableFuture<List<V>> listFuture(, +      ImmutableList<ListenableFuture<? extends V>> futures,, +      boolean allMustSucceed, Executor listenerExecutor) {, +    return new CombinedFuture<V, List<V>>(, +        futures, allMustSucceed, listenerExecutor,, +        new FutureCombiner<V, List<V>>() {, +          @Override, +          public List<V> combine(List<Optional<V>> values) {, +            List<V> result = Lists.newArrayList();, +            for (Optional<V> element : values) {, +              result.add(element != null ? element.orNull() : null);, +            }, +            // TODO(user): This should ultimately return an unmodifiableList, +            return result;, +          }, +        });, +  }, +]