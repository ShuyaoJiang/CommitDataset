[+++ b/guava/src/com/google/common/util/concurrent/Futures.java, +  private static class FallbackFuture<V> extends AbstractFuture.TrustedFuture<V> {, +    ListenableFuture<? extends V> running;, +      input.addListener(new Runnable() {, +        @Override public void run() {, +          ListenableFuture<? extends V> localRunning = running;, +          running = null;, +          if (localRunning == null | isCancelled()) {, +          Throwable throwable;, +            set(getUninterruptibly(localRunning));, +            return;, +          } catch (ExecutionException e) {, +            throwable = e.getCause();, +          } catch (Throwable e) {  // this includes cancellation exception, +            throwable = e;, +          }, +          try {, +            setFuture(fallback.create(throwable));, +      ListenableFuture<?> current = this.running;, +        // May be null if the original future completed, but we were cancelled while the fallback, +        // is still pending.  This is fine because if the original future completed, then there is, +        // nothing to cancel and if the fallback is pending, cancellation would be handled by, +        // super.cancel()., +        if (current != null) {, +          current.cancel(mayInterruptIfRunning);, +        }]