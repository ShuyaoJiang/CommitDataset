[+++ b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java, + * @author Louis Wasserman, +  private void assertParseFails(String value) {, +    boolean overflowCaught = false;, +    try {, +      UnsignedBytes.parseUnsignedByte(value);, +    } catch (NumberFormatException e) {, +      overflowCaught = true;, +    }, +    assertTrue(overflowCaught);, +  }, +, +  public void testParseUnsignedByte() {, +    // We can easily afford to test this exhaustively., +    for (int i = 0; i <= 0xff; i++) {, +      assertEquals((byte) i, UnsignedBytes.parseUnsignedByte(Integer.toString(i)));, +    }, +    assertParseFails("1000");, +    assertParseFails("-1");, +    assertParseFails("-128");, +  }, +, +  public void testMaxValue() {, +    assertTrue(UnsignedBytes, +        .compare(UnsignedBytes.MAX_VALUE, (byte) (UnsignedBytes.MAX_VALUE + 1)) > 0);, +  }, +, +  private void assertParseFails(String value, int radix) {, +    boolean overflowCaught = false;, +    try {, +      UnsignedBytes.parseUnsignedByte(value, radix);, +    } catch (NumberFormatException e) {, +      overflowCaught = true;, +    }, +    assertTrue(overflowCaught);, +  }, +, +  public void testParseUnsignedByteWithRadix() throws NumberFormatException {, +    // We can easily afford to test this exhaustively., +    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {, +      for (int i = 0; i <= 0xff; i++) {, +        assertEquals((byte) i, UnsignedBytes.parseUnsignedByte(Integer.toString(i, radix), radix));, +      }, +      assertParseFails(Integer.toString(1000, radix), radix);, +      assertParseFails(Integer.toString(-1, radix), radix);, +    }, +  }, +, +  public void testParseUnsignedByteThrowsExceptionForInvalidRadix() {, +    // Valid radix values are Character.MIN_RADIX to Character.MAX_RADIX,, +    // inclusive., +    try {, +      UnsignedBytes.parseUnsignedByte("0", Character.MIN_RADIX - 1);, +      fail();, +    } catch (NumberFormatException nfe) {, +      // expected, +    }, +, +    try {, +      UnsignedBytes.parseUnsignedByte("0", Character.MAX_RADIX + 1);, +      fail();, +    } catch (NumberFormatException nfe) {, +      // expected, +    }, +, +    // The radix is used as an array index, so try a negative value., +    try {, +      UnsignedBytes.parseUnsignedByte("0", -1);, +      fail();, +    } catch (NumberFormatException nfe) {, +      // expected, +    }, +  }, +, +  public void testToString() {, +    // We can easily afford to test this exhaustively., +    for (int i = 0; i <= 0xff; i++) {, +      assertEquals(Integer.toString(i), UnsignedBytes.toString((byte) i));, +    }, +  }, +, +  public void testToStringWithRadix() {, +    // We can easily afford to test this exhaustively., +    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {, +      for (int i = 0; i <= 0xff; i++) {, +        assertEquals(Integer.toString(i, radix), UnsignedBytes.toString((byte) i, radix));, +      }, +    }, +  }, +, +    tester.setDefault(int.class, 5);, +    tester.setDefault(String.class, "5");, +++ b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java, + * @author Louis Wasserman, +  private void assertParseFails(String value) {, +    boolean overflowCaught = false;, +    try {, +      UnsignedBytes.parseUnsignedByte(value);, +    } catch (NumberFormatException e) {, +      overflowCaught = true;]