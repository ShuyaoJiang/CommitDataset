[+++ b/guava/src/com/google/common/util/concurrent/Futures.java, +   * @param future The future to transform, +   * @param function A Function to transform the results of the provided future, +   * @return A future that holds result of the transformation., +   * @param future The future to transform, +   * @param function A Function to transform the results of the provided future, +   * @return A future that holds result of the transformation., +   * Like {@link #transform(ListenableFuture, Function)} except that the, +   * transformation {@code function} is invoked on each call to, +   * {@link Future#get() get()} on the returned future., +   *, +   * <p>The returned {@code Future} reflects the input input's cancellation, +   * state directly, and any attempt to cancel the returned Future is likewise, +   * passed through to the input Future., +   *, +   * <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get}, +   * only apply the timeout to the execution of the underlying {@code Future},, +   * <em>not</em> to the execution of the transformation function., +   *, +   * <p>The primary audience of this method is callers of {@code transform}, +   * who don't have a {@code ListenableFuture} available and, +   * do not mind repeated, lazy function evaluation., +   *, +   * @param future The future to transform, +   * @param function A Function to transform the results of the provided future, +   *     to the results of the returned future., +   * @return A future that returns the result of the transformation., +   * @since Guava release 10, +   */, +  @Beta, +  public static <I, O> Future<O> lazyTransform(final Future<I> future,, +      final Function<? super I, ? extends O> function) {, +    checkNotNull(future);, +    checkNotNull(function);, +    return new Future<O>() {, +, +      @Override, +      public boolean cancel(boolean mayInterruptIfRunning) {, +        return future.cancel(mayInterruptIfRunning);, +      }, +, +      @Override, +      public boolean isCancelled() {, +        return future.isCancelled();, +      }, +, +      @Override, +      public boolean isDone() {, +        return future.isDone();, +      }, +, +      @Override, +      public O get() throws InterruptedException, ExecutionException {, +        return applyTransformation(future.get());, +      }, +, +      @Override, +      public O get(long timeout, TimeUnit unit), +          throws InterruptedException, ExecutionException, TimeoutException {, +        return applyTransformation(future.get(timeout, unit));, +      }, +, +      private O applyTransformation(I input) throws ExecutionException {, +        try {, +          return function.apply(input);, +        } catch (Throwable t) {, +          throw new ExecutionException(t);, +        }, +      }, +    };, +  }, +, +  /**, +   * @param future The future to transform, +   * @param function A Function to transform the results of the provided future, +   * @return A future that computes result of the transformation]