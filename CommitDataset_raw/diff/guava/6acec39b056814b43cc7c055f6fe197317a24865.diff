[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import com.google.common.base.Function;, +  final Function<? super K, ? extends V> computingFunction;, +      Function<? super K, ? extends V> computingFunction) {, +    super(builder);, +    this.computingFunction = checkNotNull(computingFunction);, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new ComputingSegment<K, V>(this, initialCapacity, maxSegmentSize);, +    return segmentFor(hash).getOrCompute(key, hash, computingFunction);, +    ComputingSegment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      super(map, initialCapacity, maxSegmentSize);, +    V getOrCompute(K key, int hash, Function<? super K, ? extends V> computingFunction), +                computingValueReference = new ComputingValueReference<K, V>(computingFunction);, +    final Function<? super K, ? extends V> computingFunction;, +    public ComputingValueReference(Function<? super K, ? extends V> computingFunction) {, +      this.computingFunction = computingFunction;, +        value = computingFunction.apply(key);, +        Function<? super K, ? extends V> computingFunction) {, +      super(mapMaker, computingFunction);, +        throw new NullPointerException(computingFunction + " returned null for key " + key + ".");, +        concurrencyLevel, removalListener, this, computingFunction);, +    final Function<? super K, ? extends V> computingFunction;, +        ConcurrentMap<K, V> delegate, Function<? super K, ? extends V> computingFunction) {, +      this.computingFunction = computingFunction;, +      delegate = mapMaker.makeComputingMap(computingFunction);, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import com.google.common.base.Function;, +  final Function<? super K, ? extends V> computingFunction;, +      Function<? super K, ? extends V> computingFunction) {, +    super(builder);, +    this.computingFunction = checkNotNull(computingFunction);, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new ComputingSegment<K, V>(this, initialCapacity, maxSegmentSize);, +    return segmentFor(hash).getOrCompute(key, hash, computingFunction);, +    ComputingSegment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      super(map, initialCapacity, maxSegmentSize);, +    V getOrCompute(K key, int hash, Function<? super K, ? extends V> computingFunction), +                computingValueReference = new ComputingValueReference<K, V>(computingFunction);, +    final Function<? super K, ? extends V> computingFunction;, +    public ComputingValueReference(Function<? super K, ? extends V> computingFunction) {, +      this.computingFunction = computingFunction;, +        value = computingFunction.apply(key);, +        Function<? super K, ? extends V> computingFunction) {, +      super(mapMaker, computingFunction);, +        throw new NullPointerException(computingFunction + " returned null for key " + key + ".");, +        concurrencyLevel, removalListener, this, computingFunction);, +    final Function<? super K, ? extends V> computingFunction;, +        ConcurrentMap<K, V> delegate, Function<? super K, ? extends V> computingFunction) {, +      this.computingFunction = computingFunction;, +      delegate = mapMaker.makeComputingMap(computingFunction);, +++ b/guava/src/com/google/common/collect/CustomConcurrentHashMap.java, +  CustomConcurrentHashMap(MapMaker builder) {, +            createSegment(segmentSize, maximumSegmentSize);, +            createSegment(segmentSize, MapMaker.UNSET_INT);, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new Segment<K, V>(this, initialCapacity, maxSegmentSize);, +    Segment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/guava/src/com/google/common/collect/ComputingConcurrentHashMap.java, +import com.google.common.base.Function;, +  final Function<? super K, ? extends V> computingFunction;, +      Function<? super K, ? extends V> computingFunction) {, +    super(builder);, +    this.computingFunction = checkNotNull(computingFunction);, +  Segment<K, V> createSegment(int initialCapacity, int maxSegmentSize) {, +    return new ComputingSegment<K, V>(this, initialCapacity, maxSegmentSize);, +    return segmentFor(hash).getOrCompute(key, hash, computingFunction);, +    ComputingSegment(CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize) {, +      super(map, initialCapacity, maxSegmentSize);, +    V getOrCompute(K key, int hash, Function<? super K, ? extends V> computingFunction), +                computingValueReference = new ComputingValueReference<K, V>(computingFunction);]