[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  private static final Function<Entry, Object> VALUE_FUNCTION = new Function<Entry, Object>() {, +    @Override, +    public Object apply(Entry entry) {, +      return entry.getValue();, +    }, +  };, +, +  @SuppressWarnings("unchecked"), +  static <V> Function<Entry<?, V>, V> valueFunction() {, +    return (Function) VALUE_FUNCTION;, +  }, +, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java, +  private static final Function<Entry, Object> VALUE_FUNCTION = new Function<Entry, Object>() {, +    @Override, +    public Object apply(Entry entry) {, +      return entry.getValue();, +    }, +  };, +, +  @SuppressWarnings("unchecked"), +  static <V> Function<Entry<?, V>, V> valueFunction() {, +    return (Function) VALUE_FUNCTION;, +  }, +, +++ b/guava-tests/test/com/google/common/collect/TreeRangeMapTest.java, +import com.google.common.collect.testing.features.MapFeature;, +import com.google.common.collect.testing.testers.CollectionIteratorTester;, +          MapFeature.SUPPORTS_REMOVE,, +          MapFeature.ALLOWS_NULL_QUERIES,, +, +    suite.addTest(MapTestSuiteBuilder.using(new TestMapGenerator<Range<Integer>, String>() {, +        @Override, +        public SampleElements<Entry<Range<Integer>, String>> samples() {, +          return new SampleElements<Entry<Range<Integer>, String>>(, +              mapEntry(Range.singleton(0), "banana"),, +              mapEntry(Range.closedOpen(3, 5), "frisbee"),, +              mapEntry(Range.atMost(-1), "fruitcake"),, +              mapEntry(Range.open(10, 15), "elephant"),, +              mapEntry(Range.closed(20, 22), "umbrella"));, +        }, +, +        @Override, +        public Map<Range<Integer>, String> create(Object... elements) {, +          RangeMap<Integer, String> rangeMap = TreeRangeMap.create();, +          for (Object o : elements) {, +            @SuppressWarnings("unchecked"), +            Entry<Range<Integer>, String> entry = (Entry<Range<Integer>, String>) o;, +            rangeMap.put(entry.getKey(), entry.getValue());, +          }, +          return rangeMap.subRangeMap(Range.atMost(22)).asMapOfRanges();, +        }, +, +        @SuppressWarnings("unchecked"), +        @Override, +        public Entry<Range<Integer>, String>[] createArray(int length) {, +          return new Entry[length];, +        }, +, +        @Override, +        public Iterable<Entry<Range<Integer>, String>> order(, +            List<Entry<Range<Integer>, String>> insertionOrder) {, +          return Range.RANGE_LEX_ORDERING.onResultOf(Maps.<Range<Integer>>keyFunction()), +              .sortedCopy(insertionOrder);, +        }, +, +        @SuppressWarnings("unchecked"), +        @Override, +        public Range<Integer>[] createKeyArray(int length) {, +          return new Range[length];, +        }, +, +        @Override, +        public String[] createValueArray(int length) {, +          return new String[length];, +        }, +      }), +      .named("TreeRangeMap.subRangeMap.asMapOfRanges"), +      .withFeatures(, +          CollectionSize.ANY,, +          MapFeature.SUPPORTS_REMOVE,, +          MapFeature.ALLOWS_NULL_QUERIES,, +          CollectionFeature.KNOWN_ORDER), +      .suppressing(CollectionIteratorTester.getIteratorKnownOrderRemoveSupportedMethod()), +      .createTestSuite());, +  private static final int MIN_BOUND = -2;, +  private static final int MAX_BOUND = 2;, +  public void testSubRangeMapExhaustive() {, +    for (Range<Integer> range1 : RANGES) {, +      for (Range<Integer> range2 : RANGES) {, +        RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();, +        rangeMap.put(range1, 1);, +        rangeMap.put(range2, 2);, +, +        for (Range<Integer> subRange : RANGES) {, +          RangeMap<Integer, Integer> expected = TreeRangeMap.create();, +          for (Map.Entry<Range<Integer>, Integer> entry : rangeMap.asMapOfRanges().entrySet()) {, +            if (entry.getKey().isConnected(subRange)) {, +              expected.put(entry.getKey().intersection(subRange), entry.getValue());]