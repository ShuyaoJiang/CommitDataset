[+++ b/guava/src/com/google/common/graph/DirectedGraphConnections.java, +import static com.google.common.base.Preconditions.checkState;, +import static com.google.common.graph.Graphs.checkNonNegative;, +import static com.google.common.graph.Graphs.checkPositive;, +import com.google.common.collect.AbstractIterator;, +import com.google.common.collect.UnmodifiableIterator;, +import java.util.AbstractSet;, +import java.util.Iterator;, +import java.util.Map.Entry;, +import javax.annotation.Nullable;, +  /**, +   * A wrapper class to indicate a node is both a predecessor and successor while still providing, +   * the successor value., +   */, +  private static final class PredAndSucc {, +    private final Object successorValue;, +    PredAndSucc(Object userValue) {, +      this.successorValue = userValue;, +    }, +  }, +  private static final Object PRED = new Object();, +, +  // Every value in this map must either be an instance of PredAndSucc with a successorValue of, +  // type V, PRED (representing predecessor), or an instance of type V (representing successor)., +  private final Map<N, Object> adjacentNodeValues;, +, +  private int predecessorCount;, +  private int successorCount;, +, +  private DirectedGraphConnections(, +      Map<N, Object> adjacentNodeValues, int predecessorCount, int successorCount) {, +    this.adjacentNodeValues = checkNotNull(adjacentNodeValues, "adjacentNodeValues");, +    this.predecessorCount = checkNonNegative(predecessorCount);, +    this.successorCount = checkNonNegative(successorCount);, +    checkState(predecessorCount <= adjacentNodeValues.size(), +        && successorCount <= adjacentNodeValues.size());, +    // We store predecessors and successors in the same map, so double the initial capacity., +    int initialCapacity = INNER_CAPACITY * 2;, +        new HashMap<N, Object>(initialCapacity, INNER_LOAD_FACTOR), 0, 0);, +    Map<N, Object> adjacentNodeValues = new HashMap<N, Object>();, +    adjacentNodeValues.putAll(successorValues);, +    for (N predecessor : predecessors) {, +      Object value = adjacentNodeValues.put(predecessor, PRED);, +      if (value != null) {, +        adjacentNodeValues.put(predecessor, new PredAndSucc(value));, +      }, +    }, +    return new DirectedGraphConnections<N, V>(ImmutableMap.copyOf(adjacentNodeValues),, +        predecessors.size(), successorValues.size());, +    return Collections.unmodifiableSet(adjacentNodeValues.keySet());, +    return new AbstractSet<N>() {, +      @Override, +      public UnmodifiableIterator<N> iterator() {, +        final Iterator<Entry<N, Object>> entries = adjacentNodeValues.entrySet().iterator();, +        return new AbstractIterator<N>() {, +          @Override, +          protected N computeNext() {, +            while (entries.hasNext()) {, +              Entry<N, Object> entry = entries.next();, +              if (isPredecessor(entry.getValue())) {, +                return entry.getKey();, +              }, +            }, +            return endOfData();, +          }, +        };, +      }, +, +      @Override, +      public int size() {, +        return predecessorCount;, +      }, +, +      @Override, +      public boolean contains(@Nullable Object obj) {, +        return isPredecessor(adjacentNodeValues.get(obj));, +      }, +    };, +    return new AbstractSet<N>() {, +      @Override, +      public UnmodifiableIterator<N> iterator() {, +        final Iterator<Entry<N, Object>> entries = adjacentNodeValues.entrySet().iterator();, +        return new AbstractIterator<N>() {, +          @Override, +          protected N computeNext() {, +            while (entries.hasNext()) {, +              Entry<N, Object> entry = entries.next();, +              if (isSuccessor(entry.getValue())) {, +                return entry.getKey();, +              }, +            }, +            return endOfData();, +          }, +        };, +      public int size() {, +        return successorCount;, +      }, +, +      @Override, +      public boolean contains(@Nullable Object obj) {]