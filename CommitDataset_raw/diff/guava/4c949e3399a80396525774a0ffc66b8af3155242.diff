[+++ b/build.xml, +        match="^.*(META NAME=.date|enerated by javadoc .build).*$\n", +++ b/build.xml, +        match="^.*(META NAME=.date|enerated by javadoc .build).*$\n", +++ b/src/com/google/common/net/InetAddresses.java, +    String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));, +    String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));, +++ b/build.xml, +        match="^.*(META NAME=.date|enerated by javadoc .build).*$\n", +++ b/src/com/google/common/net/InetAddresses.java, +    String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));, +    String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));, +++ b/src/com/google/common/net/InternetDomainName.java, +import com.google.common.base.CharMatcher;, +  // TODO: For the moment, we validate that all parts of a domain, +  // * Start and end with an alphanumeric character, +  // * Have alphanumeric, dash, or underscore characters internally, +  // An additional constraint is that the first character of the last part, +  // may not be numeric., +  // All of this is a compromise to allow relatively accurate and efficient, +  // checking. We may soon move to using java.net.IDN for this purpose in, +  // non-GWT code., +    if (!validatePart(parts.get(lastIndex), true)) {, +      if (!validatePart(part, false)) {, +  private static final CharMatcher DASH_MATCHER = CharMatcher.anyOf("-_");, +, +  private static final CharMatcher PART_CHAR_MATCHER =, +      CharMatcher.JAVA_LETTER_OR_DIGIT.or(DASH_MATCHER);, +, +   * @param isFinalPart Is this the final (rightmost) domain part?, +  private static boolean validatePart(String part, boolean isFinalPart) {, +, +    // These tests could be collapsed into one big boolean expression, but, +    // they have been left as independent tests for clarity., +, +    if (part.length() < 1 || part.length() > MAX_DOMAIN_PART_LENGTH) {, +      return false;, +    }, +, +    // GWT claims to support java.lang.Character's char-classification, +    // methods, but it actually only works for ASCII. So for now,, +    // assume anything with non-ASCII characters is valid., +    // The only place this seems to be documented is here:, +    // http://osdir.com/ml/GoogleWebToolkitContributors/2010-03/msg00178.html, +, +    if (!CharMatcher.ASCII.matchesAllOf(part)) {, +      return true;, +    }, +, +    if (!PART_CHAR_MATCHER.matchesAllOf(part)) {, +      return false;, +    }, +, +    if (DASH_MATCHER.matches(part.charAt(0)), +        || DASH_MATCHER.matches(part.charAt(part.length() - 1))) {, +      return false;, +    }, +, +    if (isFinalPart && CharMatcher.DIGIT.matches(part.charAt(0))) {, +      return false;, +    }, +, +    return true;]