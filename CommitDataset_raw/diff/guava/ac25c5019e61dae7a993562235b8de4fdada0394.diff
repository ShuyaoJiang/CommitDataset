[+++ b/guava-tests/test/com/google/common/util/concurrent/GeneratedMonitorTest.java, +/*, + * Copyright (C) 2014 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;, +, +import com.google.common.base.CaseFormat;, +import com.google.common.collect.ImmutableList;, +import com.google.common.primitives.Ints;, +import junit.framework.TestCase;, +import junit.framework.TestSuite;, +, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +import java.util.Arrays;, +import java.util.Comparator;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.FutureTask;, +import java.util.concurrent.TimeUnit;, +, +/**, + * Generated tests for {@link Monitor}., + *, + * <p>This test class generates all of its own test cases in the {@link #suite()} method. Every, + * {@code enterXxx}, {@code tryEnterXxx}, and {@code waitForXxx} method of the {@code Monitor} class, + * is analyzed reflectively to determine appropriate test cases based on its signature. Additional, + * ad hoc test cases can be found in {@link SupplementalMonitorTest}., + *, + * @author Justin T. Sampson, + */, +, +public class GeneratedMonitorTest extends TestCase {, +, +  public static TestSuite suite() {, +    TestSuite suite = new TestSuite();, +, +    Method[] methods = Monitor.class.getMethods();, +    sortMethods(methods);, +    for (Method method : methods) {, +      if (isAnyEnter(method) || isWaitFor(method)) {, +        validateMethod(method);, +        addTests(suite, method);, +      }, +    }, +, +    assertEquals(548, suite.testCount());, +, +    return suite;, +  }, +, +  /**, +   * A typical timeout value we'll use in the tests., +   */, +  private static final long SMALL_TIMEOUT_MILLIS = 10;, +, +  /**, +   * How long to wait when determining that a thread is blocked if we expect it to be blocked., +   */, +  private static final long EXPECTED_HANG_DELAY_MILLIS = 75;, +, +  /**, +   * How long to wait when determining that a thread is blocked if we DON'T expect it to be blocked., +   */, +  private static final long UNEXPECTED_HANG_DELAY_MILLIS = 10000;, +, +  /**, +   * Various scenarios to be generated for each method under test. The actual scenario generation, +   * (determining which scenarios are applicable to which methods and what the outcome should be), +   * takes place in {@link #addTests(TestSuite, Method)}., +   */, +  private enum Scenario {, +, +    SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,, +    UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING,, +    SATISFIED_AND_OCCUPIED_BEFORE_ENTERING,, +    SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING,, +, +    SATISFIED_BEFORE_WAITING,, +    SATISFIED_WHILE_WAITING,, +    SATISFIED_AND_INTERRUPTED_BEFORE_WAITING,, +    UNSATISFIED_BEFORE_AND_WHILE_WAITING,, +    UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING;, +, +    @Override, +    public String toString() {]