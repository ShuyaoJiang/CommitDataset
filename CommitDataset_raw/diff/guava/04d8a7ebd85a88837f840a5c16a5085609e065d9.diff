[+++ b/android/guava/src/com/google/common/util/concurrent/InterruptibleTask.java, +    /*, +     * Set runner thread before checking isDone(). If we were to check isDone() first, the task, +     * might be cancelled before we set the runner thread. That would make it impossible to, +     * interrupt, yet it will still run, since interruptTask will leave the runner value null,, +     * allowing the CAS below to succeed., +     */, +    boolean run = !isDone();, +      if (run) {, +      }, +        /*, +         * TODO(cpovirk): Clear interrupt status here? We currently don't, which means that an, +         * interrupt before, during, or after runInterruptibly() (unless it produced an, +         * InterruptedException caught above) can linger and affect listeners., +         */, +      if (run) {, +  }, +    // Since the Thread is replaced by DONE before run() invokes listeners or returns, if we succeed, +    // in this CAS, there's no risk of interrupting the wrong thread or interrupting a thread that, +    // isn't currently executing this task., +++ b/android/guava/src/com/google/common/util/concurrent/InterruptibleTask.java, +    /*, +     * Set runner thread before checking isDone(). If we were to check isDone() first, the task, +     * might be cancelled before we set the runner thread. That would make it impossible to, +     * interrupt, yet it will still run, since interruptTask will leave the runner value null,, +     * allowing the CAS below to succeed., +     */, +    boolean run = !isDone();, +      if (run) {, +      }, +        /*, +         * TODO(cpovirk): Clear interrupt status here? We currently don't, which means that an, +         * interrupt before, during, or after runInterruptibly() (unless it produced an, +         * InterruptedException caught above) can linger and affect listeners., +         */, +      if (run) {, +  }, +    // Since the Thread is replaced by DONE before run() invokes listeners or returns, if we succeed, +    // in this CAS, there's no risk of interrupting the wrong thread or interrupting a thread that, +    // isn't currently executing this task., +++ b/guava/src/com/google/common/util/concurrent/InterruptibleTask.java, +    /*, +     * Set runner thread before checking isDone(). If we were to check isDone() first, the task, +     * might be cancelled before we set the runner thread. That would make it impossible to, +     * interrupt, yet it will still run, since interruptTask will leave the runner value null,, +     * allowing the CAS below to succeed., +     */, +    boolean run = !isDone();, +      if (run) {, +      }, +        /*, +         * TODO(cpovirk): Clear interrupt status here? We currently don't, which means that an, +         * interrupt before, during, or after runInterruptibly() (unless it produced an, +         * InterruptedException caught above) can linger and affect listeners., +         */, +      if (run) {, +  }, +    // Since the Thread is replaced by DONE before run() invokes listeners or returns, if we succeed, +    // in this CAS, there's no risk of interrupting the wrong thread or interrupting a thread that, +    // isn't currently executing this task.]