[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +import com.google.common.util.concurrent.Service.State;, +, +      schedule.schedule(null, new ScheduledThreadPoolExecutor(1) {, +      schedule.schedule(null, new ScheduledThreadPoolExecutor(10) {, +    private class TestCustomScheduler extends AbstractScheduledService.CustomScheduler {, +      public AtomicInteger scheduleCounter = new AtomicInteger(0);, +      @Override, +      protected Schedule getNextSchedule() throws Exception {, +        scheduleCounter.incrementAndGet();, +        return new Schedule(0, TimeUnit.SECONDS);, +      }, +    }, +, +      Future<?> future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);, +            protected Schedule getNextSchedule() throws Exception {, +              return new Schedule(0, TimeUnit.SECONDS);, +          protected Schedule getNextSchedule() throws Exception {, +            return new Schedule(delay, unit);, +          }};, +      }, +    }, +, +    public void testCustomSchedulerFailure() throws Exception {, +      TestFailingCustomScheduledService service = new TestFailingCustomScheduledService();, +      service.startAndWait();, +      for (int i = 1; i < 4; i++) {, +        service.firstBarrier.await();, +        assertEquals(i, service.numIterations.get());, +        service.secondBarrier.await();, +      }, +      Thread.sleep(1000);, +      try {, +        service.stop().get(100, TimeUnit.SECONDS);, +        fail();, +      } catch (ExecutionException e) {, +        assertEquals(State.FAILED, service.state());, +      }, +    }, +, +    private static class TestFailingCustomScheduledService extends AbstractScheduledService {, +      final AtomicInteger numIterations = new AtomicInteger(0);, +      final CyclicBarrier firstBarrier = new CyclicBarrier(2);, +      final CyclicBarrier secondBarrier = new CyclicBarrier(2);, +, +      @Override protected void runOneIteration() throws Exception {, +        numIterations.incrementAndGet();, +        firstBarrier.await();, +        secondBarrier.await();, +      }, +, +      @Override protected ScheduledExecutorService executor() {, +        // use a bunch of threads so that weird overlapping schedules are more likely to happen., +        return Executors.newScheduledThreadPool(10);, +      }, +, +      @Override protected void startUp() throws Exception { }, +, +      @Override protected void shutDown() throws Exception { }, +, +      @Override protected Scheduler scheduler() {, +        return new CustomScheduler() {, +          @Override, +          protected Schedule getNextSchedule() throws Exception {, +            if (numIterations.get() > 2) {, +              throw new IllegalStateException("Failed");, +            }, +            return new Schedule(delay, unit);, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java, +import com.google.common.util.concurrent.Service.State;, +, +      schedule.schedule(null, new ScheduledThreadPoolExecutor(1) {, +      schedule.schedule(null, new ScheduledThreadPoolExecutor(10) {, +    private class TestCustomScheduler extends AbstractScheduledService.CustomScheduler {, +      public AtomicInteger scheduleCounter = new AtomicInteger(0);, +      @Override, +      protected Schedule getNextSchedule() throws Exception {, +        scheduleCounter.incrementAndGet();, +        return new Schedule(0, TimeUnit.SECONDS);, +      }, +    }, +, +      Future<?> future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);, +            protected Schedule getNextSchedule() throws Exception {, +              return new Schedule(0, TimeUnit.SECONDS);, +          protected Schedule getNextSchedule() throws Exception {, +            return new Schedule(delay, unit);, +          }};, +      }, +    }, +, +    public void testCustomSchedulerFailure() throws Exception {, +      TestFailingCustomScheduledService service = new TestFailingCustomScheduledService();, +      service.startAndWait();, +      for (int i = 1; i < 4; i++) {, +        service.firstBarrier.await();, +        assertEquals(i, service.numIterations.get());, +        service.secondBarrier.await();, +      }, +      Thread.sleep(1000);]