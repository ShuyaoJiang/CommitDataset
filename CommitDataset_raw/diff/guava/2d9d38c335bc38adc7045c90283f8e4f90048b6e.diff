[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeTraverser.java, +import com.google.common.base.Function;, + * <p>For example, the tree, + * <pre>{@code, + *, + * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a, + * lambda expression to extend it:, + *, + * <pre>{@code, + * // won't work, + * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();, + * }</pre>, + *, + * Instead, you can pass a lambda expression to the {@code using} factory method:, + *, + * <pre>{@code, + * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());, + * }</pre>, + *, +  /**, +   * Returns a tree traverser that uses the given function to navigate from a node to its children., +   * This is useful if the function instance already exists, or so that you can supply a lambda, +   * expressions. If those circumstances don't apply, you probably don't need to use this; subclass, +   * {@code TreeTraverser} and implement its {@link #children} method directly., +   *, +   * @since 20.0, +   */, +  public static <T> TreeTraverser<T> using(, +      final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {, +    checkNotNull(nodeToChildrenFunction);, +    return new TreeTraverser<T>() {, +      @Override, +      public Iterable<T> children(T root) {, +        return nodeToChildrenFunction.apply(root);, +      }, +    };, +  }, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeTraverser.java, +import com.google.common.base.Function;, + * <p>For example, the tree, + * <pre>{@code, + *, + * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a, + * lambda expression to extend it:, + *, + * <pre>{@code, + * // won't work, + * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();, + * }</pre>, + *, + * Instead, you can pass a lambda expression to the {@code using} factory method:, + *, + * <pre>{@code, + * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());, + * }</pre>, + *, +  /**, +   * Returns a tree traverser that uses the given function to navigate from a node to its children., +   * This is useful if the function instance already exists, or so that you can supply a lambda, +   * expressions. If those circumstances don't apply, you probably don't need to use this; subclass, +   * {@code TreeTraverser} and implement its {@link #children} method directly., +   *, +   * @since 20.0, +   */, +  public static <T> TreeTraverser<T> using(, +      final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {, +    checkNotNull(nodeToChildrenFunction);, +    return new TreeTraverser<T>() {, +      @Override, +      public Iterable<T> children(T root) {, +        return nodeToChildrenFunction.apply(root);, +      }, +    };, +  }, +++ b/guava-gwt/test/com/google/common/collect/TreeTraverserTest_gwt.java, +, +public void testUsing() throws Exception {, +  com.google.common.collect.TreeTraverserTest testCase = new com.google.common.collect.TreeTraverserTest();, +  testCase.testUsing();, +}, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeTraverser.java, +import com.google.common.base.Function;, + * <p>For example, the tree, + * <pre>{@code, + *, + * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a, + * lambda expression to extend it:, + *, + * <pre>{@code, + * // won't work, + * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();, + * }</pre>, + *, + * Instead, you can pass a lambda expression to the {@code using} factory method:, + *, + * <pre>{@code, + * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());, + * }</pre>, + *, +  /**]