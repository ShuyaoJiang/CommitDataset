[+++ b/guava-tests/benchmark/com/google/common/util/concurrent/ExecutionListBenchmark.java, +/*, + * Copyright (C) 2013 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.common.util.concurrent;, +, +import com.google.caliper.Benchmark;, +import com.google.caliper.Param;, +import com.google.caliper.api.Footprint;, +import com.google.caliper.api.VmOptions;, +import com.google.caliper.runner.CaliperMain;, +import com.google.common.base.Preconditions;, +import com.google.common.collect.Lists;, +, +import java.util.Queue;, +import java.util.concurrent.ArrayBlockingQueue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executor;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.ThreadPoolExecutor;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +, +import javax.annotation.Nullable;, +import javax.annotation.concurrent.GuardedBy;, +, +/**, + * Benchmarks for {@link ExecutionList}., + */, +@VmOptions({"-Xms3g", "-Xmx3g"}), +public class ExecutionListBenchmark extends Benchmark {, +  private static final int NUM_THREADS = 10;  // make a param?, +, +  // We execute the listeners on the sameThreadExecutor because we don't really care about what the, +  // listeners are doing, and they aren't doing much., +  private static final Executor SAME_THREAD_EXECUTOR = MoreExecutors.sameThreadExecutor();, +, +  // simple interface to wrap our two implementations., +  interface ExecutionListWrapper {, +    void add(Runnable runnable, Executor executor);, +    void execute();, +    /** Returns the underlying implementation, useful for the Footprint benchmark. */, +    Object getImpl();, +  }, +, +  enum Impl {, +    NEW {, +      @Override ExecutionListWrapper newExecutionList() {, +        return new ExecutionListWrapper() {, +          final ExecutionList list = new ExecutionList();, +          @Override public void add(Runnable runnable, Executor executor) {, +            list.add(runnable, executor);, +          }, +, +          @Override public void execute() {, +            list.execute();, +          }, +, +          @Override public Object getImpl() {, +            return list;, +          }, +        };, +      }, +    },, +    NEW_WITH_CAS {, +      @Override ExecutionListWrapper newExecutionList() {, +        return new ExecutionListWrapper() {, +          final ExecutionListCAS list = new ExecutionListCAS();, +          @Override public void add(Runnable runnable, Executor executor) {, +            list.add(runnable, executor);, +          }, +, +          @Override public void execute() {, +            list.execute();, +          }, +, +          @Override public Object getImpl() {, +            return list;, +          }, +        };, +      }, +    },, +    NEW_WITH_QUEUE {, +      @Override ExecutionListWrapper newExecutionList() {, +        return new ExecutionListWrapper() {]