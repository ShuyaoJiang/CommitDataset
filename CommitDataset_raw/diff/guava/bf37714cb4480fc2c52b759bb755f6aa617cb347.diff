[+++ b/guava/src/com/google/common/reflect/TypeResolver.java, +        /*, +         * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's, +         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't, +         * recognize instances of our TypeVariable implementation. This is a problem because users, +         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To, +         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable, +         * implementation in each of the three possible cases:, +         *, +         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours., +         * Therefore, we can always create our own TypeVariable., +         *, +         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate, +         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:, +         *, +         * 2a. If the resolved types are identical to the original types, then we can return the, +         * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely., +         *, +         * 2b. If the resolved types are different from the original types, things are trickier. The, +         * only way to get a TypeVariable instance for the resolved types is to create our own. The, +         * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We, +         * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has, +         * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new, +         * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK, +         * TypeVariable must have a different declaration or name. The only TypeVariable that our, +         * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created, +         * by us. And that equality is guaranteed to hold because it doesn't involve the JDK, +         * TypeVariable implementation at all., +         */, +      if (t instanceof TypeVariable) {, +        return null;, +      if (type instanceof TypeVariable) {, +++ b/guava/src/com/google/common/reflect/TypeResolver.java, +        /*, +         * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's, +         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't, +         * recognize instances of our TypeVariable implementation. This is a problem because users, +         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To, +         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable, +         * implementation in each of the three possible cases:, +         *, +         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours., +         * Therefore, we can always create our own TypeVariable., +         *, +         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate, +         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:, +         *, +         * 2a. If the resolved types are identical to the original types, then we can return the, +         * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely., +         *, +         * 2b. If the resolved types are different from the original types, things are trickier. The, +         * only way to get a TypeVariable instance for the resolved types is to create our own. The, +         * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We, +         * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has, +         * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new, +         * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK, +         * TypeVariable must have a different declaration or name. The only TypeVariable that our, +         * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created, +         * by us. And that equality is guaranteed to hold because it doesn't involve the JDK, +         * TypeVariable implementation at all., +         */, +      if (t instanceof TypeVariable) {, +        return null;, +      if (type instanceof TypeVariable) {, +++ b/guava/src/com/google/common/reflect/Types.java, +        // equal only to our TypeVariable implementation with identical bounds, +        // equal to any TypeVariable implementation regardless of bounds, +   * Moreover, we don't want to reconstruct a native type variable <A> using our implementation, +   * unless some of its bounds have changed in resolution. This avoids creating unequal TypeVariable, +   * implementation unnecessarily. When the bounds do change, however, it's fine for the synthetic, +  static final class NativeTypeVariableEquals<X> {]