[+++ b/guava/src/com/google/common/collect/SortedLists.java, +import com.google.common.annotations.Beta;, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.base.Function;, +, +import java.util.RandomAccess;, +@GwtCompatible, +@Beta final class SortedLists {, +  @Beta, +  public enum Relation {, +      @Override, +      public Relation reverse() {, +      @Override, +      public Relation reverse() {, +          int middle = (lower + upper) >>> 1;, +      @Override, +      public Relation reverse() {, +      @Override, +      public Relation reverse() {, +          int middle = (lower + upper + 1) >>> 1;, +     * <p>In the {@link SortedLists#binarySearch binarySearch} methods, {@code, +     * if there is no element in the list greater than a given value, {@code, +     * list.size()} is returned as the index of the higher element. For example:, +     * <pre> {@code, +      @Override, +      public Relation reverse() {, +    public abstract Relation reverse();, +   * Searches the specified naturally ordered list for the specified object using the binary, +   * search algorithm., +   *, +   * <p>Equivalent to {@link #binarySearch(List, Object, Comparator, Relation) binarySearch}{@code, +   * (list, key, Ordering.natural(), relation)}., +   */, +  public static <E extends Comparable> int binarySearch(, +      List<? extends E> list, E e, Relation relation) {, +    checkNotNull(e);, +    return binarySearch(list, checkNotNull(e), Ordering.natural(), relation);, +  }, +, +  /**, +   * Binary searches the list for the specified key, using the specified key function., +   *, +   * <p>Equivalent to {@link #binarySearch(List, Function, Object, Comparator, Relation), +   * binarySearch} {@code (list, keyFunction, key, Ordering.natural(), relation)}., +   */, +  public static <E, K extends Comparable> int binarySearch(List<E> list,, +      Function<? super E, K> keyFunction, K key, Relation relation) {, +    return binarySearch(list, keyFunction, key, Ordering.natural(), relation);, +  }, +, +  /**, +   * Binary searches the list for the specified key, using the specified key function., +   *, +   * <p>Equivalent to {@link #binarySearch(List, Object, Comparator, Relation) binarySearch}, +   * {@code (Lists.transform(list, keyFunction), key, keyComparator, relation)}., +   */, +  public static <E, K> int binarySearch(List<E> list, Function<? super E, K> keyFunction, K key,, +      Comparator<? super K> keyComparator, Relation relation) {, +    return binarySearch(Lists.transform(list, keyFunction), key, keyComparator, relation);, +  }, +, +  /**, +   * <p>This method runs in log(n) time on random-access lists, which offer, +   * near-constant-time access to each list element., +  public static <E> int binarySearch(, +      List<? extends E> list, @Nullable E e, Comparator<? super E> comparator, Relation relation) {, +      Comparator<? super E> comparator, Relation relation, boolean worryAboutDuplicates) {, +    checkNotNull(list);, +    if (!(list instanceof RandomAccess)) {, +      list = Lists.newArrayList(list);, +    }, +    // TODO(user): benchmark when it's best to do a linear search, +      int middle = (lower + upper) >>> 1;]