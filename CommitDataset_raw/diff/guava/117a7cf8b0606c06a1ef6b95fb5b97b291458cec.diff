[+++ b/guava/src/com/google/common/cache/CacheBuilder.java, + * @param <K> the base key type for all caches created by this builder, + * @param <V> the base value type for all caches created by this builder, +public final class CacheBuilder<K, V> {, +  RemovalListener<K, V> removalListener;, +  CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence) {, +  CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence) {, +  public CacheBuilder<K, V> initialCapacity(int initialCapacity) {, +  public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {, +  public CacheBuilder<K, V> maximumSize(int size) {, +  CacheBuilder<K, V> strongKeys() {, +  public CacheBuilder<K, V> weakKeys() {, +  public CacheBuilder<K, V> softKeys() {, +  CacheBuilder<K, V> setKeyStrength(Strength strength) {, +  CacheBuilder<K, V> strongValues() {, +  public CacheBuilder<K, V> weakValues() {, +  public CacheBuilder<K, V> softValues() {, +  CacheBuilder<K, V> setValueStrength(Strength strength) {, +  public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {, +  public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {, +  public CacheBuilder<K, V> ticker(Ticker ticker) {, +   * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the, +  public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(, +      RemovalListener<K1, V1> listener) {, +    CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;, +  <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener() {, +    return (RemovalListener<K1, V1>) Objects.firstNonNull(removalListener, NullListener.INSTANCE);, +  <K1 extends K, V1 extends V> CustomConcurrentHashMap<K1, V1> makeCustomMap() {, +    return new CustomConcurrentHashMap<K1, V1>(this, DEFAULT_STATS_COUNTER);, +  <K1 extends K, V1 extends V> ConcurrentMap<K1, V1> makeComputingMap(, +      CacheLoader<? super K1, ? extends V1> loader) {, +        ? new ComputingConcurrentHashMap<K1, V1>(this, DEFAULT_STATS_COUNTER, loader), +        : new NullComputingConcurrentMap<K1, V1>(this, loader);, +  public <K1 extends K, V1 extends V> Cache<K1, V1> build(CacheLoader<? super K1, V1> loader) {, +        ? new ComputingCache<K1, V1>(this, CACHE_STATS_COUNTER, loader), +        : new NullCache<K1, V1>(this, CACHE_STATS_COUNTER, loader);]