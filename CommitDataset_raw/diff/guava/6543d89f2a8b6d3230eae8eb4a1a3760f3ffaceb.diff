[+++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import java.util.concurrent.RejectedExecutionException;, +  public void testTransform_rejectionPropagatesToOutput(), +      throws Exception {, +    SettableFuture<Foo> input = SettableFuture.create();, +    ExecutorService executor = MoreExecutors.sameThreadExecutor();, +    ListenableFuture<String> transformed =, +        Futures.transform(input, Functions.toStringFunction(), executor);, +    executor.shutdown();, +    input.set(new Foo());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertTrue(expected.getCause() instanceof RejectedExecutionException);, +    }, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java, +import java.util.concurrent.RejectedExecutionException;, +  public void testTransform_rejectionPropagatesToOutput(), +      throws Exception {, +    SettableFuture<Foo> input = SettableFuture.create();, +    ExecutorService executor = MoreExecutors.sameThreadExecutor();, +    ListenableFuture<String> transformed =, +        Futures.transform(input, Functions.toStringFunction(), executor);, +    executor.shutdown();, +    input.set(new Foo());, +    try {, +      transformed.get(5, TimeUnit.SECONDS);, +      fail();, +    } catch (ExecutionException expected) {, +      assertTrue(expected.getCause() instanceof RejectedExecutionException);, +    }, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/Futures.java, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.atomic.AtomicBoolean;, +  /**, +   * A 'same thread executor' that isn't an executor service and therefore cannot reject tasks., +   *, +   * <p>Also, since it is a shared instance it should be generally cheaper and faster than, +   * {@link MoreExecutors#sameThreadExecutor}., +   *, +   * <p>TODO(user): consider replacing all uses of sameThreadExecutor with this., +   */, +  private static final Executor INLINE_EXECUTOR = new Executor() {, +    @Override public void execute(Runnable runnable) {, +      runnable.run();, +    }, +  };, +, +    ChainingListenableFuture<I, O> output =, +        new ChainingListenableFuture<I, O>(function, input);, +    input.addListener(output, INLINE_EXECUTOR);, +    return output;, +    checkNotNull(executor);, +    input.addListener(rejectionPropagatingRunnable(output, output, executor), INLINE_EXECUTOR);, +   * Returns a Runnable that will invoke the delegate Runnable on the delegate executor, but if the, +   * task is rejected, it will propagate that rejection to the output future., +   */, +  private static Runnable rejectionPropagatingRunnable(, +      final AbstractFuture<?> outputFuture,, +      final Runnable delegateTask,, +      final Executor delegateExecutor) {, +    return new Runnable() {, +      @Override public void run() {, +        final AtomicBoolean thrownFromDelegate = new AtomicBoolean(true);, +        try {, +          delegateExecutor.execute(new Runnable() {, +            @Override public void run() {, +              thrownFromDelegate.set(false);, +              delegateTask.run();, +            }, +          });, +        } catch (RejectedExecutionException e) {, +          if (thrownFromDelegate.get()) {, +            // wrap exception?, +            outputFuture.setException(e);, +          }, +          // otherwise it must have been thrown from a transitive call and the delegate runnable, +          // should have handled it., +        }, +      }, +    };, +  }, +, +  /**, +    checkNotNull(function);, +    ChainingListenableFuture<I, O> output =, +        new ChainingListenableFuture<I, O>(asAsyncFunction(function), input);, +    input.addListener(output, INLINE_EXECUTOR);, +    return output;, +    return transform(input, asAsyncFunction(function), executor);, +  }, +, +  /** Wraps the given function as an AsyncFunction. */, +  private static <I, O> AsyncFunction<I, O> asAsyncFunction(, +      final Function<? super I, ? extends O> function) {]