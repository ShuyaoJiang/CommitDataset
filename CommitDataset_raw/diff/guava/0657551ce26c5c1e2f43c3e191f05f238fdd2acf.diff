[+++ b/guava-tests/test/com/google/common/math/StatsTesting.java, +  static final double LARGE_INTEGER_VALUES_MEAN =, +      BigInteger.valueOf(Integer.MAX_VALUE), +          .multiply(BigInteger.valueOf(3L)), +          .divide(BigInteger.valueOf(4L)), +          .doubleValue();, +      BigInteger.valueOf(Integer.MAX_VALUE), +          .multiply(BigInteger.valueOf(Integer.MAX_VALUE)), +          .divide(BigInteger.valueOf(16L)), +          .doubleValue();, +  static final double LARGE_LONG_VALUES_MEAN =, +      BigInteger.valueOf(Long.MAX_VALUE), +          .multiply(BigInteger.valueOf(3L)), +          .divide(BigInteger.valueOf(4L)), +          .doubleValue();, +      BigInteger.valueOf(Long.MAX_VALUE), +          .multiply(BigInteger.valueOf(Long.MAX_VALUE)), +          .divide(BigInteger.valueOf(16L)), +          .doubleValue();, +  static final List<Stats> ALL_STATS =, +      ImmutableList.of(, +  static final List<PairedStats> ALL_PAIRED_STATS =, +      ImmutableList.of(, +  static void assertStatsApproxEqual(Stats expectedStats, Stats actualStats) {, +   * assertions about all the public instance methods of {@link LinearTransformation} (on both, +   * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,, +   * neither {@code xDelta} nor {@code yDelta} may be zero., +    assertThat(transformation.inverse().isHorizontal()).isFalse();, +    assertThat(transformation.inverse().isVertical()).isFalse();, +    assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);, +    assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);, +    assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);, +    assertThat(transformation.inverse().transform(y1 + yDelta)), +        .isWithin(ALLOWED_ERROR), +        .of(x1 + xDelta);, +    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);, +    assertThat(transformation.inverse()).isSameAs(transformation.inverse());, +    assertThat(transformation.inverse().inverse()).isSameAs(transformation);, +   * assertion that {@link LinearTransformation#transform} and {@link LinearTransformation#slope}, +   * on its inverse throws as expected., +    assertThat(transformation.inverse().isHorizontal()).isFalse();, +    assertThat(transformation.inverse().isVertical()).isTrue();, +    assertThat(transformation.transform(-1.0)).isWithin(ALLOWED_ERROR).of(y);, +    assertThat(transformation.transform(1.0)).isWithin(ALLOWED_ERROR).of(y);, +      transformation.inverse().transform(0.0);, +    try {, +      transformation.inverse().slope();, +      fail("Expected IllegalStateException");, +    } catch (IllegalStateException expected) {, +    }, +    assertThat(transformation.inverse()).isSameAs(transformation.inverse());, +    assertThat(transformation.inverse().inverse()).isSameAs(transformation);, +   * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transform}, +    assertThat(transformation.inverse().isHorizontal()).isTrue();, +    assertThat(transformation.inverse().isVertical()).isFalse();, +      transformation.transform(0.0);, +    assertThat(transformation.inverse().transform(-1.0)).isWithin(ALLOWED_ERROR).of(x);, +    assertThat(transformation.inverse().transform(1.0)).isWithin(ALLOWED_ERROR).of(x);, +    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(0.0);, +    assertThat(transformation.inverse()).isSameAs(transformation.inverse());, +    assertThat(transformation.inverse().inverse()).isSameAs(transformation);, +    assertThat(transformation.transform(0.0)).isNaN();, +    assertThat(transformation.inverse()).isSameAs(transformation);, +  private StatsTesting() {}, +++ b/guava-tests/test/com/google/common/math/StatsTesting.java, +  static final double LARGE_INTEGER_VALUES_MEAN =, +      BigInteger.valueOf(Integer.MAX_VALUE), +          .multiply(BigInteger.valueOf(3L)), +          .divide(BigInteger.valueOf(4L)), +          .doubleValue();, +      BigInteger.valueOf(Integer.MAX_VALUE), +          .multiply(BigInteger.valueOf(Integer.MAX_VALUE)), +          .divide(BigInteger.valueOf(16L)), +          .doubleValue();, +  static final double LARGE_LONG_VALUES_MEAN =, +      BigInteger.valueOf(Long.MAX_VALUE), +          .multiply(BigInteger.valueOf(3L)), +          .divide(BigInteger.valueOf(4L)), +          .doubleValue();, +      BigInteger.valueOf(Long.MAX_VALUE), +          .multiply(BigInteger.valueOf(Long.MAX_VALUE)), +          .divide(BigInteger.valueOf(16L)), +          .doubleValue();, +  static final List<Stats> ALL_STATS =, +      ImmutableList.of(, +  static final List<PairedStats> ALL_PAIRED_STATS =, +      ImmutableList.of(, +  static void assertStatsApproxEqual(Stats expectedStats, Stats actualStats) {, +   * assertions about all the public instance methods of {@link LinearTransformation} (on both, +   * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,, +   * neither {@code xDelta} nor {@code yDelta} may be zero., +    assertThat(transformation.inverse().isHorizontal()).isFalse();, +    assertThat(transformation.inverse().isVertical()).isFalse();, +    assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);, +    assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);, +    assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);, +    assertThat(transformation.inverse().transform(y1 + yDelta)), +        .isWithin(ALLOWED_ERROR), +        .of(x1 + xDelta);, +    assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);]