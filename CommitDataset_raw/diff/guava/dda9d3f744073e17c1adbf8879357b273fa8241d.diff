[+++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          preWriteCleanup();, +        segment.preWriteCleanup();, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          preWriteCleanup();, +        segment.preWriteCleanup();, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +   * <p>This must be a (2^n)-1 as it is used as a mask., +  static final int DRAIN_THRESHOLD = 0x3F;, +  boolean isInlineCleanup() {, +    return cleanupExecutor == MapMaker.DEFAULT_CLEANUP_EXECUTOR;, +  }, +, +   * blocks that call preWriteCleanup() directly, which can simply assume that, +    /**, +     * Performs routine cleanup prior to executing a write. This should be, +     * called every time a write thread acquires the segment lock, immediately, +     * after acquiring the lock., +     */, +    @GuardedBy("Segment.this"), +    void preWriteCleanup() {, +      expireEntries();, +      // perform inline cleanup while under lock, +      scheduleCleanup();, +    }, +, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +    void scheduleCleanup() {, +      if (isInlineCleanup()) {, +        if (isHeldByCurrentThread()) {, +          runUnlockedCleanup();, +        } else {, +          runLockedCleanup();, +        }, +      } else if (!isHeldByCurrentThread()) {, +        cleanupExecutor.execute(cleanupRunnable);, +      }, +    }, +, +            runUnlockedCleanup();, +            runLockedCleanup();, +    /**, +     * Performs housekeeping tasks on this segment that don't require the, +     * segment lock., +     */, +    void runUnlockedCleanup() {, +      processPendingNotifications();, +     * Performs housekeeping tasks on this segment that require the segment, +     * lock., +    void runLockedCleanup() {, +      lock();, +++ b/src/com/google/common/collect/ComputingConcurrentHashMap.java, +          preWriteCleanup();, +        segment.preWriteCleanup();, +++ b/src/com/google/common/collect/CustomConcurrentHashMap.java, +   * <p>This must be a (2^n)-1 as it is used as a mask., +  static final int DRAIN_THRESHOLD = 0x3F;, +  boolean isInlineCleanup() {, +    return cleanupExecutor == MapMaker.DEFAULT_CLEANUP_EXECUTOR;, +  }, +, +   * blocks that call preWriteCleanup() directly, which can simply assume that, +    /**, +     * Performs routine cleanup prior to executing a write. This should be, +     * called every time a write thread acquires the segment lock, immediately, +     * after acquiring the lock., +     */, +    @GuardedBy("Segment.this"), +    void preWriteCleanup() {, +      expireEntries();, +      // perform inline cleanup while under lock, +      scheduleCleanup();, +    }, +, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +        preWriteCleanup();, +    void scheduleCleanup() {, +      if (isInlineCleanup()) {, +        if (isHeldByCurrentThread()) {, +          runUnlockedCleanup();, +        } else {, +          runLockedCleanup();, +        }, +      } else if (!isHeldByCurrentThread()) {, +        cleanupExecutor.execute(cleanupRunnable);, +      }, +    }, +, +            runUnlockedCleanup();, +            runLockedCleanup();, +    /**, +     * Performs housekeeping tasks on this segment that don't require the, +     * segment lock.]