[+++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.atomic.AtomicReference;, +, +  public void testCompletionFinishesWithDone() {, +    ExecutorService executor = Executors.newFixedThreadPool(10);, +    for (int i = 0; i < 50000; i++) {, +      final AbstractFuture<String> future = new AbstractFuture<String>() {};, +      final AtomicReference<String> errorMessage = new AtomicReference<String>();, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.set("success");, +          if (!future.isDone()) {, +            errorMessage.set("Set call exited before future was complete.");, +          }, +        }, +      });, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.setException(new IllegalArgumentException("failure"));, +          if (!future.isDone()) {, +            errorMessage.set("SetException call exited before future was complete.");, +          }, +        }, +      });, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.cancel(true);, +          if (!future.isDone()) {, +            errorMessage.set("Cancel call exited before future was complete.");, +          }, +        }, +      });, +      try {, +        future.get();, +      } catch (Throwable t) {, +        // Ignore, we just wanted to block., +      }, +      String error = errorMessage.get();, +      assertNull(error, error);, +    }, +    executor.shutdown();, +  }, +, +++ b/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.atomic.AtomicReference;, +, +  public void testCompletionFinishesWithDone() {, +    ExecutorService executor = Executors.newFixedThreadPool(10);, +    for (int i = 0; i < 50000; i++) {, +      final AbstractFuture<String> future = new AbstractFuture<String>() {};, +      final AtomicReference<String> errorMessage = new AtomicReference<String>();, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.set("success");, +          if (!future.isDone()) {, +            errorMessage.set("Set call exited before future was complete.");, +          }, +        }, +      });, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.setException(new IllegalArgumentException("failure"));, +          if (!future.isDone()) {, +            errorMessage.set("SetException call exited before future was complete.");, +          }, +        }, +      });, +      executor.execute(new Runnable() {, +        @Override, +        public void run() {, +          future.cancel(true);, +          if (!future.isDone()) {, +            errorMessage.set("Cancel call exited before future was complete.");, +          }, +        }, +      });, +      try {, +        future.get();, +      } catch (Throwable t) {, +        // Ignore, we just wanted to block., +      }, +      String error = errorMessage.get();, +      assertNull(error, error);, +    }, +    executor.shutdown();, +  }, +, +++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java, +     * return {@code false} after waiting for the state to be set to a valid, +     * final state ({@link #COMPLETED} or {@link #CANCELLED})., +    private boolean complete(@Nullable V v, @Nullable Throwable t,]