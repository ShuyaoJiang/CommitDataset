[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +   * a row in the hash table for a Set<V> associated with a key, the linked list, +  static final class ValueEntry<K, V> extends AbstractMapEntry<K, V>, +    final K key;, +    final V value;, +    final int valueHash;, +    @Nullable ValueEntry<K, V> nextInValueSetHashRow;, +    ValueEntry(@Nullable K key, @Nullable V value, int valueHash,, +        @Nullable ValueEntry<K, V> nextInValueSetHashRow) {, +      this.key = key;, +      this.value = value;, +      this.valueHash = valueHash;, +      this.nextInValueSetHashRow = nextInValueSetHashRow;, +    @Override, +    public K getKey() {, +      return key;, +    }, +, +    @Override, +    public V getValue() {, +      return value;, +          Object o = toRemove.getValue();, +          int hash = (o == null) ? 0 : o.hashCode();, +          int row = Hashing.smear(hash) & (hashTable.length - 1);, +          ValueEntry<K, V> prev = null;, +          for (ValueEntry<K, V> entry = hashTable[row]; entry != null;, +               prev = entry, entry = entry.nextInValueSetHashRow) {, +            if (entry == toRemove) {, +              if (prev == null) {, +                // first entry in row, +                hashTable[row] = entry.nextInValueSetHashRow;, +              } else {, +                prev.nextInValueSetHashRow = entry.nextInValueSetHashRow;, +              }, +              deleteFromValueSet(toRemove);, +              deleteFromMultimap(toRemove);, +              size--;, +              expectedModCount = ++modCount;, +              break;, +            }, +          }, +      int hash = (o == null) ? 0 : o.hashCode();, +      int row = Hashing.smear(hash) & (hashTable.length - 1);, +, +      for (ValueEntry<K, V> entry = hashTable[row]; entry != null;, +          entry = entry.nextInValueSetHashRow) {, +        if (hash == entry.valueHash && Objects.equal(o, entry.getValue())) {, +      int hash = (value == null) ? 0 : value.hashCode();, +      int row = Hashing.smear(hash) & (hashTable.length - 1);, +, +      ValueEntry<K, V> rowHead = hashTable[row];, +          entry = entry.nextInValueSetHashRow) {, +        if (hash == entry.valueHash && Objects.equal(value, entry.getValue())) {, +      ValueEntry<K, V> newEntry = new ValueEntry<K, V>(key, value, hash, rowHead);, +      hashTable[row] = newEntry;, +          int row = Hashing.smear(valueEntry.valueHash) & mask;, +          valueEntry.nextInValueSetHashRow = hashTable[row];, +          hashTable[row] = valueEntry;, +      int hash = (o == null) ? 0 : o.hashCode();, +      int row = Hashing.smear(hash) & (hashTable.length - 1);, +, +      for (ValueEntry<K, V> entry = hashTable[row]; entry != null;, +           prev = entry, entry = entry.nextInValueSetHashRow) {, +        if (hash == entry.valueHash && Objects.equal(o, entry.getValue())) {, +            // first entry in the row, +            hashTable[row] = entry.nextInValueSetHashRow;, +            prev.nextInValueSetHashRow = entry.nextInValueSetHashRow;, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java, +   * a row in the hash table for a Set<V> associated with a key, the linked list, +  static final class ValueEntry<K, V> extends AbstractMapEntry<K, V>, +    final K key;, +    final V value;, +    final int valueHash;, +    @Nullable ValueEntry<K, V> nextInValueSetHashRow;, +    ValueEntry(@Nullable K key, @Nullable V value, int valueHash,, +        @Nullable ValueEntry<K, V> nextInValueSetHashRow) {, +      this.key = key;, +      this.value = value;, +      this.valueHash = valueHash;, +      this.nextInValueSetHashRow = nextInValueSetHashRow;, +    @Override, +    public K getKey() {, +      return key;, +    }, +, +    @Override, +    public V getValue() {, +      return value;, +          Object o = toRemove.getValue();, +          int hash = (o == null) ? 0 : o.hashCode();, +          int row = Hashing.smear(hash) & (hashTable.length - 1);, +          ValueEntry<K, V> prev = null;, +          for (ValueEntry<K, V> entry = hashTable[row]; entry != null;, +               prev = entry, entry = entry.nextInValueSetHashRow) {, +            if (entry == toRemove) {, +              if (prev == null) {, +                // first entry in row, +                hashTable[row] = entry.nextInValueSetHashRow;, +              } else {, +                prev.nextInValueSetHashRow = entry.nextInValueSetHashRow;]