[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/HashBiMap.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except, + * in compliance with the License. You may obtain a copy of the License at, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., +import static com.google.common.base.Preconditions.checkArgument;, +import static com.google.common.base.Preconditions.checkState;, +, +import com.google.common.annotations.GwtCompatible;, +import com.google.common.base.Objects;, +import com.google.common.primitives.Ints;, +, +import java.io.Serializable;, +import java.util.AbstractMap;, +import java.util.Arrays;, +import java.util.ConcurrentModificationException;, +import java.util.Iterator;, +import java.util.NoSuchElementException;, +import java.util.Set;, + * A {@link BiMap} backed by two hash tables. This implementation allows null keys and values. A, + * {@code HashBiMap} and its inverse are both serializable., + * <p>See the Guava User Guide article on <a href=, + * "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#BiMap"> {@code BiMap}, + * </a>., + *, + * @author Louis Wasserman, + * @since 2.0 (imported from Google Collections Library), +@GwtCompatible(emulated = true), +public final class HashBiMap<K, V> extends AbstractMap<K, V> implements BiMap<K, V>, Serializable {, +   * Returns a new, empty {@code HashBiMap} with the default initial capacity (16)., +    return create(16);, +   * @throws IllegalArgumentException if the specified expected size is negative, +   * Constructs a new bimap containing initial values from {@code map}. The bimap is created with an, +   * initial capacity sufficient to hold the mappings in the specified map., +  public static <K, V> HashBiMap<K, V> create(Map<? extends K, ? extends V> map) {, +  private static final class BiEntry<K, V> {, +    final K key;, +    final int keyHash;, +, +    final V value;, +    final int valueHash;, +, +    @Nullable, +    BiEntry<K, V> nextInKToVBucket;, +, +    @Nullable, +    BiEntry<K, V> nextInVToKBucket;, +, +    BiEntry(K key, int keyHash, V value, int valueHash) {, +      this.key = key;, +      this.keyHash = keyHash;, +      this.value = value;, +      this.valueHash = valueHash;, +  }, +, +  private static final double LOAD_FACTOR = 1.0;, +  private static final int MAX_TABLE_SIZE = Ints.MAX_POWER_OF_TWO;, +, +  private transient BiEntry<K, V>[] hashTableKToV;, +  private transient BiEntry<K, V>[] hashTableVToK;, +  private transient int size;, +  private transient int mask;, +  private transient int modCount;, +    init(expectedSize);, +  private void init(int expectedSize) {, +    checkArgument(expectedSize >= 0, "expectedSize must be >= 0 but was %s", expectedSize);, +    int tableSize = Integer.highestOneBit(Math.max(2, expectedSize) - 1) << 1;, +    if (tableSize < 0) {, +      tableSize = Ints.MAX_POWER_OF_TWO;, +    }, +    this.hashTableKToV = createTable(tableSize);, +    this.hashTableVToK = createTable(tableSize);, +    this.mask = tableSize - 1;, +    this.modCount = 0;, +    this.size = 0;, +  /**, +   * Finds and removes {@code entry} from the bucket linked lists in both the, +   * key-to-value direction and the value-to-key direction., +   */, +  private void delete(BiEntry<K, V> entry) {, +    int keyBucket = entry.keyHash & mask;, +    BiEntry<K, V> prevBucketEntry = null;, +    for (BiEntry<K, V> bucketEntry = hashTableKToV[keyBucket]; true;, +        bucketEntry = bucketEntry.nextInKToVBucket) {, +      if (bucketEntry == entry) {, +        if (prevBucketEntry == null) {, +          hashTableKToV[keyBucket] = entry.nextInKToVBucket;, +        } else {, +          prevBucketEntry.nextInKToVBucket = entry.nextInKToVBucket;, +        }, +        break;, +      }, +      prevBucketEntry = bucketEntry;, +    }, +, +    int valueBucket = entry.valueHash & mask;, +    prevBucketEntry = null;, +    for (BiEntry<K, V> bucketEntry = hashTableVToK[valueBucket];;]