[+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +import static com.google.common.base.Preconditions.checkPositionIndex;, +public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V>, +  private static final class Node<K, V> extends AbstractMapEntry<K, V> {, +    @Override, +    public K getKey() {, +      return key;, +    }, +, +    @Override, +    public V getValue() {, +      return value;, +    }, +, +    @Override, +    public V setValue(@Nullable V newValue) {, +      V result = value;, +      this.value = newValue;, +      return result;, +    Iterators.clear(new ValueForKeyIterator(key));, +  private class NodeIterator implements ListIterator<Entry<K, V>> {, +      checkPositionIndex(index, size);, +    public void set(Entry<K, V> e) {, +    public void add(Entry<K, V> e) {, +      checkPositionIndex(index, size);, +    return values().contains(value);, +  Set<K> createKeySet() {, +    return new Sets.ImprovedAbstractSet<K>() {, +    return (List<V>) super.values();, +  }, +, +  @Override, +  List<V> createValues() {, +    return new AbstractSequentialList<V>() {, +, +      @Override public ListIterator<V> listIterator(int index) {, +        final NodeIterator nodeItr = new NodeIterator(index);, +        return new TransformedListIterator<Entry<K, V>, V>(nodeItr) {, +          V transform(Entry<K, V> entry) {, +            return entry.getValue();, +            nodeItr.setValue(value);, +    return (List<Entry<K, V>>) super.entries();, +  }, +, +  @Override, +  List<Entry<K, V>> createEntries() {, +    return new AbstractSequentialList<Entry<K, V>>() {, +        return new NodeIterator(index);, +  Iterator<Entry<K, V>> entryIterator() {, +    throw new AssertionError("should never be called");, +  }, +, +  @Override, +  Map<K, Collection<V>> createAsMap() {, +    return new Multimaps.AsMap<K, V>() {, +++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java, +import static com.google.common.base.Preconditions.checkPositionIndex;, +public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V>, +  private static final class Node<K, V> extends AbstractMapEntry<K, V> {, +    @Override, +    public K getKey() {, +      return key;, +    }, +, +    @Override, +    public V getValue() {, +      return value;, +    }, +, +    @Override, +    public V setValue(@Nullable V newValue) {, +      V result = value;, +      this.value = newValue;, +      return result;, +    Iterators.clear(new ValueForKeyIterator(key));, +  private class NodeIterator implements ListIterator<Entry<K, V>> {, +      checkPositionIndex(index, size);, +    public void set(Entry<K, V> e) {, +    public void add(Entry<K, V> e) {, +      checkPositionIndex(index, size);, +    return values().contains(value);, +  Set<K> createKeySet() {, +    return new Sets.ImprovedAbstractSet<K>() {, +    return (List<V>) super.values();, +  }, +, +  @Override, +  List<V> createValues() {, +    return new AbstractSequentialList<V>() {, +, +      @Override public ListIterator<V> listIterator(int index) {, +        final NodeIterator nodeItr = new NodeIterator(index);, +        return new TransformedListIterator<Entry<K, V>, V>(nodeItr) {, +          V transform(Entry<K, V> entry) {, +            return entry.getValue();, +            nodeItr.setValue(value);, +    return (List<Entry<K, V>>) super.entries();, +  }, +, +  @Override]