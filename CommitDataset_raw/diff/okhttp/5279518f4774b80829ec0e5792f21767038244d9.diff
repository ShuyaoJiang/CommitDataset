[+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.io.Closeable;, +import okio.BufferedSource;, +import okio.Okio;, +import okio.Sink;, +import okio.Source;, +import okio.Timeout;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertSame;, +  private final Executor clientExecutor = new SynchronousExecutor();, +  private final MemorySocket client2Server = new MemorySocket();, +  private final Executor serverExecutor = new SynchronousExecutor();, +  private boolean serverConnectionClosed;, +  private final MemorySocket server2client = new MemorySocket();, +    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,, +        clientExecutor, clientListener, url) {, +        if (clientConnectionClosed) {, +          throw new AssertionError("Already closed");, +        }, +, +    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,, +        serverExecutor, serverListener, url) {, +        if (serverConnectionClosed) {, +          throw new AssertionError("Already closed");, +        }, +        serverConnectionClosed = true;, +  @Test public void clientWritingThrowsSendsClientClose() throws IOException {, +    final IOException brokenException = new IOException("Broken!");, +    RequestBody brokenBody = new RequestBody() {, +      @Override public MediaType contentType() {, +        return TEXT;, +      }, +, +      @Override public void writeTo(BufferedSink sink) throws IOException {, +        throw brokenException;, +      }, +    };, +, +    try {, +      client.sendMessage(brokenBody);, +      fail();, +    } catch (IOException e) {, +      assertSame(brokenException, e);, +    }, +, +    // A failed write prevents further use of the WebSocket instance., +    try {, +      client.sendPing(new Buffer().writeUtf8("Ping!"));, +      fail();, +    } catch (IllegalStateException e) {, +      assertEquals("closed", e.getMessage());, +    }, +, +    server.readMessage();, +    serverListener.assertClose(1001, "");, +  }, +, +  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {, +    client2Server.close();, +, +    try {, +      client.sendPing(new Buffer().writeUtf8("Ping!"));, +      fail();, +    } catch (IOException ignored) {, +    }, +, +    // A failed write prevents further use of the WebSocket instance., +    try {, +      client.sendPing(new Buffer().writeUtf8("Ping!"));, +      fail();, +    } catch (IllegalStateException e) {, +      assertEquals("closed", e.getMessage());, +    }, +  }, +, +  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {, +    client2Server.close();, +, +    try {, +      client.sendMessage(RequestBody.create(TEXT, "Hello!"));, +      fail();, +    } catch (IOException ignored) {, +    }, +, +    // A failed write prevents further use of the WebSocket instance., +    try {, +      client.sendPing(new Buffer().writeUtf8("Ping!"));, +      fail();, +    } catch (IllegalStateException e) {, +      assertEquals("closed", e.getMessage());, +    }, +  }, +, +  @Test public void socketClosedDuringCloseKillsWebSocket() throws IOException {, +    client2Server.close();, +, +    try {, +      client.close(1000, "I'm done.");, +      fail();, +    } catch (IOException ignored) {]