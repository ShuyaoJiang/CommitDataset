[+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java, +import com.squareup.okhttp.internal.tls.OkHostnameVerifier;, +        : new OkHostnameVerifier();, +++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java, +import com.squareup.okhttp.internal.tls.OkHostnameVerifier;, +        : new OkHostnameVerifier();, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java, +/*, + *  Licensed to the Apache Software Foundation (ASF) under one or more, + *  contributor license agreements.  See the NOTICE file distributed with, + *  this work for additional information regarding copyright ownership., + *  The ASF licenses this file to You under the Apache License, Version 2.0, + *  (the "License"); you may not use this file except in compliance with, + *  the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + *  Unless required by applicable law or agreed to in writing, software, + *  distributed under the License is distributed on an "AS IS" BASIS,, + *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *  See the License for the specific language governing permissions and, + *  limitations under the License., + */, +, +package com.squareup.okhttp.internal.tls;, +, +import javax.security.auth.x500.X500Principal;, +, +/**, + * A distinguished name (DN) parser. This parser only supports extracting a, + * string value from a DN. It doesn't support values in the hex-string style., + */, +final class DistinguishedNameParser {, +  private final String dn;, +  private final int length;, +  private int pos;, +  private int beg;, +  private int end;, +, +  /** tmp vars to store positions of the currently parsed item */, +  private int cur;, +, +  /** distinguished name chars */, +  private char[] chars;, +, +  public DistinguishedNameParser(X500Principal principal) {, +    // RFC2253 is used to ensure we get attributes in the reverse, +    // order of the underlying ASN.1 encoding, so that the most, +    // significant values of repeated attributes occur first., +    this.dn = principal.getName(X500Principal.RFC2253);, +    this.length = this.dn.length();, +  }, +, +  // gets next attribute type: (ALPHA 1*keychar) / oid, +  private String nextAT() {, +    // skip preceding space chars, they can present after, +    // comma or semicolon (compatibility with RFC 1779), +    for (; pos < length && chars[pos] == ' '; pos++) {, +    }, +    if (pos == length) {, +      return null; // reached the end of DN, +    }, +, +    // mark the beginning of attribute type, +    beg = pos;, +, +    // attribute type chars, +    pos++;, +    for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {, +      // we don't follow exact BNF syntax here:, +      // accept any char except space and '=', +    }, +    if (pos >= length) {, +      throw new IllegalStateException("Unexpected end of DN: " + dn);, +    }, +, +    // mark the end of attribute type, +    end = pos;, +, +    // skip trailing space chars between attribute type and '=', +    // (compatibility with RFC 1779), +    if (chars[pos] == ' ') {, +      for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {, +      }, +, +      if (chars[pos] != '=' || pos == length) {, +        throw new IllegalStateException("Unexpected end of DN: " + dn);, +      }, +    }, +, +    pos++; //skip '=' char, +, +    // skip space chars between '=' and attribute value, +    // (compatibility with RFC 1779), +    for (; pos < length && chars[pos] == ' '; pos++) {, +    }, +, +    // in case of oid attribute type skip its prefix: "oid." or "OID.", +    // (compatibility with RFC 1779), +    if ((end - beg > 4) && (chars[beg + 3] == '.')]