[+++ b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt, +import okio.BufferedSink, +import okio.BufferedSource, +import okio.ByteString, +@Suppress(, +    "ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE",, +    "DEPRECATION",, +    "RedundantExplicitType",, +    "UNUSED_VALUE",, +    "UNUSED_VARIABLE",, +    "VARIABLE_WITH_REDUNDANT_INITIALIZER", +), +, +  @Test @Ignore, +  fun request() {, +    val request: Request = Request.Builder().build(), +    val isHttps: Boolean = request.isHttps, +    val url: HttpUrl = request.url(), +    val method: String = request.method(), +    val headers: Headers = request.headers(), +    val header: String? = request.header(""), +    val headersForName: List<String> = request.headers(""), +    val body: RequestBody? = request.body(), +    var tag: Any? = request.tag(), +    tag = request.tag(Any::class.java), +    val builder: Request.Builder = request.newBuilder(), +    val cacheControl: CacheControl = request.cacheControl(), +  }, +, +  @Test @Ignore, +  fun requestBuilder() {, +    val requestBody = RequestBody.create(null, ""), +    var builder = Request.Builder(), +    builder = builder.url(HttpUrl.get("")), +    builder = builder.url(""), +    builder = builder.url(URL("")), +    builder = builder.header("", ""), +    builder = builder.addHeader("", ""), +    builder = builder.removeHeader(""), +    builder = builder.headers(Headers.of()), +    builder = builder.cacheControl(CacheControl.FORCE_CACHE), +    builder = builder.get(), +    builder = builder.head(), +    builder = builder.post(requestBody), +    builder = builder.delete(requestBody), +    builder = builder.delete(null), +    builder = builder.put(requestBody), +    builder = builder.patch(requestBody), +    builder = builder.method("", requestBody), +    builder = builder.method("", null), +    builder = builder.tag(""), +    builder = builder.tag(null), +    builder = builder.tag(String::class.java, ""), +    builder = builder.tag(String::class.java, null), +    val request: Request = builder.build(), +  }, +, +  @Test @Ignore, +  fun requestBody() {, +    var requestBody: RequestBody = object : RequestBody() {, +      override fun contentType(): MediaType? = TODO(), +      override fun contentLength(): Long = TODO(), +      override val isDuplex: Boolean get() = TODO(), +      override val isOneShot: Boolean get() = TODO(), +      override fun writeTo(sink: BufferedSink) = TODO(), +    }, +    requestBody = RequestBody.create(null, ""), +    requestBody = RequestBody.create(MediaType.parse(""), ""), +    requestBody = RequestBody.create(null, ByteString.EMPTY), +    requestBody = RequestBody.create(MediaType.parse(""), ByteString.EMPTY), +    requestBody = RequestBody.create(null, byteArrayOf(0, 1)), +    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1)), +    requestBody = RequestBody.create(null, byteArrayOf(0, 1), 0, 2), +    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1), 0, 2), +    requestBody = RequestBody.create(null, File("")), +    requestBody = RequestBody.create(MediaType.parse(""), File("")), +  }, +, +  @Test @Ignore, +  fun response() {, +    val response: Response = Response.Builder().build(), +    val request: Request = response.request(), +    val protocol: Protocol = response.protocol(), +    val code: Int = response.code(), +    val successful: Boolean = response.isSuccessful, +    val message: String = response.message(), +    val handshake: Handshake? = response.handshake(), +    val headersForName: List<String> = response.headers(""), +    val header: String? = response.header(""), +    val headers: Headers = response.headers(), +    val trailers: Headers = response.trailers(), +    val peekBody: ResponseBody = response.peekBody(0L), +    val body: ResponseBody? = response.body(), +    val builder: Response.Builder = response.newBuilder(), +    val redirect: Boolean = response.isRedirect, +    val networkResponse: Response? = response.networkResponse(), +    val cacheResponse: Response? = response.cacheResponse(), +    val priorResponse: Response? = response.priorResponse(), +    val challenges: List<Challenge> = response.challenges(), +    val cacheControl: CacheControl = response.cacheControl()]