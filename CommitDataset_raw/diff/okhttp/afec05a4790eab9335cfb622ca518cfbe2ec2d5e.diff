[+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java, +    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(, +        new CountDownLatch(1),, +        // No synchronization is needed for the last request, which is not canceled., +        new CountDownLatch(0));, +    List<CountDownLatch> requestCanceledLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(0));, +    QueueDispatcher dispatcher =, +        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);, +    server.setDispatcher(dispatcher);, +    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));, +    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(1),, +        // No synchronization is needed for the last request, which is not canceled., +        new CountDownLatch(0));, +    List<CountDownLatch> requestCanceledLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(1),, +        new CountDownLatch(0));, +, +    QueueDispatcher dispatcher =, +        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);, +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    server.setDispatcher(dispatcher);, +    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));, +    callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));, +  private class RespondAfterCancelDispatcher extends QueueDispatcher {, +    final private List<CountDownLatch> responseDequeuedLatches;, +    final private List<CountDownLatch> requestCanceledLatches;, +    private int responseIndex = 0;, +, +    RespondAfterCancelDispatcher(, +        List<CountDownLatch> responseDequeuedLatches,, +        List<CountDownLatch> requestCanceledLatches) {, +      this.responseDequeuedLatches = responseDequeuedLatches;, +      this.requestCanceledLatches = requestCanceledLatches;, +    }, +, +    @Override, +    synchronized public MockResponse dispatch(RecordedRequest request), +        throws InterruptedException {, +      // This guarantees a deterministic sequence when handling the canceled request:, +      // 1. Server reads request and dequeues first response, +      // 2. Client cancels request, +      // 3. Server tries to send response on the canceled stream, +      // Otherwise, there is no guarantee for the sequence. For example, the server may use the, +      // first mocked response to respond to the second request., +      MockResponse response = super.dispatch(request);, +      responseDequeuedLatches.get(responseIndex).countDown();, +      requestCanceledLatches.get(responseIndex).await();, +      responseIndex++;, +      return response;, +    }, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java, +    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(, +        new CountDownLatch(1),, +        // No synchronization is needed for the last request, which is not canceled., +        new CountDownLatch(0));, +    List<CountDownLatch> requestCanceledLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(0));, +    QueueDispatcher dispatcher =, +        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);, +    server.setDispatcher(dispatcher);, +    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));, +    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(1),, +        // No synchronization is needed for the last request, which is not canceled., +        new CountDownLatch(0));, +    List<CountDownLatch> requestCanceledLatches = Arrays.asList(, +        new CountDownLatch(1),, +        new CountDownLatch(1),, +        new CountDownLatch(0));, +, +    QueueDispatcher dispatcher =, +        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);, +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    server.setDispatcher(dispatcher);, +    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));, +    callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));, +  private class RespondAfterCancelDispatcher extends QueueDispatcher {, +    final private List<CountDownLatch> responseDequeuedLatches;, +    final private List<CountDownLatch> requestCanceledLatches;, +    private int responseIndex = 0;, +, +    RespondAfterCancelDispatcher(, +        List<CountDownLatch> responseDequeuedLatches,, +        List<CountDownLatch> requestCanceledLatches) {, +      this.responseDequeuedLatches = responseDequeuedLatches;, +      this.requestCanceledLatches = requestCanceledLatches;, +    }]