[+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java, +    hpackWriter = new Hpack.Writer(4096, false, bytesOut);, +    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);, +  @Test public void huffmanEncode() throws IOException {, +    hpackWriter = new Hpack.Writer(4096, true, bytesOut);, +    hpackWriter.writeHeaders(headerEntries("foo", "bar"));, +, +    ByteString expected = new Buffer(), +        .writeByte(0x40) // Literal header, new name., +        .writeByte(0x82) // String literal is Huffman encoded (len = 2)., +        .writeByte(0x94) // 'foo' Huffman encoded., +        .writeByte(0xE7), +        .writeByte(3) // String literal not Huffman encoded (len = 3)., +        .writeByte('b'), +        .writeByte('a'), +        .writeByte('r'), +        .readByteString();, +, +    ByteString actual = bytesOut.readByteString();, +    assertEquals(expected, actual);, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java, +    hpackWriter = new Hpack.Writer(4096, false, bytesOut);, +    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);, +  @Test public void huffmanEncode() throws IOException {, +    hpackWriter = new Hpack.Writer(4096, true, bytesOut);, +    hpackWriter.writeHeaders(headerEntries("foo", "bar"));, +, +    ByteString expected = new Buffer(), +        .writeByte(0x40) // Literal header, new name., +        .writeByte(0x82) // String literal is Huffman encoded (len = 2)., +        .writeByte(0x94) // 'foo' Huffman encoded., +        .writeByte(0xE7), +        .writeByte(3) // String literal not Huffman encoded (len = 3)., +        .writeByte('b'), +        .writeByte('a'), +        .writeByte('r'), +        .readByteString();, +, +    ByteString actual = bytesOut.readByteString();, +    assertEquals(expected, actual);, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java, +import okio.Buffer;, +import okio.ByteString;, +      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));, +    assertRoundTrip(ByteString.of(buf));, +  private void assertRoundTrip(ByteString data) throws IOException {, +    Buffer buffer = new Buffer();, +    Huffman.get().encode(data, buffer);, +    assertEquals(buffer.size(), Huffman.get().encodedLength(data));, +    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());, +    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java, +    hpackWriter = new Hpack.Writer(4096, false, bytesOut);, +    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);, +  @Test public void huffmanEncode() throws IOException {, +    hpackWriter = new Hpack.Writer(4096, true, bytesOut);, +    hpackWriter.writeHeaders(headerEntries("foo", "bar"));, +, +    ByteString expected = new Buffer(), +        .writeByte(0x40) // Literal header, new name., +        .writeByte(0x82) // String literal is Huffman encoded (len = 2)., +        .writeByte(0x94) // 'foo' Huffman encoded., +        .writeByte(0xE7), +        .writeByte(3) // String literal not Huffman encoded (len = 3)., +        .writeByte('b'), +        .writeByte('a'), +        .writeByte('r'), +        .readByteString();, +, +    ByteString actual = bytesOut.readByteString();, +    assertEquals(expected, actual);, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java, +import okio.Buffer;, +import okio.ByteString;, +      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));, +    assertRoundTrip(ByteString.of(buf));, +  private void assertRoundTrip(ByteString data) throws IOException {, +    Buffer buffer = new Buffer();, +    Huffman.get().encode(data, buffer);, +    assertEquals(buffer.size(), Huffman.get().encodedLength(data));, +    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());, +    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));, +++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java, +    private final boolean useCompression;, +      this(SETTINGS_HEADER_TABLE_SIZE, true, out);, +    Writer(int headerTableSizeSetting, boolean useCompression, Buffer out) {, +      this.useCompression = useCompression;, +      if (useCompression && Huffman.get().encodedLength(data) < data.size()) {, +        Buffer huffmanBuffer = new Buffer();, +        Huffman.get().encode(data, huffmanBuffer);, +        ByteString huffmanBytes = huffmanBuffer.readByteString();, +        writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80);, +        out.write(huffmanBytes);, +      } else {]