[+++ b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt, +/*, + * Copyright (C) 2019 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package okhttp3, +, +import okhttp3.internal.proxy.NullProxySelector, +import okhttp3.internal.tls.OkHostnameVerifier, +import okhttp3.tls.internal.TlsUtil.localhost, +import org.junit.Ignore, +import org.junit.Test, +import java.io.File, +import java.net.Proxy, +import java.net.ProxySelector, +import java.time.Duration, +import java.util.concurrent.TimeUnit, +import javax.net.SocketFactory, +import javax.net.ssl.HostnameVerifier, +import javax.net.ssl.SSLSocketFactory, +, +/**, + * Access every type, function, and property from Kotlin to defend against unexpected regressions in, + * source-compatibility., + *, + * Unlike most tests we're only really interested in whether this test compiles: it's output is not, + * interesting. Do not simplify this code by removing unused declarations or unnecessary types;, + * doing so limits the utility of the test., + */, +@Suppress("UNUSED_VARIABLE"), +class KotlinSourceCompatibilityTest {, +  @Test @Ignore, +  fun address() {, +    val address: Address = Address(, +        "",, +        0,, +        Dns.SYSTEM,, +        SocketFactory.getDefault(),, +        localhost().sslSocketFactory(),, +        OkHostnameVerifier.INSTANCE,, +        CertificatePinner.DEFAULT,, +        Authenticator.NONE,, +        Proxy.NO_PROXY,, +        listOf(Protocol.HTTP_1_1),, +        listOf(ConnectionSpec.MODERN_TLS),, +        NullProxySelector(), +    ), +    val url: HttpUrl = address.url(), +    val dns: Dns = address.dns(), +    val socketFactory: SocketFactory = address.socketFactory(), +    val proxyAuthenticator: Authenticator = address.proxyAuthenticator(), +    val protocols: List<Protocol> = address.protocols(), +    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs(), +    val proxySelector: ProxySelector = address.proxySelector(), +    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory(), +    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier(), +    val certificatePinner: CertificatePinner? = address.certificatePinner(), +  }, +, +  @Test @Ignore, +  fun cache() {, +    val cache = Cache(File("/cache/"), Integer.MAX_VALUE.toLong()), +    cache.initialize(), +    cache.delete(), +    cache.evictAll(), +    val urls: MutableIterator<String> = cache.urls(), +    val writeAbortCount: Int = cache.writeAbortCount(), +    val writeSuccessCount: Int = cache.writeSuccessCount(), +    val size: Long = cache.size(), +    val maxSize: Long = cache.maxSize(), +    cache.flush(), +    cache.close(), +    val directory: File = cache.directory(), +    val networkCount: Int = cache.networkCount(), +    val hitCount: Int = cache.hitCount(), +    val requestCount: Int = cache.requestCount(), +  }, +, +  @Test @Ignore, +  fun cacheControl() {, +    val cacheControl: CacheControl = CacheControl.Builder().build(), +    val noCache: Boolean = cacheControl.noCache(), +    val noStore: Boolean = cacheControl.noStore(), +    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds(), +    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds(), +    val mustRevalidate: Boolean = cacheControl.mustRevalidate(), +    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds(), +    val minFreshSeconds: Int = cacheControl.minFreshSeconds(), +    val onlyIfCached: Boolean = cacheControl.onlyIfCached()]