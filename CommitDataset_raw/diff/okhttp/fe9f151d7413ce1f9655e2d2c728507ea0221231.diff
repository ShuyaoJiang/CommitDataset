[+++ /dev/null, +++ /dev/null, +++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import okhttp3.internal.Internal;, +    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));, +++ /dev/null, +++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import okhttp3.internal.Internal;, +    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +/*, + * Copyright (C) 2015 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package okhttp3.internal.connection;, +, +import java.net.InetSocketAddress;, +import java.net.Proxy;, +import java.net.ProxySelector;, +import java.net.Socket;, +import java.util.Collections;, +import java.util.concurrent.TimeUnit;, +import javax.net.SocketFactory;, +import okhttp3.Address;, +import okhttp3.Call;, +import okhttp3.ConnectionPool;, +import okhttp3.Dns;, +import okhttp3.OkHttpClient;, +import okhttp3.Request;, +import okhttp3.Route;, +import okhttp3.internal.Internal;, +import okhttp3.internal.RecordingOkAuthenticator;, +import okhttp3.internal.Transmitter;, +import org.junit.Test;, +, +import static okhttp3.TestUtil.awaitGarbageCollection;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +, +public final class ConnectionPoolTest {, +  private final Address addressA = newAddress("a");, +  private final Route routeA1 = newRoute(addressA);, +  private final Address addressB = newAddress("b");, +  private final Route routeB1 = newRoute(addressB);, +  private final Address addressC = newAddress("c");, +  private final Route routeC1 = newRoute(addressC);, +, +  static {, +    Internal.initializeInstanceForTests();, +  }, +, +  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {, +    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);, +    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started., +, +    RealConnection c1 = newConnection(pool, routeA1, 50L);, +, +    // Running at time 50, the pool returns that nothing can be evicted until time 150., +    assertEquals(100L, pool.cleanup(50L));, +    assertEquals(1, pool.connectionCount());, +    assertFalse(c1.socket().isClosed());, +, +    // Running at time 60, the pool returns that nothing can be evicted until time 150., +    assertEquals(90L, pool.cleanup(60L));, +    assertEquals(1, pool.connectionCount());, +    assertFalse(c1.socket().isClosed());, +, +    // Running at time 149, the pool returns that nothing can be evicted until time 150., +    assertEquals(1L, pool.cleanup(149L));, +    assertEquals(1, pool.connectionCount());, +    assertFalse(c1.socket().isClosed());, +, +    // Running at time 150, the pool evicts., +    assertEquals(0, pool.cleanup(150L));, +    assertEquals(0, pool.connectionCount());, +    assertTrue(c1.socket().isClosed());, +, +    // Running again, the pool reports that no further runs are necessary., +    assertEquals(-1, pool.cleanup(150L));, +    assertEquals(0, pool.connectionCount());, +    assertTrue(c1.socket().isClosed());, +  }, +, +  @Test public void inUseConnectionsNotEvicted() throws Exception {, +    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);, +    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);, +    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started., +]