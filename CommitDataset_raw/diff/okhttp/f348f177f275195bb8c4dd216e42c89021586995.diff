[+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java, +import java.net.SocketAddress;, +  final String connectionName;, +    connectionName = builder.connectionName;, +        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));, +        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));, +      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {, +          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {, +      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);, +    String connectionName;, +      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();, +      String connectionName = remoteSocketAddress instanceof InetSocketAddress, +          ? ((InetSocketAddress) remoteSocketAddress).getHostName(), +          : remoteSocketAddress.toString();, +      return socket(socket, connectionName,, +        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {, +      this.connectionName = connectionName;, +      super("OkHttp %s", connectionName);, +          listenerExecutor.execute(new NamedRunnable(, +              "OkHttp %s stream %d", connectionName, streamId) {, +                Platform.get().log(, +                    INFO, "Http2Connection.Listener failure for " + connectionName, e);, +        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {, +        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {, +      pushExecutorExecute(new NamedRunnable(, +          "OkHttp %s Push Request[%s]", connectionName, streamId) {, +      pushExecutorExecute(new NamedRunnable(, +          "OkHttp %s Push Headers[%s]", connectionName, streamId) {, +    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {, +    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {, +++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java, +import java.net.SocketAddress;, +  final String connectionName;, +    connectionName = builder.connectionName;, +        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));, +        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));, +      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {, +          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {, +      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);, +    String connectionName;, +      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();, +      String connectionName = remoteSocketAddress instanceof InetSocketAddress, +          ? ((InetSocketAddress) remoteSocketAddress).getHostName(), +          : remoteSocketAddress.toString();, +      return socket(socket, connectionName,, +        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {, +      this.connectionName = connectionName;, +      super("OkHttp %s", connectionName);, +          listenerExecutor.execute(new NamedRunnable(, +              "OkHttp %s stream %d", connectionName, streamId) {, +                Platform.get().log(, +                    INFO, "Http2Connection.Listener failure for " + connectionName, e);, +        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {, +        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {, +      pushExecutorExecute(new NamedRunnable(, +          "OkHttp %s Push Request[%s]", connectionName, streamId) {, +      pushExecutorExecute(new NamedRunnable(, +          "OkHttp %s Push Headers[%s]", connectionName, streamId) {, +    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {, +    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {, +++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java, +/*, + * Copyright (C) 2018 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package okhttp3.unixdomainsockets;, +, +import java.io.File;, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.net.InetAddress;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.ByteBuffer;, +import java.nio.channels.Channels;, +import java.nio.channels.ReadableByteChannel;, +import java.nio.channels.SelectableChannel;, +import java.nio.channels.WritableByteChannel;, +import jnr.unixsocket.UnixSocket;, +import jnr.unixsocket.UnixSocketAddress;, +import jnr.unixsocket.UnixSocketChannel;, +, +/**, + * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets., + *, + * <p>This class doesn't pass {@link SelectableChannel} implementations to create input and output, + * streams. Though that type isn't in the public API, if the channel passed in implements that, + * interface then additional synchronization is used. This additional synchronization harms]