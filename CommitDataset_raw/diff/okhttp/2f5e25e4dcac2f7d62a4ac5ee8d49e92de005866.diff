[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        /*, +         * Buffer the input to mask SSL InputStream's degenerate available(), +         * implementation. That way we can read the end of a chunked response, +         * without blocking and will recycle the connection more reliably., +         * http://code.google.com/p/android/issues/detail?id=38817, +         */, +        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);, +++ b/pom.xml, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        /*, +         * Buffer the input to mask SSL InputStream's degenerate available(), +         * implementation. That way we can read the end of a chunked response, +         * without blocking and will recycle the connection more reliably., +         * http://code.google.com/p/android/issues/detail?id=38817, +         */, +        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +    private InputStream responseTransferIn;, +            if (!reusable || !transport.makeReusable(requestBodyOut, responseTransferIn)) {, +        responseTransferIn = transferStream;, +++ b/pom.xml, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        /*, +         * Buffer the input to mask SSL InputStream's degenerate available(), +         * implementation. That way we can read the end of a chunked response, +         * without blocking and will recycle the connection more reliably., +         * http://code.google.com/p/android/issues/detail?id=38817, +         */, +        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +    private InputStream responseTransferIn;, +            if (!reusable || !transport.makeReusable(requestBodyOut, responseTransferIn)) {, +        responseTransferIn = transferStream;, +++ b/src/main/java/libcore/net/http/HttpTransport.java, +++ b/pom.xml, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        /*, +         * Buffer the input to mask SSL InputStream's degenerate available(), +         * implementation. That way we can read the end of a chunked response, +         * without blocking and will recycle the connection more reliably., +         * http://code.google.com/p/android/issues/detail?id=38817, +         */, +        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +    private InputStream responseTransferIn;, +            if (!reusable || !transport.makeReusable(requestBodyOut, responseTransferIn)) {, +        responseTransferIn = transferStream;, +++ b/src/main/java/libcore/net/http/HttpTransport.java, +++ b/src/main/java/libcore/net/http/HttpsURLConnectionImpl.java, +            // make an SSL Tunnel on the first message pair of each SSL + proxy connection, +                if (connection.getAddress().requiresTunnel()) {, +                    makeTunnel(policy, connection, getRequestHeaders());, +            }, +, +            // if super.makeConnection returned a connection from the, +            // pool, sslSocket needs to be initialized here. If it is, +            // a new connection, it will be initialized by, +            // getSecureSocket below., +            // we already have an SSL connection,, +++ b/pom.xml, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        /*, +         * Buffer the input to mask SSL InputStream's degenerate available(), +         * implementation. That way we can read the end of a chunked response, +         * without blocking and will recycle the connection more reliably., +         * http://code.google.com/p/android/issues/detail?id=38817, +         */, +        sslInputStream = new BufferedInputStream(sslSocket.getInputStream(), 128);, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +    private InputStream responseTransferIn;, +            if (!reusable || !transport.makeReusable(requestBodyOut, responseTransferIn)) {, +        responseTransferIn = transferStream;, +++ b/src/main/java/libcore/net/http/HttpTransport.java, +++ b/src/main/java/libcore/net/http/HttpsURLConnectionImpl.java, +            // make an SSL Tunnel on the first message pair of each SSL + proxy connection, +                if (connection.getAddress().requiresTunnel()) {, +                    makeTunnel(policy, connection, getRequestHeaders());, +            }, +, +            // if super.makeConnection returned a connection from the, +            // pool, sslSocket needs to be initialized here. If it is, +            // a new connection, it will be initialized by, +            // getSecureSocket below., +            // we already have an SSL connection,, +++ b/src/test/java/libcore/net/http/URLConnectionTest.java, +        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);, +        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);, +    }, +, +    public void testGzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {, +        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);, +    }, +, +    public void testGzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {, +        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);, +     * which corrupted the request that followed or prevented connection reuse., +     * http://code.google.com/p/android/issues/detail?id=38817]