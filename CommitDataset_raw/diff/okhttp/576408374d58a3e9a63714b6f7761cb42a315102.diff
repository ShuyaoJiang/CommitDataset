[+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java, +    Internal.instance.setCallWebSocket(call);, +    call.enqueue(responseCallback);, +++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java, +    Internal.instance.setCallWebSocket(call);, +    call.enqueue(responseCallback);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +, +      @Override public void setCallWebSocket(Call call) {, +        ((RealCall) call).setForWebSocket();, +      }, +++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java, +    Internal.instance.setCallWebSocket(call);, +    call.enqueue(responseCallback);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +, +      @Override public void setCallWebSocket(Call call) {, +        ((RealCall) call).setForWebSocket();, +      }, +++ b/okhttp/src/main/java/okhttp3/RealCall.java, +  private boolean forWebSocket;, +      Response result = getResponseWithInterceptorChain();, +  synchronized void setForWebSocket() {, +    if (executed) throw new IllegalStateException("Already Executed");, +    this.forWebSocket = true;, +  @Override public void enqueue(Callback responseCallback) {, +    client.dispatcher().enqueue(new AsyncCall(responseCallback));, +    private AsyncCall(Callback responseCallback) {, +        Response response = getResponseWithInterceptorChain();, +  private Response getResponseWithInterceptorChain() throws IOException {, +    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest);, +    ApplicationInterceptorChain(int index, Request request) {, +      Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request);, +, +      return new RetryAndFollowUpInterceptor().intercept(chain);, +   * Performs the request and returns the response. May throw if this call was canceled. This isn't, +   * a regular interceptor because it doesn't delegate to the chain., +  class RetryAndFollowUpInterceptor implements Interceptor {, +    @Override public Response intercept(Chain chain) throws IOException {, +      Request request = chain.request();, +, +      engine = new HttpEngine(client, request.url(), forWebSocket, null, null);, +        Response response = null;, +          response = engine.proceed(request);, +          HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);, +          HttpEngine retryEngine = engine.recover(e, false, null);, +            StreamAllocation streamAllocation = engine.close(null);, +        Request followUp = engine.followUpRequest(response);, +        StreamAllocation streamAllocation = engine.close(response);, +        if (!engine.sameConnection(response, followUp.url())) {, +        engine = new HttpEngine(client, request.url(), forWebSocket, streamAllocation,, +            response);, +      }, +++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java, +    Internal.instance.setCallWebSocket(call);, +    call.enqueue(responseCallback);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +, +      @Override public void setCallWebSocket(Call call) {, +        ((RealCall) call).setForWebSocket();, +      }, +++ b/okhttp/src/main/java/okhttp3/RealCall.java, +  private boolean forWebSocket;, +      Response result = getResponseWithInterceptorChain();, +  synchronized void setForWebSocket() {, +    if (executed) throw new IllegalStateException("Already Executed");, +    this.forWebSocket = true;, +  @Override public void enqueue(Callback responseCallback) {, +    client.dispatcher().enqueue(new AsyncCall(responseCallback));, +    private AsyncCall(Callback responseCallback) {, +        Response response = getResponseWithInterceptorChain();, +  private Response getResponseWithInterceptorChain() throws IOException {, +    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest);, +    ApplicationInterceptorChain(int index, Request request) {, +      Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request);, +, +      return new RetryAndFollowUpInterceptor().intercept(chain);, +   * Performs the request and returns the response. May throw if this call was canceled. This isn't, +   * a regular interceptor because it doesn't delegate to the chain., +  class RetryAndFollowUpInterceptor implements Interceptor {, +    @Override public Response intercept(Chain chain) throws IOException {, +      Request request = chain.request();, +, +      engine = new HttpEngine(client, request.url(), forWebSocket, null, null);, +        Response response = null;, +          response = engine.proceed(request);, +          HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);, +          HttpEngine retryEngine = engine.recover(e, false, null);, +            StreamAllocation streamAllocation = engine.close(null);, +        Request followUp = engine.followUpRequest(response);, +        StreamAllocation streamAllocation = engine.close(response);, +        if (!engine.sameConnection(response, followUp.url())) {, +        engine = new HttpEngine(client, request.url(), forWebSocket, streamAllocation,, +            response);, +      }, +++ b/okhttp/src/main/java/okhttp3/internal/Internal.java, +, +  public abstract void setCallWebSocket(Call call);, +++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java, +    Internal.instance.setCallWebSocket(call);]