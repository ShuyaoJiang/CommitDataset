[+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +  private final Executor clientExecutor = Executors.newSingleThreadExecutor();, +  private final Executor serverExecutor = Executors.newSingleThreadExecutor();, +    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,, +    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,, +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    assertFalse(server.readMessage()); // This will trigger a close response., +    assertFalse(client.readMessage());, +    client.readMessage(); // Read server close., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +, +  private static void waitForExecutor(Executor executor) {, +    final CountDownLatch latch = new CountDownLatch(1);, +    executor.execute(new Runnable() {, +      @Override public void run() {, +        latch.countDown();, +      }, +    });, +    try {, +      if (!latch.await(10, TimeUnit.SECONDS)) {, +        throw new IllegalStateException("Timed out waiting for executor.");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +    }, +  }, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +  private final Executor clientExecutor = Executors.newSingleThreadExecutor();, +  private final Executor serverExecutor = Executors.newSingleThreadExecutor();, +    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,, +    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,, +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    assertFalse(server.readMessage()); // This will trigger a close response., +    assertFalse(client.readMessage());, +    client.readMessage(); // Read server close., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +, +  private static void waitForExecutor(Executor executor) {, +    final CountDownLatch latch = new CountDownLatch(1);, +    executor.execute(new Runnable() {, +      @Override public void run() {, +        latch.countDown();, +      }, +    });, +    try {, +      if (!latch.await(10, TimeUnit.SECONDS)) {, +        throw new IllegalStateException("Timed out waiting for executor.");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +    }, +  }, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java, +    assertData("888760b420bb60b468de0cd84f");, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +  private final Executor clientExecutor = Executors.newSingleThreadExecutor();, +  private final Executor serverExecutor = Executors.newSingleThreadExecutor();, +    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,, +    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,, +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    assertFalse(server.readMessage()); // This will trigger a close response., +    assertFalse(client.readMessage());, +    client.readMessage(); // Read server close., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +, +  private static void waitForExecutor(Executor executor) {, +    final CountDownLatch latch = new CountDownLatch(1);, +    executor.execute(new Runnable() {, +      @Override public void run() {, +        latch.countDown();, +      }, +    });, +    try {, +      if (!latch.await(10, TimeUnit.SECONDS)) {, +        throw new IllegalStateException("Timed out waiting for executor.");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +    }, +  }, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java, +    assertData("888760b420bb60b468de0cd84f");, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java, +/*, + * Copyright (C) 2015 Square, Inc.]