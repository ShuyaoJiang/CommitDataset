[+++ b/checkstyle.xml, +        <module name="NeedBraces"/>, +++ b/checkstyle.xml, +        <module name="NeedBraces"/>, +++ b/src/main/java/libcore/net/http/HttpConnectionPool.java, +            throw new IllegalArgumentException(); // TODO: just 'return' here?, +++ b/checkstyle.xml, +        <module name="NeedBraces"/>, +++ b/src/main/java/libcore/net/http/HttpConnectionPool.java, +            throw new IllegalArgumentException(); // TODO: just 'return' here?, +++ b/src/main/java/libcore/net/spdy/SpdyConnection.java, +import java.util.concurrent.LinkedBlockingQueue;, +import java.util.concurrent.SynchronousQueue;, +import java.util.concurrent.ThreadPoolExecutor;, +import java.util.concurrent.TimeUnit;, +, +import static libcore.net.spdy.Threads.newThreadFactory;, + *, + * <p>Many methods in this API are <strong>synchronous:</strong> the call is, + * completed before the method returns. This is typical for Java but atypical, + * for SPDY. This is motivated by exception transparency: an IOException that, + * was triggered by a certain caller can be caught and handled by that caller., +     * Internal state of this connection is guarded by 'this'. No blocking, +     * operations may be performed while holding this lock!, +     *, +     * Socket writes are guarded by spdyWriter., +     *, +     * Socket reads are unguarded but are only made by the reader thread., +     *, +     * Certain operations (like SYN_STREAM) need to synchronize on both the, +     * spdyWriter (to do blocking I/O) and this (to create streams). Such, +     * operations must synchronize on 'this' last. This ensures that we never, +     * wait for a blocking operation while holding 'this'., +    private final ExecutorService readExecutor;, +    private final ExecutorService writeExecutor;, +    private final ExecutorService callbackExecutor;, +, +    /**, +     * User code to run in response to an incoming stream. Callbacks must not be, +     * run on the callback executor., +     */, +    private final IncomingStreamHandler handler;, +, +    private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();, +    private int nextStreamId;, +, +    /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */, +    private Map<Integer, Ping> pings;, +    private int nextPingId;, +        nextStreamId = builder.client ? 1 : 2;, +        nextPingId = builder.client ? 1 : 2;, +        String prefix = isClient() ? "Spdy Client " : "Spdy Server ";, +        readExecutor = new ThreadPoolExecutor(1, 1, 60, TimeUnit.SECONDS,, +                new SynchronousQueue<Runnable>(), newThreadFactory(prefix + "Reader", true));, +        writeExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,, +                new LinkedBlockingQueue<Runnable>(), newThreadFactory(prefix + "Writer", true));, +        callbackExecutor = new ThreadPoolExecutor(1, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,, +                new SynchronousQueue<Runnable>(), newThreadFactory(prefix + "Callbacks", true));, +, +        readExecutor.execute(new Reader());, +    private synchronized SpdyStream getStream(int id) {, +            // TODO: rst stream, +            throw new UnsupportedOperationException("TODO " + id + "; " + streams);, +    synchronized void removeStream(int streamId) {, +    public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in), +        SpdyStream stream;, +        int streamId;, +        synchronized (spdyWriter) {, +            synchronized (this) {, +                streamId = nextStreamId;, +                nextStreamId += 2;, +                stream = new SpdyStream(streamId, this, requestHeaders, flags);, +                streams.put(streamId, stream);, +            }, +        return stream;, +    }, +, +    void writeSynReply(int streamId, List<String> alternating) throws IOException {, +        synchronized (spdyWriter) {, +    }, +    void writeFrame(byte[] bytes, int offset, int length) throws IOException {, +        synchronized (spdyWriter) {, +    }, +        writeExecutor.execute(new Runnable() {, +    void writeSynReset(int streamId, int statusCode) throws IOException {, +        synchronized (spdyWriter) {, +    }, +     * Sends a ping frame to the peer. Use the returned object to await the, +     * ping's response and observe its round trip time., +    public synchronized Ping ping() {, +        int pingId = nextPingId;, +        if (pings == null) pings = new HashMap<Integer, Ping>();, +    private void writePingLater(final int id, final Ping ping) {, +        writeExecutor.execute(new Runnable() {, +    private void writePing(int id, Ping ping) throws IOException {, +, +        synchronized (spdyWriter) {, +            spdyWriter.flags = 0;, +            spdyWriter.id = id;, +    }]