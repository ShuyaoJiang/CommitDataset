[+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java, +import okio.Buffer;, +  private static final ByteString DATA = ByteString.encodeUtf8("data");, +  private static final ByteString ID = ByteString.encodeUtf8("id");, +  private static final ByteString EVENT = ByteString.encodeUtf8("event");, +  private static final ByteString RETRY = ByteString.encodeUtf8("retry");, +    Buffer data = new Buffer();, +      long lineEnd = source.indexOfElement(CRLF);, +      if (lineEnd == -1L) {, +      switch (source.buffer().getByte(0)) {, +        case '\r':, +        case '\n':, +          completeEvent(id, type, data);, +        case 'd':, +          if (isKey(DATA)) {, +            parseData(data, lineEnd);, +          break;, +        case 'e':, +          if (isKey(EVENT)) {, +            type = parseEvent(lineEnd);, +            continue;, +          }, +          break;, +        case 'i':, +          if (isKey(ID)) {, +            id = parseId(lineEnd);, +            continue;, +          }, +          break;, +        case 'r':, +          if (isKey(RETRY)) {, +            parseRetry(lineEnd);, +            continue;, +          }, +          break;, +      source.skip(lineEnd);, +      skipCrAndOrLf();, +  }, +, +  private void completeEvent(String id, String type, Buffer data) throws IOException {, +    if (data.size() != 0L) {, +      lastId = id;, +      data.skip(1L); // Leading newline., +      callback.onEvent(id, type, data.readUtf8());, +    }, +  }, +, +  private void parseData(Buffer data, long end) throws IOException {, +    data.writeByte('\n');, +    end -= skipNameAndDivider(4L);, +    source.readFully(data, end);, +    skipCrAndOrLf();, +  }, +, +  private String parseEvent(long end) throws IOException {, +    String type = null;, +    end -= skipNameAndDivider(5L);, +    if (end != 0L) {, +      type = source.readUtf8(end);, +    }, +    skipCrAndOrLf();, +    return type;, +  }, +, +  private String parseId(long end) throws IOException {, +    String id;, +    end -= skipNameAndDivider(2L);, +    if (end != 0L) {, +      id = source.readUtf8(end);, +      id = null;, +    skipCrAndOrLf();, +    return id;, +  private void parseRetry(long end) throws IOException {, +    end -= skipNameAndDivider(5L);, +    String retryString = source.readUtf8(end);, +    long retryMs = -1L;, +      retryMs = Long.parseLong(retryString);, +    if (retryMs != -1L) {, +      callback.onRetryChange(retryMs);, +    }, +, +  /**, +   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or, +   * a newline., +   */, +  private boolean isKey(ByteString key) throws IOException {, +    if (source.rangeEquals(0, key)) {, +      byte nextByte = source.buffer().getByte(key.size());, +      return nextByte == ':', +          || nextByte == '\r', +          || nextByte == '\n';, +    return false;, +, +  /**, +   * Consumes the field name of the specified length and the optional colon and its optional, +   * trailing space. Returns the number of bytes skipped., +   */, +  private long skipNameAndDivider(long length) throws IOException {, +    source.skip(length);, +]