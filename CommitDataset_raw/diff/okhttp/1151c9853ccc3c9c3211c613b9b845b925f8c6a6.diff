[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +import static com.squareup.okhttp.internal.Util.UTF_8;, +    checkOffsetAndCount(this.byteCount, 0, byteCount);, +    if (byteCount == 0) return "";, +, +    Segment head = this.head;, +    if (head.pos + byteCount > head.limit) {, +      // If the string spans multiple segments, delegate to readBytes()., +    String result = new String(head.data, head.pos, byteCount, UTF_8);, +    head.pos += byteCount;, +    this.byteCount -= byteCount;, +, +    if (head.pos == head.limit) {, +      this.head = head.pop();, +      SegmentPool.INSTANCE.recycle(head);, +    }, +, +    return result;, +  }, +, +        Segment tail = head != null ? head.prev : null;, +        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +import static com.squareup.okhttp.internal.Util.UTF_8;, +    checkOffsetAndCount(this.byteCount, 0, byteCount);, +    if (byteCount == 0) return "";, +, +    Segment head = this.head;, +    if (head.pos + byteCount > head.limit) {, +      // If the string spans multiple segments, delegate to readBytes()., +    String result = new String(head.data, head.pos, byteCount, UTF_8);, +    head.pos += byteCount;, +    this.byteCount -= byteCount;, +, +    if (head.pos == head.limit) {, +      this.head = head.pop();, +      SegmentPool.INSTANCE.recycle(head);, +    }, +, +    return result;, +  }, +, +        Segment tail = head != null ? head.prev : null;, +        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java, +import java.io.EOFException;, +  /**, +   * Returns the index of {@code b} in {@code buffer}, refilling it if necessary, +   * until it is found. This reads an unbounded number of bytes into {@code, +   * buffer}., +   */, +  public static long seek(OkBuffer buffer, byte b, Source source, Deadline deadline), +      throws IOException {, +    long start = 0;, +    long index;, +    while ((index = buffer.indexOf(b, start)) == -1) {, +      start = buffer.byteCount;, +      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();, +    }, +    return index;, +  }, +, +        return buffer.readByte() & 0xff;, +        source.close(Deadline.NONE);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);, +          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +import static com.squareup.okhttp.internal.Util.UTF_8;, +    checkOffsetAndCount(this.byteCount, 0, byteCount);, +    if (byteCount == 0) return "";, +, +    Segment head = this.head;, +    if (head.pos + byteCount > head.limit) {, +      // If the string spans multiple segments, delegate to readBytes()., +    String result = new String(head.data, head.pos, byteCount, UTF_8);, +    head.pos += byteCount;, +    this.byteCount -= byteCount;, +, +    if (head.pos == head.limit) {, +      this.head = head.pop();, +      SegmentPool.INSTANCE.recycle(head);, +    }, +, +    return result;, +  }, +]