[+++ b/src/main/java/libcore/net/spdy/SpdyConnection.java, +import libcore.io.Streams;, +        return streams.get(id);, +    synchronized SpdyStream removeStream(int streamId) {, +        return streams.remove(streamId);, +        int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream., +        int priority = 0; // TODO: permit the caller to specify a priority., +            int flags = 0; // TODO: permit the caller to send FLAG_FIN, +            spdyWriter.flags = 0;, +        close(null);, +    }, +, +    private synchronized void close(Throwable reason) throws IOException {, +        // TODO: forward 'reason' to forced closed streams?, +            Throwable failure = null;, +                failure = e;, +            }, +, +            try {, +                close(failure);, +            } catch (IOException ignored) {, +                SpdyStream dataStream = getStream(spdyReader.id);, +                if (dataStream != null) {, +                    dataStream.receiveData(spdyReader.in, spdyReader.flags, spdyReader.length);, +                } else {, +                    writeSynResetLater(spdyReader.id, SpdyStream.RST_INVALID_STREAM);, +                    Streams.skipByReading(spdyReader.in, spdyReader.length);, +                }, +                final SpdyStream synStream = new SpdyStream(spdyReader.id, SpdyConnection.this,, +                SpdyStream previous = streams.put(spdyReader.id, synStream);, +                            handler.receive(synStream);, +                SpdyStream replyStream = getStream(spdyReader.id);, +                if (replyStream != null) {, +                    // TODO: honor incoming FLAG_FIN., +                    replyStream.receiveReply(spdyReader.nameValueBlock);, +                } else {, +                    writeSynResetLater(spdyReader.id, SpdyStream.RST_INVALID_STREAM);, +                }, +                SpdyStream rstStream = removeStream(spdyReader.id);, +                if (rstStream != null) {, +                    rstStream.receiveRstStream(spdyReader.statusCode);, +                }, +                if (spdyReader.length != 4 + 8 * numberOfEntries) {, +                    throw new IOException("TYPE_SETTINGS frame length is inconsistent: ", +                            + spdyReader.length + " != 4 + 8 * " + numberOfEntries);, +                throw new IOException("Unexpected frame: " + Integer.toHexString(spdyReader.type));, +++ b/src/main/java/libcore/net/spdy/SpdyConnection.java, +import libcore.io.Streams;, +        return streams.get(id);, +    synchronized SpdyStream removeStream(int streamId) {, +        return streams.remove(streamId);, +        int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream., +        int priority = 0; // TODO: permit the caller to specify a priority., +            int flags = 0; // TODO: permit the caller to send FLAG_FIN, +            spdyWriter.flags = 0;, +        close(null);, +    }, +, +    private synchronized void close(Throwable reason) throws IOException {, +        // TODO: forward 'reason' to forced closed streams?, +            Throwable failure = null;, +                failure = e;, +            }, +, +            try {, +                close(failure);, +            } catch (IOException ignored) {, +                SpdyStream dataStream = getStream(spdyReader.id);, +                if (dataStream != null) {, +                    dataStream.receiveData(spdyReader.in, spdyReader.flags, spdyReader.length);, +                } else {, +                    writeSynResetLater(spdyReader.id, SpdyStream.RST_INVALID_STREAM);, +                    Streams.skipByReading(spdyReader.in, spdyReader.length);, +                }, +                final SpdyStream synStream = new SpdyStream(spdyReader.id, SpdyConnection.this,, +                SpdyStream previous = streams.put(spdyReader.id, synStream);, +                            handler.receive(synStream);, +                SpdyStream replyStream = getStream(spdyReader.id);, +                if (replyStream != null) {, +                    // TODO: honor incoming FLAG_FIN., +                    replyStream.receiveReply(spdyReader.nameValueBlock);, +                } else {, +                    writeSynResetLater(spdyReader.id, SpdyStream.RST_INVALID_STREAM);, +                }, +                SpdyStream rstStream = removeStream(spdyReader.id);, +                if (rstStream != null) {, +                    rstStream.receiveRstStream(spdyReader.statusCode);, +                }, +                if (spdyReader.length != 4 + 8 * numberOfEntries) {, +                    throw new IOException("TYPE_SETTINGS frame length is inconsistent: ", +                            + spdyReader.length + " != 4 + 8 * " + numberOfEntries);, +                throw new IOException("Unexpected frame: " + Integer.toHexString(spdyReader.type));, +++ b/src/main/java/libcore/net/spdy/SpdyReader.java, +            return type = SpdyConnection.TYPE_EOF;, +            return type = SpdyConnection.TYPE_DATA;, +++ b/src/main/java/libcore/net/spdy/SpdyConnection.java, +import libcore.io.Streams;, +        return streams.get(id);, +    synchronized SpdyStream removeStream(int streamId) {, +        return streams.remove(streamId);]