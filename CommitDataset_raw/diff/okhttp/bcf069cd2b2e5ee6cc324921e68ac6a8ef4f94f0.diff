[+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java, +   * Returns an early guess of the next response, used for policy on how an, +   * incoming request should be received. The default implementation returns an, +   * empty response. Mischievous implementations can return other values to test, +   * HTTP edge cases, such as unhappy socket policies or throttled request, +   * bodies., +  public MockResponse peek() {, +    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);, +  }, +, +  /** @deprecated replaced with {@link #peek}. */, +  protected final SocketPolicy peekSocketPolicy() {, +    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java, +   * Returns an early guess of the next response, used for policy on how an, +   * incoming request should be received. The default implementation returns an, +   * empty response. Mischievous implementations can return other values to test, +   * HTTP edge cases, such as unhappy socket policies or throttled request, +   * bodies., +  public MockResponse peek() {, +    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);, +  }, +, +  /** @deprecated replaced with {@link #peek}. */, +  protected final SocketPolicy peekSocketPolicy() {, +    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(, +        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);, +    MockResponse throttlePolicy = dispatcher.peek();, +      throttledTransfer(throttlePolicy, in, requestBody, contentLength);, +        throttledTransfer(throttlePolicy, in, requestBody, chunkSize);, +    throttledTransfer(response, in, out, Long.MAX_VALUE);, +  }, +  /**, +   * Transfer bytes from {@code in} to {@code out} until either {@code length}, +   * bytes have been transferred or {@code in} is exhausted. The transfer is, +   * throttled according to {@code throttlePolicy}., +   */, +  private void throttledTransfer(MockResponse throttlePolicy, InputStream in, OutputStream out,, +      long limit) throws IOException {, +    byte[] buffer = new byte[1024];, +    int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();, +    long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());, +, +        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);, +        int read = in.read(buffer, 0, toRead);, +        limit -= read;, +, +        if (limit == 0) return;, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java, +   * Returns an early guess of the next response, used for policy on how an, +   * incoming request should be received. The default implementation returns an, +   * empty response. Mischievous implementations can return other values to test, +   * HTTP edge cases, such as unhappy socket policies or throttled request, +   * bodies., +  public MockResponse peek() {, +    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);, +  }, +, +  /** @deprecated replaced with {@link #peek}. */, +  protected final SocketPolicy peekSocketPolicy() {, +    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();, +    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(, +        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);, +    MockResponse throttlePolicy = dispatcher.peek();, +      throttledTransfer(throttlePolicy, in, requestBody, contentLength);, +        throttledTransfer(throttlePolicy, in, requestBody, chunkSize);, +    throttledTransfer(response, in, out, Long.MAX_VALUE);, +  }, +  /**, +   * Transfer bytes from {@code in} to {@code out} until either {@code length}, +   * bytes have been transferred or {@code in} is exhausted. The transfer is, +   * throttled according to {@code throttlePolicy}., +   */, +  private void throttledTransfer(MockResponse throttlePolicy, InputStream in, OutputStream out,, +      long limit) throws IOException {, +    byte[] buffer = new byte[1024];, +    int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();, +    long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());, +, +        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);, +        int read = in.read(buffer, 0, toRead);, +        limit -= read;, +, +        if (limit == 0) return;, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java, +  @Override public MockResponse peek() {, +    if (peek != null) return peek;, +    if (failFastResponse != null) return failFastResponse;, +    return super.peek();, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java, +   * Returns an early guess of the next response, used for policy on how an]