[+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java, +/*, + * Copyright (C) 2014 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package com.squareup.okhttp;, +, +import com.squareup.okhttp.internal.NamedRunnable;, +import com.squareup.okhttp.internal.Util;, +import java.io.IOException;, +import java.net.InetAddress;, +import java.net.InetSocketAddress;, +import java.net.ProtocolException;, +import java.net.Proxy;, +import java.net.ServerSocket;, +import java.net.Socket;, +import java.net.SocketException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +import okio.Buffer;, +import okio.BufferedSink;, +import okio.BufferedSource;, +import okio.Okio;, +, +/**, + * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer., + * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>., + */, +public final class SocksProxy {, +  private static final int VERSION_5 = 5;, +  private static final int METHOD_NONE = 0xff;, +  private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;, +  private static final int ADDRESS_TYPE_IPV4 = 1;, +  private static final int ADDRESS_TYPE_DOMAIN_NAME = 3;, +  private static final int COMMAND_CONNECT = 1;, +  private static final int REPLY_SUCCEEDED = 0;, +, +  private static final Logger logger = Logger.getLogger(SocksProxy.class.getName());, +, +  private final ExecutorService executor = Executors.newCachedThreadPool(, +      Util.threadFactory("SocksProxy", false));, +, +  private ServerSocket serverSocket;, +  private AtomicInteger connectionCount = new AtomicInteger();, +, +  public void play() throws IOException {, +    serverSocket = new ServerSocket(0);, +    executor.execute(new NamedRunnable("SocksProxy %s", serverSocket.getLocalPort()) {, +      @Override protected void execute() {, +        try {, +          while (true) {, +            Socket socket = serverSocket.accept();, +            connectionCount.incrementAndGet();, +            service(socket);, +          }, +        } catch (SocketException e) {, +          logger.info(name + " done accepting connections: " + e.getMessage());, +        } catch (IOException e) {, +          logger.log(Level.WARNING, name + " failed unexpectedly", e);, +        }, +      }, +    });, +  }, +, +  public Proxy proxy() {, +    return new Proxy(Proxy.Type.SOCKS, InetSocketAddress.createUnresolved(, +        "localhost", serverSocket.getLocalPort()));, +  }, +, +  public int connectionCount() {, +    return connectionCount.get();, +  }, +, +  public void shutdown() throws Exception {, +    serverSocket.close();, +    executor.shutdown();, +    if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {, +      throw new IOException("Gave up waiting for executor to shut down");, +    }, +  }, +, +  private void service(final Socket from) {, +    executor.execute(new NamedRunnable("SocksProxy %s", from.getRemoteSocketAddress()) {, +      @Override protected void execute() {, +        try {]