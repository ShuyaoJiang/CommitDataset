[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import java.io.ByteArrayInputStream;, +  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import java.io.ByteArrayInputStream;, +  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java, +    @Override public InputStream byteStream() {, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import java.io.ByteArrayInputStream;, +  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java, +    @Override public InputStream byteStream() {, +++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java, +public final class Failure {, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import java.io.ByteArrayInputStream;, +  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java, +    @Override public InputStream byteStream() {, +++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java, +public final class Failure {, +++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java, +public final class HttpResponseCache extends ResponseCache implements OkResponseCache {, +  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap), +      throws IOException {, +    throw new UnsupportedOperationException("This is not a general purpose response cache.");, +  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {, +    throw new UnsupportedOperationException("This is not a general purpose response cache.");, +  }, +, +  private static String urlToKey(Request requst) {, +    return Util.hash(requst.urlString());, +  }, +, +  @Override public Response get(Request request) {, +    String key = urlToKey(request);, +    if (!entry.matches(request)) {, +    return entry.response(request, snapshot);, +  @Override public CacheRequest put(Response response) throws IOException {, +    String requestMethod = response.request().method();, +    if (maybeRemove(response.request())) {, +    ResponseHeaders responseHeaders = new ResponseHeaders(null, response.rawHeaders());, +    if (responseHeaders.hasVaryAll()) {, +    Entry entry = new Entry(response);, +      editor = cache.edit(urlToKey(response.request()));, +  @Override public boolean maybeRemove(Request request) {, +    String method = request.method();, +    if (method.equals("POST") || method.equals("PUT") || method.equals("DELETE")) {, +        cache.remove(urlToKey(request));, +  @Override public void update(Response cached, Response network) {, +    Entry entry = new Entry(network);, +    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;, +      editor = snapshot.edit(); // Returns null if snapshot is not current., +  @Override public synchronized void trackResponse(ResponseSource source) {, +  @Override public synchronized void trackConditionalCacheHit() {, +    private final String url;, +        url = reader.readLine();, +    public Entry(Response response) {, +      this.url = response.request().urlString();, +      this.varyHeaders = response.request().rawHeaders().getAll(, +          new ResponseHeaders(null, response.rawHeaders()).getVaryFields());, +      this.requestMethod = response.request().method();, +      this.responseHeaders = response.rawHeaders();, +      this.handshake = response.handshake();, +      writer.write(url + '\n');, +      return url.startsWith("https://");, +    public boolean matches(Request request) {, +      return url.equals(request.urlString()), +          && requestMethod.equals(request.method()), +          && new ResponseHeaders(null, responseHeaders).varyMatches(varyHeaders, request);, +    }, +, +    public Response response(Request request, DiskLruCache.Snapshot snapshot) {, +      String contentType = responseHeaders.get("Content-Type");, +      String contentLength = responseHeaders.get("Content-Length");, +      return new Response.Builder(request, responseHeaders.getResponseCode()), +          .rawHeaders(responseHeaders), +          .body(new CacheResponseBody(snapshot, contentType, contentLength)), +          .handshake(handshake), +          .build();, +  private static class CacheResponseBody extends Response.Body {, +    private final DiskLruCache.Snapshot snapshot;, +    private final InputStream bodyIn;, +    private final String contentType;, +    private final String contentLength;, +, +    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,, +        String contentType, String contentLength) {, +      this.snapshot = snapshot;, +      this.contentType = contentType;, +      this.contentLength = contentLength;, +, +      // This input stream closes the snapshot when the stream is closed., +      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {, +    @Override public boolean ready() throws IOException {, +      return true;, +    @Override public MediaType contentType() {, +      return contentType != null ? MediaType.parse(contentType) : null;, +    @Override public long contentLength() {]