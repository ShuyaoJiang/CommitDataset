[+++ b/okhttp-tls/README.md, +A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the, +[builder][held_certificate_builder] to create a self-signed certificate that a test server can use, +for HTTPS:, +, +```java, +String localhost = InetAddress.getByName("localhost").getCanonicalHostName();, +HeldCertificate localhostCertificate = new HeldCertificate.Builder(), +    .addSubjectAlternativeName(localhost), +    .build();, +```, +, +[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake., +Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server, +returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this, +policy:, +, +```java, +HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder(), +    .heldCertificate(localhostCertificate), +    .build();, +MockWebServer server = new MockWebServer();, +server.useHttps(serverCertificates.sslSocketFactory(), false);, +```, +, +`HandshakeCertificates` also works for clients where its job is to define which root certificates, +to trust. In this simplified example we trust the server's self-signed certificate:, +, +```java, +HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder(), +    .addTrustedCertificate(localhostCertificate.certificate()), +    .build();, +OkHttpClient client = new OkHttpClient.Builder(), +    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager()), +    .build();, +```, +, +With a server that holds a certificate and a client that trusts it we have enough for an HTTPS, +handshake. The best part of this example is that we don't need to make our test code insecure with a, +a fake `HostnameVerifier` or `X509TrustManager`., +, +### Certificate Authorities, +, +The above example uses a self-signed certificate. This is convenient for testing but not, +representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`, +to generate a trusted root certificate, an intermediate certificate, and a server certificate., +We use `certificateAuthority(int)` to create certificates that can sign other certificates. The, +int specifies how many intermediate certificates are allowed beneath it in the chain., +, +```java, +HeldCertificate rootCertificate = new HeldCertificate.Builder(), +    .certificateAuthority(1), +    .build();, +, +HeldCertificate intermediateCertificate = new HeldCertificate.Builder(), +    .certificateAuthority(0), +    .signedBy(rootCertificate), +    .build();, +, +String localhost = InetAddress.getByName("localhost").getCanonicalHostName();, +HeldCertificate serverCertificate = new HeldCertificate.Builder(), +    .addSubjectAlternativeName(localhost), +    .signedBy(intermediateCertificate), +    .build();, +```, +, +To serve this configuration the server needs to provide its clients with a chain of certificates, +starting with its own and including everything up-to but not including the root. We don't need to, +include root certificates because the client already has them., +, +```java, +HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder(), +    .heldCertificate(serverCertificate, intermediateCertificate.certificate()), +    .build();, +```, +, +The client only needs to know the trusted root certificate. It checks the server's certificate by, +validating the signatures within the chain., +, +```java, +HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder(), +    .addTrustedCertificate(rootCertificate.certificate()), +    .build();, +OkHttpClient client = new OkHttpClient.Builder(), +    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager()), +    .build();, +```, +, +### Client Authentication, +, +The above scenario is representative of most TLS set ups: the client uses certificates to validate, +the identity of a server. The converse is also possible. Here we create a server that authenticates, +a client and a client that authenticates a server., +, +```java, +// Create the root for client and server to trust. We could also use different roots for each!, +HeldCertificate rootCertificate = new HeldCertificate.Builder(), +    .certificateAuthority(0), +    .build();, +]