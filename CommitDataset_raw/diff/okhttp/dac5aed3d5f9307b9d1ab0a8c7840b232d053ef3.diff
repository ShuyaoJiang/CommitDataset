[+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private final ConnectionPool pool;, +  public Connection(ConnectionPool pool, Route route) {, +    this.pool = pool;, +      httpConnection = new HttpConnection(pool, this, in, out);, +      httpConnection = new HttpConnection(pool, this, in, out);, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private final ConnectionPool pool;, +  public Connection(ConnectionPool pool, Route route) {, +    this.pool = pool;, +      httpConnection = new HttpConnection(pool, this, in, out);, +      httpConnection = new HttpConnection(pool, this, in, out);, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);, +++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java, +  public void share(Connection connection) {, +    if (!connection.isSpdy()) throw new IllegalArgumentException();, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private final ConnectionPool pool;, +  public Connection(ConnectionPool pool, Route route) {, +    this.pool = pool;, +      httpConnection = new HttpConnection(pool, this, in, out);, +      httpConnection = new HttpConnection(pool, this, in, out);, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);, +++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java, +  public void share(Connection connection) {, +    if (!connection.isSpdy()) throw new IllegalArgumentException();, +++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java, +      engine.close(); // Close the connection if it isn't already., +        engine.releaseConnection();, +        engine.releaseConnection();, +      Connection connection = engine.close();, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private final ConnectionPool pool;, +  public Connection(ConnectionPool pool, Route route) {, +    this.pool = pool;, +      httpConnection = new HttpConnection(pool, this, in, out);, +      httpConnection = new HttpConnection(pool, this, in, out);, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);, +++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java, +  public void share(Connection connection) {, +    if (!connection.isSpdy()) throw new IllegalArgumentException();, +++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java, +      engine.close(); // Close the connection if it isn't already., +        engine.releaseConnection();, +        engine.releaseConnection();, +      Connection connection = engine.close();, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java, +import com.squareup.okhttp.ConnectionPool;, +  private static final int ON_IDLE_HOLD = 0;, +  private static final int ON_IDLE_POOL = 1;, +  private static final int ON_IDLE_CLOSE = 2;, +, +  private final ConnectionPool pool;, +  private final Connection connection;, +  private int onIdle = ON_IDLE_HOLD;, +  public HttpConnection(ConnectionPool pool, Connection connection, InputStream in,, +      OutputStream out) {, +    this.pool = pool;, +    this.connection = connection;, +  /**, +   * Configure this connection to put itself back into the connection pool when, +   * the HTTP response body is exhausted., +   */, +  public void poolOnIdle() {, +    onIdle = ON_IDLE_POOL;, +, +    // If we're already idle, go to the pool immediately., +    if (state == STATE_IDLE) {, +      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default., +      pool.recycle(connection);, +    }, +  }, +, +  /**, +   * Configure this connection to close itself when the HTTP response body is, +   * exhausted., +   */, +  public void closeOnIdle() throws IOException {, +    onIdle = ON_IDLE_CLOSE;, +, +    // If we're already idle, close immediately., +    if (state == STATE_IDLE) {, +      state = STATE_CLOSED;, +      connection.close();, +    }, +  }, +, +  /** Returns true if this connection is closed. */, +  public boolean isClosed() {, +    return state == STATE_CLOSED;, +  }, +, +  public boolean discard(InputStream responseBodyIn) {, +  public InputStream newFixedLengthInputStream(CacheRequest cacheRequest, long length), +      throws IOException {, +    return new FixedLengthInputStream(cacheRequest, length);, +  public void emptyResponseBody() throws IOException {, +    newFixedLengthInputStream(null, 0L); // Transition to STATE_IDLE., +    return new ChunkedInputStream(cacheRequest, httpEngine);]