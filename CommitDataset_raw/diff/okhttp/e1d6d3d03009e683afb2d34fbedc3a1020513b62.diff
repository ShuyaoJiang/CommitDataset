[+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java, +import java.io.FileWriter;, +import java.util.Arrays;, +import java.util.concurrent.ExecutorService;, +, +import static com.squareup.okhttp.internal.Util.UTF_8;, + * entry has a string key and a fixed number of values. Values are byte, + * sequences, accessible as streams or files. Each value must be between {@code, + * 0} and {@code Integer.MAX_VALUE} bytes in length., +  // This cache uses a journal file named "journal". A typical journal file, +  // looks like this:, +  //     libcore.io.DiskLruCache, +  //     1, +  //     100, +  //     2, +  //, +  //     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054, +  //     DIRTY 335c4c6028171cfddfbaae1a9c313c52, +  //     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342, +  //     REMOVE 335c4c6028171cfddfbaae1a9c313c52, +  //     DIRTY 1ab96a171faeeee38496d8b330771a7a, +  //     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234, +  //     READ 335c4c6028171cfddfbaae1a9c313c52, +  //     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6, +  //, +  // The first five lines of the journal form its header. They are the, +  // constant string "libcore.io.DiskLruCache", the disk cache's version,, +  // the application's version, the value count, and a blank line., +  //, +  // Each of the subsequent lines in the file is a record of the state of a, +  // cache entry. Each line contains space-separated values: a state, a key,, +  // and optional state-specific values., +  //   o DIRTY lines track that an entry is actively being created or updated., +  //     Every successful DIRTY action should be followed by a CLEAN or REMOVE, +  //     action. DIRTY lines without a matching CLEAN or REMOVE indicate that, +  //     temporary files may need to be deleted., +  //   o CLEAN lines track a cache entry that has been successfully published, +  //     and may be read. A publish line is followed by the lengths of each of, +  //     its values., +  //   o READ lines track accesses for LRU., +  //   o REMOVE lines track entries that have been deleted., +  //, +  // The journal file is appended to as cache operations occur. The journal may, +  // occasionally be compacted by dropping redundant lines. A temporary file named, +  // "journal.tmp" will be used during compaction; that file should be deleted if, +  // it exists when the cache is opened., +  private final long maxSize;, +  private final LinkedHashMap<String, Entry> lruEntries =, +      new LinkedHashMap<String, Entry>(0, 0.75f, true);, +  private final ExecutorService executorService =, +      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());, +    @Override public Void call() throws Exception {, +        cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true));, +        Platform.get(), +            .logW("DiskLruCache ", +                + directory, +                + " is corrupt: ", +                + journalIsCorrupt.getMessage(), +                + ", removing");, +    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);, +      if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion), +          .equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !"", +          .equals(blank)) {, +            + magic, +            + ", ", +            + version, +            + ", ", +            + valueCountString, +            + ", ", +            + blank, +            + "]");, +    String[] parts = line.split(" ");, +    if (parts.length < 2) {, +    String key = parts[1];, +    if (parts[0].equals(REMOVE) && parts.length == 2) {, +    if (parts[0].equals(CLEAN) && parts.length == 2 + valueCount) {, +      entry.setLengths(Arrays.copyOfRange(parts, 2, parts.length));, +    } else if (parts[0].equals(DIRTY) && parts.length == 2) {, +    } else if (parts[0].equals(READ) && parts.length == 2) {, +    Writer writer = new BufferedWriter(new FileWriter(journalFileTmp));, +, +    journalFileTmp.renameTo(journalFile);, +    journalWriter = new BufferedWriter(new FileWriter(journalFile, true));, +    file.delete();, +    // Open all streams eagerly to guarantee that we see a single published, +    // snapshot. If we opened streams lazily then the streams could come, +    // from different edits., +    return new Snapshot(key, entry.sequenceNumber, ins);, +    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null, +        || entry.sequenceNumber != expectedSequenceNumber)) {, +  /** Returns the directory where this cache stores its data. */, +  public long maxSize() {, +          Platform.get().logW("DiskLruCache: Newly created entry doesn't have file for index " + i);, +    journalWriter.flush();, +    final int redundantOpCompactThreshold = 2000;, +    return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();, +  /** Returns true if this cache has been closed. */, +  /** Force buffered operations to the filesystem. */, +  /** Closes this cache. Stored values will remain on the filesystem. */, +    if (key.contains(" ") || key.contains("\n") || key.contains("\r")) {]