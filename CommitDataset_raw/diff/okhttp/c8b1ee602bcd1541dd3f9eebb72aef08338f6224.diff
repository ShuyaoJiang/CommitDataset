[+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java, +import static org.junit.Assert.fail;, +  public MockDuplexResponseBody requestIOException() {, +    actions.add((request, requestBody, responseBody) -> {, +      try {, +        requestBody.exhausted();, +        fail();, +      } catch (IOException expected) {, +      }, +    });, +    return this;, +  }, +, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java, +import static org.junit.Assert.fail;, +  public MockDuplexResponseBody requestIOException() {, +    actions.add((request, requestBody, responseBody) -> {, +      try {, +        requestBody.exhausted();, +        fail();, +      } catch (IOException expected) {, +      }, +    });, +    return this;, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java, +import java.util.ArrayList;, +import java.util.List;, +import okhttp3.internal.Util;, +    List<Response> responsesNotClosed = new ArrayList<>();, +, +          responsesNotClosed.add(response);, +    try (Response response = call.execute()) {, +      assertEquals("unrelated response body!", response.body().string());, +    }, +, +    assertEquals(0, server.takeRequest().getSequenceNumber());, +    assertEquals(0, server.takeRequest().getSequenceNumber()); // No connection reuse., +, +    for (Response response : responsesNotClosed) {, +      Util.closeQuietly(response);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java, +import static org.junit.Assert.fail;, +  public MockDuplexResponseBody requestIOException() {, +    actions.add((request, requestBody, responseBody) -> {, +      try {, +        requestBody.exhausted();, +        fail();, +      } catch (IOException expected) {, +      }, +    });, +    return this;, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java, +import java.util.ArrayList;, +import java.util.List;, +import okhttp3.internal.Util;, +    List<Response> responsesNotClosed = new ArrayList<>();, +, +          responsesNotClosed.add(response);, +    try (Response response = call.execute()) {, +      assertEquals("unrelated response body!", response.body().string());, +    }, +, +    assertEquals(0, server.takeRequest().getSequenceNumber());, +    assertEquals(0, server.takeRequest().getSequenceNumber()); // No connection reuse., +, +    for (Response response : responsesNotClosed) {, +      Util.closeQuietly(response);, +++ b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java, +import java.net.HttpURLConnection;, +import okhttp3.internal.RecordingOkAuthenticator;, +  /**, +   * Duplex calls that have follow-ups are weird. By the time we know there's a follow-up we've, +   * already split off another thread to stream the request body. Because we permit at most one, +   * exchange at a time we break the request stream out from under that writer., +   */, +  @Test public void duplexWithRedirect() throws Exception {, +    enableProtocol(Protocol.HTTP_2);, +, +    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(, +        new MockResponse(), +            .clearHeaders(), +            .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM), +            .addHeader("Location: /b"),, +        new MockDuplexResponseBody(), +            .sendResponse("/a has moved!\n"), +            .requestIOException(), +            .exhaustResponse());, +    server.enqueue(new MockResponse(), +        .setBody("this is /b"));, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .post(new AsyncRequestBody()), +        .build());, +, +    try (Response response = call.execute()) {]