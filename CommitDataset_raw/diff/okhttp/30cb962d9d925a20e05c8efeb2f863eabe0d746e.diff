[+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, + * entry has a string key and a fixed number of values. Each key must match, + * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,, + * accessible as streams or files. Each value must be between {@code 0} and, + * {@code Integer.MAX_VALUE} bytes in length., +  static final String JOURNAL_FILE_BKP = "journal.bkp";, +  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,64}");, +    /*, +     * This cache uses a journal file named "journal". A typical journal file, +     * looks like this:, +     *     libcore.io.DiskLruCache, +     *     1, +     *     100, +     *     2, +     *, +     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054, +     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52, +     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342, +     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52, +     *     DIRTY 1ab96a171faeeee38496d8b330771a7a, +     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234, +     *     READ 335c4c6028171cfddfbaae1a9c313c52, +     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6, +     *, +     * The first five lines of the journal form its header. They are the, +     * constant string "libcore.io.DiskLruCache", the disk cache's version,, +     * the application's version, the value count, and a blank line., +     *, +     * Each of the subsequent lines in the file is a record of the state of a, +     * cache entry. Each line contains space-separated values: a state, a key,, +     * and optional state-specific values., +     *   o DIRTY lines track that an entry is actively being created or updated., +     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE, +     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that, +     *     temporary files may need to be deleted., +     *   o CLEAN lines track a cache entry that has been successfully published, +     *     and may be read. A publish line is followed by the lengths of each of, +     *     its values., +     *   o READ lines track accesses for LRU., +     *   o REMOVE lines track entries that have been deleted., +     *, +     * The journal file is appended to as cache operations occur. The journal may, +     * occasionally be compacted by dropping redundant lines. A temporary file named, +     * "journal.tmp" will be used during compaction; that file should be deleted if, +     * it exists when the cache is opened., +     */, +  private final File journalFileBkp;, +  private long maxSize;, +  private final LinkedHashMap<String, Entry> lruEntries, +      = new LinkedHashMap<String, Entry>(0, 0.75f, true);, +  final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1,, +      60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());, +    public Void call() throws Exception {, +    this.journalFileBkp = new File(directory, JOURNAL_FILE_BKP);, +    // if a bkp file exists, use it instead, +    File bkpFile = new File(directory, JOURNAL_FILE_BKP);, +    if (bkpFile.exists()) {, +      File journalFile = new File(directory, JOURNAL_FILE);, +      // if journal file also exists just delete backup file, +      if (journalFile.exists()) {, +        bkpFile.delete();, +      } else {, +        renameTo(bkpFile, journalFile, false);, +      }, +    }, +, +        cache.journalWriter = new BufferedWriter(new OutputStreamWriter(, +            new FileOutputStream(cache.journalFile, true), Util.US_ASCII));, +        Platform.get().logW("DiskLruCache " + directory + " is corrupt: ", +            + journalIsCorrupt.getMessage() + ", removing");, +    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile),, +        Util.US_ASCII);, +      if (!MAGIC.equals(magic), +          || !VERSION_1.equals(version), +          || !Integer.toString(appVersion).equals(appVersionString), +          || !Integer.toString(valueCount).equals(valueCountString), +          || !"".equals(blank)) {, +            + magic + ", " + version + ", " + valueCountString + ", " + blank + "]");, +      int lineCount = 0;, +          lineCount++;, +      redundantOpCount = lineCount - lruEntries.size();, +    int firstSpace = line.indexOf(' ');, +    if (firstSpace == -1) {, +    int keyBegin = firstSpace + 1;, +    int secondSpace = line.indexOf(' ', keyBegin);, +    final String key;, +    if (secondSpace == -1) {, +      key = line.substring(keyBegin);, +      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {, +    } else {, +      key = line.substring(keyBegin, secondSpace);, +    }, +    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {, +      String[] parts = line.substring(secondSpace + 1).split(" ");, +      entry.setLengths(parts);, +    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {, +    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {, +    Writer writer = new BufferedWriter(new OutputStreamWriter(]