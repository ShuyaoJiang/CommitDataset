[+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java, +        Address address = chain.connection().route().address();, +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java, +        Address address = chain.connection().route().address();, +++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java, +        route = connection.route();, +        handshake = connection.handshake();, +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java, +        Address address = chain.connection().route().address();, +++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java, +        route = connection.route();, +        handshake = connection.handshake();, +++ b/okhttp/src/main/java/okhttp3/Connection.java, +  Route route();, +   * Returns the socket that this connection is using. Returns an {@linkplain, +   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY, +   * connection the socket may be shared by multiple concurrent calls., +  Socket socket();, +  /**, +   * Returns the TLS handshake used to establish this connection, or null if the connection is not, +   * HTTPS., +   */, +  Handshake handshake();, +  Protocol protocol();, +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java, +        Address address = chain.connection().route().address();, +++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java, +        route = connection.route();, +        handshake = connection.handshake();, +++ b/okhttp/src/main/java/okhttp3/Connection.java, +  Route route();, +   * Returns the socket that this connection is using. Returns an {@linkplain, +   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY, +   * connection the socket may be shared by multiple concurrent calls., +  Socket socket();, +  /**, +   * Returns the TLS handshake used to establish this connection, or null if the connection is not, +   * HTTPS., +   */, +  Handshake handshake();, +  Protocol protocol();, +++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java, +import static okhttp3.internal.Util.closeQuietly;, +, +          && address.equals(connection.route().address), +      closeQuietly(connection.socket());, +    closeQuietly(longestIdleConnection.socket());, +      Internal.logger.warning("A connection to " + connection.route().address().url(), +++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java, +    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;, +++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java, +    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());, +++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java, +        Address address = chain.connection().route().address();, +++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java, +        route = connection.route();, +        handshake = connection.handshake();, +++ b/okhttp/src/main/java/okhttp3/Connection.java, +  Route route();, +   * Returns the socket that this connection is using. Returns an {@linkplain, +   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY, +   * connection the socket may be shared by multiple concurrent calls., +  Socket socket();, +  /**, +   * Returns the TLS handshake used to establish this connection, or null if the connection is not, +   * HTTPS., +   */, +  Handshake handshake();, +  Protocol protocol();, +++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java, +import static okhttp3.internal.Util.closeQuietly;, +, +          && address.equals(connection.route().address), +      closeQuietly(connection.socket());, +    closeQuietly(longestIdleConnection.socket());, +      Internal.logger.warning("A connection to " + connection.route().address().url(), +++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java, +        request, httpEngine.getConnection().route().proxy().type());]