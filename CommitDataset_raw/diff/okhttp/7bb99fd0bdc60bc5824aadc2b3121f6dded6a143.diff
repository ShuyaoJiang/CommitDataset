[+++ b/src/main/java/com/google/mockwebserver/MockWebServer.java, +import static com.google.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;, +import java.security.cert.CertificateException;, +import java.security.cert.X509Certificate;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.TrustManager;, +import javax.net.ssl.X509TrustManager;, +                    MockResponse response = responseQueue.peek();, +                    if (response != null && response.getSocketPolicy() == FAIL_HANDSHAKE) {, +                        processHandshakeFailure(raw, sequenceNumber++);, +                        return;, +                    }, +                while (!responseQueue.isEmpty() && processOneRequest(socket, in, out)) {}, +                    if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {, +            private boolean processOneRequest(Socket socket, InputStream in, OutputStream out), +                RecordedRequest request = readRequest(socket, in, sequenceNumber);, +    private void processHandshakeFailure(Socket raw, int sequenceNumber) throws Exception {, +        responseQueue.take();, +        X509TrustManager untrusted = new X509TrustManager() {, +            @Override public void checkClientTrusted(X509Certificate[] chain, String authType), +                    throws CertificateException {, +                throw new CertificateException();, +            }, +            @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {, +                throw new AssertionError();, +            }, +            @Override public X509Certificate[] getAcceptedIssuers() {, +                throw new AssertionError();, +            }, +        };, +        SSLContext context = SSLContext.getInstance("TLS");, +        context.init(null, new TrustManager[] { untrusted }, new java.security.SecureRandom());, +        SSLSocketFactory sslSocketFactory = context.getSocketFactory();, +        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(, +                raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);, +        try {, +            socket.startHandshake(); // we're testing a handshake failure, +            throw new AssertionError();, +        } catch (IOException expected) {, +        }, +        socket.close();, +        requestCount.incrementAndGet();, +        requestQueue.add(new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket));, +    }, +, +    private RecordedRequest readRequest(Socket socket, InputStream in, int sequenceNumber), +            throws IOException {, +                requestBody.numBytesReceived, requestBody.toByteArray(), sequenceNumber, socket);, +++ b/src/main/java/com/google/mockwebserver/MockWebServer.java, +import static com.google.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;, +import java.security.cert.CertificateException;, +import java.security.cert.X509Certificate;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.TrustManager;, +import javax.net.ssl.X509TrustManager;, +                    MockResponse response = responseQueue.peek();, +                    if (response != null && response.getSocketPolicy() == FAIL_HANDSHAKE) {, +                        processHandshakeFailure(raw, sequenceNumber++);, +                        return;, +                    }, +                while (!responseQueue.isEmpty() && processOneRequest(socket, in, out)) {}, +                    if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {, +            private boolean processOneRequest(Socket socket, InputStream in, OutputStream out), +                RecordedRequest request = readRequest(socket, in, sequenceNumber);, +    private void processHandshakeFailure(Socket raw, int sequenceNumber) throws Exception {, +        responseQueue.take();, +        X509TrustManager untrusted = new X509TrustManager() {, +            @Override public void checkClientTrusted(X509Certificate[] chain, String authType), +                    throws CertificateException {, +                throw new CertificateException();, +            }, +            @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {, +                throw new AssertionError();, +            }, +            @Override public X509Certificate[] getAcceptedIssuers() {, +                throw new AssertionError();, +            }, +        };, +        SSLContext context = SSLContext.getInstance("TLS");, +        context.init(null, new TrustManager[] { untrusted }, new java.security.SecureRandom());, +        SSLSocketFactory sslSocketFactory = context.getSocketFactory();, +        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(, +                raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);, +        try {, +            socket.startHandshake(); // we're testing a handshake failure, +            throw new AssertionError();, +        } catch (IOException expected) {, +        }, +        socket.close();, +        requestCount.incrementAndGet();, +        requestQueue.add(new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket));, +    }, +, +    private RecordedRequest readRequest(Socket socket, InputStream in, int sequenceNumber), +            throws IOException {, +                requestBody.numBytesReceived, requestBody.toByteArray(), sequenceNumber, socket);, +++ b/src/main/java/com/google/mockwebserver/RecordedRequest.java, +import java.net.Socket;, +import javax.net.ssl.SSLSocket;, +    private final String sslProtocol;]