[+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java, +    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);, +    CountDownLatch requestCanceledLatch = new CountDownLatch(1);, +, +    QueueDispatcher dispatcher = new QueueDispatcher() {, +      @Override, +      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {, +        // This guarantees a deterministic sequence when handling the canceled request:, +        // 1. Server reads request and dequeues first response, +        // 2. Client cancels request, +        // 3. Server tries to send response on the canceled stream, +        // Otherwise, there is no guarantee for the sequence. For example, the server may use the, +        // first mocked response to respond to the second request., +        MockResponse response = super.dispatch(request);, +        responseDequeuedLatch.countDown();, +        requestCanceledLatch.await();, +        return response;, +      }, +    };, +    server.setDispatcher(dispatcher);, +, +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);, +    callAndCancel(0, new CountDownLatch(0), new CountDownLatch(0));, +    callAndCancel(1, new CountDownLatch(0), new CountDownLatch(0));, +  private void callAndCancel(int expectedSequenceNumber, CountDownLatch responseDequeuedLatch,, +      CountDownLatch requestCanceledLatch) throws Exception {, +    responseDequeuedLatch.await();, +    requestCanceledLatch.countDown();, +++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java, +    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);, +    CountDownLatch requestCanceledLatch = new CountDownLatch(1);, +, +    QueueDispatcher dispatcher = new QueueDispatcher() {, +      @Override, +      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {, +        // This guarantees a deterministic sequence when handling the canceled request:, +        // 1. Server reads request and dequeues first response, +        // 2. Client cancels request, +        // 3. Server tries to send response on the canceled stream, +        // Otherwise, there is no guarantee for the sequence. For example, the server may use the, +        // first mocked response to respond to the second request., +        MockResponse response = super.dispatch(request);, +        responseDequeuedLatch.countDown();, +        requestCanceledLatch.await();, +        return response;, +      }, +    };, +    server.setDispatcher(dispatcher);, +, +    dispatcher.enqueueResponse(new MockResponse(), +    dispatcher.enqueueResponse(new MockResponse(), +    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);, +    callAndCancel(0, new CountDownLatch(0), new CountDownLatch(0));, +    callAndCancel(1, new CountDownLatch(0), new CountDownLatch(0));, +  private void callAndCancel(int expectedSequenceNumber, CountDownLatch responseDequeuedLatch,, +      CountDownLatch requestCanceledLatch) throws Exception {, +    responseDequeuedLatch.await();, +    requestCanceledLatch.countDown();, +++ b/pom.xml, +            <version>8.15</version>]