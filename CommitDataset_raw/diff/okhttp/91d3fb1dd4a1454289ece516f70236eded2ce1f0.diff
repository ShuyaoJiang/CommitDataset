[+++ b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java, +import java.lang.reflect.Constructor;, +import java.security.cert.Certificate;, +import java.security.cert.X509Certificate;, +import javax.net.ssl.SSLPeerUnverifiedException;, +import okhttp3.internal.tls.CertificateChainCleaner;, +  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {, +    try {, +      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");, +      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);, +      Object extensions = constructor.newInstance(trustManager);, +      Method checkServerTrusted = extensionsClass.getMethod(, +          "checkServerTrusted", X509Certificate[].class, String.class, String.class);, +      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);, +    } catch (Exception e) {, +      return super.buildCertificateChainCleaner(trustManager);, +    }, +  }, +, +, +  /**, +   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012)., +   * This is the best way to get a clean chain on Android because it uses the same code as the TLS, +   * handshake., +   */, +  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {, +    private final Object x509TrustManagerExtensions;, +    private final Method checkServerTrusted;, +, +    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {, +      this.x509TrustManagerExtensions = x509TrustManagerExtensions;, +      this.checkServerTrusted = checkServerTrusted;, +    }, +, +    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>., +    @Override public List<Certificate> clean(List<Certificate> chain, String hostname), +        throws SSLPeerUnverifiedException {, +      try {, +        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);, +        return (List<Certificate>) checkServerTrusted.invoke(, +            x509TrustManagerExtensions, certificates, "RSA", hostname);, +      } catch (InvocationTargetException e) {, +        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());, +        exception.initCause(e);, +        throw exception;, +      } catch (IllegalAccessException e) {, +        throw new AssertionError(e);, +      }, +    }, +  }, +++ b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java, +import java.lang.reflect.Constructor;, +import java.security.cert.Certificate;, +import java.security.cert.X509Certificate;, +import javax.net.ssl.SSLPeerUnverifiedException;, +import okhttp3.internal.tls.CertificateChainCleaner;, +  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {, +    try {, +      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");, +      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);, +      Object extensions = constructor.newInstance(trustManager);, +      Method checkServerTrusted = extensionsClass.getMethod(, +          "checkServerTrusted", X509Certificate[].class, String.class, String.class);, +      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);, +    } catch (Exception e) {, +      return super.buildCertificateChainCleaner(trustManager);, +    }, +  }, +, +, +  /**, +   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012)., +   * This is the best way to get a clean chain on Android because it uses the same code as the TLS, +   * handshake., +   */, +  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {, +    private final Object x509TrustManagerExtensions;, +    private final Method checkServerTrusted;, +, +    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {, +      this.x509TrustManagerExtensions = x509TrustManagerExtensions;, +      this.checkServerTrusted = checkServerTrusted;, +    }, +, +    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>., +    @Override public List<Certificate> clean(List<Certificate> chain, String hostname), +        throws SSLPeerUnverifiedException {, +      try {, +        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);, +        return (List<Certificate>) checkServerTrusted.invoke(, +            x509TrustManagerExtensions, certificates, "RSA", hostname);, +      } catch (InvocationTargetException e) {, +        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());, +        exception.initCause(e);, +        throw exception;, +      } catch (IllegalAccessException e) {, +        throw new AssertionError(e);, +      }, +    }, +  }]