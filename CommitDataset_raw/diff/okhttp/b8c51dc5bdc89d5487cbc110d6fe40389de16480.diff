[+++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpResponseCache.java, +import java.io.BufferedInputStream;, +import libcore.io.Streams;, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpResponseCache.java, +import java.io.BufferedInputStream;, +import libcore.io.Streams;, +++ b/src/main/java/libcore/net/http/HttpTransport.java, +        // If the request specified that the connection shouldn't be reused,, +        // don't reuse it. This advice doesn't apply to CONNECT requests because, +        // the "Connection: close" header goes the origin server, not the proxy., +                && httpEngine.method != HttpEngine.CONNECT) {, +            return false;, +        }, +, +        // If the response specified that the connection shouldn't be reused, don't reuse it., +        if (httpEngine.responseHeaders != null && httpEngine.responseHeaders.hasConnectionClose()) {, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpResponseCache.java, +import java.io.BufferedInputStream;, +import libcore.io.Streams;, +++ b/src/main/java/libcore/net/http/HttpTransport.java, +        // If the request specified that the connection shouldn't be reused,, +        // don't reuse it. This advice doesn't apply to CONNECT requests because, +        // the "Connection: close" header goes the origin server, not the proxy., +                && httpEngine.method != HttpEngine.CONNECT) {, +            return false;, +        }, +, +        // If the response specified that the connection shouldn't be reused, don't reuse it., +        if (httpEngine.responseHeaders != null && httpEngine.responseHeaders.hasConnectionClose()) {, +++ b/src/test/java/libcore/net/http/URLConnectionTest.java, +    // Don't disconnect after building a tunnel with CONNECT, +    // http://code.google.com/p/android/issues/detail?id=37221, +    public void testProxyWithConnectionClose() throws IOException {, +        server.useHttps(sslContext.getSocketFactory(), true);, +        server.enqueue(new MockResponse(), +                .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END), +                .clearHeaders());, +        server.enqueue(new MockResponse().setBody("this response comes via a proxy"));, +        server.play();, +, +        URL url = new URL("https://android.com/foo");, +        OkHttpsConnection connection = (OkHttpsConnection) openConnection(, +                url, server.toProxyAddress());, +        connection.setRequestProperty("Connection", "close");, +        connection.setSSLSocketFactory(sslContext.getSocketFactory());, +        connection.setHostnameVerifier(new RecordingHostnameVerifier());, +, +        assertContent("this response comes via a proxy", connection);, +    }, +]