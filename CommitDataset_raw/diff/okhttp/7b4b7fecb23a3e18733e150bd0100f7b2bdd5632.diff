[+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +      transmitter.acquireConnection(connection);, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +  public void acquireConnection(RealConnection connection) {, +    streamAllocation.transmitterAcquireConnection(connection);, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +  public void acquireConnection(RealConnection connection) {, +    streamAllocation.transmitterAcquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public boolean isEligible(Address address, @Nullable List<Route> routes) {, +    if (routes == null || !routeMatchesAny(routes)) return false;, +    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;, +  /** Returns true if this connection's route has the same address as any of {@code routes}. */, +  private boolean routeMatchesAny(List<Route> candidates) {, +    for (int i = 0, size = candidates.size(); i < size; i++) {, +      Route candidate = candidates.get(i);, +      if (candidate.proxy().type() == Proxy.Type.DIRECT, +          && route.proxy().type() == Proxy.Type.DIRECT, +          && route.socketAddress().equals(candidate.socketAddress())) {, +        return true;, +      }, +    }, +    return false;, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +  public void acquireConnection(RealConnection connection) {, +    streamAllocation.transmitterAcquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public boolean isEligible(Address address, @Nullable List<Route> routes) {, +    if (routes == null || !routeMatchesAny(routes)) return false;, +    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;, +  /** Returns true if this connection's route has the same address as any of {@code routes}. */, +  private boolean routeMatchesAny(List<Route> candidates) {, +    for (int i = 0, size = candidates.size(); i < size; i++) {, +      Route candidate = candidates.get(i);, +      if (candidate.proxy().type() == Proxy.Type.DIRECT, +          && route.proxy().type() == Proxy.Type.DIRECT, +          && route.socketAddress().equals(candidate.socketAddress())) {, +        return true;, +      }, +    }, +    return false;, +  }, +, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java, +   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns, +   * true if a connection was acquired., +   *, +   * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the, +   * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as, +   * {@code square.com} and {@code square.ca}., +  boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter,, +      @Nullable List<Route> routes, boolean requireMultiplexed) {, +      if (requireMultiplexed && !connection.isMultiplexed()) continue;, +      if (!connection.isEligible(address, routes)) continue;, +      transmitter.acquireConnection(connection);, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +  public void acquireConnection(RealConnection connection) {, +    streamAllocation.transmitterAcquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public boolean isEligible(Address address, @Nullable List<Route> routes) {, +    if (routes == null || !routeMatchesAny(routes)) return false;, +    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;, +  /** Returns true if this connection's route has the same address as any of {@code routes}. */, +  private boolean routeMatchesAny(List<Route> candidates) {, +    for (int i = 0, size = candidates.size(); i < size; i++) {, +      Route candidate = candidates.get(i);, +      if (candidate.proxy().type() == Proxy.Type.DIRECT, +          && route.proxy().type() == Proxy.Type.DIRECT, +          && route.socketAddress().equals(candidate.socketAddress())) {, +        return true;, +      }, +    }, +    return false;, +  }, +, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java, +   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns, +   * true if a connection was acquired., +   *, +   * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the, +   * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as, +   * {@code square.com} and {@code square.ca}., +  boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter,, +      @Nullable List<Route> routes, boolean requireMultiplexed) {, +      if (requireMultiplexed && !connection.isMultiplexed()) continue;]