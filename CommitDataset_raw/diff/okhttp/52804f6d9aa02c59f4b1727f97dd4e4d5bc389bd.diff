[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java, +import com.squareup.okhttp.internal.bytes.ByteString;, +import java.util.Collections;, +import java.util.LinkedHashMap;, +import java.util.Map;, +          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN, +  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();, +, +  private static Map<ByteString, Integer> nameToFirstIndex() {, +    Map<ByteString, Integer> result =, +        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);, +    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {, +      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {, +        result.put(STATIC_HEADER_TABLE[i].name, i);, +      }, +    }, +    return Collections.unmodifiableMap(result);, +  }, +, +      // TODO: implement index tracking, +        ByteString name = headerBlock.get(i).name;, +        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);, +        if (staticIndex != null) {, +          // Literal Header Field without Indexing - Indexed Name., +          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);, +        } else {, +          out.write(0x40); // Literal Header without Indexing - New Name., +          writeByteString(name);, +          writeByteString(headerBlock.get(i).value);, +        }, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java, +import com.squareup.okhttp.internal.bytes.ByteString;, +import java.util.Collections;, +import java.util.LinkedHashMap;, +import java.util.Map;, +          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN, +  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();, +, +  private static Map<ByteString, Integer> nameToFirstIndex() {, +    Map<ByteString, Integer> result =, +        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);, +    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {, +      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {, +        result.put(STATIC_HEADER_TABLE[i].name, i);, +      }, +    }, +    return Collections.unmodifiableMap(result);, +  }, +, +      // TODO: implement index tracking, +        ByteString name = headerBlock.get(i).name;, +        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);, +        if (staticIndex != null) {, +          // Literal Header Field without Indexing - Indexed Name., +          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);, +        } else {, +          out.write(0x40); // Literal Header without Indexing - New Name., +          writeByteString(name);, +          writeByteString(headerBlock.get(i).value);, +        }, +++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java, +import static org.junit.Assert.assertArrayEquals;, +  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();, +  private HpackDraft05.Writer hpackWriter;, +  @Before public void reset() {, +    hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));, +  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {, +   * Literal Header Field without Indexing - New Name, +  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {, +    List<Header> headerBlock = headerEntries("custom-key", "custom-header");, +    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();, +    expectedBytes.write(0x40); // Not indexed, +    expectedBytes.write(0x0a); // Literal name (len = 10), +    expectedBytes.write("custom-key".getBytes(), 0, 10);, +, +    expectedBytes.write(0x0d); // Literal value (len = 13), +    expectedBytes.write("custom-header".getBytes(), 0, 13);, +, +    hpackWriter.writeHeaders(headerBlock);, +    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());, +, +    bytesIn.set(bytesOut.toByteArray());, +    assertEquals(headerBlock, hpackReader.getAndReset());, +  }, +, +  /**, +   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2, +   */, +  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {, +    List<Header> headerBlock = headerEntries(":path", "/sample/path");, +, +    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();, +    expectedBytes.write(0x44); // == Literal not indexed ==, +                               // Indexed name (idx = 4) -> :path, +    expectedBytes.write(0x0c); // Literal value (len = 12), +    expectedBytes.write("/sample/path".getBytes(), 0, 12);, +, +    hpackWriter.writeHeaders(headerBlock);, +    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());, +]