[+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +    MockResponse throttlePolicy = dispatcher.peek();, +      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);, +        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);, +    if (request.startsWith("OPTIONS "), +        || request.startsWith("GET "), +        || request.startsWith("HEAD "), +        || request.startsWith("TRACE "), +        || request.startsWith("CONNECT ")) {, +      if (hasBody) {, +    } else if (!request.startsWith("POST "), +        && !request.startsWith("PUT "), +        && !request.startsWith("PATCH "), +        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous., +      throw new UnsupportedOperationException("Unexpected method: " + request);, +    }, +    throttledTransfer(response, socket, body, sink, body.size());, +   * throttled according to {@code throttlePolicy}., +  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,, +      BufferedSink sink, long byteCount) throws IOException {, +    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();, +    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);, +    boolean disconnectHalfway = throttlePolicy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;, +        throttledTransfer(response, socket, body, sink, bodyLimit);, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +    MockResponse throttlePolicy = dispatcher.peek();, +      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);, +        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);, +    if (request.startsWith("OPTIONS "), +        || request.startsWith("GET "), +        || request.startsWith("HEAD "), +        || request.startsWith("TRACE "), +        || request.startsWith("CONNECT ")) {, +      if (hasBody) {, +    } else if (!request.startsWith("POST "), +        && !request.startsWith("PUT "), +        && !request.startsWith("PATCH "), +        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous., +      throw new UnsupportedOperationException("Unexpected method: " + request);, +    }, +    throttledTransfer(response, socket, body, sink, body.size());, +   * throttled according to {@code throttlePolicy}., +  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,, +      BufferedSink sink, long byteCount) throws IOException {, +    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();, +    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);, +    boolean disconnectHalfway = throttlePolicy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;, +        throttledTransfer(response, socket, body, sink, bodyLimit);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java, +   * Initialize the cache. This will include reading the journal files from, +   * the storage and building up the necessary in-memory cache information., +   * <p>, +   * The initialization time may vary depending on the journal file size and, +   * the current actual cache size. The application needs to be aware of calling, +   * this function during the initialization phase and preferrably in a background, +   * worker thread., +   * <p>, +   * Note that if the application chooses to not call this method to initialize, +   * the cache. By default, the okhttp will perform lazy initialization upon the, +   * first usage of the cache., +   */, +  public void initialize() throws IOException {, +    cache.initialize();, +  }, +, +  /**, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +    MockResponse throttlePolicy = dispatcher.peek();, +      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);, +        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);, +    if (request.startsWith("OPTIONS "), +        || request.startsWith("GET "), +        || request.startsWith("HEAD "), +        || request.startsWith("TRACE "), +        || request.startsWith("CONNECT ")) {, +      if (hasBody) {, +    } else if (!request.startsWith("POST "), +        && !request.startsWith("PUT "), +        && !request.startsWith("PATCH "), +        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous., +      throw new UnsupportedOperationException("Unexpected method: " + request);, +    }, +    throttledTransfer(response, socket, body, sink, body.size());, +   * throttled according to {@code throttlePolicy}., +  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,, +      BufferedSink sink, long byteCount) throws IOException {, +    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();, +    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);, +    boolean disconnectHalfway = throttlePolicy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;, +        throttledTransfer(response, socket, body, sink, bodyLimit);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java, +   * Initialize the cache. This will include reading the journal files from, +   * the storage and building up the necessary in-memory cache information., +   * <p>, +   * The initialization time may vary depending on the journal file size and, +   * the current actual cache size. The application needs to be aware of calling, +   * this function during the initialization phase and preferrably in a background, +   * worker thread., +   * <p>, +   * Note that if the application chooses to not call this method to initialize]