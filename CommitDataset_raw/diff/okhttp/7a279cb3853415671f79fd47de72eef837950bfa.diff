[+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java, +  /** Returns an input stream containing the raw HTTP payload. */, +  InputStream getBodyStream() {, +    if (bodyStream != null) {, +      return bodyStream;, +    }, +    Buffer body = getBody();, +    return body != null ? body.inputStream() : null;, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java, +  /** Returns an input stream containing the raw HTTP payload. */, +  InputStream getBodyStream() {, +    if (bodyStream != null) {, +      return bodyStream;, +    }, +    Buffer body = getBody();, +    return body != null ? body.inputStream() : null;, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +import java.io.BufferedInputStream;, +import java.io.BufferedOutputStream;, +import java.io.ByteArrayOutputStream;, +import java.io.InputStream;, +import java.io.OutputStream;, +          logger.info(MockWebServer.this + " connection from ", +              + raw.getInetAddress() + " failed: " + e);, +          logger.log(Level.SEVERE, MockWebServer.this + " connection from ", +              + raw.getInetAddress() + " crashed", e);, +          socket = sslSocketFactory.createSocket(, +              raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);, +            protocol = protocolString != null, +                ? Protocol.get(protocolString), +                : Protocol.HTTP_1_1;, +          SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket), +              .protocol(protocol), +              .handler(spdySocketHandler).build();, +        InputStream in = new BufferedInputStream(socket.getInputStream());, +        OutputStream out = new BufferedOutputStream(socket.getOutputStream());, +        while (processOneRequest(socket, in, out)) {, +          logger.warning(MockWebServer.this + " connection from " + raw.getInetAddress(), +        in.close();, +        out.close();, +          if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {, +      private boolean processOneRequest(Socket socket, InputStream in, OutputStream out), +        RecordedRequest request = readRequest(socket, in, out, sequenceNumber);, +          if (in.read() == -1) return false;, +          handleWebSocketUpgrade(socket, in, out, request, response);, +          writeHttpResponse(socket, out, response);, +          in.close();, +          out.close();, +          logger.info(MockWebServer.this + " received request: " + request, +              + " and responded: " + response);, +  private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream out,, +      request = readAsciiUntilCrlf(in);, +    while ((header = readAsciiUntilCrlf(in)).length() != 0) {, +      out.write(("HTTP/1.1 100 Continue\r\n").getBytes(Util.US_ASCII));, +      out.write(("Content-Length: 0\r\n").getBytes(Util.US_ASCII));, +      out.write(("\r\n").getBytes(Util.US_ASCII));, +      out.flush();, +    TruncatingOutputStream requestBody = new TruncatingOutputStream();, +      throttledTransfer(throttlePolicy, socket, in, requestBody, contentLength);, +        int chunkSize = Integer.parseInt(readAsciiUntilCrlf(in).trim(), 16);, +          readEmptyLine(in);, +        throttledTransfer(throttlePolicy, socket, in, requestBody, chunkSize);, +        readEmptyLine(in);, +    return new RecordedRequest(request, headers, chunkSizes, requestBody.numBytesReceived,, +        new Buffer().write(requestBody.toByteArray()), sequenceNumber, socket);, +  private void handleWebSocketUpgrade(Socket socket, InputStream in, OutputStream out,, +    writeHttpResponse(socket, out, response);, +, +    BufferedSource source = Okio.buffer(Okio.source(in));, +    BufferedSink sink = Okio.buffer(Okio.sink(out));, +  private void writeHttpResponse(Socket socket, OutputStream out, MockResponse response), +    out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));, +      String header = headers.get(i);, +      out.write((header + "\r\n").getBytes(Util.US_ASCII));, +    out.write(("\r\n").getBytes(Util.US_ASCII));, +    out.flush();, +    InputStream in = response.getBodyStream();, +    if (in == null) return;, +    throttledTransfer(response, socket, in, out, Long.MAX_VALUE);, +  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, InputStream in,, +      OutputStream out, long limit) throws IOException {, +    byte[] buffer = new byte[1024];, +        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);, +        int read = in.read(buffer, 0, toRead);, +        out.write(buffer, 0, read);, +        out.flush();, +        if (delayMs != 0) Thread.sleep(delayMs);, +, +  /**, +   * Returns the text from {@code in} until the next "\r\n", or null if {@code, +   * in} is exhausted., +   */, +  private String readAsciiUntilCrlf(InputStream in) throws IOException {, +    StringBuilder builder = new StringBuilder();, +    while (true) {, +      int c = in.read();, +      if (c == '\n' && builder.length() > 0 && builder.charAt(builder.length() - 1) == '\r') {, +        builder.deleteCharAt(builder.length() - 1);, +        return builder.toString();, +      } else if (c == -1) {]