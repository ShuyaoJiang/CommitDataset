[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +  private Segment head;, +      int toCopy = Math.min(byteCount - offset, head.limit - head.pos);, +      System.arraycopy(head.data, head.pos, result, offset, toCopy);, +      head.pos += toCopy;, +      if (head.pos == head.limit) {, +        Segment toRecycle = head;, +        head = toRecycle.pop();, +        SegmentPool.INSTANCE.recycle(toRecycle);, +      if (head == null) {, +        head = SegmentPool.INSTANCE.take(); // Acquire a first segment., +        head.next = head.prev = head;, +      Segment tail = head.prev;, +        tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up., +    // Move bytes from the head of the source buffer to the tail of this buffer, +    // while balancing two conflicting goals: don't waste CPU and don't waste, +    // memory., +    //, +    //, +    // Don't waste CPU (ie. don't copy data around)., +    //, +    // Copying large amounts of data is expensive. Instead, we prefer to, +    // reassign entire segments from one OkBuffer to the other., +    //, +    //, +    // Don't waste memory., +    //, +    // As an invariant, adjacent pairs of segments in an OkBuffer should be at, +    // least 50% full, except for the head segment and the tail segment., +    //, +    // The head segment cannot maintain the invariant because the application is, +    // consuming bytes from this segment, decreasing its level., +    //, +    // The tail segment cannot maintain the invariant because the application is, +    // producing bytes, which may require new nearly-empty tail segments to be, +    // appended., +    //, +    //, +    // Moving segments between buffers, +    //, +    // When writing one buffer to another, we prefer to reassign entire segments, +    // over copying bytes into their most compact form. Suppose we have a buffer, +    // with these segment levels [91%, 61%]. If we append a buffer with a, +    // single [72%] segment, that yields [91%, 61%, 72%]. No bytes are copied., +    //, +    // Or suppose we have a buffer with these segment levels: [100%, 2%], and we, +    // want to append it to a buffer with these segment levels [99%, 3%]. This, +    // operation will yield the following segments: [100%, 2%, 99%, 3%]. That, +    // is, we do not spend time copying bytes around to achieve more efficient, +    // memory use like [100%, 100%, 4%]., +    //, +    // When combining buffers, we will compact adjacent buffers when their, +    // combined level is less than 100%. For example, when we start with [100%,, +    // 40%] and append [30%, 80%], the result is [100%, 70%, 80%]., +    //, +    //, +    // Splitting segments, +    //, +    // Occasionally we write only part of a source buffer to a sink buffer. For, +    // example, given a sink [51%, 91%], we may want to write the first 30% of, +    // a source [92%, 82%] to it. To simplify, we first transform the source to, +    // an equivalent buffer [30%, 62%, 82%] and then move the head segment,, +    // yielding sink [51%, 91%, 30%] and source [62%, 82%]., +, +    if (source == this) throw new IllegalArgumentException("source == this");, +    if (byteCount > source.byteCount) {, +      throw new IllegalArgumentException(, +          String.format("requested %s > available %s", byteCount, this.byteCount));, +    }, +, +    while (byteCount > 0) {, +      // Is a prefix of the source's head segment all that we need to move?, +      if (byteCount < (source.head.limit - source.head.pos)) {, +        Segment tail = head.prev;, +        if (head == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {, +          // We're going to need another segment. Split the source's head, +          // segment in two, then move the first of those two to this buffer., +          source.head = source.head.split((int) byteCount);, +        } else {, +          // Our existing segments are sufficient. Move bytes from source's head to our tail., +          source.head.writeTo(tail, (int) byteCount);, +          source.byteCount -= byteCount;, +          this.byteCount += byteCount;, +          return;, +        }, +      }, +, +      // Remove the source's head segment and append it to our tail., +      Segment segmentToMove = source.head;, +      long movedByteCount = segmentToMove.limit - segmentToMove.pos;, +      source.head = segmentToMove.pop();, +      if (head == null) {, +        head = segmentToMove;, +        head.next = head.prev = head;, +      } else {, +        Segment tail = head.prev;, +        tail = tail.push(segmentToMove);]