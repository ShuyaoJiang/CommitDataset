[+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      tunnelConnection.emptyResponseBody();, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      tunnelConnection.emptyResponseBody();, +++ /dev/null, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      tunnelConnection.emptyResponseBody();, +++ /dev/null, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java, +/**, + * A socket connection that can be used to send HTTP/1.1 messages. This class, + * strictly enforces the following lifecycle:, + * <ol>, + *   <li>{@link #writeRequest Send request headers}., + *   <li>Open the request body output stream. Either {@link, + *       #newFixedLengthOutputStream fixed-length} or {@link, + *       #newChunkedOutputStream chunked}., + *   <li>Write to and then close that stream., + *   <li>{@link #readResponse Read response headers}., + *   <li>Open the HTTP response body input stream. Either {@link, + *       #newFixedLengthInputStream fixed-length}, {@link #newChunkedInputStream, + *       chunked} or {@link #newUnknownLengthInputStream unknown length}., + *   <li>Read from and close that stream., + * </ol>, + * <p>Exchanges that do not have a request body may skip creating and closing, + * the request body. Exchanges that do not have a response body must call {@link, + * #emptyResponseBody}., + */, +  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers., +  private static final int STATE_OPEN_REQUEST_BODY = 1;, +  private static final int STATE_WRITING_REQUEST_BODY = 2;, +  private static final int STATE_READ_RESPONSE_HEADERS = 3;, +  private static final int STATE_OPEN_RESPONSE_BODY = 4;, +  private static final int STATE_READING_RESPONSE_BODY = 5;, +  private static final int STATE_CLOSED = 6;, +, +  private int state = STATE_IDLE;, +, +    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);, +    state = STATE_OPEN_REQUEST_BODY;, +    if (state != STATE_OPEN_REQUEST_BODY, +        && state != STATE_READ_RESPONSE_HEADERS) {, +      throw new IllegalStateException("state: " + state);, +    }, +      if (statusLine.code() != HTTP_CONTINUE) {, +        state = STATE_OPEN_RESPONSE_BODY;, +        return responseBuilder;, +      }, +    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_WRITING_REQUEST_BODY;, +    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_WRITING_REQUEST_BODY;, +  public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {, +    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_READ_RESPONSE_HEADERS;, +    requestBody.writeToSocket(out);, +  }, +, +    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_READING_RESPONSE_BODY;, +  /**, +   * Call this to advance past a response body for HTTP responses that do not, +   * have a response body., +   */, +  public void emptyResponseBody() {, +    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_IDLE;, +  }, +, +    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_READING_RESPONSE_BODY;, +    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);, +    state = STATE_READING_RESPONSE_BODY;, +  private final class FixedLengthOutputStream extends AbstractOutputStream {, +      state = STATE_READ_RESPONSE_HEADERS;, +  /**, +   * An HTTP body with alternating chunk sizes and chunk bodies. Chunks are, +   * buffered until {@code maxChunkLength} bytes are ready, at which point the, +   * chunk is written and the buffer is cleared., +   */, +  private final class ChunkedOutputStream extends AbstractOutputStream {, +      state = STATE_READ_RESPONSE_HEADERS;, +  private class AbstractHttpInputStream extends InputStream {, +    protected final InputStream in;, +    protected final HttpEngine httpEngine;, +    private final CacheRequest cacheRequest;, +    protected final OutputStream cacheBody;, +    protected boolean closed;, +, +    AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest), +        throws IOException {, +      this.in = in;, +      this.httpEngine = httpEngine;, +, +      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;, +, +      // Some apps return a null body; for compatibility we treat that like a null cache request., +      if (cacheBody == null) {, +        cacheRequest = null;, +      }]