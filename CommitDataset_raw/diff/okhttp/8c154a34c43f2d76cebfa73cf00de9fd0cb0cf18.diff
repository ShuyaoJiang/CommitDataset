[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +        source.close();, +        sink.close();, +      long read = in.read(skipBuffer, 2048);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +        source.close();, +        sink.close();, +      long read = in.read(skipBuffer, 2048);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java, +  @Override public void write(OkBuffer source, long byteCount), +    buffer.write(source, byteCount);, +    emitCompleteSegments();, +  public void write(ByteString byteString) throws IOException {, +    emitCompleteSegments();, +  public void writeUtf8(String string) throws IOException {, +    emitCompleteSegments();, +  public void write(byte[] data, int offset, int byteCount) throws IOException {, +    emitCompleteSegments();, +  public void writeByte(int b) throws IOException {, +    emitCompleteSegments();, +  public void writeShort(int s) throws IOException {, +    emitCompleteSegments();, +  public void writeInt(int i) throws IOException {, +    emitCompleteSegments();, +  void emitCompleteSegments() throws IOException {, +    sink.write(buffer, byteCount);, +        emitCompleteSegments();, +        emitCompleteSegments();, +        BufferedSink.this.flush();, +        BufferedSink.this.close();, +  @Override public void flush() throws IOException {, +      sink.write(buffer, buffer.byteCount);, +    sink.flush();, +  @Override public void close() throws IOException {, +    flush();, +    sink.close();, +  @Override public Sink deadline(Deadline deadline) {, +    sink.deadline(deadline);, +    return this;, +  }, +, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +        source.close();, +        sink.close();, +      long read = in.read(skipBuffer, 2048);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java, +  @Override public void write(OkBuffer source, long byteCount), +    buffer.write(source, byteCount);, +    emitCompleteSegments();, +  public void write(ByteString byteString) throws IOException {, +    emitCompleteSegments();, +  public void writeUtf8(String string) throws IOException {, +    emitCompleteSegments();, +  public void write(byte[] data, int offset, int byteCount) throws IOException {, +    emitCompleteSegments();, +  public void writeByte(int b) throws IOException {, +    emitCompleteSegments();, +  public void writeShort(int s) throws IOException {, +    emitCompleteSegments();, +  public void writeInt(int i) throws IOException {, +    emitCompleteSegments();, +  void emitCompleteSegments() throws IOException {, +    sink.write(buffer, byteCount);, +        emitCompleteSegments();, +        emitCompleteSegments();, +        BufferedSink.this.flush();, +        BufferedSink.this.close();, +  @Override public void flush() throws IOException {, +      sink.write(buffer, buffer.byteCount);, +    sink.flush();, +  @Override public void close() throws IOException {, +    flush();, +    sink.close();, +  @Override public Sink deadline(Deadline deadline) {, +    sink.deadline(deadline);, +    return this;, +  }, +, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java, +  @Override public long read(OkBuffer sink, long byteCount), +      long read = source.read(buffer, Segment.SIZE);, +    return buffer.read(sink, toRead);, +  public boolean exhausted() throws IOException {, +    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE) == -1;, +  void require(long byteCount) throws IOException {, +      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();, +    require(1);, +    require(byteCount);, +    require(2);, +    require(2);, +    require(4);, +    require(4);, +  public void skip(long byteCount) throws IOException {, +      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE) == -1) {, +  public long seek(byte b) throws IOException {, +      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();, +          long count = source.read(buffer, Segment.SIZE);, +          long count = source.read(buffer, Segment.SIZE);, +        BufferedSource.this.close();, +  @Override public Source deadline(Deadline deadline) {]