[+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java, +import java.util.ArrayList;, +import java.util.concurrent.CountDownLatch;, +import okhttp3.Call;, +import okhttp3.Callback;, +import okhttp3.internal.Util;, +    List<Call> networkRequests = new ArrayList<>(2);, +    List<Exception> failures = new ArrayList<>(2);, +    List<InetAddress> results = new ArrayList<>(5);, +, +    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);, +, +    if (includeIPv6) {, +      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);, +    }, +, +    executeRequests(hostname, networkRequests, results, failures);, +, +    if (!results.isEmpty()) {, +      return results;, +    }, +, +    return throwBestFailure(hostname, failures);, +  }, +, +  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,, +      List<Exception> failures, int type) {, +    Request request = buildRequest(hostname, type);, +    Response response = getCacheOnlyResponse(request);, +, +    if (response != null) {, +      processResponse(response, hostname, results, failures);, +    } else {, +      networkRequests.add(client.newCall(request));, +    }, +  }, +, +  private void executeRequests(final String hostname, List<Call> networkRequests,, +      final List<InetAddress> responses, final List<Exception> failures) {, +    final CountDownLatch latch = new CountDownLatch(networkRequests.size());, +, +    for (Call call : networkRequests) {, +      call.enqueue(new Callback() {, +        @Override public void onFailure(Call call, IOException e) {, +          synchronized (failures) {, +            failures.add(e);, +          }, +          latch.countDown();, +        }, +, +        @Override public void onResponse(Call call, Response response) {, +          processResponse(response, hostname, responses, failures);, +          latch.countDown();, +        }, +      });, +    }, +, +      latch.await();, +    } catch (InterruptedException e) {, +      failures.add(e);, +    }, +  }, +  private void processResponse(Response response, String hostname, List<InetAddress> results,, +      List<Exception> failures) {, +    try {, +      List<InetAddress> addresses = readResponse(hostname, response);, +      synchronized (results) {, +        results.addAll(addresses);, +      }, +      synchronized (failures) {, +        failures.add(e);, +      }, +    }, +  }, +, +  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures), +      throws UnknownHostException {, +    if (failures.size() == 0) {, +      throw new UnknownHostException(hostname);, +    }, +, +    Exception failure = failures.get(0);, +, +    if (failure instanceof UnknownHostException) {, +      throw (UnknownHostException) failure;, +    }, +, +    unknownHostException.initCause(failure);, +, +    for (int i = 1; i < failures.size(); i++) {, +      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));, +    }, +, +  private @Nullable Response getCacheOnlyResponse(Request request) {, +      try {, +        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();, +        Response cacheResponse = client.newCall(cacheRequest).execute();, +        if (cacheResponse.code() != 504) {, +          return cacheResponse;, +        }]