[+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java, +  /** Ensure a later toggle of the same index emits! */, +  @Test public void toggleIndexOffOn() throws IOException {, +, +    bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1., +    bytesIn.writeByte(0x81); // Remove index 1 from the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(1, hpackReader.headerCount);, +    assertTrue(hpackReader.getAndReset().isEmpty());, +, +    bytesIn.writeByte(0x81); // Add index 1 back to the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(1, hpackReader.headerCount);, +    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());, +  }, +, +  /** Check later toggle of the same index for large header sets. */, +  @Test public void toggleIndexOffBeyond64Entries() throws IOException {, +    int expectedHeaderCount = 65;, +, +    for (int i = 0; i < expectedHeaderCount; i++) {, +      bytesIn.writeByte(0x82 + i); // Copy static header 1 to the header table as index 1., +      bytesIn.writeByte(0x81); // Remove index 1 from the reference set., +    }, +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(expectedHeaderCount, hpackReader.headerCount);, +    assertTrue(hpackReader.getAndReset().isEmpty());, +, +    bytesIn.writeByte(0x81); // Add index 1 back to the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(expectedHeaderCount, hpackReader.headerCount);, +    assertHeaderReferenced(headerTableLength() - expectedHeaderCount);, +    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());, +  }, +, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java, +  /** Ensure a later toggle of the same index emits! */, +  @Test public void toggleIndexOffOn() throws IOException {, +, +    bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1., +    bytesIn.writeByte(0x81); // Remove index 1 from the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(1, hpackReader.headerCount);, +    assertTrue(hpackReader.getAndReset().isEmpty());, +, +    bytesIn.writeByte(0x81); // Add index 1 back to the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(1, hpackReader.headerCount);, +    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());, +  }, +, +  /** Check later toggle of the same index for large header sets. */, +  @Test public void toggleIndexOffBeyond64Entries() throws IOException {, +    int expectedHeaderCount = 65;, +, +    for (int i = 0; i < expectedHeaderCount; i++) {, +      bytesIn.writeByte(0x82 + i); // Copy static header 1 to the header table as index 1., +      bytesIn.writeByte(0x81); // Remove index 1 from the reference set., +    }, +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(expectedHeaderCount, hpackReader.headerCount);, +    assertTrue(hpackReader.getAndReset().isEmpty());, +, +    bytesIn.writeByte(0x81); // Add index 1 back to the reference set., +, +    hpackReader.readHeaders();, +    hpackReader.emitReferenceSet();, +    assertEquals(expectedHeaderCount, hpackReader.headerCount);, +    assertHeaderReferenced(headerTableLength() - expectedHeaderCount);, +    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java, +     * Set bit positions indicate {@code headerTable[pos]} was already emitted., +     */, +    BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();, +, +    /**, +        emittedReferencedHeaders.shiftLeft(entriesToEvict);, +      emittedReferencedHeaders.clear();, +        if (referencedHeaders.get(i) && !emittedReferencedHeaders.get(i)) {, +      emittedReferencedHeaders.clear();, +        int headerTableIndex = headerTableIndex(index);, +        if (!referencedHeaders.get(headerTableIndex)) { // When re-referencing, emit immediately., +          emittedHeaders.add(headerTable[headerTableIndex]);, +          emittedReferencedHeaders.set(headerTableIndex);]