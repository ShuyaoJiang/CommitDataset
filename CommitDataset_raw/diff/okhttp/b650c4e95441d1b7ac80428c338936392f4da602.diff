[+++ b/.gitignore, +++ b/.gitignore, +++ b/okhttp/build.gradle, +      'okhttp3.RealCall#getResponseWithInterceptorChain()',, +      'okhttp3.RealCall#redactedUrl()',, +      'okhttp3.RealCall#toLoggableString()',, +      'okhttp3.RealCall$AsyncCall#callsPerHost()',, +      'okhttp3.RealCall$AsyncCall#executeOn(java.util.concurrent.ExecutorService)',, +      'okhttp3.RealCall$AsyncCall#get()',, +      'okhttp3.RealCall$AsyncCall#host()',, +      'okhttp3.RealCall$AsyncCall#request()',, +      'okhttp3.RealCall$AsyncCall#reuseCallsPerHostFrom(okhttp3.RealCall$AsyncCall)',, +++ b/.gitignore, +++ b/okhttp/build.gradle, +      'okhttp3.RealCall#getResponseWithInterceptorChain()',, +      'okhttp3.RealCall#redactedUrl()',, +      'okhttp3.RealCall#toLoggableString()',, +      'okhttp3.RealCall$AsyncCall#callsPerHost()',, +      'okhttp3.RealCall$AsyncCall#executeOn(java.util.concurrent.ExecutorService)',, +      'okhttp3.RealCall$AsyncCall#get()',, +      'okhttp3.RealCall$AsyncCall#host()',, +      'okhttp3.RealCall$AsyncCall#request()',, +      'okhttp3.RealCall$AsyncCall#reuseCallsPerHostFrom(okhttp3.RealCall$AsyncCall)',, +++ /dev/null, +++ b/.gitignore, +++ b/okhttp/build.gradle, +      'okhttp3.RealCall#getResponseWithInterceptorChain()',, +      'okhttp3.RealCall#redactedUrl()',, +      'okhttp3.RealCall#toLoggableString()',, +      'okhttp3.RealCall$AsyncCall#callsPerHost()',, +      'okhttp3.RealCall$AsyncCall#executeOn(java.util.concurrent.ExecutorService)',, +      'okhttp3.RealCall$AsyncCall#get()',, +      'okhttp3.RealCall$AsyncCall#host()',, +      'okhttp3.RealCall$AsyncCall#request()',, +      'okhttp3.RealCall$AsyncCall#reuseCallsPerHostFrom(okhttp3.RealCall$AsyncCall)',, +++ /dev/null, +++ b/okhttp/src/main/java/okhttp3/RealCall.kt, +/*, + * Copyright (C) 2014 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package okhttp3, +, +import okhttp3.internal.NamedRunnable, +import okhttp3.internal.Util.closeQuietly, +import okhttp3.internal.cache.CacheInterceptor, +import okhttp3.internal.connection.ConnectInterceptor, +import okhttp3.internal.connection.Transmitter, +import okhttp3.internal.http.BridgeInterceptor, +import okhttp3.internal.http.CallServerInterceptor, +import okhttp3.internal.http.RealInterceptorChain, +import okhttp3.internal.http.RetryAndFollowUpInterceptor, +import okhttp3.internal.platform.Platform, +import okhttp3.internal.platform.Platform.Companion.INFO, +import okio.Timeout, +import java.io.IOException, +import java.io.InterruptedIOException, +import java.util.ArrayList, +import java.util.concurrent.ExecutorService, +import java.util.concurrent.RejectedExecutionException, +import java.util.concurrent.atomic.AtomicInteger, +, +internal class RealCall private constructor(, +  val client: OkHttpClient,, +  /** The application's original request unadulterated by redirects or auth headers.  */, +  val originalRequest: Request,, +  // TODO(egorand): Remove @JvmField once Dispatcher.java is converted to Kotlin, +  @JvmField val forWebSocket: Boolean, +) : Call {, +  /**, +   * There is a cycle between the [Call] and [Transmitter] that makes this awkward., +   * This is set after immediately after creating the call instance., +   */, +  private lateinit var transmitter: Transmitter, +, +  // Guarded by this., +  @get:Synchronized override var isExecuted: Boolean = false, +, +  override val isCanceled: Boolean, +    get() = transmitter.isCanceled, +, +  override fun request(): Request = originalRequest, +, +  override fun execute(): Response {, +    synchronized(this) {, +      check(!isExecuted) { "Already Executed" }, +      isExecuted = true, +    }, +    transmitter.timeoutEnter()]