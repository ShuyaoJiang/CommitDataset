[+++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +import okhttp3.internal.connection.RealConnectionPool;, +  public final RealConnectionPool connectionPool;, +    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());, +  public void noNewStreamsOnConnection() {, +    connection().noNewStreams();, +  public void responseBodyComplete(long bytesRead, IOException e) {, +      streamAllocation.responseBodyComplete(bytesRead, e);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +import okhttp3.internal.connection.RealConnectionPool;, +  public final RealConnectionPool connectionPool;, +    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());, +  public void noNewStreamsOnConnection() {, +    connection().noNewStreams();, +  public void responseBodyComplete(long bytesRead, IOException e) {, +      streamAllocation.responseBodyComplete(bytesRead, e);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public final RealConnectionPool connectionPool;, +  /**, +   * If true, no new streams can be created on this connection. Once true this is always true., +   * Guarded by {@link #connectionPool}., +   */, +  /** Prevent further streams from being created on this connection. */, +  public void noNewStreams() {, +    assert (!Thread.holdsLock(connectionPool));, +    synchronized (connectionPool) {, +      noNewStreams = true;, +    }, +  }, +, +      Http1Codec tunnelConnection = new Http1Codec(null, this, null, source, sink);, +      return new Http1Codec(client, this, transmitter, source, sink);, +        transmitter.responseBodyComplete(-1L, null);, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +import okhttp3.internal.connection.RealConnectionPool;, +  public final RealConnectionPool connectionPool;, +    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());, +  public void noNewStreamsOnConnection() {, +    connection().noNewStreams();, +  public void responseBodyComplete(long bytesRead, IOException e) {, +      streamAllocation.responseBodyComplete(bytesRead, e);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public final RealConnectionPool connectionPool;, +  /**, +   * If true, no new streams can be created on this connection. Once true this is always true., +   * Guarded by {@link #connectionPool}., +   */, +  /** Prevent further streams from being created on this connection. */, +  public void noNewStreams() {, +    assert (!Thread.holdsLock(connectionPool));, +    synchronized (connectionPool) {, +      noNewStreams = true;, +    }, +  }, +, +      Http1Codec tunnelConnection = new Http1Codec(null, this, null, source, sink);, +      return new Http1Codec(client, this, transmitter, source, sink);, +        transmitter.responseBodyComplete(-1L, null);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java, + *     <li>{@link RealConnection#noNewStreams} prevents the connection from being used for new, + *         streams in the future. Use this after a {@code Connection: close} header, or when the, + *         connection may be inconsistent., + *     <li>{@link #responseBodyComplete} releases the active stream from this allocation., + *         it before creating a subsequent stream with {@link #newStream}., +        candidate.noNewStreams();, +      return deallocate(false, true);, +  public void responseBodyComplete(long bytesRead, IOException e) {, +      if (codec == null) throw new IllegalStateException("codec == null");, +      socket = deallocate(false, true);, +  public RealConnection connection() {, +    synchronized (connectionPool) {, +  }, +      socket = deallocate(true, false);, +  private Socket deallocate(boolean released, boolean streamFinished) {, +            connection.noNewStreams = true;, +          connection.noNewStreams = true;, +        connection.noNewStreams = true;, +      socket = deallocate(false, true);, +    connection.noNewStreams = true;, +    Socket socket = transmitterReleaseConnection();, +++ b/okhttp/src/main/java/okhttp3/internal/Transmitter.java, +import okhttp3.internal.connection.RealConnectionPool;, +  public final RealConnectionPool connectionPool;, +    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());, +  public void noNewStreamsOnConnection() {, +    connection().noNewStreams();, +  public void responseBodyComplete(long bytesRead, IOException e) {, +      streamAllocation.responseBodyComplete(bytesRead, e);, +++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java, +  public final RealConnectionPool connectionPool;, +  /**, +   * If true, no new streams can be created on this connection. Once true this is always true., +   * Guarded by {@link #connectionPool}., +   */, +  /** Prevent further streams from being created on this connection. */, +  public void noNewStreams() {, +    assert (!Thread.holdsLock(connectionPool));, +    synchronized (connectionPool) {, +      noNewStreams = true;, +    }]