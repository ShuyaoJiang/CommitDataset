[+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  public void updateReadTimeout(int newTimeout) throws IOException {, +    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");, +    socket.setSoTimeout(newTimeout);, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  public void updateReadTimeout(int newTimeout) throws IOException {, +    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");, +    socket.setSoTimeout(newTimeout);, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  public void updateReadTimeout(int newTimeout) throws IOException {, +    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");, +    socket.setSoTimeout(newTimeout);, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java, +  /** Whether the connection has been established. */, +  boolean connected;, +, +    } else {, +      connection.updateReadTimeout(client.getReadTimeout());, +    policy.setSelectedProxy(connection.getRoute().getProxy());, +    connected = true;, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  public void updateReadTimeout(int newTimeout) throws IOException {, +    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");, +    socket.setSoTimeout(newTimeout);, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java, +  /** Whether the connection has been established. */, +  boolean connected;, +, +    } else {, +      connection.updateReadTimeout(client.getReadTimeout());, +    policy.setSelectedProxy(connection.getRoute().getProxy());, +    connected = true;, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java, +  private Proxy selectedProxy;, +, +    if (selectedProxy != null) {, +      return isValidNonDirectProxy(selectedProxy);, +    }, +, +    // This behavior is a bit odd (but is probably justified by the, +    // oddness of the APIs involved). Before a connection is established,, +    // this method will return true only if this connection was explicitly, +    // opened with a Proxy. We don't attempt to query the ProxySelector, +    // at all., +    return isValidNonDirectProxy(client.getProxy());, +  }, +, +  private static boolean isValidNonDirectProxy(Proxy proxy) {, +, +  @Override public final void setSelectedProxy(Proxy proxy) {, +    this.selectedProxy = proxy;, +  }, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  public void updateReadTimeout(int newTimeout) throws IOException {, +    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");, +    socket.setSoTimeout(newTimeout);, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;, +        }, +, +        if (!"Basic".equals(challenge.getScheme())) {, +          continue;]