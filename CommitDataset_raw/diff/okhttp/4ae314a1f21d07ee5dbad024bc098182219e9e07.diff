[+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java, +import com.squareup.okhttp.internal.http.StreamAllocation;, +    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);, +    streamAllocation.acquire(c1);, +  @Test public void leakedAllocation() throws Exception {, +    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);, +    pool.setCleanupRunnableForTest(emptyRunnable);, +, +    RealConnection c1 = newConnection(routeA1, 0L);, +    pool.put(c1);, +    allocateAndLeakAllocation(pool, c1);, +, +    awaitGarbageCollection();, +    assertEquals(0L, pool.cleanup(100L));, +    assertEquals(Collections.emptyList(), c1.allocations);, +, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +  }, +, +  /** Use a helper method so there's no hidden reference remaining on the stack. */, +  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {, +    StreamAllocation leak = new StreamAllocation(pool, connection.getRoute().getAddress());, +    leak.acquire(connection);, +  }, +, +  /**, +   * See FinalizationTester for discussion on how to best trigger GC in tests., +   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/, +   * java/lang/ref/FinalizationTester.java, +   */, +  private void awaitGarbageCollection() throws InterruptedException {, +    Runtime.getRuntime().gc();, +    Thread.sleep(100);, +    System.runFinalization();, +  }, +, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java, +import com.squareup.okhttp.internal.http.StreamAllocation;, +    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);, +    streamAllocation.acquire(c1);, +  @Test public void leakedAllocation() throws Exception {, +    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);, +    pool.setCleanupRunnableForTest(emptyRunnable);, +, +    RealConnection c1 = newConnection(routeA1, 0L);, +    pool.put(c1);, +    allocateAndLeakAllocation(pool, c1);, +, +    awaitGarbageCollection();, +    assertEquals(0L, pool.cleanup(100L));, +    assertEquals(Collections.emptyList(), c1.allocations);, +, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +  }, +, +  /** Use a helper method so there's no hidden reference remaining on the stack. */, +  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {, +    StreamAllocation leak = new StreamAllocation(pool, connection.getRoute().getAddress());, +    leak.acquire(connection);, +  }, +, +  /**, +   * See FinalizationTester for discussion on how to best trigger GC in tests., +   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/, +   * java/lang/ref/FinalizationTester.java, +   */, +  private void awaitGarbageCollection() throws InterruptedException {, +    Runtime.getRuntime().gc();, +    Thread.sleep(100);, +    System.runFinalization();, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java, +import com.squareup.okhttp.internal.Internal;, +import com.squareup.okhttp.internal.http.StreamAllocation;, +import java.lang.ref.Reference;, +      if (connection.allocations.isEmpty()) total++;, +  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {, +      if (connection.allocations.size() < connection.allocationLimit(), +        streamAllocation.acquire(connection);, +        if (connection.allocations.isEmpty()) {, +        if (pruneAndGetAllocationCount(connection, now) > 0) {, +  /**, +   * Prunes any leaked allocations and then returns the number of remaining live allocations on, +   * {@code connection}. Allocations are leaked if the connection is tracking them but the, +   * application code has abandoned them. Leak detection is imprecise and relies on garbage, +   * collection., +   */, +  private int pruneAndGetAllocationCount(RealConnection connection, long now) {, +    List<Reference<StreamAllocation>> references = connection.allocations;, +    for (int i = 0; i < references.size(); ) {, +      Reference<StreamAllocation> reference = references.get(i);, +, +      if (reference.get() != null) {, +        i++;, +        continue;, +      }, +, +      // We've discovered a leaked allocation. This is an application bug., +      Internal.logger.warning("A connection to " + connection.getRoute().getAddress().url()]