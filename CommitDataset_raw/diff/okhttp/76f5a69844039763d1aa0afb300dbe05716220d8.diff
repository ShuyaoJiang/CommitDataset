[+++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt, +    fun get(url: String): HttpUrl = Builder().parse(null, url).build(), +    fun get(url: URL): HttpUrl? = parse(url.toString()), +    fun get(uri: URI): HttpUrl? = parse(uri.toString()), +++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt, +    fun get(url: String): HttpUrl = Builder().parse(null, url).build(), +    fun get(url: URL): HttpUrl? = parse(url.toString()), +    fun get(uri: URI): HttpUrl? = parse(uri.toString()), +++ b/okhttp/src/main/java/okhttp3/Protocol.kt, +    fun get(protocol: String): Protocol {, +++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt, +    fun get(url: String): HttpUrl = Builder().parse(null, url).build(), +    fun get(url: URL): HttpUrl? = parse(url.toString()), +    fun get(uri: URI): HttpUrl? = parse(uri.toString()), +++ b/okhttp/src/main/java/okhttp3/Protocol.kt, +    fun get(protocol: String): Protocol {, +++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt, +  fun get(request: Request, proxyType: Proxy.Type): String {, +++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt, +    fun get(url: String): HttpUrl = Builder().parse(null, url).build(), +    fun get(url: URL): HttpUrl? = parse(url.toString()), +    fun get(uri: URI): HttpUrl? = parse(uri.toString()), +++ b/okhttp/src/main/java/okhttp3/Protocol.kt, +    fun get(protocol: String): Protocol {, +++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt, +  fun get(request: Request, proxyType: Proxy.Type): String {, +++ b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt, +import okhttp3.tls.HeldCertificate, +import okio.Buffer, +import okio.Timeout, +import java.io.IOException, +import java.net.InetAddress, +import java.net.InetSocketAddress, +import java.net.Socket, +import java.net.URI, +import java.net.URL, +import java.nio.charset.Charset, +import java.security.Principal, +import java.security.cert.Certificate, +import java.security.cert.X509Certificate, +import java.time.Instant, +import java.util.Date, +import java.util.concurrent.ExecutorService, +import java.util.concurrent.Executors, +import javax.net.ssl.SSLSocket, +  fun authenticator() {, +    val authenticator = object : Authenticator {, +      override fun authenticate(route: Route?, response: Response): Request? = TODO(), +    }, +  }, +, +  @Test @Ignore, +  fun call() {, +    val call = object : Call {, +      override fun request(): Request = TODO(), +      override fun execute(): Response = TODO(), +      override fun enqueue(responseCallback: Callback) = TODO(), +      override fun cancel() = TODO(), +      override val isExecuted: Boolean get() = TODO(), +      override val isCanceled: Boolean get() = TODO(), +      override fun timeout(): Timeout = TODO(), +      override fun clone(): Call = TODO(), +    }, +  }, +, +  @Test @Ignore, +  fun callback() {, +    val callback = object : Callback {, +      override fun onFailure(call: Call, e: IOException) = TODO(), +      override fun onResponse(call: Call, response: Response) = TODO(), +    }, +  }, +, +  @Test @Ignore, +  fun certificatePinner() {, +    val heldCertificate: HeldCertificate = HeldCertificate.Builder().build(), +    val certificate: X509Certificate = heldCertificate.certificate(), +    val certificatePinner: CertificatePinner = CertificatePinner.Builder().build(), +    val certificates: List<Certificate> = listOf(), +    certificatePinner.check("", listOf(certificate)), +    certificatePinner.check("", certificate, certificate), +    val pin: String = CertificatePinner.pin(certificate), +    val default: CertificatePinner = CertificatePinner.DEFAULT, +  }, +, +  @Test @Ignore, +  fun certificatePinnerBuilder() {, +    val builder: CertificatePinner.Builder = CertificatePinner.Builder(), +    builder.add("", "pin1", "pin2"), +  }, +, +  @Test @Ignore, +  fun challenge() {, +    var challenge = Challenge("", mapOf<String?, String>("" to "")), +    challenge = Challenge("", ""), +    val scheme: String = challenge.scheme(), +    val authParams: Map<String?, String> = challenge.authParams(), +    val realm: String? = challenge.realm(), +    val charset: Charset = challenge.charset(), +    val utf8: Challenge = challenge.withCharset(Charsets.UTF_8)]