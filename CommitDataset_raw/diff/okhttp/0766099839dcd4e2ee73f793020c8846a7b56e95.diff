[+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +import static okhttp3.internal.Util.closeQuietly;, +        closeQuietly(serverSocket);, +          closeQuietly(s.next());, +          closeQuietly(s.next());, +    closeQuietly(sink);, +    closeQuietly(source);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +import static okhttp3.internal.Util.closeQuietly;, +        closeQuietly(serverSocket);, +          closeQuietly(s.next());, +          closeQuietly(s.next());, +    closeQuietly(sink);, +    closeQuietly(source);, +++ b/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java, +import java.net.SocketTimeoutException;, +import java.util.concurrent.TimeUnit;, +import okhttp3.internal.ws.WebSocketProtocol;, +import okhttp3.internal.ws.WebSocketRecorder;, +import okhttp3.mockwebserver.Dispatcher;, +import okhttp3.mockwebserver.RecordedRequest;, +import okhttp3.mockwebserver.SocketPolicy;, +import okio.Buffer;, +import static org.junit.Assert.assertFalse;, +      .writeTimeout(500, TimeUnit.MILLISECONDS), +      .readTimeout(500, TimeUnit.MILLISECONDS), +    WebSocket webSocket = newWebSocket();, +    webSocket.send("Hello, WebSockets!");, +    WebSocket webSocket = newWebSocket();, +    webSocket.send(ByteString.encodeUtf8("Hello!"));, +    WebSocket webSocket = newWebSocket();, +      webSocket.send((String) null);, +    WebSocket webSocket = newWebSocket();, +      webSocket.send((ByteString) null);, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    WebSocket webSocket = newWebSocket();, +    webSocket.send("abc");, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +    newWebSocket();, +  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {, +    webServer.enqueue(new MockResponse(), +        .setSocketPolicy(SocketPolicy.NO_RESPONSE));, +, +    WebSocket webSocket = newWebSocket();, +, +    clientListener.assertFailure(SocketTimeoutException.class, "timeout");, +    assertFalse(webSocket.close(1000, null));, +  }, +, +  /**, +   * There's no read timeout when reading the first byte of a new frame. But as soon as we start, +   * reading a frame we enable the read timeout. In this test we have the server returning the first, +   * byte of a frame but no more frames., +   */, +  @Test public void readTimeoutAppliesWithinFrames() throws IOException {, +    webServer.setDispatcher(new Dispatcher() {, +      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {, +        return upgradeResponse(request), +            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame., +            .removeHeader("Content-Length"), +            .setSocketPolicy(SocketPolicy.KEEP_OPEN);, +      }, +    });, +, +    WebSocket webSocket = newWebSocket();, +    clientListener.assertOpen();, +, +    clientListener.assertFailure(SocketTimeoutException.class, "timeout");, +    assertFalse(webSocket.close(1000, null));, +  }, +, +  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {, +    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));, +    newWebSocket();, +, +    clientListener.assertOpen();, +    WebSocket server = serverListener.assertOpen();, +, +    // Sleep longer than the HTTP client's read timeout., +    Thread.sleep(client.readTimeoutMillis() + 500);, +, +    server.send("abc");, +    clientListener.assertTextMessage("abc");, +  }, +, +  private MockResponse upgradeResponse(RecordedRequest request) {, +    String key = request.getHeader("Sec-WebSocket-Key");, +    return new MockResponse(), +        .setStatus("HTTP/1.1 101 Switching Protocols"), +        .setHeader("Connection", "Upgrade")]