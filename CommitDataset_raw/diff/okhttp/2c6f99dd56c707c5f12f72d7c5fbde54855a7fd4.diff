[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +, +  public static int reverseBytesShort(short s) {, +    int i = s & 0xffff;, +    return (i & 0xff00) >>> 8, +        |  (i & 0x00ff) << 8;, +  }, +, +  public static int reverseBytesInt(int i) {, +    return (i & 0xff000000) >>> 24, +        |  (i & 0x00ff0000) >>> 8, +        |  (i & 0x0000ff00) << 8, +        |  (i & 0x000000ff) << 24;, +  }, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +, +  public static int reverseBytesShort(short s) {, +    int i = s & 0xffff;, +    return (i & 0xff00) >>> 8, +        |  (i & 0x00ff) << 8;, +  }, +, +  public static int reverseBytesInt(int i) {, +    return (i & 0xff000000) >>> 24, +        |  (i & 0x00ff0000) >>> 8, +        |  (i & 0x0000ff00) << 8, +        |  (i & 0x000000ff) << 24;, +  }, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +/*, + * Copyright (C) 2014 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package com.squareup.okhttp.internal.bytes;, +, +import java.io.EOFException;, +import java.io.IOException;, +import java.util.zip.CRC32;, +import java.util.zip.Inflater;, +, +public final class GzipSource implements Source {, +  private static final byte FHCRC = 1;, +  private static final byte FEXTRA = 2;, +  private static final byte FNAME = 3;, +  private static final byte FCOMMENT = 4;, +, +  private static final byte SECTION_HEADER = 0;, +  private static final byte SECTION_BODY = 1;, +  private static final byte SECTION_TRAILER = 2;, +  private static final byte SECTION_DONE = 3;, +, +  /** The current section. Always progresses forward. */, +  private int section = SECTION_HEADER;, +, +  /**, +   * This buffer is carefully shared between this source and the InflaterSource, +   * it wraps. In particular, this source may read more bytes than necessary for, +   * the GZIP header; the InflaterSource will pick those up when it starts to, +   * read the compressed body. And the InflaterSource may read more bytes than, +   * necessary for the compressed body, and this source will pick those up for, +   * the GZIP trailer., +   */, +  private final OkBuffer buffer = new OkBuffer();, +, +  /**, +   * Our source should yield a GZIP header (which we consume directly), followed, +   * by deflated bytes (which we consume via an InflaterSource), followed by a, +   * GZIP trailer (which we also consume directly)., +   */, +  private final Source source;, +, +  /** The inflater used to decompress the deflated body. */, +  private final Inflater inflater;, +, +  /**, +   * The inflater source takes care of moving data between compressed source and, +   * decompressed sink buffers., +   */, +  private final InflaterSource inflaterSource;, +, +  /** Checksum used to check both the GZIP header and decompressed body. */, +  private final CRC32 crc = new CRC32();, +, +  public GzipSource(Source source) throws IOException {, +    this.inflater = new Inflater(true);, +    this.source = source;, +    this.inflaterSource = new InflaterSource(source, inflater, buffer);, +  }, +]