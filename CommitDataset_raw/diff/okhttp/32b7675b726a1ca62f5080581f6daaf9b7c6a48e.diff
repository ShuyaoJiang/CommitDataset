[+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java, +      if (HttpEngine.hasBody(response.getResponse()), +          && response.getResponse().code() >= HTTP_BAD_REQUEST) {, +        return response.getResponse().body().byteStream();, +    return response.getResponse().body().byteStream();, +    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,, +        requestBody, priorResponse);, +        httpEngine.readResponse(false, null);, +++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java, +      if (HttpEngine.hasBody(response.getResponse()), +          && response.getResponse().code() >= HTTP_BAD_REQUEST) {, +        return response.getResponse().body().byteStream();, +    return response.getResponse().body().byteStream();, +    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,, +        requestBody, priorResponse);, +        httpEngine.readResponse(false, null);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java, +    engine = new HttpEngine(client, request, false, false, null, null, null, null);, +        engine.readResponse(forWebSocket, request.body());, +        return response;, +      engine = new HttpEngine(client, request, false, false, connection, null, null, response);, +++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java, +      if (HttpEngine.hasBody(response.getResponse()), +          && response.getResponse().code() >= HTTP_BAD_REQUEST) {, +        return response.getResponse().body().byteStream();, +    return response.getResponse().body().byteStream();, +    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,, +        requestBody, priorResponse);, +        httpEngine.readResponse(false, null);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java, +    engine = new HttpEngine(client, request, false, false, null, null, null, null);, +        engine.readResponse(forWebSocket, request.body());, +        return response;, +      engine = new HttpEngine(client, request, false, false, connection, null, null, response);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      if (contentLength == -1L) {, +        contentLength = 0L;, +      }, +      body.close();, +++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java, +      if (HttpEngine.hasBody(response.getResponse()), +          && response.getResponse().code() >= HTTP_BAD_REQUEST) {, +        return response.getResponse().body().byteStream();, +    return response.getResponse().body().byteStream();, +    return new HttpEngine(engineClient, request, bufferRequestBody, true, connection, null,, +        requestBody, priorResponse);, +        httpEngine.readResponse(false, null);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java, +    engine = new HttpEngine(client, request, false, false, null, null, null, null);, +        engine.readResponse(forWebSocket, request.body());, +        return response;, +      engine = new HttpEngine(client, request, false, false, connection, null, null, response);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      if (contentLength == -1L) {, +        contentLength = 0L;, +      }, +      body.close();, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java, +import com.squareup.okhttp.RequestBody;, +  private final boolean callerWritesRequestBody;, +   * @param request the HTTP request without a body. The body must be written via the engine's, +   *     request body stream., +   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction, +   *     model where control flow is returned to the calling application to write the request body, +   *     before the response body is readable., +   * @param connection the connection used for an intermediate response immediately prior to this, +   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the, +   *     connection and must release it when it is unneeded., +   * @param routeSelector the route selector used for a failed attempt immediately preceding this, +   *     attempt, or null if this request doesn't, +      boolean callerWritesRequestBody, Connection connection, RouteSelector routeSelector,, +      RetryableSink requestBodyOut, Response priorResponse) {, +    this.callerWritesRequestBody = callerWritesRequestBody;, +      // If the caller's control flow writes the request body, we need to create that stream, +      // immediately. And that means we need to immediately write the request headers, so we can, +      // start streaming the request body. (We may already have a request body if we're retrying a, +      // failed POST.), +      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {, +            transport.writeRequestHeaders(networkRequest);, +          transport.writeRequestHeaders(networkRequest);, +          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);, +      userResponse = unzip(userResponse);, +    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,, +        connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);, +    if (userResponse == null) {, +    closeQuietly(userResponse.body());, +   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip, +   * was both offered by OkHttp and used by the origin server., +   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the, +   * Content-Encoding header to prevent the application from attempting to double decompress. We, +   * strip the Content-Length header because it is the length of the compressed content, but the, +   * application is only interested in the length of the uncompressed content., +   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not, +   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we, +   * attempt to decompress the zero-byte source., +  private Response unzip(final Response response) throws IOException {, +    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {, +      return response;, +, +    if (response.body() == null) {]