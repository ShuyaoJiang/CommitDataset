[+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +import java.net.ProtocolException;, +  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {, +    server.useHttps(sslContext.getSocketFactory(), true);, +    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));, +    for (int i = 0; i < 21; i++) {, +      server.enqueue(new MockResponse(), +          .setResponseCode(407), +          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""), +          .addHeader("Connection: close"));, +    }, +, +    client = client.newBuilder(), +        .sslSocketFactory(sslContext.getSocketFactory()), +        .proxy(server.toProxyAddress()), +        .proxyAuthenticator(new RecordingOkAuthenticator("password")), +        .hostnameVerifier(new RecordingHostnameVerifier()), +        .build();, +, +    Request request = new Request.Builder(), +        .url("https://android.com/foo"), +        .build();, +    try {, +      client.newCall(request).execute();, +      fail();, +    } catch (ProtocolException expected) {, +    }, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +import java.net.ProtocolException;, +  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {, +    server.useHttps(sslContext.getSocketFactory(), true);, +    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));, +    for (int i = 0; i < 21; i++) {, +      server.enqueue(new MockResponse(), +          .setResponseCode(407), +          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""), +          .addHeader("Connection: close"));, +    }, +, +    client = client.newBuilder(), +        .sslSocketFactory(sslContext.getSocketFactory()), +        .proxy(server.toProxyAddress()), +        .proxyAuthenticator(new RecordingOkAuthenticator("password")), +        .hostnameVerifier(new RecordingHostnameVerifier()), +        .build();, +, +    Request request = new Request.Builder(), +        .url("https://android.com/foo"), +        .build();, +    try {, +      client.newCall(request).execute();, +      fail();, +    } catch (ProtocolException expected) {, +    }, +  }, +, +++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java, +import java.net.ProtocolException;, +        if (route.requiresTunnel()) {, +          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,, +              connectionSpecSelector);, +        } else {, +          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +        }, +  /**, +   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a, +   * proxy server can issue an auth challenge and then close the connection., +   */, +  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,, +      ConnectionSpecSelector connectionSpecSelector) throws IOException {, +    Request tunnelRequest = createTunnelRequest();, +    HttpUrl url = tunnelRequest.url();, +    int attemptedConnections = 0;, +    int maxAttempts = 21;, +    while (true) {, +      if (++attemptedConnections > maxAttempts) {, +        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);, +      }, +, +      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);, +, +      if (tunnelRequest == null) break; // Tunnel successfully created., +, +      // The proxy decided to close the connection after an auth challenge. We need to create a new, +      // connection, but this time with the auth credentials., +      closeQuietly(rawSocket);, +      rawSocket = null;, +      sink = null;, +      source = null;, +    }, +, +    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);, +  }, +, +  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,, +      ConnectionSpecSelector connectionSpecSelector) throws IOException {, +    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);]