[+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +      Headers headers = httpHeaders.build();, +      MockResponse peek = dispatcher.peek();, +      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {, +        String contentLengthString = headers.get("content-length");, +        long byteCount = contentLengthString != null, +            ? Long.parseLong(contentLengthString), +            : Long.MAX_VALUE;, +        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);, +      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +      Headers headers = httpHeaders.build();, +      MockResponse peek = dispatcher.peek();, +      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {, +        String contentLengthString = headers.get("content-length");, +        long byteCount = contentLengthString != null, +            ? Long.parseLong(contentLengthString), +            : Long.MAX_VALUE;, +        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);, +      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,, +++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import okhttp3.RecordingEventListener.RequestBodyEnd;, +import okio.BufferedSink;, +  @Test public void requestBodyFailHttp1OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));, +    requestBodyFail();, +  }, +, +  @Test public void requestBodyFailHttp2OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));, +    requestBodyFail();, +  }, +, +  @Test public void requestBodyFailHttp() throws IOException {, +    requestBodyFail();, +  }, +, +  private void requestBodyFail() throws IOException {, +    // Stream a 8 MiB body so the disconnect will happen before the server has read everything., +    RequestBody requestBody = new RequestBody() {, +      @Override public MediaType contentType() {, +        return MediaType.parse("text/plain");, +      }, +, +      @Override public long contentLength() throws IOException {, +        return 1024 * 8192;, +      }, +, +      @Override public void writeTo(BufferedSink sink) throws IOException {, +        for (int i = 0; i < 1024; i++) {, +          sink.write(new byte[8192]);, +          sink.flush();, +        }, +      }, +    };, +, +    server.enqueue(new MockResponse(), +        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .post(requestBody), +        .build());, +    try {, +      call.execute();, +      fail();, +    } catch (IOException expected) {, +    }, +, +    RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);, +    assertNotNull(responseBodyEnd.throwable);, +  }, +]