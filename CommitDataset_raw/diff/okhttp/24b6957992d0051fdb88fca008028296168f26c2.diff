[+++ b/okio/src/main/java/okio/RealBufferedSink.java, +    // Emit buffered data to the underlying sink. If this fails, we still need, +    // to close the sink; otherwise we risk leaking resources., +    } catch (Throwable e) {, +    try {, +    } catch (Throwable e) {, +      if (thrown == null) thrown = e;, +    }, +    if (thrown != null) Util.sneakyRethrow(thrown);, +++ b/okio/src/main/java/okio/RealBufferedSink.java, +    // Emit buffered data to the underlying sink. If this fails, we still need, +    // to close the sink; otherwise we risk leaking resources., +    } catch (Throwable e) {, +    try {, +    } catch (Throwable e) {, +      if (thrown == null) thrown = e;, +    }, +    if (thrown != null) Util.sneakyRethrow(thrown);, +++ b/okio/src/main/java/okio/Util.java, +, +  /**, +   * Throws {@code t}, even if the declared throws clause doesn't permit it., +   * This is a terrible – but terribly convenient – hack that makes it easy to, +   * catch and rethrow exceptions after cleanup. See Java Puzzlers #43., +   */, +  public static void sneakyRethrow(Throwable t) {, +    Util.<Error>sneakyThrow2(t);, +  }, +, +  @SuppressWarnings("unchecked"), +  private static <T extends Throwable> void sneakyThrow2(Throwable t) throws T {, +    throw (T) t;, +  }, +++ b/okio/src/main/java/okio/RealBufferedSink.java, +    // Emit buffered data to the underlying sink. If this fails, we still need, +    // to close the sink; otherwise we risk leaking resources., +    } catch (Throwable e) {, +    try {, +    } catch (Throwable e) {, +      if (thrown == null) thrown = e;, +    }, +    if (thrown != null) Util.sneakyRethrow(thrown);, +++ b/okio/src/main/java/okio/Util.java, +, +  /**, +   * Throws {@code t}, even if the declared throws clause doesn't permit it., +   * This is a terrible – but terribly convenient – hack that makes it easy to, +   * catch and rethrow exceptions after cleanup. See Java Puzzlers #43., +   */, +  public static void sneakyRethrow(Throwable t) {, +    Util.<Error>sneakyThrow2(t);, +  }, +, +  @SuppressWarnings("unchecked"), +  private static <T extends Throwable> void sneakyThrow2(Throwable t) throws T {, +    throw (T) t;, +  }, +++ b/okio/src/test/java/okio/RealBufferedSinkTest.java, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +  @Test public void closeEmitsBufferedBytes() throws IOException {, +    OkBuffer sink = new OkBuffer();, +    BufferedSink bufferedSink = new RealBufferedSink(sink);, +    bufferedSink.writeByte('a');, +    bufferedSink.close();, +    assertEquals('a', sink.readByte());, +  }, +, +  @Test public void closeWithExceptionWhenWriting() throws IOException {, +    MockSink mockSink = new MockSink();, +    mockSink.scheduleThrow(0, new IOException());, +    BufferedSink bufferedSink = new RealBufferedSink(mockSink);, +    bufferedSink.writeByte('a');, +    try {, +      bufferedSink.close();, +      fail();, +    } catch (IOException expected) {, +    }, +    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");, +  }, +, +  @Test public void closeWithExceptionWhenClosing() throws IOException {, +    MockSink mockSink = new MockSink();, +    mockSink.scheduleThrow(1, new IOException());, +    BufferedSink bufferedSink = new RealBufferedSink(mockSink);, +    bufferedSink.writeByte('a');, +    try {, +      bufferedSink.close();, +      fail();, +    } catch (IOException expected) {, +    }, +    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");, +  }, +, +  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {, +    MockSink mockSink = new MockSink();, +    mockSink.scheduleThrow(0, new IOException("first"));, +    mockSink.scheduleThrow(1, new IOException("second"));]