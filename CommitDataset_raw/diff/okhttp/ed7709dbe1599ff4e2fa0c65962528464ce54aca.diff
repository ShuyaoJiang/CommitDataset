[+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +        throttledTransfer(response, socket, body, sink, body.size(), false);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +        throttledTransfer(response, socket, body, sink, body.size(), false);, +++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import okhttp3.RecordingEventListener.ResponseBodyEnd;, +import okio.Buffer;, +  @Test public void responseBodyFailHttp1OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));, +    responseBodyFail(Protocol.HTTP_1_1);, +  }, +, +  @Test public void responseBodyFailHttp2OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));, +    responseBodyFail(Protocol.HTTP_2);, +  }, +, +  @Test public void responseBodyFailHttp() throws IOException {, +    responseBodyFail(Protocol.HTTP_1_1);, +  }, +, +  private void responseBodyFail(Protocol expectedProtocol) throws IOException {, +    // Use a 2 MiB body so the disconnect won't happen until the client has read some data., +    int responseBodySize = 2 * 1024 * 1024; // 2 MiB, +    server.enqueue(new MockResponse(), +        .setBody(new Buffer().write(new byte[responseBodySize])), +        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .build());, +    Response response = call.execute();, +    assertEquals(expectedProtocol, response.protocol());, +    try {, +      response.body.string();, +      fail();, +    } catch (IOException expected) {, +    }, +, +    ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);, +    assertNotNull(responseBodyEnd.throwable);, +  }, +, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +        throttledTransfer(response, socket, body, sink, body.size(), false);, +++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import okhttp3.RecordingEventListener.ResponseBodyEnd;, +import okio.Buffer;, +  @Test public void responseBodyFailHttp1OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));, +    responseBodyFail(Protocol.HTTP_1_1);, +  }, +, +  @Test public void responseBodyFailHttp2OverHttps() throws IOException {, +    enableTlsWithTunnel(false);, +    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));, +    responseBodyFail(Protocol.HTTP_2);, +  }, +, +  @Test public void responseBodyFailHttp() throws IOException {, +    responseBodyFail(Protocol.HTTP_1_1);, +  }, +, +  private void responseBodyFail(Protocol expectedProtocol) throws IOException {, +    // Use a 2 MiB body so the disconnect won't happen until the client has read some data., +    int responseBodySize = 2 * 1024 * 1024; // 2 MiB, +    server.enqueue(new MockResponse(), +        .setBody(new Buffer().write(new byte[responseBodySize])), +        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .build());, +    Response response = call.execute();, +    assertEquals(expectedProtocol, response.protocol());, +    try {, +      response.body.string();, +      fail();, +    } catch (IOException expected) {, +    }, +, +    ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);, +    assertNotNull(responseBodyEnd.throwable);, +  }, +, +++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java, +import okio.Buffer;, +    @Override public long read(Buffer sink, long byteCount) throws IOException {, +      try {, +        return delegate().read(sink, byteCount);, +      } catch (IOException e) {, +        endOfInput(e);, +        throw e;, +      }, +    }, +, +      endOfInput(null);]