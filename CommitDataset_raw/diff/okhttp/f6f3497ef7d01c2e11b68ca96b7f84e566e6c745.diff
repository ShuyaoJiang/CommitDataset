[+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java, +  @Override public String toString() {, +    StringBuilder result = new StringBuilder();, +    for (int i = 0; i < size(); i++) {, +      result.append(name(i)).append(": ").append(value(i)).append("\n");, +    }, +    return result.toString();, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java, +  @Override public String toString() {, +    StringBuilder result = new StringBuilder();, +    for (int i = 0; i < size(); i++) {, +      result.append(name(i)).append(": ").append(value(i)).append("\n");, +    }, +    return result.toString();, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java, +  protected final OutputStream cacheBody;, +++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java, +  @Override public String toString() {, +    StringBuilder result = new StringBuilder();, +    for (int i = 0; i < size(); i++) {, +      result.append(name(i)).append(": ").append(value(i)).append("\n");, +    }, +    return result.toString();, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java, +  protected final OutputStream cacheBody;, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java, +++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java, +  @Override public String toString() {, +    StringBuilder result = new StringBuilder();, +    for (int i = 0; i < size(); i++) {, +      result.append(name(i)).append(": ").append(value(i)).append("\n");, +    }, +    return result.toString();, +  }, +, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java, +  protected final OutputStream cacheBody;, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java, +import com.squareup.okhttp.Protocol;, +import com.squareup.okhttp.internal.Util;, +import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;, +, +    return new SpdyInputStream(stream, cacheRequest, httpEngine);, +    return true; // SPDY sockets are always reusable., +, +  /** An HTTP message body terminated by the end of the underlying stream. */, +  private static class SpdyInputStream extends AbstractHttpInputStream {, +    private final SpdyStream stream;, +    private boolean inputExhausted;, +, +    SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine), +        throws IOException {, +      super(stream.getInputStream(), httpEngine, cacheRequest);, +      this.stream = stream;, +    }, +, +    @Override public int read(byte[] buffer, int offset, int count) throws IOException {, +      checkOffsetAndCount(buffer.length, offset, count);, +      checkNotClosed();, +      if (in == null || inputExhausted) {, +        return -1;, +      }, +      int read = in.read(buffer, offset, count);, +      if (read == -1) {, +        inputExhausted = true;, +        endOfInput();, +        return -1;, +      }, +      cacheWrite(buffer, offset, read);, +      return read;, +    }, +, +    @Override public int available() throws IOException {, +      checkNotClosed();, +      return in == null ? 0 : in.available();, +    }, +, +    @Override public void close() throws IOException {, +      if (closed) return;, +, +      if (!inputExhausted && cacheBody != null) {, +        discardStream(); // Could make inputExhausted true!, +      }, +, +      closed = true;, +, +      if (!inputExhausted) {, +        stream.closeLater(ErrorCode.CANCEL);, +        unexpectedEndOfInput();, +      }, +    }, +, +    private boolean discardStream() {]