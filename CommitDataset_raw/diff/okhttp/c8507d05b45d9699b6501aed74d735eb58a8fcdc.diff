[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java, +  public boolean exhausted(Deadline deadline) throws IOException {, +    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, deadline) == -1;, +  public int readShortLe() throws IOException {, +    require(2, Deadline.NONE);, +    return buffer.readShortLe();, +  }, +, +  public int readIntLe() throws IOException {, +    require(4, Deadline.NONE);, +    return buffer.readIntLe();, +  }, +, +  /**, +   * Returns the index of {@code b} in the buffer, refilling it if necessary, +   * until it is found. This reads an unbounded number of bytes into the buffer., +   */, +  public long seek(byte b, Deadline deadline) throws IOException {, +    long start = 0;, +    long index;, +    while ((index = buffer.indexOf(b, start)) == -1) {, +      start = buffer.byteCount;, +      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();, +    }, +    return index;, +  }, +, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java, +  public boolean exhausted(Deadline deadline) throws IOException {, +    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, deadline) == -1;, +  public int readShortLe() throws IOException {, +    require(2, Deadline.NONE);, +    return buffer.readShortLe();, +  }, +, +  public int readIntLe() throws IOException {, +    require(4, Deadline.NONE);, +    return buffer.readIntLe();, +  }, +, +  /**, +   * Returns the index of {@code b} in the buffer, refilling it if necessary, +   * until it is found. This reads an unbounded number of bytes into the buffer., +   */, +  public long seek(byte b, Deadline deadline) throws IOException {, +    long start = 0;, +    long index;, +    while ((index = buffer.indexOf(b, start)) == -1) {, +      start = buffer.byteCount;, +      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();, +    }, +    return index;, +  }, +, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java, +  private final BufferedSource source;, +    this.source = new BufferedSource(source, new OkBuffer());, +    this.inflaterSource = new InflaterSource(this.source, inflater);, +    source.require(10, deadline);, +    byte flags = source.buffer.getByte(3);, +    if (fhcrc) updateCrc(source.buffer, 0, 10);, +    short id1id2 = source.readShort();, +    source.skip(8, deadline);, +      source.require(2, deadline);, +      if (fhcrc) updateCrc(source.buffer, 0, 2);, +      int xlen = source.buffer.readShortLe() & 0xffff;, +      source.require(xlen, deadline);, +      if (fhcrc) updateCrc(source.buffer, 0, xlen);, +      source.skip(xlen, deadline);, +      long index = source.seek((byte) 0, deadline);, +      if (fhcrc) updateCrc(source.buffer, 0, index + 1);, +      source.buffer.skip(index + 1);, +      long index = source.seek((byte) 0, deadline);, +      if (fhcrc) updateCrc(source.buffer, 0, index + 1);, +      source.skip(index + 1, deadline);, +      checkEqual("FHCRC", source.readShortLe(), (short) crc.getValue());, +    checkEqual("CRC", source.readIntLe(), (int) crc.getValue());, +    checkEqual("ISIZE", source.readIntLe(), inflater.getTotalOut());, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java, +  public boolean exhausted(Deadline deadline) throws IOException {, +    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, deadline) == -1;, +  public int readShortLe() throws IOException {, +    require(2, Deadline.NONE);, +    return buffer.readShortLe();, +  }, +, +  public int readIntLe() throws IOException {, +    require(4, Deadline.NONE);, +    return buffer.readIntLe();, +  }, +, +  /**, +   * Returns the index of {@code b} in the buffer, refilling it if necessary, +   * until it is found. This reads an unbounded number of bytes into the buffer., +   */, +  public long seek(byte b, Deadline deadline) throws IOException {, +    long start = 0;, +    long index;, +    while ((index = buffer.indexOf(b, start)) == -1) {, +      start = buffer.byteCount;]