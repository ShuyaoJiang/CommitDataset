[+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java, +import okio.Buffer;, +  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {, +    int keyIndex = 0;, +    do {, +      byte[] buffer = cursor.data;, +      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {, +        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter., +    } while (cursor.next() != -1);, +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java, +import okio.Buffer;, +  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {, +    int keyIndex = 0;, +    do {, +      byte[] buffer = cursor.data;, +      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {, +        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter., +    } while (cursor.next() != -1);, +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java, +  private final Buffer.UnsafeCursor maskCursor;, +    maskCursor = isClient ? null : new Buffer.UnsafeCursor();, +    if (frameLength > 0) {, +, +      if (!isClient) {, +        controlFrameBuffer.readAndWriteUnsafe(maskCursor);, +        maskCursor.seek(0);, +        toggleMask(maskCursor, maskKey);, +        maskCursor.close();, +      if (frameLength > 0) {, +        source.readFully(messageFrameBuffer, frameLength);, +, +        if (!isClient) {, +          messageFrameBuffer.readAndWriteUnsafe(maskCursor);, +          maskCursor.seek(messageFrameBuffer.size() - frameLength);, +          toggleMask(maskCursor, maskKey);, +          maskCursor.close();, +        }, +      }, +, +      if (isFinalFrame) break; // We are exhausted and have no continuations., +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java, +import okio.Buffer;, +  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {, +    int keyIndex = 0;, +    do {, +      byte[] buffer = cursor.data;, +      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {, +        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter., +    } while (cursor.next() != -1);, +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java, +  private final Buffer.UnsafeCursor maskCursor;, +    maskCursor = isClient ? null : new Buffer.UnsafeCursor();, +    if (frameLength > 0) {, +, +      if (!isClient) {, +        controlFrameBuffer.readAndWriteUnsafe(maskCursor);, +        maskCursor.seek(0);, +        toggleMask(maskCursor, maskKey);, +        maskCursor.close();, +      if (frameLength > 0) {, +        source.readFully(messageFrameBuffer, frameLength);, +, +        if (!isClient) {, +          messageFrameBuffer.readAndWriteUnsafe(maskCursor);, +          maskCursor.seek(messageFrameBuffer.size() - frameLength);, +          toggleMask(maskCursor, maskKey);, +          maskCursor.close();, +        }, +      }, +, +      if (isFinalFrame) break; // We are exhausted and have no continuations., +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java, +  private final byte[] maskKey;, +  private final Buffer.UnsafeCursor maskCursor;, +    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;, +      if (length > 0) {, +        long payloadStart = sinkBuffer.size();, +        sinkBuffer.write(payload);, +, +        sinkBuffer.readAndWriteUnsafe(maskCursor);, +        maskCursor.seek(payloadStart);, +        toggleMask(maskCursor, maskKey);, +        maskCursor.close();, +      }, +      if (byteCount > 0) {, +        long bufferStart = sinkBuffer.size();, +        sinkBuffer.write(buffer, byteCount);, +, +        sinkBuffer.readAndWriteUnsafe(maskCursor);, +        maskCursor.seek(bufferStart);, +        toggleMask(maskCursor, maskKey);, +        maskCursor.close();, +++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java, +import okio.Buffer;, +  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {, +    int keyIndex = 0;, +    do {, +      byte[] buffer = cursor.data;, +      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {, +        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter.]