[+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    BufferedSink tunnelSink = Okio.buffer(Okio.sink(out));, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, tunnelSink);, +      tunnelConnection.flush();, +  private void initSourceAndSink() throws IOException {, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    BufferedSink tunnelSink = Okio.buffer(Okio.sink(out));, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, tunnelSink);, +      tunnelConnection.flush();, +  private void initSourceAndSink() throws IOException {, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java, +import okio.BufferedSink;, +  private final BufferedSink sink;, +      BufferedSink sink) {, +    this.sink = sink;, +    sink.flush();, +    sink.writeUtf8(requestLine).writeUtf8("\r\n");, +      sink.writeUtf8(headers.name(i)), +          .writeUtf8(": "), +          .writeUtf8(headers.value(i)), +          .writeUtf8("\r\n");, +    sink.writeUtf8("\r\n");, +    return new ChunkedOutputStream(sink, defaultChunkLength);, +    return new FixedLengthOutputStream(sink, contentLength);, +    requestBody.writeToSocket(sink);, +    private final BufferedSink sink;, +    private FixedLengthOutputStream(BufferedSink sink, long bytesRemaining) {, +      this.sink = sink;, +      sink.write(buffer, offset, count);, +      sink.flush();, +  private static final String CRLF = "\r\n";, +    private final BufferedSink sink;, +    private final OkBuffer bufferedChunk;, +    private ChunkedOutputStream(BufferedSink sink, int maxChunkLength) {, +      this.sink = sink;, +      this.bufferedChunk = new OkBuffer();, +        if (bufferedChunk.byteCount() > 0 || count < maxChunkLength) {, +          numBytesWritten = (int) Math.min(count, maxChunkLength - bufferedChunk.byteCount());, +          if (bufferedChunk.byteCount() == maxChunkLength) {, +          sink.write(buffer, offset, numBytesWritten);, +          sink.writeUtf8(CRLF);, +      sink.write(hex, cursor, hex.length - cursor);, +      sink.flush();, +      sink.write(FINAL_CHUNK);, +      int size = (int) bufferedChunk.byteCount();, +      if (size == 0) return;, +      sink.write(bufferedChunk, bufferedChunk.byteCount());, +      sink.writeUtf8(CRLF);, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +      initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    initSourceAndSink();, +      httpConnection = new HttpConnection(pool, this, source, sink);, +    BufferedSink tunnelSink = Okio.buffer(Okio.sink(out));, +    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, tunnelSink);, +      tunnelConnection.flush();, +  private void initSourceAndSink() throws IOException {, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java, +import okio.BufferedSink;, +  private final BufferedSink sink;, +      BufferedSink sink) {, +    this.sink = sink;, +    sink.flush();, +    sink.writeUtf8(requestLine).writeUtf8("\r\n");, +      sink.writeUtf8(headers.name(i)), +          .writeUtf8(": "), +          .writeUtf8(headers.value(i)), +          .writeUtf8("\r\n");, +    sink.writeUtf8("\r\n");, +    return new ChunkedOutputStream(sink, defaultChunkLength);, +    return new FixedLengthOutputStream(sink, contentLength);, +    requestBody.writeToSocket(sink);, +    private final BufferedSink sink;, +    private FixedLengthOutputStream(BufferedSink sink, long bytesRemaining) {, +      this.sink = sink;, +      sink.write(buffer, offset, count);, +      sink.flush();, +  private static final String CRLF = "\r\n";, +    private final BufferedSink sink;, +    private final OkBuffer bufferedChunk;, +    private ChunkedOutputStream(BufferedSink sink, int maxChunkLength) {, +      this.sink = sink;, +      this.bufferedChunk = new OkBuffer();, +        if (bufferedChunk.byteCount() > 0 || count < maxChunkLength) {, +          numBytesWritten = (int) Math.min(count, maxChunkLength - bufferedChunk.byteCount());, +          if (bufferedChunk.byteCount() == maxChunkLength) {, +          sink.write(buffer, offset, numBytesWritten);, +          sink.writeUtf8(CRLF);, +      sink.write(hex, cursor, hex.length - cursor);, +      sink.flush();, +      sink.write(FINAL_CHUNK);, +      int size = (int) bufferedChunk.byteCount();]