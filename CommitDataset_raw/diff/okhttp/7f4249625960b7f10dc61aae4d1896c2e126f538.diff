[+++ b/src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyConnection.java, +    /**, +     * Returns the number of {@link SpdyStream#isOpen() open streams} on this, +     * connection., +     */, +    public synchronized int openStreamCount() {, +        return streams.size();, +    }, +, +                if (stream.isOpen()) {, +            }, +        if (reason != null) {, +            reason.printStackTrace();, +        }, +            if (dataStream == null) {, +                writeSynResetLater(streamId, SpdyStream.RST_INVALID_STREAM);, +                Streams.skipByReading(in, length);, +                return;, +            }, +                dataStream.receiveData(in, length);, +                if ((flags & SpdyConnection.FLAG_FIN) != 0) {, +                    dataStream.receiveFin();, +                }, +            if (replyStream == null) {, +                writeSynResetLater(streamId, SpdyStream.RST_INVALID_STREAM);, +                return;, +            }, +                if ((flags & SpdyConnection.FLAG_FIN) != 0) {, +                    replyStream.receiveFin();, +                }, +++ b/src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyConnection.java, +    /**, +     * Returns the number of {@link SpdyStream#isOpen() open streams} on this, +     * connection., +     */, +    public synchronized int openStreamCount() {, +        return streams.size();, +    }, +, +                if (stream.isOpen()) {, +            }, +        if (reason != null) {, +            reason.printStackTrace();, +        }, +            if (dataStream == null) {, +                writeSynResetLater(streamId, SpdyStream.RST_INVALID_STREAM);, +                Streams.skipByReading(in, length);, +                return;, +            }, +                dataStream.receiveData(in, length);, +                if ((flags & SpdyConnection.FLAG_FIN) != 0) {, +                    dataStream.receiveFin();, +                }, +            if (replyStream == null) {, +                writeSynResetLater(streamId, SpdyStream.RST_INVALID_STREAM);, +                return;, +            }, +                if ((flags & SpdyConnection.FLAG_FIN) != 0) {, +                    replyStream.receiveFin();, +                }, +++ b/src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyStream.java, +     * Returns true if this stream is open. A stream is open until either:, +     * <ul>, +     *   <li>A {@code SYN_RESET} frame abnormally terminates the stream., +     *   <li>Both input and output streams have transmitted all data., +     * </ul>, +     * Note that the input stream may continue to yield data even after a stream, +     * reports itself as not open. This is because input data is buffered., +     */, +    public synchronized boolean isOpen() {, +        if (rstStatusCode != -1) {, +            return false;, +        }, +        if ((in.finished || in.closed) && (out.finished || out.closed)) {, +            return false;, +        }, +        return true;, +    }, +, +    /**, +    void receiveReply(List<String> strings) throws IOException {, +        assert (!Thread.holdsLock(SpdyStream.this));, +        synchronized (this) {, +    void receiveData(InputStream in, int length) throws IOException {, +        assert (!Thread.holdsLock(SpdyStream.this));, +        this.in.receive(in, length);, +    }, +, +    void receiveFin() {, +        assert (!Thread.holdsLock(SpdyStream.this));, +        boolean open;, +            open = isOpen();, +        if (!open) {, +            connection.removeStream(id);, +        }, +        boolean open;, +        boolean cancel;, +            cancel = !in.finished && in.closed && (out.finished || out.closed);, +            open = isOpen();, +        if (cancel) {]