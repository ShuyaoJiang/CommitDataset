[+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +  private final Executor clientExecutor = Executors.newSingleThreadExecutor();, +  private final Executor serverExecutor = Executors.newSingleThreadExecutor();, +    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,, +    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,, +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    assertFalse(server.readMessage()); // This will trigger a close response., +    assertFalse(client.readMessage());, +    client.readMessage(); // Read server close., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +, +  private static void waitForExecutor(Executor executor) {, +    final CountDownLatch latch = new CountDownLatch(1);, +    executor.execute(new Runnable() {, +      @Override public void run() {, +        latch.countDown();, +      }, +    });, +    try {, +      if (!latch.await(10, TimeUnit.SECONDS)) {, +        throw new IllegalStateException("Timed out waiting for executor.");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +    }, +  }, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +  private final Executor clientExecutor = Executors.newSingleThreadExecutor();, +  private final Executor serverExecutor = Executors.newSingleThreadExecutor();, +    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,, +    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,, +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    waitForExecutor(serverExecutor); // Pong write happens asynchronously., +    assertFalse(server.readMessage()); // This will trigger a close response., +    assertFalse(client.readMessage());, +    client.readMessage(); // Read server close., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +    waitForExecutor(clientExecutor); // Close happens asynchronously., +, +  private static void waitForExecutor(Executor executor) {, +    final CountDownLatch latch = new CountDownLatch(1);, +    executor.execute(new Runnable() {, +      @Override public void run() {, +        latch.countDown();, +      }, +    });, +    try {, +      if (!latch.await(10, TimeUnit.SECONDS)) {, +        throw new IllegalStateException("Timed out waiting for executor.");, +      }, +    } catch (InterruptedException e) {, +      Thread.currentThread().interrupt();, +    }, +  }, +++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java, +        final boolean writeCloseResponse;, +        synchronized (closeLock) {, +          readerSentClose = true;, +, +          // If the writer has not indicated a desire to close we will write a close response., +          writeCloseResponse = !writerSentClose;, +        }, +, +            peerClose(code, reason, writeCloseResponse);, +  private void peerClose(int code, String reason, boolean writeCloseResponse) {]