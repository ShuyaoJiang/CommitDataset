[+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java, +import okio.Okio;, +import okio.Source;, +  Source getBodySource() {, +    return bodyStream != null ? Okio.source(bodyStream) : getBody();, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java, +import okio.Okio;, +import okio.Source;, +  Source getBodySource() {, +    return bodyStream != null ? Okio.source(bodyStream) : getBody();, +++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java, +import okio.Sink;, +import okio.Source;, +import okio.Timeout;, +          logger.info(, +              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);, +          logger.log(Level.SEVERE,, +              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);, +          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),, +              raw.getPort(), true);, +            protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;, +          SpdyConnection spdyConnection =, +              new SpdyConnection.Builder(false, socket).protocol(protocol), +                  .handler(spdySocketHandler), +                  .build();, +        BufferedSource source = Okio.buffer(Okio.source(socket));, +        BufferedSink sink = Okio.buffer(Okio.sink(socket));, +        while (processOneRequest(socket, source, sink)) {, +          logger.warning(MockWebServer.this, +              + " connection from ", +              + raw.getInetAddress(), +        source.close();, +        sink.close();, +        BufferedSource source = Okio.buffer(Okio.source(raw));, +        BufferedSink sink = Okio.buffer(Okio.sink(raw));, +          if (!processOneRequest(raw, source, sink)) {, +      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink), +        RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);, +          if (source.exhausted()) return false;, +          handleWebSocketUpgrade(socket, source, sink, request, response);, +          writeHttpResponse(socket, sink, response);, +          source.close();, +          sink.close();, +          logger.info(, +              MockWebServer.this + " received request: " + request + " and responded: " + response);, +  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,, +      request = source.readUtf8LineStrict();, +    while ((header = source.readUtf8LineStrict()).length() != 0) {, +      sink.writeUtf8("HTTP/1.1 100 Continue\r\n");, +      sink.writeUtf8("Content-Length: 0\r\n");, +      sink.writeUtf8("\r\n");, +      sink.flush();, +    TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);, +      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);, +        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);, +          readEmptyLine(source);, +        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);, +        readEmptyLine(source);, +    return new RecordedRequest(request, headers, chunkSizes, requestBody.receivedByteCount,, +        requestBody.buffer, sequenceNumber, socket);, +  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,, +    writeHttpResponse(socket, sink, response);, +  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response), +    sink.writeUtf8(response.getStatus());, +    sink.writeUtf8("\r\n");, +, +      sink.writeUtf8(headers.get(i));, +      sink.writeUtf8("\r\n");, +    sink.writeUtf8("\r\n");, +    sink.flush();, +    Source source = response.getBodySource();, +    if (source == null) return;, +    throttledTransfer(response, socket, Okio.buffer(source), sink, Long.MAX_VALUE);, +  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,, +      BufferedSink sink, long limit) throws IOException {, +    Buffer buffer = new Buffer();, +        long toRead = Math.min(Math.min(2048, limit), bytesPerPeriod - b);, +        if (toRead > 0) {, +          long read = source.read(buffer, toRead);, +          sink.write(buffer, read);, +          sink.flush();, +        }, +      if (delayMs != 0) {, +          Thread.sleep(delayMs);, +  private void readEmptyLine(BufferedSource source) throws IOException {, +    String line = source.readUtf8LineStrict();, +  /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */, +  private static class TruncatingBuffer implements Sink {, +    private final Buffer buffer = new Buffer();, +    private long remainingByteCount;, +    private long receivedByteCount;, +    TruncatingBuffer(long bodyLimit) {, +      remainingByteCount = bodyLimit;, +    @Override public void write(Buffer source, long byteCount) throws IOException {, +      long toRead = Math.min(remainingByteCount, byteCount);, +      if (toRead > 0) {, +        source.read(buffer, toRead);, +      long toSkip = byteCount - toRead;, +      if (toSkip > 0) {, +        source.skip(toSkip);]