[+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java, +/*, + * Copyright (C) 2016 Square, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package okhttp3.internal.io;, +, +import java.io.IOException;, +import java.io.InterruptedIOException;, +import java.util.Random;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +import okio.Buffer;, +import okio.ByteString;, +import okio.HashingSink;, +import okio.Source;, +import org.junit.After;, +import org.junit.Test;, +, +import static junit.framework.TestCase.fail;, +import static org.junit.Assert.assertEquals;, +, +public final class PipeTest {, +  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);, +, +  @After public void tearDown() throws Exception {, +    executorService.shutdown();, +  }, +, +  @Test public void test() throws Exception {, +    Pipe pipe = new Pipe(6);, +    pipe.sink.write(new Buffer().writeUtf8("abc"), 3L);, +, +    Source source = pipe.source;, +    Buffer readBuffer = new Buffer();, +    assertEquals(3L, source.read(readBuffer, 6L));, +    assertEquals("abc", readBuffer.readUtf8());, +, +    pipe.sink.close();, +    assertEquals(-1L, source.read(readBuffer, 6L));, +, +    source.close();, +  }, +, +  /**, +   * A producer writes the first 16 MiB of bytes generated by {@code new Random(0)} to a sink, and a, +   * consumer consumes them. Both compute hashes of their data to confirm that they're as expected., +   */, +  @Test public void largeDataset() throws Exception {, +    final Pipe pipe = new Pipe(1000L); // An awkward size to force producer/consumer exchange., +    final long totalBytes = 16L * 1024L * 1024L;, +    ByteString expectedHash = ByteString.decodeHex("7c3b224bea749086babe079360cf29f98d88262d");, +, +    // Write data to the sink., +    Future<ByteString> sinkHash = executorService.submit(new Callable<ByteString>() {, +      @Override public ByteString call() throws Exception {, +        HashingSink hashingSink = HashingSink.sha1(pipe.sink);, +        Random random = new Random(0);, +        byte[] data = new byte[8192];, +, +        Buffer buffer = new Buffer();, +        for (long i = 0L; i < totalBytes; i += data.length) {, +          random.nextBytes(data);, +          buffer.write(data);, +          hashingSink.write(buffer, buffer.size());, +        }, +, +        hashingSink.close();, +        return hashingSink.hash();, +      }, +    });, +, +    // Read data from the source., +    Future<ByteString> sourceHash = executorService.submit(new Callable<ByteString>() {, +      @Override public ByteString call() throws Exception {, +        Buffer blackhole = new Buffer();, +        HashingSink hashingSink = HashingSink.sha1(blackhole);, +, +        Buffer buffer = new Buffer();, +        while (pipe.source.read(buffer, Long.MAX_VALUE) != -1) {, +          hashingSink.write(buffer, buffer.size());, +          blackhole.clear();, +        }, +, +        pipe.source.close();, +        return hashingSink.hash();]