[+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java, +    assertEquals(53, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +    assertEquals(112, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +        + "Content-Length: 337\r\n", +    assertEquals(568, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java, +    assertEquals(53, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +    assertEquals(112, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +        + "Content-Length: 337\r\n", +    assertEquals(568, requestBody.contentLength());, +    assertEquals(buffer.size(), requestBody.contentLength());, +++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java, +import okio.Buffer;, +    private long contentLength = -1L;, +      long result = contentLength;, +      if (result != -1L) return result;, +      return contentLength = writeOrCountBytes(null, true);, +    /**, +     * Either writes this request to {@code sink} or measures its content length. We have one method, +     * do double-duty to make sure the counting and content are consistent, particularly when it, +     * comes to awkward operations like measuring the encoded length of header strings, or the, +     * length-in-digits of an encoded integer., +     */, +    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {, +      long byteCount = 0L;, +, +      Buffer byteCountBuffer = null;, +      if (countBytes) {, +        sink = byteCountBuffer = new Buffer();, +      }, +, +        } else if (countBytes) {, +          // We can't measure the body's size without the sizes of its components., +          byteCountBuffer.clear();, +          return -1L;, +, +        if (countBytes) {, +          byteCount += contentLength;, +        } else {, +        }, +, +, +      if (countBytes) {, +        byteCount += byteCountBuffer.size();, +        byteCountBuffer.clear();, +      }, +, +      return byteCount;, +    }, +, +    @Override public void writeTo(BufferedSink sink) throws IOException {, +      writeOrCountBytes(sink, false);]