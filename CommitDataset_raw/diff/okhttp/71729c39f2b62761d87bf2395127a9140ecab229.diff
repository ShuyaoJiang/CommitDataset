[+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {, +    server.useHttps(sslClient.socketFactory, false);, +    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));, +    server.enqueue(new MockResponse().setBody("response that will never be received"));, +    RecordedResponse response = executeSynchronously("/");, +    response.assertFailure(, +            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE, +            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE, +    );, +    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));, +  }, +, +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {, +    server.useHttps(sslClient.socketFactory, false);, +    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));, +    server.enqueue(new MockResponse().setBody("response that will never be received"));, +    RecordedResponse response = executeSynchronously("/");, +    response.assertFailure(, +            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE, +            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE, +    );, +    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));, +  }, +, +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java, +  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {, +    boolean found = false;, +    for (Class expectedClass : allowedExceptionTypes) {, +      if (expectedClass.isInstance(failure)) {, +        found = true;, +        break;, +      }, +    }, +    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes), +            + ", got " + failure, found);, +++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {, +    server.useHttps(sslClient.socketFactory, false);, +    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));, +    server.enqueue(new MockResponse().setBody("response that will never be received"));, +    RecordedResponse response = executeSynchronously("/");, +    response.assertFailure(, +            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE, +            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE, +    );, +    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));, +  }, +, +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        // opt-in to fallback to COMPATIBLE_TLS, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java, +  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {, +    boolean found = false;, +    for (Class expectedClass : allowedExceptionTypes) {, +      if (expectedClass.isInstance(failure)) {, +        found = true;, +        break;, +      }, +    }, +    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes), +            + ", got " + failure, found);, +++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java, +import java.util.HashSet;, +import javax.net.ssl.SSLProtocolException;, +import javax.net.ssl.SSLSocket;, +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS)), +  @Test public void testNoSslFallback() throws Exception {, +    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);, +    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));, +    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));, +, +    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();, +    connection.setSSLSocketFactory(sslClient.socketFactory);, +    try {, +      connection.getInputStream();, +      fail();, +    } catch (SSLProtocolException expected) {, +      // RI response to the FAIL_HANDSHAKE, +    } catch (SSLHandshakeException expected) {, +      // Android's response to the FAIL_HANDSHAKE, +    }, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java]