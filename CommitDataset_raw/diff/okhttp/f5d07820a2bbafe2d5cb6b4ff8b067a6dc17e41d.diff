[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import com.squareup.okhttp.internal.bytes.Sink;, +   * Closes {@code sink}, ignoring any checked exceptions. Does nothing if, +   * {@code sink} is null., +   */, +  public static void closeQuietly(Sink sink) {, +    if (sink != null) {, +      try {, +        sink.close(Deadline.NONE);, +      } catch (RuntimeException rethrown) {, +        throw rethrown;, +      } catch (Exception ignored) {, +      }, +    }, +  }, +, +  /**, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import com.squareup.okhttp.internal.bytes.Sink;, +   * Closes {@code sink}, ignoring any checked exceptions. Does nothing if, +   * {@code sink} is null., +   */, +  public static void closeQuietly(Sink sink) {, +    if (sink != null) {, +      try {, +        sink.close(Deadline.NONE);, +      } catch (RuntimeException rethrown) {, +        throw rethrown;, +      } catch (Exception ignored) {, +      }, +    }, +  }, +, +  /**, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java, +  public void write(byte[] data, int offset, int byteCount, Deadline deadline) throws IOException {, +    if (closed) throw new IllegalStateException("closed");, +    buffer.write(data, offset, byteCount);, +    emitCompleteSegments(deadline);, +  }, +, +    long byteCount = buffer.completeSegmentByteCount();, +    sink.flush(deadline);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java, +import com.squareup.okhttp.internal.bytes.Sink;, +   * Closes {@code sink}, ignoring any checked exceptions. Does nothing if, +   * {@code sink} is null., +   */, +  public static void closeQuietly(Sink sink) {, +    if (sink != null) {, +      try {, +        sink.close(Deadline.NONE);, +      } catch (RuntimeException rethrown) {, +        throw rethrown;, +      } catch (Exception ignored) {, +      }, +    }, +  }, +, +  /**, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java, +  public void write(byte[] data, int offset, int byteCount, Deadline deadline) throws IOException {, +    if (closed) throw new IllegalStateException("closed");, +    buffer.write(data, offset, byteCount);, +    emitCompleteSegments(deadline);, +  }, +, +    long byteCount = buffer.completeSegmentByteCount();, +    sink.flush(deadline);, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +public final class OkBuffer implements Source, Sink, Cloneable {, +  /**, +   * Returns the number of bytes in segments that are not writable. This is the, +   * number of bytes that can be flushed immediately to an underlying sink, +   * without harming throughput., +   */, +  public long completeSegmentByteCount() {, +    long result = byteCount;, +    if (result == 0) return 0;, +, +    // Omit the tail if it's still writable., +    Segment tail = head.prev;, +    if (tail.limit < Segment.SIZE) {, +      result -= tail.limit - tail.pos;, +    }, +, +    return result;, +  }, +, +, +  /** Returns a deep copy of this buffer. */, +  @Override public OkBuffer clone() {, +    OkBuffer result = new OkBuffer();, +    if (byteCount() == 0) return result;, +, +    result.write(head.data, head.pos, head.limit - head.pos);, +    for (Segment s = head.next; s != head; s = s.next) {, +      result.write(s.data, s.pos, s.limit - s.pos);, +    }, +]