[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java, +    bufferPool = new ByteArrayPool(initialWindowSize * 8); // TODO: revisit size limit!, +  synchronized SpdyStream getStream(int id) {, +  /**, +   * Callers of this method are not thread safe, and sometimes on application, +   * threads.  Most often, this method will be called to send a buffer worth of, +   * data to the peer., +   * <p>, +   * Writes are subject to the write window of the stream and the connection., +   * Until there is a window sufficient to send {@code byteCount}, the caller, +   * will block.  For example, a user of {@code HttpURLConnection} who flushes, +   * more bytes to the output stream than the connection's write window will, +   * block., +   * <p>, +   * Zero {@code byteCount} writes are not subject to flow control and, +   * will not block.  The only use case for zero {@code byteCount} is closing, +   * a flushed output stream., +   */, +    if (byteCount == 0) { // Empty data frames are not flow-controlled., +      frameWriter.data(outFinished, streamId, buffer, offset, byteCount);, +      return;, +    }, +  void writeWindowUpdateLater(final int streamId, final long windowSizeIncrement) {, +          frameWriter.windowUpdate(streamId, windowSizeIncrement);, +  /**, +   * Methods in this class must not lock FrameWriter.  If a method needs to, +   * write a frame, create an async task to do so., +   */, +      long delta = 0;, +          delta = peerInitialWindowSize - initialWindowSize;, +      if (streamsToNotify != null && delta != 0) {, +        for (SpdyStream stream : streams.values()) {, +          synchronized (stream) {, +            stream.addBytesToWriteWindow(delta);, +    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {, +          synchronized (stream) {, +            stream.addBytesToWriteWindow(windowSizeIncrement);, +          }, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java, +    bufferPool = new ByteArrayPool(initialWindowSize * 8); // TODO: revisit size limit!, +  synchronized SpdyStream getStream(int id) {, +  /**, +   * Callers of this method are not thread safe, and sometimes on application, +   * threads.  Most often, this method will be called to send a buffer worth of, +   * data to the peer., +   * <p>, +   * Writes are subject to the write window of the stream and the connection., +   * Until there is a window sufficient to send {@code byteCount}, the caller, +   * will block.  For example, a user of {@code HttpURLConnection} who flushes, +   * more bytes to the output stream than the connection's write window will, +   * block., +   * <p>, +   * Zero {@code byteCount} writes are not subject to flow control and, +   * will not block.  The only use case for zero {@code byteCount} is closing, +   * a flushed output stream., +   */, +    if (byteCount == 0) { // Empty data frames are not flow-controlled., +      frameWriter.data(outFinished, streamId, buffer, offset, byteCount);, +      return;, +    }, +  void writeWindowUpdateLater(final int streamId, final long windowSizeIncrement) {, +          frameWriter.windowUpdate(streamId, windowSizeIncrement);, +  /**, +   * Methods in this class must not lock FrameWriter.  If a method needs to, +   * write a frame, create an async task to do so., +   */, +      long delta = 0;, +          delta = peerInitialWindowSize - initialWindowSize;, +      if (streamsToNotify != null && delta != 0) {, +        for (SpdyStream stream : streams.values()) {, +          synchronized (stream) {, +            stream.addBytesToWriteWindow(delta);, +    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {, +          synchronized (stream) {, +            stream.addBytesToWriteWindow(windowSizeIncrement);, +          }, +++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java, +, +  /**, +   * Count of bytes that can be written on the stream before receiving a, +   * window update. Even if this is positive, writes will block until there, +   * available bytes in {@code connection.bytesLeftInWriteWindow}., +   */, +  // guarded by this, +  long bytesLeftInWriteWindow = 0;, +    this.bytesLeftInWriteWindow = initialWriteWindow;, +  final class SpdyDataOutputStream extends OutputStream {, +      synchronized (SpdyStream.this) {, +        checkOutNotClosed();, +      }, +          writeFrame();, +      synchronized (SpdyStream.this) {, +        checkOutNotClosed();, +      }, +        writeFrame();, +        connection.writeData(id, true, buffer, 0, pos);, +    private void writeFrame() throws IOException {, +        waitUntilWritable(length);, +        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting., +        bytesLeftInWriteWindow -= length;]