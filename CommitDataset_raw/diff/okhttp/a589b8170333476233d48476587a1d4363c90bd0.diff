[+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;, +    boolean readBody = true;, +          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {, +        readBody = false;, +    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +      readBody = true;, +    if (!readBody) {, +      // Don't read the body unless we've invited the client to send it., +    } else if (contentLength != -1) {, +      boolean readBody = true;, +        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {, +          // Don't read the body unless we've invited the client to send it., +          readBody = false;, +        }, +      }, +, +      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +        stream.sendResponseHeaders(Collections.singletonList(, +            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);, +        stream.getConnection().flush();, +        readBody = true;, +      if (readBody) {, +      }, +      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);, +++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;, +    boolean readBody = true;, +          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {, +        readBody = false;, +    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +      readBody = true;, +    if (!readBody) {, +      // Don't read the body unless we've invited the client to send it., +    } else if (contentLength != -1) {, +      boolean readBody = true;, +        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {, +          // Don't read the body unless we've invited the client to send it., +          readBody = false;, +        }, +      }, +, +      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +        stream.sendResponseHeaders(Collections.singletonList(, +            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);, +        stream.getConnection().flush();, +        readBody = true;, +      if (readBody) {, +      }, +      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java, +  RESET_STREAM_AT_START,, +, +  /**, +   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body., +   * Typically this response is sent when a client makes a request with the header {@code, +   * Expect: 100-continue}., +   */, +  EXPECT_CONTINUE, +++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +    stream.sendResponseHeaders(responseHeaders, true);, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;, +    boolean readBody = true;, +          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {, +        readBody = false;, +    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +      readBody = true;, +    if (!readBody) {, +      // Don't read the body unless we've invited the client to send it., +    } else if (contentLength != -1) {, +      boolean readBody = true;, +        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {, +          // Don't read the body unless we've invited the client to send it., +          readBody = false;, +        }, +      }, +, +      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {, +        stream.sendResponseHeaders(Collections.singletonList(, +            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);, +        stream.getConnection().flush();, +        readBody = true;, +      if (readBody) {, +      }, +      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);]