[+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java, +import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;, +import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;, +  @Test public void closeFlushes() throws IOException {, +    assertData("80026c6f");, +  }, +, +  @Test public void noWritesAfterClose() throws IOException {, +    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT);, +, +    sink.close();, +    assertData("8100");, +, +    Buffer payload = new Buffer().writeUtf8("Hello");, +    try {, +      // Write to the unbuffered sink as BufferedSink keeps its own closed state., +      sink.write(payload, payload.size());, +      fail();, +    } catch (IOException e) {, +      assertEquals("closed", e.getMessage());, +    }, +    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY));, +    sink.write(binaryData(50)).flush();, +    assertData(binaryData(50));, +    sink.write(binaryData(50)).flush();, +    assertData(binaryData(50));, +  @Test public void serverMessageLengthShort() throws IOException {, +    // Create a payload which will overflow the normal payload byte size., +    Buffer payload = new Buffer();, +    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {, +      payload.writeByte('0');, +    }, +    long byteCount = payload.completeSegmentByteCount();, +, +    // Write directly to the unbuffered sink. This ensures it will become single frame., +    sink.write(payload.clone(), byteCount);, +    assertData("027e"); // 'e' == 4-byte follow-up length., +    assertData(String.format("%04X", payload.completeSegmentByteCount()));, +    assertData(payload.readByteArray());, +  @Test public void serverMessageLengthLong() throws IOException {, +    // Create a payload which will overflow the normal and short payload byte size., +    Buffer payload = new Buffer();, +    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {, +      payload.writeByte('0');, +    }, +    long byteCount = payload.completeSegmentByteCount();, +, +    // Write directly to the unbuffered sink. This ensures it will become single frame., +    sink.write(payload.clone(), byteCount);, +    assertData("027f"); // 'f' == 16-byte follow-up length., +    assertData(String.format("%016X", byteCount));, +    assertData(payload.readByteArray(byteCount));, +    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY));, +    byte[] part1 = binaryData(50);, +    sink.write(part1).flush();, +    byte[] part2 = binaryData(50);, +    sink.write(part2).close();, +    assertData("80b2");, +      serverWriter.writePing(new Buffer().write(binaryData(1000)));, +      serverWriter.writePong(new Buffer().write(binaryData(1000)));, +      String longString = ByteString.of(binaryData(75)).hex();, +  private static byte[] binaryData(int length) {, +    return junk;, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java, +  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {, +++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java, +import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;, +import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;, +  @Test public void closeFlushes() throws IOException {, +    assertData("80026c6f");, +  }, +, +  @Test public void noWritesAfterClose() throws IOException {, +    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT);, +, +    sink.close();, +    assertData("8100");, +, +    Buffer payload = new Buffer().writeUtf8("Hello");, +    try {, +      // Write to the unbuffered sink as BufferedSink keeps its own closed state., +      sink.write(payload, payload.size());, +      fail();, +    } catch (IOException e) {, +      assertEquals("closed", e.getMessage());, +    }, +    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY));, +    sink.write(binaryData(50)).flush();, +    assertData(binaryData(50));, +    sink.write(binaryData(50)).flush();, +    assertData(binaryData(50));, +  @Test public void serverMessageLengthShort() throws IOException {, +    // Create a payload which will overflow the normal payload byte size., +    Buffer payload = new Buffer();, +    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {, +      payload.writeByte('0');]