[+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java, +  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {, +    dispatcher.setMaxRequests(1);, +    dispatcher.setMaxRequestsPerHost(1);, +    client.newCall(newRequest("http://a/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/2")).enqueue(callback);, +    client.newCall(newRequest("http://b/3")).enqueue(callback);, +    dispatcher.setMaxRequests(3);, +    executor.finishJob("http://a/1");, +    executor.assertJobs("http://b/1");, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java, +  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {, +    dispatcher.setMaxRequests(1);, +    dispatcher.setMaxRequestsPerHost(1);, +    client.newCall(newRequest("http://a/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/2")).enqueue(callback);, +    client.newCall(newRequest("http://b/3")).enqueue(callback);, +    dispatcher.setMaxRequests(3);, +    executor.finishJob("http://a/1");, +    executor.assertJobs("http://b/1");, +  }, +, +++ b/okhttp/src/main/java/okhttp3/Dispatcher.java, +, +      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to, +      // the same host., +      if (!call.get().forWebSocket) {, +        AsyncCall existingCall = findExistingCallWithHost(call.host());, +        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);, +      }, +  @Nullable private AsyncCall findExistingCallWithHost(String host) {, +    for (AsyncCall existingCall : runningAsyncCalls) {, +      if (existingCall.host().equals(host)) return existingCall;, +    }, +    for (AsyncCall existingCall : readyAsyncCalls) {, +      if (existingCall.host().equals(host)) return existingCall;, +    }, +    return null;, +  }, +, +        if (asyncCall.callsPerHost().get() >= maxRequestsPerHost) continue; // Host max capacity., +        asyncCall.callsPerHost().incrementAndGet();, +    call.callsPerHost().decrementAndGet();, +++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java, +  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {, +    dispatcher.setMaxRequests(1);, +    dispatcher.setMaxRequestsPerHost(1);, +    client.newCall(newRequest("http://a/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/1")).enqueue(callback);, +    client.newCall(newRequest("http://b/2")).enqueue(callback);, +    client.newCall(newRequest("http://b/3")).enqueue(callback);, +    dispatcher.setMaxRequests(3);, +    executor.finishJob("http://a/1");, +    executor.assertJobs("http://b/1");, +  }, +, +++ b/okhttp/src/main/java/okhttp3/Dispatcher.java, +, +      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to, +      // the same host., +      if (!call.get().forWebSocket) {, +        AsyncCall existingCall = findExistingCallWithHost(call.host());, +        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);, +      }, +  @Nullable private AsyncCall findExistingCallWithHost(String host) {, +    for (AsyncCall existingCall : runningAsyncCalls) {, +      if (existingCall.host().equals(host)) return existingCall;, +    }, +    for (AsyncCall existingCall : readyAsyncCalls) {, +      if (existingCall.host().equals(host)) return existingCall;, +    }, +    return null;, +  }, +, +        if (asyncCall.callsPerHost().get() >= maxRequestsPerHost) continue; // Host max capacity., +        asyncCall.callsPerHost().incrementAndGet();, +    call.callsPerHost().decrementAndGet();, +++ b/okhttp/src/main/java/okhttp3/RealCall.java, +import java.util.concurrent.atomic.AtomicInteger;, +    private volatile AtomicInteger callsPerHost = new AtomicInteger(0);, +    AtomicInteger callsPerHost() {, +      return callsPerHost;, +    }, +, +    void reuseCallsPerHostFrom(AsyncCall other) {, +      this.callsPerHost = other.callsPerHost;, +    }, +]