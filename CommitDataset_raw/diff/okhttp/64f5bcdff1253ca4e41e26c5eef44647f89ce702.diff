[+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +      transmitter.acquireConnection(connection);, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +import okhttp3.internal.DeferredTrailers;, +import okhttp3.internal.Transmitter;, +      @Override public Transmitter transmitter(Call call) {, +        return ((RealCall) call).transmitter();, +      }, +, +      @Override public void initDeferredTrailers(, +          Response.Builder responseBuilder, DeferredTrailers deferredTrailers) {, +        responseBuilder.initDeferredTrailers(deferredTrailers);, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +import okhttp3.internal.DeferredTrailers;, +import okhttp3.internal.Transmitter;, +      @Override public Transmitter transmitter(Call call) {, +        return ((RealCall) call).transmitter();, +      }, +, +      @Override public void initDeferredTrailers(, +          Response.Builder responseBuilder, DeferredTrailers deferredTrailers) {, +        responseBuilder.initDeferredTrailers(deferredTrailers);, +++ b/okhttp/src/main/java/okhttp3/RealCall.java, +    captureCallStackTrace();, +      Response result = getResponseWithInterceptorChain();, +      if (result == null) throw new IOException("Canceled");, +      return result;, +    } catch (IOException e) {, +      e = timeoutExit(e);, +      transmitter.callFailed(e);, +      throw e;, +  private void captureCallStackTrace() {, +    transmitter.initCallStackTrace(, +        Platform.get().getStackTraceForCloseable("response.body().close()"));, +  }, +, +    captureCallStackTrace();, +  Transmitter transmitter() {, +    return transmitter;, +  }, +, +        transmitter.callFailed(ioException);, +        if (transmitter.isCanceled()) {, +          signalledCallback = true;, +          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));, +        } else {, +        }, +        e = timeoutExit(e);, +          transmitter.callFailed(e);, +      transmitter.noMoreStreamsOnCall();, +++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java, +      transmitter.acquireConnection(c1);, +    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected., +      transmitter.acquireConnection(connection);, +++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java, +import okhttp3.internal.DeferredTrailers;, +import okhttp3.internal.Transmitter;, +      @Override public Transmitter transmitter(Call call) {, +        return ((RealCall) call).transmitter();, +      }, +, +      @Override public void initDeferredTrailers(, +          Response.Builder responseBuilder, DeferredTrailers deferredTrailers) {, +        responseBuilder.initDeferredTrailers(deferredTrailers);, +++ b/okhttp/src/main/java/okhttp3/RealCall.java, +    captureCallStackTrace();, +      Response result = getResponseWithInterceptorChain();, +      if (result == null) throw new IOException("Canceled");, +      return result;, +    } catch (IOException e) {, +      e = timeoutExit(e);, +      transmitter.callFailed(e);, +      throw e;, +  private void captureCallStackTrace() {, +    transmitter.initCallStackTrace(, +        Platform.get().getStackTraceForCloseable("response.body().close()"));, +  }, +, +    captureCallStackTrace();, +  Transmitter transmitter() {, +    return transmitter;, +  }, +, +        transmitter.callFailed(ioException);, +        if (transmitter.isCanceled()) {, +          signalledCallback = true;, +          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));, +        } else {, +        }, +        e = timeoutExit(e);]