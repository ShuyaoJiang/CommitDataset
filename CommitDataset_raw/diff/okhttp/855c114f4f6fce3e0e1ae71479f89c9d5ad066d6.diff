[+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java, +  /** Reads a byte from the front of this buffer and returns it. */, +  public byte readByte() {, +    if (byteCount < 1) throw new IllegalArgumentException("byteCount < 1: " + byteCount);, +, +    Segment segment = head;, +    int pos = segment.pos;, +    int limit = segment.limit;, +, +    byte[] data = segment.data;, +    byte b = data[pos++];, +    byteCount -= 1;, +, +    if (pos == limit) {, +      head = segment.pop();, +      SegmentPool.INSTANCE.recycle(segment);, +    } else {, +      segment.pos = pos;, +    }, +, +    return b;, +  }, +, +  /** Reads a Big-Endian short from the front of this buffer and returns it. */, +  public short readShort() {, +    if (byteCount < 2) throw new IllegalArgumentException("byteCount < 2: " + byteCount);, +, +    Segment segment = head;, +    int pos = segment.pos;, +    int limit = segment.limit;, +, +    // If the short is split across multiple segments, delegate to readByte()., +    if (limit - pos < 2) {, +      int s = (readByte() & 0xff) << 8, +          |   (readByte() & 0xff);, +      return (short) s;, +    }, +, +    byte[] data = segment.data;, +    int s = (data[pos++] & 0xff) << 8, +        |   (data[pos++] & 0xff);, +    byteCount -= 2;, +, +    if (pos == limit) {, +      head = segment.pop();, +      SegmentPool.INSTANCE.recycle(segment);, +    } else {, +      segment.pos = pos;, +    }, +, +    return (short) s;, +  }, +, +  /** Reads a Big-Endian int from the front of this buffer and returns it. */, +  public int readInt() {, +    if (byteCount < 4) throw new IllegalArgumentException("byteCount < 4: " + byteCount);, +, +    Segment segment = head;, +    int pos = segment.pos;, +    int limit = segment.limit;, +, +    // If the int is split across multiple segments, delegate to readByte()., +    if (limit - pos < 4) {, +      return (readByte() & 0xff) << 24, +          |  (readByte() & 0xff) << 16, +          |  (readByte() & 0xff) << 8, +          |  (readByte() & 0xff);, +    }, +, +    byte[] data = segment.data;, +    int i = (data[pos++] & 0xff) << 24, +        |   (data[pos++] & 0xff) << 16, +        |   (data[pos++] & 0xff) << 8, +        |   (data[pos++] & 0xff);, +    byteCount -= 4;, +, +    if (pos == limit) {, +      head = segment.pop();, +      SegmentPool.INSTANCE.recycle(segment);, +    } else {, +      segment.pos = pos;, +    }, +, +    return i;, +  }, +, +    write(byteString.data, 0, byteString.data.length);, +    byte[] data = string.getBytes(Util.UTF_8);, +    write(data, 0, data.length);, +  void write(byte[] data, int offset, int byteCount) {, +    int limit = offset + byteCount;, +    while (offset < limit) {, +      Segment tail = writableSegment(1);, +      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);, +  /** Appends a Big-Endian byte to the end of this buffer. */, +  public OkBuffer writeByte(int b) {, +    Segment tail = writableSegment(1);, +    tail.data[tail.limit++] = (byte) b;, +    byteCount += 1;, +    return this;]