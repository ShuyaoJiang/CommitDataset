[+++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        inputStream = address.requiresTunnel(), +            Proxy proxy, int connectTimeout) throws IOException {, +                    : new Address(uri, sslSocketFactory, proxy);, +                    Address address = new Address(uri, sslSocketFactory, selectedProxy);, +        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy), +                throws UnknownHostException {, +                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory);, +, +        /**, +         * Returns true if the HTTP connection needs to tunnel one protocol over, +         * another, such as when using HTTPS through an HTTP proxy. When doing so,, +         * we must avoid buffering bytes intended for the higher-level protocol., +         */, +        public boolean requiresTunnel() {, +            return sslSocketFactory != null && proxy != null && proxy.type() == Proxy.Type.HTTP;, +        }, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        inputStream = address.requiresTunnel(), +            Proxy proxy, int connectTimeout) throws IOException {, +                    : new Address(uri, sslSocketFactory, proxy);, +                    Address address = new Address(uri, sslSocketFactory, selectedProxy);, +        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy), +                throws UnknownHostException {, +                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory);, +, +        /**, +         * Returns true if the HTTP connection needs to tunnel one protocol over, +         * another, such as when using HTTPS through an HTTP proxy. When doing so,, +         * we must avoid buffering bytes intended for the higher-level protocol., +         */, +        public boolean requiresTunnel() {, +            return sslSocketFactory != null && proxy != null && proxy.type() == Proxy.Type.HTTP;, +        }, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +                policy.getProxy(), policy.getConnectTimeout());, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        inputStream = address.requiresTunnel(), +            Proxy proxy, int connectTimeout) throws IOException {, +                    : new Address(uri, sslSocketFactory, proxy);, +                    Address address = new Address(uri, sslSocketFactory, selectedProxy);, +        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy), +                throws UnknownHostException {, +                        && Objects.equal(this.sslSocketFactory, that.sslSocketFactory);, +, +        /**, +         * Returns true if the HTTP connection needs to tunnel one protocol over, +         * another, such as when using HTTPS through an HTTP proxy. When doing so,, +         * we must avoid buffering bytes intended for the higher-level protocol., +         */, +        public boolean requiresTunnel() {, +            return sslSocketFactory != null && proxy != null && proxy.type() == Proxy.Type.HTTP;, +        }, +++ b/src/main/java/libcore/net/http/HttpEngine.java, +                policy.getProxy(), policy.getConnectTimeout());, +++ b/src/main/java/libcore/net/http/HttpResponseCache.java, +import java.io.BufferedInputStream;, +import libcore.io.Streams;, +++ b/pom.xml, +        <mockwebserver.version>20120905</mockwebserver.version>, +++ b/src/main/java/com/squareup/okhttp/OkHttpsConnection.java, +++ b/src/main/java/libcore/io/StrictLineReader.java, +        if (!(charset.equals(Charsets.US_ASCII) || charset.equals(Charsets.UTF_8) ||, +                charset.equals(Charsets.ISO_8859_1))) {, +++ b/src/main/java/libcore/net/http/HttpConnection.java, +        inputStream = address.requiresTunnel(), +            Proxy proxy, int connectTimeout) throws IOException {, +                    : new Address(uri, sslSocketFactory, proxy);, +                    Address address = new Address(uri, sslSocketFactory, selectedProxy);, +        public Address(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy), +                throws UnknownHostException {]