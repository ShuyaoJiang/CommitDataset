[+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +  private static final int CLIENT_AUTH_NONE = 0;, +  private static final int CLIENT_AUTH_REQUESTED = 1;, +  private static final int CLIENT_AUTH_REQUIRED = 2;, +, +  private int clientAuth = CLIENT_AUTH_NONE;, +   * Configure the server to not perform SSL authentication of the client. This leaves, +   * authentication to another layer such as in an HTTP cookie or header. This is the default and, +   * most common configuration., +   */, +  public void noClientAuth() {, +    this.clientAuth = CLIENT_AUTH_NONE;, +  }, +, +  /**, +   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the, +   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will, +   * proceed normally. The connection will also proceed normally if the client presents no, +   * certificate at all! But if the client presents an untrusted certificate the handshake will fail, +   * and no connection will be established., +   */, +  public void requestClientAuth() {, +    this.clientAuth = CLIENT_AUTH_REQUESTED;, +  }, +, +  /**, +   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the, +   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will, +   * proceed normally. If the client presents an untrusted certificate or no certificate at all the, +   * handshake will fail and no connection will be established., +   */, +  public void requireClientAuth() {, +    this.clientAuth = CLIENT_AUTH_REQUIRED;, +  }, +, +  /**, +          if (clientAuth == CLIENT_AUTH_REQUIRED) {, +            sslSocket.setNeedClientAuth(true);, +          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {, +            sslSocket.setWantClientAuth(true);, +          }, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java, +  private static final int CLIENT_AUTH_NONE = 0;, +  private static final int CLIENT_AUTH_REQUESTED = 1;, +  private static final int CLIENT_AUTH_REQUIRED = 2;, +, +  private int clientAuth = CLIENT_AUTH_NONE;, +   * Configure the server to not perform SSL authentication of the client. This leaves, +   * authentication to another layer such as in an HTTP cookie or header. This is the default and, +   * most common configuration., +   */, +  public void noClientAuth() {, +    this.clientAuth = CLIENT_AUTH_NONE;, +  }, +, +  /**, +   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the, +   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will, +   * proceed normally. The connection will also proceed normally if the client presents no, +   * certificate at all! But if the client presents an untrusted certificate the handshake will fail, +   * and no connection will be established., +   */, +  public void requestClientAuth() {, +    this.clientAuth = CLIENT_AUTH_REQUESTED;, +  }, +, +  /**, +   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the, +   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will, +   * proceed normally. If the client presents an untrusted certificate or no certificate at all the, +   * handshake will fail and no connection will be established., +   */, +  public void requireClientAuth() {, +    this.clientAuth = CLIENT_AUTH_REQUIRED;, +  }, +, +  /**, +          if (clientAuth == CLIENT_AUTH_REQUIRED) {, +            sslSocket.setNeedClientAuth(true);, +          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {, +            sslSocket.setWantClientAuth(true);, +          }, +++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java, +import java.io.IOException;, +import okhttp3.Handshake;, +  private final Handshake handshake;, +    if (socket instanceof SSLSocket) {, +      try {, +        this.handshake = Handshake.get(((SSLSocket) socket).getSession());, +      } catch (IOException e) {, +        throw new IllegalArgumentException(e);, +      }, +    } else {, +      this.handshake = null;, +    }, +    return handshake != null ? handshake.tlsVersion() : null;, +  }, +, +  /**, +   * Returns the TLS handshake of the connection that carried this request, or null if the request]