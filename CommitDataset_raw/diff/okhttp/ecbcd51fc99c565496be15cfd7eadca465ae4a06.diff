[+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +import java.util.logging.Level;, +import java.util.logging.SimpleFormatter;, +import static okhttp3.TestUtil.awaitGarbageCollection;, +    response.body().close();, +  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {, +    server.enqueue(new MockResponse(), +        .setBody("This gets leaked."));, +, +    client = new OkHttpClient.Builder(), +        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS)), +        .build();, +, +    Request request = new Request.Builder(), +        .url(server.url("/")), +        .build();, +, +    Level original = logger.getLevel();, +    logger.setLevel(Level.FINE);, +    logHandler.setFormatter(new SimpleFormatter());, +    try {, +      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd., +      awaitGarbageCollection();, +, +      String message = logHandler.take();, +      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked.", +          + " Did you forget to close a response body?"));, +      assertTrue(message.contains("okhttp3.RealCall.execute("));, +      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));, +    } finally {, +      logger.setLevel(original);, +    }, +  }, +, +  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {, +    server.enqueue(new MockResponse(), +        .setBody("This gets leaked."));, +, +    client = new OkHttpClient.Builder(), +        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS)), +        .build();, +, +    Request request = new Request.Builder(), +        .url(server.url("/")), +        .build();, +, +    Level original = logger.getLevel();, +    logger.setLevel(Level.FINE);, +    logHandler.setFormatter(new SimpleFormatter());, +    try {, +      final CountDownLatch latch = new CountDownLatch(1);, +      client.newCall(request).enqueue(new Callback() {, +        @Override public void onFailure(Call call, IOException e) {, +          fail();, +        }, +, +        @Override public void onResponse(Call call, Response response) throws IOException {, +          // Ignore the response so it gets leaked then GC'd., +          latch.countDown();, +        }, +      });, +      latch.await();, +      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a, +      // small delay appears to ensure the objects will get GC'd., +      Thread.sleep(200);, +      awaitGarbageCollection();, +, +      String message = logHandler.take();, +      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked.", +          + " Did you forget to close a response body?"));, +      assertTrue(message.contains("okhttp3.RealCall.enqueue("));, +      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));, +    } finally {, +      logger.setLevel(original);, +    }, +  }, +, +++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java, +import java.util.logging.Level;, +import java.util.logging.SimpleFormatter;, +import static okhttp3.TestUtil.awaitGarbageCollection;, +    response.body().close();, +  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {, +    server.enqueue(new MockResponse(), +        .setBody("This gets leaked."));, +, +    client = new OkHttpClient.Builder(), +        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS)), +        .build();, +, +    Request request = new Request.Builder(), +        .url(server.url("/")), +        .build();, +, +    Level original = logger.getLevel();, +    logger.setLevel(Level.FINE);, +    logHandler.setFormatter(new SimpleFormatter());, +    try {, +      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd., +      awaitGarbageCollection();]