[+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java, +import java.net.InetSocketAddress;, +import java.net.Proxy;, +import okhttp3.internal.RecordingOkAuthenticator;, +import org.junit.After;, +import static okhttp3.TestUtil.defaultClient;, +  private OkHttpClient client;, +  private SocksProxy socksProxy;, +, +  @Before public void setUp() throws IOException {, +    client = defaultClient().newBuilder(), +  @After public void tearDown() throws Exception {, +    if (socksProxy != null) {, +      socksProxy.shutdown();, +    }, +  }, +, +    List<Class<?>> expectedEvents = Arrays.asList(, +        DnsStart.class, DnsEnd.class,, +        ConnectStart.class, ConnectEnd.class);, +    enableTlsWithTunnel(false);, +        ConnectStart.class, SecureConnectStart.class,, +        SecureConnectEnd.class, ConnectEnd.class);, +  @Test public void successfulConnect() throws IOException {, +    server.enqueue(new MockResponse());, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .build());, +    Response response = call.execute();, +    assertEquals(200, response.code());, +    response.body().close();, +, +    InetAddress address = singleDns.lookup(server.getHostName()).get(0);, +    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());, +, +    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);, +    assertSame(call, connectStart.call);, +    assertEquals(expectedAddress, connectStart.inetSocketAddress);, +    assertEquals(Proxy.NO_PROXY, connectStart.proxy);, +, +    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);, +    assertSame(call, connectEnd.call);, +    assertEquals(expectedAddress, connectEnd.inetSocketAddress);, +    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);, +    assertNull(connectEnd.throwable);, +  }, +, +  @Test public void failedConnect() throws UnknownHostException {, +    enableTlsWithTunnel(false);, +    server.enqueue(new MockResponse(), +        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .build());, +    try {, +      call.execute();, +      fail();, +    } catch (IOException expected) {, +    }, +, +    InetAddress address = singleDns.lookup(server.getHostName()).get(0);, +    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());, +, +    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);, +    assertSame(call, connectStart.call);, +    assertEquals(expectedAddress, connectStart.inetSocketAddress);, +    assertEquals(Proxy.NO_PROXY, connectStart.proxy);, +, +    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);, +    assertSame(call, connectEnd.call);, +    assertEquals(expectedAddress, connectEnd.inetSocketAddress);, +    assertNull(connectEnd.protocol);, +    assertTrue(connectEnd.throwable instanceof IOException);, +  }, +, +  @Test public void multipleConnectsForSingleCall() throws IOException {, +    enableTlsWithTunnel(false);, +    server.enqueue(new MockResponse(), +        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));, +    server.enqueue(new MockResponse());, +, +    client = client.newBuilder(), +        .dns(new DoubleInetAddressDns()), +        .build();, +, +    Call call = client.newCall(new Request.Builder(), +        .url(server.url("/")), +        .build());, +    Response response = call.execute();, +    assertEquals(200, response.code());, +    response.body().close();, +, +    listener.removeUpToEvent(ConnectStart.class);, +    listener.removeUpToEvent(ConnectEnd.class);, +    listener.removeUpToEvent(ConnectStart.class);, +    listener.removeUpToEvent(ConnectEnd.class);, +  }, +]