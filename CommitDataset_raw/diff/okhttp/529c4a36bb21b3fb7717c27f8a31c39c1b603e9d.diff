[+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java, +    List<Header> headerBlock = FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3);, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3));, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2));, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java, +    List<Header> headerBlock = FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3);, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3));, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2));, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private Handshake handshake;, +  private Protocol protocol;, +    if (protocol != null) throw new IllegalStateException("already connected");, +    while (protocol == null) {, +        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +        handshake = null;, +        protocol = null;, +        httpConnection = null;, +        framedConnection = null;, +    } else {, +      protocol = Protocol.HTTP_1_1;, +      socket = sslSocket;, +      handshake = unverifiedHandshake;, +    return protocol != null;, +   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol, +   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is, +   * using {@link Protocol#HTTP_1_0}., +    return protocol != null ? protocol : Protocol.HTTP_1_1;, +    if (protocol == null) throw new IllegalStateException("not connected");, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java, +    List<Header> headerBlock = FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3);, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3));, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2));, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private Handshake handshake;, +  private Protocol protocol;, +    if (protocol != null) throw new IllegalStateException("already connected");, +    while (protocol == null) {, +        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +        handshake = null;, +        protocol = null;, +        httpConnection = null;, +        framedConnection = null;, +    } else {, +      protocol = Protocol.HTTP_1_1;, +      socket = sslSocket;, +      handshake = unverifiedHandshake;, +    return protocol != null;, +   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol, +   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is, +   * using {@link Protocol#HTTP_1_0}., +    return protocol != null ? protocol : Protocol.HTTP_1_1;, +    if (protocol == null) throw new IllegalStateException("not connected");, +++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java, +    List<Header> headerBlock = FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3);, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3));, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2));, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private Handshake handshake;, +  private Protocol protocol;, +    if (protocol != null) throw new IllegalStateException("already connected");, +    while (protocol == null) {, +        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +        handshake = null;, +        protocol = null;, +        httpConnection = null;, +        framedConnection = null;, +    } else {, +      protocol = Protocol.HTTP_1_1;, +      socket = sslSocket;, +      handshake = unverifiedHandshake;, +    return protocol != null;, +   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol, +   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is, +   * using {@link Protocol#HTTP_1_0}., +    return protocol != null ? protocol : Protocol.HTTP_1_1;, +    if (protocol == null) throw new IllegalStateException("not connected");, +++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java, +++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java, +++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java, +    List<Header> headerBlock = FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3);, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3));, +    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2));, +++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java, +  private Handshake handshake;, +  private Protocol protocol;, +    if (protocol != null) throw new IllegalStateException("already connected");, +    while (protocol == null) {, +        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);, +        handshake = null;, +        protocol = null;, +        httpConnection = null;, +        framedConnection = null;, +    } else {]