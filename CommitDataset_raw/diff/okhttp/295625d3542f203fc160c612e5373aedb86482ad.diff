[+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java, +import java.lang.reflect.Method;, +  public void testToStringIsClassname() throws NoSuchMethodException {, +    assumeTrue(getPlatform().equals("jdk9"));, +, +    Method method = this.getClass().getMethod("toString");, +    assertThat(new Jdk9Platform(method, method).toString()).isEqualTo("Jdk9Platform");, +++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java, +import java.lang.reflect.Method;, +  public void testToStringIsClassname() throws NoSuchMethodException {, +    assumeTrue(getPlatform().equals("jdk9"));, +, +    Method method = this.getClass().getMethod("toString");, +    assertThat(new Jdk9Platform(method, method).toString()).isEqualTo("Jdk9Platform");, +++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt, +package okhttp3.internal.platform, +import android.os.Build, +import android.util.Log, +import okhttp3.Protocol, +import okhttp3.internal.Util, +import okhttp3.internal.tls.BasicTrustRootIndex, +import okhttp3.internal.tls.CertificateChainCleaner, +import okhttp3.internal.tls.TrustRootIndex, +import java.io.IOException, +import java.lang.reflect.InvocationTargetException, +import java.lang.reflect.Method, +import java.net.InetSocketAddress, +import java.net.Socket, +import java.nio.charset.StandardCharsets.UTF_8, +import java.security.NoSuchAlgorithmException, +import java.security.cert.Certificate, +import java.security.cert.TrustAnchor, +import java.security.cert.X509Certificate, +import javax.net.ssl.SSLContext, +import javax.net.ssl.SSLPeerUnverifiedException, +import javax.net.ssl.SSLSocket, +import javax.net.ssl.SSLSocketFactory, +import javax.net.ssl.X509TrustManager, +class AndroidPlatform(, +  private val sslParametersClass: Class<*>,, +  private val sslSocketClass: Class<*>,, +  private val setUseSessionTickets: Method,, +  private val setHostname: Method,, +  private val getAlpnSelectedProtocol: Method,, +  private val setAlpnProtocols: Method, +) : Platform() {, +  private val closeGuard = CloseGuard.get(), +  // Not a real Android runtime; probably RoboVM or MoE, +  // Try to load TLS 1.2 explicitly., +  // fallback to TLS, +  override fun getSSLContext(): SSLContext {, +    var tryTls12: Boolean, +    tryTls12 = try {, +      Build.VERSION.SDK_INT in 16..21, +    } catch (e: NoClassDefFoundError) {, +      true, +    if (tryTls12) {, +        return SSLContext.getInstance("TLSv1.2"), +      } catch (e: NoSuchAlgorithmException) {, +      }, +    }, +, +    try {, +      return SSLContext.getInstance("TLS"), +    } catch (e: NoSuchAlgorithmException) {, +      throw IllegalStateException("No TLS provider", e), +    }, +  }, +, +  @Throws(IOException::class), +  override fun connectSocket(, +    socket: Socket, address: InetSocketAddress,, +    connectTimeout: Int, +  ) {, +    try {, +      socket.connect(address, connectTimeout), +    } catch (e: AssertionError) {, +      if (Util.isAndroidGetsocknameError(e)) throw IOException(e), +      throw e, +    } catch (e: ClassCastException) {, +        throw IOException("Exception in connect", e), +        throw e, +  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {, +    var context: Any? =, +        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters"), +        val gmsSslParametersClass = Class.forName(, +            sslSocketFactory.javaClass.classLoader), +        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,, +            "sslParameters"), +      } catch (e: ClassNotFoundException) {, +        return super.trustManager(sslSocketFactory), +    val x509TrustManager = readFieldOrNull(, +        context!!, X509TrustManager::class.java, "x509TrustManager"), +    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,, +        "trustManager"), +  override fun configureTlsExtensions(, +    sslSocket: SSLSocket, hostname: String?, protocols: List<Protocol>, +  ) {, +      return  // No TLS extensions if the socket class is custom., +        setUseSessionTickets.invoke(sslSocket, true)]