[+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataContext.java, +	 * @since 4.2, +	 * @since 4.2, +		return this.namedBinding;, +, +		final List<SqlParameter> declaredReturnParams = new ArrayList<SqlParameter>();, +		final Map<String, SqlParameter> declaredParams = new LinkedHashMap<String, SqlParameter>();, +		List<String> outParamNames = new ArrayList<String>();, +		List<String> metaDataParamNames = new ArrayList<String>();, +				metaDataParamNames.add(meta.getParameterName().toLowerCase());, +		for (SqlParameter param : parameters) {, +			if (param.isResultsParameter()) {, +				declaredReturnParams.add(param);, +				String paramName = param.getName();, +				if (paramName == null) {, +					throw new IllegalArgumentException("Anonymous parameters not supported for calls - " +, +							"please specify a name for the parameter of SQL type " + param.getSqlType());, +				}, +				String paramNameToMatch = this.metaDataProvider.parameterNameToUse(paramName).toLowerCase();, +				declaredParams.put(paramNameToMatch, param);, +				if (param instanceof SqlOutParameter) {, +					outParamNames.add(paramName);, +					if (isFunction() && !metaDataParamNames.contains(paramNameToMatch)) {, +								logger.debug("Using declared out parameter '" + paramName +, +										"' for function return value");, +							setFunctionReturnName(paramName);, +		setOutParameterNames(outParamNames);, +		List<SqlParameter> workParams = new ArrayList<SqlParameter>();, +		workParams.addAll(declaredReturnParams);, +			workParams.addAll(declaredParams.values());, +			return workParams;, +		for (String limitedParamName : this.limitedInParameterNames) {, +					this.metaDataProvider.parameterNameToUse(limitedParamName).toLowerCase(), limitedParamName);, +			String paramNameToCheck = null;, +				paramNameToCheck = this.metaDataProvider.parameterNameToUse(meta.getParameterName()).toLowerCase();, +			String paramNameToUse = this.metaDataProvider.parameterNameToUse(meta.getParameterName());, +			if (declaredParams.containsKey(paramNameToCheck) ||, +				SqlParameter param;, +					param = declaredParams.get(getFunctionReturnName());, +					if (param == null && getOutParameterNames().size() > 0) {, +						param = declaredParams.get(getOutParameterNames().get(0).toLowerCase());, +					if (param == null) {, +								" add a SqlOutParameter with name '" + getFunctionReturnName() + "'");, +						setFunctionReturnName(param.getName());, +					param = declaredParams.get(paramNameToCheck);, +				if (param != null) {, +					workParams.add(param);, +						logger.debug("Using declared parameter for '" +, +								(paramNameToUse != null ? paramNameToUse : getFunctionReturnName()) + "'");, +							logger.debug("Bypassing metadata return parameter for '" + meta.getParameterName() + "'");, +								paramNameToUse : getFunctionReturnName());, +						workParams.add(this.metaDataProvider.createDefaultOutParameter(returnNameToUse, meta));, +							outParamNames.add(returnNameToUse);, +							logger.debug("Added metadata return parameter for '" + returnNameToUse + "'");, +						workParams.add(this.metaDataProvider.createDefaultOutParameter(paramNameToUse, meta));, +						outParamNames.add(paramNameToUse);, +							logger.debug("Added metadata out parameter for '" + paramNameToUse + "'");, +						workParams.add(this.metaDataProvider.createDefaultInOutParameter(paramNameToUse, meta));, +						outParamNames.add(paramNameToUse);, +							logger.debug("Added metadata in out parameter for '" + paramNameToUse + "'");, +								limitedInParamNamesMap.containsKey(paramNameToUse.toLowerCase())) {, +							workParams.add(this.metaDataProvider.createDefaultInParameter(paramNameToUse, meta));, +								logger.debug("Added metadata in parameter for '" + paramNameToUse + "'");, +										" skipped parameter for '" + paramNameToUse + "'");, +		return workParams;, +	 * @since 4.2, +		}, +		else {, +++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataContext.java, +	 * @since 4.2, +	 * @since 4.2, +		return this.namedBinding;, +, +		final List<SqlParameter> declaredReturnParams = new ArrayList<SqlParameter>();, +		final Map<String, SqlParameter> declaredParams = new LinkedHashMap<String, SqlParameter>();, +		List<String> outParamNames = new ArrayList<String>();, +		List<String> metaDataParamNames = new ArrayList<String>();, +				metaDataParamNames.add(meta.getParameterName().toLowerCase());, +		for (SqlParameter param : parameters) {, +			if (param.isResultsParameter()) {, +				declaredReturnParams.add(param);, +				String paramName = param.getName();, +				if (paramName == null) {, +					throw new IllegalArgumentException("Anonymous parameters not supported for calls - " +, +							"please specify a name for the parameter of SQL type " + param.getSqlType());, +				}, +				String paramNameToMatch = this.metaDataProvider.parameterNameToUse(paramName).toLowerCase();, +				declaredParams.put(paramNameToMatch, param);, +				if (param instanceof SqlOutParameter) {, +					outParamNames.add(paramName);, +					if (isFunction() && !metaDataParamNames.contains(paramNameToMatch)) {, +								logger.debug("Using declared out parameter '" + paramName +, +										"' for function return value");, +							setFunctionReturnName(paramName);, +		setOutParameterNames(outParamNames);, +		List<SqlParameter> workParams = new ArrayList<SqlParameter>();, +		workParams.addAll(declaredReturnParams);, +			workParams.addAll(declaredParams.values());, +			return workParams;, +		for (String limitedParamName : this.limitedInParameterNames) {]