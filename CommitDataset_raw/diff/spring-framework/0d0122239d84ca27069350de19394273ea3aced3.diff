[+++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.Constructor;, +import java.lang.reflect.InvocationHandler;, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +import java.lang.reflect.Proxy;, +import java.util.Arrays;, +import java.util.Locale;, +import org.springframework.beans.factory.DisposableBean;, +import org.springframework.context.support.MessageSourceResourceBundle;, +import org.springframework.core.LocalVariableTableParameterNameDiscoverer;, +import org.springframework.core.ParameterNameDiscoverer;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ReflectionUtils;, + * <p>As of Spring 4.0, this class supports Bean Validation 1.0 and 1.1, with special support, + * for Hibernate Validator 4.x and 5.0 (see {@link #setValidationMessageSource})., + *, + * <p>Note that Bean Validation 1.1's {@code #forExecutables} method isn't supported: We do not, + * expect that method to be called by application code; consider {@link MethodValidationInterceptor}, + * instead. If you really need programmatic {@code #forExecutables} access, inject this class as, + * a {@link ValidatorFactory} and call {@link #getValidator()} on it, then {@code #forExecutables}, + * on the returned native {@link Validator} reference instead of directly on this class., + *, +		implements ValidatorFactory, ApplicationContextAware, InitializingBean, DisposableBean {, +, +	private static final Method closeMethod = ClassUtils.getMethodIfAvailable(ValidatorFactory.class, "close");, +, +	private ParameterNameDiscoverer parameterNameDiscoverer;, +, +	 * Spring-based {@code ResourceBundleLocator} when constructing your interpolator., +	 * Set the ParameterNameDiscoverer to use for resolving method and constructor, +	 * parameter names if needed for message interpolation., +	 * <p>Default is a {@link org.springframework.core.LocalVariableTableParameterNameDiscoverer}., +	 */, +	public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {, +		this.parameterNameDiscoverer = parameterNameDiscoverer;, +	}, +, +	/**, +		configureParameterNameProviderIfPossible(configuration);, +, +	private void configureParameterNameProviderIfPossible(Configuration configuration) {, +		try {, +			Class<?> parameterNameProviderClass =, +					ClassUtils.forName("javax.validation.ParameterNameProvider", getClass().getClassLoader());, +			Method parameterNameProviderMethod =, +					Configuration.class.getMethod("parameterNameProvider", parameterNameProviderClass);, +			final Object defaultProvider = ReflectionUtils.invokeMethod(, +					Configuration.class.getMethod("getDefaultParameterNameProvider"), configuration);, +			final ParameterNameDiscoverer discoverer = (this.parameterNameDiscoverer != null ?, +					this.parameterNameDiscoverer : new LocalVariableTableParameterNameDiscoverer());, +			Object parameterNameProvider = Proxy.newProxyInstance(getClass().getClassLoader(),, +					new Class[] {parameterNameProviderClass}, new InvocationHandler() {, +				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {, +					if (method.getName().equals("getParameterNames")) {, +						String[] result = null;, +						if (args[0] instanceof Constructor) {, +							result = discoverer.getParameterNames((Constructor) args[0]);, +						}, +						else if (args[0] instanceof Method) {, +							result = discoverer.getParameterNames((Method) args[0]);, +						}, +						if (result != null) {, +							return Arrays.asList(result);, +						}, +						else {, +							try {, +								return method.invoke(defaultProvider, args);, +							}, +							catch (InvocationTargetException ex) {, +								throw ex.getTargetException();, +							}, +						}, +					}, +					else {, +						// toString, equals, hashCode, +						try {, +							return method.invoke(this, args);, +						}, +						catch (InvocationTargetException ex) {, +							throw ex.getTargetException();, +						}, +					}, +				}, +			});, +			ReflectionUtils.invokeMethod(parameterNameProviderMethod, configuration, parameterNameProvider);, +, +		}, +		catch (Exception ex) {, +			// Bean Validation 1.1 API not available - simply not applying the ParameterNameDiscoverer, +		}, +	}, +, +	public void close() {, +		ReflectionUtils.invokeMethod(closeMethod, this.validatorFactory);, +	}, +, +	public void destroy() {, +		close();]