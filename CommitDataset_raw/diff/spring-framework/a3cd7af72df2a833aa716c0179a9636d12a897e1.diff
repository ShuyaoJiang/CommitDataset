[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/NettyDataBuffer.java, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/NettyDataBuffer.java, +++ b/src/docs/asciidoc/data-access.adoc, +How to create different transaction managers and how they are linked to related resources, +that need to be synchronized to transactions (for example `DataSourceTransactionManager`, +to a JDBC `DataSource`, `HibernateTransactionManager` to a Hibernate `SessionFactory`,, +and so forth) should now be clear. This section describes how the application code, +(directly or indirectly, by using a persistence API such as JDBC, Hibernate, or JPA), +and expect you to understand how it all works. To provide a deeper understanding,, +this section explains the inner workings of the Spring Framework's declarative, +transaction infrastructure in the event of transaction-related issues., +<<core.adoc#aop-understanding-aop-proxies,via AOP proxies>> and that the transactional, +advice is driven by metadata (currently XML- or annotation-based). The combination of, +AOP with transactional metadata yields an AOP proxy that uses a `TransactionInterceptor`, +in conjunction with an appropriate `PlatformTransactionManager` implementation to drive, +NOTE: The standard `javax.transaction.Transactional` annotation is also supported as a, +drop-in replacement to Spring's own annotation. Please refer to JTA 1.2 documentation, +for more details., +illustrated with an example, which is explained in the text that follows., +Consider the following class definition:, +method does not exhibit the configured transactional settings. If you need to annotate, +non-public methods, consider using AspectJ (described later)., +TIP: The Spring team recommends that you annotate only concrete classes (and methods of, +concrete classes) with the `@Transactional` annotation, as opposed to annotating interfaces., +You certainly can place the `@Transactional` annotation on an interface (or an interface, +NOTE: In proxy mode (which is the default), only external method calls coming in through, +the proxy are intercepted. This means that self-invocation (in effect, a method within, +the target object calling another method of the target object) does not lead to an actual, +Consider using of AspectJ mode (see the `mode` attribute in the following table) if you, +expect self-invocations to be wrapped with transactions as well. In this case, there no, +proxy in the first place. Instead, the target class is woven (that is, its byte code is, +modified) to turn `@Transactional` into runtime behavior on any kind of method., +NOTE: The default advice mode for processing `@Transactional` annotations is `proxy`,, +which allows for interception of calls through the proxy only. Local calls within the, +same class cannot get intercepted that way. For a more advanced mode of interception,, +`@Transactional` only on beans in the same application context in which they are defined., +This means that, if you put annotation-driven configuration in a `WebApplicationContext`, +for a `DispatcherServlet`, it checks for `@Transactional` beans only in your controllers, +The `@Transactional` annotation is metadata that specifies that an interface, class,, +or method must have transactional semantics (for example, "`start a brand new read-only, +transaction when this method is invoked, suspending any existing transaction`")., +The default `@Transactional` settings are as follows:, +You can change these default settings. The following table summarizes the various, +properties of the `@Transactional` annotation:, +optionally specify the identity of the `PlatformTransactionManager` to be used., +This can either be the bean name or the qualifier value of the transaction manager bean., +For example, using the qualifier notation, you can combine the following Java code with, +the following transaction manager bean declarations in the application context:, +In this case, the two methods on `TransactionalService` run under separate transaction, +managers, differentiated by the `order` and `account` qualifiers. The default, +`<tx:annotation-driven>` target bean name, `transactionManager`, is still used if no, +specifically qualified `PlatformTransactionManager` bean is found., +If you find you repeatedly use the same attributes with `@Transactional` on many different, +methods, <<core.adoc#beans-meta-annotations,Spring's meta-annotation support>> lets you, +define custom shortcut annotations for your specific use cases. For example, consider the, +following annotation definitions:, +You can also use the Spring Framework's `@Transactional` support outside of a Spring, +container by means of an AspectJ aspect. To do so, first annotate your classes, +(and optionally your classes' methods) with the `@Transactional` annotation,, +and then link (weave) your application with the, +In the container, you need to set up the `PlatformTransactionManager` implementation, +(as a bean) and a `<tx:annotation-driven/>` entry, opting into `@Transactional`, +processing at runtime. The following example shows how to do so:]