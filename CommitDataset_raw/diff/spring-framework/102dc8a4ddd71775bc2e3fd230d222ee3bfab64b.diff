[+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationInvoker.java, +	 * Invoke the cache operation defined by this instance. Wraps any exception, +	 * that is thrown during the invocation in a {@link ThrowableWrapper}., +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationInvoker.java, +	 * Invoke the cache operation defined by this instance. Wraps any exception, +	 * that is thrown during the invocation in a {@link ThrowableWrapper}., +++ b/spring-core/src/main/java/org/springframework/util/UpdateMessageDigestInputStream.java, +	 * @param messageDigest the message digest to update, +	 * @param messageDigest the message digest to update, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationInvoker.java, +	 * Invoke the cache operation defined by this instance. Wraps any exception, +	 * that is thrown during the invocation in a {@link ThrowableWrapper}., +++ b/spring-core/src/main/java/org/springframework/util/UpdateMessageDigestInputStream.java, +	 * @param messageDigest the message digest to update, +	 * @param messageDigest the message digest to update, +++ b/spring-core/src/main/java/org/springframework/util/concurrent/FutureAdapter.java, + * Copyright 2002-2016 the original author or authors., + * Abstract class that adapts a {@link Future} parameterized over S into a {@code Future}, + * parameterized over T. All methods are delegated to the adaptee, where {@link #get()}, + * and {@link #get(long, TimeUnit)} call {@link #adapt(Object)} on the adaptee's result., +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationInvoker.java, +	 * Invoke the cache operation defined by this instance. Wraps any exception, +	 * that is thrown during the invocation in a {@link ThrowableWrapper}., +++ b/spring-core/src/main/java/org/springframework/util/UpdateMessageDigestInputStream.java, +	 * @param messageDigest the message digest to update, +	 * @param messageDigest the message digest to update, +++ b/spring-core/src/main/java/org/springframework/util/concurrent/FutureAdapter.java, + * Copyright 2002-2016 the original author or authors., + * Abstract class that adapts a {@link Future} parameterized over S into a {@code Future}, + * parameterized over T. All methods are delegated to the adaptee, where {@link #get()}, + * and {@link #get(long, TimeUnit)} call {@link #adapt(Object)} on the adaptee's result., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +	 * Called after the main expression evaluation method has been generated, this, +	 * method will callback any registered FieldAdders or ClinitAdders to add any, +	 * extra information to the class representing the compiled expression., +	 */, +	public void finish() {, +		if (this.fieldAdders != null) {, +			for (FieldAdder fieldAdder : this.fieldAdders) {, +				fieldAdder.generateField(cw,this);, +			}, +		}, +		if (this.clinitAdders != null) {, +			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null);, +			mv.visitCode();, +			this.nextFreeVariableId = 0; // To 0 because there is no 'this' in a clinit, +			for (ClinitAdder clinitAdder : this.clinitAdders) {, +				clinitAdder.generateCode(mv, this);, +			}, +			mv.visitInsn(RETURN);, +			mv.visitMaxs(0,0); // not supplied due to COMPUTE_MAXS, +			mv.visitEnd();, +		}, +	}, +, +	/**, +	 * Register a FieldAdder which will add a new field to the generated, +	 * class to support the code produced by an ast nodes primary, +	 * generateCode() method., +	 */, +	public void registerNewField(FieldAdder fieldAdder) {, +		if (this.fieldAdders == null) {, +			this.fieldAdders = new ArrayList<>();, +		}, +		this.fieldAdders.add(fieldAdder);, +	}, +, +	/**, +	 * Register a ClinitAdder which will add code to the static, +	 * initializer in the generated class to support the code, +	 * produced by an ast nodes primary generateCode() method., +	 */, +	public void registerNewClinit(ClinitAdder clinitAdder) {, +		if (this.clinitAdders == null) {, +			this.clinitAdders = new ArrayList<>();, +		}, +		this.clinitAdders.add(clinitAdder);, +	}, +, +	public int nextFieldId() {, +		return this.nextFieldId++;, +	}, +, +	public int nextFreeVariableId() {, +		return this.nextFreeVariableId++;, +	}, +, +	public String getClassName() {, +		return this.clazzName;, +	}, +, +, +	/**, +	@FunctionalInterface, +	public interface FieldAdder {, +, +		void generateField(ClassWriter cw, CodeFlow codeflow);, +	}, +, +]