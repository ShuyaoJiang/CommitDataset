[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <h3>With nested {@code @Configuration} classes</h3>, + * {@code @Configuration} classes may be nested within one another as follows:, + * <pre class="code">, + * &#064;Configuration, + * public class AppConfig {, + *     &#064;Inject DataSource dataSource;, + *, + *     &#064;Bean, + *     public MyBean myBean() {, + *         return new MyBean(dataSource);, + *     }, + *, + *     &#064;Configuration, + *     static class DatabaseConfig {, + *         &#064;Bean, + *         DataSource dataSource() {, + *             return new EmbeddedDatabaseBuilder().build();, + *         }, + *     }, + * }</pre>, + *, + * When bootstrapping such an arrangement, only {@code AppConfig} need be registered, + * against the application context. By virtue of being a nested {@code @Configuration}, + * class, {@code DatabaseConfig} <em>will be registered automatically</em>. This avoids, + * the need to use an {@code @Import} annotation when the relationship between, + * {@code AppConfig} {@code DatabaseConfig} is already implicitly clear., + *, + * <p>Note also that nested {@code @Configuration} classes can be used to good effect, + * with the {@code @Profile} annotation to provide two options of the same bean to the, + * enclosing {@code @Configuration} class., + *, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <h3>With nested {@code @Configuration} classes</h3>, + * {@code @Configuration} classes may be nested within one another as follows:, + * <pre class="code">, + * &#064;Configuration, + * public class AppConfig {, + *     &#064;Inject DataSource dataSource;, + *, + *     &#064;Bean, + *     public MyBean myBean() {, + *         return new MyBean(dataSource);, + *     }, + *, + *     &#064;Configuration, + *     static class DatabaseConfig {, + *         &#064;Bean, + *         DataSource dataSource() {, + *             return new EmbeddedDatabaseBuilder().build();, + *         }, + *     }, + * }</pre>, + *, + * When bootstrapping such an arrangement, only {@code AppConfig} need be registered, + * against the application context. By virtue of being a nested {@code @Configuration}, + * class, {@code DatabaseConfig} <em>will be registered automatically</em>. This avoids, + * the need to use an {@code @Import} annotation when the relationship between, + * {@code AppConfig} {@code DatabaseConfig} is already implicitly clear., + *, + * <p>Note also that nested {@code @Configuration} classes can be used to good effect, + * with the {@code @Profile} annotation to provide two options of the same bean to the, + * enclosing {@code @Configuration} class., + *, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import static org.springframework.context.annotation.ConfigurationClassUtils.isConfigurationCandidate;, +, +, +		// recursively process any member (nested) classes first, +		for (String memberClassName : metadata.getMemberClassNames()) {, +			MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);, +			AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();, +			if (isConfigurationCandidate(memberClassMetadata)) {, +				processConfigurationClass(new ConfigurationClass(reader, null));, +			}, +		}, +, +		// process any @PropertySource annotations, +		// process any @ComponentScan annotions, +		// process any @Import annotations, +		// process any @ImportResource annotations, +, +		// process individual @Bean methods, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <h3>With nested {@code @Configuration} classes</h3>, + * {@code @Configuration} classes may be nested within one another as follows:, + * <pre class="code">, + * &#064;Configuration, + * public class AppConfig {, + *     &#064;Inject DataSource dataSource;, + *, + *     &#064;Bean, + *     public MyBean myBean() {, + *         return new MyBean(dataSource);, + *     }, + *, + *     &#064;Configuration, + *     static class DatabaseConfig {, + *         &#064;Bean, + *         DataSource dataSource() {]