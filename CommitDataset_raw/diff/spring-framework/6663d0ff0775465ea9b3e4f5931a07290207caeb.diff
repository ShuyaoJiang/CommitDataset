[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		public String getTypeName() {, +			StringBuilder result = new StringBuilder(this.rawType.getTypeName());, +			if (this.typeArguments.length > 0) {, +				result.append('<');, +				for (int i = 0; i < this.typeArguments.length; i++) {, +					if (i > 0) {, +						result.append(", ");, +					}, +					result.append(this.typeArguments[i].getTypeName());, +				}, +				result.append('>');, +			}, +			return result.toString();, +		}, +, +		@Override, +, +		@Override, +		public String toString() {, +			return getTypeName();, +		}, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		public String getTypeName() {, +			StringBuilder result = new StringBuilder(this.rawType.getTypeName());, +			if (this.typeArguments.length > 0) {, +				result.append('<');, +				for (int i = 0; i < this.typeArguments.length; i++) {, +					if (i > 0) {, +						result.append(", ");, +					}, +					result.append(this.typeArguments[i].getTypeName());, +				}, +				result.append('>');, +			}, +			return result.toString();, +		}, +, +		@Override, +, +		@Override, +		public String toString() {, +			return getTypeName();, +		}, +++ b/spring-core/src/test/java/org/springframework/core/ResolvableTypeTests.java, +		assertThat(t.toString(), equalTo("java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>"));, +		assertThat(t.getType().getTypeName(), equalTo("java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>"));, +		assertThat(t.getType().toString(), equalTo("java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>"));, +		assertThat(t.getGeneric(0).resolve(), equalTo(Integer.class));, +		assertThat(t.getGeneric(1).resolve(), equalTo(List.class));, +		assertThat(t.resolveGeneric(1, 0), equalTo(String.class));, +		assertThat(listType.getType().getTypeName(), equalTo("java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>"));, +		assertThat(listType.getType().toString(), equalTo("java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>"));, +		assertThat(type.resolve(), equalTo(List[].class));, +		assertThat(type.resolve(), equalTo(void.class));, +		assertThat(narrow.getGeneric().resolve(), equalTo(String.class));, +		assertThat(read.resolve(), equalTo(type.resolve()));, +	private void assertFieldToStringValue(String field, String expected) throws Exception {, +		ResolvableType type = ResolvableType.forField(Fields.class.getField(field));, +		assertThat("field " + field + " toString", type.toString(), equalTo(expected));, +	}, +, +	private void assertTypedFieldToStringValue(String field, String expected) throws Exception {, +		ResolvableType type = ResolvableType.forField(Fields.class.getField(field), TypedFields.class);, +		assertThat("field " + field + " toString", type.toString(), equalTo(expected));, +	}, +, +	private AssertAssignbleMatcher assertAssignable(final ResolvableType type, final ResolvableType... fromTypes) {, +		return values -> {, +						type.isAssignableFrom(fromTypes[i]), equalTo(values[i]));, +	private String stringDesc(ResolvableType type) {, +	@SuppressWarnings("unused"), +	private HashMap<Integer, List<String>> myMap;, +, +, +	private interface AssertAssignbleMatcher {]