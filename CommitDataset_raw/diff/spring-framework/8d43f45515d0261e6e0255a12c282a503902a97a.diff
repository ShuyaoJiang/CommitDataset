[+++ b/spring-web/src/main/java/org/springframework/web/cors/reactive/UrlBasedCorsConfigurationSource.java, +import java.util.List;, +	public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {, +			corsConfigurations.forEach((pattern, config) -> {, +				List<PathPattern> registered = this.patternRegistry.register(pattern);, +				registered.forEach(p -> this.corsConfigurations.put(p, config));, +			});, +++ b/spring-web/src/main/java/org/springframework/web/cors/reactive/UrlBasedCorsConfigurationSource.java, +import java.util.List;, +	public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {, +			corsConfigurations.forEach((pattern, config) -> {, +				List<PathPattern> registered = this.patternRegistry.register(pattern);, +				registered.forEach(p -> this.corsConfigurations.put(p, config));, +			});, +++ b/spring-web/src/main/java/org/springframework/web/util/patterns/PathPatternRegistry.java, +	public PathPatternRegistry(Set<PathPattern> patterns) {, +		this();, +		this.patterns.addAll(patterns);, +	}, +, +		List<PathPattern> newPatterns = generatePathPatterns(rawPattern);, +	private List<PathPattern> generatePathPatterns(String rawPattern) {, +		String fixedPattern = prependLeadingSlash(rawPattern);, +		List<PathPattern> patterns = new ArrayList<>();, +		PathPattern pattern = this.pathPatternParser.parse(fixedPattern);, +		patterns.add(pattern);, +		if (StringUtils.hasLength(fixedPattern) && !pattern.isCatchAll()) {, +			if (this.useSuffixPatternMatch) {, +				if (this.fileExtensions != null && !this.fileExtensions.isEmpty()) {, +					for (String extension : this.fileExtensions) {, +						patterns.add(this.pathPatternParser.parse(fixedPattern + extension));, +					}, +				}, +				else {, +					patterns.add(this.pathPatternParser.parse(fixedPattern + ".*"));, +				}, +			}, +			if (this.useTrailingSlashMatch && !fixedPattern.endsWith("/")) {, +				patterns.add(this.pathPatternParser.parse(fixedPattern + "/"));, +			}, +		}, +		return patterns;, +	}, +, +	/**, +	 * Parse the given {@code rawPattern} and removes it to this registry,, +	 * as well as pattern variants, depending on the given options and, +	 * the nature of the input pattern., +	 *, +	 * @param rawPattern raw path pattern to parse and unregister, +	 * @return the list of {@link PathPattern} that were unregistered as a result, +	 */, +	public List<PathPattern> unregister(String rawPattern) {, +		List<PathPattern> unregisteredPatterns = generatePathPatterns(rawPattern);, +		this.patterns.removeAll(unregisteredPatterns);, +		return unregisteredPatterns;, +	}, +, +, +++ b/spring-web/src/main/java/org/springframework/web/cors/reactive/UrlBasedCorsConfigurationSource.java, +import java.util.List;, +	public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {, +			corsConfigurations.forEach((pattern, config) -> {, +				List<PathPattern> registered = this.patternRegistry.register(pattern);, +				registered.forEach(p -> this.corsConfigurations.put(p, config));, +			});, +++ b/spring-web/src/main/java/org/springframework/web/util/patterns/PathPatternRegistry.java, +	public PathPatternRegistry(Set<PathPattern> patterns) {, +		this();, +		this.patterns.addAll(patterns);, +	}, +, +		List<PathPattern> newPatterns = generatePathPatterns(rawPattern);, +	private List<PathPattern> generatePathPatterns(String rawPattern) {, +		String fixedPattern = prependLeadingSlash(rawPattern);, +		List<PathPattern> patterns = new ArrayList<>();, +		PathPattern pattern = this.pathPatternParser.parse(fixedPattern);, +		patterns.add(pattern);, +		if (StringUtils.hasLength(fixedPattern) && !pattern.isCatchAll()) {, +			if (this.useSuffixPatternMatch) {, +				if (this.fileExtensions != null && !this.fileExtensions.isEmpty()) {, +					for (String extension : this.fileExtensions) {, +						patterns.add(this.pathPatternParser.parse(fixedPattern + extension));, +					}, +				}, +				else {, +					patterns.add(this.pathPatternParser.parse(fixedPattern + ".*"));, +				}, +			}, +			if (this.useTrailingSlashMatch && !fixedPattern.endsWith("/")) {, +				patterns.add(this.pathPatternParser.parse(fixedPattern + "/"));, +			}, +		}, +		return patterns;, +	}, +, +	/**, +	 * Parse the given {@code rawPattern} and removes it to this registry,, +	 * as well as pattern variants, depending on the given options and, +	 * the nature of the input pattern.]