[+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java, +		DataAccessException dae = customTranslate(task, sql, sqlEx);, +		if (dae != null) {, +			return dae;, +	 * Subclasses can override this method to attempt a custom mapping from, +	 * {@link SQLException} to {@link DataAccessException}., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}, +	 * resulting from custom translation. This exception should include the {@code sqlEx} parameter, +	 * as a nested root cause. This implementation always returns {@code null}, meaning that the, +	 * translator always falls back to the default error codes., +	 * Create a custom {@link DataAccessException}, based on a given exception, +	 * class from a {@link CustomSQLErrorCodesTranslation} definition., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * {@link CustomSQLErrorCodesTranslation} definition, +	 * @return {@code null} if the custom exception could not be created, otherwise, +	 * the resulting {@link DataAccessException}. This exception should include the, +	 * {@code sqlEx} parameter as a nested root cause., +++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java, +		DataAccessException dae = customTranslate(task, sql, sqlEx);, +		if (dae != null) {, +			return dae;, +	 * Subclasses can override this method to attempt a custom mapping from, +	 * {@link SQLException} to {@link DataAccessException}., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}, +	 * resulting from custom translation. This exception should include the {@code sqlEx} parameter, +	 * as a nested root cause. This implementation always returns {@code null}, meaning that the, +	 * translator always falls back to the default error codes., +	 * Create a custom {@link DataAccessException}, based on a given exception, +	 * class from a {@link CustomSQLErrorCodesTranslation} definition., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * {@link CustomSQLErrorCodesTranslation} definition, +	 * @return {@code null} if the custom exception could not be created, otherwise, +	 * the resulting {@link DataAccessException}. This exception should include the, +	 * {@code sqlEx} parameter as a nested root cause., +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java, +			DataAccessException dae = (this.exceptionTranslator != null) ?, +			return (dae != null ? dae : ex);, +++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java, +		DataAccessException dae = customTranslate(task, sql, sqlEx);, +		if (dae != null) {, +			return dae;, +	 * Subclasses can override this method to attempt a custom mapping from, +	 * {@link SQLException} to {@link DataAccessException}., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}, +	 * resulting from custom translation. This exception should include the {@code sqlEx} parameter, +	 * as a nested root cause. This implementation always returns {@code null}, meaning that the, +	 * translator always falls back to the default error codes., +	 * Create a custom {@link DataAccessException}, based on a given exception, +	 * class from a {@link CustomSQLErrorCodesTranslation} definition., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * {@link CustomSQLErrorCodesTranslation} definition, +	 * @return {@code null} if the custom exception could not be created, otherwise, +	 * the resulting {@link DataAccessException}. This exception should include the, +	 * {@code sqlEx} parameter as a nested root cause., +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java, +			DataAccessException dae = (this.exceptionTranslator != null) ?, +			return (dae != null ? dae : ex);, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java, +				DataAccessException dae = getJpaDialect().translateExceptionIfPossible((RuntimeException) ex.getCause());, +				if (dae != null) {, +					throw dae;, +++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java, +		DataAccessException dae = customTranslate(task, sql, sqlEx);, +		if (dae != null) {, +			return dae;, +	 * Subclasses can override this method to attempt a custom mapping from, +	 * {@link SQLException} to {@link DataAccessException}., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}, +	 * resulting from custom translation. This exception should include the {@code sqlEx} parameter, +	 * as a nested root cause. This implementation always returns {@code null}, meaning that the, +	 * translator always falls back to the default error codes., +	 * Create a custom {@link DataAccessException}, based on a given exception, +	 * class from a {@link CustomSQLErrorCodesTranslation} definition., +	 * @param sql the SQL query or update that caused the problem (may be {@code null}), +	 * {@link CustomSQLErrorCodesTranslation} definition, +	 * @return {@code null} if the custom exception could not be created, otherwise, +	 * the resulting {@link DataAccessException}. This exception should include the, +	 * {@code sqlEx} parameter as a nested root cause., +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java, +			DataAccessException dae = (this.exceptionTranslator != null) ?, +			return (dae != null ? dae : ex);, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java, +				DataAccessException dae = getJpaDialect().translateExceptionIfPossible((RuntimeException) ex.getCause());, +				if (dae != null) {, +					throw dae;, +++ b/spring-tx/src/main/java/org/springframework/dao/support/DataAccessUtils.java, +		DataAccessException dae = pet.translateExceptionIfPossible(rawException);, +		return (dae != null ? dae : rawException);]