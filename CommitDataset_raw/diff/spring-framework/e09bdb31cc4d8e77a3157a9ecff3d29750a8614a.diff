[+++ b/src/reference/docbook/mvc.xml, +              <para>A <interfacename>Callable&lt;?&gt;</interfacename> can, +              be returned when the application wants to produce the return, +              value asynchronously in a thread managed by Spring MVC.</para>, +            </listitem>, +, +            <listitem>, +              <para>A <classname>DeferredResult&lt;?&gt;</classname> can, +              be returned when the application wants to produce the return, +              value from a thread of its own choosing.</para>, +            </listitem>, +, +            <listitem>, +, +    <section xml:id="mvc-ann-async">, +      <title>Asynchronous Request Processing</title>, +, +      <para>Spring MVC 3.2 introduced Servlet 3 based asynchronous request, +      processing. Instead of returning a value, as usual, a controller method, +      can now return a <interfacename>java.util.concurrent.Callable</interfacename>, +      and produce the return value from a separate thread. Meanwhile the main Servlet, +      container thread is released and allowed to process other requests., +      Spring MVC invokes the <interfacename>Callable</interfacename> in a, +      separate thread with the help of a <interfacename>TaskExecutor</interfacename>, +      and when the <interfacename>Callable</interfacename> returns, the, +      request is dispatched back to the Servlet container to resume, +      processing with the value returned by the, +      <interfacename>Callable</interfacename>., +      Here is an example controller method:</para>, +, +      <programlisting language="java">, +@RequestMapping(method=RequestMethod.POST), +public Callable&lt;String&gt; processUpload(final MultipartFile file) {, +, +  return new Callable&lt;String&gt;() {, +    public Object call() throws Exception {, +      // ..., +      return "someView";, +    }, +  };, +}</programlisting>, +, +      <para>A second option is for the controller to return an instance of, +      <classname>DeferredResult</classname>. In this case the return value, +      will also be produced from a separate thread. However, that thread is not, +      known to Spring MVC. For example the result may be produced in response, +      to some external event such as a JMS message, a scheduled task, etc., +      Here is an example controller method:</para>, +, +      <programlisting language="java">, +@RequestMapping("/quotes"), +@ResponseBody, +public DeferredResult&lt;String&gt; quotes() {, +  DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();, +  // Save the deferredResult in in-memory queue ..., +  return deferredResult;, +}, +, +// In some other thread..., +deferredResult.setResult(data);, +</programlisting>, +, +      <para>This may be difficult to understand without any knowledge of the, +      Servlet 3 async processing feature. It would certainly help to read up on it., +      At a very minimum consider the following basic facts:</para>, +, +      <itemizedlist>, +        <listitem>, +          <para>A <interfacename>ServletRequest</interfacename>, +          can be put in asynchronous mode by calling, +          <code>request.startAsync()</code>. The main effect of doing so is, +          that the Servlet, as well as any Filters, can exit but the response, +          will remain open allowing some other thread to complete processing., +          </para>, +        </listitem>, +        <listitem>, +          <para>The call to <code>request.startAsync()</code> returns an, +          <interfacename>AsyncContext</interfacename>, which can be used for, +          further control over async processing. For example it provides, +          the method <code>dispatch</code>, which can be called from an, +          application thread in order to "dispatch" the request back to, +          the Servlet container. An async dispatch is similar to a forward, +          except it is made from one (application) thread to another, +          (Servlet container) thread whereas a forward occurs synchronously, +          in the same (Servlet container) thread.</para>, +        </listitem>, +        <listitem>, +          <para><interfacename>ServletRequest</interfacename> provides access, +          to the current <interfacename>DispatcherType</interfacename>, which, +          can be used to distinguish if a <interfacename>Servlet</interfacename> or, +          a <interfacename>Filter</interfacename> is processing on, +          the initial request processing thread and when it is processing in, +          an async dispatch.</para>, +        </listitem>, +      </itemizedlist>, +, +      <para>With the above in mind, the following is the sequence, +      of events for async request processing with a <interfacename>Callable</interfacename>:, +      (1) Controller returns a, +      <interfacename>Callable</interfacename>, (2) Spring MVC starts async processing]