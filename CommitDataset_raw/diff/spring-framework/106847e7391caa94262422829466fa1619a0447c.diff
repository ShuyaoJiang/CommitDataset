[+++ b/spring-framework-reference/src/validation.xml, +			There are scenarios, particularly in large message-oriented business applications, where object transformation is required., +			In cases like this, a general-purpose object-to-object mapping facility can be useful for automating the mapping between these disparate models., +				The API to implement object mapping logic is simple and strongly typed:, +				A general purpose object-to-object mapping system exists in the <classname>org.springframework.mapping.support</classname> package., +				Built on the flexible Spring Expression Language (SpEL), this system is capable of mapping between a variety of object types, including JavaBeans, Arrays, Collections, and Maps., +				It can perform field-to-field, field-to-multi-field, and multi-field to field mappings., +				It also can carry out type conversion and recursive mapping, often needed with rich object models., +					To obtain a general purpose object Mapper with its default configuration, simply call MappingFactory.getDefaultMapper()., +					Then invoke the Mapper by calling its <literal>map(Object, Object)</literal> operation:, +MappingFactory.defaultMapper().map(aSource, aTarget);]]>, +				</programlisting>, +					By default, the defaultMapper will map the fields on the source and target that have the same names., +					Now used in the following test case:, +    MapperFactory.getDefaultMapper().map(source, target);, +					When default mapping rules are not sufficient, explicit mapping rules can be registered by obtaining a <classname>MapperBuilder</classname> and using it to construct a <classname>Mapper</classname>., +				</para>, +				<programlisting language="java"><![CDATA[, +MappingBuilder<PersonDto, Person> builder = MappingFactory.mappingBuilder(PersonDto.class, Person.class)]]>, +				</programlisting>			, +				<section id="mapping.SpelMapper-Explicit-differentFieldNames">, +					<title>Mapping between two fields with different names</title>, +					<para>, +						Suppose you need to map <literal>AccountDto.name</literal> to <literal>Account.fullName</literal>., +					<programlisting language="java">builder.addMapping("name", "fullName")</programlisting>, +				</section>, +					<programlisting language="java"><![CDATA[, +builder.setAutoMappingEnabled(false);]]>, +					</programlisting>, +builder.addMapping("name", "fullName").setConverter() { new Converter<String, String>() {, +});]]>, +				</programlisting>, +				<programlisting language="java">builder.setExcludedFields("name");</programlisting>, +					You can also install Converters to convert values of different types in a custom way:, +builder.addConverter(new Converter<String, Date>() {, +});]]>, +				</programlisting>, +builder.addNestedMapper(new Mapper<AddressDto, Address>() {, +});]]>, +				</programlisting>, +					This particular nested Mapper is "hand-coded", but it could have easily been another Mapper instance built by a MapperBuilder.]