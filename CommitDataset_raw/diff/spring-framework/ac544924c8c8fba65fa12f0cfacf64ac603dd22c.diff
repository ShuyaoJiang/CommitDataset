[+++ b/spring-core/src/main/java/org/springframework/util/xml/AbstractXMLStreamReader.java, + * Copyright 2002-2018 the original author or authors., +			throw new XMLStreamException("Parser must be on START_ELEMENT to read next text", getLocation());, +				throw new XMLStreamException("Unexpected end of document when reading element text content",, +				throw new XMLStreamException("Element text content may not contain START_ELEMENT", getLocation());, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS ||, +				eventType == XMLStreamConstants.ENTITY_REFERENCE);, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT);, +	public boolean hasNext() {, +	public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/AbstractXMLStreamReader.java, + * Copyright 2002-2018 the original author or authors., +			throw new XMLStreamException("Parser must be on START_ELEMENT to read next text", getLocation());, +				throw new XMLStreamException("Unexpected end of document when reading element text content",, +				throw new XMLStreamException("Element text content may not contain START_ELEMENT", getLocation());, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS ||, +				eventType == XMLStreamConstants.ENTITY_REFERENCE);, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT);, +	public boolean hasNext() {, +	public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/DomContentHandler.java, +, +	 * Create a new instance of the {@code DomContentHandler} with the given node., +, +	public void startElement(String uri, String localName, String qName, Attributes attributes) {, +	public void endElement(String uri, String localName, String qName) {, +	public void characters(char[] ch, int start, int length) {, +	public void processingInstruction(String target, String data) {, +, +	// Unsupported, +	public void startDocument() {, +	public void endDocument() {, +	public void startPrefixMapping(String prefix, String uri) {, +	public void endPrefixMapping(String prefix) {, +	public void ignorableWhitespace(char[] ch, int start, int length) {, +	public void skippedEntity(String name) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/AbstractXMLStreamReader.java, + * Copyright 2002-2018 the original author or authors., +			throw new XMLStreamException("Parser must be on START_ELEMENT to read next text", getLocation());, +				throw new XMLStreamException("Unexpected end of document when reading element text content",, +				throw new XMLStreamException("Element text content may not contain START_ELEMENT", getLocation());, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS ||, +				eventType == XMLStreamConstants.ENTITY_REFERENCE);, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT);, +	public boolean hasNext() {, +	public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/DomContentHandler.java, +, +	 * Create a new instance of the {@code DomContentHandler} with the given node., +, +	public void startElement(String uri, String localName, String qName, Attributes attributes) {, +	public void endElement(String uri, String localName, String qName) {, +	public void characters(char[] ch, int start, int length) {, +	public void processingInstruction(String target, String data) {, +, +	// Unsupported, +	public void startDocument() {, +	public void endDocument() {, +	public void startPrefixMapping(String prefix, String uri) {, +	public void endPrefixMapping(String prefix) {, +	public void ignorableWhitespace(char[] ch, int start, int length) {, +	public void skippedEntity(String name) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/StaxEventHandler.java, + * Copyright 2002-2018 the original author or authors., +	private List<Namespace> getNamespaces(Map<String, String> namespaceMappings) {, +		List<Namespace> result = new ArrayList<>(namespaceMappings.size());, +		namespaceMappings.forEach((prefix, namespaceUri) ->, +		int attrLength = attributes.getLength();, +		List<Attribute> result = new ArrayList<>(attrLength);, +		for (int i = 0; i < attrLength; i++) {, +	protected void skippedEntityInternal(String name) {, +++ b/spring-core/src/main/java/org/springframework/util/xml/AbstractXMLStreamReader.java, + * Copyright 2002-2018 the original author or authors., +			throw new XMLStreamException("Parser must be on START_ELEMENT to read next text", getLocation());, +				throw new XMLStreamException("Unexpected end of document when reading element text content",, +				throw new XMLStreamException("Element text content may not contain START_ELEMENT", getLocation());, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS ||, +				eventType == XMLStreamConstants.ENTITY_REFERENCE);, +			throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");, +		return (eventType == XMLStreamConstants.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT);, +	public boolean hasNext() {, +	public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) {, +, +++ b/spring-core/src/main/java/org/springframework/util/xml/DomContentHandler.java, +, +	 * Create a new instance of the {@code DomContentHandler} with the given node., +, +	public void startElement(String uri, String localName, String qName, Attributes attributes) {]