[+++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, +	@CodeGenerationHint(ifNameSuffix="6f1"), +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, +	@CodeGenerationHint(ifNameSuffix="6f1"), +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj, + *   <li>Normal object creation via the '{@code new}' operator: this is, + *       taken care of by advising {@code initialization()} join points.</li>, + *           {@code private}</p>. Since aspects cannot introduce a private member,, + *           {@code public}. However, this shouldn't be a big burden, since, + *           in any case asking to make that method {@code public} should not, + *       implementation of {@code readResolve()}, if any, must be, + *       {@code public}) can be lifted as well if we were to use an, + *       experimental feature in AspectJ - the {@code hasmethod()} PCD.</li>, +	 * A marker interface to which the {@code readResolve()} is introduced., +	 * Introduce the {@code readResolve()} method so that we can advise its, +	 * {@code Serializable} class of ConfigurableObject type,, +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, +	@CodeGenerationHint(ifNameSuffix="6f1"), +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj, + *   <li>Normal object creation via the '{@code new}' operator: this is, + *       taken care of by advising {@code initialization()} join points.</li>, + *           {@code private}</p>. Since aspects cannot introduce a private member,, + *           {@code public}. However, this shouldn't be a big burden, since, + *           in any case asking to make that method {@code public} should not, + *       implementation of {@code readResolve()}, if any, must be, + *       {@code public}) can be lifted as well if we were to use an, + *       experimental feature in AspectJ - the {@code hasmethod()} PCD.</li>, +	 * A marker interface to which the {@code readResolve()} is introduced., +	 * Introduce the {@code readResolve()} method so that we can advise its, +	 * {@code Serializable} class of ConfigurableObject type,, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, + * {@code &#64;Configurable} annotation if specified, otherwise the, +	@CodeGenerationHint(ifNameSuffix="bb0"), +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, +	@CodeGenerationHint(ifNameSuffix="6f1"), +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj, + *   <li>Normal object creation via the '{@code new}' operator: this is, + *       taken care of by advising {@code initialization()} join points.</li>, + *           {@code private}</p>. Since aspects cannot introduce a private member,, + *           {@code public}. However, this shouldn't be a big burden, since, + *           in any case asking to make that method {@code public} should not, + *       implementation of {@code readResolve()}, if any, must be, + *       {@code public}) can be lifted as well if we were to use an, + *       experimental feature in AspectJ - the {@code hasmethod()} PCD.</li>, +	 * A marker interface to which the {@code readResolve()} is introduced., +	 * Introduce the {@code readResolve()} method so that we can advise its, +	 * {@code Serializable} class of ConfigurableObject type,, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, + * {@code &#64;Configurable} annotation if specified, otherwise the, +	@CodeGenerationHint(ifNameSuffix="bb0"), +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.aj, + * For example, here is a subaspect that configures the {@code PricingStrategyClient} objects., +++ b/build.gradle, +	ext.aspectjVersion  = "1.7.2", +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj, + * {@code BeanWiringInfoResolver} interface. The default implementation, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj, +import org.aspectj.lang.annotation.control.CodeGenerationHint;, +	@CodeGenerationHint(ifNameSuffix="6f1"), +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj, + *   <li>Normal object creation via the '{@code new}' operator: this is, + *       taken care of by advising {@code initialization()} join points.</li>, + *           {@code private}</p>. Since aspects cannot introduce a private member,, + *           {@code public}. However, this shouldn't be a big burden, since, + *           in any case asking to make that method {@code public} should not, + *       implementation of {@code readResolve()}, if any, must be, + *       {@code public}) can be lifted as well if we were to use an, + *       experimental feature in AspectJ - the {@code hasmethod()} PCD.</li>, +	 * A marker interface to which the {@code readResolve()} is introduced., +	 * Introduce the {@code readResolve()} method so that we can advise its, +	 * {@code Serializable} class of ConfigurableObject type,, +++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj]