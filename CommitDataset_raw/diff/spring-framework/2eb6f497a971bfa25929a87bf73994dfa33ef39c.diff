[+++ b/spring-framework-reference/src/testing.xml, +    <title>Introduction to testing</title>, +    <para>Testing is an integral part of enterprise software development. This, +    chapter focuses on the value-add of the IoC principle to <link, +    linkend="unit-testing">unit testing</link> and on the benefits of Spring, +    Framework <link linkend="integration-testing">integration testing</link>., +    (A thorough treatment of testing in the enterprise is beyond the scope of, +    this chapter.)</para>, +    <para>Dependency Injection should make your code less dependent on the, +    container than it would be with traditional Java EE development. The POJOs, +    that make up your application should be testable in JUnit or TestNG tests,, +    with objects simply instantiated using the <literal>new</literal>, +    operator, <emphasis>without Spring or any other container</emphasis>. You, +    can use <link linkend="mock-objects">mock objects</link> (in conjunction, +    with other valuable testing techniques) to test your code in isolation. If, +    you follow the architecture recommendations for Spring, the resulting, +    clean layering and componentization of your codebase will facilitate, +    easier unit testing. For example, you can test service layer objects by, +    stubbing or mocking DAO or Repository interfaces, without needing to, +    access persistent data while running unit tests.</para>, +    <para>True unit tests typically run extremely quickly, as there is no, +    runtime infrastructure to set up. Emphasizing true unit tests as part of, +    your development methodology will boost your productivity. You may not, +    need this section of the testing chapter to help you write effective unit, +    tests for your IoC-based applications. For certain unit testing scenarios,, +    however, the Spring Framework provides the following mock objects and, +    testing support classes.</para>, +        contains an implementation of the JNDI SPI, which you can use to set, +        up a simple JNDI environment for test suites or stand-alone, +        container, you can reuse both application code and configuration in, +        convenient to use than dynamic mock objects such as <ulink, +        url="http://www.easymock.org">EasyMock</ulink> or existing Servlet API, +        mock objects such as <ulink, +        url="http://www.mockobjects.com">MockObjects</ulink>.</para>, +        collection of reflection-based utility methods. Developers use these, +        methods in unit and integration testing scenarios in which they need, +        to set a non-<literal>public</literal> field or invoke a, +        non-<literal>public</literal> setter method when testing application, +            <para>ORM frameworks such as JPA and Hibernate that condone, +            <literal>private</literal> or <literal>protected</literal> field, +            access as opposed to <literal>public</literal> setter methods for, +            properties in a domain entity.</para>, +            <interfacename>@Resource,</interfacename> which provides, +            dependency injection for <literal>private</literal> or, +        contains <classname>ModelAndViewAssert</classname>, which you can use, +        in combination with JUnit 4+, TestNG, and so on for unit tests dealing, +        with Spring MVC <classname>ModelAndView</classname> objects.</para>, +          <literal>MockHttpSession</literal>, and so on from the <link, +      library (where <literal>VERSION</literal> is the release version). This, +      library includes the <literal>org.springframework.test</literal>, +      package, which contains valuable classes for integration testing with a, +      Spring container. This testing does not rely on an application server or, +      other deployment environment. Such tests are slower to run than unit, +      tests but much faster to than the equivalent Cactus tests or remote, +      tests that rely on deployment to an application server.</para>, +      <para>In Spring 2.5 and later, unit and integration testing support is, +      provided in the form of the annotation-driven <link, +      including JUnit, TestNG, and so on.</para>, +        <para>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy (for, +        example,, +        Migrate this code to the <link linkend="testcontext-framework">Spring, +      <title>Goals of integration testing</title>, +      <para>Spring's integration testing support has the following, +      goals:</para>, +          test fixture instances</link>.</para>, +          appropriate to integration testing.</para>, +          support classes</link> that are useful in writing integration, +          tests.<!--How is the last bullet point a *goal*? A goal is what the testing support is supposed to accomplish. Does customer write integration, +, +tests? Aren't these already provided?--></para>, +      <para>The next few sections describe each goal and provide links to, +      implementation and configuration details.</para>, +        because startup time can become an issue - not because of the overhead, +        of Spring itself, but because the objects instantiated by the Spring, +        container take time to instantiate. For example, a project with 50 to, +        100 Hibernate mapping files might take 10 to 20 seconds to load the, +        mapping files, and incurring that cost before running every test in, +        every test fixture leads to slower overall test runs that could reduce, +        of XML configuration metadata - typically in the classpath - that is, +        used to configure the application. These locations are the same as or, +        similar to the list of configuration locations specified in, +        <literal>web.xml</literal> or other deployment configuration, +        files.</para>, +        <interfacename>ApplicationContext</interfacename> is reused for each, +        test. Thus the setup cost is incurred only once (per test fixture),, +        and subsequent test execution is much faster. In the unlikely case, +        that a test corrupts the application context and requires reloading --, +        for example, by changing a bean definition or the state of an, +        application object-- a Spring testing support mechanism causes the, +        test fixture to reload the configurations and rebuilds the application, +        context before executing the next test.</para>, +        <para>See context management and caching with the <link, +        up test fixtures using preconfigured beans from your application, +        <para>See transaction management with the <link, +        <title>Support classes for integration testing</title>, +        <literal>abstract</literal> support classes that simplify the writing, +        of integration tests. These base test classes provide well-defined, +        hooks into the testing framework as well as convenient instance, +        variables and methods, which enable you to access:</para>, +            <para>The <literal>ApplicationContext</literal>, for performing]