[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	@SuppressWarnings("deprecation"), +		return determineRequiredStatus((AnnotationAttributes), +				ann.asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType())));, +	 * @deprecated since 5.2, in favor of {@link #determineRequiredStatus(MergedAnnotation)}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	@SuppressWarnings("deprecation"), +		return determineRequiredStatus((AnnotationAttributes), +				ann.asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType())));, +	 * @deprecated since 5.2, in favor of {@link #determineRequiredStatus(MergedAnnotation)}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AbstractMergedAnnotation.java, + * @author Juergen Hoeller, +	public Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition), +		return (condition.test(this) ? Optional.of(synthesize()) : Optional.empty());, +					"' present in merged annotation " + getType().getName());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	@SuppressWarnings("deprecation"), +		return determineRequiredStatus((AnnotationAttributes), +				ann.asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType())));, +	 * @deprecated since 5.2, in favor of {@link #determineRequiredStatus(MergedAnnotation)}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AbstractMergedAnnotation.java, + * @author Juergen Hoeller, +	public Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition), +		return (condition.test(this) ? Optional.of(synthesize()) : Optional.empty());, +					"' present in merged annotation " + getType().getName());, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	public static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {, +	private static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {, +				.map(mergedAnnotation -> mergedAnnotation.getType().getName()), +	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {, +		return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);, +	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {, +		return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);, +	public static boolean isAnnotated(AnnotatedElement element,Class<? extends Annotation> annotationType) {, +		// Shortcut: directly present on the element, with no processing needed?, +		if (AnnotationFilter.PLAIN.matches(annotationType)) {, +			return element.isAnnotationPresent(annotationType);, +		}, +		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types..., +		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {, +			return false;, +		}, +		// Exhaustive retrieval of merged annotations..., +	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,, +			String annotationName) {, +	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,, +			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +	public static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {, +		// Shortcut: directly present on the element, with no merging needed?, +		if (AnnotationFilter.PLAIN.matches(annotationType)) {, +			return element.getDeclaredAnnotation(annotationType);, +		}, +		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types..., +		// Exhaustive retrieval of merged annotations..., +	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,, +			String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {, +	public static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {, +		if (AnnotationFilter.PLAIN.matches(annotationType)) {, +			return element.isAnnotationPresent(annotationType);, +		}, +		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types..., +		// Exhaustive retrieval of merged annotations..., +	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,, +			Class<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,, +			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +	public static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {, +		// Shortcut: directly present on the element, with no merging needed?, +		if (AnnotationFilter.PLAIN.matches(annotationType)) {, +			return element.getDeclaredAnnotation(annotationType);, +		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types..., +		// Exhaustive retrieval of merged annotations..., +	public static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {, +	public static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {, +	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {, +				RepeatableContainers.none(), AnnotationFilter.PLAIN);, +			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {, +				repeatableContainers, AnnotationFilter.PLAIN);, +				RepeatableContainers.none(), AnnotationFilter.PLAIN);, +			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {, +				repeatableContainers, AnnotationFilter.PLAIN);, +			return annotation.getType().getName();, +		return annotation.getParent().getType().getName() + ":" + annotation.getParent().getType().getName();, +	private static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {, +		return (map.isEmpty() ? null : map);, +		return annotation.asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType()),, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	@SuppressWarnings("deprecation"), +		return determineRequiredStatus((AnnotationAttributes), +				ann.asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType())));, +	 * @deprecated since 5.2, in favor of {@link #determineRequiredStatus(MergedAnnotation)}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AbstractMergedAnnotation.java, + * @author Juergen Hoeller, +	public Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition), +		return (condition.test(this) ? Optional.of(synthesize()) : Optional.empty());, +					"' present in merged annotation " + getType().getName());, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java]