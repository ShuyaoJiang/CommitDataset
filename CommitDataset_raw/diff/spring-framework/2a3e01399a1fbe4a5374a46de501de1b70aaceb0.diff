[+++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpClient.java, +import io.netty.channel.group.ChannelGroupFuture;, +import org.springframework.util.concurrent.SettableListenableFuture;, + * Reactor Netty based implementation of {@link TcpOperations}., +	private final ChannelGroup channelGroup;, +, +	private volatile boolean stopping = false;, +	 * Basic constructor with a host and a port., +	 * Alternate constructor with a {@link ClientOptions} consumer providing, +	 * additional control beyond a host and a port., +	public ReactorNettyTcpClient(Consumer<ClientOptions> consumer, ReactorNettyCodec<P> codec) {, +		Assert.notNull(consumer, "Consumer<ClientOptions> is required");, +		Assert.notNull(codec, "ReactorNettyCodec is required");, +		this.channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);, +		this.tcpClient = TcpClient.create(consumer.andThen(opts -> opts.channelGroup(this.channelGroup)));, +		Assert.notNull(handler, "TcpConnectionHandler is required");, +			return handleShuttingDownConnectFailure(handler);, +				.newHandler(new ReactorNettyHandler(handler)), +		Assert.notNull(handler, "TcpConnectionHandler is required");, +		Assert.notNull(strategy, "ReconnectStrategy is required");, +			return handleShuttingDownConnectFailure(handler);, +		this.tcpClient, +				.newHandler(new ReactorNettyHandler(handler)), +				.doOnNext(connectFailureConsumer(connectMono)), +				.doOnError(connectFailureConsumer(connectMono)), +				.retryWhen(reconnectFunction(strategy)), +				.repeatWhen(reconnectFunction(strategy)), +	private ListenableFuture<Void> handleShuttingDownConnectFailure(TcpConnectionHandler<P> handler) {, +		IllegalStateException ex = new IllegalStateException("Shutting down.");, +		handler.afterConnectFailure(ex);, +		return new MonoToListenableFutureAdapter<>(Mono.error(ex));, +	}, +, +	private <T> Consumer<T> connectFailureConsumer(MonoProcessor<Void> connectMono) {, +		return o -> {, +			if (!connectMono.isTerminated()) {, +				if (o instanceof Throwable) {, +					connectMono.onError((Throwable) o);, +				}, +				else {, +					connectMono.onComplete();, +				}, +			}, +		};, +	}, +, +	private <T> Function<Flux<T>, Publisher<?>> reconnectFunction(ReconnectStrategy reconnectStrategy) {, +		return flux -> flux.scan(1, (count, e) -> count++), +				.flatMap(attempt -> Mono.delayMillis(reconnectStrategy.getTimeToNextAttempt(attempt)));, +	}, +, +			SettableListenableFuture<Void> future = new SettableListenableFuture<>();, +			future.set(null);, +			return future;, +		ChannelGroupFuture future = this.channelGroup.close();, +		Mono<Void> completion = FutureMono.from(future).doAfterTerminate((x, e) -> scheduler.dispose());, +	private class ReactorNettyHandler implements BiFunction<NettyInbound, NettyOutbound, Publisher<Void>> {, +		ReactorNettyHandler(TcpConnectionHandler<P> handler) {, +		public Publisher<Void> apply(NettyInbound inbound, NettyOutbound outbound) {, +			DirectProcessor<Void> completion = DirectProcessor.create();, +			TcpConnection<P> connection = new ReactorNettyTcpConnection<>(inbound, outbound,  codec, completion);, +			scheduler.schedule(() -> connectionHandler.afterConnected(connection));, +			inbound.receive(), +					.map(codec.getDecoder()), +					.publishOn(scheduler, QueueSupplier.SMALL_BUFFER_SIZE), +					.flatMapIterable(Function.identity()), +			return completion;, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpClient.java, +import io.netty.channel.group.ChannelGroupFuture;, +import org.springframework.util.concurrent.SettableListenableFuture;, + * Reactor Netty based implementation of {@link TcpOperations}., +	private final ChannelGroup channelGroup;, +, +	private volatile boolean stopping = false;, +	 * Basic constructor with a host and a port., +	 * Alternate constructor with a {@link ClientOptions} consumer providing, +	 * additional control beyond a host and a port., +	public ReactorNettyTcpClient(Consumer<ClientOptions> consumer, ReactorNettyCodec<P> codec) {, +		Assert.notNull(consumer, "Consumer<ClientOptions> is required");, +		Assert.notNull(codec, "ReactorNettyCodec is required");, +		this.channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);, +		this.tcpClient = TcpClient.create(consumer.andThen(opts -> opts.channelGroup(this.channelGroup)));, +		Assert.notNull(handler, "TcpConnectionHandler is required");, +			return handleShuttingDownConnectFailure(handler);, +				.newHandler(new ReactorNettyHandler(handler)), +		Assert.notNull(handler, "TcpConnectionHandler is required");, +		Assert.notNull(strategy, "ReconnectStrategy is required");, +			return handleShuttingDownConnectFailure(handler);, +		this.tcpClient, +				.newHandler(new ReactorNettyHandler(handler)), +				.doOnNext(connectFailureConsumer(connectMono)), +				.doOnError(connectFailureConsumer(connectMono)), +				.retryWhen(reconnectFunction(strategy)), +				.repeatWhen(reconnectFunction(strategy)), +	private ListenableFuture<Void> handleShuttingDownConnectFailure(TcpConnectionHandler<P> handler) {, +		IllegalStateException ex = new IllegalStateException("Shutting down.");, +		handler.afterConnectFailure(ex);, +		return new MonoToListenableFutureAdapter<>(Mono.error(ex));, +	}, +]