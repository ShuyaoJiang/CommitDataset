[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +, +		return Flux.defer(() -> {, +						long remainder = countDown.addAndGet(-buffer.readableByteCount());, +						if (remainder < 0) {, +							int length = buffer.readableByteCount() + (int) remainder;, +							return buffer.slice(0, length);, +						}, +						else {, +							return buffer;, +						}, +		}); // no doOnDiscard necessary, as this method does not drop buffers, +, +		return Flux.defer(() -> {, +			AtomicLong countDown = new AtomicLong(maxByteCount);, +						long remainder = countDown.addAndGet(-buffer.readableByteCount());, +						return remainder < 0;, +						long remainder = countDown.get();, +						if (remainder < 0) {, +							countDown.set(0);, +							int start = buffer.readableByteCount() + (int)remainder;, +							int length = (int) -remainder;, +							return buffer.slice(start, length);, +						else {, +						}, +		}).doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);, +				.map(list -> {, +					return bufferFactory.join(list);, +				}), +				.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +, +		return Flux.defer(() -> {, +						long remainder = countDown.addAndGet(-buffer.readableByteCount());, +						if (remainder < 0) {, +							int length = buffer.readableByteCount() + (int) remainder;, +							return buffer.slice(0, length);, +						}, +						else {, +							return buffer;, +						}, +		}); // no doOnDiscard necessary, as this method does not drop buffers, +, +		return Flux.defer(() -> {, +			AtomicLong countDown = new AtomicLong(maxByteCount);, +						long remainder = countDown.addAndGet(-buffer.readableByteCount());, +						return remainder < 0;, +						long remainder = countDown.get();, +						if (remainder < 0) {, +							countDown.set(0);, +							int start = buffer.readableByteCount() + (int)remainder;, +							int length = (int) -remainder;, +							return buffer.slice(start, length);, +						else {, +						}, +		}).doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);, +				.map(list -> {, +					return bufferFactory.join(list);, +				}), +				.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/DataBufferUtilsTests.java, +	public void takeUntilByteCountErrorInFlux() {, +		DataBuffer foo = stringBuffer("foo");, +		Flux<DataBuffer> flux =, +				Flux.just(foo).concatWith(Mono.error(new RuntimeException()));, +, +		Flux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(flux, 5L);, +, +		StepVerifier.create(result), +				.consumeNextWith(stringConsumer("foo")), +				.expectError(RuntimeException.class), +				.verify(Duration.ofSeconds(5));, +	}, +, +	@Test, +	public void skipUntilByteCountErrorInFlux() {, +		DataBuffer foo = stringBuffer("foo");, +		Flux<DataBuffer> flux =, +				Flux.just(foo).concatWith(Mono.error(new RuntimeException()));, +		Flux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(flux, 3L);, +, +		StepVerifier.create(result), +				.expectError(RuntimeException.class), +				.verify(Duration.ofSeconds(5));, +	}, +, +	@Test]