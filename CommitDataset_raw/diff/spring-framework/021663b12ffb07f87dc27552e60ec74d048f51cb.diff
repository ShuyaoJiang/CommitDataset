[+++ b/org.springframework.context.support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = Integer.MAX_VALUE;, +	 * Specify the phase in which this scheduler should be started and, +	 * stopped. The startup order proceeds from lowest to highest, and, +	 * the shutdown order is the reverse of that. By default this value, +	 * is Integer.MAX_VALUE meaning that this scheduler starts as late, +	 * as possible and stops as soon as possible., +	public void setPhase(int phase) {, +		this.phase = phase;, +	 * Return the phase in which this scheduler will be started and stopped., +	public int getPhase() {, +		return this.phase;, +++ b/org.springframework.context.support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = Integer.MAX_VALUE;, +	 * Specify the phase in which this scheduler should be started and, +	 * stopped. The startup order proceeds from lowest to highest, and, +	 * the shutdown order is the reverse of that. By default this value, +	 * is Integer.MAX_VALUE meaning that this scheduler starts as late, +	 * as possible and stops as soon as possible., +	public void setPhase(int phase) {, +		this.phase = phase;, +	 * Return the phase in which this scheduler will be started and stopped., +	public int getPhase() {, +		return this.phase;, +++ b/org.springframework.context.support/src/test/resources/org/springframework/scheduling/quartz/quartzSchedulerLifecycleTests.xml, +		<property name="phase" value="99"/>, +++ b/org.springframework.context.support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = Integer.MAX_VALUE;, +	 * Specify the phase in which this scheduler should be started and, +	 * stopped. The startup order proceeds from lowest to highest, and, +	 * the shutdown order is the reverse of that. By default this value, +	 * is Integer.MAX_VALUE meaning that this scheduler starts as late, +	 * as possible and stops as soon as possible., +	public void setPhase(int phase) {, +		this.phase = phase;, +	 * Return the phase in which this scheduler will be started and stopped., +	public int getPhase() {, +		return this.phase;, +++ b/org.springframework.context.support/src/test/resources/org/springframework/scheduling/quartz/quartzSchedulerLifecycleTests.xml, +		<property name="phase" value="99"/>, +++ b/org.springframework.context/src/main/java/org/springframework/context/SmartLifecycle.java, +	 * Return the phase within which this Lifecycle component should be started, +	 * and stopped. The startup process begins with the <i>lowest</i> phase, +	 * value and ends with the <i>highest</i> phase value (Integer.MIN_VALUE is, +	 * the lowest possible, and Integer.MAX_VALUE is the highest possible). The, +	 * shutdown process will apply the reverse order. Any components with the, +	 * same value will be arbitrarily ordered within the same phase., +	 * <p>, +	 * Example: if component B depends on component A having already started, then, +	 * component A should have a lower phase value than component B. During the, +	 * shutdown process, component B would be stopped before component A., +	 * <p>, +	 * Any Lifecycle components within the context that do not also implement, +	 * SmartLifecycle will be treated as if they have a phase value of 0. That, +	 * way a SmartLifecycle implementation may start before those Lifecycle, +	 * components if it has a negative phase value, or it may start after, +	 * those components if it has a positive phase value., +	 * <p>, +	 * Any explicit "depends-on" relationship will take precedence over, +	 * the phase order such that the dependent bean always starts after its, +	 * dependency and always stops before its dependency., +	int getPhase();, +++ b/org.springframework.context.support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = Integer.MAX_VALUE;, +	 * Specify the phase in which this scheduler should be started and, +	 * stopped. The startup order proceeds from lowest to highest, and, +	 * the shutdown order is the reverse of that. By default this value, +	 * is Integer.MAX_VALUE meaning that this scheduler starts as late, +	 * as possible and stops as soon as possible., +	public void setPhase(int phase) {, +		this.phase = phase;, +	 * Return the phase in which this scheduler will be started and stopped., +	public int getPhase() {, +		return this.phase;, +++ b/org.springframework.context.support/src/test/resources/org/springframework/scheduling/quartz/quartzSchedulerLifecycleTests.xml, +		<property name="phase" value="99"/>, +++ b/org.springframework.context/src/main/java/org/springframework/context/SmartLifecycle.java, +	 * Return the phase within which this Lifecycle component should be started, +	 * and stopped. The startup process begins with the <i>lowest</i> phase, +	 * value and ends with the <i>highest</i> phase value (Integer.MIN_VALUE is, +	 * the lowest possible, and Integer.MAX_VALUE is the highest possible). The, +	 * shutdown process will apply the reverse order. Any components with the, +	 * same value will be arbitrarily ordered within the same phase., +	 * <p>, +	 * Example: if component B depends on component A having already started, then, +	 * component A should have a lower phase value than component B. During the, +	 * shutdown process, component B would be stopped before component A., +	 * <p>, +	 * Any Lifecycle components within the context that do not also implement, +	 * SmartLifecycle will be treated as if they have a phase value of 0. That, +	 * way a SmartLifecycle implementation may start before those Lifecycle, +	 * components if it has a negative phase value, or it may start after, +	 * those components if it has a positive phase value., +	 * <p>, +	 * Any explicit "depends-on" relationship will take precedence over, +	 * the phase order such that the dependent bean always starts after its, +	 * dependency and always stops before its dependency., +	int getPhase();, +++ b/org.springframework.context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java, +	private volatile long timeoutPerShutdownPhase = 30000;]