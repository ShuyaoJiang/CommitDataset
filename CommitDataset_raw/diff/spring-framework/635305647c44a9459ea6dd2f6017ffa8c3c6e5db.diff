[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +, +		return findMergedAnnotationOnBean(beanName, annotationType), +				.synthesize(MergedAnnotation::isPresent).orElse(null);, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +, +		return findMergedAnnotationOnBean(beanName, annotationType), +				.synthesize(MergedAnnotation::isPresent).orElse(null);, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +		this.root = (parent != null ? parent.getRoot() : this);, +		this.depth = (parent == null ? 0 : parent.getDepth() + 1);, +		this.aliasMappings = filledIntArray(this.attributes.size());, +		this.conventionMappings = filledIntArray(this.attributes.size());, +		this.annotationValueMappings = filledIntArray(this.attributes.size());, +			AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);, +				aliasedBy.computeIfAbsent(target, key -> new ArrayList<>()).add(attribute);, +		if (StringUtils.hasText(aliasFor.value()) && StringUtils.hasText(aliasFor.attribute())) {, +					"In @AliasFor declared on %s, attribute 'attribute' and its alias 'value' " +, +					"are present with values of '%s' and '%s', but only one is permitted.",, +		Method target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);, +						"@AliasFor declaration on %s declares an alias for '%s' which is not present.",, +					"@AliasFor declaration on %s points to itself. " +, +					"Specify 'annotation' to point to a same-named attribute on a meta-annotation.",, +				throw new AnnotationConfigurationException(String.format(, +						"%s must be declared as an @AliasFor '%s'.",, +			while (mapping != null && mapping.depth > 0) {, +				if (mapped != -1 && (this.annotationValueMappings[i] == -1 ||, +						this.annotationValueSource[i].depth > mapping.depth)) {, +						AttributeMethods.describe(attribute), AttributeMethods.describe(target)));, +						AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));, +						AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));, +		return ReflectionUtils.invokeMethod(source.attributes.get(mapped), source.annotation);, +, +, +	private static int[] filledIntArray(int size) {, +		Arrays.fill(array, -1);, +, +	private static boolean areEquivalent(@Nullable Object value, @Nullable Object extractedValue,, +, +, +		AttributeMethods attributes = AttributeMethods.forAnnotationType(value.annotationType());, +				Set<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));, +					boolean isDefaultValue = (value == null ||, +							isEquivalentToDefaultValue(attribute, value, valueExtractor));, +								"Different @AliasFor mirror values for annotation [%s]%s, attribute '%s' " +, +								"and its alias '%s' are declared with values of [%s] and [%s].",, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +, +		return findMergedAnnotationOnBean(beanName, annotationType), +				.synthesize(MergedAnnotation::isPresent).orElse(null);, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +		this.root = (parent != null ? parent.getRoot() : this);, +		this.depth = (parent == null ? 0 : parent.getDepth() + 1);, +		this.aliasMappings = filledIntArray(this.attributes.size());, +		this.conventionMappings = filledIntArray(this.attributes.size());, +		this.annotationValueMappings = filledIntArray(this.attributes.size());, +			AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);, +				aliasedBy.computeIfAbsent(target, key -> new ArrayList<>()).add(attribute);, +		if (StringUtils.hasText(aliasFor.value()) && StringUtils.hasText(aliasFor.attribute())) {, +					"In @AliasFor declared on %s, attribute 'attribute' and its alias 'value' " +, +					"are present with values of '%s' and '%s', but only one is permitted.",, +		Method target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);, +						"@AliasFor declaration on %s declares an alias for '%s' which is not present.",, +					"@AliasFor declaration on %s points to itself. " +, +					"Specify 'annotation' to point to a same-named attribute on a meta-annotation.",, +				throw new AnnotationConfigurationException(String.format(, +						"%s must be declared as an @AliasFor '%s'.",, +			while (mapping != null && mapping.depth > 0) {, +				if (mapped != -1 && (this.annotationValueMappings[i] == -1 ||, +						this.annotationValueSource[i].depth > mapping.depth)) {, +						AttributeMethods.describe(attribute), AttributeMethods.describe(target)));, +						AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));, +						AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));, +		return ReflectionUtils.invokeMethod(source.attributes.get(mapped), source.annotation);, +, +, +	private static int[] filledIntArray(int size) {, +		Arrays.fill(array, -1);, +, +	private static boolean areEquivalent(@Nullable Object value, @Nullable Object extractedValue,, +, +, +		AttributeMethods attributes = AttributeMethods.forAnnotationType(value.annotationType());, +				Set<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));, +					boolean isDefaultValue = (value == null ||, +							isEquivalentToDefaultValue(attribute, value, valueExtractor));, +								"Different @AliasFor mirror values for annotation [%s]%s, attribute '%s' " +, +								"and its alias '%s' are declared with values of [%s] and [%s].",, +		}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationsScanner.java, +				return processElement(context, source, processor, classFilter);, +				return processClassInheritedAnnotations(context, source, processor, classFilter);, +				return processClassHierarchy(context, new int[] {0}, source, processor, classFilter, false);, +				return processClassHierarchy(context, new int[] {0}, source, processor, classFilter, true);, +		return (result != null ? result : processor.doWithAnnotations(, +				context, 0, source, getDeclaredAnnotations(context, source, classFilter, false)));]