[+++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Abstract implementation of {@link JCacheOperationSource} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. declaring method., + * <p>This implementation caches attributes by method after they are first used., + * @author Juergen Hoeller, +public abstract class AbstractFallbackJCacheOperationSource implements JCacheOperationSource {, +, +	private final Map<Object, Object> cache = new ConcurrentHashMap<Object, Object>(1024);, +, +, +			return (cached != NULL_CACHING_ATTRIBUTE ? (JCacheOperation<?>) cached : null);, +			if (operation != null) {, +					logger.debug("Adding cacheable method '" + method.getName() + "' with operation: " + operation);, +			else {, +				this.cache.put(cacheKey, NULL_CACHING_ATTRIBUTE);, +			}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Abstract implementation of {@link JCacheOperationSource} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. declaring method., + * <p>This implementation caches attributes by method after they are first used., + * @author Juergen Hoeller, +public abstract class AbstractFallbackJCacheOperationSource implements JCacheOperationSource {, +, +	private final Map<Object, Object> cache = new ConcurrentHashMap<Object, Object>(1024);, +, +, +			return (cached != NULL_CACHING_ATTRIBUTE ? (JCacheOperation<?>) cached : null);, +			if (operation != null) {, +					logger.debug("Adding cacheable method '" + method.getName() + "' with operation: " + operation);, +			else {, +				this.cache.put(cacheKey, NULL_CACHING_ATTRIBUTE);, +			}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/DefaultJCacheOperationSource.java, +	 * <p>A non-JSR-107 setup requires either a {@link CacheManager} or a {@link CacheResolver}. If only, +	 * <p>This gives this weird situation of a perfectly valid configuration that breaks all the sudden, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Abstract implementation of {@link JCacheOperationSource} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. declaring method., + * <p>This implementation caches attributes by method after they are first used., + * @author Juergen Hoeller, +public abstract class AbstractFallbackJCacheOperationSource implements JCacheOperationSource {, +, +	private final Map<Object, Object> cache = new ConcurrentHashMap<Object, Object>(1024);, +, +, +			return (cached != NULL_CACHING_ATTRIBUTE ? (JCacheOperation<?>) cached : null);, +			if (operation != null) {, +					logger.debug("Adding cacheable method '" + method.getName() + "' with operation: " + operation);, +			else {, +				this.cache.put(cacheKey, NULL_CACHING_ATTRIBUTE);, +			}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/DefaultJCacheOperationSource.java, +	 * <p>A non-JSR-107 setup requires either a {@link CacheManager} or a {@link CacheResolver}. If only, +	 * <p>This gives this weird situation of a perfectly valid configuration that breaks all the sudden, +++ b/spring-context-support/src/test/java/org/springframework/cache/jcache/config/JCacheJavaConfigTests.java, +, +, +		ConfigurableApplicationContext context =, +				new AnnotationConfigApplicationContext(NoExceptionCacheResolverConfig.class);, +, +, +, +, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Abstract implementation of {@link JCacheOperationSource} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. declaring method., + * <p>This implementation caches attributes by method after they are first used., + * @author Juergen Hoeller, +public abstract class AbstractFallbackJCacheOperationSource implements JCacheOperationSource {, +, +	private final Map<Object, Object> cache = new ConcurrentHashMap<Object, Object>(1024);, +, +, +			return (cached != NULL_CACHING_ATTRIBUTE ? (JCacheOperation<?>) cached : null);, +			if (operation != null) {, +					logger.debug("Adding cacheable method '" + method.getName() + "' with operation: " + operation);, +			else {, +				this.cache.put(cacheKey, NULL_CACHING_ATTRIBUTE);, +			}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/DefaultJCacheOperationSource.java, +	 * <p>A non-JSR-107 setup requires either a {@link CacheManager} or a {@link CacheResolver}. If only, +	 * <p>This gives this weird situation of a perfectly valid configuration that breaks all the sudden, +++ b/spring-context-support/src/test/java/org/springframework/cache/jcache/config/JCacheJavaConfigTests.java, +, +, +		ConfigurableApplicationContext context =, +				new AnnotationConfigApplicationContext(NoExceptionCacheResolverConfig.class);, +, +, +, +]