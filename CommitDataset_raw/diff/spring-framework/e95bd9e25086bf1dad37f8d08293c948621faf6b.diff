[+++ b/spring-context/src/main/java/org/springframework/context/annotation/AnnotationConfigUtils.java, +import java.util.Collections;, +import java.util.Map;, +import org.springframework.core.type.AnnotationMetadata;, + * @author Phillip Webb, +	static AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, Class<?> annotationClass) {, +		return attributesFor(metadata, annotationClass.getName());, +	static AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, String annotationClassName) {, +		return AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName, false));, +	}, +, +	static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,, +			Class<?> containerClass, Class<?> annotationClass) {, +		return attributesForRepeatable(metadata, containerClass.getName(), annotationClass.getName());, +	}, +, +	@SuppressWarnings("unchecked"), +	static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,, +			String containerClassName, String annotationClassName) {, +		Set<AnnotationAttributes> result = new LinkedHashSet<AnnotationAttributes>();, +, +		addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, false));, +, +		Map<String, Object> container = metadata.getAnnotationAttributes(containerClassName, false);, +		if (container != null && container.containsKey("value")) {, +			for (Map<String, Object> containedAttributes : (Map<String, Object>[]) container.get("value")) {, +				addAttributesIfNotNull(result, containedAttributes);, +			}, +		}, +		return Collections.unmodifiableSet(result);, +	}, +, +	private static void addAttributesIfNotNull(Set<AnnotationAttributes> result,, +			Map<String, Object> attributes) {, +		if (attributes != null) {, +			result.add(AnnotationAttributes.fromMap(attributes));, +		}, +++ b/spring-context/src/main/java/org/springframework/context/annotation/AnnotationConfigUtils.java, +import java.util.Collections;, +import java.util.Map;, +import org.springframework.core.type.AnnotationMetadata;, + * @author Phillip Webb, +	static AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, Class<?> annotationClass) {, +		return attributesFor(metadata, annotationClass.getName());, +	static AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, String annotationClassName) {, +		return AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName, false));, +	}, +, +	static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,, +			Class<?> containerClass, Class<?> annotationClass) {, +		return attributesForRepeatable(metadata, containerClass.getName(), annotationClass.getName());, +	}, +, +	@SuppressWarnings("unchecked"), +	static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,, +			String containerClassName, String annotationClassName) {, +		Set<AnnotationAttributes> result = new LinkedHashSet<AnnotationAttributes>();, +, +		addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, false));, +, +		Map<String, Object> container = metadata.getAnnotationAttributes(containerClassName, false);, +		if (container != null && container.containsKey("value")) {, +			for (Map<String, Object> containedAttributes : (Map<String, Object>[]) container.get("value")) {, +				addAttributesIfNotNull(result, containedAttributes);, +			}, +		}, +		return Collections.unmodifiableSet(result);, +	}, +, +	private static void addAttributesIfNotNull(Set<AnnotationAttributes> result,, +			Map<String, Object> attributes) {, +		if (attributes != null) {, +			result.add(AnnotationAttributes.fromMap(attributes));, +		}, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.io.FileNotFoundException;, +import org.springframework.core.io.Resource;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +	private final MultiValueMap<String, PropertySource<?>> propertySources = new LinkedMultiValueMap<String, PropertySource<?>>();, +		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(, +				sourceClass.getMetadata(), PropertySources.class,, +				org.springframework.context.annotation.PropertySource.class)) {, +		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");, +			Resource resource = this.resourceLoader.getResource(, +					this.environment.resolveRequiredPlaceholders(location));, +			try {, +				if (!StringUtils.hasText(name) || this.propertySources.containsKey(name)) {, +					// We need to ensure unique names when the property source will, +					// ultimately end up in a composite, +					ResourcePropertySource ps = new ResourcePropertySource(resource);, +					this.propertySources.add((StringUtils.hasText(name) ? name : ps.getName()), ps);, +					this.propertySources.add(name, new ResourcePropertySource(name, resource));, +			catch (FileNotFoundException ex) {, +				if (!ignoreResourceNotFound) {, +					throw ex;, +				}, +	public List<PropertySource<?>> getPropertySources() {, +		List<PropertySource<?>> propertySources = new LinkedList<PropertySource<?>>();, +		for (Map.Entry<String, List<PropertySource<?>>> entry : this.propertySources.entrySet()) {]