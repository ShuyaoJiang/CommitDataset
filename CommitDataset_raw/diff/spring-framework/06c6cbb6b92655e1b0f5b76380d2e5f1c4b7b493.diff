[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import javax.servlet.http.HttpServletRequest;, +import javax.servlet.http.HttpServletResponse;, +	/** Dummy marker object for unresolved views in the cache Maps */, +	private static final View UNRESOLVED_VIEW = new View() {, +		public String getContentType() {, +			return null;, +		}, +		public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {, +		}, +	};, +, +	/** The maximum number of entries in the cache */, +	/** Fast access cache for Views, returning already cached instances without a global lock */, +	private final Map<Object, View> viewAccessCache = new ConcurrentHashMap<Object, View>(DEFAULT_CACHE_LIMIT);, +, +	/** Map from view key to View instance, synchronized for View creation */, +	private final Map<Object, View> viewCreationCache =, +					if (size() > getCacheLimit()) {, +						viewAccessCache.remove(eldest.getKey());, +						return true;, +					}, +					else {, +						return false;, +					}, +			View view = this.viewAccessCache.get(cacheKey);, +			if (view == null) {, +				synchronized (this.viewCreationCache) {, +					view = this.viewCreationCache.get(cacheKey);, +					if (view == null) {, +						if (view == null && this.cacheUnresolved) {, +							view = UNRESOLVED_VIEW;, +						}, +						if (view != null) {, +							this.viewAccessCache.put(cacheKey, view);, +							this.viewCreationCache.put(cacheKey, view);, +			return (view != UNRESOLVED_VIEW ? view : null);, +		}, +			synchronized (this.viewCreationCache) {, +				this.viewAccessCache.remove(cacheKey);, +				cachedView = this.viewCreationCache.remove(cacheKey);, +				// Some debug output might be useful..., +				if (cachedView == null) {, +		synchronized (this.viewCreationCache) {, +			this.viewAccessCache.clear();, +			this.viewCreationCache.clear();]