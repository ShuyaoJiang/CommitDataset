[+++ b/spring-core/src/main/java/org/springframework/core/codec/StringDecoder.java, + * Copyright 2002-2018 the original author or authors., +import java.util.Arrays;, +import java.util.stream.Collectors;, +import reactor.core.publisher.Mono;, +import org.springframework.core.io.buffer.DefaultDataBufferFactory;, +import org.springframework.util.Assert;, + * Decode from a data buffer stream to a {@code String} stream. Before decoding, this decoder, + * realigns the incoming data buffers so that each buffer ends with a newline., + * This is to make sure that multibyte characters are decoded properly, and do not cross buffer, + * boundaries. The default delimiters ({@code \n}, {@code \r\n})can be customized., + * <p>Partially inspired by Netty's {@code DelimiterBasedFrameDecoder}., +	private static final DataBuffer END_FRAME = new DefaultDataBufferFactory().wrap(new byte[0]);, +	 * The default charset to use, i.e. "UTF-8"., +	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;, +, +	/**, +	 * The default delimiter strings to use, i.e. {@code \n} and {@code \r\n}., +	 */, +	public static final List<String> DEFAULT_DELIMITERS = Arrays.asList("\r\n", "\n");, +, +, +	private final List<String> delimiters;, +, +	private final boolean stripDelimiter;, +, +	private StringDecoder(List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {, +		Assert.notEmpty(delimiters, "'delimiters' must not be empty");, +		this.delimiters = new ArrayList<>(delimiters);, +		this.stripDelimiter = stripDelimiter;, +		List<byte[]> delimiterBytes = getDelimiterBytes(mimeType);, +, +		Flux<DataBuffer> inputFlux = Flux.from(inputStream), +				.flatMap(dataBuffer -> splitOnDelimiter(dataBuffer, delimiterBytes)), +				.bufferUntil(StringDecoder::isEndFrame), +				.flatMap(StringDecoder::joinUntilEndFrame);, +	private List<byte[]> getDelimiterBytes(@Nullable MimeType mimeType) {, +		Charset charset = getCharset(mimeType);, +		return this.delimiters.stream(), +				.map(s -> s.getBytes(charset)), +				.collect(Collectors.toList());, +, +	/**, +	 * Splits the given data buffer on delimiter boundaries. The returned Flux contains a, +	 * {@link #END_FRAME} buffer after each delimiter., +	 */, +	private Flux<DataBuffer> splitOnDelimiter(DataBuffer dataBuffer, List<byte[]> delimiterBytes) {, +		List<DataBuffer> frames = new ArrayList<>();, +		do {, +			int length = Integer.MAX_VALUE;, +			byte[] matchingDelimiter = null;, +			for (byte[] delimiter : delimiterBytes) {, +				int idx = indexOf(dataBuffer, delimiter);, +				if (idx >= 0 && idx < length) {, +					length = idx;, +					matchingDelimiter = delimiter;, +				}, +			}, +			DataBuffer frame;, +			int readPosition = dataBuffer.readPosition();, +			if (matchingDelimiter != null) {, +				if (this.stripDelimiter) {, +					frame = dataBuffer.slice(readPosition, length);, +				}, +				else {, +					frame = dataBuffer.slice(readPosition, length + matchingDelimiter.length);, +				}, +				dataBuffer.readPosition(readPosition + length + matchingDelimiter.length);, +, +				frames.add(DataBufferUtils.retain(frame));, +				frames.add(END_FRAME);, +			}, +			else {, +				frame = dataBuffer.slice(readPosition, dataBuffer.readableByteCount());, +				dataBuffer.readPosition(readPosition + dataBuffer.readableByteCount());, +				frames.add(DataBufferUtils.retain(frame));, +			}, +		}, +		while (dataBuffer.readableByteCount() > 0);, +, +		return Flux.fromIterable(frames);, +	}, +, +	/**, +	 * Finds the given delimiter in the given data buffer. Return the index of the delimiter, or, +	 * -1 if not found., +	 */, +	private static int indexOf(DataBuffer dataBuffer, byte[] delimiter) {, +		for (int i = dataBuffer.readPosition(); i < dataBuffer.writePosition(); i++) {, +			int dataBufferPos = i;, +			int delimiterPos = 0;, +			while (delimiterPos < delimiter.length) {, +				if (dataBuffer.getByte(dataBufferPos) != delimiter[delimiterPos]) {, +					break;, +				}, +				else {, +					dataBufferPos++;, +					if (dataBufferPos == dataBuffer.writePosition() &&, +							delimiterPos != delimiter.length - 1) {, +						return -1;]