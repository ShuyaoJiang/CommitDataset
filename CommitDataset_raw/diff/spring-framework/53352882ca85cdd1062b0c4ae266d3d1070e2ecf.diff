[+++ b/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java, + * Copyright 2002-2014 the original author or authors., +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Assert.notNull(source, "Source must not be null");, +		Assert.notNull(type, "Type must not be null");, +		return (this.host != null && this.host.startsWith("[")) ? Type.HOST_IPV6 : Type.HOST_IPV4;, +++ b/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java, + * Copyright 2002-2014 the original author or authors., +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Assert.notNull(source, "Source must not be null");, +		Assert.notNull(type, "Type must not be null");, +		return (this.host != null && this.host.startsWith("[")) ? Type.HOST_IPV6 : Type.HOST_IPV4;, +++ b/spring-web/src/main/java/org/springframework/web/util/UriUtils.java, + * Copyright 2002-2014 the original author or authors., + * Utility class for URI encoding and decoding based on RFC 3986., + * Offers encoding methods for the various URI components., + * <li>All other characters are converted into one or more bytes in the given encoding scheme., + * Each of the resulting bytes is written as a hexadecimal string in the "{@code %<i>xy</i>}", + * format.</li>, +, +		Assert.notNull(uri, "URI must not be null");, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Matcher matcher = URI_PATTERN.matcher(uri);, +		if (matcher.matches()) {, +			String scheme = matcher.group(2);, +			String authority = matcher.group(3);, +			String userinfo = matcher.group(5);, +			String host = matcher.group(6);, +			String port = matcher.group(8);, +			String path = matcher.group(9);, +			String query = matcher.group(11);, +			String fragment = matcher.group(13);, +		Assert.notNull(httpUrl, "HTTP URL must not be null");, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		Matcher matcher = HTTP_URL_PATTERN.matcher(httpUrl);, +		if (matcher.matches()) {, +			String scheme = matcher.group(1);, +			String authority = matcher.group(2);, +			String userinfo = matcher.group(4);, +			String host = matcher.group(5);, +			String portString = matcher.group(7);, +			String path = matcher.group(8);, +			String query = matcher.group(10);, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		return HierarchicalUriComponents.encodeUriComponent(scheme, encoding, HierarchicalUriComponents.Type.SCHEME);, +		return HierarchicalUriComponents.encodeUriComponent(authority, encoding, HierarchicalUriComponents.Type.AUTHORITY);, +		return HierarchicalUriComponents.encodeUriComponent(userInfo, encoding, HierarchicalUriComponents.Type.USER_INFO);, +		return HierarchicalUriComponents.encodeUriComponent(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);, +		return HierarchicalUriComponents.encodeUriComponent(port, encoding, HierarchicalUriComponents.Type.PORT);, +		return HierarchicalUriComponents.encodeUriComponent(path, encoding, HierarchicalUriComponents.Type.PATH);, +		return HierarchicalUriComponents.encodeUriComponent(segment, encoding, HierarchicalUriComponents.Type.PATH_SEGMENT);, +		return HierarchicalUriComponents.encodeUriComponent(query, encoding, HierarchicalUriComponents.Type.QUERY);, +		return HierarchicalUriComponents.encodeUriComponent(queryParam, encoding, HierarchicalUriComponents.Type.QUERY_PARAM);, +		return HierarchicalUriComponents.encodeUriComponent(fragment, encoding, HierarchicalUriComponents.Type.FRAGMENT);, +		Assert.notNull(source, "Source must not be null");, +		Assert.hasLength(encoding, "Encoding must not be empty");, +		return (changed ? new String(bos.toByteArray(), encoding) : source);]