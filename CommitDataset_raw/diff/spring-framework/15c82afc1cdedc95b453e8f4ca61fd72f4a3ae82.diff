[+++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToOptionalConverter.java, +import java.lang.reflect.Array;, +import java.util.Collection;, +import java.util.LinkedHashSet;, +		Set<ConvertiblePair> convertibleTypes = new LinkedHashSet<>(4);, +		convertibleTypes.add(new ConvertiblePair(Collection.class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object[].class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object.class, Optional.class));, +		return convertibleTypes;, +			if (target == null || (target.getClass().isArray() && Array.getLength(target) == 0) ||, +						(target instanceof Collection && ((Collection) target).isEmpty())) {, +				return Optional.empty();, +			}, +			return Optional.of(target);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToOptionalConverter.java, +import java.lang.reflect.Array;, +import java.util.Collection;, +import java.util.LinkedHashSet;, +		Set<ConvertiblePair> convertibleTypes = new LinkedHashSet<>(4);, +		convertibleTypes.add(new ConvertiblePair(Collection.class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object[].class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object.class, Optional.class));, +		return convertibleTypes;, +			if (target == null || (target.getClass().isArray() && Array.getLength(target) == 0) ||, +						(target instanceof Collection && ((Collection) target).isEmpty())) {, +				return Optional.empty();, +			}, +			return Optional.of(target);, +++ b/spring-core/src/main/java/org/springframework/util/ObjectUtils.java, +		if (obj.getClass().isArray()) {, +			return Array.getLength(obj) == 0;, +		}, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToOptionalConverter.java, +import java.lang.reflect.Array;, +import java.util.Collection;, +import java.util.LinkedHashSet;, +		Set<ConvertiblePair> convertibleTypes = new LinkedHashSet<>(4);, +		convertibleTypes.add(new ConvertiblePair(Collection.class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object[].class, Optional.class));, +		convertibleTypes.add(new ConvertiblePair(Object.class, Optional.class));, +		return convertibleTypes;, +			if (target == null || (target.getClass().isArray() && Array.getLength(target) == 0) ||, +						(target instanceof Collection && ((Collection) target).isEmpty())) {, +				return Optional.empty();, +			}, +			return Optional.of(target);, +++ b/spring-core/src/main/java/org/springframework/util/ObjectUtils.java, +		if (obj.getClass().isArray()) {, +			return Array.getLength(obj) == 0;, +		}, +++ b/spring-test/src/test/java/org/springframework/test/web/servlet/samples/standalone/MultipartControllerTests.java, +import java.util.List;, +import java.util.Optional;, +import org.junit.Assert;, + * @author Juergen Hoeller, +	public void multipartRequestWithSingleFile() throws Exception {, +				.perform(multipart("/multipartfile").file(filePart).file(jsonPart)), +	public void multipartRequestWithFileArray() throws Exception {, +		byte[] fileContent = "bar".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile filePart1 = new MockMultipartFile("file", "orig", null, fileContent);, +		MockMultipartFile filePart2 = new MockMultipartFile("file", "orig", null, fileContent);, +, +		byte[] json = "{\"name\":\"yeeeah\"}".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile jsonPart = new MockMultipartFile("json", "json", "application/json", json);, +, +		standaloneSetup(new MultipartController()).build(), +				.perform(multipart("/multipartfilearray").file(filePart1).file(filePart2).file(jsonPart)), +				.andExpect(status().isFound()), +				.andExpect(model().attribute("fileContent", fileContent)), +				.andExpect(model().attribute("jsonContent", Collections.singletonMap("name", "yeeeah")));, +	}, +, +	@Test, +	public void multipartRequestWithFileList() throws Exception {, +		byte[] fileContent = "bar".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile filePart1 = new MockMultipartFile("file", "orig", null, fileContent);, +		MockMultipartFile filePart2 = new MockMultipartFile("file", "orig", null, fileContent);, +, +		byte[] json = "{\"name\":\"yeeeah\"}".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile jsonPart = new MockMultipartFile("json", "json", "application/json", json);, +, +		standaloneSetup(new MultipartController()).build(), +				.perform(multipart("/multipartfilelist").file(filePart1).file(filePart2).file(jsonPart)), +				.andExpect(status().isFound()), +				.andExpect(model().attribute("fileContent", fileContent)), +				.andExpect(model().attribute("jsonContent", Collections.singletonMap("name", "yeeeah")));, +	}, +, +	@Test, +	public void multipartRequestWithOptionalFile() throws Exception {, +		byte[] fileContent = "bar".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile filePart = new MockMultipartFile("file", "orig", null, fileContent);, +, +		byte[] json = "{\"name\":\"yeeeah\"}".getBytes(StandardCharsets.UTF_8);, +		MockMultipartFile jsonPart = new MockMultipartFile("json", "json", "application/json", json);, +, +		standaloneSetup(new MultipartController()).build(), +				.perform(multipart("/optionalfile").file(filePart).file(jsonPart)), +				.andExpect(status().isFound()), +				.andExpect(model().attribute("fileContent", fileContent))]