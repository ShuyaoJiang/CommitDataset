[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/AdvisorChainFactory.java, + * Copyright 2002-2014 the original author or authors., +	 * @param targetClass the target class (may be {@code null} to indicate a proxy without, +	 * target object, in which case the method's declaring class is the next best option), +	List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class<?> targetClass);, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/AdvisorChainFactory.java, + * Copyright 2002-2014 the original author or authors., +	 * @param targetClass the target class (may be {@code null} to indicate a proxy without, +	 * target object, in which case the method's declaring class is the next best option), +	List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class<?> targetClass);, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2014 the original author or authors., +		// This is somewhat tricky... We have to process introductions first,, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);, +, +				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {, +					if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {, +				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {, +, +	private static boolean hasMatchingIntroductions(Advised config, Class<?> actualClass) {, +				if (ia.getClassFilter().matches(actualClass)) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/AdvisorChainFactory.java, + * Copyright 2002-2014 the original author or authors., +	 * @param targetClass the target class (may be {@code null} to indicate a proxy without, +	 * target object, in which case the method's declaring class is the next best option), +	List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class<?> targetClass);, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2014 the original author or authors., +		// This is somewhat tricky... We have to process introductions first,, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);, +, +				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {, +					if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {, +				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {, +, +	private static boolean hasMatchingIntroductions(Advised config, Class<?> actualClass) {, +				if (ia.getClassFilter().matches(actualClass)) {, +++ b/spring-web/src/test/java/org/springframework/remoting/httpinvoker/HttpInvokerFactoryBeanIntegrationTests.java, +import org.springframework.remoting.support.RemoteInvocation;, +import org.springframework.remoting.support.RemoteInvocationResult;, +import org.springframework.scheduling.annotation.Async;, +import org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor;, +		myBean.myService.handle();, +		myBean.myService.handleAsync();, +		myBean.myService.handle();, +		myBean.myService.handleAsync();, +, +		public void handle();, +, +		@Async, +		public void handleAsync();, +		public MyService myService;, +		public AsyncAnnotationBeanPostProcessor aabpp() {, +			return new AsyncAnnotationBeanPostProcessor();, +		}, +, +		@Bean, +			Thread thread = Thread.currentThread();, +			factory.setHttpInvokerRequestExecutor(new HttpInvokerRequestExecutor() {, +				@Override, +				public RemoteInvocationResult executeRequest(HttpInvokerClientConfiguration config, RemoteInvocation invocation) {, +					return new RemoteInvocationResult(null);, +				}, +			});]