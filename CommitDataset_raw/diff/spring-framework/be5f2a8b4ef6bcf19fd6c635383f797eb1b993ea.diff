[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.java, + * A strategy for handling uncaught exceptions thrown from asynchronous methods., + * instance that gives access to the underlying exception. When the method does, + * not provide that return type, this handler can be used to managed such, +	 * Handle the given uncaught exception thrown from an asynchronous method., +	 * @param ex the exception thrown from the asynchronous method, +	 * @param method the asynchronous method, +, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.java, + * A strategy for handling uncaught exceptions thrown from asynchronous methods., + * instance that gives access to the underlying exception. When the method does, + * not provide that return type, this handler can be used to managed such, +	 * Handle the given uncaught exception thrown from an asynchronous method., +	 * @param ex the exception thrown from the asynchronous method, +	 * @param method the asynchronous method, +, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java, +	 * Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor., +	 * @param defaultExecutor the executor to be used by default if no more specific, +	 * executor has been qualified at the method level using {@link Async#value()}, +	 * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use to, +	 * handle exceptions thrown by asynchronous method executions with {@code void}, +	 * return type, +	 */, +	public AnnotationAsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {, +		super(defaultExecutor, exceptionHandler);, +	}, +, +, +	/**, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.java, + * A strategy for handling uncaught exceptions thrown from asynchronous methods., + * instance that gives access to the underlying exception. When the method does, + * not provide that return type, this handler can be used to managed such, +	 * Handle the given uncaught exception thrown from an asynchronous method., +	 * @param ex the exception thrown from the asynchronous method, +	 * @param method the asynchronous method, +, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java, +	 * Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor., +	 * @param defaultExecutor the executor to be used by default if no more specific, +	 * executor has been qualified at the method level using {@link Async#value()}, +	 * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use to, +	 * handle exceptions thrown by asynchronous method executions with {@code void}, +	 * return type, +	 */, +	public AnnotationAsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {, +		super(defaultExecutor, exceptionHandler);, +	}, +, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassPostProcessorTests.java, +, +		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()));, +		BeanDefinitionHolder proxied = ScopedProxyUtils.createScopedProxy(, +				new BeanDefinitionHolder(rbd, "bar"), beanFactory, true);, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(ScopedProxyRepositoryConfiguration.class));, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(RepositoryFactoryBeanConfiguration.class));, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(WildcardWithGenericExtendsConfiguration.class));, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.java, + * A strategy for handling uncaught exceptions thrown from asynchronous methods., + * instance that gives access to the underlying exception. When the method does, + * not provide that return type, this handler can be used to managed such, +	 * Handle the given uncaught exception thrown from an asynchronous method., +	 * @param ex the exception thrown from the asynchronous method, +	 * @param method the asynchronous method, +, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java, +	 * Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor., +	 * @param defaultExecutor the executor to be used by default if no more specific, +	 * executor has been qualified at the method level using {@link Async#value()}, +	 * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use to, +	 * handle exceptions thrown by asynchronous method executions with {@code void}, +	 * return type, +	 */, +	public AnnotationAsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {, +		super(defaultExecutor, exceptionHandler);, +	}, +, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassPostProcessorTests.java, +, +		beanFactory.registerBeanDefinition("unloadedConfig", new RootBeanDefinition(UnloadedConfig.class.getName()));, +		BeanDefinitionHolder proxied = ScopedProxyUtils.createScopedProxy(, +				new BeanDefinitionHolder(rbd, "bar"), beanFactory, true);, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(ScopedProxyRepositoryConfiguration.class));, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(RepositoryFactoryBeanConfiguration.class));, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(WildcardWithGenericExtendsConfiguration.class));, +++ b/spring-core/src/main/java/org/springframework/core/env/EnumerablePropertySource.java, + * Copyright 2002-2014 the original author or authors., +, +, +	 * Return the names of all properties contained by the, +	 * {@linkplain #getSource() source} object (never {@code null})., +	 * <p>This implementation checks for the presence of the given name within the, +	 * {@link #getPropertyNames()} array., +	 * @param name the name of the property to find, +		Assert.notNull(name, "Property name must not be null");]