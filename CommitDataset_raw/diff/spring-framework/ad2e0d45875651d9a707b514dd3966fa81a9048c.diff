[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java, +	public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {, +	public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java, +	public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {, +	public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java, +import javax.servlet.ServletException;, +import org.springframework.util.StringUtils;, +import org.springframework.web.HttpMediaTypeNotAcceptableException;, +import org.springframework.web.HttpMediaTypeNotSupportedException;, + * An {@link AbstractHandlerMethodMapping} variant that uses {@link RequestMappingInfo}s for the registration and the, + * lookup of {@link HandlerMethod}s., +	 * {@inheritDoc} The handler determination in this method is made based on the presence of a type-level {@link, +	 * Controller} annotation., +	 * Provides a {@link RequestMappingInfo} for the given method. <p>Only {@link RequestMapping @RequestMapping}-annotated, +	 * methods are considered. Type-level {@link RequestMapping @RequestMapping} annotations are also detected and their, +				RequestConditionFactory.parseProduces(annotation.produces(), annotation.headers()));, +	 *, +	protected RequestMappingInfo getMatchingMapping(RequestMappingInfo mapping,, +													String lookupPath,, +													HttpServletRequest request) {, +	 *, +	 * @throws HttpRequestMethodNotSupportedException if there are matches by URL but not by HTTP method, +	protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> requestMappingInfos,, +										  String lookupPath,, +										  HttpServletRequest request) throws ServletException {, +		Set<MediaType> consumableMediaTypes = new HashSet<MediaType>();, +		Set<MediaType> producibleMediaTypes = new HashSet<MediaType>();, +			if (!info.getMethods().match(request)) {, +			if (!info.getConsumes().match(request)) {, +				consumableMediaTypes.addAll(info.getConsumes().getMediaTypes());, +			}, +			if (!info.getProduces().match(request)) {, +				producibleMediaTypes.addAll(info.getProduces().getMediaTypes());, +			throw new HttpRequestMethodNotSupportedException(request.getMethod(), allowedMethods);, +		}, +		else if (!consumableMediaTypes.isEmpty()) {, +			MediaType contentType = null;, +			if (StringUtils.hasLength(request.getContentType())) {, +				contentType = MediaType.parseMediaType(request.getContentType());, +			}, +			throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList<MediaType>(consumableMediaTypes));, +		}, +		else if (!producibleMediaTypes.isEmpty()) {, +			throw new HttpMediaTypeNotAcceptableException(new ArrayList<MediaType>(producibleMediaTypes));, +		}, +		else {, +	 * A comparator for {@link RequestMappingInfo}s. Effective comparison can only be done in the context of a specific, +	 * request. For example not all {@link RequestMappingInfo} patterns may apply to the current request. Therefore an, +	 * HttpServletRequest is required as input., +	 * <p>Furthermore, the following assumptions are made about the input RequestMappings: <ul><li>Each RequestMappingInfo, +	 * has been fully matched to the request <li>The RequestMappingInfo contains matched patterns only <li>Patterns are, +	 * ordered with the best matching pattern at the top </ul>, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java, +	public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {, +	public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java, +import javax.servlet.ServletException;, +import org.springframework.util.StringUtils;, +import org.springframework.web.HttpMediaTypeNotAcceptableException;, +import org.springframework.web.HttpMediaTypeNotSupportedException;, + * An {@link AbstractHandlerMethodMapping} variant that uses {@link RequestMappingInfo}s for the registration and the, + * lookup of {@link HandlerMethod}s., +	 * {@inheritDoc} The handler determination in this method is made based on the presence of a type-level {@link, +	 * Controller} annotation., +	 * Provides a {@link RequestMappingInfo} for the given method. <p>Only {@link RequestMapping @RequestMapping}-annotated, +	 * methods are considered. Type-level {@link RequestMapping @RequestMapping} annotations are also detected and their, +				RequestConditionFactory.parseProduces(annotation.produces(), annotation.headers()));, +	 *, +	protected RequestMappingInfo getMatchingMapping(RequestMappingInfo mapping,, +													String lookupPath,, +													HttpServletRequest request) {, +	 *, +	 * @throws HttpRequestMethodNotSupportedException if there are matches by URL but not by HTTP method, +	protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> requestMappingInfos,, +										  String lookupPath,, +										  HttpServletRequest request) throws ServletException {, +		Set<MediaType> consumableMediaTypes = new HashSet<MediaType>();, +		Set<MediaType> producibleMediaTypes = new HashSet<MediaType>();, +			if (!info.getMethods().match(request)) {, +			if (!info.getConsumes().match(request)) {, +				consumableMediaTypes.addAll(info.getConsumes().getMediaTypes());, +			}, +			if (!info.getProduces().match(request)) {, +				producibleMediaTypes.addAll(info.getProduces().getMediaTypes());, +			throw new HttpRequestMethodNotSupportedException(request.getMethod(), allowedMethods);, +		}, +		else if (!consumableMediaTypes.isEmpty()) {, +			MediaType contentType = null;, +			if (StringUtils.hasLength(request.getContentType())) {, +				contentType = MediaType.parseMediaType(request.getContentType());, +			}, +			throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList<MediaType>(consumableMediaTypes));, +		}, +		else if (!producibleMediaTypes.isEmpty()) {, +			throw new HttpMediaTypeNotAcceptableException(new ArrayList<MediaType>(producibleMediaTypes));, +		}, +		else {, +	 * A comparator for {@link RequestMappingInfo}s. Effective comparison can only be done in the context of a specific]