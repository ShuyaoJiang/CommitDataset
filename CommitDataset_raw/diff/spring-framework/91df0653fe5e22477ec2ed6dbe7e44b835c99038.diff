[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +					new BeanDefinitionHolder(beanDef, beanName), this.registry,, +					proxyMode == ScopedProxyMode.TARGET_CLASS);, +			return ccbd.getMetadata().getClassName().equals(, +					beanMethod.getConfigurationClass().getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +					new BeanDefinitionHolder(beanDef, beanName), this.registry,, +					proxyMode == ScopedProxyMode.TARGET_CLASS);, +			return ccbd.getMetadata().getClassName().equals(, +					beanMethod.getConfigurationClass().getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass), +			throws IOException {, +, +				sourceClass.getMetadata(), PropertySources.class,, +				org.springframework.context.annotation.PropertySource.class)) {, +		if (!componentScans.isEmpty() &&, +				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +				// Check the set of scanned definitions for any further config classes and parse recursively if needed, +					if (ConfigurationClassUtils.checkConfigurationClassCandidate(, +							holder.getBeanDefinition(), this.metadataReaderFactory)) {, +	private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited), +			throws IOException {, +, +				throw new BeanDefinitionStoreException(, +						"Failed to process import candidates for configuration class [" +, +				throw new BeanDefinitionStoreException(, +						"Failed to process import candidates for configuration class [" +, +		public DeferredImportSelectorHolder(ConfigurationClass configClass, DeferredImportSelector selector) {, +			this.configurationClass = configClass;, +			this.importSelector = selector;, +		public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {, +			Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +					new BeanDefinitionHolder(beanDef, beanName), this.registry,, +					proxyMode == ScopedProxyMode.TARGET_CLASS);, +			return ccbd.getMetadata().getClassName().equals(, +					beanMethod.getConfigurationClass().getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass), +			throws IOException {, +, +				sourceClass.getMetadata(), PropertySources.class,, +				org.springframework.context.annotation.PropertySource.class)) {, +		if (!componentScans.isEmpty() &&, +				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +				// Check the set of scanned definitions for any further config classes and parse recursively if needed, +					if (ConfigurationClassUtils.checkConfigurationClassCandidate(, +							holder.getBeanDefinition(), this.metadataReaderFactory)) {, +	private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited), +			throws IOException {, +, +				throw new BeanDefinitionStoreException(, +						"Failed to process import candidates for configuration class [" +, +				throw new BeanDefinitionStoreException(, +						"Failed to process import candidates for configuration class [" +, +		public DeferredImportSelectorHolder(ConfigurationClass configClass, DeferredImportSelector selector) {, +			this.configurationClass = configClass;, +			this.importSelector = selector;, +		public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {, +			Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, + * Copyright 2002-2017 the original author or authors., +		SingletonBeanRegistry sbr = null;, +			sbr = (SingletonBeanRegistry) registry;, +			if (!this.localBeanNameGeneratorSet && sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {, +				BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);, +						BeanDefinition bd = registry.getBeanDefinition(candidateName);, +						if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&, +								!alreadyParsedClasses.contains(bd.getBeanClassName())) {, +							candidates.add(new BeanDefinitionHolder(bd, candidateName));, +		if (sbr != null) {, +			if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {, +				sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());, +		public PropertyValues postProcessPropertyValues(, +				PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {, +, +				ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);, +				AnnotationMetadata importingClass = ir.getImportingClassFor(bean.getClass().getSuperclass().getName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +					new BeanDefinitionHolder(beanDef, beanName), this.registry,, +					proxyMode == ScopedProxyMode.TARGET_CLASS);, +			return ccbd.getMetadata().getClassName().equals(, +					beanMethod.getConfigurationClass().getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass), +			throws IOException {, +, +				sourceClass.getMetadata(), PropertySources.class,, +				org.springframework.context.annotation.PropertySource.class)) {, +		if (!componentScans.isEmpty() &&, +				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +				// Check the set of scanned definitions for any further config classes and parse recursively if needed, +					if (ConfigurationClassUtils.checkConfigurationClassCandidate(, +							holder.getBeanDefinition(), this.metadataReaderFactory)) {, +	private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited), +			throws IOException {, +, +				throw new BeanDefinitionStoreException(, +						"Failed to process import candidates for configuration class [" +]