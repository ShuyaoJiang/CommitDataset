[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Projection.java, +import java.lang.reflect.Array;, +import java.util.Arrays;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ObjectUtils;, + * @author Mark Fisher, + * @since 3.0, +		boolean operandIsArray = ObjectUtils.isArray(operand);, +		} else if (operand instanceof List || operandIsArray) {, +			Collection<?> c = (operand instanceof List) ? (Collection<?>) operand : Arrays.asList(ObjectUtils.toObjectArray(operand));, +			data.addAll(c);, +			Class<?> arrayElementType = null;, +					Object value = children[0].getValueInternal(state).getValue();, +					if (value != null && operandIsArray) {, +						arrayElementType = this.determineCommonType(arrayElementType, value.getClass());, +					}, +					result.add(value);, +			if (operandIsArray) {, +				if (arrayElementType == null) {, +					arrayElementType = Object.class;, +				}, +				Object resultArray = Array.newInstance(arrayElementType, result.size());, +				System.arraycopy(result.toArray(), 0, resultArray, 0, result.size());, +				return new TypedValue(resultArray, op.getTypeDescriptor());, +			}, +	private Class<?> determineCommonType(Class<?> oldType, Class<?> newType) {, +		if (oldType == null) {, +			return newType;, +		}, +		if (oldType.isAssignableFrom(newType)) {, +			return oldType;, +		}, +		Class<?> nextType = newType;, +		while (nextType != Object.class) {, +			if (nextType.isAssignableFrom(oldType)) {, +				return nextType;, +			}, +			nextType = nextType.getSuperclass();, +		}, +		Class<?>[] interfaces = ClassUtils.getAllInterfacesForClass(newType);, +		for (Class<?> nextInterface : interfaces) {, +			if (nextInterface.isAssignableFrom(oldType)) {, +				return nextInterface;, +			}, +		}, +		return Object.class;, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Projection.java, +import java.lang.reflect.Array;, +import java.util.Arrays;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ObjectUtils;, + * @author Mark Fisher, + * @since 3.0, +		boolean operandIsArray = ObjectUtils.isArray(operand);, +		} else if (operand instanceof List || operandIsArray) {, +			Collection<?> c = (operand instanceof List) ? (Collection<?>) operand : Arrays.asList(ObjectUtils.toObjectArray(operand));, +			data.addAll(c);, +			Class<?> arrayElementType = null;, +					Object value = children[0].getValueInternal(state).getValue();, +					if (value != null && operandIsArray) {, +						arrayElementType = this.determineCommonType(arrayElementType, value.getClass());, +					}, +					result.add(value);, +			if (operandIsArray) {, +				if (arrayElementType == null) {, +					arrayElementType = Object.class;, +				}, +				Object resultArray = Array.newInstance(arrayElementType, result.size());, +				System.arraycopy(result.toArray(), 0, resultArray, 0, result.size());, +				return new TypedValue(resultArray, op.getTypeDescriptor());, +			}, +	private Class<?> determineCommonType(Class<?> oldType, Class<?> newType) {, +		if (oldType == null) {, +			return newType;, +		}, +		if (oldType.isAssignableFrom(newType)) {, +			return oldType;, +		}, +		Class<?> nextType = newType;, +		while (nextType != Object.class) {, +			if (nextType.isAssignableFrom(oldType)) {, +				return nextType;, +			}, +			nextType = nextType.getSuperclass();, +		}, +		Class<?>[] interfaces = ClassUtils.getAllInterfacesForClass(newType);, +		for (Class<?> nextInterface : interfaces) {, +			if (nextInterface.isAssignableFrom(oldType)) {, +				return nextInterface;, +			}, +		}, +		return Object.class;, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Selection.java, +import java.lang.reflect.Array;, +import java.util.Arrays;, +import org.springframework.util.ClassUtils;]