[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2015 the original author or authors., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2015 the original author or authors., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, + * Copyright 2002-2015 the original author or authors., +		String classDesc = constructor.getDeclaringClass().getName().replace('.', '/');, +		mv.visitTypeInsn(NEW, classDesc);, +		mv.visitMethodInsn(INVOKESPECIAL, classDesc, "<init>", CodeFlow.createSignatureDescriptor(constructor), false);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2015 the original author or authors., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, + * Copyright 2002-2015 the original author or authors., +		String classDesc = constructor.getDeclaringClass().getName().replace('.', '/');, +		mv.visitTypeInsn(NEW, classDesc);, +		mv.visitMethodInsn(INVOKESPECIAL, classDesc, "<init>", CodeFlow.createSignatureDescriptor(constructor), false);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2015 the original author or authors., + * A function reference is of the form "#someFunction(a,b,c)". Functions may be defined, + * in the context prior to the expression being evaluated or within the expression itself, + * <p>Functions are very simplistic, the arguments are not part of the definition, + * (right now), so the names must be unique., +			throw new SpelEvaluationException(, +					SpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());, +			functionArgs =, +					ReflectionHelper.setupArgumentsForVarargsInvocation(method.getParameterTypes(), functionArgs);, +		if (this.method == null || this.argumentConversionOccurred) {, +		if (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||, +				!Modifier.isPublic(this.method.getDeclaringClass().getModifiers())) {, +		String classDesc = this.method.getDeclaringClass().getName().replace('.', '/');, +		generateCodeForArguments(mv, cf, this.method, this.children);, +		mv.visitMethodInsn(INVOKESTATIC, classDesc, this.method.getName(),, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2015 the original author or authors., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, + * Copyright 2002-2015 the original author or authors., +		String classDesc = constructor.getDeclaringClass().getName().replace('.', '/');, +		mv.visitTypeInsn(NEW, classDesc);, +		mv.visitMethodInsn(INVOKESPECIAL, classDesc, "<init>", CodeFlow.createSignatureDescriptor(constructor), false);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2015 the original author or authors., + * A function reference is of the form "#someFunction(a,b,c)". Functions may be defined, + * in the context prior to the expression being evaluated or within the expression itself, + * <p>Functions are very simplistic, the arguments are not part of the definition, + * (right now), so the names must be unique., +			throw new SpelEvaluationException(, +					SpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());, +			functionArgs =, +					ReflectionHelper.setupArgumentsForVarargsInvocation(method.getParameterTypes(), functionArgs);, +		if (this.method == null || this.argumentConversionOccurred) {, +		if (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||, +				!Modifier.isPublic(this.method.getDeclaringClass().getModifiers())) {, +		String classDesc = this.method.getDeclaringClass().getName().replace('.', '/');, +		generateCodeForArguments(mv, cf, this.method, this.children);, +		mv.visitMethodInsn(INVOKESTATIC, classDesc, this.method.getName(),, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java, +			int childCount = arguments.length;, +			SpelNodeImpl lastchild = (childCount == 0 ? null : arguments[childCount - 1]);, +				CodeFlow.insertNewArrayCode(mv, childCount - p, arraytype);, +				while (p < childCount) {, +	protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {, +		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {, +		else if (paramDesc.length() == 1 && !primitiveOnStack) {, +			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), cf.lastDescriptor());, +		else if (!cf.lastDescriptor().equals(paramDesc)) {, +			CodeFlow.insertCheckCast(mv, paramDesc);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2015 the original author or authors., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, + * Copyright 2002-2015 the original author or authors., +		String classDesc = constructor.getDeclaringClass().getName().replace('.', '/');, +		mv.visitTypeInsn(NEW, classDesc);, +		mv.visitMethodInsn(INVOKESPECIAL, classDesc, "<init>", CodeFlow.createSignatureDescriptor(constructor), false);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2015 the original author or authors., + * A function reference is of the form "#someFunction(a,b,c)". Functions may be defined, + * in the context prior to the expression being evaluated or within the expression itself, + * <p>Functions are very simplistic, the arguments are not part of the definition, + * (right now), so the names must be unique., +			throw new SpelEvaluationException(, +					SpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());, +			functionArgs =, +					ReflectionHelper.setupArgumentsForVarargsInvocation(method.getParameterTypes(), functionArgs);, +		if (this.method == null || this.argumentConversionOccurred) {, +		if (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||, +				!Modifier.isPublic(this.method.getDeclaringClass().getModifiers())) {, +		String classDesc = this.method.getDeclaringClass().getName().replace('.', '/');, +		generateCodeForArguments(mv, cf, this.method, this.children);, +		mv.visitMethodInsn(INVOKESTATIC, classDesc, this.method.getName(),, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java, +			int childCount = arguments.length;, +			SpelNodeImpl lastchild = (childCount == 0 ? null : arguments[childCount - 1]);, +				CodeFlow.insertNewArrayCode(mv, childCount - p, arraytype);, +				while (p < childCount) {, +	protected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {, +		if (primitiveOnStack && paramDesc.charAt(0) == 'L') {, +		else if (paramDesc.length() == 1 && !primitiveOnStack) {, +			CodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), cf.lastDescriptor());, +		else if (!cf.lastDescriptor().equals(paramDesc)) {, +			CodeFlow.insertCheckCast(mv, paramDesc);]