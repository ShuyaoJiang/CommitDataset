[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import org.springframework.context.config.SpecificationContext;, +				Object proxiedBean = proxyCreator.createProxyIfPossible(dd);, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import org.springframework.context.config.SpecificationContext;, +				Object proxiedBean = proxyCreator.createProxyIfPossible(dd);, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/EarlyBeanReferenceProxyCreator.java, +	 * the given dependency descriptor. No proxy is created if the dependency type, +	 * is final, rather the dependency is resolved immediately. This is important, +	 * especially with regard to supporting @Value injection., +	public Object createProxyIfPossible(DependencyDescriptor descriptor) {, +		if (Modifier.isFinal(descriptor.getDependencyType().getModifiers())) {, +			return beanFactory.resolveDependency(descriptor, "");, +		}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import org.springframework.context.config.SpecificationContext;, +				Object proxiedBean = proxyCreator.createProxyIfPossible(dd);, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/EarlyBeanReferenceProxyCreator.java, +	 * the given dependency descriptor. No proxy is created if the dependency type, +	 * is final, rather the dependency is resolved immediately. This is important, +	 * especially with regard to supporting @Value injection., +	public Object createProxyIfPossible(DependencyDescriptor descriptor) {, +		if (Modifier.isFinal(descriptor.getDependencyType().getModifiers())) {, +			return beanFactory.resolveDependency(descriptor, "");, +		}, +++ b/org.springframework.context/src/test/java/org/springframework/context/annotation/EarlyBeanReferenceProxyCreatorTests.java, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy2 = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		BeanWithFinalizer proxy = (BeanWithFinalizer) pc.createProxyIfPossible(descriptorFor(BeanWithFinalizer.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		ComponentWithInterfaceBeanMethod proxy = (ComponentWithInterfaceBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithInterfaceBeanMethod.class));, +		ComponentWithConcreteBeanMethod proxy = (ComponentWithConcreteBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithConcreteBeanMethod.class));, +		ITestBean proxy = (ITestBean) pc.createProxyIfPossible(descriptorFor(ITestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		ComponentWithInterfaceBeanMethod proxy = (ComponentWithInterfaceBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithInterfaceBeanMethod.class));, +		ComponentWithConcreteBeanMethod proxy = (ComponentWithConcreteBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithConcreteBeanMethod.class));, +			pc.createProxyIfPossible(descriptorFor(BeanMissingNoArgConstructor.class));, +			pc.createProxyIfPossible(descriptorFor(BeanWithPrivateNoArgConstructor.class));, +	public void attemptToProxyFinalClassReturnsNonProxiedInstance() throws Exception {, +		bf.registerBeanDefinition("finalBean", new RootBeanDefinition(FinalBean.class));, +		Object bean = pc.createProxyIfPossible(descriptorFor(FinalBean.class));, +		assertThat(bean, instanceOf(FinalBean.class));, +		assertThat(bean, not(instanceOf(EarlyBeanReferenceProxy.class)));, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import org.springframework.context.config.SpecificationContext;, +				Object proxiedBean = proxyCreator.createProxyIfPossible(dd);, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/EarlyBeanReferenceProxyCreator.java, +	 * the given dependency descriptor. No proxy is created if the dependency type, +	 * is final, rather the dependency is resolved immediately. This is important, +	 * especially with regard to supporting @Value injection., +	public Object createProxyIfPossible(DependencyDescriptor descriptor) {, +		if (Modifier.isFinal(descriptor.getDependencyType().getModifiers())) {, +			return beanFactory.resolveDependency(descriptor, "");, +		}, +++ b/org.springframework.context/src/test/java/org/springframework/context/annotation/EarlyBeanReferenceProxyCreatorTests.java, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		TestBean proxy2 = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		BeanWithFinalizer proxy = (BeanWithFinalizer) pc.createProxyIfPossible(descriptorFor(BeanWithFinalizer.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		ComponentWithInterfaceBeanMethod proxy = (ComponentWithInterfaceBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithInterfaceBeanMethod.class));, +		ComponentWithConcreteBeanMethod proxy = (ComponentWithConcreteBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithConcreteBeanMethod.class));, +		ITestBean proxy = (ITestBean) pc.createProxyIfPossible(descriptorFor(ITestBean.class));, +		TestBean proxy = (TestBean) pc.createProxyIfPossible(descriptorFor(TestBean.class));, +		ComponentWithInterfaceBeanMethod proxy = (ComponentWithInterfaceBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithInterfaceBeanMethod.class));, +		ComponentWithConcreteBeanMethod proxy = (ComponentWithConcreteBeanMethod) pc.createProxyIfPossible(descriptorFor(ComponentWithConcreteBeanMethod.class));, +			pc.createProxyIfPossible(descriptorFor(BeanMissingNoArgConstructor.class));, +			pc.createProxyIfPossible(descriptorFor(BeanWithPrivateNoArgConstructor.class));, +	public void attemptToProxyFinalClassReturnsNonProxiedInstance() throws Exception {, +		bf.registerBeanDefinition("finalBean", new RootBeanDefinition(FinalBean.class));, +		Object bean = pc.createProxyIfPossible(descriptorFor(FinalBean.class));, +		assertThat(bean, instanceOf(FinalBean.class));, +		assertThat(bean, not(instanceOf(EarlyBeanReferenceProxy.class)));, +++ b/org.springframework.context/src/test/java/org/springframework/context/annotation/FeatureMethodValueInjectionTests.java, +/*, + * Copyright 2002-2011 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.context.annotation;, +, +import static org.hamcrest.CoreMatchers.is;, +import static org.junit.Assert.assertThat;, +]