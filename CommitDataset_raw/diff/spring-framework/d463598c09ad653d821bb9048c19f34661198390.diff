[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, + * Copyright 2002-2019 the original author or authors., +			return Mono.defer(() -> exchangeFunction.exchange(request)), +					.switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, + * Copyright 2002-2019 the original author or authors., +			return Mono.defer(() -> exchangeFunction.exchange(request)), +					.switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunction.java, + * Copyright 2002-2019 the original author or authors., + * <p>The filter is executed when a {@code Subscriber} subscribes to the, + * {@code Publisher} returned by the {@code WebClient}., +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, + * Copyright 2002-2019 the original author or authors., +			return Mono.defer(() -> exchangeFunction.exchange(request)), +					.switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunction.java, + * Copyright 2002-2019 the original author or authors., + * <p>The filter is executed when a {@code Subscriber} subscribes to the, + * {@code Publisher} returned by the {@code WebClient}., +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/DefaultWebClientTests.java, + * Copyright 2002-2019 the original author or authors., + * @author Brian Clozel, +		ClientResponse mockResponse = mock(ClientResponse.class);, +		when(this.exchangeFunction.exchange(this.captor.capture())).thenReturn(Mono.just(mockResponse));, +		this.builder.build().get().uri("/path"), +				.exchange().block(Duration.ofSeconds(10));, +				.exchange().block(Duration.ofSeconds(10));, +				.exchange().block(Duration.ofSeconds(10));, +				.exchange().block(Duration.ofSeconds(10));, +		client.get().uri("/path").exchange().block(Duration.ofSeconds(10));, +		client.get().uri("/path"), +				.header("Accept", "application/xml"), +				.cookie("id", "456"), +				.exchange().block(Duration.ofSeconds(10));, +			client.get().uri("/path").attribute("foo", "bar"), +					.exchange().block(Duration.ofSeconds(10));, +				.exchange().block(Duration.ofSeconds(10));, +				.exchange().block(Duration.ofSeconds(10));, +		client.get().uri("/path").exchange().block(Duration.ofSeconds(10));, +		ExchangeFunction exchangeFunction = mock(ExchangeFunction.class);, +		when(exchangeFunction.exchange(any())).thenReturn(Mono.empty());, +		WebClient.Builder builder = WebClient.builder().baseUrl("/base").exchangeFunction(exchangeFunction);, +	@Test, +	public void shouldApplyFiltersAtSubscription() {, +		WebClient client = this.builder, +				.filter((request, next) -> {, +					return next.exchange(ClientRequest, +							.from(request), +							.header("Custom", "value"), +							.build());, +				}), +				.build();, +		Mono<ClientResponse> exchange = client.get().uri("/path").exchange();, +		verifyZeroInteractions(this.exchangeFunction);, +		exchange.block(Duration.ofSeconds(10));, +		ClientRequest request = verifyAndGetRequest();, +		assertEquals("value", request.headers().getFirst("Custom"));, +	}, +]