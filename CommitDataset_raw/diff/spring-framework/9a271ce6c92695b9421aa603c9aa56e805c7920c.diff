[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.beans.BeanUtils;, +import org.springframework.core.type.filter.AssignableTypeFilter;, +			processImport(configClass, (String[]) importAttribs.get("value"), true);, +	private void processImport(ConfigurationClass configClass, String[] classesToImport, boolean checkForCircularImports) throws IOException {, +		if (checkForCircularImports && this.importStack.contains(configClass)) {, +			AnnotationMetadata importingClassMetadata = configClass.getMetadata();, +			for (String candidate : classesToImport) {, +				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(candidate);, +				if (new AssignableTypeFilter(ImportSelector.class).match(reader, metadataReaderFactory)) {, +					// the candidate class is an ImportSelector -> delegate to it to determine imports, +					try {, +						ImportSelector selector = BeanUtils.instantiateClass(Class.forName(candidate), ImportSelector.class);, +						processImport(configClass, selector.selectImports(importingClassMetadata), false);, +					} catch (ClassNotFoundException ex) {, +						throw new IllegalStateException(ex);, +					}, +				}, +				else {, +					// the candidate class not an ImportSelector -> process it as a @Configuration class, +					this.importStack.registerImport(importingClassMetadata.getClassName(), candidate);, +			}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.beans.BeanUtils;, +import org.springframework.core.type.filter.AssignableTypeFilter;, +			processImport(configClass, (String[]) importAttribs.get("value"), true);, +	private void processImport(ConfigurationClass configClass, String[] classesToImport, boolean checkForCircularImports) throws IOException {, +		if (checkForCircularImports && this.importStack.contains(configClass)) {, +			AnnotationMetadata importingClassMetadata = configClass.getMetadata();, +			for (String candidate : classesToImport) {, +				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(candidate);, +				if (new AssignableTypeFilter(ImportSelector.class).match(reader, metadataReaderFactory)) {, +					// the candidate class is an ImportSelector -> delegate to it to determine imports, +					try {, +						ImportSelector selector = BeanUtils.instantiateClass(Class.forName(candidate), ImportSelector.class);, +						processImport(configClass, selector.selectImports(importingClassMetadata), false);, +					} catch (ClassNotFoundException ex) {, +						throw new IllegalStateException(ex);, +					}, +				}, +				else {, +					// the candidate class not an ImportSelector -> process it as a @Configuration class, +					this.importStack.registerImport(importingClassMetadata.getClassName(), candidate);, +			}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ImportSelector.java, +/*, + * Copyright 2002-2011 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.context.annotation;, +, +import org.springframework.core.type.AnnotationMetadata;, +, +, +/**, + * Interface to be implemented by types that determine, + * which @{@link Configuration} class(es) should be imported based on, + * a given selection criteria, usually an annotation attribute., + *, + * @author Chris Beams, + * @since 3.1, + * @see Import, + */, +public interface ImportSelector {, +, +	/**, +	 * Select and return the names of which class(es) should be imported., +	 * @param importingClassMetadata the AnnotationMetodata of the, +	 * importing @{@link Configuration} class., +	 */, +	String[] selectImports(AnnotationMetadata importingClassMetadata);, +, +}]