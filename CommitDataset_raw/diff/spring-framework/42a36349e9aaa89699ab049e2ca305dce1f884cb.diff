[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, + * Copyright 2002-2014 the original author or authors., +	 * Find a single {@link Annotation} of {@code annotationType} on the, +	 * supplied {@link Class}, traversing its interfaces, annotations, and, +	 * superclasses if the annotation is not <em>present</em> on the given class, +	 * itself., +	 * declared as {@link java.lang.annotation.Inherited inherited} <em>as well, +	 * as meta-annotations and annotations on interfaces</em>., +	 * <li>Search for the annotation on the given class and return it if found., +	 * <li>Recursively search through all interfaces that the given class declares., +	 * <li>Recursively search through all annotations that the given class declares., +	 * <li>Recursively search through the superclass hierarchy of the given class., +	 * <p>Note: in this context, the term <em>recursively</em> means that the search, +	 * process continues by returning to step #1 with the current interface,, +	 * annotation, or superclass as the class to look for annotations on., +	 * @param annotationType the type of annotation to look for, +	 * @return the annotation if found, or {@code null} if not found, +		return findAnnotation(clazz, annotationType, new HashSet<Annotation>());, +	}, +, +	/**, +	 * Perform the search algorithm for {@link #findAnnotation(Class, Class)},, +	 * avoiding endless recursion by tracking which annotations have already, +	 * been visited., +	 * @param clazz the class to look for annotations on, +	 * @param annotationType the type of annotation to look for, +	 * @param visitedAnnotations the set of annotations that have already been visited, +	 * @return the annotation if found, or {@code null} if not found, +	 */, +	private static <A extends Annotation> A findAnnotation(Class<?> clazz, Class<A> annotationType,, +			Set<Annotation> visitedAnnotations) {, +, +			annotation = findAnnotation(ifc, annotationType, visitedAnnotations);, +			if (!visitedAnnotations.contains(ann)) {, +				visitedAnnotations.add(ann);, +				annotation = findAnnotation(ann.annotationType(), annotationType, visitedAnnotations);, +		Class<?> superclass = clazz.getSuperclass();, +		if (superclass == null || superclass.equals(Object.class)) {, +		return findAnnotation(superclass, annotationType, visitedAnnotations);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, + * Copyright 2002-2014 the original author or authors., +	 * Find a single {@link Annotation} of {@code annotationType} on the, +	 * supplied {@link Class}, traversing its interfaces, annotations, and, +	 * superclasses if the annotation is not <em>present</em> on the given class, +	 * itself., +	 * declared as {@link java.lang.annotation.Inherited inherited} <em>as well, +	 * as meta-annotations and annotations on interfaces</em>., +	 * <li>Search for the annotation on the given class and return it if found., +	 * <li>Recursively search through all interfaces that the given class declares., +	 * <li>Recursively search through all annotations that the given class declares., +	 * <li>Recursively search through the superclass hierarchy of the given class., +	 * <p>Note: in this context, the term <em>recursively</em> means that the search, +	 * process continues by returning to step #1 with the current interface,, +	 * annotation, or superclass as the class to look for annotations on., +	 * @param annotationType the type of annotation to look for, +	 * @return the annotation if found, or {@code null} if not found, +		return findAnnotation(clazz, annotationType, new HashSet<Annotation>());, +	}, +, +	/**, +	 * Perform the search algorithm for {@link #findAnnotation(Class, Class)},, +	 * avoiding endless recursion by tracking which annotations have already, +	 * been visited., +	 * @param clazz the class to look for annotations on, +	 * @param annotationType the type of annotation to look for, +	 * @param visitedAnnotations the set of annotations that have already been visited, +	 * @return the annotation if found, or {@code null} if not found, +	 */, +	private static <A extends Annotation> A findAnnotation(Class<?> clazz, Class<A> annotationType,, +			Set<Annotation> visitedAnnotations) {, +, +			annotation = findAnnotation(ifc, annotationType, visitedAnnotations);, +			if (!visitedAnnotations.contains(ann)) {, +				visitedAnnotations.add(ann);, +				annotation = findAnnotation(ann.annotationType(), annotationType, visitedAnnotations);, +		Class<?> superclass = clazz.getSuperclass();, +		if (superclass == null || superclass.equals(Object.class)) {, +		return findAnnotation(superclass, annotationType, visitedAnnotations);, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +	public void findAnnotationOnMetaMetaAnnotatedClass() {, +		Component component = AnnotationUtils.findAnnotation(MetaMetaAnnotatedClass.class, Component.class);, +		assertNotNull("Should find meta-annotation on composed annotation on class", component);, +		assertEquals("meta2", component.value());, +	}, +, +	@Test, +	public void findAnnotationOnMetaMetaMetaAnnotatedClass() {, +		Component component = AnnotationUtils.findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);, +		assertNotNull("Should find meta-annotation on meta-annotation on composed annotation on class", component);, +		assertEquals("meta2", component.value());, +	}, +, +	@Test, +	public void findAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {, +		// TransactionalClass is NOT annotated or meta-annotated with @Component, +		Component component = AnnotationUtils.findAnnotation(TransactionalClass.class, Component.class);, +		assertNull("Should not find @Component on TransactionalClass", component);, +	}, +, +	@Test]