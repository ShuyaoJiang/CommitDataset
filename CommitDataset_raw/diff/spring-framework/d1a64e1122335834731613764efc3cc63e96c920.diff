[+++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +		private DefaultResponseSpec toResponseSpec(Mono<ClientResponse> mono) {, +			ClientResponse response = mono.block(getTimeout());, +			ClientHttpRequest httpRequest = webTestClientConnector.claimRequest(this.requestId);, +			return new DefaultResponseSpec(httpRequest, response);, +	/**, +	 * ExchangeResult that contains the live {@link ClientResponse}., +	 */, +	private class UndecodedExchangeResult extends ExchangeResult {, +		public UndecodedExchangeResult(ClientHttpRequest httpRequest, ClientResponse response) {, +			super(httpRequest, response);, +		public EntityExchangeResult<?> consumeSingle(ResolvableType elementType) {, +			Object body = this.response.body(toMono(elementType)).block(getTimeout());, +			return new EntityExchangeResult<>(this, body);, +		public EntityExchangeResult<List<?>> consumeList(ResolvableType elementType, int count) {, +			Flux<?> flux = this.response.body(toFlux(elementType));, +			if (count >= 0) {, +				flux = flux.take(count);, +			}, +			List<?> body = flux.collectList().block(getTimeout());, +			return new EntityExchangeResult<>(this, body);, +		public <T> FluxExchangeResult<T> decodeBody(ResolvableType elementType) {, +			Flux<T> body = this.response.body(toFlux(elementType));, +			return new FluxExchangeResult<>(this, body, elementType);, +		@SuppressWarnings("unchecked"), +		public EntityExchangeResult<Map<?, ?>> consumeMap(ResolvableType keyType, ResolvableType valueType) {, +			ResolvableType mapType = ResolvableType.forClassWithGenerics(Map.class, keyType, valueType);, +			return (EntityExchangeResult<Map<?, ?>>) consumeSingle(mapType);, +		public EntityExchangeResult<Void> consumeEmpty() {, +			DataBuffer buffer = this.response.body(toDataBuffers()).blockFirst(getTimeout());, +			assertTrue("Expected empty body", buffer == null);, +			return new EntityExchangeResult<>(this, null);, +		}, +	}, +, +	private class DefaultResponseSpec implements ResponseSpec {, +, +		private final UndecodedExchangeResult exchangeResult;, +		public DefaultResponseSpec(ClientHttpRequest httpRequest, ClientResponse response) {, +			this.exchangeResult = new UndecodedExchangeResult(httpRequest, response);, +			return new StatusAssertions(this.exchangeResult, this);, +			return new HeaderAssertions(this.exchangeResult, this);, +			return new DefaultTypeBodySpec(this.exchangeResult, elementType);, +			return new DefaultBodySpec(this.exchangeResult);, +		public ResponseSpec consumeWith(Consumer<ExchangeResult> consumer) {, +			consumer.accept(this.exchangeResult);, +		public ExchangeResult returnResult() {, +			return this.exchangeResult;, +	private class DefaultTypeBodySpec implements TypeBodySpec {, +, +		private final UndecodedExchangeResult exchangeResult;, +		public DefaultTypeBodySpec(UndecodedExchangeResult result, ResolvableType elementType) {, +			this.exchangeResult = result;, +			EntityExchangeResult<?> completed = this.exchangeResult.consumeSingle(this.elementType);, +			return new DefaultSingleValueBodySpec(completed);, +		public ListBodySpec list(int count) {, +			EntityExchangeResult<List<?>> completed = this.exchangeResult.consumeList(this.elementType, count);, +			return new DefaultListBodySpec(completed);, +		public <T> FluxExchangeResult<T> returnResult() {, +			return this.exchangeResult.decodeBody(this.elementType);, +	private class DefaultSingleValueBodySpec implements SingleValueBodySpec {, +		private final EntityExchangeResult<?> exchangeResult;, +		public DefaultSingleValueBodySpec(EntityExchangeResult<?> result) {, +			this.exchangeResult = result;, +		public <T> EntityExchangeResult<T> isEqualTo(T expected) {, +			assertEquals("Response body", expected, this.exchangeResult.getResponseBody());, +		public <T> EntityExchangeResult<T> returnResult() {, +			return new EntityExchangeResult<>(this.exchangeResult, (T) this.exchangeResult.getResponseBody());, +	private class DefaultListBodySpec implements ListBodySpec {, +		private final EntityExchangeResult<List<?>> exchangeResult;, +		public DefaultListBodySpec(EntityExchangeResult<List<?>> result) {, +			this.exchangeResult = result;, +		public <T> EntityExchangeResult<List<T>> isEqualTo(List<T> expected) {, +			assertEquals("Response body", expected, this.exchangeResult.getResponseBody());, +			assertTrue(message, this.exchangeResult.getResponseBody().containsAll(elementList));, +			assertTrue(message, !this.exchangeResult.getResponseBody().containsAll(Arrays.asList(elements)));, +		public <T> EntityExchangeResult<List<T>> returnResult() {, +			return new EntityExchangeResult<>(this.exchangeResult,  (List<T>) this.exchangeResult.getResponseBody());, +	private class DefaultBodySpec implements BodySpec {, +, +		private final UndecodedExchangeResult exchangeResult;, +		public DefaultBodySpec(UndecodedExchangeResult result) {, +			this.exchangeResult = result;, +		public EntityExchangeResult<Void> isEmpty() {, +			return this.exchangeResult.consumeEmpty();, +			EntityExchangeResult<Map<?, ?>> completed = this.exchangeResult.consumeMap(keyType, valueType);, +			return new DefaultMapBodySpec(completed);, +	private class DefaultMapBodySpec implements MapBodySpec {, +		private final EntityExchangeResult<Map<?, ?>> exchangeResult;, +		public DefaultMapBodySpec(EntityExchangeResult<Map<?, ?>> result) {, +			this.exchangeResult = result;, +		private Map<?, ?> getBody() {, +			return this.exchangeResult.getResponseBody();, +		}, +, +		public <K, V> EntityExchangeResult<Map<K, V>> isEqualTo(Map<K, V> expected) {, +			assertEquals("Response body map", expected, getBody());, +			assertEquals("Response body map size", size, getBody().size());, +			assertEquals("Response body map value for key " + key, value, getBody().get(key));, +			List<?> missing = Arrays.stream(keys).filter(k -> !getBody().containsKey(k)).collect(toList());]