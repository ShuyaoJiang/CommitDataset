[+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);, +, +		String ext1 = pattern1.substring(starDotPos1 + 1);, +		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));, +		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2));, +		boolean ext1All = (ext1.equals(".*") || ext1.equals(""));, +		boolean ext2All = (ext2.equals(".*") || ext2.equals(""));, +		if (!ext1All && !ext2All) {, +			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2);, +		}, +		String ext = (ext1All ? ext2 : ext1);, +		return file2 + ext;, +	 * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of, +	 * explicitness., +	 * <p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}, +	 * a list so that more specific patterns (without uri templates or wild cards) come before, +	 * generic patterns. So given a list with the following patterns:, +	 * <ol>, +	 * <li>{@code /hotels/new}</li>, +	 * <li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>, +	 * </ol>, +	 * the returned comparator will sort this list so that the order will be as indicated., +	 * <p>The full path given as parameter is used to test for exact matches. So when the given path, +	 * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}., +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);, +, +		String ext1 = pattern1.substring(starDotPos1 + 1);, +		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));, +		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2));, +		boolean ext1All = (ext1.equals(".*") || ext1.equals(""));, +		boolean ext2All = (ext2.equals(".*") || ext2.equals(""));, +		if (!ext1All && !ext2All) {, +			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2);, +		}, +		String ext = (ext1All ? ext2 : ext1);, +		return file2 + ext;, +	 * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of, +	 * explicitness., +	 * <p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}, +	 * a list so that more specific patterns (without uri templates or wild cards) come before, +	 * generic patterns. So given a list with the following patterns:, +	 * <ol>, +	 * <li>{@code /hotels/new}</li>, +	 * <li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>, +	 * </ol>, +	 * the returned comparator will sort this list so that the order will be as indicated., +	 * <p>The full path given as parameter is used to test for exact matches. So when the given path, +	 * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}., +++ b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java, +	private final AntPathMatcher pathMatcher = new AntPathMatcher();, +	public final ExpectedException exception = ExpectedException.none();]