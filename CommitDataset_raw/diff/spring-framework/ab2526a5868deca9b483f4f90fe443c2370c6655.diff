[+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private PathSeparatorPatternCache pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);, +, +, +	 * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}., +	 * A convenience alternative constructor to use with a custom path separator., +	 * @param pathSeparator the path separator to use, must not be {@code null}., +		Assert.notNull(pathSeparator, "'pathSeparator' is required");, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);, +, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);, +		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {, +			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);, +		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {, +			return concat(pattern1, pattern2);, +			return concat(pattern1, pattern2);, +	private String concat(String path1, String path2) {, +, +	/**, +	 * A simple cache for patterns that depend on the configured path separator., +	 */, +	private static class PathSeparatorPatternCache {, +, +		private final String endsOnWildCard;, +, +		private final String endsOnDoubleWildCard;, +, +, +		private PathSeparatorPatternCache(String pathSeparator) {, +			this.endsOnWildCard = pathSeparator + "*";, +			this.endsOnDoubleWildCard = pathSeparator + "**";, +		}, +, +		public String getEndsOnWildCard() {, +			return this.endsOnWildCard;, +		}, +, +		public String getEndsOnDoubleWildCard() {, +			return this.endsOnDoubleWildCard;, +		}, +	}, +, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private PathSeparatorPatternCache pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);, +, +, +	 * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}., +	 * A convenience alternative constructor to use with a custom path separator., +	 * @param pathSeparator the path separator to use, must not be {@code null}., +		Assert.notNull(pathSeparator, "'pathSeparator' is required");, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);, +, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);, +		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {, +			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);, +		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {, +			return concat(pattern1, pattern2);, +			return concat(pattern1, pattern2);, +	private String concat(String path1, String path2) {, +, +	/**, +	 * A simple cache for patterns that depend on the configured path separator., +	 */, +	private static class PathSeparatorPatternCache {, +, +		private final String endsOnWildCard;, +, +		private final String endsOnDoubleWildCard;, +, +, +		private PathSeparatorPatternCache(String pathSeparator) {, +			this.endsOnWildCard = pathSeparator + "*";, +			this.endsOnDoubleWildCard = pathSeparator + "**";, +		}, +, +		public String getEndsOnWildCard() {, +			return this.endsOnWildCard;, +		}, +, +		public String getEndsOnDoubleWildCard() {, +			return this.endsOnDoubleWildCard;, +		}, +	}, +, +++ b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java, +	public void testExtensionMappingWithDotPathSeparator() {, +		assertEquals("Extension mapping should be disabled with \".\" as path separator",, +				"/*.html.hotel.*", pathMatcher.combine("/*.html", "hotel.*"));, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private PathSeparatorPatternCache pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);, +, +, +	 * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}., +	 * A convenience alternative constructor to use with a custom path separator., +	 * @param pathSeparator the path separator to use, must not be {@code null}., +		Assert.notNull(pathSeparator, "'pathSeparator' is required");, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);, +, +		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);, +		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {]