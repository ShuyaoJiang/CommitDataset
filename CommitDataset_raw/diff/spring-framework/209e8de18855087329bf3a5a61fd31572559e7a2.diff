[+++ b/src/asciidoc/web-mvc.adoc, +`java.util.concurrent.Callable` and produce the return value from a Spring MVC managed thread., +Meanwhile the main Servlet container thread is exited and released and allowed to process other, +Servlet container to resume processing using the value returned by the `Callable`. Here, +is an example of such a controller method:, +Another option is for the controller method to return an instance of `DeferredResult`. In this, +case the return value will also be produced from any thread, i.e. one that, +is not managed by Spring MVC. For example the result may be produced in response to some, +external event such as a JMS message, a scheduled task, and so on. Here is an example, +of such a controller method:, +		// Save the deferredResult somewhere.., +This may be difficult to understand without any knowledge of the Servlet 3.0, +asynchronous request processing features. It would certainly help to read up, +on that. Here are a few basic facts about the underlying mechanism:, +  the response will remain open to allow processing to complete later., +* The call to `request.startAsync()` returns `AsyncContext` which can be used for, +  that is similar to a forward from the Servlet API except it allows an, +  application to resume request processing on a Servlet container thread., +* The `ServletRequest` provides access to the current `DispatcherType` that can, +  be used to distinguish between processing the initial request, an async, +  dispatch, a forward, and other dispatcher types., +processing with a `Callable`:, +* Controller returns a `Callable`., +* Spring MVC starts asynchronous processing and submits the `Callable` to, +  a `TaskExecutor` for processing in a separate thread., +* The `DispatcherServlet` and all Filter's exit the Servlet container thread, +  but the response remains open., +* The `Callable` produces a result and Spring MVC dispatches the request back, +  to the Servlet container to resume processing., +* The `DispatcherServlet` is invoked again and processing resumes with the, +  asynchronously produced result from the `Callable`., +The sequence for `DeferredResult` is very similar except it's up to the, +application to produce the asynchronous result from any thread:, +, +* Controller returns a `DeferredResult` and saves it in some in-memory, +  queue or list where it can be accessed., +* Spring MVC starts async processing., +* The `DispatcherServlet` and all configured Filter's exit the request, +  processing thread but the response remains open., +* The application sets the `DeferredResult` from some thread and Spring MVC, +  dispatches the request back to the Servlet container., +* The `DispatcherServlet` is invoked again and processing resumes with the, +  asynchronously produced result., +, +For further background on the motivation for async request processing and, +when or why to use it please read, +What happens if a `Callable` returned from a controller method raises an, +Exception while being executed? The short answer is the same as what happens, +when a controller method raises an exception. It goes through the regular, +exception handling mechanism. The longer explanation is that when a `Callable`, +raises an Exception Spring MVC dispatches to the Servlet container with, +the `Exception` as the result and that leads to resume request processing, +with the `Exception` instead of a controller method return value., +When using a `DeferredResult` you have a choice whether to call, +`setResult` or `setErrorResult` with an `Exception` instance., +A `HandlerInterceptor` can also implement `AsyncHandlerInterceptor` in order, +to implement the `afterConcurrentHandlingStarted` callback, which is called, +instead of `postHandle` and `afterCompletion` when asynchronous processing, +starts., +A `HandlerInterceptor` can also register a `CallableProcessingInterceptor`, +or a `DeferredResultProcessingInterceptor` in order to integrate more, +deeply with the lifecycle of an asynchronous request and for example, +handle a timeout event. See the Javadoc of `AsyncHandlerInterceptor`, +for more details., +The `DeferredResult` type also provides methods such as `onTimeout(Runnable)`, +and `onCompletion(Runnable)`. See the Javadoc of `DeferredResult` for more, +details., +When using a `Callable` you can wrap it with an instance of `WebAsyncTask`, +which also provides registration methods for timeout and completion., +, +[[mvc-ann-async-http-streaming]], +==== HTTP Streaming, +, +A controller method can use `DeferredResult` and `Callable` to produce its, +return value asynchronously and that can be used to implement techniques such as, +http://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[long polling], +where the server can push an event to the client as soon as possible., +, +What if you wanted to push multiple events on a single HTTP response?, +This is a technique related to "Long Polling" that is known as "HTTP Streaming"., +Spring MVC makes this possible through the `ResponseBodyEmitter` return value, +type which can be used to send multiple Objects, instead of one as is normally, +the case with `@ResponseBody`, where each Object sent is written to the, +response with an `HttpMessageConverter`., +, +Here is an example of that:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@RequestMapping("/events"), +	public ResponseBodyEmitter<String> handle() {, +		ResponseBodyEmitter<String> emitter = new ResponseBodyEmitter<String>();, +		// Save the emitter somewhere.., +		return emitter;, +	}, +, +	// In some other thread, +	emitter.send("Hello once");, +]