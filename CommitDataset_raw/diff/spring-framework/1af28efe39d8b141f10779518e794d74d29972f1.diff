[+++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj, + * @author Juergen Hoeller, +	 * Construct the aspect using the given transaction metadata retrieval strategy., +	 * transaction metadata for each joinpoint. Implement the subclass to pass in, +	 * {@code null} if it is intended to be configured through Setter Injection., +	Object around(final Object txObject): transactionalMethodExecution(txObject) {, +		// Adapt to TransactionAspectSupport's invokeWithinTransaction..., +			return invokeWithinTransaction(methodSignature.getMethod(), txObject.getClass(), new InvocationCallback() {, +				public Object proceedWithInvocation() throws Throwable {, +					return proceed(txObject);, +			});, +		catch (RuntimeException ex) {, +			throw ex;, +		catch (Error err) {, +			throw err;, +		catch (Throwable thr) {, +			Rethrower.rethrow(thr);, +			throw new IllegalStateException("Should never get here", thr);, +		}, +, +	/**, +	 * Ugly but safe workaround: We need to be able to propagate checked exceptions,, +	 * despite AspectJ around advice supporting specifically declared exceptions only., +	 */, +	private static class Rethrower {, +, +		public static void rethrow(final Throwable exception) {, +			class CheckedExceptionRethrower<T extends Throwable> {, +				@SuppressWarnings("unchecked"), +				private void rethrow(Throwable exception) throws T {, +					throw (T) exception;, +				}, +			}, +			new CheckedExceptionRethrower<RuntimeException>().rethrow(exception);, +		}, +	}, +, +++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj, + * @author Juergen Hoeller, +	 * Construct the aspect using the given transaction metadata retrieval strategy., +	 * transaction metadata for each joinpoint. Implement the subclass to pass in, +	 * {@code null} if it is intended to be configured through Setter Injection., +	Object around(final Object txObject): transactionalMethodExecution(txObject) {, +		// Adapt to TransactionAspectSupport's invokeWithinTransaction..., +			return invokeWithinTransaction(methodSignature.getMethod(), txObject.getClass(), new InvocationCallback() {, +				public Object proceedWithInvocation() throws Throwable {, +					return proceed(txObject);, +			});, +		catch (RuntimeException ex) {, +			throw ex;, +		catch (Error err) {, +			throw err;, +		catch (Throwable thr) {, +			Rethrower.rethrow(thr);, +			throw new IllegalStateException("Should never get here", thr);, +		}, +, +	/**, +	 * Ugly but safe workaround: We need to be able to propagate checked exceptions,, +	 * despite AspectJ around advice supporting specifically declared exceptions only., +	 */, +	private static class Rethrower {, +, +		public static void rethrow(final Throwable exception) {, +			class CheckedExceptionRethrower<T extends Throwable> {, +				@SuppressWarnings("unchecked"), +				private void rethrow(Throwable exception) throws T {, +					throw (T) exception;, +				}, +			}, +			new CheckedExceptionRethrower<RuntimeException>().rethrow(exception);, +		}, +	}, +, +++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AnnotationTransactionAspect.aj, +	 * Matches the execution of any public method in a type with the Transactional, +	 * annotation, or any subtype of a type with the Transactional annotation., +	 * Matches the execution of any method with the Transactional annotation., +++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj, + * @author Juergen Hoeller, +	 * Construct the aspect using the given transaction metadata retrieval strategy., +	 * transaction metadata for each joinpoint. Implement the subclass to pass in, +	 * {@code null} if it is intended to be configured through Setter Injection., +	Object around(final Object txObject): transactionalMethodExecution(txObject) {, +		// Adapt to TransactionAspectSupport's invokeWithinTransaction..., +			return invokeWithinTransaction(methodSignature.getMethod(), txObject.getClass(), new InvocationCallback() {, +				public Object proceedWithInvocation() throws Throwable {, +					return proceed(txObject);, +			});, +		catch (RuntimeException ex) {, +			throw ex;, +		catch (Error err) {, +			throw err;, +		catch (Throwable thr) {, +			Rethrower.rethrow(thr);, +			throw new IllegalStateException("Should never get here", thr);, +		}, +, +	/**, +	 * Ugly but safe workaround: We need to be able to propagate checked exceptions,]