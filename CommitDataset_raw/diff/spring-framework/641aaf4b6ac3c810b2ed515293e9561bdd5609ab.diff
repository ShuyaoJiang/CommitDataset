[+++ b/build.gradle, +		optional("com.fasterxml.jackson.core:jackson-databind:2.2.0") // currently needed for SockJS support, +		optional("reactor:reactor-core:1.0.0.BUILD-SNAPSHOT") // STOMP message processing, +		optional("reactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT")  // STOMP relay to message broker, +    mavenLocal() // temporary workaround for locally installed (latest) reactor, +++ b/build.gradle, +		optional("com.fasterxml.jackson.core:jackson-databind:2.2.0") // currently needed for SockJS support, +		optional("reactor:reactor-core:1.0.0.BUILD-SNAPSHOT") // STOMP message processing, +		optional("reactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT")  // STOMP relay to message broker, +    mavenLocal() // temporary workaround for locally installed (latest) reactor, +++ b/spring-websocket/src/main/java/org/springframework/web/messaging/converter/ContentTypeNotSupportedException.java, +	private static final long serialVersionUID = -3597879520747071896L;, +, +++ b/build.gradle, +		optional("com.fasterxml.jackson.core:jackson-databind:2.2.0") // currently needed for SockJS support, +		optional("reactor:reactor-core:1.0.0.BUILD-SNAPSHOT") // STOMP message processing, +		optional("reactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT")  // STOMP relay to message broker, +    mavenLocal() // temporary workaround for locally installed (latest) reactor, +++ b/spring-websocket/src/main/java/org/springframework/web/messaging/converter/ContentTypeNotSupportedException.java, +	private static final long serialVersionUID = -3597879520747071896L;, +, +++ b/spring-websocket/src/main/java/org/springframework/web/messaging/stomp/support/StompRelayPubSubMessageHandler.java, +import java.nio.charset.Charset;, +import reactor.core.Environment;, +import reactor.core.Promise;, +import reactor.fn.Consumer;, +import reactor.tcp.TcpClient;, +import reactor.tcp.TcpConnection;, +import reactor.tcp.encoding.DelimitedCodec;, +import reactor.tcp.encoding.StandardCodecs;, +import reactor.tcp.netty.NettyTcpClient;, +, +	private final TcpClient<String, String> tcpClient;, +	private final Map<String, TcpConnection<String, String>> connections =, +			new ConcurrentHashMap<String, TcpConnection<String, String>>();, +	public StompRelayPubSubMessageHandler(SubscribableChannel publishChannel, MessageChannel clientChannel) {, +, +		this.tcpClient = new TcpClient.Spec<String, String>(NettyTcpClient.class), +				.using(new Environment()), +				.codec(new DelimitedCodec<String, String>((byte) 0, StandardCodecs.STRING_CODEC)), +				.connect("127.0.0.1", 61613), +				.get();, +, +	public void handleConnect(final Message<?> message) {, +		final String sessionId = (String) message.getHeaders().get(PubSubHeaders.SESSION_ID);, +		Promise<TcpConnection<String, String>> promise = this.tcpClient.open();, +		promise.onSuccess(new Consumer<TcpConnection<String,String>>() {, +			@Override, +			public void accept(TcpConnection<String, String> connection) {, +				connections.put(sessionId, connection);, +			}, +		});, +		promise.consume(new Consumer<TcpConnection<String,String>>() {, +			@Override, +			public void accept(TcpConnection<String, String> connection) {, +				connection.in().consume(new Consumer<String>() {, +					@Override, +					public void accept(String stompFrame) {, +						if (stompFrame.isEmpty()) {, +							// TODO: why are we getting empty frames?, +							return;, +						Message<byte[]> message = stompMessageConverter.toMessage(stompFrame, sessionId);, +						getClientChannel().send(message);, +				});, +			}, +		});, +, +		// TODO: ATM no way to detect closed socket, +, +//		StompHeaders stompHeaders = StompHeaders.create(StompCommand.ERROR);, +//		stompHeaders.setMessage("Socket closed, STOMP session=" + sessionId);, +//		stompHeaders.setSessionId(sessionId);, +//		Message<byte[]> errorMessage = new GenericMessage<byte[]>(new byte[0], stompHeaders.toMessageHeaders());, +//		getClientChannel().send(errorMessage);, +, +		byte[] bytesToWrite;, +			bytesToWrite = this.stompMessageConverter.fromMessage(byteMessage);, +		}, +		catch (Throwable ex) {, +			logger.error("Failed to forward message " + message, ex);, +			return;, +		}, +		TcpConnection<String, String> connection = getConnection(sessionId);, +		Assert.notNull(connection, "TCP connection to message broker not found, sessionId=" + sessionId);, +		try {, +			connection.out().accept(new String(bytesToWrite, Charset.forName("UTF-8")));, +		catch (Throwable ex) {, +			logger.error("Could not get TCP connection " + sessionId, ex);, +				if (connection != null) {, +					connection.close();, +			}, +			catch (Throwable t) {, +	private TcpConnection<String, String> getConnection(String sessionId) {, +		TcpConnection<String, String> connection = this.connections.get(sessionId);, +		if (connection == null) {, +			try {, +				Thread.sleep(1000);, +			}, +			catch (InterruptedException e) {, +				return null;]