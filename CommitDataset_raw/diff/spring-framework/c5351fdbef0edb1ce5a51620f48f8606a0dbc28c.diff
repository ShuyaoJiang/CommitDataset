[+++ b/src/asciidoc/web-flux-functional.adoc, +==== Functional Programming Model, +, +NOTE: This section is to be merged into `web-flux.adoc`., +, +===== HandlerFunctions, +, +Incoming HTTP requests are handled by a **`HandlerFunction`**, which is essentially a function that, +takes a `ServerRequest` and returns a `Mono<ServerResponse>`. The annotation counterpart to a, +handler function would be a method with `@RequestMapping`., +, +`ServerRequest` and `ServerResponse` are immutable interfaces that offer JDK-8 friendly access, +to the underlying HTTP messages. Both are fully reactive by, +building on top of Reactor: the request expose the body as `Flux` or `Mono`; the response accepts, +any http://www.reactive-streams.org[Reactive Streams] `Publisher` as body., +, +`ServerRequest` gives access to various HTTP request elements:, +the method, URI, query parameters, and -- through the separate `ServerRequest.Headers` interface, +-- the headers. Access to the body is provided through the `body` methods. For instance, this is, +how to extract the request body into a `Mono<String>`:, +, + Mono<String> string = request.bodyToMono(String.class);, +, +And here is how to extract the body into a `Flux`, where `Person` is a class that can be, +deserialised from the contents of the body (i.e. `Person` is supported by Jackson if the body, +contains JSON, or JAXB if XML)., +, + Flux<Person> people = request.bodyToFlux(Person.class);, +, +The two methods above (`bodyToMono` and `bodyToFlux`) are, in fact, convenience methods that use the, +generic `ServerRequest.body(BodyExtractor)` method. `BodyExtractor` is, +a functional strategy interface that allows you to write your own extraction logic, but common, +`BodyExtractor` instances can be found in the `BodyExtractors` utility class. So, the above, +examples can be replaced with:, +, + Mono<String> string = request.body(BodyExtractors.toMono(String.class);, + Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class);, +, +Similarly, `ServerResponse` provides access to the HTTP response. Since it is immutable, you create, +a `ServerResponse` with a builder. The builder allows you to set the response status, add response, +headers, and provide a body. For instance, this is how to create a response with a 200 OK status,, +a JSON content-type, and a body:, +, + Mono<Person> person = ..., + ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);, +, +And here is how to build a response with a 201 Created status, Location header, and empty body:, +, + URI location = ..., + ServerResponse.created(location).build();, +, +, +Putting these together allows us to create a `HandlerFunction`. For instance, here is an example, +of a simple "Hello World" handler lambda, that returns a response with a 200 status and a body, +based on a String:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +HandlerFunction<ServerResponse> helloWorld =, +  request -> ServerResponse.ok().body(fromObject("Hello World"));, +----, +, +Writing handler functions as lambda's, as we do above, is convenient, but perhaps lacks in, +readability and becomes less maintainable when dealing with multiple functions. Therefore, it is, +recommended to group related handler functions into a handler or controller class. For example,, +here is a class that exposes a reactive `Person` repository:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +import static org.springframework.http.MediaType.APPLICATION_JSON;, +import static org.springframework.web.reactive.function.BodyInserters.fromObject;, +, +public class PersonHandler {, +, +	private final PersonRepository repository;, +, +	public PersonHandler(PersonRepository repository) {, +		this.repository = repository;, +	}, +, +	public Mono<ServerResponse> listPeople(ServerRequest request) { // <1>, +		Flux<Person> people = repository.allPeople();, +		return ServerResponse.ok().contentType(APPLICATION_JSON).body(people, Person.class);, +	}, +, +	public Mono<ServerResponse> createPerson(ServerRequest request) { // <2>, +		Mono<Person> person = request.bodyToMono(Person.class);, +		return ServerResponse.ok().build(repository.savePerson(person));, +	}, +, +	public Mono<ServerResponse> getPerson(ServerRequest request) { // <3>, +		int personId = Integer.valueOf(request.pathVariable("id"));, +		Mono<ServerResponse> notFound = ServerResponse.notFound().build();, +		Mono<Person> personMono = this.repository.getPerson(personId);, +		return personMono, +				.then(person -> ServerResponse.ok().contentType(APPLICATION_JSON).body(fromObject(person))), +				.otherwiseIfEmpty(notFound);, +	}]