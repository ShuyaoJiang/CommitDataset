[+++ b/spring-context/src/main/java/org/springframework/context/Lifecycle.java, +	 * <p>Should not throw an exception if the component is already running., +	 * <p>In the case of a container, this will propagate the start signal to all, +	 * components that apply., +	 * Stop this component, typically in a synchronous fashion, such that the component is, +	 * fully stopped upon return of this method. Consider implementing {@link SmartLifecycle}, +	 * and its {@code stop(Runnable)} variant when asynchronous stop behavior is necessary., +	 * <p>Note that this stop notification is not guaranteed to come before destruction: On, +	 * regular shutdown, {@code Lifecycle} beans will first receive a stop notification before, +	 * the general destruction callbacks are being propagated; however, on hot refresh during a, +	 * context's lifetime or on aborted refresh attempts, only destroy methods will be called., +	 * <p>In the case of a container, this will propagate the stop signal to all components, +	 * that apply., +	 * @see org.springframework.beans.factory.DisposableBean#destroy(), +	 * <p>In the case of a container, this will return {@code true} only if <i>all</i>, +	 * components that apply are currently running., +++ b/spring-context/src/main/java/org/springframework/context/Lifecycle.java, +	 * <p>Should not throw an exception if the component is already running., +	 * <p>In the case of a container, this will propagate the start signal to all, +	 * components that apply., +	 * Stop this component, typically in a synchronous fashion, such that the component is, +	 * fully stopped upon return of this method. Consider implementing {@link SmartLifecycle}, +	 * and its {@code stop(Runnable)} variant when asynchronous stop behavior is necessary., +	 * <p>Note that this stop notification is not guaranteed to come before destruction: On, +	 * regular shutdown, {@code Lifecycle} beans will first receive a stop notification before, +	 * the general destruction callbacks are being propagated; however, on hot refresh during a, +	 * context's lifetime or on aborted refresh attempts, only destroy methods will be called., +	 * <p>In the case of a container, this will propagate the stop signal to all components, +	 * that apply., +	 * @see org.springframework.beans.factory.DisposableBean#destroy(), +	 * <p>In the case of a container, this will return {@code true} only if <i>all</i>, +	 * components that apply are currently running., +++ b/src/asciidoc/core-beans.adoc, +no-argument signature. With Java config, you use the `initMethod` attribute of `@Bean`,, +configuration metadata, you use the `destroy-method` attribute on the `<bean/>`., +With Java config, you use the `destroyMethod` attribute of `@Bean`, see, +Also, please note that stop notifications are not guaranteed to come before destruction:, +On regular shutdown, all `Lifecycle` beans will first receive a stop notification before, +the general destruction callbacks are being propagated; however, on hot refresh during a, +context's lifetime or on aborted refresh attempts, only destroy methods will be called., +this with the same `@Bean` annotation used to define bean metadata within `@Configuration`, +annotated classes. Here is a simple example:, +such methods are __not__ invoked with normal Java semantics but rather go through the, +container in order to provide the usual lifecycle management and proxying of Spring, +beans even when referring to other beans via programmatic calls to `@Bean` methods., +In contrast, invoking a method or field in an `@Bean` method within a plain `@Component`, +class __has__ standard Java semantics, with no special CGLIB processing or other, +constraints applying., +, +[NOTE], +====, +You may declare `@Bean` methods as `static`, allowing for them to be called without, +creating their containing configuration class as an instance. This makes particular, +sense when defining post-processor beans, e.g. of type `BeanFactoryPostProcessor` or, +`BeanPostProcessor`, since such beans will get initialized early in the container, +lifecycle and should avoid triggering other parts of the configuration at that point., +, +Note that calls to static `@Bean` methods will never get intercepted by the container,, +not even within `@Configuration` classes (see above). This is due to technical, +limitations: CGLIB subclassing can only override non-static methods. As a consequence,, +a direct call to another `@Bean` method will have standard Java semantics, resulting, +in an independent instance being returned straight from the factory method itself., +, +The Java language visibility of `@Bean` methods does not have an immediate impact on, +the resulting bean definition in Spring's container. You may freely declare your, +factory methods as you see fit in non-`@Configuration` classes and also for static, +methods anywhere. However, regular `@Bean` methods in `@Configuration` classes need, +to be overridable, i.e. they must not be declared as `private` or `final`., +, +Finally, `@Bean` methods will also be discovered on base classes of a given component, +or configuration class, as well as on Java 8 default methods declared in interfaces, +implemented by the component or configuration class. This allows for a lot of, +flexibility in composing complex configuration arrangements, with even multiple, +inheritance being possible through Java 8 default methods as of Spring 4.2., +====]