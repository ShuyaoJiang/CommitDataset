[+++ b/src/reference/docbook/testing.xml, +        framework had already existed as a separate project on GitHub where it, +        grew and evolved through actual use, feedback, and the contribution of, +        <para>The standalone <link, +        xl:href="https://github.com/SpringSource/spring-test-mvc">spring-test-mvc, +        project</link> is still available on GitHub and can be used in, +        conjunction with Spring Framework 3.1.x. Applications upgrading to 3.2, +        should replace the <filename>spring-test-mvc</filename> dependency, +        with a dependency on <filename>spring-test</filename>.</para>, +, +        <para>The <filename>spring-test</filename> module uses a different, +        package <classname>org.springframework.test.web</classname> but, +        otherwise is nearly identical with two exceptions. One is support for, +        features new in 3.2 (e.g. async web requests). The other relates to, +        the options for creating a <classname>MockMvc</classname> instance. In, +        Spring Framework 3.2, this can only be done through the TestContext, +        framework, which provides caching benefits for the loaded, +        configuration.</para>, +      <para>The <emphasis>Spring MVC Test framework</emphasis> provides first, +      class JUnit support for testing client and server-side Spring MVC code, +      through a fluent API. Typically it loads the actual Spring configuration, +      through the <emphasis>TestContext framework</emphasis> and always uses, +      the <classname>DispatcherServlet</classname> to process requests thus, +      approximating full integration tests without requiring a running servlet, +      container.</para>, +      <para>Client-side tests are <classname>RestTemplate</classname>-based, +      and allow tests for code that relies on the <code>RestTemplate</code>, +      without requiring a running server to respond to the requests.</para>, +        <para>Before Spring Framework 3.2, the most likely way to test a, +        Spring MVC controller was to write a unit test that instantiates the, +        controller, injects it with mock or stub dependencies, and then calls, +        its methods directly, using a, +        <classname>MockHttpServletRequest</classname> and, +, +        <para>Although this is pretty easy to do, controllers have many, +        annotations, and much remains untested. Request mappings, data, +        binding, type conversion, and validation are just a few examples of, +        what isn't tested. Furthermore, there are other types of annotated, +        methods such as <interfacename>@InitBinder</interfacename>,, +        <interfacename>@ExceptionHandler</interfacename> that get invoked as, +        part of request processing.</para>, +        <para>The idea behind Spring MVC Test is to be able to re-write those, +        controller tests by performing actual requests and generating, +        responses, as they would be at runtime, along the way invoking, +        controllers through the Spring MVC, +        <classname>DispatcherServlet</classname>. Controllers can still be, +        injected with mock dependencies, so tests can remain focused on the, +        web layer.</para>, +        <para>Spring MVC Test builds on the familiar "mock" implementations of, +        the Servlet API available in the <filename>spring-test</filename>, +        module. This allows performing requests and generating responses, +        without the need for running in a Servlet container. For the most part, +        everything should work as it does at runtime with the exception of JSP, +        rendering, which is not available outside a Servlet container., +        Furthermore, if you are familiar with how the, +        <classname>MockHttpServletResponse</classname> works, you'll know that, +        forwards and redirects are not actually executed. Instead "forwarded", +        and "redirected" URLs are saved and can be asserted in tests. This, +        means if you are using JSPs, you can verify the JSP page to which the request was, +        forwarded.</para>, +        Freemarker, Velocity, Thymeleaf, and others for rendering HTML, JSON,, +        XML, and so on should work as expected, and the response will contain, +        the generated content.</para>, +        <para>Below is an example of a test requesting account information in, +        JSON format:</para>, +        <para>The test relies on the, +        <interfacename>WebApplicationContext</interfacename> support of the, +        <emphasis>TestContext framework</emphasis>. It loads Spring, +        configuration from an XML config file located in the same package as, +        the test class (also supports Java config) and injects the created, +        <interfacename>WebApplicationContext</interfacename> into the test so, +        a <classname>MockMvc</classname> instance can be created with, +        it.</para>, +        <para>The <classname>MockMvc</classname> is then used to perform a, +        request to <filename>"/accounts/1"</filename> and verify the resulting, +        <filename>"application/json"</filename>, and response content has a, +        JSON property called "name" with the value "Lee". JSON content is, +        inspected with the help of Jayway's <link, +        xl:href="https://github.com/jayway/JsonPath">JsonPath project</link>., +        There are lots of other options for verifying the result of the, +        performed request and those will be discussed later.</para>, +          <para>The fluent API in the example above requires a few static, +          imports such as <classname>MockMvcRequestBuilders.*</classname>,, +          <classname>MockMvcBuilders.*</classname>. An easy way to find these, +          classes is to search for types matching, +          <emphasis>"MockMvc*"</emphasis>. If using Eclipse, be sure to add, +          them as "favorite static members" in the Eclipse preferences under, +          <emphasis>Java -&gt; Editor -&gt; Content Assist -&gt;, +          Favorites</emphasis>. That will allow use of content assist after, +          typing the first character of the static method name. Other IDEs, +          (e.g. IntelliJ) may not require any additional configuration. Just, +          check the support for code completion on static members.</para>, +          <para>The goal of server-side test setup is to create an instance of, +          <classname>MockMvc</classname> that can be used to perform requests., +          There are two main options.</para>, +          through the <emphasis>TestContext framework</emphasis>, which loads, +          the Spring configuration and injects a, +          <interfacename>WebApplicationContext</interfacename> into the test, +          to use to create a <classname>MockMvc</classname>:</para>, +          <para>The second option is to simply register a controller instance]