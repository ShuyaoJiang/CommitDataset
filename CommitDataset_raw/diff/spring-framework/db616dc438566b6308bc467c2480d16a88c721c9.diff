[+++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2014 the original author or authors., +			Set<Class<?>> groups = new LinkedHashSet<Class<?>>();, +						groups.add((Class<?>) hint);, +					this.targetValidator.validate(target, groups.toArray(new Class<?>[groups.size()])), errors);, +++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2014 the original author or authors., +			Set<Class<?>> groups = new LinkedHashSet<Class<?>>();, +						groups.add((Class<?>) hint);, +					this.targetValidator.validate(target, groups.toArray(new Class<?>[groups.size()])), errors);, +++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, +		Entry<K, V> entry = (reference != null ? reference.get() : null);, +		Entry<K, V> entry = (reference != null ? reference.get() : null);, +	 * Return a {@link Reference} to the {@link Entry} for the specified {@code key},, +	 * or {@code null} if not found., +	 * @return the reference, or {@code null} if not found, +		/** Use {@link SoftReference}s */, +		/** Use {@link WeakReference}s */, +		 * Apply an update operation to this segment., +		 * The segment will be locked during the update., +			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {, +				Entry<K, V> entry = (reference != null ? reference.get() : null);, +			}, +			finally {, +					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold);, +					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {, +				}, +				finally {, +			return (hash & (references.length - 1));, +			return (this.key + "=" + this.value);, +		public final boolean equals(Object other) {, +			if (this == other) {, +			if (!(other instanceof Map.Entry)) {, +			Map.Entry otherEntry = (Map.Entry) other;, +			return (ObjectUtils.nullSafeEquals(getKey(), otherEntry.getKey()) &&, +					ObjectUtils.nullSafeEquals(getValue(), otherEntry.getValue()));, +		}, +			return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));, +				Entry<K, V> other = (reference != null ? reference.get() : null);, +			return (this.next != null);]