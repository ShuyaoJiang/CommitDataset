[+++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/AllTests.java, +		suite.addTestSuite(LiteralTests.class);, +		suite.addTestSuite(ParserErrorMessagesTests.class);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/AllTests.java, +		suite.addTestSuite(LiteralTests.class);, +		suite.addTestSuite(ParserErrorMessagesTests.class);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/BooleanExpressionTests.java, +, +	public void testBooleanErrors01() {, +		evaluateAndCheckError("1 or false", SpelMessages.TYPE_CONVERSION_ERROR, 0);, +		evaluateAndCheckError("false or 39", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError("true and 'hello'", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError(" 'hello' and 'goodbye'", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("!35", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("! 'foob'", SpelMessages.TYPE_CONVERSION_ERROR, 2);, +	}, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/AllTests.java, +		suite.addTestSuite(LiteralTests.class);, +		suite.addTestSuite(ParserErrorMessagesTests.class);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/BooleanExpressionTests.java, +, +	public void testBooleanErrors01() {, +		evaluateAndCheckError("1 or false", SpelMessages.TYPE_CONVERSION_ERROR, 0);, +		evaluateAndCheckError("false or 39", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError("true and 'hello'", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError(" 'hello' and 'goodbye'", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("!35", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("! 'foob'", SpelMessages.TYPE_CONVERSION_ERROR, 2);, +	}, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java, +		evaluate("name", "Nikola Tesla", String.class, false); // not writable because (1) name is private (2) there is, +		// no, +		// setter, only a getter, +		evaluate("placeOfBirth.city", "SmilJan", String.class, true);, +		evaluate("#{1:'January', 2:'February', 3:'March'}.size()", 3, Integer.class);// "{2=February, 1=January,, +		// 3=March}", HashMap.class);, +		evaluate("(#var1='value1';#var1)", "value1", String.class, true);, +		evaluate("@(apple).name", "Apple", String.class, true);, +		evaluate("@(fruits:banana).name", "Banana", String.class, true);, +		evaluate("@(a/b/c:orange).name", "Orange", String.class, true);, +		evaluate("#answer", "42", Integer.class, true);, +		evaluate("(#fn={|| false };#fn)", "{|| false }", Lambda.class, true);, +		evaluate("(#answer=42;#answer)", "42", Integer.class, true);, +		evaluate("($answer=42;$answer)", "42", Integer.class, true);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/AllTests.java, +		suite.addTestSuite(LiteralTests.class);, +		suite.addTestSuite(ParserErrorMessagesTests.class);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/BooleanExpressionTests.java, +, +	public void testBooleanErrors01() {, +		evaluateAndCheckError("1 or false", SpelMessages.TYPE_CONVERSION_ERROR, 0);, +		evaluateAndCheckError("false or 39", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError("true and 'hello'", SpelMessages.TYPE_CONVERSION_ERROR, 9);, +		evaluateAndCheckError(" 'hello' and 'goodbye'", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("!35", SpelMessages.TYPE_CONVERSION_ERROR, 1);, +		evaluateAndCheckError("! 'foob'", SpelMessages.TYPE_CONVERSION_ERROR, 2);, +	}, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java, +		evaluate("name", "Nikola Tesla", String.class, false); // not writable because (1) name is private (2) there is, +		// no, +		// setter, only a getter, +		evaluate("placeOfBirth.city", "SmilJan", String.class, true);, +		evaluate("#{1:'January', 2:'February', 3:'March'}.size()", 3, Integer.class);// "{2=February, 1=January,, +		// 3=March}", HashMap.class);, +		evaluate("(#var1='value1';#var1)", "value1", String.class, true);, +		evaluate("@(apple).name", "Apple", String.class, true);, +		evaluate("@(fruits:banana).name", "Banana", String.class, true);, +		evaluate("@(a/b/c:orange).name", "Orange", String.class, true);, +		evaluate("#answer", "42", Integer.class, true);, +		evaluate("(#fn={|| false };#fn)", "{|| false }", Lambda.class, true);, +		evaluate("(#answer=42;#answer)", "42", Integer.class, true);, +		evaluate("($answer=42;$answer)", "42", Integer.class, true);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/ExpressionTestCase.java, +	public void evaluate(String expression, Object expectedValue, Class<?> expectedClassOfResult,, +			boolean shouldBeWritable) {, +		evaluateAndCheckError(expression, null, expectedMessage, otherProperties);, +	}, +, +	/**, +	 * Evaluate the specified expression and ensure the expected message comes out. The message may have inserts and, +	 * they will be checked if otherProperties is specified. The first entry in otherProperties should always be the, +	 * position., +	 * @param expression The expression to evaluate, +	 * @param expectedReturnType Ask the expression return value to be of this type if possible (null indicates don't, +	 * ask for conversion), +	 * @param expectedMessage The expected message, +	 * @param otherProperties The expected inserts within the message, +	 */, +	protected void evaluateAndCheckError(String expression, Class<?> expectedReturnType, SpelMessages expectedMessage,, +			Object... otherProperties) {, +			if (expectedReturnType != null) {, +				@SuppressWarnings("unused"), +				Object value = expr.getValue(eContext, expectedReturnType);, +			} else {, +			}, +	/**, +	 * Parse the specified expression and ensure the expected message comes out. The message may have inserts and they, +	 * will be checked if otherProperties is specified. The first entry in otherProperties should always be the, +	 * position., +	 * @param expression The expression to evaluate]