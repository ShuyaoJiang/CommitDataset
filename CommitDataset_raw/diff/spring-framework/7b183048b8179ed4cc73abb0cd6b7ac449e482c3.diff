[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientStrategiesBuilder.java, +import org.springframework.http.codec.ServerSentEventHttpMessageReader;, +		if (jackson2Present) {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.singletonList(new Jackson2JsonDecoder())));, +		}, +		else {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.emptyList()));, +		}, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientStrategiesBuilder.java, +import org.springframework.http.codec.ServerSentEventHttpMessageReader;, +		if (jackson2Present) {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.singletonList(new Jackson2JsonDecoder())));, +		}, +		else {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.emptyList()));, +		}, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/server/SseHandlerFunctionIntegrationTests.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.springframework.http.MediaType.TEXT_EVENT_STREAM;, +import static org.springframework.web.reactive.function.BodyExtractors.toFlux;, +import org.springframework.core.ResolvableType;, +public class SseHandlerFunctionIntegrationTests extends AbstractRouterFunctionIntegrationTests {, +		ClientRequest<Void> request = ClientRequest, +						.accept(TEXT_EVENT_STREAM), +				.flatMap(response -> response.body(toFlux(String.class)));, +				.expectNext("foo 0"), +				.expectNext("foo 1"), +				.verify(Duration.ofSeconds(5L));, +						.accept(TEXT_EVENT_STREAM), +		Flux<Person> result = this.webClient, +				.flatMap(response -> response.body(toFlux(Person.class)));, +				.expectNext(new Person("foo 0")), +				.expectNext(new Person("foo 1")), +				.verify(Duration.ofSeconds(5L));, +						.accept(TEXT_EVENT_STREAM), +		ResolvableType type = ResolvableType.forClassWithGenerics(ServerSentEvent.class, String.class);, +		Flux<ServerSentEvent<String>> result = this.webClient, +				.flatMap(response -> response.body(toFlux(type)));, +				.consumeNextWith( event -> {, +					assertEquals("0", event.id().get());, +					assertEquals("foo", event.data().get());, +					assertEquals("bar", event.comment().get());, +					assertFalse(event.event().isPresent());, +					assertFalse(event.retry().isPresent());, +				}), +				.consumeNextWith( event -> {, +					assertEquals("1", event.id().get());, +					assertEquals("foo", event.data().get());, +					assertEquals("bar", event.comment().get());, +					assertFalse(event.event().isPresent());, +					assertFalse(event.retry().isPresent());, +				}), +				.verify(Duration.ofSeconds(5L));, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientStrategiesBuilder.java, +import org.springframework.http.codec.ServerSentEventHttpMessageReader;, +		if (jackson2Present) {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.singletonList(new Jackson2JsonDecoder())));, +		}, +		else {, +			messageReader(new ServerSentEventHttpMessageReader(Collections.emptyList()));, +		}, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/server/SseHandlerFunctionIntegrationTests.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.springframework.http.MediaType.TEXT_EVENT_STREAM;, +import static org.springframework.web.reactive.function.BodyExtractors.toFlux;, +import org.springframework.core.ResolvableType;, +public class SseHandlerFunctionIntegrationTests extends AbstractRouterFunctionIntegrationTests {, +		ClientRequest<Void> request = ClientRequest, +						.accept(TEXT_EVENT_STREAM), +				.flatMap(response -> response.body(toFlux(String.class)));, +				.expectNext("foo 0"), +				.expectNext("foo 1"), +				.verify(Duration.ofSeconds(5L));, +						.accept(TEXT_EVENT_STREAM), +		Flux<Person> result = this.webClient, +				.flatMap(response -> response.body(toFlux(Person.class)));, +				.expectNext(new Person("foo 0")), +				.expectNext(new Person("foo 1")), +				.verify(Duration.ofSeconds(5L));, +						.accept(TEXT_EVENT_STREAM), +		ResolvableType type = ResolvableType.forClassWithGenerics(ServerSentEvent.class, String.class);, +		Flux<ServerSentEvent<String>> result = this.webClient, +				.flatMap(response -> response.body(toFlux(type)));, +				.consumeNextWith( event -> {, +					assertEquals("0", event.id().get());, +					assertEquals("foo", event.data().get());, +					assertEquals("bar", event.comment().get());, +					assertFalse(event.event().isPresent());, +					assertFalse(event.retry().isPresent());, +				}), +				.consumeNextWith( event -> {, +					assertEquals("1", event.id().get());, +					assertEquals("foo", event.data().get());, +					assertEquals("bar", event.comment().get());, +					assertFalse(event.event().isPresent());, +					assertFalse(event.retry().isPresent());, +				}), +				.verify(Duration.ofSeconds(5L));]