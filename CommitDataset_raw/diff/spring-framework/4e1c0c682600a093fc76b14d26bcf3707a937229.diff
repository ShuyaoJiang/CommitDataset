[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		return new ChannelSendOperator<>(encodedContent, publisher ->, +				handleEncodedContent(Flux.from(publisher), returnType, message));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		return new ChannelSendOperator<>(encodedContent, publisher ->, +				handleEncodedContent(Flux.from(publisher), returnType, message));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/ChannelSendOperator.java, +/*, + * Copyright 2002-2018 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.messaging.handler.invocation.reactive;, +, +import java.util.function.Function;, +, +import org.reactivestreams.Publisher;, +import org.reactivestreams.Subscriber;, +import org.reactivestreams.Subscription;, +import reactor.core.CoreSubscriber;, +import reactor.core.Scannable;, +import reactor.core.publisher.Flux;, +import reactor.core.publisher.Mono;, +import reactor.core.publisher.Operators;, +import reactor.util.context.Context;, +, +import org.springframework.lang.Nullable;, +import org.springframework.util.Assert;, +, +/**, + * ----------------------, + * <p><strong>NOTE:</strong> This class was copied from, + * {@code org.springframework.http.server.reactive.ChannelSendOperator} and is, + * identical to it. It's used for the same purpose, i.e. the ability to switch to, + * alternate handling via annotated exception handler methods if the output, + * publisher starts with an error., + * <p>----------------------<br>, + *, + * <p>Given a write function that accepts a source {@code Publisher<T>} to write, + * with and returns {@code Publisher<Void>} for the result, this operator helps, + * to defer the invocation of the write function, until we know if the source, + * publisher will begin publishing without an error. If the first emission is, + * an error, the write function is bypassed, and the error is sent directly, + * through the result publisher. Otherwise the write function is invoked., + *, + * @author Rossen Stoyanchev, + * @author Stephane Maldini, + * @since 5.2, + * @param <T> the type of element signaled, + */, +class ChannelSendOperator<T> extends Mono<Void> implements Scannable {, +, +	private final Function<Publisher<T>, Publisher<Void>> writeFunction;, +, +	private final Flux<T> source;, +, +, +	public ChannelSendOperator(Publisher<? extends T> source, Function<Publisher<T>, Publisher<Void>> writeFunction) {, +		this.source = Flux.from(source);, +		this.writeFunction = writeFunction;, +	}, +, +, +	@Override, +	@Nullable, +	@SuppressWarnings("rawtypes"), +	public Object scanUnsafe(Attr key) {, +		if (key == Attr.PREFETCH) {, +			return Integer.MAX_VALUE;, +		}, +		if (key == Attr.PARENT) {, +			return this.source;, +		}, +		return null;, +	}, +, +	@Override, +	public void subscribe(CoreSubscriber<? super Void> actual) {, +		this.source.subscribe(new WriteBarrier(actual));, +	}, +, +, +	private enum State {, +, +		/** No emissions from the upstream source yet. */, +		NEW,, +, +		/**, +		 * At least one signal of any kind has been received; we're ready to]