[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final Set<String> knownSuperclasses = new LinkedHashSet<String>();, +, +		// recursively process the configuration class and its superclass hierarchy, +		do {, +			metadata = doProcessConfigurationClass(configClass, metadata);, +		while (metadata != null);, +, +	/**, +	 * @return annotation metadata of superclass, null if none found or previously processed, +	 */, +	protected AnnotationMetadata doProcessConfigurationClass(, +			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {, +, +		// process superclass, if any, +		if (metadata.hasSuperClass()) {, +			String superclass = metadata.getSuperClassName();, +			if (this.knownSuperclasses.add(superclass)) {, +				// superclass found, return its annotation metadata and recurse, +				if (metadata instanceof StandardAnnotationMetadata) {, +					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();, +					return new StandardAnnotationMetadata(clazz.getSuperclass(), true);, +				}, +				else {, +					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);, +					return reader.getAnnotationMetadata();, +				}, +			}, +		// no superclass, processing is complete, +		return null;, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final Set<String> knownSuperclasses = new LinkedHashSet<String>();, +, +		// recursively process the configuration class and its superclass hierarchy, +		do {, +			metadata = doProcessConfigurationClass(configClass, metadata);, +		while (metadata != null);, +, +	/**, +	 * @return annotation metadata of superclass, null if none found or previously processed, +	 */, +	protected AnnotationMetadata doProcessConfigurationClass(, +			ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {, +, +		// process superclass, if any, +		if (metadata.hasSuperClass()) {, +			String superclass = metadata.getSuperClassName();, +			if (this.knownSuperclasses.add(superclass)) {, +				// superclass found, return its annotation metadata and recurse, +				if (metadata instanceof StandardAnnotationMetadata) {, +					Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();, +					return new StandardAnnotationMetadata(clazz.getSuperclass(), true);, +				}, +				else {, +					MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);, +					return reader.getAnnotationMetadata();, +				}, +			}, +		// no superclass, processing is complete, +		return null;, +	}, +++ b/org.springframework.context/src/test/java/org/springframework/context/annotation/configuration/spr8955/Spr8955Parent.java, +/*, + * Copyright 2002-2012 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.context.annotation.configuration.spr8955;, +, +import org.springframework.stereotype.Component;, +, +/**, + * @author Chris Beams, + * @author Willem Dekker, + */, +abstract class Spr8955Parent {, +, +	@Component, +	static class Spr8955Child extends Spr8955Parent {, +, +	}, +, +}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final Set<String> knownSuperclasses = new LinkedHashSet<String>();, +, +		// recursively process the configuration class and its superclass hierarchy, +		do {]