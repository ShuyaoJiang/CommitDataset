[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, +import java.lang.reflect.Modifier;, +import org.springframework.expression.EvaluationContext;, +import org.springframework.expression.spel.ExpressionState;, +import org.springframework.expression.spel.reflection.ReflectionUtils;, +		, +		// Two possibilities: a lambda function or a Java static method registered as a function, +	/**, +	 * Execute a function represented as a java.lang.reflect.Method., +	 * , +	 * @param state the expression evaluation state, +	 * @param the java method to invoke, +	 * @return the return value of the invoked Java method, +	 * @throws EvaluationException if there is any problem invoking the method, +	 */, +		, +		// Only static methods can be called in this way, +		if (!Modifier.isStatic(m.getModifiers())) {, +			throw new SpelException(getCharPositionInLine(),SpelMessages.FUNCTION_MUST_BE_STATIC,m.getDeclaringClass().getName()+"."+m.getName(),name);, +		if (functionArgs != null) {, +			EvaluationContext ctx = state.getEvaluationContext();, +			TypeConverter converter = null;, +			if (ctx.getTypeUtils()!=null) {, +				converter = ctx.getTypeUtils().getTypeConverter();, +			ReflectionUtils.convertArguments(m.getParameterTypes(), m.isVarArgs(), converter, functionArgs);, +		}, +		if (m.isVarArgs()) {, +			functionArgs = ReflectionUtils.setupArgumentsForVarargsInvocation(m.getParameterTypes(), functionArgs);, +			return m.invoke(m.getClass(), functionArgs);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, +import java.lang.reflect.Modifier;, +import org.springframework.expression.EvaluationContext;, +import org.springframework.expression.spel.ExpressionState;, +import org.springframework.expression.spel.reflection.ReflectionUtils;, +		, +		// Two possibilities: a lambda function or a Java static method registered as a function, +	/**, +	 * Execute a function represented as a java.lang.reflect.Method., +	 * , +	 * @param state the expression evaluation state, +	 * @param the java method to invoke, +	 * @return the return value of the invoked Java method, +	 * @throws EvaluationException if there is any problem invoking the method, +	 */, +		, +		// Only static methods can be called in this way, +		if (!Modifier.isStatic(m.getModifiers())) {, +			throw new SpelException(getCharPositionInLine(),SpelMessages.FUNCTION_MUST_BE_STATIC,m.getDeclaringClass().getName()+"."+m.getName(),name);, +		if (functionArgs != null) {, +			EvaluationContext ctx = state.getEvaluationContext();, +			TypeConverter converter = null;, +			if (ctx.getTypeUtils()!=null) {, +				converter = ctx.getTypeUtils().getTypeConverter();, +			ReflectionUtils.convertArguments(m.getParameterTypes(), m.isVarArgs(), converter, functionArgs);, +		}, +		if (m.isVarArgs()) {, +			functionArgs = ReflectionUtils.setupArgumentsForVarargsInvocation(m.getParameterTypes(), functionArgs);, +			return m.invoke(m.getClass(), functionArgs);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/StandardTypeConverter.java, +			if (value instanceof String) {, +				try {, +					return Integer.parseInt((String)value);, +				} catch (NumberFormatException nfe) {, +					throw new SpelException(SpelMessages.PROBLEM_DURING_TYPE_CONVERSION, "cannot parse string '" + value, +							+ "' as an integer");, +				}, +			} else { // Long, +		}, +			return new Class<?>[] { Long.class, String.class };]