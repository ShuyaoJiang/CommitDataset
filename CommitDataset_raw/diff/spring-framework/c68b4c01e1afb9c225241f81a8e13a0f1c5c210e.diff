[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/client/AbstractXhrTransport.java, +import org.springframework.web.socket.sockjs.transport.TransportType;, +import java.util.Arrays;, +import java.util.List;, +	@Override, +	public List<TransportType> getTransportTypes() {, +		return (isXhrStreamingDisabled() ?, +				Arrays.asList(TransportType.XHR) :, +				Arrays.asList(TransportType.XHR_STREAMING, TransportType.XHR));, +	}, +, +	 * An {@code XhrTransport} can support both the "xhr_streaming" and "xhr", +	 * SockJS server transports. From a client perspective there is no, +	 * implementation difference., +	 *, +	 * <p>Typically an {@code XhrTransport} is used as "XHR streaming" first and, +	 * then, if that fails, as "XHR". In some cases however it may be helpful to, +	 * suppress XHR streaming so that only XHR is attempted., +	 * "XHR streaming" and "XHR" apply., +	/**, +	 * Whether XHR streaming is disabled or not., +	 */, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/client/AbstractXhrTransport.java, +import org.springframework.web.socket.sockjs.transport.TransportType;, +import java.util.Arrays;, +import java.util.List;, +	@Override, +	public List<TransportType> getTransportTypes() {, +		return (isXhrStreamingDisabled() ?, +				Arrays.asList(TransportType.XHR) :, +				Arrays.asList(TransportType.XHR_STREAMING, TransportType.XHR));, +	}, +, +	 * An {@code XhrTransport} can support both the "xhr_streaming" and "xhr", +	 * SockJS server transports. From a client perspective there is no, +	 * implementation difference., +	 *, +	 * <p>Typically an {@code XhrTransport} is used as "XHR streaming" first and, +	 * then, if that fails, as "XHR". In some cases however it may be helpful to, +	 * suppress XHR streaming so that only XHR is attempted., +	 * "XHR streaming" and "XHR" apply., +	/**, +	 * Whether XHR streaming is disabled or not., +	 */, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/client/SockJsClient.java, + * with fallback alternatives that simulate a WebSocket interaction through plain, + * HTTP streaming and long polling techniques.., + *, + * <p>Implements {@link Lifecycle} in order to propagate lifecycle events to, + * the transports it is configured with., +	private final List<Transport> transports;, +, +	private TaskScheduler connectTimeoutScheduler;, +	private final Map<URI, ServerInfo> serverInfoCache = new ConcurrentHashMap<URI, ServerInfo>();, +	 *, +	 * <p>If the list includes an {@link XhrTransport} (or more specifically an, +	 * implementation of {@link InfoReceiver}) the instance is used to initialize, +	 * the {@link #setInfoReceiver(InfoReceiver) infoReceiver} property, or, +	 * otherwise is defaulted to {@link RestTemplateXhrTransport}., +	 *, +	 * @param transports the (non-empty) list of transports to use, +		this.transports = new ArrayList<Transport>(transports);, +	 * <p>If the list of transports provided to the constructor contained an, +	 * {@link XhrTransport} or an implementation of {@link InfoReceiver} that, +	 * instance would have been used to initialize this property, or otherwise, +	 * it defaults to {@link RestTemplateXhrTransport}., +		Assert.notNull(infoReceiver, "'infoReceiver' is required");, +	/**, +	 * Return the configured {@code InfoReceiver}, never {@code null}., +	 */, +	 * SockJS "Info" request. The connect timeout task ensures a more timely, +	 * fallback but is otherwise entirely optional., +	 * <p>By default this is not configured in which case a fallback may take longer., +	 * @param connectTimeoutScheduler the task scheduler to use, +	public void setConnectTimeoutScheduler(TaskScheduler connectTimeoutScheduler) {, +		this.connectTimeoutScheduler = connectTimeoutScheduler;, +			this.running = true;, +			this.running = false;, +	/**, +	 * By default the result of a SockJS "Info" request, including whether the, +	 * server has WebSocket disabled and how long the request took (used for, +	 * calculating transport timeout time) is cached. This method can be used to, +	 * clear that cache hence causing it to re-populate., +	 */, +		this.serverInfoCache.clear();, +			createRequest(sockJsUrlInfo, handshakeHeaders, serverInfo).connect(handler, connectFuture);, +		ServerInfo info = this.serverInfoCache.get(infoUrl);, +			this.serverInfoCache.put(infoUrl, info);, +	private DefaultTransportRequest createRequest(SockJsUrlInfo urlInfo, HttpHeaders headers, ServerInfo serverInfo) {, +			for (TransportType type : transport.getTransportTypes()) {, +				if (serverInfo.isWebSocketEnabled() || !TransportType.WEBSOCKET.equals(type)) {, +					requests.add(new DefaultTransportRequest(urlInfo, headers, transport, type, getMessageCodec()));, +		}, +		Assert.notEmpty(requests, "No transports, " + urlInfo + ", wsEnabled=" + serverInfo.isWebSocketEnabled());, +			DefaultTransportRequest request = requests.get(i);, +			request.setUser(getUser());, +			if (this.connectTimeoutScheduler != null) {, +				request.setTimeoutValue(serverInfo.getRetransmissionTimeout());, +				request.setTimeoutScheduler(this.connectTimeoutScheduler);, +			}]