[+++ b/spring-web/src/main/java/org/springframework/http/codec/CodecConfigurer.java, +		 * Override the default Protobuf {@code Encoder}., +		 * @param encoder the encoder instance to use, +		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder, +		void protobufEncoder(Encoder<?> encoder);, +++ b/spring-web/src/main/java/org/springframework/http/codec/CodecConfigurer.java, +		 * Override the default Protobuf {@code Encoder}., +		 * @param encoder the encoder instance to use, +		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder, +		void protobufEncoder(Encoder<?> encoder);, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufCodecSupport.java, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/CodecConfigurer.java, +		 * Override the default Protobuf {@code Encoder}., +		 * @param encoder the encoder instance to use, +		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder, +		void protobufEncoder(Encoder<?> encoder);, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufCodecSupport.java, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufDecoder.java, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.lang.Nullable;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final ConcurrentMap<Class<?>, Method> methodCache = new ConcurrentReferenceHashMap<>();, +, +, +	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {, +		return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType);, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +, +						Message.Builder builder = getMessageBuilder(elementType.toClass());, +		@Nullable, +		// TODO Instead of the recursive call, loop over the current DataBuffer,, +		// produce a list of as many messages as are contained, and save any remaining bytes with flatMapIterable, +					Message.Builder builder = getMessageBuilder(this.elementType.toClass());, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/CodecConfigurer.java, +		 * Override the default Protobuf {@code Encoder}., +		 * @param encoder the encoder instance to use, +		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder, +		void protobufEncoder(Encoder<?> encoder);, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufCodecSupport.java, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufDecoder.java, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.lang.Nullable;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final ConcurrentMap<Class<?>, Method> methodCache = new ConcurrentReferenceHashMap<>();, +, +, +	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {, +		return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType);, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +, +						Message.Builder builder = getMessageBuilder(elementType.toClass());, +		@Nullable, +		// TODO Instead of the recursive call, loop over the current DataBuffer,, +		// produce a list of as many messages as are contained, and save any remaining bytes with flatMapIterable, +					Message.Builder builder = getMessageBuilder(this.elementType.toClass());, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufEncoder.java, +import org.springframework.lang.Nullable;, +			.map(mimeType -> new MediaType(mimeType.getType(), mimeType.getSubtype(),, +					Collections.singletonMap(DELIMITED_KEY, DELIMITED_VALUE))), +, +	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {, +		return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType);, +	public Flux<DataBuffer> encode(Publisher<? extends Message> inputStream, DataBufferFactory bufferFactory,, +			ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/CodecConfigurer.java, +		 * Override the default Protobuf {@code Encoder}., +		 * @param encoder the encoder instance to use, +		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder, +		void protobufEncoder(Encoder<?> encoder);, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufCodecSupport.java, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufDecoder.java, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.lang.Nullable;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final ConcurrentMap<Class<?>, Method> methodCache = new ConcurrentReferenceHashMap<>();, +, +, +	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {, +		return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType);, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {, +, +						Message.Builder builder = getMessageBuilder(elementType.toClass());, +		@Nullable, +		// TODO Instead of the recursive call, loop over the current DataBuffer,, +		// produce a list of as many messages as are contained, and save any remaining bytes with flatMapIterable, +					Message.Builder builder = getMessageBuilder(this.elementType.toClass());, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufEncoder.java, +import org.springframework.lang.Nullable;]