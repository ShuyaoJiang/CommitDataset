[+++ b/spring-context/src/main/java/org/springframework/cache/concurrent/ConcurrentMapCache.java, +		this(name, new ConcurrentHashMap<>(256), true);, +		this(name, new ConcurrentHashMap<>(256), allowNullValues);, +			return (T) fromStoreValue(this.store.computeIfAbsent(key, r -> {, +					return toStoreValue(valueLoader.call());, +			}));, +++ b/spring-context/src/main/java/org/springframework/cache/concurrent/ConcurrentMapCache.java, +		this(name, new ConcurrentHashMap<>(256), true);, +		this(name, new ConcurrentHashMap<>(256), allowNullValues);, +			return (T) fromStoreValue(this.store.computeIfAbsent(key, r -> {, +					return toStoreValue(valueLoader.call());, +			}));, +++ b/spring-context/src/test/java/org/springframework/cache/concurrent/ConcurrentMapCacheTests.java, + * Copyright 2002-2016 the original author or authors., +		this.nativeCache = new ConcurrentHashMap<>();, +		this.cache = new ConcurrentMapCache(CACHE_NAME, this.nativeCache, true);, +		this.cache.clear();, +		this.thrown.expect(IllegalArgumentException.class);, +		this.thrown.expectMessage("Failed to serialize");, +		this.thrown.expectMessage(this.cache.getClass().getName());, +		this.thrown.expect(IllegalArgumentException.class);, +		this.thrown.expectMessage("Failed to deserialize");, +		this.thrown.expectMessage("Some garbage");, +		return new ConcurrentMapCache(CACHE_NAME, this.nativeCache, true,]