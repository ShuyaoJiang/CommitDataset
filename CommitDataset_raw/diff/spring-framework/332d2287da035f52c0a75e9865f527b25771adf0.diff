[+++ b/spring-framework-reference/src/mvc.xml, +<chapter id="mvc">, +    theme resolution as well as support for uploading files. The default, +    handler is based on the <interfacename>@Controller</interfacename> and, +    <interfacename>@RequestMapping</interfacename> annotations, offering a, +    wide range of flexible handling methods. With the introduction of Spring, +    3.0, the <interfacename>@Controller</interfacename> mechanism also allows, +    your to create RESTful Web sites or application, though the, +    <interfacename>@PathVarariable</interfacename> annotation and other, +    features.</para>, +    backing object - there is no need to implement a framework-specific, +    interface or base class. Spring's data binding is highly flexible: for, +    example, it treats type mismatches as validation errors that can be, +    evaluated by the application, not as system errors. All this means that, +    you don't need to duplicate your business objects' properties as simple,, +    untyped strings in your form objects just to be able to handle invalid, +    submissions, or to convert the Strings properly. Instead, it is often, +    preferable to bind directly to your business objects.</para>, +    <interfacename>Controller</interfacename> implementation can even write, +    directly to the response stream. In the normal case, a, +      <xi:include href="swf-sidebar.xml", +                  xmlns:xi="http://www.w3.org/2001/XInclude" />, +          <para>Adaptability, non-intrusiveness, and flexibility. Define, +          whatever controller method signature you need, possibly using one of, +          the parameter annotations (such as @RequestParam, @RequestHeader,, +          @PathVariable, and more) for a given scenario.</para>, +        &lt;url-pattern&gt;/golfing/*&lt;/url-pattern&gt;, +, +, +    created.</para>, +    <para>Spring 2.5 introduced an annotation-based programming model for MVC, +    controllers, using annotations such as, +    <interfacename>@RequestMapping</interfacename>,, +    <interfacename>@RequestParam</interfacename>,, +    <interfacename>@ModelAttribute</interfacename>, etc. This annotation, +    support is available for both Servlet MVC and Portlet MVC. Controllers, +    implemented in this style do not have to extend specific base classes or, +    implement specific interfaces. Furthermore, they do not usually have, +    direct dependencies on Servlet or Portlet API's, although they can easily, +    get access to Servlet or Portlet facilities if desired.</para>, +    <tip>, +      <para>The Spring distribution ships with the, +      <emphasis>PetClinic</emphasis> sample, which is a web application that, +      takes advantage of the annotation support described in this section, in, +      the context of simple form processing. You can find the, +      <emphasis>PetClinic</emphasis> application in the, +      <literal>'samples/petclinic'</literal> directory.</para>, +      <para>For a further sample application that builds on annotation-based, +      Web MVC, check out <emphasis>imagedb</emphasis>. The focus in that, +      sample is on stateless multi-action controllers, including the, +      processing of multipart file uploads. You can find the, +      <emphasis>imagedb</emphasis> application in the, +      <literal>'samples/imagedb'</literal> directory.</para>, +    </tip>, +    <programlisting language="java">@Controller, +public class HelloWorldController {, +    @RequestMapping("/helloWorld"), +    public ModelAndView helloWorld() {, +        ModelAndView mac = new ModelAndView();, +        mav.setViewName("helloWorld");, +    <para>As you can see, the <interfacename>@Controller</interfacename> and, +    <interfacename>@RequestMapping</interfacename> annotations allow for, +    flexible method names and signatures. In this particular example the, +    method has no parameters and returns a, +    <classname>ModelAndView</classname>, but various other (and better), +    strategies exist, as will be explained later in this section., +    <classname>ModelAndView</classname>,, +    <interfacename>@Controller</interfacename>, and, +    <interfacename>@RequestMapping</interfacename> form the basis for the, +    Spring MVC implementation. This section document these annotations and how, +    they are most commonly used in a Servlet environment.</para>, +    <section id="mvc-ann-controller">, +      <title>Defining a controller with, +      <interfacename>@Controller</interfacename></title>, +, +      <para>The <interfacename>@Controller</interfacename> annotation, +      indicates that a particular class serves the role of a, +      <emphasis>controller</emphasis>. There is no need to extend any, +      controller base class or reference the Servlet API. You are of course, +      still able to reference Servlet-specific features if you need to.</para>, +, +      <para>The basic purpose of the, +      <interfacename>@Controller</interfacename> annotation is to act as a, +      stereotype for the annotated class, indicating its role. The dispatcher, +      will scan such annotated classes for mapped methods, detecting, +      <interfacename>@RequestMapping</interfacename> annotations (see the next, +      section).</para>, +, +      <para>Annotated controller beans may be defined explicitly, using a, +      standard Spring bean definition in the dispatcher's context. However,, +      the <interfacename>@Controller</interfacename> stereotype also allows, +      for autodetection, aligned with Spring general support for detecting, +      component classes in the classpath and auto-registering bean definitions, +      for them.</para>, +, +      <para>To enable autodetection of such annotated controllers, you have to, +      add component scanning to your configuration. This is easily achieved by, +      using the <emphasis>spring-context</emphasis> schema as shown in the, +      following XML snippet:</para>, +]