[+++ b/spring-context/src/main/java/org/springframework/cache/support/AbstractCacheManager.java, + * Copyright 2002-2015 the original author or authors., +	private volatile Set<String> cacheNames = Collections.emptySet();, +		initializeCaches();, +	}, +, +	/**, +	 * Initialize the static configuration of caches., +	 * <p>Triggered on startup through {@link #afterPropertiesSet()};, +	 * can also be called to re-initialize at runtime., +	 * @since 4.2.2, +	 * @see #loadCaches(), +	 */, +	public void initializeCaches() {, +		synchronized (this.cacheMap) {, +			this.cacheNames = Collections.emptySet();, +			Set<String> cacheNames = new LinkedHashSet<String>(caches.size());, +				String name = cache.getName();, +				this.cacheMap.put(name, decorateCache(cache));, +				cacheNames.add(name);, +			}, +			this.cacheNames = Collections.unmodifiableSet(cacheNames);, +		Cache cache = this.cacheMap.get(name);, +			// Fully synchronize now for missing cache creation..., +			synchronized (this.cacheMap) {, +				cache = this.cacheMap.get(name);, +				if (cache == null) {, +					cache = getMissingCache(name);, +					if (cache != null) {, +						cache = decorateCache(cache);, +						this.cacheMap.put(name, cache);, +						updateCacheNames(name);, +				}, +				return cache;, +			}, +		return this.cacheNames;, +	// Common cache initialization delegates for subclasses, +	/**, +	 * Check for a registered cache of the given name., +	 * In contrast to {@link #getCache(String)}, this method does not trigger, +	 * the lazy creation of missing caches via {@link #getMissingCache(String)}., +	 * @param name the cache identifier (must not be {@code null}), +	 * @return the associated Cache instance, or {@code null} if none found, +	 * @since 4.1, +	 * @see #getCache(String), +	 * @see #getMissingCache(String), +	 */, +	 * Dynamically register an additional Cache with this manager., +	 * @param cache the Cache to register, +	 */, +	protected final void addCache(Cache cache) {, +		String name = cache.getName();, +		synchronized (this.cacheMap) {, +			if (this.cacheMap.put(name, decorateCache(cache)) == null) {, +				updateCacheNames(name);, +			}, +		}, +	}, +, +	/**, +	 * Update the exposed {@link #cacheNames} set with the given name., +	 * <p>This will always be called within a full {@link #cacheMap} lock, +	 * and effectively behaves like a {@code CopyOnWriteArraySet} with, +	 * preserved order but exposed as an unmodifiable reference., +	 * @param name the name of the cache to be added, +	 */, +	private void updateCacheNames(String name) {, +		Set<String> cacheNames = new LinkedHashSet<String>(this.cacheNames.size() + 1);, +		cacheNames.addAll(this.cacheNames);, +		cacheNames.add(name);, +		this.cacheNames = Collections.unmodifiableSet(cacheNames);, +	}, +, +, +	// Overridable template methods for cache initialization, +, +	/**, +	 * @since 4.1]