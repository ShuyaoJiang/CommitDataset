[+++ b/spring-context/src/main/java/org/springframework/cache/CacheManager.java, + * Copyright 2002-2014 the original author or authors., +	 * @return the associated cache, or {@code null} if none is found, +	 * @return names of caches known by the cache manager, +++ b/spring-context/src/main/java/org/springframework/cache/CacheManager.java, + * Copyright 2002-2014 the original author or authors., +	 * @return the associated cache, or {@code null} if none is found, +	 * @return names of caches known by the cache manager, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2014 the original author or authors., +			throw new IllegalStateException("Do not build compound expression less than one entry: " +, +					expressionComponents.length);, +		SpelNodeImpl nextNode = this.children[0];, +			TypedValue result = nextNode.getValueInternal(state);, +	 * Evaluates a compound expression. This involves evaluating each piece in turn and the, +	 * return value from each piece is the active context object for the subsequent piece., +++ b/spring-context/src/main/java/org/springframework/cache/CacheManager.java, + * Copyright 2002-2014 the original author or authors., +	 * @return the associated cache, or {@code null} if none is found, +	 * @return names of caches known by the cache manager, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, + * Copyright 2002-2014 the original author or authors., +			throw new IllegalStateException("Do not build compound expression less than one entry: " +, +					expressionComponents.length);, +		SpelNodeImpl nextNode = this.children[0];, +			TypedValue result = nextNode.getValueInternal(state);, +	 * Evaluates a compound expression. This involves evaluating each piece in turn and the, +	 * return value from each piece is the active context object for the subsequent piece., +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2014 the original author or authors., + * Supported structures are: strings / collections (lists/sets) / arrays., +	private void setArrayElement(TypeConverter converter, Object ctx, int idx, Object newValue,, +			Class<?> arrayComponentType) throws EvaluationException {, +, +					TypeDescriptor.valueOf(arrayComponentType));, +, +	private class ArrayIndexingValueRef implements ValueRef {, +, +		private final TypeConverter typeConverter;, +, +		private final Object array;, +, +		private final int index;, +, +		private final TypeDescriptor typeDescriptor;, +, +, +		ArrayIndexingValueRef(TypeConverter typeConverter, Object array, int index, TypeDescriptor typeDescriptor) {, +			this.typeConverter = typeConverter;, +			this.array = array;, +			this.index = index;, +			this.typeDescriptor = typeDescriptor;, +		}, +, +, +		@Override, +		public TypedValue getValue() {, +			Object arrayElement = accessArrayElement(this.array, this.index);, +			return new TypedValue(arrayElement, this.typeDescriptor.elementTypeDescriptor(arrayElement));, +		}, +, +		@Override, +		public void setValue(Object newValue) {, +			setArrayElement(this.typeConverter, this.array, this.index, newValue,, +					this.typeDescriptor.getElementTypeDescriptor().getType());, +		}, +, +		@Override, +		public boolean isWritable() {, +			return true;, +		}, +	}, +, +, +	@SuppressWarnings({"rawtypes", "unchecked"}), +	private static class MapIndexingValueRef implements ValueRef {, +, +		private final TypeConverter typeConverter;, +, +		private final Map map;, +, +		private final Object key;, +, +		private final TypeDescriptor mapEntryTypeDescriptor;, +, +		public MapIndexingValueRef(TypeConverter typeConverter, Map map, Object key, TypeDescriptor mapEntryTypeDescriptor) {, +			this.typeConverter = typeConverter;, +			this.map = map;, +			this.key = key;, +			this.mapEntryTypeDescriptor = mapEntryTypeDescriptor;, +		}, +, +		@Override, +		public TypedValue getValue() {, +			Object value = this.map.get(this.key);, +			return new TypedValue(value,, +					this.mapEntryTypeDescriptor.getMapValueTypeDescriptor(value));, +		}, +, +		@Override]