[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +				String attributeOverrideName = AnnotationUtils.getAttributeOverrideName(attributeMethod, targetAnnotationType);, +				if (attributeOverrideName != null) {, +					if (attributes.containsKey(attributeOverrideName)) {, +						overrideAttribute(element, annotation, attributes, attributeName, attributeOverrideName);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +				String attributeOverrideName = AnnotationUtils.getAttributeOverrideName(attributeMethod, targetAnnotationType);, +				if (attributeOverrideName != null) {, +					if (attributes.containsKey(attributeOverrideName)) {, +						overrideAttribute(element, annotation, attributes, attributeName, attributeOverrideName);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +	private static final Map<Method, AliasDescriptor> aliasDescriptorCache =, +			new ConcurrentReferenceHashMap<Method, AliasDescriptor>(256);, +, +			List<String> aliasNames = getAttributeAliasNames(attribute);, +			if (!getAttributeAliasNames(attribute).isEmpty()) {, +	 * @see #getAttributeOverrideName(Method, Class), +	static List<String> getAttributeAliasNames(Method attribute) {, +		Assert.notNull(attribute, "attribute must not be null");, +, +		AliasDescriptor descriptor = AliasDescriptor.from(attribute);, +		return (descriptor == null ? Collections.emptyList() : descriptor.getAttributeAliasNames());, +	 * Get the name of the overridden attribute configured via, +	 * @param attribute the attribute from which to retrieve the override;, +	 * never {@code null}, +	 * @param metaAnnotationType the type of meta-annotation in which the, +	 * overridden attribute is allowed to be declared, +	 * @return the name of the overridden attribute, or {@code null} if not, +	 * found or not applicable for the specified meta-annotation type, +	 * type is {@code null} or {@link Annotation}, +	static String getAttributeOverrideName(Method attribute, Class<? extends Annotation> metaAnnotationType) {, +		Assert.notNull(attribute, "attribute must not be null");, +		Assert.notNull(metaAnnotationType, "metaAnnotationType must not be null");, +		return (descriptor == null ? null : descriptor.getAttributeOverrideName(metaAnnotationType));, +	 * @see #from, +	 * @see #getAttributeAliasNames, +	 * @see #getAttributeOverrideName, +		private final Method aliasedAttribute;, +, +		 * Create an {@code AliasDescriptor} <em>from</em> the declaration, +		 * @return an alias descriptor, or {@code null} if the attribute, +		 * @see #validateAgainst, +			AliasDescriptor descriptor = aliasDescriptorCache.get(attribute);, +			if (descriptor != null) {, +				return descriptor;, +			}, +, +			descriptor = new AliasDescriptor(attribute, aliasFor);, +			aliasDescriptorCache.put(attribute, descriptor);, +			Assert.isTrue(declaringClass.isAnnotation(), "sourceAttribute must be from an annotation");, +, +			try {, +				this.aliasedAttribute = this.aliasedAnnotationType.getDeclaredMethod(this.aliasedAttributeName);, +			}, +			catch (NoSuchMethodException ex) {, +				String msg = String.format(, +					"Attribute [%s] in annotation [%s] is declared as an @AliasFor nonexistent attribute [%s] in annotation [%s].",, +					this.sourceAttributeName, this.sourceAnnotationType.getName(), this.aliasedAttributeName,, +					this.aliasedAnnotationType.getName());, +				throw new AnnotationConfigurationException(msg, ex);, +			}, +, +				AliasFor mirrorAliasFor = this.aliasedAttribute.getAnnotation(AliasFor.class);, +				String mirrorAliasedAttributeName = getAliasedAttributeName(mirrorAliasFor, this.aliasedAttribute);, +			Class<?> aliasedReturnType = this.aliasedAttribute.getReturnType();, +				validateDefaultValueConfiguration(this.aliasedAttribute);, +		 * are validated when they are created., +		private void validateAgainst(AliasDescriptor otherDescriptor) {, +		 * Determine if this descriptor represents an explicit override for, +		 * an attribute in the supplied {@code metaAnnotationType}., +		 * @see #isAliasFor, +		private boolean isOverrideFor(Class<? extends Annotation> metaAnnotationType) {, +			return this.aliasedAnnotationType.equals(metaAnnotationType);, +		 * Determine if this descriptor and the supplied descriptor both, +		 * effectively represent aliases for the same attribute in the same, +		 * target annotation, either explicitly or implicitly., +		 * <p>This method searches the attribute override hierarchy, beginning, +		 * with this descriptor, in order to detect implicit and transitively, +		 * implicit aliases., +		 * @return {@code true} if this descriptor and the supplied descriptor, +		 * effectively alias the same annotation attribute, +		 * @see #isOverrideFor, +		private boolean isAliasFor(AliasDescriptor otherDescriptor) {, +			for (AliasDescriptor lhs = this; lhs != null; lhs = lhs.getAttributeOverrideDescriptor()) {, +				for (AliasDescriptor rhs = otherDescriptor; rhs != null; rhs = rhs.getAttributeOverrideDescriptor()) {, +					if (lhs.aliasedAttribute.equals(rhs.aliasedAttribute)) {, +				}, +			}, +		public List<String> getAttributeAliasNames() {, +			// Explicit alias pair?, +			if (this.isAliasPair) {, +				return Collections.singletonList(this.aliasedAttributeName);, +			// Else: search for implicit aliases, +			List<String> aliases = new ArrayList<String>();, +			for (AliasDescriptor otherDescriptor : getOtherDescriptors()) {, +				if (this.isAliasFor(otherDescriptor)) {, +					this.validateAgainst(otherDescriptor);, +					aliases.add(otherDescriptor.sourceAttributeName);, +				}, +			}]