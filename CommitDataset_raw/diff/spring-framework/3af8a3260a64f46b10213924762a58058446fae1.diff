[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())));, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())));, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +		if (accessorsToTry != null) {, +			for (PropertyAccessor accessor : accessorsToTry) {, +					if (accessor.canWrite(eContext, contextObject.getValue(), name)) {, +	 * @param contextObject the object upon which property access is being attempted, +	private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {, +		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null);, +, +			if (targets == null) {, +				// generic resolver that says it can be used for any type, +			else if (targetType != null) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())));, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())));, +		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors());, +		if (accessorsToTry != null) {, +			for (PropertyAccessor accessor : accessorsToTry) {, +					if (accessor.canWrite(eContext, contextObject.getValue(), name)) {, +	 * @param contextObject the object upon which property access is being attempted, +	private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {, +		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null);, +, +			if (targets == null) {, +				// generic resolver that says it can be used for any type, +			else if (targetType != null) {, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java, +		public Class<?>[] getSpecificTargetClasses() {, +			return new Class<?>[] {Map.class};, +		}, +, +		@Override, +		Spr10486 rootObject = new Spr10486();, +		assertThat(classNameExpression.getValue(context, rootObject), equalTo((Object) Spr10486.class.getName()));, +		Spr11142 rootObject = new Spr11142();, +	@Test, +	public void SPR11609() {, +		StandardEvaluationContext sec = new StandardEvaluationContext();, +		sec.addPropertyAccessor(new MapAccessor());, +		Expression exp = new SpelExpressionParser().parseExpression(, +				"T(org.springframework.expression.spel.SpelReproTests$MapWithConstant).X");, +		assertEquals(1, exp.getValue(sec));, +	}, +, +	public static class Spr10486 {, +	static class Spr11142 {, +, +	static class Spr11445Class implements BeanResolver {, +, +		private final AtomicInteger counter = new AtomicInteger();, +, +		public int echo(int invocation) {, +			return invocation;, +		}, +, +		public int parameter() {, +			return counter.incrementAndGet();, +		}, +, +		@Override, +		public Object resolve(EvaluationContext context, String beanName) throws AccessException {, +			return beanName.equals("bean") ? this : null;, +		}, +	}, +, +, +	public static class MapWithConstant extends HashMap {, +, +		public static final int X = 1;, +	}, +]