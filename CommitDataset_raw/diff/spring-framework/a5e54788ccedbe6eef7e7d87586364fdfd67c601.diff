[+++ /dev/null, +++ /dev/null, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathPatternRegistry.java, +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +++ /dev/null, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathPatternRegistry.java, +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/PatternsRequestCondition.java, +import java.util.stream.Stream;, +import org.springframework.http.server.reactive.PathContainer;, +	private final Set<PathPattern> patterns;, +, +		this(patterns, null);, +		this(Arrays.asList(patterns), patternParser);, +	private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser) {, +		this.parser = (parser != null ? parser : new PathPatternParser());, +		this.patterns = toSortedSet(patterns.stream().map(pattern -> parse(pattern, this.parser)));, +	}, +, +	private static PathPattern parse(String pattern, PathPatternParser parser) {, +		return parser.parse(pattern);, +	}, +, +	private static Set<PathPattern> toSortedSet(Stream<PathPattern> stream) {, +		Set<PathPattern> result = stream.sorted().collect(Collectors.toCollection(TreeSet::new));, +		return Collections.unmodifiableSet(result);, +		this.patterns = toSortedSet(patterns.stream());, +		return this.patterns;, +	 * that is guaranteed to contain matching patterns, sorted., +		SortedSet<PathPattern> matches = getMatchingPatterns(exchange);, +		return matches.isEmpty() ? null :, +				new PatternsRequestCondition(new ArrayList<PathPattern>(matches), this.parser);, +	 * @param exchange the current exchange, +	private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {, +		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication();, +				.collect(Collectors.toCollection(TreeSet::new));, +	 * Patterns are compared one at a time, from top to bottom. If all compared, +		Iterator<PathPattern> iterator = this.patterns.iterator();, +		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator();, +			int result = iterator.next().compareTo(iteratorOther.next());, +++ /dev/null, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathPatternRegistry.java, +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/PatternsRequestCondition.java, +import java.util.stream.Stream;, +import org.springframework.http.server.reactive.PathContainer;, +	private final Set<PathPattern> patterns;, +, +		this(patterns, null);, +		this(Arrays.asList(patterns), patternParser);, +	private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser) {, +		this.parser = (parser != null ? parser : new PathPatternParser());, +		this.patterns = toSortedSet(patterns.stream().map(pattern -> parse(pattern, this.parser)));, +	}, +, +	private static PathPattern parse(String pattern, PathPatternParser parser) {, +		return parser.parse(pattern);, +	}, +, +	private static Set<PathPattern> toSortedSet(Stream<PathPattern> stream) {, +		Set<PathPattern> result = stream.sorted().collect(Collectors.toCollection(TreeSet::new));, +		return Collections.unmodifiableSet(result);, +		this.patterns = toSortedSet(patterns.stream());, +		return this.patterns;, +	 * that is guaranteed to contain matching patterns, sorted., +		SortedSet<PathPattern> matches = getMatchingPatterns(exchange);, +		return matches.isEmpty() ? null :, +				new PatternsRequestCondition(new ArrayList<PathPattern>(matches), this.parser);, +	 * @param exchange the current exchange, +	private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {, +		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication();, +				.collect(Collectors.toCollection(TreeSet::new));, +	 * Patterns are compared one at a time, from top to bottom. If all compared, +		Iterator<PathPattern> iterator = this.patterns.iterator();, +		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator();, +			int result = iterator.next().compareTo(iteratorOther.next());, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/AbstractHandlerMethodMapping.java, +	 * @see #handleMatch(Object, HandlerMethod, String, ServerWebExchange), +++ /dev/null, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathPatternRegistry.java, +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/PatternsRequestCondition.java, +import java.util.stream.Stream;, +import org.springframework.http.server.reactive.PathContainer;, +	private final Set<PathPattern> patterns;, +, +		this(patterns, null);, +		this(Arrays.asList(patterns), patternParser);, +	private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser) {, +		this.parser = (parser != null ? parser : new PathPatternParser());, +		this.patterns = toSortedSet(patterns.stream().map(pattern -> parse(pattern, this.parser)));, +	}, +, +	private static PathPattern parse(String pattern, PathPatternParser parser) {, +		return parser.parse(pattern);, +	}]