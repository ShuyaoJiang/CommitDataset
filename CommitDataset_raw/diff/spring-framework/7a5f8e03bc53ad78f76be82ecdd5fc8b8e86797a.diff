[+++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java, +	private final AtomicBoolean rejectSubscribers = new AtomicBoolean();, +				.doOnSubscribe(s -> {, +					if (this.rejectSubscribers.get()) {, +						throw new IllegalStateException("The client response body can only be consumed once.");, +					}, +				}), +				.doOnCancel(() -> {, +					// https://github.com/reactor/reactor-netty/issues/503, +					// FluxReceive rejects multiple subscribers, but not after a cancel()., +					// Subsequent subscribers after cancel() will not be rejected, but will hang instead., +					// So we need to intercept and reject them in that case., +					this.rejectSubscribers.set(true);, +				}), +++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java, +	private final AtomicBoolean rejectSubscribers = new AtomicBoolean();, +				.doOnSubscribe(s -> {, +					if (this.rejectSubscribers.get()) {, +						throw new IllegalStateException("The client response body can only be consumed once.");, +					}, +				}), +				.doOnCancel(() -> {, +					// https://github.com/reactor/reactor-netty/issues/503, +					// FluxReceive rejects multiple subscribers, but not after a cancel()., +					// Subsequent subscribers after cancel() will not be rejected, but will hang instead., +					// So we need to intercept and reject them in that case., +					this.rejectSubscribers.set(true);, +				}), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, +			// but ignore exception, in case the handler did consume., +			return (Mono<T>) response.bodyToMono(Void.class), +					.onErrorResume(ex2 -> Mono.empty()).thenReturn(ex);]