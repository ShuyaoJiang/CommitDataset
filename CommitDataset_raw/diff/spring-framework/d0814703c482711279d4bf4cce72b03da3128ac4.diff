[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +				if (ann.annotationType() == annotationType) {, +				if (ann.annotationType() == annotationType) {, +				if (ann.annotationType() == annotationType) {, +		if (annotation instanceof SynthesizedAnnotation || (Proxy.isProxyClass(annotation.getClass()) &&, +				Proxy.getInvocationHandler(annotation) instanceof SynthesizedAnnotationInvocationHandler)) {, +		Class<?>[] exposedInterfaces = (canExposeSynthesizedMarker(annotationType) ?, +				new Class<?>[] {annotationType, SynthesizedAnnotation.class} : new Class<?>[] {annotationType});, +		return (A) Proxy.newProxyInstance(annotation.getClass().getClassLoader(), exposedInterfaces, handler);, +		Class<?>[] exposedInterfaces = (canExposeSynthesizedMarker(annotationType) ?, +				new Class<?>[] {annotationType, SynthesizedAnnotation.class} : new Class<?>[] {annotationType});, +		return (A) Proxy.newProxyInstance(annotationType.getClassLoader(), exposedInterfaces, handler);, +	 * Check whether we can expose our {@link SynthesizedAnnotation} marker for the given annotation type., +	 * @param annotationType the annotation type that we are about to create a synthesized proxy for, +	 */, +	private static boolean canExposeSynthesizedMarker(Class<? extends Annotation> annotationType) {, +		try {, +			return (Class.forName(SynthesizedAnnotation.class.getName(), false, annotationType.getClassLoader()) ==, +					SynthesizedAnnotation.class);, +		}, +		catch (ClassNotFoundException ex) {, +			return false;, +		}, +	}, +, +	/**, +		Assert.isTrue(Annotation.class != metaAnnotationType,, +			this.aliasedAnnotationType = (Annotation.class == aliasFor.annotation() ?, +			this.isAliasPair = (this.sourceAnnotationType == this.aliasedAnnotationType);, +			if (returnType != aliasedReturnType) {, +			return (this.aliasedAnnotationType == metaAnnotationType);, +			Assert.isTrue(Annotation.class != metaAnnotationType,, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +				if (ann.annotationType() == annotationType) {, +				if (ann.annotationType() == annotationType) {, +				if (ann.annotationType() == annotationType) {, +		if (annotation instanceof SynthesizedAnnotation || (Proxy.isProxyClass(annotation.getClass()) &&, +				Proxy.getInvocationHandler(annotation) instanceof SynthesizedAnnotationInvocationHandler)) {, +		Class<?>[] exposedInterfaces = (canExposeSynthesizedMarker(annotationType) ?, +				new Class<?>[] {annotationType, SynthesizedAnnotation.class} : new Class<?>[] {annotationType});, +		return (A) Proxy.newProxyInstance(annotation.getClass().getClassLoader(), exposedInterfaces, handler);, +		Class<?>[] exposedInterfaces = (canExposeSynthesizedMarker(annotationType) ?, +				new Class<?>[] {annotationType, SynthesizedAnnotation.class} : new Class<?>[] {annotationType});, +		return (A) Proxy.newProxyInstance(annotationType.getClassLoader(), exposedInterfaces, handler);, +	 * Check whether we can expose our {@link SynthesizedAnnotation} marker for the given annotation type., +	 * @param annotationType the annotation type that we are about to create a synthesized proxy for, +	 */, +	private static boolean canExposeSynthesizedMarker(Class<? extends Annotation> annotationType) {, +		try {, +			return (Class.forName(SynthesizedAnnotation.class.getName(), false, annotationType.getClassLoader()) ==, +					SynthesizedAnnotation.class);, +		}, +		catch (ClassNotFoundException ex) {, +			return false;, +		}, +	}, +, +	/**, +		Assert.isTrue(Annotation.class != metaAnnotationType,, +			this.aliasedAnnotationType = (Annotation.class == aliasFor.annotation() ?, +			this.isAliasPair = (this.sourceAnnotationType == this.aliasedAnnotationType);, +			if (returnType != aliasedReturnType) {, +			return (this.aliasedAnnotationType == metaAnnotationType);, +			Assert.isTrue(Annotation.class != metaAnnotationType,, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotatedElementUtilsTests.java, +import java.lang.reflect.Constructor;, +import java.util.Date;, +import javax.annotation.Resource;, +	@Test, +	public void javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {, +		Constructor<?> deprecatedCtor = Date.class.getConstructor(String.class);, +		assertEquals(deprecatedCtor.getAnnotation(Deprecated.class), findMergedAnnotation(deprecatedCtor, Deprecated.class));, +		assertEquals(Date.class.getAnnotation(Deprecated.class), findMergedAnnotation(Date.class, Deprecated.class));, +	}, +, +	@Test, +	public void javaxAnnotationTypeViaFindMergedAnnotation() throws Exception {, +		assertEquals(ResourceHolder.class.getAnnotation(Resource.class), findMergedAnnotation(ResourceHolder.class, Resource.class));, +		assertEquals(SpringAppConfigClass.class.getAnnotation(Resource.class), findMergedAnnotation(SpringAppConfigClass.class, Resource.class));, +	}, +, +	public interface GenericParameter<T> {, +	public interface InheritedAnnotationInterface {, +	public interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {, +	public interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {, +	public interface NonInheritedAnnotationInterface {, +	public interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {, +	public interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {, +	@Resource(name = "x"), +	static class ResourceHolder {, +	}, +]