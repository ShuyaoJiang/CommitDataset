[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.util.LinkedHashMap;, +import java.util.Map;, +import org.springframework.beans.factory.ListableBeanFactory;, + * Convenience methods performing bean lookups related to Spring-specific annotations,, + * for example Spring's {@link Qualifier @Qualifier} annotation., +	 * Retrieve all bean of type {@code T} from the given {@code BeanFactory} declaring a, +	 * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given, +	 * qualifier, or having a bean name matching the given qualifier., +	 * @param beanFactory the factory to get the target beans from (also searching ancestors), +	 * @param beanType the type of beans to retrieve, +	 * @param qualifier the qualifier for selecting among all type matches, +	 * @return the matching beans of type {@code T}, +	 * @throws BeansException if any of the matching beans could not be created, +	 * @since 5.1.1, +	 * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class), +	 */, +	public static <T> Map<String, T> qualifiedBeansOfType(, +			ListableBeanFactory beanFactory, Class<T> beanType, String qualifier) throws BeansException {, +, +		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);, +		Map<String, T> result = new LinkedHashMap<>(4);, +		for (String beanName : candidateBeans) {, +			if (isQualifierMatch(qualifier::equals, beanName, beanFactory)) {, +				result.put(beanName, beanFactory.getBean(beanName, beanType));, +			}, +		}, +		return result;, +	}, +, +	/**, +	 * @param beanFactory the factory to get the target bean from (also searching ancestors), +	 * @see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class), +		if (beanFactory instanceof ListableBeanFactory) {, +			return qualifiedBeanOfType((ListableBeanFactory) beanFactory, beanType, qualifier);, +	 * @param bf the factory to get the target bean from, +	private static <T> T qualifiedBeanOfType(ListableBeanFactory bf, Class<T> beanType, String qualifier) {, +	 * @param beanFactory the factory from which to retrieve the named bean, +	public static boolean isQualifierMatch(, +			Predicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory) {, +				Class<?> beanType = beanFactory.getType(beanName);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.util.LinkedHashMap;, +import java.util.Map;, +import org.springframework.beans.factory.ListableBeanFactory;, + * Convenience methods performing bean lookups related to Spring-specific annotations,, + * for example Spring's {@link Qualifier @Qualifier} annotation., +	 * Retrieve all bean of type {@code T} from the given {@code BeanFactory} declaring a, +	 * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given, +	 * qualifier, or having a bean name matching the given qualifier., +	 * @param beanFactory the factory to get the target beans from (also searching ancestors), +	 * @param beanType the type of beans to retrieve, +	 * @param qualifier the qualifier for selecting among all type matches, +	 * @return the matching beans of type {@code T}, +	 * @throws BeansException if any of the matching beans could not be created, +	 * @since 5.1.1, +	 * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class), +	 */, +	public static <T> Map<String, T> qualifiedBeansOfType(, +			ListableBeanFactory beanFactory, Class<T> beanType, String qualifier) throws BeansException {, +, +		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);, +		Map<String, T> result = new LinkedHashMap<>(4);, +		for (String beanName : candidateBeans) {, +			if (isQualifierMatch(qualifier::equals, beanName, beanFactory)) {, +				result.put(beanName, beanFactory.getBean(beanName, beanType));, +			}, +		}, +		return result;, +	}, +, +	/**, +	 * @param beanFactory the factory to get the target bean from (also searching ancestors), +	 * @see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class), +		if (beanFactory instanceof ListableBeanFactory) {, +			return qualifiedBeanOfType((ListableBeanFactory) beanFactory, beanType, qualifier);, +	 * @param bf the factory to get the target bean from, +	private static <T> T qualifiedBeanOfType(ListableBeanFactory bf, Class<T> beanType, String qualifier) {, +	 * @param beanFactory the factory from which to retrieve the named bean, +	public static boolean isQualifierMatch(, +			Predicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory) {, +				Class<?> beanType = beanFactory.getType(beanName);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +		if (uniqueCandidate != null) {, +			synchronized (mbd.constructorArgumentLock) {, +				mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;, +			}, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.util.LinkedHashMap;, +import java.util.Map;, +import org.springframework.beans.factory.ListableBeanFactory;, + * Convenience methods performing bean lookups related to Spring-specific annotations,, + * for example Spring's {@link Qualifier @Qualifier} annotation., +	 * Retrieve all bean of type {@code T} from the given {@code BeanFactory} declaring a, +	 * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given, +	 * qualifier, or having a bean name matching the given qualifier.]