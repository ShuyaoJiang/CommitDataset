[+++ b/src/asciidoc/core-beans.adoc, +The Spring IoC container manages not only the instantiation of your objects (beans),, +but also the wiring up of collaborators (or dependencies). If you want to inject (for, +example) an HTTP request scoped bean into another bean of a longer-lived scope, you may, +choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject, +a proxy object that exposes the same public interface as the scoped object but that can, +also retrieve the real target object from the relevant scope (such as an HTTP request), +and delegate method calls onto the real object., +You may also use `<aop:scoped-proxy/>` between beans that are scoped as `singleton`,, +with the reference then going through an intermediate proxy that is serializable, +and therefore able to re-obtain the target singleton bean on deserialization., +, +When declaring `<aop:scoped-proxy/>` against a bean of scope `prototype`, every method, +call on the shared proxy will lead to the creation of a new target instance which the, +call is then being forwarded to., +, +Also, scoped proxies are not the only way to access beans from shorter scopes in a, +lifecycle-safe fashion. You may also simply declare your injection point (i.e. the, +constructor/setter argument or autowired field) as `ObjectFactory<MyTargetBean>`,, +allowing for a `getObject()` call to retrieve the current instance on demand every, +time it is needed - without holding on to the instance or storing it separately., +, +The JSR-330 variant of this is called `Provider`, used with a `Provider<MyTargetBean>`, +declaration and a corresponding `get()` call for every retrieval attempt., +See <<beans-standard-annotations,here>> for more details on JSR-330 overall., +, +, +JSR 330's `@Inject` annotation can be used in place of Spring's `@Autowired` annotation, +in the examples below. See <<beans-standard-annotations,here>> for more details., +		public void listMovies() {, +			this.movieFinder.findMovies(...);, +			..., +		}, +As with `@Autowired`, it is possible to use `@Inject` at the field level, method level, +and constructor-argument level. Furthermore, you may declare your injection point as a, +`Provider`, allowing for on-demand access to beans of shorter scopes or lazy access to, +other beans through a `Provider.get()` call. As a variant of the example above:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	import javax.inject.Inject;, +	import javax.inject.Provider;, +, +	public class SimpleMovieLister {, +, +		private Provider<MovieFinder> movieFinder;, +, +		public void listMovies() {, +			this.movieFinder.get().findMovies(...);, +			..., +		}, +	}, +----, +, +If you would like to use a qualified name for the dependency that should be injected,, +you should use the `@Named` annotation as follows:, +It is very common to use `@Component` without specifying a name for the component., +`@Named` can be used in a similar fashion:, +.Spring component model elements vs. JSR-330 variants, +| `@Inject` has no 'required' attribute; can be used with Java 8's `Optional` instead., +| JSR-330 does not provide a composable model, just a way to identify named components., +  you should use Spring's `@Scope` annotation. `javax.inject` also provides a, +| @Qualifier / @Named, +| `javax.inject.Qualifier` is just a meta-annotation for building custom qualifiers., +  Concrete String qualifiers (like Spring's `@Qualifier` with a value) can be associated, +  through `javax.inject.Named`., +, +| ObjectFactory, +| Provider, +| `javax.inject.Provider` is a direct alternative to Spring's `ObjectFactory`,, +  just with a shorter `get()` method name. It can also be used in combination with, +  Spring's `@Autowired` or with non-annotated constructors and setter methods.]