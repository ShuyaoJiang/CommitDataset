[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncResult.java, + * Copyright 2002-2017 the original author or authors., +import java.util.concurrent.CompletableFuture;, +	private final Throwable executionException;, +	private AsyncResult(@Nullable V value, @Nullable Throwable ex) {, +			throw (this.executionException instanceof ExecutionException ?, +					(ExecutionException) this.executionException :, +					new ExecutionException(this.executionException));, +				failureCallback.onFailure(exposedException(this.executionException));, +	@Override, +	public CompletableFuture<V> completable() {, +		if (this.executionException != null) {, +			CompletableFuture<V> completable = new CompletableFuture<>();, +			completable.completeExceptionally(exposedException(this.executionException));, +			return completable;, +		}, +		else {, +			return CompletableFuture.completedFuture(this.value);, +		}, +	}, +, +		return new AsyncResult<>(null, ex);, +	}, +, +	/**, +	 * Determine the exposed exception: either the cause of a given, +	 * {@link ExecutionException}, or the original exception as-is., +	 * @param original the original as given to {@link #forExecutionException}, +	 * @return the exposed exception, +	 */, +	private static Throwable exposedException(Throwable original) {, +		if (original instanceof ExecutionException) {, +			Throwable cause = original.getCause();, +			if (cause != null) {, +				return cause;, +			}, +		}, +		return original;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncResult.java, + * Copyright 2002-2017 the original author or authors., +import java.util.concurrent.CompletableFuture;, +	private final Throwable executionException;, +	private AsyncResult(@Nullable V value, @Nullable Throwable ex) {, +			throw (this.executionException instanceof ExecutionException ?, +					(ExecutionException) this.executionException :, +					new ExecutionException(this.executionException));, +				failureCallback.onFailure(exposedException(this.executionException));, +	@Override, +	public CompletableFuture<V> completable() {, +		if (this.executionException != null) {, +			CompletableFuture<V> completable = new CompletableFuture<>();, +			completable.completeExceptionally(exposedException(this.executionException));, +			return completable;, +		}, +		else {, +			return CompletableFuture.completedFuture(this.value);, +		}, +	}, +, +		return new AsyncResult<>(null, ex);, +	}, +, +	/**, +	 * Determine the exposed exception: either the cause of a given, +	 * {@link ExecutionException}, or the original exception as-is., +	 * @param original the original as given to {@link #forExecutionException}, +	 * @return the exposed exception, +	 */, +	private static Throwable exposedException(Throwable original) {, +		if (original instanceof ExecutionException) {, +			Throwable cause = original.getCause();, +			if (cause != null) {, +				return cause;, +			}, +		}, +		return original;, +++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncResultTests.java, + * Copyright 2002-2017 the original author or authors., +import java.util.concurrent.ExecutionException;, +	public void asyncResultWithCallbackAndValue() throws Exception {, +		assertSame(value, future.get());, +		assertSame(value, future.completable().get());, +		future.completable().thenAccept(v -> assertSame(value, v));, +	public void asyncResultWithCallbackAndException() throws Exception {, +		try {, +			future.get();, +			fail("Should have thrown ExecutionException");, +		}, +		catch (ExecutionException ex2) {, +			assertSame(ex, ex2.getCause());, +		}, +		try {, +			future.completable().get();, +			fail("Should have thrown ExecutionException");]