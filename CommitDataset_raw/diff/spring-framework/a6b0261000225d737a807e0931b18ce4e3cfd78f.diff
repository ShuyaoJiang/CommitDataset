[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +			Method resolvedFactoryMethod = bd.getResolvedFactoryMethod();, +			if (resolvedFactoryMethod != null) {, +				targetAnnotation = AnnotationUtils.getAnnotation(resolvedFactoryMethod, type);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +			Method resolvedFactoryMethod = bd.getResolvedFactoryMethod();, +			if (resolvedFactoryMethod != null) {, +				targetAnnotation = AnnotationUtils.getAnnotation(resolvedFactoryMethod, type);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +import java.lang.reflect.TypeVariable;, +	protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +	protected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +		Class<?> preResolved = mbd.resolvedFactoryMethodReturnType;, +		if (preResolved != null) {, +			return preResolved;, +		}, +, +		boolean cache = false;, +				TypeVariable<Method>[] declaredTypeVariables = factoryMethod.getTypeParameters();, +				// No declared type variables to inspect, so just process the standard return type., +				if (declaredTypeVariables.length > 0) {, +					// Fully resolve parameter names and argument values., +						cache = true;, +				else {, +					returnTypes.add(factoryMethod.getReturnType());, +				}, +			}, +			Class<?> result = returnTypes.iterator().next();, +			if (cache) {, +				mbd.resolvedFactoryMethodReturnType = result;, +			}, +			return result;, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +			Method resolvedFactoryMethod = bd.getResolvedFactoryMethod();, +			if (resolvedFactoryMethod != null) {, +				targetAnnotation = AnnotationUtils.getAnnotation(resolvedFactoryMethod, type);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +import java.lang.reflect.TypeVariable;, +	protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +	protected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +		Class<?> preResolved = mbd.resolvedFactoryMethodReturnType;, +		if (preResolved != null) {, +			return preResolved;, +		}, +, +		boolean cache = false;, +				TypeVariable<Method>[] declaredTypeVariables = factoryMethod.getTypeParameters();, +				// No declared type variables to inspect, so just process the standard return type., +				if (declaredTypeVariables.length > 0) {, +					// Fully resolve parameter names and argument values., +						cache = true;, +				else {, +					returnTypes.add(factoryMethod.getReturnType());, +				}, +			}, +			Class<?> result = returnTypes.iterator().next();, +			if (cache) {, +				mbd.resolvedFactoryMethodReturnType = result;, +			}, +			return result;, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AutowireUtils.java, +		Assert.isTrue(args.length == methodArgumentTypes.length, "Argument array does not match parameter count");, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +			Method resolvedFactoryMethod = bd.getResolvedFactoryMethod();, +			if (resolvedFactoryMethod != null) {, +				targetAnnotation = AnnotationUtils.getAnnotation(resolvedFactoryMethod, type);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +import java.lang.reflect.TypeVariable;, +	protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +	protected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {, +		Class<?> preResolved = mbd.resolvedFactoryMethodReturnType;, +		if (preResolved != null) {, +			return preResolved;, +		}, +, +		boolean cache = false;, +				TypeVariable<Method>[] declaredTypeVariables = factoryMethod.getTypeParameters();, +				// No declared type variables to inspect, so just process the standard return type., +				if (declaredTypeVariables.length > 0) {, +					// Fully resolve parameter names and argument values., +						cache = true;, +				else {, +					returnTypes.add(factoryMethod.getReturnType());, +				}, +			}, +			Class<?> result = returnTypes.iterator().next();, +			if (cache) {, +				mbd.resolvedFactoryMethodReturnType = result;, +			}, +			return result;, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AutowireUtils.java, +		Assert.isTrue(args.length == methodArgumentTypes.length, "Argument array does not match parameter count");, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/GenericTypeAwareAutowireCandidateResolver.java, +import java.lang.reflect.Method;, +, +		if (dependencyType.getType() instanceof Class) {, +		if (rbd != null && rbd.getFactoryMethodName() != null) {, +			Class<?> preResolved = rbd.resolvedFactoryMethodReturnType;, +			if (preResolved != null) {, +				targetType = ResolvableType.forClass(preResolved);]