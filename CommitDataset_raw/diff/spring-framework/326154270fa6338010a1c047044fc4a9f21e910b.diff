[+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private static final int CACHE_TURNOFF_THRESHOLD = 65536;, +, +	private String pathSeparator = DEFAULT_PATH_SEPARATOR;, +	private volatile Boolean cachePatterns;, +	final Map<String, AntPathStringMatcher> stringMatcherCache =, +			new ConcurrentHashMap<String, AntPathStringMatcher>(256);, +, +, +	/**, +	 * Set the path separator to use for pattern parsing., +	 * Default is "/", as in Ant., +	 */, +	/**, +	 * Specify whether to trim tokenized paths and patterns., +	 * Default is {@code true}., +	 */, +	/**, +	 * Specify whether to cache parsed pattern metadata for patterns passed, +	 * into this matcher's {@link #match} method. A value of {@code true}, +	 * activates an unlimited pattern cache; a value of {@code false} turns, +	 * the pattern cache off completely., +	 * <p>Default is for the cache to be on, but with the variant to automatically, +	 * turn it off when encountering too many patterns to cache at runtime, +	 * (the threshold is 65536), assuming that arbitrary permutations of patterns, +	 * are coming in, with little chance for encountering a reoccurring pattern., +	 * @see #getStringMatcher(String), +	 */, +	public void setCachePatterns(boolean cachePatterns) {, +		this.cachePatterns = cachePatterns;, +	}, +, +, +	protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {, +			String pattDir = pattDirs[pattIdxStart];, +			if ("**".equals(pattDir)) {, +			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {, +			String pattDir = pattDirs[pattIdxEnd];, +			if (pattDir.equals("**")) {, +			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {, +	 * Tests whether or not a string matches against a pattern., +	 * @param pattern the pattern to match against (never {@code null}), +	 * @param str the String which must be matched against the pattern (never {@code null}), +	 * @return {@code true} if the string matches against the pattern, or {@code false} otherwise, +		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables);, +	}, +, +	/**, +	 * Build or retrieve an {@link AntPathStringMatcher} for the given pattern., +	 * <p>The default implementation checks this AntPathMatcher's internal cache, +	 * (see {@link #setCachePatterns}, creating a new AntPathStringMatcher instance, +	 * through {@link AntPathStringMatcher#AntPathStringMatcher(String)} if none found., +	 * When encountering too many patterns to cache at runtime (the threshold is 65536),, +	 * it turns the default cache off, assuming that arbitrary permutations of patterns, +	 * are coming in, with little chance for encountering a reoccurring pattern., +	 * <p>This method may get overridden to implement a custom cache strategy., +	 * @param pattern the pattern to match against (never {@code null}), +	 * @return a corresponding AntPathStringMatcher (never {@code null}), +	 * @see #setCachePatterns, +	 */, +	protected AntPathStringMatcher getStringMatcher(String pattern) {, +		AntPathStringMatcher matcher = null;, +		Boolean cachePatterns = this.cachePatterns;, +		if (cachePatterns == null || cachePatterns.booleanValue()) {, +			matcher = this.stringMatcherCache.get(pattern);, +		}, +			if (cachePatterns == null && this.stringMatcherCache.size() == CACHE_TURNOFF_THRESHOLD) {, +				// Try to adapt to the runtime situation that we're encountering:, +				// There are obviously too many different paths coming in here..., +				// So let's turn off the cache since the patterns are unlikely to be reoccurring., +				this.cachePatterns = false;, +				this.stringMatcherCache.clear();, +				return matcher;, +			}, +			if (cachePatterns == null || cachePatterns.booleanValue()) {, +		}, +		return matcher;, +	/**, +	 * Tests whether or not a string matches against a pattern via a {@link Pattern}., +	 * <p>The pattern may contain special characters: '*' means zero or more characters; '?' means one and, +	 * only one character; '{' and '}' indicate a URI template pattern. For example <tt>/users/{user}</tt>., +	 */, +	protected static class AntPathStringMatcher {, +, +		private static final Pattern GLOB_PATTERN = Pattern.compile("\\?|\\*|\\{((?:\\{[^/]+?\\}|[^/{}]|\\\\[{}])+?)\\}");, +, +		private static final String DEFAULT_VARIABLE_PATTERN = "(.*)";, +, +		private final Pattern pattern;, +, +		private final List<String> variableNames = new LinkedList<String>();, +, +		public AntPathStringMatcher(String pattern) {, +			StringBuilder patternBuilder = new StringBuilder();, +			Matcher m = GLOB_PATTERN.matcher(pattern);, +			int end = 0;, +			while (m.find()) {, +				patternBuilder.append(quote(pattern, end, m.start()));, +				String match = m.group();, +				if ("?".equals(match)) {]