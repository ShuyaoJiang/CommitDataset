[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/HandlerMapping.java, +	 * Name of the {@link HttpServletRequest} attribute that contains the, +	 * best matching pattern within the handler mapping., +	 * <p>Note: This attribute is not required to be supported by all, +	 * HandlerMapping implementations. URL-based HandlerMappings will, +	 * typically support it, but handlers should not necessarily expect, +	 * this request attribute to be present in all scenarios., +	 */, +	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";, +, +	/**, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/HandlerMapping.java, +	 * Name of the {@link HttpServletRequest} attribute that contains the, +	 * best matching pattern within the handler mapping., +	 * <p>Note: This attribute is not required to be supported by all, +	 * HandlerMapping implementations. URL-based HandlerMappings will, +	 * typically support it, but handlers should not necessarily expect, +	 * this request attribute to be present in all scenarios., +	 */, +	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";, +, +	/**, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/handler/AbstractUrlHandlerMapping.java, +				handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);, +			return buildPathExposingHandler(handler, urlPath, urlPath, null);, +		List<String> matchingPatterns = new ArrayList<String>();, +		for (String registeredPattern : this.handlerMap.keySet()) {, +			if (getPathMatcher().match(registeredPattern, urlPath)) {, +				matchingPatterns.add(registeredPattern);, +		String bestPatternMatch = null;, +		if (!matchingPatterns.isEmpty()) {, +			Collections.sort(matchingPatterns, getPathMatcher().getPatternComparator(urlPath));, +				logger.debug("Matching patterns for request [" + urlPath + "] are " + matchingPatterns);, +			bestPatternMatch = matchingPatterns.get(0);, +		if (bestPatternMatch != null) {, +			handler = this.handlerMap.get(bestPatternMatch);, +			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);, +					getPathMatcher().extractUriTemplateVariables(bestPatternMatch, urlPath);, +			return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);, +	protected Object buildPathExposingHandler(Object rawHandler,, +			String bestMatchingPattern,, +			String pathWithinMapping,, +			Map<String, String> uriTemplateVariables) {, +		chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));, +	protected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping, HttpServletRequest request) {, +		request.setAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);, +		private final String bestMatchingPattern;, +, +		private PathExposingHandlerInterceptor(String bestMatchingPattern, String pathWithinMapping) {, +			this.bestMatchingPattern = bestMatchingPattern;, +			exposePathWithinMapping(this.bestMatchingPattern, this.pathWithinMapping, request);, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/HandlerMapping.java, +	 * Name of the {@link HttpServletRequest} attribute that contains the, +	 * best matching pattern within the handler mapping., +	 * <p>Note: This attribute is not required to be supported by all, +	 * HandlerMapping implementations. URL-based HandlerMappings will, +	 * typically support it, but handlers should not necessarily expect, +	 * this request attribute to be present in all scenarios., +	 */, +	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";, +, +	/**, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/handler/AbstractUrlHandlerMapping.java, +				handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);, +			return buildPathExposingHandler(handler, urlPath, urlPath, null);, +		List<String> matchingPatterns = new ArrayList<String>();, +		for (String registeredPattern : this.handlerMap.keySet()) {, +			if (getPathMatcher().match(registeredPattern, urlPath)) {, +				matchingPatterns.add(registeredPattern);, +		String bestPatternMatch = null;, +		if (!matchingPatterns.isEmpty()) {, +			Collections.sort(matchingPatterns, getPathMatcher().getPatternComparator(urlPath));, +				logger.debug("Matching patterns for request [" + urlPath + "] are " + matchingPatterns);, +			bestPatternMatch = matchingPatterns.get(0);, +		if (bestPatternMatch != null) {, +			handler = this.handlerMap.get(bestPatternMatch);, +			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);, +					getPathMatcher().extractUriTemplateVariables(bestPatternMatch, urlPath);, +			return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);, +	protected Object buildPathExposingHandler(Object rawHandler,, +			String bestMatchingPattern,, +			String pathWithinMapping,, +			Map<String, String> uriTemplateVariables) {, +		chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));, +	protected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping, HttpServletRequest request) {, +		request.setAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);, +		private final String bestMatchingPattern;, +, +		private PathExposingHandlerInterceptor(String bestMatchingPattern, String pathWithinMapping) {, +			this.bestMatchingPattern = bestMatchingPattern;, +			exposePathWithinMapping(this.bestMatchingPattern, this.pathWithinMapping, request);, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +						String matchedPattern = getMatchedPattern(methodLevelPattern, lookupPath, request);, +		/**, +		 * Determines the matched pattern for the given methodLevelPattern and path., +		 *, +		 * <p>Uses the following algorithm:, +		 * <ol>, +		 * <li>If there is a type-level mapping with path information, it is, +		 * {@linkplain PathMatcher#combine(String, String) combined} with the method-level pattern.]