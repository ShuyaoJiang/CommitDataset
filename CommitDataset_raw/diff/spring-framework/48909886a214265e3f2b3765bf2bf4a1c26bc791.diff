[+++ b/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java, +	private static final boolean jsr310Available =, +		if (jsr310Available) {, +			Jsr310ConverterRegistrar.registerZoneIdConverters(converterRegistry);, +	 * Inner class to avoid a hard-coded dependency on Java 8's {@code java.time} package., +	private static final class Jsr310ConverterRegistrar {, +			converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java, +	private static final boolean jsr310Available =, +		if (jsr310Available) {, +			Jsr310ConverterRegistrar.registerZoneIdConverters(converterRegistry);, +	 * Inner class to avoid a hard-coded dependency on Java 8's {@code java.time} package., +	private static final class Jsr310ConverterRegistrar {, +			converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/FallbackObjectToStringConverter.java, + * Copyright 2002-2013 the original author or authors., +, +import org.springframework.util.ClassUtils;, + * Supports CharSequence, StringWriter, and any class with a String constructor or, + * {@code valueOf(String)} method., +		return (CharSequence.class.isAssignableFrom(sourceClass) ||, +				StringWriter.class.isAssignableFrom(sourceClass) ||, +				ObjectToObjectConverter.getOfMethod(sourceClass, String.class) != null ||, +				ClassUtils.getConstructorIfAvailable(sourceClass, String.class) != null);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java, +	private static final boolean jsr310Available =, +		if (jsr310Available) {, +			Jsr310ConverterRegistrar.registerZoneIdConverters(converterRegistry);, +	 * Inner class to avoid a hard-coded dependency on Java 8's {@code java.time} package., +	private static final class Jsr310ConverterRegistrar {, +			converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/FallbackObjectToStringConverter.java, + * Copyright 2002-2013 the original author or authors., +, +import org.springframework.util.ClassUtils;, + * Supports CharSequence, StringWriter, and any class with a String constructor or, + * {@code valueOf(String)} method., +		return (CharSequence.class.isAssignableFrom(sourceClass) ||, +				StringWriter.class.isAssignableFrom(sourceClass) ||, +				ObjectToObjectConverter.getOfMethod(sourceClass, String.class) != null ||, +				ClassUtils.getConstructorIfAvailable(sourceClass, String.class) != null);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java, + * <p>Calls a static {@code valueOf(sourceType)} or Java 8 style {@code of|from(sourceType)}, + * method on the target type to perform the conversion, if such a method exists. Otherwise,, + * it checks for a {@code to[targetType.simpleName]} method on the source type calls, +		return (String.class.equals(targetType.getType()) ?, +				(ClassUtils.getConstructorIfAvailable(String.class, sourceType.getType()) != null) :, +				hasToMethodOrOfMethodOrConstructor(targetType.getType(), sourceType.getType()));, +			if (!String.class.equals(targetClass)) {, +				Method method = getToMethod(targetClass, sourceClass);, +				if (method != null) {, +					ReflectionUtils.makeAccessible(method);, +					return method.invoke(source);, +				}, +				method = getOfMethod(targetClass, sourceClass);, +			}, +			Constructor<?> constructor = ClassUtils.getConstructorIfAvailable(targetClass, sourceClass);, +		throw new IllegalStateException("No static valueOf/of/from(" + sourceClass.getName() +, +, +	private static boolean hasToMethodOrOfMethodOrConstructor(Class<?> targetClass, Class<?> sourceClass) {, +		return (getToMethod(targetClass, sourceClass) != null ||, +				getOfMethod(targetClass, sourceClass) != null ||, +				ClassUtils.getConstructorIfAvailable(targetClass, sourceClass) != null);, +	private static Method getToMethod(Class<?> targetClass, Class<?> sourceClass) {, +		Method method = ClassUtils.getMethodIfAvailable(sourceClass, "to" + targetClass.getSimpleName());, +		return (method != null && targetClass.equals(method.getReturnType()) ? method : null);, +	}, +, +	static Method getOfMethod(Class<?> targetClass, Class<?> sourceClass) {, +		Method method = ClassUtils.getStaticMethod(targetClass, "valueOf", sourceClass);, +			method = ClassUtils.getStaticMethod(targetClass, "of", sourceClass);, +			if (method == null) {, +				method = ClassUtils.getStaticMethod(targetClass, "from", sourceClass);, +			}, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java, +	private static final boolean jsr310Available =, +		if (jsr310Available) {, +			Jsr310ConverterRegistrar.registerZoneIdConverters(converterRegistry);, +	 * Inner class to avoid a hard-coded dependency on Java 8's {@code java.time} package., +	private static final class Jsr310ConverterRegistrar {, +			converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/FallbackObjectToStringConverter.java, + * Copyright 2002-2013 the original author or authors., +, +import org.springframework.util.ClassUtils;, + * Supports CharSequence, StringWriter, and any class with a String constructor or, + * {@code valueOf(String)} method., +		return (CharSequence.class.isAssignableFrom(sourceClass) ||, +				StringWriter.class.isAssignableFrom(sourceClass) ||, +				ObjectToObjectConverter.getOfMethod(sourceClass, String.class) != null ||, +				ClassUtils.getConstructorIfAvailable(sourceClass, String.class) != null);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java, + * <p>Calls a static {@code valueOf(sourceType)} or Java 8 style {@code of|from(sourceType)}, + * method on the target type to perform the conversion, if such a method exists. Otherwise,, + * it checks for a {@code to[targetType.simpleName]} method on the source type calls, +		return (String.class.equals(targetType.getType()) ?, +				(ClassUtils.getConstructorIfAvailable(String.class, sourceType.getType()) != null) :, +				hasToMethodOrOfMethodOrConstructor(targetType.getType(), sourceType.getType()));, +			if (!String.class.equals(targetClass)) {, +				Method method = getToMethod(targetClass, sourceClass);]