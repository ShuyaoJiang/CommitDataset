[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RouterFunctions.java, +import java.util.function.Supplier;, +import org.springframework.web.reactive.function.server.support.*;, +					.then(handlerFunction -> wrapException(() -> handlerFunction.handle(request))), +					.then(response -> wrapException(() -> response.writeTo(exchange, strategies))), +					.otherwise(ResponseStatusException.class,, +							ex -> {, +								exchange.getResponse().setStatusCode(ex.getStatus());, +								return Mono.empty();, +							});, +	private static <T> Mono<T> wrapException(Supplier<Mono<T>> supplier) {, +			return supplier.get();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RouterFunctions.java, +import java.util.function.Supplier;, +import org.springframework.web.reactive.function.server.support.*;, +					.then(handlerFunction -> wrapException(() -> handlerFunction.handle(request))), +					.then(response -> wrapException(() -> response.writeTo(exchange, strategies))), +					.otherwise(ResponseStatusException.class,, +							ex -> {, +								exchange.getResponse().setStatusCode(ex.getStatus());, +								return Mono.empty();, +							});, +	private static <T> Mono<T> wrapException(Supplier<Mono<T>> supplier) {, +			return supplier.get();, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/function/server/PublisherHandlerFunctionIntegrationTests.java, +import static org.junit.Assert.*;, +import static org.springframework.web.reactive.function.BodyExtractors.*;, +import static org.springframework.web.reactive.function.BodyInserters.*;, +import static org.springframework.web.reactive.function.server.RequestPredicates.*;, +import static org.springframework.web.reactive.function.server.RouterFunctions.*;, +	private final RestTemplate restTemplate = new RestTemplate();, +				.and(route(GET("/flux"), personHandler::flux));, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RouterFunctions.java, +import java.util.function.Supplier;, +import org.springframework.web.reactive.function.server.support.*;, +					.then(handlerFunction -> wrapException(() -> handlerFunction.handle(request))), +					.then(response -> wrapException(() -> response.writeTo(exchange, strategies))), +					.otherwise(ResponseStatusException.class,, +							ex -> {, +								exchange.getResponse().setStatusCode(ex.getStatus());, +								return Mono.empty();, +							});, +	private static <T> Mono<T> wrapException(Supplier<Mono<T>> supplier) {, +			return supplier.get();, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/function/server/PublisherHandlerFunctionIntegrationTests.java, +import static org.junit.Assert.*;, +import static org.springframework.web.reactive.function.BodyExtractors.*;, +import static org.springframework.web.reactive.function.BodyInserters.*;, +import static org.springframework.web.reactive.function.server.RequestPredicates.*;, +import static org.springframework.web.reactive.function.server.RouterFunctions.*;, +	private final RestTemplate restTemplate = new RestTemplate();, +				.and(route(GET("/flux"), personHandler::flux));, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/function/server/RouterFunctionsTests.java, +import org.springframework.http.HttpHeaders;, +import org.springframework.http.HttpStatus;, +import org.springframework.web.server.ResponseStatusException;, +	public void toHttpHandlerNormal() throws Exception {, +		HandlerFunction<ServerResponse> handlerFunction = request -> ServerResponse.accepted().build();, +		RouterFunction<ServerResponse> routerFunction =, +				RouterFunctions.route(RequestPredicates.all(), handlerFunction);, +		HttpHandler result = RouterFunctions.toHttpHandler(routerFunction);, +		MockServerHttpResponse httpResponse = new MockServerHttpResponse();, +		result.handle(httpRequest, httpResponse).block();, +		assertEquals(HttpStatus.ACCEPTED, httpResponse.getStatusCode());, +	}, +, +	@Test, +	public void toHttpHandlerHandlerThrowsException() throws Exception {, +		HandlerFunction<ServerResponse> handlerFunction =, +				request -> {, +					throw new IllegalStateException();, +				};, +		RouterFunction<ServerResponse> routerFunction =, +				RouterFunctions.route(RequestPredicates.all(), handlerFunction);, +, +		HttpHandler result = RouterFunctions.toHttpHandler(routerFunction);, +		assertNotNull(result);, +, +		MockServerHttpRequest httpRequest = MockServerHttpRequest.get("http://localhost").build();, +		MockServerHttpResponse httpResponse = new MockServerHttpResponse();, +		result.handle(httpRequest, httpResponse).block();, +		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, httpResponse.getStatusCode());, +	}, +, +	@Test, +	public void toHttpHandlerHandlerReturnsException() throws Exception {, +		HandlerFunction<ServerResponse> handlerFunction =, +				request -> Mono.error(new IllegalStateException());, +		RouterFunction<ServerResponse> routerFunction =, +				RouterFunctions.route(RequestPredicates.all(), handlerFunction);, +, +		HttpHandler result = RouterFunctions.toHttpHandler(routerFunction);, +		assertNotNull(result);, +, +		MockServerHttpRequest httpRequest = MockServerHttpRequest.get("http://localhost").build();, +		MockServerHttpResponse httpResponse = new MockServerHttpResponse();, +		result.handle(httpRequest, httpResponse).block();, +		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, httpResponse.getStatusCode());, +	}, +]