[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, + * Copyright 2002-2010 the original author or authors., +import java.io.IOException;, +import org.springframework.beans.factory.parsing.Location;, +import org.springframework.beans.factory.parsing.Problem;, +import org.springframework.beans.factory.parsing.ProblemReporter;, +import org.springframework.beans.factory.support.AbstractBeanDefinition;, +import org.springframework.core.Conventions;, +import org.springframework.core.type.StandardAnnotationMetadata;, +import org.springframework.core.type.classreading.CachingMetadataReaderFactory;, +import org.springframework.core.type.classreading.MetadataReader;, +import org.springframework.core.type.classreading.MetadataReaderFactory;, +import org.springframework.stereotype.Component;, +	static final String CONFIGURATION_CLASS_FULL = "full";, +, +	static final String CONFIGURATION_CLASS_LITE = "lite";, +, +	static final String CONFIGURATION_CLASS_ATTRIBUTE =, +		Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "configurationClass");, +, +	private final ProblemReporter problemReporter;, +, +	private final MetadataReaderFactory metadataReaderFactory;, +, +, +	 * @param problemReporter , +	 * @param metadataReaderFactory , +	public ConfigurationClassBeanDefinitionReader(BeanDefinitionRegistry registry, SourceExtractor sourceExtractor,, +			ProblemReporter problemReporter, MetadataReaderFactory metadataReaderFactory) {, +		this.problemReporter = problemReporter;, +		this.metadataReaderFactory = metadataReaderFactory;, +		doLoadBeanDefinitionForConfigurationClassIfNecessary(configClass);, +	private void doLoadBeanDefinitionForConfigurationClassIfNecessary(ConfigurationClass configClass) {, +		if (configClass.getBeanName() != null) {, +			// a bean definition already exists for this configuration class -> nothing to do, +			return;, +		}, +, +		// no bean definition exists yet -> this must be an imported configuration class (@Import)., +		String className = configClass.getMetadata().getClassName();, +		configBeanDef.setBeanClassName(className);, +		if(checkConfigurationClassCandidate(configBeanDef, this.metadataReaderFactory)) {, +		} else {, +			try {, +				MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);, +				AnnotationMetadata metadata = reader.getAnnotationMetadata();, +				this.problemReporter.error(, +						new InvalidConfigurationImportProblem(className, reader.getResource(), metadata));, +			} catch (IOException ex) {, +				throw new IllegalStateException("Could not create MetadataReader for class " + className);, +			}, +	 * Check whether the given bean definition is a candidate for a configuration class,, +	 * and mark it accordingly., +	 * @param beanDef the bean definition to check, +	 * @param metadataReaderFactory the current factory in use by the caller, +	 * @return whether the candidate qualifies as (any kind of) configuration class, +	 */, +	static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {, +		AnnotationMetadata metadata = null;, +	, +		// Check already loaded Class if present..., +		// since we possibly can't even load the class file for this Class., +		if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {, +			metadata = new StandardAnnotationMetadata(((AbstractBeanDefinition) beanDef).getBeanClass());, +		}, +		else {, +			String className = beanDef.getBeanClassName();, +			if (className != null) {, +				try {, +					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);, +					metadata = metadataReader.getAnnotationMetadata();, +				}, +				catch (IOException ex) {, +					if (logger.isDebugEnabled()) {, +						logger.debug("Could not find class file for introspecting factory methods: " + className, ex);, +					}, +					return false;, +				}, +			}, +		}, +	, +		if (metadata != null) {, +			if (metadata.isAnnotated(Configuration.class.getName())) {, +				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);, +				return true;, +			}, +			else if (metadata.isAnnotated(Component.class.getName()) ||, +					metadata.hasAnnotatedMethods(Bean.class.getName())) {, +				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +	, +	/**, +	 * Configuration classes must be annotated with {@link Configuration @Configuration} or, +	 * declare at least one {@link Bean @Bean} method.]