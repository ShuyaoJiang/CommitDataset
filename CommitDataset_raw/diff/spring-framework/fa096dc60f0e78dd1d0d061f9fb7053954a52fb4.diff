[+++ b/spring-core/src/main/java/org/springframework/core/codec/DataBufferDecoder.java, + *, + * <p><strong>Note:</strong> The data buffers should be released via, + * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, + * after they have been consumed. In addition, if using {@code Flux} or, + * {@code Mono} operators such as flatMap, reduce, and others that prefetch,, + * cache, and skip or filter out data items internally, please add, + * {@code doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)} to the, + * composition chain to ensure cached data buffers are released prior to an, + * error or cancellation signal., +		return (super.canDecode(elementType, mimeType) &&, +				clazz != null && DataBuffer.class.isAssignableFrom(clazz));, +++ b/spring-core/src/main/java/org/springframework/core/codec/DataBufferDecoder.java, + *, + * <p><strong>Note:</strong> The data buffers should be released via, + * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, + * after they have been consumed. In addition, if using {@code Flux} or, + * {@code Mono} operators such as flatMap, reduce, and others that prefetch,, + * cache, and skip or filter out data items internally, please add, + * {@code doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)} to the, + * composition chain to ensure cached data buffers are released prior to an, + * error or cancellation signal., +		return (super.canDecode(elementType, mimeType) &&, +				clazz != null && DataBuffer.class.isAssignableFrom(clazz));, +++ b/spring-core/src/main/java/org/springframework/core/codec/StringDecoder.java, +	/** The default charset to use, i.e. "UTF-8". */, +	/** The default delimiter strings to use, i.e. {@code \r\n} and {@code \n}. */, +	private static final List<byte[]> DEFAULT_DELIMITER_BYTES = DEFAULT_DELIMITERS.stream(), +			.map(s -> s.getBytes(StandardCharsets.UTF_8)), +			.collect(Collectors.toList());, +, +	@Nullable, +, +	private StringDecoder(@Nullable List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {, +		this.delimiters = delimiters != null ? new ArrayList<>(delimiters) : null;, +		List<byte[]> delimiterBytes = this.delimiters != null ?, +				this.delimiters.stream().map(s -> s.getBytes(getCharset(mimeType))).collect(Collectors.toList()) :, +				DEFAULT_DELIMITER_BYTES;, +				.flatMapIterable(dataBuffer -> splitOnDelimiter(dataBuffer, delimiterBytes)), +				.map(StringDecoder::joinUntilEndFrame), +		return super.decode(inputFlux, elementType, mimeType, hints);, +	private List<DataBuffer> splitOnDelimiter(DataBuffer dataBuffer, List<byte[]> delimiterBytes) {, +				int index = indexOf(dataBuffer, delimiter);, +				if (index >= 0 && index < length) {, +					length = index;, +		return frames;, +	 * Find the given delimiter in the given data buffer., +	 * @return the index of the delimiter, or -1 if not found., +	 * Joins the given list of buffers into a single buffer, also removing, +	 * the (inserted) {@link #END_FRAME}., +	private static DataBuffer joinUntilEndFrame(List<DataBuffer> dataBuffers) {, +		return dataBuffers.get(0).factory().join(dataBuffers);, +		return textPlainOnly(null, true);, +	 * @param delimiters delimiter strings to use to split the input stream, if, +	 * {@code null} by default {@link #DEFAULT_DELIMITERS} is used., +	 * @param stripDelimiter whether to remove delimiters from the resulting, +	 * input strings., +	public static StringDecoder textPlainOnly(@Nullable List<String> delimiters, boolean stripDelimiter) {, +		return new StringDecoder(delimiters, stripDelimiter, new MimeType("text", "plain", DEFAULT_CHARSET));, +		return allMimeTypes(null, true);, +	 * @param delimiters delimiter strings to use to split the input stream, if, +	 * {@code null} by default {@link #DEFAULT_DELIMITERS} is used., +	 * @param stripDelimiter whether to remove delimiters from the resulting, +	 * input strings., +	public static StringDecoder allMimeTypes(@Nullable List<String> delimiters, boolean stripDelimiter) {, +++ b/spring-core/src/main/java/org/springframework/core/codec/DataBufferDecoder.java, + *, + * <p><strong>Note:</strong> The data buffers should be released via, + * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, + * after they have been consumed. In addition, if using {@code Flux} or, + * {@code Mono} operators such as flatMap, reduce, and others that prefetch,, + * cache, and skip or filter out data items internally, please add, + * {@code doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)} to the, + * composition chain to ensure cached data buffers are released prior to an, + * error or cancellation signal., +		return (super.canDecode(elementType, mimeType) &&, +				clazz != null && DataBuffer.class.isAssignableFrom(clazz));, +++ b/spring-core/src/main/java/org/springframework/core/codec/StringDecoder.java, +	/** The default charset to use, i.e. "UTF-8". */, +	/** The default delimiter strings to use, i.e. {@code \r\n} and {@code \n}. */, +	private static final List<byte[]> DEFAULT_DELIMITER_BYTES = DEFAULT_DELIMITERS.stream(), +			.map(s -> s.getBytes(StandardCharsets.UTF_8)), +			.collect(Collectors.toList());, +, +	@Nullable, +, +	private StringDecoder(@Nullable List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {, +		this.delimiters = delimiters != null ? new ArrayList<>(delimiters) : null;, +		List<byte[]> delimiterBytes = this.delimiters != null ?, +				this.delimiters.stream().map(s -> s.getBytes(getCharset(mimeType))).collect(Collectors.toList()) :, +				DEFAULT_DELIMITER_BYTES;, +				.flatMapIterable(dataBuffer -> splitOnDelimiter(dataBuffer, delimiterBytes)), +				.map(StringDecoder::joinUntilEndFrame), +		return super.decode(inputFlux, elementType, mimeType, hints);, +	private List<DataBuffer> splitOnDelimiter(DataBuffer dataBuffer, List<byte[]> delimiterBytes) {, +				int index = indexOf(dataBuffer, delimiter);, +				if (index >= 0 && index < length) {, +					length = index;, +		return frames;, +	 * Find the given delimiter in the given data buffer.]