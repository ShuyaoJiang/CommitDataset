[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/ConsumesRequestCondition.java, +import org.springframework.lang.Nullable;, +import org.springframework.util.CollectionUtils;, +		this.expressions = new ArrayList<>(parseExpressions(consumes, headers));, +		Collections.sort(this.expressions);, +	 * Private constructor for internal when creating matching conditions., +	 * Note the expressions List is neither sorted nor deep copied., +	private ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {, +		this.expressions = expressions;, +		List<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);, +		return !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;, +	}, +, +	@Nullable, +	private List<ConsumeMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {, +		List<ConsumeMediaTypeExpression> result = null;, +		for (ConsumeMediaTypeExpression expression : this.expressions) {, +			if (expression.match(exchange)) {, +				result = result != null ? result : new ArrayList<>();, +				result.add(expression);, +			}, +		}, +		return result;, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/ConsumesRequestCondition.java, +import org.springframework.lang.Nullable;, +import org.springframework.util.CollectionUtils;, +		this.expressions = new ArrayList<>(parseExpressions(consumes, headers));, +		Collections.sort(this.expressions);, +	 * Private constructor for internal when creating matching conditions., +	 * Note the expressions List is neither sorted nor deep copied., +	private ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {, +		this.expressions = expressions;, +		List<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);, +		return !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;, +	}, +, +	@Nullable, +	private List<ConsumeMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {, +		List<ConsumeMediaTypeExpression> result = null;, +		for (ConsumeMediaTypeExpression expression : this.expressions) {, +			if (expression.match(exchange)) {, +				result = result != null ? result : new ArrayList<>();, +				result.add(expression);, +			}, +		}, +		return result;, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/HeadersRequestCondition.java, + * Copyright 2002-2019 the original author or authors., +	private HeadersRequestCondition(Set<HeaderExpression> conditions) {, +		this.expressions = conditions;, +	private static Set<HeaderExpression> parseExpressions(String... headers) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/ConsumesRequestCondition.java, +import org.springframework.lang.Nullable;, +import org.springframework.util.CollectionUtils;, +		this.expressions = new ArrayList<>(parseExpressions(consumes, headers));, +		Collections.sort(this.expressions);, +	 * Private constructor for internal when creating matching conditions., +	 * Note the expressions List is neither sorted nor deep copied., +	private ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {, +		this.expressions = expressions;, +		List<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);, +		return !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;, +	}, +, +	@Nullable, +	private List<ConsumeMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {, +		List<ConsumeMediaTypeExpression> result = null;, +		for (ConsumeMediaTypeExpression expression : this.expressions) {, +			if (expression.match(exchange)) {, +				result = result != null ? result : new ArrayList<>();, +				result.add(expression);, +			}, +		}, +		return result;, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/HeadersRequestCondition.java, + * Copyright 2002-2019 the original author or authors., +	private HeadersRequestCondition(Set<HeaderExpression> conditions) {, +		this.expressions = conditions;, +	private static Set<HeaderExpression> parseExpressions(String... headers) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/PatternsRequestCondition.java, + * Copyright 2002-2019 the original author or authors., +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/ConsumesRequestCondition.java, +import org.springframework.lang.Nullable;, +import org.springframework.util.CollectionUtils;, +		this.expressions = new ArrayList<>(parseExpressions(consumes, headers));, +		Collections.sort(this.expressions);, +	 * Private constructor for internal when creating matching conditions., +	 * Note the expressions List is neither sorted nor deep copied., +	private ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {, +		this.expressions = expressions;, +		List<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);, +		return !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;, +	}, +, +	@Nullable, +	private List<ConsumeMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {, +		List<ConsumeMediaTypeExpression> result = null;, +		for (ConsumeMediaTypeExpression expression : this.expressions) {, +			if (expression.match(exchange)) {, +				result = result != null ? result : new ArrayList<>();]