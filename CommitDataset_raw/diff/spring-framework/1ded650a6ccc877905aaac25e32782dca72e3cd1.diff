[+++ b/spring-framework-reference/src/jdbc.xml, +        we would annotate the setter method for the, +        since the <classname>SimpleJdbcTemplate</classname> was designed for, +        only be used for testing purposes since it does not provide pooling, +        and will perform poorly when multiple requests for a connection are, +      supplied <interfacename>ResultSet</interfacename> into an object of the, +      type specified. Below is a brief example of a custom query that maps the, +      data from the t_actor relation to an instance of the, +      <classname>Actor</classname> class.</para>, +      <programlisting language="java"><![CDATA[public class ActorMappingQuery extends MappingSqlQuery<Actor> {, +    public ActorMappingQuery(DataSource ds) {, +        super(ds, "select id, first_name, last_name from t_actor where id = ?");, +    @Override, +    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {, +        Actor actor = new Actor();, +        actor.setId(rs.getLong("id"));, +        actor.setFirstName(rs.getString("first_name"));, +        actor.setLastName(rs.getString("last_name"));, +        return actor;, +, +      <para>The class extends <classname>MappingSqlQuery</classname>, +      parameterized with the <classname>Actor</classname> type. We provide a, +      constructor for this customer query that takes the, +      statement can be prepared and later be executed. This class is thread, +      safe once it has been compiled, so as long as these classes are created, +      when the DAO is initialized they can be kept as instance variable and be, +      reused.</para>, +      <programlisting language="java"><![CDATA[private ActorMappingQuery actorMappingQuery;, +, +@Autowired, +public void setDataSource(DataSource dataSource) {, +    this.actorMappingQuery = new ActorMappingQuery(dataSource);, +, +public Customer getCustomer(Long id) {, +    return actorMappingQuery.findObject(id);, +      is passed in as the only parameter. Since we only want one object, +      returned we simply call the convenience method findObject with the id as, +      parameter. If we instead had a query the returned a list of objects and, +      took additional parameters then we would use one of the execute methods, +      that takes an array of parameter values passed in as varargs.</para>, +, +      <programlisting language="java"><![CDATA[public List<Actor> searchForActors(int age, String namePattern) {, +    List<Actor> actors = actorSearchMappingQuery.execute(age, namePattern);, +    return actors;, +}]]></programlisting>, +      custom update method - like in this example where we call it execute) it, +      can easily be parameterized by setting SQL and declaring, +      parameters.</para>, +      <programlisting language="java"><![CDATA[import java.sql.Types;, +        declareParameter(new SqlParameter("creditRating", Types.NUMERIC));, +        declareParameter(new SqlParameter("id", Types.NUMERIC));, +    /**, +     */, +    public int execute(int id, int rating) {, +        return update(rating, id);, +}]]></programlisting>, +      <para>To define a parameter to be used for the StoredProcedure class,, +          is provided will also be used as an input parameter.</para>, +      <para>Here is an example of a simple DAO that uses a, +      <classname>StoredProcedure</classname> to call a function,, +      use the stored procedure functionality you have to create a class that, +      extends <classname>StoredProcedure</classname>. In this example the, +      <classname>StoredProcedure</classname> class is an inner class, but if, +      you need to reuse the <classname>StoredProcedure</classname> you would, +      declare it as a top-level class. There are no input parameters in this, +      example, but there is an output parameter that is declared as a date, +      <literal>execute()</literal> method executes the procedure and extracts, +      the returned date from the results <classname>Map</classname>. The, +      results <classname>Map</classname> has an entry for each declared output, +      parameter, in this case only one, using the parameter name as the, +      key.</para>, +      <programlisting language="java"><![CDATA[import java.sql.Types;, +import java.util.Date;, +import org.springframework.beans.factory.annotation.Autowired;, +public class StoredProcedureDao {, +    private GetSysdateProcedure getSysdate;, +    , +    @Autowired, +    public void init(DataSource dataSource) {, +        this.getSysdate = new GetSysdateProcedure(dataSource);, +    public Date getSysdate() {, +        return getSysdate.execute();, +    private class GetSysdateProcedure extends StoredProcedure {, +        public GetSysdateProcedure(DataSource dataSource) {, +            setDataSource(dataSource);, +        public Date execute() {, +            // the 'sysdate' sproc has no input parameters, so an empty Map is supplied..., +            Map<String, Object> results = execute(new HashMap<String, Object>());, +            Date sysdate = (Date) results.get("date");, +            return sysdate;    , +}]]></programlisting>, +      <para>Below is an example of a <classname>StoredProcedure</classname>, +      <programlisting language="java"><![CDATA[import oracle.jdbc.OracleTypes;, +    public Map<String, Object> execute() {, +        // again, this sproc has no input parameters, so an empty Map is supplied, +        return super.execute(new HashMap<String, Object>());, +}]]></programlisting>, +      <para>First the <classname>TitleMapper</classname> class, which simply, +      <programlisting language="java"><![CDATA[import org.springframework.jdbc.core.RowMapper;, +import com.foo.domain.Title;]