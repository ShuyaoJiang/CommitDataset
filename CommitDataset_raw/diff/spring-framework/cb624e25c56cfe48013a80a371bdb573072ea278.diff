[+++ b/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java, +		return this.delegate.getAdditionalBeanInfo();, +		return this.delegate.getBeanDescriptor();, +		return this.delegate.getDefaultEventIndex();, +		return this.delegate.getDefaultPropertyIndex();, +		return this.delegate.getEventSetDescriptors();, +		return this.delegate.getIcon(iconKind);, +		return this.delegate.getMethodDescriptors();, +				// Ignore, as does PropertyDescriptor#getPropertyType, +				// Ignore, as does IndexedPropertyDescriptor#getPropertyType, +				// Ignore, as does IndexedPropertyDescriptor#getIndexedPropertyType, +		// Copy all attributes (emulating behavior of private FeatureDescriptor#addTable), +		// See java.beans.PropertyDescriptor#PropertyDescriptor(PropertyDescriptor), +				throw new IntrospectionException("Bad read method arg count: " + readMethod);, +				throw new IntrospectionException("Read method returns void: " + readMethod);, +				throw new IntrospectionException("Bad write method arg count: " + writeMethod);, +			if (propertyType != null) {, +				if (propertyType.isAssignableFrom(params[0])) {, +					// Write method's property type potentially more specific, +				else if (params[0].isAssignableFrom(propertyType)) {, +					// Proceed with read method's property type, +				}, +				else {, +					throw new IntrospectionException(, +							"Type mismatch between read and write methods: " + readMethod + " - " + writeMethod);, +				}, +			}, +			else {, +				propertyType = params[0];, +			}, +		}, +				throw new IntrospectionException("Bad indexed read method arg count: " + indexedReadMethod);, +				throw new IntrospectionException("Non int index to indexed read method: " + indexedReadMethod);, +				throw new IntrospectionException("Indexed read method returns void: " + indexedReadMethod);, +				throw new IntrospectionException("Bad indexed write method arg count: " + indexedWriteMethod);, +				throw new IntrospectionException("Non int index to indexed write method: " + indexedWriteMethod);, +			if (indexedPropertyType != null) {, +				if (indexedPropertyType.isAssignableFrom(params[1])) {, +					// Write method's property type potentially more specific, +				else if (params[1].isAssignableFrom(indexedPropertyType)) {, +					// Proceed with read method's property type, +				}, +				else {, +					throw new IntrospectionException("Type mismatch between indexed read and write methods: " +, +							indexedReadMethod + " - " + indexedWriteMethod);, +				}, +			}, +			else {, +				indexedPropertyType = params[1];, +			}, +		}, +		if (propertyType != null && (!propertyType.isArray() ||, +			throw new IntrospectionException("Type mismatch between indexed and non-indexed methods: " +, +					indexedReadMethod + " - " + indexedWriteMethod);, +			if (pd1.getPropertyType() == pd2.getPropertyType() &&, +					pd1.getPropertyEditorClass() == pd2.getPropertyEditorClass() &&, +					pd1.isBound() == pd2.isBound() && pd1.isConstrained() == pd2.isConstrained()) {, +		if (a != null) {, +++ b/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java, +		return this.delegate.getAdditionalBeanInfo();, +		return this.delegate.getBeanDescriptor();, +		return this.delegate.getDefaultEventIndex();, +		return this.delegate.getDefaultPropertyIndex();, +		return this.delegate.getEventSetDescriptors();, +		return this.delegate.getIcon(iconKind);, +		return this.delegate.getMethodDescriptors();, +				// Ignore, as does PropertyDescriptor#getPropertyType, +				// Ignore, as does IndexedPropertyDescriptor#getPropertyType, +				// Ignore, as does IndexedPropertyDescriptor#getIndexedPropertyType, +		// Copy all attributes (emulating behavior of private FeatureDescriptor#addTable), +		// See java.beans.PropertyDescriptor#PropertyDescriptor(PropertyDescriptor), +				throw new IntrospectionException("Bad read method arg count: " + readMethod);, +				throw new IntrospectionException("Read method returns void: " + readMethod);, +				throw new IntrospectionException("Bad write method arg count: " + writeMethod);, +			if (propertyType != null) {, +				if (propertyType.isAssignableFrom(params[0])) {, +					// Write method's property type potentially more specific, +				else if (params[0].isAssignableFrom(propertyType)) {, +					// Proceed with read method's property type, +				}, +				else {, +					throw new IntrospectionException(, +							"Type mismatch between read and write methods: " + readMethod + " - " + writeMethod);, +				}, +			}, +			else {, +				propertyType = params[0];, +			}, +		}, +				throw new IntrospectionException("Bad indexed read method arg count: " + indexedReadMethod);, +				throw new IntrospectionException("Non int index to indexed read method: " + indexedReadMethod);, +				throw new IntrospectionException("Indexed read method returns void: " + indexedReadMethod);, +				throw new IntrospectionException("Bad indexed write method arg count: " + indexedWriteMethod);, +				throw new IntrospectionException("Non int index to indexed write method: " + indexedWriteMethod);, +			if (indexedPropertyType != null) {, +				if (indexedPropertyType.isAssignableFrom(params[1])) {, +					// Write method's property type potentially more specific, +				else if (params[1].isAssignableFrom(indexedPropertyType)) {, +					// Proceed with read method's property type, +				}]