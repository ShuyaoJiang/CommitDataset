[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2015 the original author or authors., +import java.util.HashSet;, +	final Set<String> skippedBeans = new HashSet<String>();, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2015 the original author or authors., +import java.util.HashSet;, +	final Set<String> skippedBeans = new HashSet<String>();, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, + * Copyright 2002-2015 the original author or authors., +		ConfigurationClass configClass = beanMethod.getConfigurationClass();, +		MethodMetadata metadata = beanMethod.getMetadata();, +, +		// Consider name and any aliases, +		AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);, +		List<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray("name")));, +		String beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());, +, +		// Do we need to mark the bean as skipped by its condition?, +		if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {, +			configClass.skippedBeans.add(beanName);, +			return;, +		}, +		if (configClass.skippedBeans.contains(beanName)) {, +		// Register aliases even when overridden, +		for (String alias : names) {, +			this.registry.registerAlias(beanName, alias);, +		}, +, +		// Has this effectively been overridden before (e.g. via XML)?, +		if (isOverriddenByExistingDefinition(beanMethod, beanName)) {, +			return;, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2015 the original author or authors., +import java.util.HashSet;, +	final Set<String> skippedBeans = new HashSet<String>();, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, + * Copyright 2002-2015 the original author or authors., +		ConfigurationClass configClass = beanMethod.getConfigurationClass();, +		MethodMetadata metadata = beanMethod.getMetadata();, +, +		// Consider name and any aliases, +		AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);, +		List<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray("name")));, +		String beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());, +, +		// Do we need to mark the bean as skipped by its condition?, +		if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {, +			configClass.skippedBeans.add(beanName);, +			return;, +		}, +		if (configClass.skippedBeans.contains(beanName)) {, +		// Register aliases even when overridden, +		for (String alias : names) {, +			this.registry.registerAlias(beanName, alias);, +		}, +, +		// Has this effectively been overridden before (e.g. via XML)?, +		if (isOverriddenByExistingDefinition(beanMethod, beanName)) {, +			return;, +		}, +, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassWithConditionTests.java, + * Copyright 2002-2015 the original author or authors., + * @author Juergen Hoeller, +	@Test, +	public void conditionOnOverriddenMethodHonored() {, +		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigWithBeanSkipped.class);, +		assertEquals(0, context.getBeansOfType(ExampleBean.class).size());, +	}, +, +	@Test, +	public void noConditionOnOverriddenMethodHonored() {, +		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigWithBeanReactivated.class);, +		assertEquals(1, context.getBeansOfType(ExampleBean.class).size());, +	}, +, +, +, +	@Configuration, +	private static class ConfigWithBeanActive {, +, +		@Bean, +		public ExampleBean baz() {, +			return new ExampleBean();, +		}, +	}, +, +	private static class ConfigWithBeanSkipped extends ConfigWithBeanActive {, +, +		@Override, +		@Bean, +		@Conditional(NeverCondition.class), +		public ExampleBean baz() {, +			return new ExampleBean();]