[+++ b/org.springframework.aop/src/main/java/org/springframework/aop/support/AopUtils.java, + * Copyright 2002-2010 the original author or authors., +	public static boolean isCglibProxyClass(Class<?> clazz) {, +	 * @return the target class (or the plain class of the given object as fallback;, +	 * never <code>null</code>), +	public static Class<?> getTargetClass(Object candidate) {, +		Class<?> result = null;, +			result = ((TargetClassAware) candidate).getTargetClass();, +		if (result == null) {, +			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());, +		return result;, +	public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {, +		for (Class<?> clazz : classes) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {, +	public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/support/AopUtils.java, + * Copyright 2002-2010 the original author or authors., +	public static boolean isCglibProxyClass(Class<?> clazz) {, +	 * @return the target class (or the plain class of the given object as fallback;, +	 * never <code>null</code>), +	public static Class<?> getTargetClass(Object candidate) {, +		Class<?> result = null;, +			result = ((TargetClassAware) candidate).getTargetClass();, +		if (result == null) {, +			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());, +		return result;, +	public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {, +		for (Class<?> clazz : classes) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {, +	public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {, +++ b/org.springframework.context/src/main/java/org/springframework/jmx/support/JmxUtils.java, +	public static Class<?> getClassToExpose(Object managedBean) {, +	 * @param clazz the bean class (might be an AOP proxy class), +	public static Class<?> getClassToExpose(Class<?> clazz) {, +		return ClassUtils.getUserClass(clazz);, +	 * @param clazz the bean class to analyze, +	public static boolean isMBean(Class<?> clazz) {, +		return (clazz != null &&, +				(DynamicMBean.class.isAssignableFrom(clazz) ||, +						(getMBeanInterface(clazz) != null || getMXBeanInterface(clazz) != null)));, +	public static Class<?> getMBeanInterface(Class<?> clazz) {, +		if (clazz == null || clazz.getSuperclass() == null) {, +		for (Class<?> iface : implementedInterfaces) {, +	public static Class<?> getMXBeanInterface(Class<?> clazz) {, +		if (clazz == null || clazz.getSuperclass() == null) {, +		for (Class<?> iface : implementedInterfaces) {, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/support/AopUtils.java, + * Copyright 2002-2010 the original author or authors., +	public static boolean isCglibProxyClass(Class<?> clazz) {, +	 * @return the target class (or the plain class of the given object as fallback;, +	 * never <code>null</code>), +	public static Class<?> getTargetClass(Object candidate) {, +		Class<?> result = null;, +			result = ((TargetClassAware) candidate).getTargetClass();, +		if (result == null) {, +			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());, +		return result;, +	public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass) {, +	public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {, +		for (Class<?> clazz : classes) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass) {, +	public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {, +	public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {, +++ b/org.springframework.context/src/main/java/org/springframework/jmx/support/JmxUtils.java, +	public static Class<?> getClassToExpose(Object managedBean) {, +	 * @param clazz the bean class (might be an AOP proxy class), +	public static Class<?> getClassToExpose(Class<?> clazz) {, +		return ClassUtils.getUserClass(clazz);, +	 * @param clazz the bean class to analyze, +	public static boolean isMBean(Class<?> clazz) {, +		return (clazz != null &&, +				(DynamicMBean.class.isAssignableFrom(clazz) ||, +						(getMBeanInterface(clazz) != null || getMXBeanInterface(clazz) != null)));, +	public static Class<?> getMBeanInterface(Class<?> clazz) {, +		if (clazz == null || clazz.getSuperclass() == null) {, +		for (Class<?> iface : implementedInterfaces) {, +	public static Class<?> getMXBeanInterface(Class<?> clazz) {, +		if (clazz == null || clazz.getSuperclass() == null) {, +		for (Class<?> iface : implementedInterfaces) {, +++ b/org.springframework.context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.java, + * Copyright 2002-2010 the original author or authors., +import java.util.concurrent.Executor;, +	public Object postProcessBeforeInitialization(Object bean, String beanName) {, +	public Object postProcessAfterInitialization(Object bean, String beanName) {, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/support/AopUtils.java, + * Copyright 2002-2010 the original author or authors., +	public static boolean isCglibProxyClass(Class<?> clazz) {, +	 * @return the target class (or the plain class of the given object as fallback;, +	 * never <code>null</code>), +	public static Class<?> getTargetClass(Object candidate) {, +		Class<?> result = null;, +			result = ((TargetClassAware) candidate).getTargetClass();, +		if (result == null) {]