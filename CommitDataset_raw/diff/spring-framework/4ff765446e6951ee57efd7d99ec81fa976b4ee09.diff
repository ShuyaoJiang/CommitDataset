[+++ b/spring-orm/src/main/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.java, +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as, +	 * overriding data source configuration in <code>persistence.xml</code> (if any)., +	 * Note that this variant typically works for JTA transaction management as well;, +	 * if it does not, consider using the explicit {@link #setJtaDataSource} instead., +	 * Specify the JDBC DataSource that the JPA persistence provider is supposed, +	 * to use for accessing the database. This is an alternative to keeping the, +	 * JDBC configuration in <code>persistence.xml</code>, passing in a Spring-managed, +	 * DataSource instead., +	 * <p>In JPA speak, a DataSource passed in here will be used as "jtaDataSource", +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as, +	 * overriding data source configuration in <code>persistence.xml</code> (if any)., +	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>, +	 * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource(), +	 * @see #setPersistenceUnitManager, +	 */, +	public void setJtaDataSource(DataSource jtaDataSource) {, +		this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(jtaDataSource));, +		this.internalPersistenceUnitManager.setDefaultJtaDataSource(jtaDataSource);, +	}, +, +	/**, +	 * classes and jar files, in addition to the metadata read from, +			return (this.persistenceUnitInfo.getJtaDataSource() != null ?, +					this.persistenceUnitInfo.getJtaDataSource() :, +					this.persistenceUnitInfo.getNonJtaDataSource());, +		return (this.internalPersistenceUnitManager.getDefaultJtaDataSource() != null ?, +				this.internalPersistenceUnitManager.getDefaultJtaDataSource() :, +				this.internalPersistenceUnitManager.getDefaultDataSource());, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.java, +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as, +	 * overriding data source configuration in <code>persistence.xml</code> (if any)., +	 * Note that this variant typically works for JTA transaction management as well;, +	 * if it does not, consider using the explicit {@link #setJtaDataSource} instead., +	 * Specify the JDBC DataSource that the JPA persistence provider is supposed, +	 * to use for accessing the database. This is an alternative to keeping the, +	 * JDBC configuration in <code>persistence.xml</code>, passing in a Spring-managed, +	 * DataSource instead., +	 * <p>In JPA speak, a DataSource passed in here will be used as "jtaDataSource", +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as, +	 * overriding data source configuration in <code>persistence.xml</code> (if any)., +	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>, +	 * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource(), +	 * @see #setPersistenceUnitManager, +	 */, +	public void setJtaDataSource(DataSource jtaDataSource) {, +		this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(jtaDataSource));, +		this.internalPersistenceUnitManager.setDefaultJtaDataSource(jtaDataSource);, +	}, +, +	/**, +	 * classes and jar files, in addition to the metadata read from, +			return (this.persistenceUnitInfo.getJtaDataSource() != null ?, +					this.persistenceUnitInfo.getJtaDataSource() :, +					this.persistenceUnitInfo.getNonJtaDataSource());, +		return (this.internalPersistenceUnitManager.getDefaultJtaDataSource() != null ?, +				this.internalPersistenceUnitManager.getDefaultJtaDataSource() :, +				this.internalPersistenceUnitManager.getDefaultDataSource());, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/persistenceunit/DefaultPersistenceUnitManager.java, +	private DataSource defaultJtaDataSource;, +, +	 * Specify the JDBC DataSource that the JPA persistence provider is supposed to use, +	 * for accessing the database if none has been specified in <code>persistence.xml</code>., +	 * This variant indicates no special transaction setup, i.e. typical resource-local., +	 * Return the JDBC DataSource that the JPA persistence provider is supposed to use, +	 * for accessing the database if none has been specified in <code>persistence.xml</code>., +	 * Specify the JDBC DataSource that the JPA persistence provider is supposed to use, +	 * for accessing the database if none has been specified in <code>persistence.xml</code>., +	 * This variant indicates that JTA is supposed to be used as transaction type., +	 * <p>In JPA speak, a DataSource passed in here will be uses as "jtaDataSource", +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, provided that, +	 * none has been registered before., +	 * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource(), +	 */, +	public void setDefaultJtaDataSource(DataSource defaultJtaDataSource) {, +		this.defaultJtaDataSource = defaultJtaDataSource;, +	}, +, +	/**, +	 * Return the JTA-aware DataSource that the JPA persistence provider is supposed to use, +	 * for accessing the database if none has been specified in <code>persistence.xml</code>., +	 */, +	public DataSource getDefaultJtaDataSource() {, +		return this.defaultJtaDataSource;, +	}, +, +	/**, +	 * <p>Such post-processors can, for example, register further entity classes and, +	 * jar files, in addition to the metadata read from <code>persistence.xml</code>., +			if (pui.getJtaDataSource() == null) {, +				pui.setJtaDataSource(this.defaultJtaDataSource);, +			}, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.java, +	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as, +	 * overriding data source configuration in <code>persistence.xml</code> (if any)., +	 * Note that this variant typically works for JTA transaction management as well;, +	 * if it does not, consider using the explicit {@link #setJtaDataSource} instead., +	 * Specify the JDBC DataSource that the JPA persistence provider is supposed, +	 * to use for accessing the database. This is an alternative to keeping the, +	 * JDBC configuration in <code>persistence.xml</code>, passing in a Spring-managed]