[+++ b/spring-framework-reference/src/beans.xml, +        created. Scopes are defined in <xref linkend="beans-factory-scopes" />, +        Otherwise, the bean is created only when it is requested. Creation of, +        a bean potentially causes a graph of beans to be created, as the, +        bean's dependencies and its dependencies' dependencies (and so on) are, +        created and assigned.</para>, +      linkend="metadata-annotations-required" /></literal> to be of, +      interest.</para>, +, +, +      <para>As of Spring 3.0, a <emphasis>thread scope</emphasis> is, +      available, but is not registered by default. For more information, see, +      the documentation for <ulink, +      url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/support/SimpleThreadScope.html">SimpleThreadScope</ulink>., +, +          which is included with Spring, but not registered by default. The, +          instructions would be the same for your own custom, +          <literal>Scope</literal> implementations.</para>, +      information, see <xref linkend="beans-autowired-annotation" />.</para>, +        shown in <xref linkend="metadata-annotations-required" /> which, +        demonstrates the usage of a custom, +        <interfacename>BeanPostProcessor</interfacename> implementation that, +        ships with the Spring distribution which ensures that JavaBean, +        properties on beans that are marked with an (arbitrary) annotation are, +        actually (configured to be) dependency-injected with a value.</para>, +    <interfacename>@PreDestroy</interfacename>. Spring 3.0 adds support for, +    JSR-330 (Dependency Injection for Java) annotations contained in the, +    javax.inject package such as <classname>@Inject</classname>,, +    <literal>@Qualifier, @Named, and @Provider</literal> if the JSR330 jar is, +    present on the classpath. Use of these annotations also requires that, +    certain <interfacename>BeanPostProcessors</interfacename> be registered, +    within the Spring container. As always, you can register them as, +    individual bean definitions, but they can also be implicitly registered by, +    including the following tag in an XML-based Spring configuration (notice, +    the inclusion of the <literal>context</literal> namespace):</para>, +      <title><interfacename>@Autowired and @Inject</interfacename></title>, +      <note>, +        <para>JSR 330's @Inject annotation can be used in place of Spring's, +        <interfacename>@Autowired</interfacename> in the examples below., +        <interfacename>@Inject</interfacename> does not have a required, +        property unlike Spring's <interfacename>@Autowire</interfacename>, +        annotation which as a required property to indicate if the value being, +        injected is optional. This behavior is enabled automatically if you, +        have the JSR 330 jar on the classpath.</para>, +      </note>, +, +      <note>, +        <para>Note that the JSR 330 <interfacename>@Qualifier</interfacename>, +        annotation can only be applied as a meta-annotation unlike Spring's, +        @Qualifier which takes a string property to discriminate among, +        multiple injection candidates and can be placed on annotation as well, +        as types, fields, methods, contstructors and parameters.</para>, +      </note>, +, +      <note>, +        <para>You can use JSR 330's <interfacename>@Qualifier, +        </interfacename>annotation in the manner described below in place of, +        Spring's <interfacename>@Qualifier</interfacename> annotation. This, +        behavior is enabled automatically if you have the JSR 330 jar on the, +        classpath.</para>, +      </note>, +, +, +      <note>, +        <para>In Spring 3.0 RC1 you can use JSR 330's, +        <interfacename>@Named</interfacename> annotation in place of, +        stereotpye annotations and they will be automatically detected during, +        component-scanning. The value of the, +        <interfacename>@Named</interfacename> property will be used as the, +        Bean Name. At this time Spring default for bean scope will be applied, +        when using @Named. This behavior as well as mapping of JSR 330 and, +        JSR299 scopes is planned for Spring 3.0 GA assuming the JSRs are, +        stable at that time.</para>, +      </note>, +              .TypeFilter</interfacename> interface.</entry>, +      additional support for autowiring of <literal>@Bean</literal>, +      methods:</para>, +      corresponding bean definition.</para>, +, +      <note>, +        <para>JSR 330's @Named annotation can be used as a mean to both detect, +        components and to provide them with a name. This behavior is enabled, +        automatically if you have the JSR 330 jar on the classpath.</para>, +      </note>, +, +      <para>If such an annotation contains no <literal>name</literal> value or, +      for any other detected component (such as those discovered by custom, +      filters), the default bean name generator returns the uncapitalized, +      non-qualified class name. For example, if the following two components, +      were detected, the names would be myMovieLister and, +      movieFinderImpl:</para>, +        JSR-250, see <link, +        linkend="beans-factory-lifecycle-combined-effects">JSR-250, +        <code><link linkend="beans-factory-aware">BeanNameAware</link></code>,, +++ b/spring-framework-reference/src/beans.xml, +        created. Scopes are defined in <xref linkend="beans-factory-scopes" />, +        Otherwise, the bean is created only when it is requested. Creation of, +        a bean potentially causes a graph of beans to be created, as the, +        bean's dependencies and its dependencies' dependencies (and so on) are, +        created and assigned.</para>]