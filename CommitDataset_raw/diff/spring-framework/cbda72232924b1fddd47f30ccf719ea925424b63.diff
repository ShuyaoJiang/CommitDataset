[+++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java, + * <p><b>NOTE: Hibernate 4.2+ is strongly recommended for efficient transaction, + * management with Spring, in particular for transactional Spring JDBC access.</b>, + *, +							"Hibernate connection release mode is set to 'on_close' (the default for JDBC).");, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java, + * <p><b>NOTE: Hibernate 4.2+ is strongly recommended for efficient transaction, + * management with Spring, in particular for transactional Spring JDBC access.</b>, + *, +							"Hibernate connection release mode is set to 'on_close' (the default for JDBC).");, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java, + * Copyright 2002-2014 the original author or authors., +import org.springframework.jdbc.datasource.DataSourceUtils;, +import org.springframework.transaction.InvalidIsolationLevelException;, + * @author Costin Leau, +	private boolean prepareConnection = (HibernateConnectionHandle.sessionConnectionMethod == null);, +, +, +	/**, +	 * Set whether to prepare the underlying JDBC Connection of a transactional, +	 * Hibernate Session, that is, whether to apply a transaction-specific, +	 * isolation level and/or the transaction's read-only flag to the underlying, +	 * JDBC Connection., +	 * <p>Default is "true" on Hibernate EntityManager 4.x (with its 'on-close', +	 * connection release mode, and "false" on Hibernate EntityManager 3.6 (due to, +	 * the 'after-transaction' release mode there). <b>Note that Hibernate 4.2+ is, +	 * strongly recommended in order to make isolation levels work efficiently.</b>, +	 * <p>If you turn this flag off, JPA transaction management will not support, +	 * per-transaction isolation levels anymore. It will not call, +	 * {@code Connection.setReadOnly(true)} for read-only transactions anymore either., +	 * If this flag is turned off, no cleanup of a JDBC Connection is required after, +	 * a transaction, since no Connection settings will get modified., +	 * @see java.sql.Connection#setTransactionIsolation, +	 * @see java.sql.Connection#setReadOnly, +	 */, +	public void setPrepareConnection(boolean prepareConnection) {, +		this.prepareConnection = prepareConnection;, +	}, +, +, +		Session session = getSession(entityManager);, +, +			session.getTransaction().setTimeout(definition.getTimeout());, +, +		Integer previousIsolationLevel = null;, +		boolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);, +		if (isolationLevelNeeded || definition.isReadOnly()) {, +			if (this.prepareConnection) {, +				Connection con = HibernateConnectionHandle.doGetConnection(session);, +				previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);, +			}, +			else if (isolationLevelNeeded) {, +				throw new InvalidIsolationLevelException(getClass().getSimpleName() +, +						" does not support custom isolation levels since the 'prepareConnection' flag is off. " +, +						"This is the case on Hibernate 3.6 by default; either switch that flag at your own risk " +, +						"or upgrade to Hibernate 4.x, with 4.2+ recommended.");, +			}, +		}, +, +		// Standard JPA transaction begin call for full JPA context setup..., +		entityManager.getTransaction().begin();, +, +		// Adapt flush mode and store previous isolation level, if any., +		return doPrepareTransaction(session, definition.isReadOnly(), previousIsolationLevel);, +		return doPrepareTransaction(getSession(entityManager), readOnly, null);, +	}, +, +	protected Object doPrepareTransaction(Session session, boolean readOnly, Integer previousIsolationLevel), +			throws PersistenceException {, +, +, +		boolean resetConnection = (previousIsolationLevel != null || readOnly);, +		return new SessionTransactionData(session, previousFlushMode, resetConnection, previousIsolationLevel);, +		((SessionTransactionData) transactionData).resetSessionState();, +		private final boolean connectionReset;, +, +		private final Integer previousIsolationLevel;, +, +		public SessionTransactionData(, +				Session session, FlushMode previousFlushMode, boolean resetConnection, Integer previousIsolationLevel) {, +			this.connectionReset = resetConnection;, +			this.previousIsolationLevel = previousIsolationLevel;, +		public void resetSessionState() {, +			if (this.connectionReset && this.session.isConnected()) {, +				Connection con = HibernateConnectionHandle.doGetConnection(this.session);, +				DataSourceUtils.resetConnectionAfterTransaction(con, this.previousIsolationLevel);, +			}, +			return doGetConnection(this.session);, +, +		public static Connection doGetConnection(Session session) {, +			try {, +				if (connectionMethodToUse == null) {, +					// Reflective lookup trying to find SessionImpl's connection() on Hibernate 4.x, +					connectionMethodToUse = session.getClass().getMethod("connection");, +				}, +				return (Connection) ReflectionUtils.invokeMethod(connectionMethodToUse, session);, +			}, +			catch (NoSuchMethodException ex) {, +				throw new IllegalStateException("Cannot find connection() method on Hibernate Session", ex);, +			}]