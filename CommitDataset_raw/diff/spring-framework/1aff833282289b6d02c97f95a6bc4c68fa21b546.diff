[+++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, +	private static final int DEFAULT_CONCURRENCY_LEVEL = 16;, +, +		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative");, +		Assert.isTrue(loadFactor > 0f, "Load factor must be positive");, +		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive");, +		 * {@code ReferenceManager#pollForPurge()}., +	 * Various options supported by a {@code Task}., +++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, +	private static final int DEFAULT_CONCURRENCY_LEVEL = 16;, +, +		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative");, +		Assert.isTrue(loadFactor > 0f, "Load factor must be positive");, +		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive");, +		 * {@code ReferenceManager#pollForPurge()}., +	 * Various options supported by a {@code Task}., +++ b/spring-core/src/test/java/org/springframework/util/ConcurrentReferenceHashMapTests.java, + * Copyright 2002-2013 the original author or authors., +, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.*;, +, + *, +, +		ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<Integer, String>(32);, +		ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<Integer, String>(32, 0.5f);, +		ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<Integer, String>(16, 2);, +		ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<Integer, String>(5, 0.5f, 3);, +		this.thrown.expectMessage("Initial capacity must not be negative");, +		this.thrown.expectMessage("Load factor must be positive");, +	public void shouldNeedPositiveConcurrencyLevel() throws Exception {, +		new ConcurrentReferenceHashMap<Integer, String>(1, 1);, +		this.thrown.expect(IllegalArgumentException.class);, +		this.thrown.expectMessage("Concurrency level must be positive");, +		new TestWeakConcurrentCache<Integer, String>(1, 0);, +	}, +, +	@Test, +, +				}, +		for (Thread thread : threads) {, +			thread.start();, +		for (Thread thread : threads) {, +			if (thread.isAlive()) {, +				thread.join(2000);, +, +, +	private static class TestWeakConcurrentCache<K, V> extends ConcurrentReferenceHashMap<K, V> {, +		public TestWeakConcurrentCache(int initialCapacity, float loadFactor, int concurrencyLevel) {, +, +		public MockReference(Entry<K, V> entry, int hash, Reference<K, V> next, LinkedList<MockReference<K, V>> queue) {, +]