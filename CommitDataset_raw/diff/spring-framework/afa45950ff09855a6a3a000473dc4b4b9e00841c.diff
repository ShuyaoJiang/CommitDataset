[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunction.java, +	 * <p>The given {@linkplain ExchangeFunction} represents the next entity, +	 * in the chain, to be invoked via, +	 * {@linkplain ExchangeFunction#exchange(ClientRequest) invoked} in order to, +	 * proceed with the exchange, or not invoked to shortcut the chain., +	 * @param request the current request, +	 * Return a composed filter function that first applies this filter, and, +	 * then applies the given {@code "after"} filter., +	 * @param afterFilter the filter to apply after this filter, +	 * @return the composed filter, +	default ExchangeFilterFunction andThen(ExchangeFilterFunction afterFilter) {, +		Assert.notNull(afterFilter, "ExchangeFilterFunction must not be null");, +		return (request, next) ->, +				filter(request, afterRequest -> afterFilter.filter(afterRequest, next));, +	 * Apply this filter to the given {@linkplain ExchangeFunction}, resulting, +	 * in a filtered exchange function., +	 * Adapt the given request processor function to a filter function that only, +	 * operates on the {@code ClientRequest}., +	 * @param processor the request processor, +	 * @return the resulting filter adapter, +	static ExchangeFilterFunction ofRequestProcessor(Function<ClientRequest, Mono<ClientRequest>> processor) {, +		Assert.notNull(processor, "ClientRequest Function must not be null");, +		return (request, next) -> processor.apply(request).flatMap(next::exchange);, +	 * Adapt the given response processor function to a filter function that, +	 * only operates on the {@code ClientResponse}., +	 * @param processor the response processor, +	 * @return the resulting filter adapter, +	static ExchangeFilterFunction ofResponseProcessor(Function<ClientResponse, Mono<ClientResponse>> processor) {, +		Assert.notNull(processor, "ClientResponse Function must not be null");, +		return (request, next) -> next.exchange(request).flatMap(processor);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunction.java, +	 * <p>The given {@linkplain ExchangeFunction} represents the next entity, +	 * in the chain, to be invoked via, +	 * {@linkplain ExchangeFunction#exchange(ClientRequest) invoked} in order to, +	 * proceed with the exchange, or not invoked to shortcut the chain., +	 * @param request the current request, +	 * Return a composed filter function that first applies this filter, and, +	 * then applies the given {@code "after"} filter., +	 * @param afterFilter the filter to apply after this filter, +	 * @return the composed filter, +	default ExchangeFilterFunction andThen(ExchangeFilterFunction afterFilter) {, +		Assert.notNull(afterFilter, "ExchangeFilterFunction must not be null");, +		return (request, next) ->, +				filter(request, afterRequest -> afterFilter.filter(afterRequest, next));, +	 * Apply this filter to the given {@linkplain ExchangeFunction}, resulting, +	 * in a filtered exchange function., +	 * Adapt the given request processor function to a filter function that only, +	 * operates on the {@code ClientRequest}., +	 * @param processor the request processor, +	 * @return the resulting filter adapter, +	static ExchangeFilterFunction ofRequestProcessor(Function<ClientRequest, Mono<ClientRequest>> processor) {, +		Assert.notNull(processor, "ClientRequest Function must not be null");, +		return (request, next) -> processor.apply(request).flatMap(next::exchange);, +	 * Adapt the given response processor function to a filter function that, +	 * only operates on the {@code ClientResponse}., +	 * @param processor the response processor, +	 * @return the resulting filter adapter, +	static ExchangeFilterFunction ofResponseProcessor(Function<ClientResponse, Mono<ClientResponse>> processor) {, +		Assert.notNull(processor, "ClientResponse Function must not be null");, +		return (request, next) -> next.exchange(request).flatMap(processor);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunctions.java, + * Static factory methods providing access to built-in implementations of, + * {@link ExchangeFilterFunction} for basic authentication, error handling, etc., +	 * Name of the {@linkplain ClientRequest#attributes() request attribute} that, +	 * contains the {@link Credentials} used by {@link #basicAuthentication()}., +	 * Return a filter for HTTP Basic Authentication that adds an authorization, +	 * header, based on the given user and password., +	 * @param user the user, +	 * @param password the password, +	 * @return the filter for basic authentication, +	 * @throws IllegalArgumentException if either {@code user} or, +	 * {@code password} contain characters that cannot be encoded to ISO-8859-1., +	public static ExchangeFilterFunction basicAuthentication(String user, String password) {, +		Assert.notNull(user, "'user' must not be null");, +		checkIllegalCharacters(user, password);, +		return basicAuthenticationInternal(request -> Optional.of(new Credentials(user, password)));, +	 * Variant of {@link #basicAuthentication(String, String)} that looks up, +	 * the {@link Credentials Credentials} provided in a, +	 * {@linkplain ClientRequest#attributes() request attribute}, or if the, +	 * attribute is not found, the authorization header is not added., +	 * @return the filter for basic authentication, +		return basicAuthenticationInternal(request ->, +				request.attribute(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE), +						.map(credentials -> (Credentials) credentials));, +		return ExchangeFilterFunction.ofRequestProcessor(request ->, +				credentialsFunction.apply(request), +						.map(credentials -> Mono.just(insertAuthorizationHeader(request, credentials))), +						.orElse(Mono.just(request)));, +, +		// Basic authentication only supports ISO 8859-1, see, +		// https://stackoverflow.com/questions/702629/utf-8-characters-mangled-in-http-basic-auth-username#703341, +, +	}, +	private static ClientRequest insertAuthorizationHeader(ClientRequest request, Credentials credentials) {, +		return ClientRequest.from(request).headers(headers -> {, +			String credentialsString = credentials.username + ":" + credentials.password;, +			byte[] credentialBytes = credentialsString.getBytes(StandardCharsets.ISO_8859_1);, +			byte[] encodedBytes = Base64.getEncoder().encode(credentialBytes);, +			String encodedCredentials = new String(encodedBytes, StandardCharsets.ISO_8859_1);, +			headers.set(HttpHeaders.AUTHORIZATION, "Basic " + encodedCredentials);]