[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +import org.springframework.core.ResolvableType;, +	private static final Map<Class<?>, TypeDescriptor> commonTypesCache = new HashMap<Class<?>, TypeDescriptor>();, +	private static final Class<?>[] CACHED_COMMON_TYPES = { Boolean.class, byte.class,, +		Byte.class, char.class, Character.class, short.class, Short.class, int.class,, +		Integer.class, long.class, Long.class, float.class, Float.class, double.class,, +		Double.class, String.class };, +		for (Class<?> preCachedClass : CACHED_COMMON_TYPES) {, +			commonTypesCache.put(preCachedClass, valueOf(preCachedClass));, +		}, +	private final ResolvableType resolvableType;, +		Assert.notNull(methodParameter, "MethodParameter must not be null");, +		if (methodParameter.getNestingLevel() != 1) {, +			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1");, +		}, +		this.resolvableType = ResolvableType.forMethodParameter(methodParameter);, +		this.type = this.resolvableType.resolve(Object.class);, +		this.annotations = (methodParameter.getParameterIndex() == -1 ?, +				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :, +				nullSafeAnnotations(methodParameter.getParameterAnnotations()));, +		Assert.notNull(field, "Field must not be null");, +		this.resolvableType = ResolvableType.forField(field);, +		this.type = this.resolvableType.resolve(Object.class);, +		this.annotations = nullSafeAnnotations(field.getAnnotations());, +		Assert.notNull(property, "Property must not be null");, +		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter());, +		this.type = this.resolvableType.resolve(Object.class);, +		this.annotations = nullSafeAnnotations(property.getAnnotations());, +	}, +, +	private TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {, +		this.resolvableType = resolvableType;, +		this.type = (type != null ? type : resolvableType.resolve(Object.class));, +		this.annotations = nullSafeAnnotations(annotations);, +	private Annotation[] nullSafeAnnotations(Annotation[] annotations) {, +		return annotations != null ? annotations : EMPTY_ANNOTATION_ARRAY;, +	 * Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type., +	 * <p>This is useful for conversion service implementations that wish to normalize to object-based types, +	 * and not work with primitive types directly., +	public Class<?> getObjectType() {, +		return ClassUtils.resolvePrimitiveIfNecessary(getType());, +		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType);, +		return new TypeDescriptor(narrowed, null, this.annotations);, +		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations);, +		for (Annotation annotation : getAnnotations()) {, +		for (Annotation metaAnn : getAnnotations()) {, +	private boolean isNestedAssignable(TypeDescriptor nestedTypeDescriptor, TypeDescriptor otherNestedTypeDescriptor) {, +		if (nestedTypeDescriptor == null || otherNestedTypeDescriptor == null) {, +			return true;, +		}, +		return nestedTypeDescriptor.isAssignableTo(otherNestedTypeDescriptor);, +	}, +		if (this.resolvableType.isArray()) {, +			return getRelatedIfResolvable(this, this.resolvableType.getComponentType());, +		}, +		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric());, +, +		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0));, +		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1));, +		return getType(getElementTypeDescriptor());, +		return getType(getMapKeyTypeDescriptor());, +		return getType(getMapValueTypeDescriptor());, +	private Class<?> getType(TypeDescriptor typeDescriptor) {, +		return (typeDescriptor == null ? null : typeDescriptor.getType());, +		return (value != null ? new TypeDescriptor(this.resolvableType, value.getClass(), this.annotations) : null);, +		if (getAnnotations().length != other.getAnnotations().length) {, +		for (Annotation ann : this.getAnnotations()) {, +			return ObjectUtils.nullSafeEquals(this.getElementTypeDescriptor(), other.getElementTypeDescriptor());, +			return ObjectUtils.nullSafeEquals(this.getMapKeyTypeDescriptor(), other.getMapKeyTypeDescriptor()) &&, +					ObjectUtils.nullSafeEquals(this.getMapValueTypeDescriptor(), other.getMapValueTypeDescriptor());, +		for (Annotation ann : getAnnotations()) {, +		builder.append(this.resolvableType.toString());, +	/**, +	 * Create a new type descriptor from the given type., +	 * <p>Use this to instruct the conversion system to convert an object to a, +	 * specific target type, when no type location such as a method parameter or, +	 * field is available to provide additional conversion context., +	 * <p>Generally prefer use of {@link #forObject(Object)} for constructing type, +	 * descriptors from source objects, as it handles the {@code null} object case., +	 * @param type the class]