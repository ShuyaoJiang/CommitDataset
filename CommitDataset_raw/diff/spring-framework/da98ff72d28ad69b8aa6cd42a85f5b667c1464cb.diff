[+++ b/spring-web/src/main/java/org/springframework/http/codec/ServerSentEventHttpMessageReader.java, +	private static final ResolvableType STRING_TYPE = ResolvableType.forClass(String.class);, +, +		return stringDecoder.decode(message.getBody(), STRING_TYPE, null, Collections.emptyMap()), +				.bufferUntil(line -> line.equals("")), +				.concatMap(lines -> buildEvent(lines, valueType, shouldWrap, hints));, +	private Mono<?> buildEvent(List<String> lines, ResolvableType valueType, boolean shouldWrap,, +		ServerSentEvent.Builder<Object> sseBuilder = shouldWrap ? ServerSentEvent.builder() : null;, +			if (line.startsWith("data:")) {, +				data = (data != null ? data : new StringBuilder());, +				data.append(line.substring(5)).append("\n");, +			}, +			if (shouldWrap) {, +		}, +, +		Mono<?> decodedData = (data != null ? decodeData(data.toString(), valueType, hints) : Mono.empty());, +, +		if (shouldWrap) {, +			return decodedData.map(o -> {, +				sseBuilder.data(o);, +			return decodedData;, +++ b/spring-web/src/main/java/org/springframework/http/codec/ServerSentEventHttpMessageReader.java, +	private static final ResolvableType STRING_TYPE = ResolvableType.forClass(String.class);, +, +		return stringDecoder.decode(message.getBody(), STRING_TYPE, null, Collections.emptyMap()), +				.bufferUntil(line -> line.equals("")), +				.concatMap(lines -> buildEvent(lines, valueType, shouldWrap, hints));, +	private Mono<?> buildEvent(List<String> lines, ResolvableType valueType, boolean shouldWrap,, +		ServerSentEvent.Builder<Object> sseBuilder = shouldWrap ? ServerSentEvent.builder() : null;, +			if (line.startsWith("data:")) {, +				data = (data != null ? data : new StringBuilder());, +				data.append(line.substring(5)).append("\n");, +			}, +			if (shouldWrap) {, +		}, +, +		Mono<?> decodedData = (data != null ? decodeData(data.toString(), valueType, hints) : Mono.empty());, +, +		if (shouldWrap) {, +			return decodedData.map(o -> {, +				sseBuilder.data(o);, +			return decodedData;, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/SseIntegrationTests.java, +import org.junit.Assume;, +import org.springframework.http.server.reactive.bootstrap.JettyHttpServer;, +import org.springframework.web.bind.annotation.RequestMapping;, +, +		Assume.assumeTrue(server instanceof JettyHttpServer);, +, +		Flux<ServerSentEvent<Person>> result = this.webClient.get(), +				.bodyToFlux(new ParameterizedTypeReference<ServerSentEvent<Person>>() {});, +		verifyPersonEvents(result);, +		Flux<ServerSentEvent<Person>> result = this.webClient.get(), +				.bodyToFlux(new ParameterizedTypeReference<ServerSentEvent<Person>>() {});, +		verifyPersonEvents(result);, +	}, +, +	private void verifyPersonEvents(Flux<ServerSentEvent<Person>> result) {, +					assertEquals(new Person("foo 0"), event.data());, +					assertEquals("bar 0", event.comment());, +					assertEquals(new Person("foo 1"), event.data());, +					assertEquals("bar 1", event.comment());, +	@RequestMapping("/sse"), +		@GetMapping("/string"), +		@GetMapping("/person"), +		@GetMapping("/event"), +		Flux<ServerSentEvent<Person>> sse() {, +			return INTERVAL.take(2).map(l ->, +					ServerSentEvent.builder(new Person("foo " + l)), +							.comment("bar " + l), +		@GetMapping("/infinite")]