[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.core.OrderComparator;, +import org.springframework.core.Ordered;, +		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();, +		if (!memberClasses.isEmpty()) {, +			List<SourceClass> candidates = new ArrayList<>(memberClasses.size());, +			for (SourceClass memberClass : memberClasses) {, +					candidates.add(memberClass);, +				}, +			}, +			OrderComparator.sort(candidates);, +			for (SourceClass candidate : candidates) {, +						processConfigurationClass(candidate.asConfigClass(configClass));, +	private class SourceClass implements Ordered {, +		@Override, +		public int getOrder() {, +			Integer order = ConfigurationClassUtils.getOrder(this.metadata);, +			return (order != null ? order : Ordered.LOWEST_PRECEDENCE);, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.core.OrderComparator;, +import org.springframework.core.Ordered;, +		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();, +		if (!memberClasses.isEmpty()) {, +			List<SourceClass> candidates = new ArrayList<>(memberClasses.size());, +			for (SourceClass memberClass : memberClasses) {, +					candidates.add(memberClass);, +				}, +			}, +			OrderComparator.sort(candidates);, +			for (SourceClass candidate : candidates) {, +						processConfigurationClass(candidate.asConfigClass(configClass));, +	private class SourceClass implements Ordered {, +		@Override, +		public int getOrder() {, +			Integer order = ConfigurationClassUtils.getOrder(this.metadata);, +			return (order != null ? order : Ordered.LOWEST_PRECEDENCE);, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java, + * Copyright 2002-2017 the original author or authors., +		Integer order = getOrder(metadata);, +		if (order != null) {, +			beanDef.setAttribute(ORDER_ATTRIBUTE, order);, +	 * Determine the order for the given configuration class metadata., +	 * @param metadata the metadata of the annotated class, +	 * @return the {@link @Order} annotation value on the configuration class,, +	 * or {@link Ordered#LOWEST_PRECEDENCE} if none declared, +	 * @since 5.0, +	 */, +	public static Integer getOrder(AnnotationMetadata metadata) {, +		Map<String, Object> orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());, +		return (orderAttributes != null ? ((Integer) orderAttributes.get(AnnotationUtils.VALUE)) : null);, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.core.OrderComparator;, +import org.springframework.core.Ordered;, +		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();, +		if (!memberClasses.isEmpty()) {, +			List<SourceClass> candidates = new ArrayList<>(memberClasses.size());, +			for (SourceClass memberClass : memberClasses) {, +					candidates.add(memberClass);, +				}, +			}, +			OrderComparator.sort(candidates);, +			for (SourceClass candidate : candidates) {, +						processConfigurationClass(candidate.asConfigClass(configClass));, +	private class SourceClass implements Ordered {, +		@Override, +		public int getOrder() {, +			Integer order = ConfigurationClassUtils.getOrder(this.metadata);, +			return (order != null ? order : Ordered.LOWEST_PRECEDENCE);, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java, + * Copyright 2002-2017 the original author or authors., +		Integer order = getOrder(metadata);, +		if (order != null) {, +			beanDef.setAttribute(ORDER_ATTRIBUTE, order);, +	 * Determine the order for the given configuration class metadata., +	 * @param metadata the metadata of the annotated class, +	 * @return the {@link @Order} annotation value on the configuration class,, +	 * or {@link Ordered#LOWEST_PRECEDENCE} if none declared, +	 * @since 5.0, +	 */, +	public static Integer getOrder(AnnotationMetadata metadata) {, +		Map<String, Object> orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());, +		return (orderAttributes != null ? ((Integer) orderAttributes.get(AnnotationUtils.VALUE)) : null);, +	}, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassPostProcessorTests.java, +	public void nestedConfigurationClassesProcessedInCorrectOrder() {, +		beanFactory.registerBeanDefinition("config", new RootBeanDefinition(ConfigWithOrderedNestedClasses.class));, +		ConfigurationClassPostProcessor pp = new ConfigurationClassPostProcessor();, +		pp.postProcessBeanFactory(beanFactory);, +]