[+++ /dev/null, +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriter.java, + * {@code HttpMessageWriter} for {@code "multipart/form-data"} requests., + * <p>This writer delegates to other message writers to write the respective, + * parts. By default basic writers are registered for {@code String}, and, + * {@code Resources}. These can be overridden through the provided constructors., + * @author Rossen Stoyanchev, +	private final List<HttpMessageWriter<?>> partWriters;, +	public MultipartHttpMessageWriter(List<HttpMessageWriter<?>> partWriters, DataBufferFactory factory) {, +		this.bufferFactory = factory;, +	public List<MediaType> getWritableMediaTypes() {, +		return Collections.singletonList(MediaType.MULTIPART_FORM_DATA);, +	}, +, +	@Override, +		return MultiValueMap.class.isAssignableFrom(elementType.getRawClass()) &&, +				(mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType));, +		byte[] boundary = generateMultipartBoundary();, +		headers.setContentType(new MediaType(MediaType.MULTIPART_FORM_DATA,, +				Collections.singletonMap("boundary", new String(boundary, StandardCharsets.US_ASCII))));, +		return Mono.from(inputStream).flatMap(multiValueMap ->, +				outputMessage.writeWith(generateParts(multiValueMap, boundary)));, +	}, +, +	/**, +	 * Generate a multipart boundary., +	 * <p>By default delegates to {@link MimeTypeUtils#generateMultipartBoundary()}., +	 */, +	protected byte[] generateMultipartBoundary() {, +		return MimeTypeUtils.generateMultipartBoundary();, +	}, +, +	private Flux<DataBuffer> generateParts(MultiValueMap<String, ?> map, byte[] boundary) {, +		return Flux.fromIterable(map.entrySet()), +				.concatMap(entry -> Flux, +						.fromIterable(entry.getValue()), +						.concatMap(value -> generatePart(entry.getKey(), value, boundary))), +	private <T> Flux<DataBuffer> generatePart(String name, T value, byte[] boundary) {, +		MultipartHttpOutputMessage outputMessage = new MultipartHttpOutputMessage(this.bufferFactory);, +, +		T body;, +		if (value instanceof HttpEntity) {, +			outputMessage.getHeaders().putAll(((HttpEntity<T>) value).getHeaders());, +			body = ((HttpEntity<T>) value).getBody();, +		}, +		else {, +			body = value;, +		}, +, +		ResolvableType bodyType = ResolvableType.forClass(body.getClass());, +		outputMessage.getHeaders().setContentDispositionFormData(name, getFilename(body));, +, +		MediaType contentType = outputMessage.getHeaders().getContentType();, +, +		Optional<HttpMessageWriter<?>> writer = this.partWriters.stream(), +				.filter(partWriter -> partWriter.canWrite(bodyType, contentType)), +			return Flux.error(new CodecException("No suitable writer found for part: " + name));, +, +		Mono<Void> partWritten = ((HttpMessageWriter<T>) writer.get()), +				.write(Mono.just(body), bodyType, contentType, outputMessage, Collections.emptyMap());, +	 * Return the filename of the given multipart part. This value will be used, +	 * for the {@code Content-Disposition} header., +	 * <p>The default implementation returns {@link Resource#getFilename()} if, +	 * the part is a {@code Resource}, and {@code null} in other cases., +	 * @param part the part for which return a file name, +	 * @return the filename or {@code null}, +		public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {, +			return Mono.error(new UnsupportedOperationException());, +			return (this.body != null ? this.body :, +					Flux.error(new IllegalStateException("Body has not been written yet")));, +, +		@Override, +		public Mono<Void> setComplete() {, +			return (this.body != null ? this.body.then() :, +					Mono.error(new IllegalStateException("Body has not been written yet")));, +		}, +, +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriter.java, + * {@code HttpMessageWriter} for {@code "multipart/form-data"} requests., + * <p>This writer delegates to other message writers to write the respective, + * parts. By default basic writers are registered for {@code String}, and, + * {@code Resources}. These can be overridden through the provided constructors., + * @author Rossen Stoyanchev, +	private final List<HttpMessageWriter<?>> partWriters;, +	public MultipartHttpMessageWriter(List<HttpMessageWriter<?>> partWriters, DataBufferFactory factory) {, +		this.bufferFactory = factory;, +	public List<MediaType> getWritableMediaTypes() {, +		return Collections.singletonList(MediaType.MULTIPART_FORM_DATA);, +	}, +, +	@Override, +		return MultiValueMap.class.isAssignableFrom(elementType.getRawClass()) &&, +				(mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType));, +		byte[] boundary = generateMultipartBoundary();, +		headers.setContentType(new MediaType(MediaType.MULTIPART_FORM_DATA,, +				Collections.singletonMap("boundary", new String(boundary, StandardCharsets.US_ASCII))));, +		return Mono.from(inputStream).flatMap(multiValueMap ->, +				outputMessage.writeWith(generateParts(multiValueMap, boundary)));]