[+++ b/spring-context/src/main/java/org/springframework/cache/concurrent/ConcurrentMapCache.java, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import org.springframework.core.serializer.support.SerializationDelegate;, + * @author Stephane Nicoll, +	private final SerializationDelegate serialization;, +, +		this(name, store, allowNullValues, null);, +	}, +, +	/**, +	 * Create a new ConcurrentMapCache with the specified name and the, +	 * given internal {@link ConcurrentMap} to use. If the, +	 * {@link SerializationDelegate} is specified,, +	 * {@link #isStoreByValue() store-by-value} is enabled, +	 * @param name the name of the cache, +	 * @param store the ConcurrentMap to use as an internal store, +	 * @param allowNullValues whether to allow {@code null} values, +	 * (adapting them to an internal null holder value), +	 * @param serialization the {@link SerializationDelegate} to use, +	 * to serialize cache entry or {@code null} to store the reference, +	 */, +	protected ConcurrentMapCache(String name, ConcurrentMap<Object, Object> store,, +			boolean allowNullValues, SerializationDelegate serialization) {, +, +		this.serialization = serialization;, +	/**, +	 * Return whether this cache stores a copy of each entry ({@code true}) or, +	 * a reference ({@code false}, default). If store by value is enabled, each, +	 * entry in the cache must be serializable., +	 */, +	public final boolean isStoreByValue() {, +		return this.serialization != null;, +	}, +	@Override, +	protected Object toStoreValue(Object userValue) {, +		Object storeValue = super.toStoreValue(userValue);, +		if (this.serialization != null) {, +			try {, +				return serializeValue(storeValue);, +			}, +			catch (Exception ex) {, +				throw new IllegalArgumentException("Failed to serialize cache value '", +						+ userValue + "'. Does it implement Serializable?", ex);, +			}, +		}, +		else {, +			return storeValue;, +		}, +	}, +, +	private Object serializeValue(Object storeValue) throws IOException {, +		ByteArrayOutputStream out = new ByteArrayOutputStream();, +		try {, +			this.serialization.serialize(storeValue, out);, +			return out.toByteArray();, +		}, +		finally {, +			out.close();, +		}, +	}, +, +	@Override, +	protected Object fromStoreValue(Object storeValue) {, +		if (this.serialization != null) {, +			try {, +				return super.fromStoreValue(deserializeValue(storeValue));, +			}, +			catch (Exception ex) {, +				throw new IllegalArgumentException("Failed to deserialize cache value '" +, +						storeValue + "'", ex);, +			}, +		}, +		else {, +			return super.fromStoreValue(storeValue);, +		}, +, +	}, +, +	private Object deserializeValue(Object storeValue) throws IOException {, +		ByteArrayInputStream in = new ByteArrayInputStream((byte[]) storeValue);, +		try {, +			return this.serialization.deserialize(in);, +		}, +		finally {, +			in.close();, +		}, +	}, +, +++ b/spring-context/src/main/java/org/springframework/cache/concurrent/ConcurrentMapCache.java, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import org.springframework.core.serializer.support.SerializationDelegate;, + * @author Stephane Nicoll, +	private final SerializationDelegate serialization;, +, +		this(name, store, allowNullValues, null);, +	}]