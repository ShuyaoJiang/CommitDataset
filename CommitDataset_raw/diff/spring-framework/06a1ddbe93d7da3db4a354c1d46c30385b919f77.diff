[+++ b/spring-web-reactive/src/main/java/org/springframework/reactive/util/CompletableFutureUtils.java, +import reactor.Publishers;, +import reactor.core.error.CancelException;, +import reactor.core.error.Exceptions;, +import reactor.core.support.BackpressureUtils;, +, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, + * @author Stephane Maldini, +		return new CompletableFuturePublisher<T>(future);, +	private static class CompletableFuturePublisher<T> implements Publisher<T> {, +		private final Publisher<? extends T> futurePublisher;, +		@SuppressWarnings("unused"), +		private volatile long requested;, +		private static final AtomicLongFieldUpdater<CompletableFuturePublisher> REQUESTED =, +		  AtomicLongFieldUpdater.newUpdater(CompletableFuturePublisher.class, "requested");, +, +		public CompletableFuturePublisher(CompletableFuture<? extends T> future) {, +			this.futurePublisher = Publishers.createWithDemand((n, sub) -> {, +, +				if (!BackpressureUtils.checkRequest(n, sub)) {, +					return;, +				}, +, +				if(BackpressureUtils.getAndAdd(REQUESTED, CompletableFuturePublisher.this, n) > 0) {, +					return;, +				}, +, +				future.whenComplete((result, error) -> {, +					if (error != null) {, +						sub.onError(error);, +					} else {, +						sub.onNext(result);, +						sub.onComplete();, +					}, +				});, +			}, null, nothing -> {, +			  if(!future.isDone()){, +				  future.cancel(true);, +			  }, +			});, +				if (future.isDone()) {, +					Publishers.just(future.get()).subscribe(subscriber);, +				else if ( future.isCancelled()){, +					Exceptions.publisher(CancelException.get());, +				else {, +					futurePublisher.subscribe(subscriber);]