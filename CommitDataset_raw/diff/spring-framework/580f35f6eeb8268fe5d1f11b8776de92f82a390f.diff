[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +			if (desiredTokenKind == TokenKind.IDENTIFIER) {, +				// might be one of the textual forms of the operators (e.g. NE for != ) - in which case we can treat it as an identifier, +				// The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum, +				if (t.kind.ordinal()>=TokenKind.DIV.ordinal() && t.kind.ordinal()<=TokenKind.NOT.ordinal() && t.data!=null) {, +					// if t.data were null, we'd know it wasn't the textual form, it was the symbol form, +					return true;, +				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +			if (desiredTokenKind == TokenKind.IDENTIFIER) {, +				// might be one of the textual forms of the operators (e.g. NE for != ) - in which case we can treat it as an identifier, +				// The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum, +				if (t.kind.ordinal()>=TokenKind.DIV.ordinal() && t.kind.ordinal()<=TokenKind.NOT.ordinal() && t.data!=null) {, +					// if t.data were null, we'd know it wasn't the textual form, it was the symbol form, +					return true;, +				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"),  MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	DIV("/"), GE(">="), GT(">"), LE("<="), LT("<"), EQ("=="), NE("!="),, +	MOD("%"), NOT("!"), ASSIGN("="), INSTANCEOF("instanceof"), MATCHES("matches"), BETWEEN("between"),, +	SELECT("?["),   POWER("^"),, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +			if (desiredTokenKind == TokenKind.IDENTIFIER) {, +				// might be one of the textual forms of the operators (e.g. NE for != ) - in which case we can treat it as an identifier, +				// The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum, +				if (t.kind.ordinal()>=TokenKind.DIV.ordinal() && t.kind.ordinal()<=TokenKind.NOT.ordinal() && t.data!=null) {, +					// if t.data were null, we'd know it wasn't the textual form, it was the symbol form, +					return true;, +				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"),  MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	DIV("/"), GE(">="), GT(">"), LE("<="), LT("<"), EQ("=="), NE("!="),, +	MOD("%"), NOT("!"), ASSIGN("="), INSTANCEOF("instanceof"), MATCHES("matches"), BETWEEN("between"),, +	SELECT("?["),   POWER("^"),, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +				pushOneCharOrTwoCharToken(TokenKind.valueOf(asString),start,subarray);, +	private void pushOneCharOrTwoCharToken(TokenKind kind, int pos, char[] data) {, +		tokens.add(new Token(kind,data,pos,pos+kind.getLength()));, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +			if (desiredTokenKind == TokenKind.IDENTIFIER) {, +				// might be one of the textual forms of the operators (e.g. NE for != ) - in which case we can treat it as an identifier, +				// The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum, +				if (t.kind.ordinal()>=TokenKind.DIV.ordinal() && t.kind.ordinal()<=TokenKind.NOT.ordinal() && t.data!=null) {, +					// if t.data were null, we'd know it wasn't the textual form, it was the symbol form, +					return true;, +				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"),  MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	DIV("/"), GE(">="), GT(">"), LE("<="), LT("<"), EQ("=="), NE("!="),, +	MOD("%"), NOT("!"), ASSIGN("="), INSTANCEOF("instanceof"), MATCHES("matches"), BETWEEN("between"),, +	SELECT("?["),   POWER("^"),, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +				pushOneCharOrTwoCharToken(TokenKind.valueOf(asString),start,subarray);, +	private void pushOneCharOrTwoCharToken(TokenKind kind, int pos, char[] data) {, +		tokens.add(new Token(kind,data,pos,pos+kind.getLength()));, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/SpringEL300Tests.java, +, +	@Test, +	public void testReservedWords_8228() throws Exception {, +		// "DIV","EQ","GE","GT","LE","LT","MOD","NE","NOT", +        @SuppressWarnings("unused"), +        class Reserver {, +        	public Reserver getReserver() {, +        		return this;, +        	}, +        	public String NE = "abc";, +        	public String ne = "def";, +        	, +        	public int DIV = 1;, +        	public int div = 3;, +        	, +        	public Map m = new HashMap();, +        	, +        	@SuppressWarnings("unchecked"), +			Reserver() {, +        		m.put("NE","xyz");, +        	}, +        }, +        StandardEvaluationContext ctx = new StandardEvaluationContext(new Reserver());, +        SpelExpressionParser parser = new SpelExpressionParser();, +        String ex = "getReserver().NE";, +        SpelExpression exp = null;, +        exp = parser.parseRaw(ex);, +        String value = (String)exp.getValue(ctx);, +        Assert.assertEquals("abc",value);, +, +        ex = "getReserver().ne";, +        exp = parser.parseRaw(ex);, +        value = (String)exp.getValue(ctx);, +        Assert.assertEquals("def",value);, +, +        ex = "getReserver().m[NE]";, +        exp = parser.parseRaw(ex);, +        value = (String)exp.getValue(ctx);, +        Assert.assertEquals("xyz",value);, +        ]