[+++ b/org.springframework.core/src/main/java/org/springframework/core/convert/ConversionService.java, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/ConversionService.java, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	 * Constant value typeDescriptor for the type of a null value, +			return wrapperType(type);, +			return wrapperType(field.getType());, +			return wrapperType(methodParameter.getParameterType());, +	private Class<?> wrapperType(Class<?> type) {, +		if (type.isPrimitive()) {, +			if (type.equals(int.class)) {, +				return Integer.class;, +			} else if (type.equals(short.class)) {, +				return Short.class;, +			} else if (type.equals(long.class)) {, +				return Long.class;, +			} else if (type.equals(float.class)) {, +				return Float.class;, +			} else if (type.equals(double.class)) {, +				return Double.class;, +			} else if (type.equals(byte.class)) {, +				return Byte.class;, +			} else if (type.equals(boolean.class)) {, +				return Boolean.class;, +			} else if (type.equals(char.class)) {, +				return Character.class;, +			} else {, +				throw new IllegalStateException("Should never happen - primitive type is not a primitive?");, +			}, +		} else {, +			return type;, +		}, +	}, +	, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/ConversionService.java, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	 * Constant value typeDescriptor for the type of a null value, +			return wrapperType(type);, +			return wrapperType(field.getType());, +			return wrapperType(methodParameter.getParameterType());, +	private Class<?> wrapperType(Class<?> type) {, +		if (type.isPrimitive()) {, +			if (type.equals(int.class)) {, +				return Integer.class;, +			} else if (type.equals(short.class)) {, +				return Short.class;, +			} else if (type.equals(long.class)) {, +				return Long.class;, +			} else if (type.equals(float.class)) {, +				return Float.class;, +			} else if (type.equals(double.class)) {, +				return Double.class;, +			} else if (type.equals(byte.class)) {, +				return Byte.class;, +			} else if (type.equals(boolean.class)) {, +				return Boolean.class;, +			} else if (type.equals(char.class)) {, +				return Character.class;, +			} else {, +				throw new IllegalStateException("Should never happen - primitive type is not a primitive?");, +			}, +		} else {, +			return type;, +		}, +	}, +	, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java, +	 * value is a Map that defines the targetType-to-Converter mappings for that source., +	private final Map sourceTypeConverters = new HashMap();, +	 * Map.Entry value is a Map that defines the targetType-to-SuperConverter mappings for that source., +	private final Map sourceTypeSuperConverters = new HashMap();, +		Class sourceType = (Class) typeInfo.get(0);, +		Class targetType = (Class) typeInfo.get(1);, +		Map sourceMap = getSourceMap(sourceType);, +		sourceMap.put(targetType, converter);, +		sourceMap = getSourceMap(targetType);, +		sourceMap.put(sourceType, new ReverseConverter(converter));, +		Class sourceType = (Class) typeInfo.get(0);, +		Class targetType = (Class) typeInfo.get(1);, +		Map sourceMap = getSourceSuperConverterMap(sourceType);, +		sourceMap.put(targetType, converter);, +			sourceMap = getSourceSuperConverterMap(targetType);, +			sourceMap.put(sourceType, new ReverseSuperConverter((SuperTwoWayConverter) converter));, +	 * @param sourceType the source class S to convert from, which must be equal or extend BS, +	 * @param targetType the target type T to convert to, which must equal or extend BT, +	public static <S, T> Converter<S, T> converterFor(Class<S> sourceType, Class<T> targetType,, +		return new SuperTwoWayConverterConverter(converter, sourceType, targetType);, +	public boolean canConvert(Class<?> sourceType, TypeDescriptor targetType) {, +		try {, +			getConversionExecutor(sourceType, targetType);, +			return true;, +		} catch (ConversionExecutorNotFoundException e) {, +	}, +		if (source == null) {, +			return true;, +		}, +		try {, +			getConversionExecutor(source.getClass(), targetType);, +			return true;, +		} catch (ConversionExecutorNotFoundException e) {, +	}]