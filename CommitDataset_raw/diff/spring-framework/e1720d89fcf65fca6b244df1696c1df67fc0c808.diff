[+++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationReadingVisitorUtils.java, +import org.springframework.core.annotation.AnnotationUtils;, +		// To start with, we populate the results with a copy of all attribute, +		// values from the target annotation. A copy is necessary so that we do, +		// not inadvertently mutate the state of the metadata passed to this, +		// method., +		AnnotationAttributes results = new AnnotationAttributes(attributesList.get(0));, +		overridableAttributeNames.remove(AnnotationUtils.VALUE);, +		// No need to revisit the target annotation type:, +		annotationTypes.remove(annotationType);, +, +++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationReadingVisitorUtils.java, +import org.springframework.core.annotation.AnnotationUtils;, +		// To start with, we populate the results with a copy of all attribute, +		// values from the target annotation. A copy is necessary so that we do, +		// not inadvertently mutate the state of the metadata passed to this, +		// method., +		AnnotationAttributes results = new AnnotationAttributes(attributesList.get(0));, +		overridableAttributeNames.remove(AnnotationUtils.VALUE);, +		// No need to revisit the target annotation type:, +		annotationTypes.remove(annotationType);, +, +++ b/spring-core/src/test/java/org/springframework/core/type/AnnotationMetadataTests.java, +import org.springframework.util.MultiValueMap;, +	/**, +	 * @param metadata the metadata for {@link ComposedConfigurationWithAttributeOverridesClass}, +	 */, +		assertAllAttributesForMetaAnnotationOverrides(metadata);, +		assertAttributesForMetaAnnotationOverrides(metadata);, +, +		// SPR-11710: Invoke a 2nd time after invoking getAnnotationAttributes() in order, +		// to ensure that getMergedAnnotationAttributes() in AnnotationReadingVisitorUtils, +		// does not mutate the state of the metadata., +		assertAllAttributesForMetaAnnotationOverrides(metadata);, +	}, +, +	/**, +	 * @param metadata the metadata for {@link ComposedConfigurationWithAttributeOverridesClass}, +	 */, +	private void assertAttributesForMetaAnnotationOverrides(AnnotationMetadata metadata) {, +	/**, +	 * @param metadata the metadata for {@link ComposedConfigurationWithAttributeOverridesClass}, +	 */, +	private void assertAllAttributesForMetaAnnotationOverrides(AnnotationMetadata metadata) {, +		MultiValueMap<String, Object> map = metadata.getAllAnnotationAttributes(TestComponentScan.class.getName());, +		List<Object> basePackages = map.get("basePackages");, +		assertThat("length of basePackages list", basePackages.size(), is(1));, +, +		// Ideally, the expected base package should be "org.example.componentscan", but, +		// since Spring's annotation processing currently does not support meta-annotation, +		// attribute overrides when searching for "all attributes", the actual value found, +		// is "bogus"., +		String expectedBasePackage = "bogus";, +		assertThat("basePackages[0]", ((String[]) basePackages.get(0))[0], is(expectedBasePackage));, +, +		List<Object> value = map.get("value");, +		assertThat("length of value list", value.size(), is(1));, +		assertThat("length of 0th value array", ((String[]) value.get(0)).length, is(0));, +, +		List<Object> basePackageClasses = map.get("basePackageClasses");, +		assertThat("length of basePackageClasses list", basePackageClasses.size(), is(1));, +		assertThat("length of 0th basePackageClasses array", ((Class<?>[]) basePackageClasses.get(0)).length, is(0));, +	}, +, +		/* Do not delete! This subclassing is intentional. */, +		/* Do not delete! This subclassing is intentional. */]