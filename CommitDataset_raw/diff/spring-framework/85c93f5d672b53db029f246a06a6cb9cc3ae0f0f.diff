[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/ReactorNettyTcpStompClient.java, + * A STOMP over TCP client that uses {@link ReactorNettyTcpClient}., + * @since 5.0, +	 * @param host target host, +	 * @param port target port, +	protected static TcpOperations<byte[]> create(String host, int port, StompDecoder decoder) {, +		return new ReactorNettyTcpClient<>(host, port,, +				new ReactorNettyTcpClient.MessageHandlerConfiguration<>(, +						new DecodingFunction(decoder),, +	private static final class EncodingConsumer implements BiConsumer<ByteBuf, Message<byte[]>> {, +			byteBuf.writeBytes(this.encoder.encode(message));, +	private static final class DecodingFunction implements Function<ByteBuf, List<Message<byte[]>>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/ReactorNettyTcpStompClient.java, + * A STOMP over TCP client that uses {@link ReactorNettyTcpClient}., + * @since 5.0, +	 * @param host target host, +	 * @param port target port, +	protected static TcpOperations<byte[]> create(String host, int port, StompDecoder decoder) {, +		return new ReactorNettyTcpClient<>(host, port,, +				new ReactorNettyTcpClient.MessageHandlerConfiguration<>(, +						new DecodingFunction(decoder),, +	private static final class EncodingConsumer implements BiConsumer<ByteBuf, Message<byte[]>> {, +			byteBuf.writeBytes(this.encoder.encode(message));, +	private static final class DecodingFunction implements Function<ByteBuf, List<Message<byte[]>>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractMonoToListenableFutureAdapter.java, + * Adapts {@link Mono} to {@link ListenableFuture} optionally converting the, + * result Object type {@code <S>} to the expected target type {@code <T>}., + * @since 5.0, +abstract class AbstractMonoToListenableFutureAdapter<S, T> implements ListenableFuture<T> {, +	private final MonoProcessor<S> monoProcessor;, +, +	protected AbstractMonoToListenableFutureAdapter(Mono<S> mono) {, +		Assert.notNull(mono, "'mono' must not be null");, +		this.monoProcessor = mono, +				.doOnSuccess(result -> {, +				.doOnError(this.registry::failure), +		S result = this.monoProcessor.block();, +	public T get(long timeout, TimeUnit unit), +			throws InterruptedException, ExecutionException, TimeoutException {, +, +		Assert.notNull(unit);, +		Duration duration = Duration.ofMillis(TimeUnit.MILLISECONDS.convert(timeout, unit));, +		S result = this.monoProcessor.block(duration);, +		this.monoProcessor.cancel();, +		return this.monoProcessor.isCancelled();, +		return this.monoProcessor.isTerminated();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/ReactorNettyTcpStompClient.java, + * A STOMP over TCP client that uses {@link ReactorNettyTcpClient}., + * @since 5.0, +	 * @param host target host, +	 * @param port target port, +	protected static TcpOperations<byte[]> create(String host, int port, StompDecoder decoder) {, +		return new ReactorNettyTcpClient<>(host, port,, +				new ReactorNettyTcpClient.MessageHandlerConfiguration<>(, +						new DecodingFunction(decoder),, +	private static final class EncodingConsumer implements BiConsumer<ByteBuf, Message<byte[]>> {, +			byteBuf.writeBytes(this.encoder.encode(message));, +	private static final class DecodingFunction implements Function<ByteBuf, List<Message<byte[]>>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractMonoToListenableFutureAdapter.java, + * Adapts {@link Mono} to {@link ListenableFuture} optionally converting the, + * result Object type {@code <S>} to the expected target type {@code <T>}., + * @since 5.0, +abstract class AbstractMonoToListenableFutureAdapter<S, T> implements ListenableFuture<T> {, +	private final MonoProcessor<S> monoProcessor;, +, +	protected AbstractMonoToListenableFutureAdapter(Mono<S> mono) {, +		Assert.notNull(mono, "'mono' must not be null");, +		this.monoProcessor = mono, +				.doOnSuccess(result -> {, +				.doOnError(this.registry::failure), +		S result = this.monoProcessor.block();, +	public T get(long timeout, TimeUnit unit), +			throws InterruptedException, ExecutionException, TimeoutException {, +, +		Assert.notNull(unit);, +		Duration duration = Duration.ofMillis(TimeUnit.MILLISECONDS.convert(timeout, unit));, +		S result = this.monoProcessor.block(duration);, +		this.monoProcessor.cancel();, +		return this.monoProcessor.isCancelled();, +		return this.monoProcessor.isTerminated();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/MonoToListenableFutureAdapter.java, + * Copyright 2002-2016 the original author or authors., + * A Mono-to-ListenableFuture adapter where the source and the target from, + * @since 5.0, +class MonoToListenableFutureAdapter<T> extends AbstractMonoToListenableFutureAdapter<T, T> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/ReactorNettyTcpStompClient.java, + * A STOMP over TCP client that uses {@link ReactorNettyTcpClient}., + * @since 5.0, +	 * @param host target host, +	 * @param port target port, +	protected static TcpOperations<byte[]> create(String host, int port, StompDecoder decoder) {, +		return new ReactorNettyTcpClient<>(host, port,, +				new ReactorNettyTcpClient.MessageHandlerConfiguration<>(, +						new DecodingFunction(decoder),, +	private static final class EncodingConsumer implements BiConsumer<ByteBuf, Message<byte[]>> {, +			byteBuf.writeBytes(this.encoder.encode(message));, +	private static final class DecodingFunction implements Function<ByteBuf, List<Message<byte[]>>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractMonoToListenableFutureAdapter.java, + * Adapts {@link Mono} to {@link ListenableFuture} optionally converting the, + * result Object type {@code <S>} to the expected target type {@code <T>}.]