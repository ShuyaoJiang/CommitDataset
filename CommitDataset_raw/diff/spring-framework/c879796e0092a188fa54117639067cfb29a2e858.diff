[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, +import java.util.Collection;, +import java.util.HashSet;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +import org.springframework.util.PathMatcher;, +	/** Default maximum number of entries for the destination cache: 1024 */, +	public static final int DEFAULT_CACHE_LIMIT = 1024;, +, +, +	/** The maximum number of entries in the cache */, +	private volatile int cacheLimit = DEFAULT_CACHE_LIMIT;, +, +	private PathMatcher pathMatcher = new AntPathMatcher();, +, +	 * Specify the maximum number of entries for the resolved destination cache., +	 * Default is 1024., +	public void setCacheLimit(int cacheLimit) {, +		this.cacheLimit = cacheLimit;, +	}, +, +	/**, +	 * Return the maximum number of entries for the resolved destination cache., +	 */, +	public int getCacheLimit() {, +		return this.cacheLimit;, +	}, +, +	/**, +	 * The PathMatcher to use., +	 */, +	public void setPathMatcher(PathMatcher pathMatcher) {, +	/**, +	 * The configured PathMatcher., +	 */, +	public PathMatcher getPathMatcher() {, +		this.subscriptionRegistry.addSubscription(sessionId, subsId, destination);, +		this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);, +				this.destinationCache.updateAfterRemovedSubscription(destination, sessionId, subsId);, +			this.destinationCache.updateAfterRemovedSession(info);, +		MultiValueMap<String,String> result = this.destinationCache.getSubscriptions(destination);, +		if (result != null) {, +			return result;, +	 * A cache for destinations previously resolved via, +	 * {@link DefaultSubscriptionRegistry#findSubscriptionsInternal(String, Message)}, +	private class DestinationCache {, +		/** Map from destination -> <sessionId, subscriptionId> */, +		@SuppressWarnings("serial"), +		private final Map<String, MultiValueMap<String, String>> cache =, +				new LinkedHashMap<String, MultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT, 0.75f, true) {, +					@Override, +					protected boolean removeEldestEntry(Map.Entry<String, MultiValueMap<String, String>> eldest) {, +						return size() > getCacheLimit();, +					}, +				};, +			synchronized (this.cache) {, +				return this.cache.get(destination);, +			}, +		public void addSubscriptions(String destination, MultiValueMap<String, String> subscriptions) {, +			synchronized (this.cache) {, +				this.cache.put(destination, subscriptions);, +			}, +		}, +, +		public void updateAfterNewSubscription(String destination, String sessionId, String subsId) {, +			synchronized(this.cache) {, +				for (String cachedDestination : this.cache.keySet()) {, +					if (getPathMatcher().match(destination, cachedDestination)) {, +						MultiValueMap<String, String> subscriptions = this.cache.get(cachedDestination);, +						subscriptions.add(sessionId, subsId);, +					}, +				}, +			}, +		}, +, +		public void updateAfterRemovedSubscription(String destination, String sessionId, String subsId) {, +			synchronized(this.cache) {, +				for (String cachedDestination : this.cache.keySet()) {, +					if (getPathMatcher().match(destination, cachedDestination)) {, +						MultiValueMap<String, String> subscriptions = this.cache.get(cachedDestination);, +						List<String> subsIds = subscriptions.get(sessionId);, +						subsIds.remove(subsId);, +						if (subsIds.isEmpty()) {, +							subscriptions.remove(sessionId);, +						}, +						if (subscriptions.isEmpty()) {, +							this.cache.remove(cachedDestination);, +						}, +					}, +				}, +			}, +		}, +, +		public void updateAfterRemovedSession(SessionSubscriptionInfo info) {, +			synchronized(this.cache) {, +				for (String destination : info.getDestinations()) {, +					for (String cachedDestination : this.cache.keySet()) {, +						if (getPathMatcher().match(destination, cachedDestination)) {]