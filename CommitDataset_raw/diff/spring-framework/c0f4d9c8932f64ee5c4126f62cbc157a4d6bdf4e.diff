[+++ b/spring-framework-reference/src/beans.xml, +          <para><link linkend="beans-java">Java-based configuration</link>:, +          Starting with Spring 3.0, many features provided by the <ulink, +        <programlisting language="xml">&lt;bean id="clientService", +      class="examples.ClientService", +        <programlisting language="java">public class ClientService {	, +	private static ClientService clientService = new ClientService();, +	private ClientService() {}, +	, +	public static ClientService createInstance() {, +		return clientService;, +	}, +}</programlisting>, +, +&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;, +&lt;bean id="clientService", +      factory-method="createClientServiceInstance"/&gt;</programlisting>, +, +        <programlisting language="java">public class DefaultServiceLocator {	, +	private static ClientService clientService = new ClientServiceImpl();, +	private DefaultServiceLocator() {}, +	, +	public ClientService createClientServiceInstance() {, +		return clientService;, +	}, +}</programlisting>, +, +        <para>One factory class can also hold more than one factory method as, +        shown here:</para>, +, +<programlisting language="xml">, +&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;, +  <lineannotation>&lt;!-- inject any dependencies required by this locator bean --&gt;</lineannotation>, +&lt;/bean&gt;, +&lt;bean id="clientService", +      factory-bean="serviceLocator", +      factory-method="createClientServiceInstance"/&gt;, +	  , +&lt;bean id="accountService", +      factory-bean="serviceLocator", +      factory-method="createAccountServiceInstance"/&gt;</programlisting>, +, +        <programlisting language="java">public class DefaultServiceLocator {	, +	private static ClientService clientService = new ClientServiceImpl();, +	private static AccountService accountService = new AccountServiceImpl();, +	, +	private DefaultServiceLocator() {}, +	, +	public ClientService createClientServiceInstance() {, +		return clientService;, +	}, +	, +	public AccountService createAccountServiceInstance() {, +		return accountService;, +	}, +}</programlisting>, +        annotation style configurations such as <link, +        linkend="beans-autowired-annotation"><interfacename>@Autowired</interfacename></link>).</para>, +        <ulink, +        url="http://blog.springsource.com/2004/08/06/method-injection/">this, +        blog entry</ulink>.</para>, +      <interfacename>Lifecycle</interfacename> interface so that those objects, +      can participate in the startup and shutdown process as driven by the, +      container's own lifecycle.</para>, +        those calls to all Lifecycle implementations defined within that, +        context. It does this by delegating to a, +        <interfacename>LifecycleProcessor</interfacename>:</para>, +        <para>Notice that the, +        <interfacename>LifecycleProcessor</interfacename> is itself an, +        extension of the <interfacename>Lifecycle</interfacename> interface., +        It also adds two other methods for reacting to the context being, +        refreshed and closed.</para>, +        type. In those cases, the, +        <interfacename>SmartLifecycle</interfacename> interface defines, +        another option, namely the <methodname>getPhase()</methodname> method, +        as defined on its super-interface,, +        <interfacename>Phased</interfacename>.</para>, +        <para>When starting, the objects with the lowest phase start first,, +        and when stopping, the reverse order is followed. Therefore, an object, +        that implements <interfacename>SmartLifecycle</interfacename> and, +        whose getPhase() method returns <literal>Integer.MIN_VALUE</literal>, +        would be among the first to start and the last to stop. At the other, +        end of the spectrum, a phase value of, +        <literal>Integer.MAX_VALUE</literal> would indicate that the object, +        should be started last and stopped first (likely because it depends on, +        other processes to be running). When considering the phase value, it's, +        also important to know that the default phase for any "normal", +        <interfacename>Lifecycle</interfacename> object that does not, +        implement <interfacename>SmartLifecycle</interfacename> would be 0., +        Therefore, any negative phase value would indicate that an object, +        should start before those standard components (and stop after them),, +        and vice versa for any positive phase value.</para>, +        <para>As you can see the stop method defined by, +        <interfacename>SmartLifecycle</interfacename> accepts a callback. Any, +        implementation <emphasis>must</emphasis> invoke that callback's run(), +        method after that implementation's shutdown process is complete. That, +        enables asynchronous shutdown where necessary since the default, +        implementation of the, +        <interfacename>LifecycleProcessor</interfacename> interface,, +        <classname>DefaultLifecycleProcessor</classname>, will wait up to its]