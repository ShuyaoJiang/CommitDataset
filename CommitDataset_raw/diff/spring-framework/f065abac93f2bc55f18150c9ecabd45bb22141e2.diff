[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationAwareOrderComparator.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;, +		return findOrderFromAnnotation(obj);, +	}, +	private Integer findOrderFromAnnotation(Object obj) {, +		AnnotatedElement element = obj instanceof AnnotatedElement, +				? (AnnotatedElement) obj, +				: obj.getClass();, +		MergedAnnotations annotations = MergedAnnotations.from(element,, +				SearchStrategy.EXHAUSTIVE);, +		Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);, +			return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());, +			return getPriority(((DecoratingProxy) obj).getDecoratedClass());, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationAwareOrderComparator.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;, +		return findOrderFromAnnotation(obj);, +	}, +	private Integer findOrderFromAnnotation(Object obj) {, +		AnnotatedElement element = obj instanceof AnnotatedElement, +				? (AnnotatedElement) obj, +				: obj.getClass();, +		MergedAnnotations annotations = MergedAnnotations.from(element,, +				SearchStrategy.EXHAUSTIVE);, +		Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);, +			return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());, +			return getPriority(((DecoratingProxy) obj).getDecoratedClass());, +++ b/spring-core/src/main/java/org/springframework/core/annotation/OrderUtils.java, + * Copyright 2002-2019 the original author or authors., +import java.lang.reflect.AnnotatedElement;, +import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;, +	private static final String JAVAX_PRIORITY_ANNOTATION = "javax.annotation.Priority";, +	private static final Map<AnnotatedElement, Object> orderCache = new ConcurrentReferenceHashMap<>(64);, +		return getOrderFromAnnotations(type, MergedAnnotations.from(type, SearchStrategy.EXHAUSTIVE));, +	}, +, +	/**, +	 * Return the order from the specified annotations collection., +	 * <p>Takes care of {@link Order @Order} and, +	 * {@code @javax.annotation.Priority}., +	 * @param element the source element, +	 * @param annotations the annotation to consider, +	 * @return the order value, or {@code null} if none can be found, +	 */, +	static Integer getOrderFromAnnotations(AnnotatedElement element,, +			MergedAnnotations annotations) {, +		if (!(element instanceof Class)) {, +			return findOrder(annotations);, +		}, +		Object cached = orderCache.get(element);, +		Integer result = findOrder(annotations);, +		orderCache.put(element, result != null ? result : NOT_ANNOTATED);, +	private static Integer findOrder(MergedAnnotations annotations) {, +		MergedAnnotation<Order> orderAnnotation = annotations.get(Order.class);, +		if (orderAnnotation.isPresent()) {, +			return orderAnnotation.getInt(MergedAnnotation.VALUE);, +		}, +		MergedAnnotation<?> priorityAnnotation = annotations.get(JAVAX_PRIORITY_ANNOTATION);, +		if (priorityAnnotation.isPresent()) {, +			return priorityAnnotation.getInt(MergedAnnotation.VALUE);, +		}, +		return null;, +	}, +, +		return MergedAnnotations.from(type, SearchStrategy.EXHAUSTIVE).get(, +				JAVAX_PRIORITY_ANNOTATION).getValue(MergedAnnotation.VALUE,, +						Integer.class).orElse(null);]