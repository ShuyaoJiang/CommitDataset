[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java, +	 * The pointcut for Spring AOP to use., +	 * Actual behaviour of the pointcut will change depending on the state of the advice., +	@Override, +	public boolean isLazy() {, +		return this.lazy;, +	}, +, +	@Override, +	public synchronized boolean isAdviceInstantiated() {, +		return (this.instantiatedAdvice != null);, +	}, +, +	/**, +	 * Lazily instantiate advice if necessary., +	 */, +	@Override, +	public synchronized Advice getAdvice() {, +		if (this.instantiatedAdvice == null) {, +			this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);, +		}, +		return this.instantiatedAdvice;, +	}, +, +	private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {, +		Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,, +				this.aspectInstanceFactory, this.declarationOrder, this.aspectName);, +		return (advice != null ? advice : EMPTY_ADVICE);, +	}, +, +				case AtPointcut:, +				case AtAround:, +					this.isBeforeAdvice = false;, +					this.isAfterAdvice = false;, +					break;, +				case AtBefore:, +					this.isBeforeAdvice = true;, +					this.isAfterAdvice = false;, +					break;, +					this.isBeforeAdvice = false;, +	@Override, +	public String toString() {, +		return "InstantiationModelAwarePointcutAdvisor: expression [" + getDeclaredPointcut().getExpression() +, +				"]; advice method [" + this.aspectJAdviceMethod + "]; perClauseKind=" +, +				this.aspectInstanceFactory.getAspectMetadata().getAjType().getPerClause().getKind();, +	}, +, +	 * Note that this is a <i>dynamic</i> pointcut; otherwise it might be optimized out, +	 * if it does not at first match statically., +		public PerTargetInstantiationModelPointcut(AspectJExpressionPointcut declaredPointcut,, +			// We're either instantiated and matching on declared pointcut,, +			// or uninstantiated matching on either pointcut..., +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java, +	 * The pointcut for Spring AOP to use., +	 * Actual behaviour of the pointcut will change depending on the state of the advice., +	@Override, +	public boolean isLazy() {, +		return this.lazy;, +	}, +, +	@Override, +	public synchronized boolean isAdviceInstantiated() {, +		return (this.instantiatedAdvice != null);, +	}, +, +	/**, +	 * Lazily instantiate advice if necessary., +	 */, +	@Override, +	public synchronized Advice getAdvice() {, +		if (this.instantiatedAdvice == null) {, +			this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);, +		}, +		return this.instantiatedAdvice;, +	}, +, +	private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {, +		Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,, +				this.aspectInstanceFactory, this.declarationOrder, this.aspectName);, +		return (advice != null ? advice : EMPTY_ADVICE);, +	}, +, +				case AtPointcut:, +				case AtAround:, +					this.isBeforeAdvice = false;, +					this.isAfterAdvice = false;, +					break;, +				case AtBefore:, +					this.isBeforeAdvice = true;, +					this.isAfterAdvice = false;, +					break;, +					this.isBeforeAdvice = false;, +	@Override, +	public String toString() {, +		return "InstantiationModelAwarePointcutAdvisor: expression [" + getDeclaredPointcut().getExpression() +, +				"]; advice method [" + this.aspectJAdviceMethod + "]; perClauseKind=" +, +				this.aspectInstanceFactory.getAspectMetadata().getAjType().getPerClause().getKind();, +	}, +, +	 * Note that this is a <i>dynamic</i> pointcut; otherwise it might be optimized out]