[+++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, +import java.time.Duration;, +import java.time.Instant;, + * Base class for tests that read or write data buffers with a rule to check, + * that allocated buffers have been released., + *, + * @author Rossen Stoyanchev, +, +	/**, +	 * Wait until allocations are at 0, or the given duration elapses., +	 */, +	protected void waitForDataBufferRelease(Duration duration) throws InterruptedException {, +		Instant start = Instant.now();, +		while (Instant.now().isBefore(start.plus(duration))) {, +			try {, +				verifyAllocations();, +				break;, +			}, +			catch (AssertionError ex) {, +				// ignore;, +			}, +			Thread.sleep(50);, +		}, +	}, +	private void verifyAllocations() {, +		if (this.bufferFactory instanceof NettyDataBufferFactory) {, +			ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator();, +			if (allocator instanceof PooledByteBufAllocator) {, +				PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric();, +				long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas());, +				assertEquals("ByteBuf Leak: " + total + " unreleased allocations", 0, total);, +	private static long getAllocations(List<PoolArenaMetric> metrics) {, +, +	protected class LeakDetector extends Verifier {, +, +		@Override, +		public void verify() {, +			AbstractDataBufferAllocatingTestCase.this.verifyAllocations();, +		}, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, +import java.time.Duration;, +import java.time.Instant;, + * Base class for tests that read or write data buffers with a rule to check, + * that allocated buffers have been released., + *, + * @author Rossen Stoyanchev, +, +	/**, +	 * Wait until allocations are at 0, or the given duration elapses., +	 */, +	protected void waitForDataBufferRelease(Duration duration) throws InterruptedException {, +		Instant start = Instant.now();, +		while (Instant.now().isBefore(start.plus(duration))) {, +			try {, +				verifyAllocations();, +				break;, +			}, +			catch (AssertionError ex) {, +				// ignore;, +			}, +			Thread.sleep(50);, +		}, +	}, +	private void verifyAllocations() {, +		if (this.bufferFactory instanceof NettyDataBufferFactory) {, +			ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator();, +			if (allocator instanceof PooledByteBufAllocator) {, +				PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric();, +				long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas());, +				assertEquals("ByteBuf Leak: " + total + " unreleased allocations", 0, total);, +	private static long getAllocations(List<PoolArenaMetric> metrics) {, +, +	protected class LeakDetector extends Verifier {, +, +		@Override, +		public void verify() {, +			AbstractDataBufferAllocatingTestCase.this.verifyAllocations();, +		}, +++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.springframework.util.Assert;, +	private final AtomicBoolean bodyConsumed = new AtomicBoolean();, +, +				.doOnSubscribe(s ->, +						// See https://github.com/reactor/reactor-netty/issues/503, +						Assert.state(this.bodyConsumed.compareAndSet(false, true),, +								"The client response body can only be consumed once.")), +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, +import java.time.Duration;, +import java.time.Instant;, + * Base class for tests that read or write data buffers with a rule to check, + * that allocated buffers have been released., + *, + * @author Rossen Stoyanchev, +, +	/**, +	 * Wait until allocations are at 0, or the given duration elapses., +	 */, +	protected void waitForDataBufferRelease(Duration duration) throws InterruptedException {, +		Instant start = Instant.now();]