[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java, +					logger.trace("Checking location: " + location);, +						logger.trace("Found match: " + resource);, +					logger.trace("No match for location: " + location);, +				logger.trace("Failure checking for relative resource - trying next location", ex);, +	 * @return the resource, or {@code null} if none found, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java, +					logger.trace("Checking location: " + location);, +						logger.trace("Found match: " + resource);, +					logger.trace("No match for location: " + location);, +				logger.trace("Failure checking for relative resource - trying next location", ex);, +	 * @return the resource, or {@code null} if none found, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, +	 * authenticated user., +	 * <p>If the user has not been authenticated, the method returns <code>null</code>., +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java, +					logger.trace("Checking location: " + location);, +						logger.trace("Found match: " + resource);, +					logger.trace("No match for location: " + location);, +				logger.trace("Failure checking for relative resource - trying next location", ex);, +	 * @return the resource, or {@code null} if none found, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, +	 * authenticated user., +	 * <p>If the user has not been authenticated, the method returns <code>null</code>., +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/client/SockJsClient.java, + * Copyright 2002-2014 the original author or authors., +import java.util.HashSet;, +import java.util.Set;, +import org.springframework.util.CollectionUtils;, +	private static final Set<String> supportedProtocols = new HashSet<String>(4);, +	static {, +		supportedProtocols.add("ws");, +		supportedProtocols.add("wss");, +		supportedProtocols.add("http");, +		supportedProtocols.add("https");, +	}, +, +	private InfoReceiver infoReceiver;, +, +	private final Map<URI, ServerInfo> serverInfoCache = new ConcurrentHashMap<URI, ServerInfo>();, +, +		this.infoReceiver = initInfoReceiver(transports);, +		Assert.notNull(infoReceiver, "InfoReceiver is required");, +	 * Return the configured {@code InfoReceiver} (never {@code null})., +	/**, +	 * Return the SockJsMessageCodec to use., +	 */, +, +	public ListenableFuture<WebSocketSession> doHandshake(, +			WebSocketHandler handler, String uriTemplate, Object... uriVars) {, +	public final ListenableFuture<WebSocketSession> doHandshake(, +			WebSocketHandler handler, WebSocketHttpHeaders headers, URI url) {, +		Assert.notNull(handler, "WebSocketHandler is required");, +		Assert.notNull(url, "URL is required");, +		if (!supportedProtocols.contains(scheme)) {, +			throw new IllegalArgumentException("Invalid scheme: '" + scheme + "'");, +		}, +		if (CollectionUtils.isEmpty(requests)) {, +			throw new IllegalStateException(, +					"No transports: " + urlInfo + ", webSocketEnabled=" + serverInfo.isWebSocketEnabled());, +		}, +	 * {@link org.springframework.web.socket.WebSocketSession#getPrincipal()}., +	 * @return the user to associate with the session (possibly {@code null}), +	/**, +	 * By default the result of a SockJS "Info" request, including whether the, +	 * server has WebSocket disabled and how long the request took (used for, +	 * calculating transport timeout time) is cached. This method can be used to, +	 * clear that cache hence causing it to re-populate., +	 */, +	public void clearServerInfoCache() {, +		this.serverInfoCache.clear();, +	}, +, +		public ServerInfo(String response, long responseTime) {]