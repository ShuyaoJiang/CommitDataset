[+++ b/src/reference/docbook/beans-java.xml, +    <title>Basic concepts: <literal>@Bean</literal> and <literal>@Configuration</literal></title>, +    <sidebar>, +      <title>Full @Configuration vs 'lite' @Beans mode?</title>, +      <para>When <interfacename>@Bean</interfacename> methods are declared within, +        classes that are <emphasis>not</emphasis> annotated with, +        <interfacename>@Configuration</interfacename> they are referred to as being, +        processed in a 'lite' mode. For example, bean methods declared in a, +        <interfacename>@Component</interfacename> or even in a <emphasis>plain old, +        class</emphasis> will be considered 'lite'.</para>, +      <para>Unlike full <interfacename>@Configuration</interfacename>, lite, +        <interfacename>@Bean</interfacename> methods cannot easily declare inter-bean, +        dependencies. Usually one <interfacename>@Bean</interfacename> method should not, +        invoke another  <interfacename>@Bean</interfacename> method when operating in, +        'lite' mode.</para>, +      <para>Only using <interfacename>@Bean</interfacename> methods within, +        <interfacename>@Configuration</interfacename> classes is a recommended approach, +        of ensuring that 'full' mode is always used. This will prevent the same, +        <interfacename>@Bean</interfacename> method from accidentally being invoked, +        multiple times and helps to reduce subtle bugs that can be hard to track down, +        when operating in 'lite' mode.</para>, +    </sidebar>, +    <para>The central artifacts in Spring's new Java-configuration support are, +      <interfacename>@Configuration</interfacename>-annotated classes and, +      <interfacename>@Bean</interfacename>-annotated methods.</para>, +    <para>The <interfacename>@Bean</interfacename> annotation is used to indicate that a, +      method instantiates, configures and initializes a new object to be managed by, +      the Spring IoC container. For those familiar with Spring's, +      <literal>&lt;beans/&gt;</literal> XML configuration the <literal>@Bean</literal>, +      annotation plays the same role as the <literal>&lt;bean/&gt;</literal>, +      element. You can use <interfacename>@Bean</interfacename> annotated methods with, +      any Spring <interfacename>@Component</interfacename>, however, they are most, +      often used with <interfacename>@Configuration</interfacename> beans.</para>, +    <para>Annotating a class with <interfacename>@Configuration</interfacename>, +      indicates that its primary purpose is as a source of bean definitions. Furthermore,, +      <interfacename>@Configuration</interfacename> classes allow inter-bean, +      dependencies to be defined by simply calling other <interfacename>@Bean</interfacename>, +      methods in the same class.  The simplest possible, +      <interfacename>@Configuration</interfacename> class would read as follows:, +    <para>The <literal>AppConfig</literal> class above would be equivalent to the, +      following Spring <literal>&lt;beans/&gt;</literal> XML:, +      The <interfacename>@Bean</interfacename> and <interfacename>@Configuration</interfacename>, +      annotations will be discussed in depth in the sections below. First, however, we'll, +      cover the various ways of creating a spring container using Java-based, +      configuration.</para>, +  <section xml:id="beans-java-bean-annotation">, +    <title>Using the <interfacename>@Bean</interfacename> annotation</title>, +, +    <para><interfacename>@Bean</interfacename> is a method-level annotation and, +      a direct analog of the XML <code>&lt;bean/&gt;</code> element. The, +      annotation supports some of the attributes offered by, +      <code>&lt;bean/&gt;</code>, such as: <code><link, +      linkend="beans-factory-lifecycle-initializingbean", +      >init-method</link></code>, <code><link, +      linkend="beans-factory-lifecycle-disposablebean", +      >destroy-method</link></code>, <code><link, +      linkend="beans-factory-autowire">autowiring</link></code> and, +      <code>name</code>.</para>, +, +    <para>You can use the <interfacename>@Bean</interfacename> annotation in a, +      <interfacename>@Configuration</interfacename>-annotated or in a, +      <interfacename>@Component</interfacename>-annotated class.</para>, +, +    <section xml:id="beans-java-declaring-a-bean">, +      <title>Declaring a bean</title>, +, +      <para>To declare a bean, simply annotate a method with the, +        <interfacename>@Bean</interfacename> annotation. You use this method to, +        register a bean definition within an <code>ApplicationContext</code> of, +        the type specified as the method's return value. By default, the bean, +        name will be the same as the method name. The following is a simple, +        example of a <interfacename>@Bean</interfacename> method declaration:, +        <programlisting language="java">@Configuration, +public class AppConfig {, +, +  @Bean, +  public TransferService transferService() {, +      return new TransferServiceImpl();, +  }, +, +}</programlisting></para>, +, +      <para>The preceding configuration is exactly equivalent to the following, +        Spring XML:, +        <programlisting language="xml">&lt;beans&gt;, +  &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;, +&lt;/beans&gt;                </programlisting></para>, +, +      <para>Both declarations make a bean named <code>transferService</code>, +        available in the <code>ApplicationContext</code>, bound to an object, +        instance of type <code>TransferServiceImpl</code>:, +        <programlisting>, +transferService -&gt; com.acme.TransferServiceImpl, +              </programlisting></para>, +    </section>, +, +    <section xml:id="beans-java-lifecycle-callbacks">, +      <title>Receiving lifecycle callbacks</title>, +, +      <para>Any classes defined with the]