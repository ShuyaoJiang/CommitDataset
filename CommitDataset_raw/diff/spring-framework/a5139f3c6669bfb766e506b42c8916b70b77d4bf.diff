[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * @see #findAllMergedAnnotations(AnnotatedElement, Class), +	 * Find <strong>all</strong> annotations of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy, and synthesize the result back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within the annotation hierarchy., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @return the set of all merged, synthesized {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #findMergedAnnotation(AnnotatedElement, Class), +	 */, +	public static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +, +		Assert.notNull(element, "AnnotatedElement must not be null");, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(annotationType, null,, +			false, false, true);, +, +		searchWithFindSemantics(element, annotationType, annotationType.getName(), processor);, +, +		Set<A> annotations = new LinkedHashSet<A>();, +		for (AnnotationAttributes attributes : processor.getAggregatedResults()) {, +			AnnotationUtils.postProcessAnnotationAttributes(element, attributes, false, false);, +			annotations.add(AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element));, +		}, +		return annotations;, +	}, +, +	/**, +				List<T> aggregatedResults = processor.aggregates() ? new ArrayList<T>() : null;, +, +							if (processor.aggregates() && metaDepth == 0) {, +								aggregatedResults.add(result);, +							}, +							else {, +				}, +							if (processor.aggregates() && metaDepth == 0) {, +								aggregatedResults.add(result);, +							}, +							else {, +				}, +, +				if (processor.aggregates()) {, +					processor.getAggregatedResults().addAll(0, aggregatedResults);, +				}, +	 * the search)., +	 * <p>Returning a non-null value from the {@link #process}, +	 * annotations. One exception to this rule applies to processors, +	 * that {@linkplain #aggregates aggregate} results. If an aggregating, +	 * processor returns a non-null value, that value will be added to the, +	 * list of {@linkplain #getAggregatedResults aggregated results}, +	 * and the search algorithm will continue., +		 * Determine if this processor aggregates the results returned by {@link #process}., +		 * <p>If this method returns {@code true}, then {@link #getAggregatedResults()}, +		 * must return a non-null value., +		 * <p>WARNING: aggregation is currently only supported for <em>find semantics</em>., +		 * @return {@code true} if this processor supports aggregated results, +		 * @see #getAggregatedResults, +		 * @since 4.3, +		 */, +		boolean aggregates();, +, +		/**, +		 * Get the list of results aggregated by this processor., +		 * <p>NOTE: the processor does not aggregate the results itself., +		 * Rather, the search algorithm that uses this processor is responsible, +		 * for asking this processor if it {@link #aggregates} results and then, +		 * adding the post-processed results to the list returned by this, +		 * method., +		 * <p>WARNING: aggregation is currently only supported for <em>find semantics</em>., +		 * @return the list of results aggregated by this processor; never, +		 * {@code null} unless {@link #aggregates} returns {@code false}, +		 * @see #aggregates, +		 * @since 4.3, +		 */, +		List<T> getAggregatedResults();, +	}, +, +	/**, +	 * {@link Processor} that {@linkplain #process(AnnotatedElement, Annotation, int), +	 * processes} annotations but does not {@linkplain #postProcess post-process} or, +	 * {@linkplain #aggregates aggregate} results., +, +		@Override, +		public final boolean aggregates() {, +			return false;, +		}, +, +		@Override, +		public List<T> getAggregatedResults() {, +			throw new UnsupportedOperationException("SimpleAnnotationProcessor does not support aggregated results");, +		}]