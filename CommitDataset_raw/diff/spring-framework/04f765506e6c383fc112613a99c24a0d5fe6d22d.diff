[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2015 the original author or authors., +, +, +, +			String classDesc = member.getDeclaringClass().getName().replace('.', '/');, +, +				if (descriptor == null || !classDesc.equals(descriptor.substring(1))) {, +					mv.visitTypeInsn(CHECKCAST, classDesc);, +, +			if (member instanceof Method) {, +				mv.visitMethodInsn((isStatic? INVOKESTATIC : INVOKEVIRTUAL), classDesc, member.getName(),, +						CodeFlow.createSignatureDescriptor((Method) member), false);, +				mv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, member.getName(),, +						CodeFlow.toJvmDescriptor(((Field) member).getType()));, +								Indexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(member instanceof Method ?, +										((Method) member).getReturnType() : ((Field) member).getType());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2015 the original author or authors., +, +, +, +			String classDesc = member.getDeclaringClass().getName().replace('.', '/');, +, +				if (descriptor == null || !classDesc.equals(descriptor.substring(1))) {, +					mv.visitTypeInsn(CHECKCAST, classDesc);, +, +			if (member instanceof Method) {, +				mv.visitMethodInsn((isStatic? INVOKESTATIC : INVOKEVIRTUAL), classDesc, member.getName(),, +						CodeFlow.createSignatureDescriptor((Method) member), false);, +				mv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, member.getName(),, +						CodeFlow.toJvmDescriptor(((Field) member).getType()));, +								Indexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(member instanceof Method ?, +										((Method) member).getReturnType() : ((Field) member).getType());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		}, +		else {, +		String classDesc = (Modifier.isPublic(method.getDeclaringClass().getModifiers()) ?, +				method.getDeclaringClass().getName().replace('.', '/') :, +				methodExecutor.getPublicDeclaringClass().getName().replace('.', '/'));, +			if (descriptor == null || !descriptor.substring(1).equals(classDesc)) {, +				CodeFlow.insertCheckCast(mv, "L" + classDesc);, +, +		generateCodeForArguments(mv, cf, method, this.children);, +		mv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),, +				CodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2015 the original author or authors., +, +, +, +			String classDesc = member.getDeclaringClass().getName().replace('.', '/');, +, +				if (descriptor == null || !classDesc.equals(descriptor.substring(1))) {, +					mv.visitTypeInsn(CHECKCAST, classDesc);, +, +			if (member instanceof Method) {, +				mv.visitMethodInsn((isStatic? INVOKESTATIC : INVOKEVIRTUAL), classDesc, member.getName(),, +						CodeFlow.createSignatureDescriptor((Method) member), false);, +				mv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, member.getName(),, +						CodeFlow.toJvmDescriptor(((Field) member).getType()));, +								Indexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(member instanceof Method ?, +										((Method) member).getReturnType() : ((Field) member).getType());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		}, +		else {, +		String classDesc = (Modifier.isPublic(method.getDeclaringClass().getModifiers()) ?, +				method.getDeclaringClass().getName().replace('.', '/') :, +				methodExecutor.getPublicDeclaringClass().getName().replace('.', '/'));, +			if (descriptor == null || !descriptor.substring(1).equals(classDesc)) {, +				CodeFlow.insertCheckCast(mv, "L" + classDesc);, +, +		generateCodeForArguments(mv, cf, method, this.children);, +		mv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),, +				CodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java, + * Copyright 2002-2015 the original author or authors., +					throw new AccessException("Unable to access property '" + name + "' through getter method", ex);, +					throw new AccessException("Unable to access field '" + name + "'", ex);, +		throw new AccessException("Neither getter method nor field found for property '" + name + "'");, +					throw new AccessException("Unable to access property '" + name + "' through setter method", ex);, +					throw new AccessException("Unable to access field '" + name + "'", ex);, +		throw new AccessException("Neither setter method nor field found for property '" + name + "'");, +			Method method = (Method) (invocationTarget != null ? invocationTarget.member : null);, +, +			this.needsToBeMadeAccessible = (!Modifier.isPublic(this.member.getModifiers()) ||, +					!Modifier.isPublic(this.member.getDeclaringClass().getModifiers()));, +, +, +				Method method = (Method) this.member;, +					if (this.needsToBeMadeAccessible && !method.isAccessible()) {, +						method.setAccessible(true);, +					Object value = method.invoke(target);, +					throw new AccessException("Unable to access property '" + name + "' through getter method", ex);, +			else {, +				Field field = (Field) this.member;, +					if (this.needsToBeMadeAccessible && !field.isAccessible()) {, +						field.setAccessible(true);, +					Object value = field.get(target);, +					throw new AccessException("Unable to access field '" + name + "'", ex);]