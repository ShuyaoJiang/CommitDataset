[+++ b/org.springframework.core/src/main/java/org/springframework/util/ReflectionUtils.java, + * <p>, + * Only intended for internal use., +	 * the supplied <code>name</code>. Searches all superclasses up to, +	 * {@link Object}., +	 * , +	public static Field findField(Class<?> clazz, String name) {, +	 * , +	 * @param name the name of the field (may be <code>null</code> if type is, +	 * specified), +	 * @param type the type of the field (may be <code>null</code> if name is, +	 * specified), +	public static Field findField(Class<?> clazz, String name, Class<?> type) {, +		Class<?> searchType = clazz;, +				if ((name == null || name.equals(field.getName())) && (type == null || type.equals(field.getType()))) {, +	 * <code>value</code>. In accordance with {@link Field#set(Object, Object)}, +	 * semantics, the new value is automatically unwrapped if the underlying, +	 * field has a primitive type., +	 * <p>, +	 * Thrown exceptions are handled via a call to, +	 * , +			throw new IllegalStateException("Unexpected reflection exception - " + ex.getClass().getName() + ": ", +					+ ex.getMessage());, +	 * {@link Field#get(Object)} semantics, the returned value is automatically, +	 * wrapped if the underlying field has a primitive type., +	 * <p>, +	 * Thrown exceptions are handled via a call to, +	 * , +			throw new IllegalStateException("Unexpected reflection exception - " + ex.getClass().getName() + ": ", +					+ ex.getMessage());, +	 * Attempt to find a {@link Method} on the supplied class with the supplied, +	 * name and no parameters. Searches all superclasses up to, +	 * <code>Object</code>., +	 * <p>, +	 * Returns <code>null</code> if no {@link Method} can be found., +	 * , +	public static Method findMethod(Class<?> clazz, String name) {, +	 * Attempt to find a {@link Method} on the supplied class with the supplied, +	 * name and parameter types. Searches all superclasses up to, +	 * <code>Object</code>., +	 * <p>, +	 * Returns <code>null</code> if no {@link Method} can be found., +	 * , +	 * @param paramTypes the parameter types of the method (may be, +	 * <code>null</code> to indicate any signature), +	public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {, +		Class<?> searchType = clazz;, +				if (name.equals(method.getName()), +						&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {, +	 * <p>, +	 * Thrown exceptions are handled via a call to, +	 * {@link #handleReflectionException}., +	 * , +	 * <p>, +	 * Thrown exceptions are handled via a call to, +	 * {@link #handleReflectionException}., +	 * , +	 * Invoke the specified JDBC API {@link Method} against the supplied target, +	 * object with no arguments., +	 * , +	 * Invoke the specified JDBC API {@link Method} against the supplied target, +	 * object with the supplied arguments., +	 * , +	 * Handle the given reflection exception. Should only be called if no, +	 * checked exception is expected to be thrown by the target method., +	 * <p>, +	 * Throws the underlying RuntimeException or Error in case of an, +	 * , +	 * Handle the given invocation target exception. Should only be called if no, +	 * checked exception is expected to be thrown by the target method., +	 * <p>, +	 * Throws the underlying RuntimeException or Error in case of such a root, +	 * cause. Throws an IllegalStateException else., +	 * , +	 * <em>target exception</em> of an {@link InvocationTargetException}. Should, +	 * only be called if no checked exception is expected to be thrown by the, +	 * target method., +	 * <p>, +	 * Rethrows the underlying exception cast to an {@link RuntimeException} or, +	 * {@link Error} if appropriate; otherwise, throws an, +	 * , +	 * <em>target exception</em> of an {@link InvocationTargetException}. Should, +	 * only be called if no checked exception is expected to be thrown by the, +	 * target method., +	 * <p>, +	 * Rethrows the underlying exception cast to an {@link Exception} or, +	 * , +	 * , +	 * Determine whether the given method explicitly declares the given, +	 * exception or one of its superclasses, which means that an exception of, +	 * that type can be propagated as-is within a reflective invocation., +	 * , +	public static boolean declaresException(Method method, Class<?> exceptionType) {, +		Class<?>[] declaredExceptions = method.getExceptionTypes();, +		for (Class<?> declaredException : declaredExceptions) {, +	 * , +	 * , +		Class<?>[] paramTypes = method.getParameterTypes();, +	 * , +		return (method != null && method.getName().equals("hashCode") && method.getParameterTypes().length == 0);]