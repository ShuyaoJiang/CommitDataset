[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/BrokerAvailabilityEvent.java, +, +	@Override, +	public String toString() {, +		return "BrokerAvailabilityEvent=" + this.brokerAvailable;, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/BrokerAvailabilityEvent.java, +, +	@Override, +	public String toString() {, +		return "BrokerAvailabilityEvent=" + this.brokerAvailable;, +	}, +, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandlerIntegrationTests.java, +, +		startActiveMqBroker();, +	private void startActiveMqBroker() throws Exception {, +		this.activeMQBroker.addConnector("stomp://localhost:" + this.port);, +		this.relay.setRelayPort(this.port);, +			stopActiveMqBrokerAndAwait();, +	private void stopActiveMqBrokerAndAwait() throws Exception {, +	// When TCP client is behind interface and configurable:, +	// test "host" header (virtualHost property), +	// test "/user/.." destination is excluded, +, +	@Test, +	public void publishSubscribe() throws Exception {, +, +		String sess1 = "sess1";, +		String sess2 = "sess2";, +		MessageExchange conn1 = MessageExchangeBuilder.connect(sess1).build();, +		MessageExchange conn2 = MessageExchangeBuilder.connect(sess2).build();, +		this.responseHandler.expect(conn1, conn2);, +, +		this.relay.handleMessage(conn1.message);, +		this.relay.handleMessage(conn2.message);, +		this.responseHandler.awaitAndAssert();, +, +		String subs1 = "subs1";, +		String destination = "/topic/test";, +, +		MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build();, +		this.responseHandler.expect(subscribe);, +, +		this.relay.handleMessage(subscribe.message);, +		this.responseHandler.awaitAndAssert();, +, +		MessageExchange send = MessageExchangeBuilder.send(destination, "foo").andExpectMessage(sess1, subs1).build();, +		this.responseHandler.expect(send);, +, +		this.relay.handleMessage(send.message);, +		this.responseHandler.awaitAndAssert();, +	}, +, +	@Test, +	public void brokerUnvailableErrorFrameOnConnect() throws Exception {, +, +		stopActiveMqBrokerAndAwait();, +, +		MessageExchange connect = MessageExchangeBuilder.connectWithError("sess1").build();, +		this.responseHandler.expect(connect);, +, +		this.relay.handleMessage(connect.message);, +		this.responseHandler.awaitAndAssert();, +	}, +, +	@Test(expected=MessageDeliveryException.class), +	public void messageDeliverExceptionIfSystemSessionForwardFails() throws Exception {, +		stopActiveMqBrokerAndAwait();, +		StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND);, +		this.relay.handleMessage(MessageBuilder.withPayload("test".getBytes()).setHeaders(headers).build());, +	}, +, +	@Test, +	public void brokerBecomingUnvailableTriggersErrorFrame() throws Exception {, +, +		String sess1 = "sess1";, +		MessageExchange connect = MessageExchangeBuilder.connect(sess1).build();, +		this.responseHandler.expect(connect);, +, +		this.relay.handleMessage(connect.message);, +		this.responseHandler.awaitAndAssert();, +, +		this.responseHandler.expect(MessageExchangeBuilder.error(sess1).build());, +, +		stopActiveMqBrokerAndAwait();, +, +		this.responseHandler.awaitAndAssert();, +	}, +, +	@Test, +	public void brokerAvailabilityEventWhenStopped() throws Exception {, +		this.eventPublisher.expectAvailabilityStatusChanges(false);, +		stopActiveMqBrokerAndAwait();, +		this.eventPublisher.awaitAndAssert();, +	}, +, +	@Test, +	public void relayReconnectsIfBrokerComesBackUp() throws Exception {]