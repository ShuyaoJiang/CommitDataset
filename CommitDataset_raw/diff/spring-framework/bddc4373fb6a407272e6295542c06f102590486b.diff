[+++ b/spring-core/src/main/java/org/springframework/core/convert/support/FallbackObjectToStringConverter.java, + * @author Sam Brannen, + * @see ObjectToObjectConverter, +			// no conversion required, +				ObjectToObjectConverter.hasFactoryMethod(sourceClass, String.class) ||, +				ObjectToObjectConverter.hasFactoryConstructor(sourceClass, String.class));, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/FallbackObjectToStringConverter.java, + * @author Sam Brannen, + * @see ObjectToObjectConverter, +			// no conversion required, +				ObjectToObjectConverter.hasFactoryMethod(sourceClass, String.class) ||, +				ObjectToObjectConverter.hasFactoryConstructor(sourceClass, String.class));, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java, + * <p><strong>Warning</strong>: this converter does <em>not</em> support the, + * {@link Object#toString()} method for converting from a {@code sourceType}, + * to {@code java.lang.String}. For {@code toString()} support, use, + * {@link FallbackObjectToStringConverter} instead., + *, + * @author Sam Brannen, + * @see FallbackObjectToStringConverter, +				hasFactoryConstructor(String.class, sourceType.getType()) :, +				hasToMethodOrFactoryMethodOrConstructor(targetType.getType(), sourceType.getType()));, +			// Do not invoke a toString() method, +			}, +, +			Method method = getFactoryMethod(targetClass, sourceClass);, +, +			Constructor<?> constructor = getFactoryConstructor(targetClass, sourceClass);, +, +		// If sourceClass is Number and targetClass is Integer, then the following message, +		// format should expand to:, +		// No toInteger() method exists on java.lang.Number, and no static, +		// valueOf/of/from(java.lang.Number) method or Integer(java.lang.Number), +		// constructor exists on java.lang.Integer., +		String message = String.format(, +			"No to%3$s() method exists on %1$s, and no static valueOf/of/from(%1$s) method or %3$s(%1$s) constructor exists on %2$s.",, +			sourceClass.getName(), targetClass.getName(), targetClass.getSimpleName());, +, +		throw new IllegalStateException(message);, +	private static Method getFactoryMethod(Class<?> targetClass, Class<?> sourceClass) {, +	private static Constructor<?> getFactoryConstructor(Class<?> targetClass, Class<?> sourceClass) {, +		return ClassUtils.getConstructorIfAvailable(targetClass, sourceClass);, +	}, +, +	private static boolean hasToMethodOrFactoryMethodOrConstructor(Class<?> targetClass,, +			Class<?> sourceClass) {, +		return (hasToMethod(targetClass, sourceClass) ||, +				hasFactoryMethod(targetClass, sourceClass) ||, +				hasFactoryConstructor(targetClass, sourceClass));, +	}, +, +	static boolean hasToMethod(Class<?> targetClass, Class<?> sourceClass) {, +		return getToMethod(targetClass, sourceClass) != null;, +	}, +, +	static boolean hasFactoryMethod(Class<?> targetClass, Class<?> sourceClass) {, +		return getFactoryMethod(targetClass, sourceClass) != null;, +	}, +, +	static boolean hasFactoryConstructor(Class<?> targetClass, Class<?> sourceClass) {, +		return getFactoryConstructor(targetClass, sourceClass) != null;, +	}, +]