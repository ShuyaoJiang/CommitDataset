[+++ b/spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java, + * @author Juergen Hoeller, +	private final String condition;, +, +	private final int order;, +, +, +		EventListener ann = AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class);, +		this.declaredEventTypes = resolveDeclaredEventTypes(method, ann);, +		this.condition = (ann != null ? ann.condition() : null);, +		this.order = resolveOrder(method);, +, +		this.methodKey = new AnnotatedElementKey(method, targetClass);, +	private List<ResolvableType> resolveDeclaredEventTypes(Method method, EventListener ann) {, +		int count = method.getParameterCount();, +		if (count > 1) {, +			throw new IllegalStateException(, +					"Maximum one parameter is allowed for event listener method: " + method);, +		}, +		if (ann != null && ann.classes().length > 0) {, +			List<ResolvableType> types = new ArrayList<>(ann.classes().length);, +			for (Class<?> eventType : ann.classes()) {, +				types.add(ResolvableType.forClass(eventType));, +			}, +			return types;, +		}, +		else {, +			if (count == 0) {, +				throw new IllegalStateException(, +						"Event parameter is mandatory for event listener method: " + method);, +			}, +			return Collections.singletonList(ResolvableType.forMethodParameter(method, 0));, +		}, +	}, +, +	private int resolveOrder(Method method) {, +		Order ann = AnnotatedElementUtils.findMergedAnnotation(method, Order.class);, +		return (ann != null ? ann.value() : 0);, +	}, +, +		return this.order;, +		if (!ApplicationEvent.class.isAssignableFrom(declaredEventType.getRawClass()) &&, +				event instanceof PayloadApplicationEvent) {, +++ b/spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java, + * @author Juergen Hoeller, +	private final String condition;, +, +	private final int order;, +, +, +		EventListener ann = AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class);, +		this.declaredEventTypes = resolveDeclaredEventTypes(method, ann);, +		this.condition = (ann != null ? ann.condition() : null);, +		this.order = resolveOrder(method);, +, +		this.methodKey = new AnnotatedElementKey(method, targetClass);, +	private List<ResolvableType> resolveDeclaredEventTypes(Method method, EventListener ann) {, +		int count = method.getParameterCount();, +		if (count > 1) {, +			throw new IllegalStateException(, +					"Maximum one parameter is allowed for event listener method: " + method);, +		}, +		if (ann != null && ann.classes().length > 0) {, +			List<ResolvableType> types = new ArrayList<>(ann.classes().length);, +			for (Class<?> eventType : ann.classes()) {, +				types.add(ResolvableType.forClass(eventType));, +			}, +			return types;, +		}, +		else {, +			if (count == 0) {, +				throw new IllegalStateException(, +						"Event parameter is mandatory for event listener method: " + method);, +			}, +			return Collections.singletonList(ResolvableType.forMethodParameter(method, 0));, +		}, +	}, +, +	private int resolveOrder(Method method) {, +		Order ann = AnnotatedElementUtils.findMergedAnnotation(method, Order.class);, +		return (ann != null ? ann.value() : 0);, +	}, +, +		return this.order;, +		if (!ApplicationEvent.class.isAssignableFrom(declaredEventType.getRawClass()) &&, +				event instanceof PayloadApplicationEvent) {, +++ b/spring-tx/src/main/java/org/springframework/transaction/event/ApplicationListenerMethodTransactionalAdapter.java, + * @author Juergen Hoeller, +			throw new IllegalStateException("No TransactionalEventListener annotation found on method: " + method);, +			if (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK && logger.isWarnEnabled()) {, +				logger.warn("Processing " + event + " as a fallback execution on AFTER_ROLLBACK phase");, +		else if (logger.isDebugEnabled()) {, +			logger.debug("No transaction is running - skipping " + event);]