[+++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, + * Copyright 2002-2018 the original author or authors., + * @author Juergen Hoeller, +	public V get(@Nullable Object key) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +	@Nullable, +	public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +		return (entry != null ? entry.getValue() : defaultValue);, +	}, +, +	@Override, +	public boolean containsKey(@Nullable Object key) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +	@Nullable, +	private Entry<K, V> getEntryIfAvailable(@Nullable Object key) {, +		Reference<K, V> reference = getReference(key, Restructure.WHEN_NECESSARY);, +		return (reference != null ? reference.get() : null);, +	}, +, +	public V put(@Nullable K key, @Nullable V value) {, +	public V putIfAbsent(@Nullable K key, @Nullable V value) {, +	private V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {, +					V oldValue = entry.getValue();, +					return oldValue;, +					V oldValue = entry.getValue();, +					return oldValue;, +	private <T> T doTask(@Nullable Object key, Task<T> task) {, +		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {, +					public void add(@Nullable V value) {, +						if (ObjectUtils.nullSafeEquals(entryKey, key)) {, +		@Nullable, +		@Nullable, +		public Entry(@Nullable K key, @Nullable V value) {, +		@Nullable, +		@Nullable, +		@Nullable, +		public V setValue(@Nullable V value) {, +		public abstract void add(@Nullable V value);, +++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, + * Copyright 2002-2018 the original author or authors., + * @author Juergen Hoeller, +	public V get(@Nullable Object key) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +	@Nullable, +	public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +		return (entry != null ? entry.getValue() : defaultValue);, +	}, +, +	@Override, +	public boolean containsKey(@Nullable Object key) {, +		Entry<K, V> entry = getEntryIfAvailable(key);, +	@Nullable, +	private Entry<K, V> getEntryIfAvailable(@Nullable Object key) {, +		Reference<K, V> reference = getReference(key, Restructure.WHEN_NECESSARY);, +		return (reference != null ? reference.get() : null);, +	}, +, +	public V put(@Nullable K key, @Nullable V value) {, +	public V putIfAbsent(@Nullable K key, @Nullable V value) {, +	private V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {, +					V oldValue = entry.getValue();, +					return oldValue;, +					V oldValue = entry.getValue();, +					return oldValue;, +	private <T> T doTask(@Nullable Object key, Task<T> task) {, +		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {, +					public void add(@Nullable V value) {, +						if (ObjectUtils.nullSafeEquals(entryKey, key)) {, +		@Nullable, +		@Nullable, +		public Entry(@Nullable K key, @Nullable V value) {, +		@Nullable, +		@Nullable, +		@Nullable, +		public V setValue(@Nullable V value) {, +		public abstract void add(@Nullable V value);, +++ b/spring-core/src/test/java/org/springframework/util/ConcurrentReferenceHashMapTests.java, + * Copyright 2002-2018 the original author or authors., +	public void shouldCreateWithDefaults() {, +	public void shouldCreateWithInitialCapacity() {, +	public void shouldCreateWithInitialCapacityAndLoadFactor() {, +	public void shouldCreateWithInitialCapacityAndConcurrenyLevel() {, +	public void shouldCreateFullyCustom() {, +	public void shouldNeedNonNegativeInitialCapacity() {, +	public void shouldNeedPositiveLoadFactor() {, +	public void shouldNeedPositiveConcurrencyLevel() {, +	public void shouldPutAndGet() {, +	public void shouldReplaceOnDoublePut() {, +	public void shouldPutNullKey() {, +		assertThat(this.map.get(null), is(nullValue()));, +		assertThat(this.map.getOrDefault(null, "456"), is("456"));, +		assertThat(this.map.getOrDefault(null, "456"), is("123"));, +	public void shouldPutNullValue() {, +		assertThat(this.map.get(123), is(nullValue()));, +		assertThat(this.map.getOrDefault(123, "456"), is("456"));, +		assertThat(this.map.get(123), is("321"));, +		assertThat(this.map.getOrDefault(123, "456"), is("321"));, +		assertThat(this.map.getOrDefault(123, "456"), is(nullValue()));]