[+++ b/org.springframework.test/src/main/java/org/springframework/test/annotation/DirtiesContext.java, + * Test annotation which indicates that the, + * {@link org.springframework.context.ApplicationContext ApplicationContext}, + * associated with a test is <em>dirty</em> and should be closed:, + * <ul>, + * <li>after the current test, when declared at the method level, or</li>, + * <li>after the current test class, when declared at the class level.</li>, + * </ul>, + * <p>, + * Use this annotation if a test has modified the context (for example, by, + * replacing a bean definition). Subsequent tests will be supplied a new, + * context., + * </p>, + * <p>, + * <code>&#064;DirtiesContext</code> may be used as a class-level and, + * method-level annotation within the same class. In such scenarios, the, + * <code>ApplicationContext</code> will be marked as <em>dirty</em> after any, + * such annotated method as well as after the entire class., + * </p>, +@Target( { ElementType.TYPE, ElementType.METHOD }), +++ b/org.springframework.test/src/main/java/org/springframework/test/annotation/DirtiesContext.java, + * Test annotation which indicates that the, + * {@link org.springframework.context.ApplicationContext ApplicationContext}, + * associated with a test is <em>dirty</em> and should be closed:, + * <ul>, + * <li>after the current test, when declared at the method level, or</li>, + * <li>after the current test class, when declared at the class level.</li>, + * </ul>, + * <p>, + * Use this annotation if a test has modified the context (for example, by, + * replacing a bean definition). Subsequent tests will be supplied a new, + * context., + * </p>, + * <p>, + * <code>&#064;DirtiesContext</code> may be used as a class-level and, + * method-level annotation within the same class. In such scenarios, the, + * <code>ApplicationContext</code> will be marked as <em>dirty</em> after any, + * such annotated method as well as after the entire class., + * </p>, +@Target( { ElementType.TYPE, ElementType.METHOD }), +++ b/org.springframework.test/src/main/java/org/springframework/test/context/TestContextManager.java, + * Copyright 2002-2009 the original author or authors., +	 * Hook for pre-processing a test class <em>before</em> execution of any, +	 * tests within the class. Should be called prior to any framework-specific, +	 * <em>before class methods</em> (e.g., methods annotated with JUnit's, +	 * {@link org.junit.BeforeClass &#064;BeforeClass})., +	 * <p>, +	 * An attempt will be made to give each registered, +	 * {@link TestExecutionListener} a chance to pre-process the test class, +	 * execution. If a listener throws an exception, however, the remaining, +	 * registered listeners will <strong>not</strong> be called., +	 * , +	 * @throws Exception if a registered TestExecutionListener throws an, +	 * exception, +	 * @see #getTestExecutionListeners(), +	 */, +	public void beforeTestClass() throws Exception {, +		final Class<?> testClass = getTestContext().getTestClass();, +		if (logger.isTraceEnabled()) {, +			logger.trace("beforeTestClass(): class [" + testClass + "]");, +		}, +, +		for (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {, +			try {, +				testExecutionListener.beforeTestClass(getTestContext());, +			}, +			catch (Exception ex) {, +				logger.warn("Caught exception while allowing TestExecutionListener [" + testExecutionListener, +						+ "] to process 'before class' callback for test class [" + testClass + "]", ex);, +				throw ex;, +			}, +		}, +	}, +, +	/**, +	/**, +	 * Hook for post-processing a test class <em>after</em> execution of all, +	 * tests within the class. Should be called after any framework-specific, +	 * <em>after class methods</em> (e.g., methods annotated with JUnit's, +	 * {@link org.junit.AfterClass &#064;AfterClass})., +	 * <p>, +	 * Each registered {@link TestExecutionListener} will be given a chance to, +	 * post-process the test class. If a listener throws an exception, the, +	 * remaining registered listeners will still be called, but the first, +	 * exception thrown will be tracked and rethrown after all listeners have, +	 * executed. Note that registered listeners will be executed in the opposite, +	 * order in which they were registered., +	 * , +	 * @throws Exception if a registered TestExecutionListener throws an, +	 * exception, +	 * @see #getTestExecutionListeners(), +	 */, +	public void afterTestClass() throws Exception {, +		final Class<?> testClass = getTestContext().getTestClass();, +		if (logger.isTraceEnabled()) {, +			logger.trace("afterTestClass(): class [" + testClass + "]");, +		}, +, +		// Traverse the TestExecutionListeners in reverse order to ensure proper, +		// "wrapper"-style execution of listeners.]