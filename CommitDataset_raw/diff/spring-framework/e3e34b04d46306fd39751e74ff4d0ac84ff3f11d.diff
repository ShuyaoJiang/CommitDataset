[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessage.java, +	UNABLE_TO_CREATE_LIST_FOR_INDEXING(Kind.ERROR,1054,"Unable to dynamically create a List to replace a null value"),//, +	UNABLE_TO_CREATE_MAP_FOR_INDEXING(Kind.ERROR,1055,"Unable to dynamically create a Map to replace a null value"),//, +	UNABLE_TO_DYNAMICALLY_CREATE_OBJECT(Kind.ERROR,1056,"Unable to dynamically create instance of ''{0}'' to replace a null value"),//, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessage.java, +	UNABLE_TO_CREATE_LIST_FOR_INDEXING(Kind.ERROR,1054,"Unable to dynamically create a List to replace a null value"),//, +	UNABLE_TO_CREATE_MAP_FOR_INDEXING(Kind.ERROR,1055,"Unable to dynamically create a Map to replace a null value"),//, +	UNABLE_TO_DYNAMICALLY_CREATE_OBJECT(Kind.ERROR,1056,"Unable to dynamically create instance of ''{0}'' to replace a null value"),//, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +		if (targetObjectTypeDescriptor.isMap()) {, +			if (targetObject == null) {, +			    // Current decision: attempt to index into null map == exception and does not just return null, +				throw new SpelEvaluationException(getStartPosition(),SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);, +//				if (targetObjectTypeDescriptor.isMapEntryTypeKnown()) {, +//					return new TypedValue(null,TypeDescriptor.valueOf(targetObjectTypeDescriptor.getMapValueType()));, +//				} else {, +//					return new TypedValue(null,TypeDescriptor.NULL);				, +//				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessage.java, +	UNABLE_TO_CREATE_LIST_FOR_INDEXING(Kind.ERROR,1054,"Unable to dynamically create a List to replace a null value"),//, +	UNABLE_TO_CREATE_MAP_FOR_INDEXING(Kind.ERROR,1055,"Unable to dynamically create a Map to replace a null value"),//, +	UNABLE_TO_DYNAMICALLY_CREATE_OBJECT(Kind.ERROR,1056,"Unable to dynamically create instance of ''{0}'' to replace a null value"),//, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +		if (targetObjectTypeDescriptor.isMap()) {, +			if (targetObject == null) {, +			    // Current decision: attempt to index into null map == exception and does not just return null, +				throw new SpelEvaluationException(getStartPosition(),SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);, +//				if (targetObjectTypeDescriptor.isMapEntryTypeKnown()) {, +//					return new TypedValue(null,TypeDescriptor.valueOf(targetObjectTypeDescriptor.getMapValueType()));, +//				} else {, +//					return new TypedValue(null,TypeDescriptor.NULL);				, +//				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +import java.util.HashMap;, +		TypeDescriptor resultDescriptor = result.getTypeDescriptor();, +		// Dynamically create the objects if the user has requested that optional behaviour, +		if (result.getValue()==null && state.configuredToCreateCollectionOrMap() && nextChildIs(Indexer.class,PropertyOrFieldReference.class)) {, +			// Creating lists and maps, +			if ((resultDescriptor.getType().equals(List.class) || resultDescriptor.getType().equals(Map.class))) {, +				// Create a new collection or map ready for the indexer, +				if (resultDescriptor.getType().equals(List.class)) {, +				} else {, +					try { , +						if (isWritable(state)) {, +							Map newMap = HashMap.class.newInstance();, +							writeProperty(state, name, newMap);, +							result = readProperty(state, this.name);, +						}, +					} catch (InstantiationException e) {, +						throw new SpelEvaluationException(getStartPosition(), e, SpelMessage.UNABLE_TO_CREATE_MAP_FOR_INDEXING);, +					} catch (IllegalAccessException e) {, +						throw new SpelEvaluationException(getStartPosition(), e, SpelMessage.UNABLE_TO_CREATE_MAP_FOR_INDEXING);, +					}, +				}, +			} else {, +				// 'simple' object, +				try { , +					if (isWritable(state)) {, +						Object newObject  = result.getTypeDescriptor().getType().newInstance();, +						writeProperty(state, name, newObject);, +						result = readProperty(state, this.name);, +					}, +				} catch (InstantiationException e) {, +					throw new SpelEvaluationException(getStartPosition(), e, SpelMessage.UNABLE_TO_DYNAMICALLY_CREATE_OBJECT,result.getTypeDescriptor().getType());, +				} catch (IllegalAccessException e) {, +					throw new SpelEvaluationException(getStartPosition(), e, SpelMessage.UNABLE_TO_DYNAMICALLY_CREATE_OBJECT,result.getTypeDescriptor().getType());, +				}				, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessage.java, +	UNABLE_TO_CREATE_LIST_FOR_INDEXING(Kind.ERROR,1054,"Unable to dynamically create a List to replace a null value"),//, +	UNABLE_TO_CREATE_MAP_FOR_INDEXING(Kind.ERROR,1055,"Unable to dynamically create a Map to replace a null value"),//, +	UNABLE_TO_DYNAMICALLY_CREATE_OBJECT(Kind.ERROR,1056,"Unable to dynamically create instance of ''{0}'' to replace a null value"),//, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +		if (targetObjectTypeDescriptor.isMap()) {, +			if (targetObject == null) {, +			    // Current decision: attempt to index into null map == exception and does not just return null, +				throw new SpelEvaluationException(getStartPosition(),SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);, +//				if (targetObjectTypeDescriptor.isMapEntryTypeKnown()) {, +//					return new TypedValue(null,TypeDescriptor.valueOf(targetObjectTypeDescriptor.getMapValueType()));, +//				} else {, +//					return new TypedValue(null,TypeDescriptor.NULL);				, +//				}, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +import java.util.HashMap;, +		TypeDescriptor resultDescriptor = result.getTypeDescriptor();, +		// Dynamically create the objects if the user has requested that optional behaviour, +		if (result.getValue()==null && state.configuredToCreateCollectionOrMap() && nextChildIs(Indexer.class,PropertyOrFieldReference.class)) {, +			// Creating lists and maps, +			if ((resultDescriptor.getType().equals(List.class) || resultDescriptor.getType().equals(Map.class))) {, +				// Create a new collection or map ready for the indexer, +				if (resultDescriptor.getType().equals(List.class)) {, +				} else {, +					try { , +						if (isWritable(state)) {, +							Map newMap = HashMap.class.newInstance();, +							writeProperty(state, name, newMap);, +							result = readProperty(state, this.name);]