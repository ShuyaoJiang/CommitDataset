[+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/EnableAsync.java, + * <p><b>NOTE: {@link AsyncConfigurer} configuration classes get initialized early, + * in the application context bootstrap. If you need any dependencies on other beans, + * there, make sure to declare them 'lazy' as far as possible in order to let them, + * go through other post-processors as well.</b>, + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/EnableAsync.java, + * <p><b>NOTE: {@link AsyncConfigurer} configuration classes get initialized early, + * in the application context bootstrap. If you need any dependencies on other beans, + * there, make sure to declare them 'lazy' as far as possible in order to let them, + * go through other post-processors as well.</b>, + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolExecutorFactoryBean.java, + * Copyright 2002-2018 the original author or authors., + * <p>The default configuration is a core pool size of 1, with unlimited max pool size, + * and unlimited queue capacity. This is roughly equivalent to, + * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single, + * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics, + * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling, + * of threads in the pool to a potentially very high number. Consider also setting a, + * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher, + * {@link #setCorePoolSize "corePoolSize"} (see also the, + * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling)., + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/EnableAsync.java, + * <p><b>NOTE: {@link AsyncConfigurer} configuration classes get initialized early, + * in the application context bootstrap. If you need any dependencies on other beans, + * there, make sure to declare them 'lazy' as far as possible in order to let them, + * go through other post-processors as well.</b>, + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolExecutorFactoryBean.java, + * Copyright 2002-2018 the original author or authors., + * <p>The default configuration is a core pool size of 1, with unlimited max pool size, + * and unlimited queue capacity. This is roughly equivalent to, + * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single, + * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics, + * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling, + * of threads in the pool to a potentially very high number. Consider also setting a, + * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher, + * {@link #setCorePoolSize "corePoolSize"} (see also the, + * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling)., + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.java, + * <p>The default configuration is a core pool size of 1, with unlimited max pool size, + * and unlimited queue capacity. This is roughly equivalent to, + * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single, + * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics, + * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling, + * of threads in the pool to a potentially very high number. Consider also setting a, + * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher, + * {@link #setCorePoolSize "corePoolSize"} (see also the, + * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling)., + * <p>For an alternative, you may set up a ThreadPoolExecutor instance directly using, + * constructor injection, or use a factory method definition that points to the, + * {@link java.util.concurrent.Executors} class. To expose such a raw Executor as a, + * Spring {@link org.springframework.core.task.TaskExecutor}, simply wrap it with a, + * {@link org.springframework.scheduling.concurrent.ConcurrentTaskExecutor} adapter., + * @see ThreadPoolExecutorFactoryBean, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/EnableAsync.java, + * <p><b>NOTE: {@link AsyncConfigurer} configuration classes get initialized early, + * in the application context bootstrap. If you need any dependencies on other beans, + * there, make sure to declare them 'lazy' as far as possible in order to let them, + * go through other post-processors as well.</b>, + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolExecutorFactoryBean.java, + * Copyright 2002-2018 the original author or authors., + * <p>The default configuration is a core pool size of 1, with unlimited max pool size, + * and unlimited queue capacity. This is roughly equivalent to, + * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single, + * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics, + * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling, + * of threads in the pool to a potentially very high number. Consider also setting a, + * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher, + * {@link #setCorePoolSize "corePoolSize"} (see also the, + * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling)., + *, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.java, + * <p>The default configuration is a core pool size of 1, with unlimited max pool size, + * and unlimited queue capacity. This is roughly equivalent to, + * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single, + * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics, + * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling, + * of threads in the pool to a potentially very high number. Consider also setting a, + * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher, + * {@link #setCorePoolSize "corePoolSize"} (see also the, + * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling)., + * <p>For an alternative, you may set up a ThreadPoolExecutor instance directly using, + * constructor injection, or use a factory method definition that points to the, + * {@link java.util.concurrent.Executors} class. To expose such a raw Executor as a, + * Spring {@link org.springframework.core.task.TaskExecutor}, simply wrap it with a, + * {@link org.springframework.scheduling.concurrent.ConcurrentTaskExecutor} adapter., + * @see ThreadPoolExecutorFactoryBean, +++ b/src/docs/asciidoc/integration.adoc, +Spring distribution. In all likelihood, you should never need to implement your own., +The common out-of-the-box variants are:, +* `SyncTaskExecutor`, +  This implementation does not execute invocations asynchronously. Instead, each, +  invocation takes place in the calling thread. It is primarily used in situations, +  where multi-threading is not necessary such as in simple test cases., +  are looking for true pooling, see `ThreadPoolTaskExecutor` below.]