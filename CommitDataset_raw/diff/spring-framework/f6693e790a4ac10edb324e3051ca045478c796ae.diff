[+++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), true);, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), false);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), true);, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), false);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java, + * Copyright 2002-2019 the original author or authors., +import com.fasterxml.jackson.databind.DeserializationContext;, + * @author Rossen Stoyanchev, + * @author Juergen Hoeller, +	private Jackson2Tokenizer(, +			JsonParser parser, DeserializationContext deserializationContext, boolean tokenizeArrayElements) {, +		this.tokenBuffer = new TokenBuffer(parser, deserializationContext);, +			return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex));, +			return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex));, +			if (token == JsonToken.NOT_AVAILABLE ||, +		if ((token.isStructEnd() || token.isScalarValue()) && this.objectDepth == 0 && this.arrayDepth == 0) {, +		if (this.objectDepth == 0 && (this.arrayDepth == 0 || this.arrayDepth == 1) &&, +, +	/**, +	 * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}., +	 * @param dataBuffers the source data buffers, +	 * @param jsonFactory the factory to use, +	 * @param tokenizeArrayElements if {@code true} and the "top level" JSON object is, +	 * an array, each element is returned individually immediately after it is received, +	 * @return the resulting token buffers, +	 */, +	public static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,, +			DeserializationContext deserializationContext, boolean tokenizeArrayElements) {, +, +		try {, +			JsonParser parser = jsonFactory.createNonBlockingByteArrayParser();, +			Jackson2Tokenizer tokenizer = new Jackson2Tokenizer(parser, deserializationContext, tokenizeArrayElements);, +			return dataBuffers.flatMap(tokenizer::tokenize, Flux::error, tokenizer::endOfInput);, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), true);, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				Flux.from(input), this.jsonFactory, getObjectMapper().getDeserializationContext(), false);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java, + * Copyright 2002-2019 the original author or authors., +import com.fasterxml.jackson.databind.DeserializationContext;, + * @author Rossen Stoyanchev, + * @author Juergen Hoeller, +	private Jackson2Tokenizer(, +			JsonParser parser, DeserializationContext deserializationContext, boolean tokenizeArrayElements) {, +		this.tokenBuffer = new TokenBuffer(parser, deserializationContext);, +			return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex));, +			return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex));, +			if (token == JsonToken.NOT_AVAILABLE ||, +		if ((token.isStructEnd() || token.isScalarValue()) && this.objectDepth == 0 && this.arrayDepth == 0) {, +		if (this.objectDepth == 0 && (this.arrayDepth == 0 || this.arrayDepth == 1) &&, +, +	/**, +	 * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}., +	 * @param dataBuffers the source data buffers, +	 * @param jsonFactory the factory to use, +	 * @param tokenizeArrayElements if {@code true} and the "top level" JSON object is, +	 * an array, each element is returned individually immediately after it is received, +	 * @return the resulting token buffers, +	 */, +	public static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,, +			DeserializationContext deserializationContext, boolean tokenizeArrayElements) {, +, +		try {, +			JsonParser parser = jsonFactory.createNonBlockingByteArrayParser();, +			Jackson2Tokenizer tokenizer = new Jackson2Tokenizer(parser, deserializationContext, tokenizeArrayElements);, +			return dataBuffers.flatMap(tokenizer::tokenize, Flux::error, tokenizer::endOfInput);, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +, +++ b/spring-web/src/test/java/org/springframework/http/codec/json/Jackson2TokenizerTests.java, + * Copyright 2002-2019 the original author or authors., +import static java.util.Arrays.*;, +import static java.util.Collections.*;, + * @author Juergen Hoeller, +	private ObjectMapper objectMapper;, +, +, +		Flux<TokenBuffer> result = Jackson2Tokenizer.tokenize(, +				source, this.jsonFactory, this.objectMapper.getDeserializationContext(), true);, +		Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(, +				source, this.jsonFactory, this.objectMapper.getDeserializationContext(), false);, +				this.jsonFactory, this.objectMapper.getDeserializationContext(),, +]