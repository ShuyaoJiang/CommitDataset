[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethod.java, +	 * Create a ServletInvocableHandlerMethod that will return the given value from an, +	 * async operation instead of invoking the controller method again. The async result, +	 * value is then either processed as if the controller method returned it or an, +	 * exception is raised if the async result value itself is an Exception., +	 * A sub-class of {@link HandlerMethod} that invokes the given {@link Callable}, +	 * instead of the target controller method. This is useful for resuming processing, +	 * with the result of an async operation. The goal is to process the value returned, +	 * from the Callable as if it was returned by the target controller method, i.e., +	 * taking into consideration both method and type-level controller annotations (e.g., +	 * {@code @ResponseBody}, {@code @ResponseStatus}, etc)., +		/**, +		 * Bridge to type-level annotations of the target controller method., +		 */, +		@Override, +		public Class<?> getBeanType() {, +			return ServletInvocableHandlerMethod.this.getBeanType();, +		}, +, +		/**, +		 * Bridge to method-level annotations of the target controller method., +		 */, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethod.java, +	 * Create a ServletInvocableHandlerMethod that will return the given value from an, +	 * async operation instead of invoking the controller method again. The async result, +	 * value is then either processed as if the controller method returned it or an, +	 * exception is raised if the async result value itself is an Exception., +	 * A sub-class of {@link HandlerMethod} that invokes the given {@link Callable}, +	 * instead of the target controller method. This is useful for resuming processing, +	 * with the result of an async operation. The goal is to process the value returned, +	 * from the Callable as if it was returned by the target controller method, i.e., +	 * taking into consideration both method and type-level controller annotations (e.g., +	 * {@code @ResponseBody}, {@code @ResponseStatus}, etc)., +		/**, +		 * Bridge to type-level annotations of the target controller method., +		 */, +		@Override, +		public Class<?> getBeanType() {, +			return ServletInvocableHandlerMethod.this.getBeanType();, +		}, +, +		/**, +		 * Bridge to method-level annotations of the target controller method., +		 */, +++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethodTests.java, +import java.util.ArrayList;, +import java.util.List;, +import org.springframework.http.ResponseEntity;, +import org.springframework.http.converter.HttpMessageConverter;, +import org.springframework.http.converter.StringHttpMessageConverter;, +import org.springframework.web.bind.annotation.ResponseBody;, +import org.springframework.web.context.request.async.DeferredResult;, +import static org.junit.Assert.*;, +, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "responseStatus");, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "httpServletResponse", HttpServletResponse.class);, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "notModified");, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "responseStatusWithReason");, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "handle");, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "dynamicReturnValue", String.class);, +	@Test, +	public void wrapConcurrentResult_MethodLevelResponseBody() throws Exception {, +		wrapConcurrentResult_ResponseBody(new MethodLevelResponseBodyHandler());, +	}, +	@Test, +	public void wrapConcurrentResult_TypeLevelResponseBody() throws Exception {, +		wrapConcurrentResult_ResponseBody(new TypeLevelResponseBodyHandler());, +	}, +, +	private void wrapConcurrentResult_ResponseBody(Object handler) throws Exception {, +		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();, +		converters.add(new StringHttpMessageConverter());, +		returnValueHandlers.addHandler(new RequestResponseBodyMethodProcessor(converters));, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(handler, "handle");, +		handlerMethod = handlerMethod.wrapConcurrentResult("bar");, +		handlerMethod.invokeAndHandle(webRequest, mavContainer);, +, +		assertEquals("bar", response.getContentAsString());, +	}, +, +	@Test, +	public void wrapConcurrentResult_ResponseEntity() throws Exception {, +		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();, +		converters.add(new StringHttpMessageConverter());, +		returnValueHandlers.addHandler(new HttpEntityMethodProcessor(converters));, +		ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseEntityHandler(), "handle");, +		handlerMethod = handlerMethod.wrapConcurrentResult(new ResponseEntity<>("bar", HttpStatus.OK));, +		handlerMethod.invokeAndHandle(webRequest, mavContainer);, +, +		assertEquals("bar", response.getContentAsString());, +	}, +, +, +	private ServletInvocableHandlerMethod getHandlerMethod(Object controller,, +			String methodName, Class<?>... argTypes) throws NoSuchMethodException {, +, +		Method method = controller.getClass().getDeclaredMethod(methodName, argTypes);, +		ServletInvocableHandlerMethod handlerMethod = new ServletInvocableHandlerMethod(controller, method);, +	private static class MethodLevelResponseBodyHandler {, +]