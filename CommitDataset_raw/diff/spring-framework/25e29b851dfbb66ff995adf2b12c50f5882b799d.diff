[+++ b/spring-context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, + * Copyright 2002-2013 the original author or authors., +		Class<?> typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +			Class<?> targetClass = AopUtils.getTargetClass(this.delegate);, +++ b/spring-context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, + * Copyright 2002-2013 the original author or authors., +		Class<?> typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +			Class<?> targetClass = AopUtils.getTargetClass(this.delegate);, +++ b/spring-core/src/main/java/org/springframework/core/GenericCollectionTypeResolver.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.MalformedParameterizedTypeException;, +			try {, +				return extractType(clazz.getGenericSuperclass(), source, typeIndex, typeVariableMap,, +						typeIndexesPerLevel, nestingLevel, currentLevel);, +			}, +			catch (MalformedParameterizedTypeException ex) {, +				// from getGenericSuperclass() - ignore and continue with interface introspection, +			}, +++ b/spring-context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, + * Copyright 2002-2013 the original author or authors., +		Class<?> typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +			Class<?> targetClass = AopUtils.getTargetClass(this.delegate);, +++ b/spring-core/src/main/java/org/springframework/core/GenericCollectionTypeResolver.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.MalformedParameterizedTypeException;, +			try {, +				return extractType(clazz.getGenericSuperclass(), source, typeIndex, typeVariableMap,, +						typeIndexesPerLevel, nestingLevel, currentLevel);, +			}, +			catch (MalformedParameterizedTypeException ex) {, +				// from getGenericSuperclass() - ignore and continue with interface introspection, +			}, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +import java.lang.reflect.MalformedParameterizedTypeException;, +	public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {, +		Class<?> result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType());, +	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {, +	public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +	private static Class[] doResolveTypeArguments(Class<?> ownerClass, Class<?> classToIntrospect, Class<?> genericIfc) {, +				try {, +					Class[] result = doResolveTypeArguments(ownerClass, classToIntrospect.getGenericSuperclass(), genericIfc);, +				catch (MalformedParameterizedTypeException ex) {, +					// from getGenericSuperclass() - return null to skip further superclass traversal, +					return null;, +				}, +			}, +	private static Class[] doResolveTypeArguments(Class<?> ownerClass, Type ifc, Class<?> genericIfc) {, +	private static Class<?> extractClass(Class<?> ownerClass, Type arg) {, +	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {, +			try {, +				Class<?> type = clazz;, +				while (type.getSuperclass() != null && !Object.class.equals(type.getSuperclass())) {, +					Type genericType = type.getGenericSuperclass();, +					extractTypeVariablesFromGenericInterfaces(type.getSuperclass().getGenericInterfaces(), typeVariableMap);, +			}, +			catch (MalformedParameterizedTypeException ex) {, +				// from getGenericSuperclass() - ignore and continue with member class check, +			}, +			try {, +				Class<?> type = clazz;, +					Type genericType = type.getGenericSuperclass();, +			}, +			catch (MalformedParameterizedTypeException ex) {, +				// from getGenericSuperclass() - ignore and preserve previously accumulated type variables, +			}, +++ b/spring-context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, + * Copyright 2002-2013 the original author or authors., +		Class<?> typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +			Class<?> targetClass = AopUtils.getTargetClass(this.delegate);, +++ b/spring-core/src/main/java/org/springframework/core/GenericCollectionTypeResolver.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.MalformedParameterizedTypeException;, +			try {, +				return extractType(clazz.getGenericSuperclass(), source, typeIndex, typeVariableMap,, +						typeIndexesPerLevel, nestingLevel, currentLevel);, +			}, +			catch (MalformedParameterizedTypeException ex) {, +				// from getGenericSuperclass() - ignore and continue with interface introspection, +			}, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +import java.lang.reflect.MalformedParameterizedTypeException;, +	public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {, +		Class<?> result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType());, +	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {, +	public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +	private static Class[] doResolveTypeArguments(Class<?> ownerClass, Class<?> classToIntrospect, Class<?> genericIfc) {, +				try {, +					Class[] result = doResolveTypeArguments(ownerClass, classToIntrospect.getGenericSuperclass(), genericIfc);, +				catch (MalformedParameterizedTypeException ex) {, +					// from getGenericSuperclass() - return null to skip further superclass traversal, +					return null;, +				}, +			}, +	private static Class[] doResolveTypeArguments(Class<?> ownerClass, Type ifc, Class<?> genericIfc) {, +	private static Class<?> extractClass(Class<?> ownerClass, Type arg) {, +	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {, +			try {, +				Class<?> type = clazz;, +				while (type.getSuperclass() != null && !Object.class.equals(type.getSuperclass())) {, +					Type genericType = type.getGenericSuperclass();]