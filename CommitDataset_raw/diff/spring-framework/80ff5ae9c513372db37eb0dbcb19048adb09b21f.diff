[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +import org.apache.commons.logging.LogFactory;, +import io.netty.handler.codec.http.HttpResponseStatus;, +, +		return this.httpHandler.handle(adaptedRequest, adaptedResponse), +				.otherwise(ex -> {, +					LogFactory.getLog(ReactorHttpHandlerAdapter.class).error("Could not complete request", ex);, +					channel.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);, +					return Mono.empty();, +				});, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +import org.apache.commons.logging.LogFactory;, +import io.netty.handler.codec.http.HttpResponseStatus;, +, +		return this.httpHandler.handle(adaptedRequest, adaptedResponse), +				.otherwise(ex -> {, +					LogFactory.getLog(ReactorHttpHandlerAdapter.class).error("Could not complete request", ex);, +					channel.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);, +					return Mono.empty();, +				});, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/RxNettyHttpHandlerAdapter.java, +import io.netty.handler.codec.http.HttpResponseStatus;, +, +import org.apache.commons.logging.LogFactory;, +import reactor.core.publisher.Mono;, +		Publisher<Void> result = this.httpHandler.handle(adaptedRequest, adaptedResponse), +				.otherwise(ex -> {, +					LogFactory.getLog(RxNettyHttpHandlerAdapter.class).error("Could not complete request", ex);, +					response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);, +					return Mono.empty();, +				});, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyProcessor.java, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onError: " + t);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +import org.apache.commons.logging.LogFactory;, +import io.netty.handler.codec.http.HttpResponseStatus;, +, +		return this.httpHandler.handle(adaptedRequest, adaptedResponse), +				.otherwise(ex -> {, +					LogFactory.getLog(ReactorHttpHandlerAdapter.class).error("Could not complete request", ex);, +					channel.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);, +					return Mono.empty();, +				});, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/RxNettyHttpHandlerAdapter.java, +import io.netty.handler.codec.http.HttpResponseStatus;, +, +import org.apache.commons.logging.LogFactory;, +import reactor.core.publisher.Mono;, +		Publisher<Void> result = this.httpHandler.handle(adaptedRequest, adaptedResponse), +				.otherwise(ex -> {, +					LogFactory.getLog(RxNettyHttpHandlerAdapter.class).error("Could not complete request", ex);, +					response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);, +					return Mono.empty();, +				});, +++ b/spring-web/src/main/java/org/springframework/web/server/handler/ExceptionHandlingWebHandler.java, +import java.util.HashSet;, +import java.util.Set;, +import org.springframework.core.NestedCheckedException;, +	/**, +	 * Log category to use on network IO exceptions after a client has gone away., +	 * <p>The Servlet API does not provide notifications when a client disconnects;, +	 * see <a href="https://java.net/jira/browse/SERVLET_SPEC-44">SERVLET_SPEC-44</a>., +	 * Therefore network IO failures may occur simply because a client has gone away,, +	 * and that can fill the logs with unnecessary stack traces., +	 * <p>We make a best effort to identify such network failures, on a per-server, +	 * basis, and log them under a separate log category. A simple one-line message, +	 * is logged at DEBUG level, while a full stack trace is shown at TRACE level., +	 * @see #disconnectedClientLogger, +	 */, +	private static final String DISCONNECTED_CLIENT_LOG_CATEGORY =, +			"org.springframework.web.server.handler.DisconnectedClient";, +, +	/**, +	 * Separate logger to use on network IO failure after a client has gone away., +	 * @see #DISCONNECTED_CLIENT_LOG_CATEGORY]