[+++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = DEFAULT_PHASE;, +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = DEFAULT_PHASE;, +++ b/spring-context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2018 the original author or authors., + * <p>Note that the present {@code Lifecycle} interface is only supported on, + * <b>top-level singleton beans</b>. On any other component, the {@code Lifecycle}, + * interface will remain undetected and hence ignored. Also, note that the extended, + * {@link SmartLifecycle} interface provides sophisticated integration with the, + * application context's startup and shutdown phases., +	 * <p>Note that this stop notification is not guaranteed to come before destruction:, +	 * On regular shutdown, {@code Lifecycle} beans will first receive a stop notification, +	 * before the general destruction callbacks are being propagated; however, on hot, +	 * refresh during a context's lifetime or on aborted refresh attempts, a given bean's, +	 * destroy method will be called without any consideration of stop signals upfront., +	 * <p>Should not throw an exception if the component is not running (not started yet)., +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = DEFAULT_PHASE;, +++ b/spring-context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2018 the original author or authors., + * <p>Note that the present {@code Lifecycle} interface is only supported on, + * <b>top-level singleton beans</b>. On any other component, the {@code Lifecycle}, + * interface will remain undetected and hence ignored. Also, note that the extended, + * {@link SmartLifecycle} interface provides sophisticated integration with the, + * application context's startup and shutdown phases., +	 * <p>Note that this stop notification is not guaranteed to come before destruction:, +	 * On regular shutdown, {@code Lifecycle} beans will first receive a stop notification, +	 * before the general destruction callbacks are being propagated; however, on hot, +	 * refresh during a context's lifetime or on aborted refresh attempts, a given bean's, +	 * destroy method will be called without any consideration of stop signals upfront., +	 * <p>Should not throw an exception if the component is not running (not started yet)., +++ b/spring-context/src/main/java/org/springframework/context/SmartLifecycle.java, + * Copyright 2002-2018 the original author or authors., + * callback's {@code run()} method upon shutdown completion to avoid unnecessary, + * delays in the overall ApplicationContext shutdown., + * be started and stopped. The startup process begins with the <i>lowest</i> phase, + * value and ends with the <i>highest</i> phase value ({@code Integer.MIN_VALUE}, + * is the lowest possible, and {@code Integer.MAX_VALUE} is the highest possible)., + * The shutdown process will apply the reverse order. Any components with the, + * <p>Example: if component B depends on component A having already started,, + * then component A should have a lower phase value than component B. During, + * the shutdown process, component B would be stopped before component A., + * <p>Any explicit "depends-on" relationship will take precedence over the phase, + * order such that the dependent bean always starts after its dependency and, + * always stops before its dependency., + * <p>Any {@code Lifecycle} components within the context that do not also, + * implement {@code SmartLifecycle} will be treated as if they have a phase, + * value of 0. That way a {@code SmartLifecycle} implementation may start, + * before those {@code Lifecycle} components if it has a negative phase value,, + * or it may start after those components if it has a positive phase value., + * <p>Note that, due to the auto-startup support in {@code SmartLifecycle}, a, + * {@code SmartLifecycle} bean instance will usually get initialized on startup, + * of the application context in any case. As a consequence, the bean definition, + * lazy-init flag has very limited actual effect on {@code SmartLifecycle} beans., + * @author Juergen Hoeller, +	 * The default phase for {@code SmartLifecycle}: {@code Integer.MAX_VALUE}., +	 * <p>This is different from the common phase 0 associated with regular, +	 * {@link Lifecycle} implementations, putting the typically auto-started, +	 * {@code SmartLifecycle} beans into a separate later shutdown phase., +	 * @since 5.1, +	 * @see #getPhase(), +	 * @see org.springframework.context.support.DefaultLifecycleProcessor#getPhase(Lifecycle), +	 */, +	int DEFAULT_PHASE = Integer.MAX_VALUE;, +, +, +	/**, +	 * <p>The default implementation returns {@code true}., +	default boolean isAutoStartup() {, +		return true;, +	}, +	 * <p>The default implementation delegates to {@link #stop()} and immediately, +	 * triggers the given callback in the calling thread. Note that there is no, +	 * synchronization between the two, so custom implementations may at least, +	 * want to put the same steps within their common lifecycle monitor (if any)., +	default void stop(Runnable callback) {, +		stop();, +		callback.run();, +	}, +, +	/**, +	 * Return the phase that this lifecycle object is supposed to run in., +	 * <p>The default implementation returns {@link #DEFAULT_PHASE} in order to, +	 * let stop callbacks execute after regular {@code Lifecycle} implementations., +	 * @see #isAutoStartup(), +	 * @see #start(), +	 * @see #stop(Runnable), +	 * @see org.springframework.context.support.DefaultLifecycleProcessor#getPhase(Lifecycle), +	 */, +	@Override, +	default int getPhase() {, +		return DEFAULT_PHASE;, +	}, +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java, +	private int phase = DEFAULT_PHASE;, +++ b/spring-context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2018 the original author or authors., + * <p>Note that the present {@code Lifecycle} interface is only supported on, + * <b>top-level singleton beans</b>. On any other component, the {@code Lifecycle}]