[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/View.java, +	 * Return the list of media types this View supports, or an empty list., +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/View.java, +	 * Return the list of media types this View supports, or an empty list., +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.java, +import org.springframework.http.MediaType;, +import org.springframework.web.reactive.accept.HeaderContentTypeResolver;, +import org.springframework.web.reactive.accept.RequestedContentTypeResolver;, +import org.springframework.web.reactive.result.ContentNegotiatingResultHandlerSupport;, +import org.springframework.web.server.NotAcceptableStatusException;, + * <p>By default this resolver is ordered at {@link Ordered#LOWEST_PRECEDENCE}, + * and generally needs to be late in the order since it interprets any String, + * return value as a view name while others may interpret the same otherwise, + * based on annotations (e.g. for {@code @ResponseBody})., +public class ViewResolutionResultHandler extends ContentNegotiatingResultHandlerSupport, +		implements HandlerResultHandler, Ordered {, +	private final List<View> defaultViews = new ArrayList<>(4);, +	 * Constructor with {@code ViewResolver}s and a {@code ConversionService} only, +	 * and creating a {@link HeaderContentTypeResolver}, i.e. using Accept header, +	 * to determine the requested content type., +	 * @param resolvers the resolver to use, +	 * @param conversionService for converting other reactive types (e.g. rx.Single) to Mono, +	 */, +	public ViewResolutionResultHandler(List<ViewResolver> resolvers, ConversionService conversionService) {, +		this(resolvers, conversionService, new HeaderContentTypeResolver());, +	}, +, +	/**, +	 * @param conversionService for converting other reactive types (e.g. rx.Single) to Mono, +	 * @param contentTypeResolver for resolving the requested content type, +	public ViewResolutionResultHandler(List<ViewResolver> resolvers, ConversionService conversionService,, +			RequestedContentTypeResolver contentTypeResolver) {, +, +		super(conversionService, contentTypeResolver);, +	 * Set the default views to consider always when resolving view names and, +	 * trying to satisfy the best matching content type., +	public void setDefaultViews(List<View> defaultViews) {, +		this.defaultViews.clear();, +		if (defaultViews != null) {, +			this.defaultViews.addAll(defaultViews);, +		}, +	public List<View> getDefaultViews() {, +		return this.defaultViews;, +		if (getConversionService().canConvert(clazz, Mono.class)) {, +		if (getConversionService().canConvert(returnType.getRawClass(), Mono.class)) {, +				Mono<?> converted = getConversionService().convert(optionalValue.get(), Mono.class);, +				return resolveViewAndRender(viewName, locale, result, exchange);, +, +	private Mono<? extends Void> resolveViewAndRender(String viewName, Locale locale,, +			HandlerResult result, ServerWebExchange exchange) {, +, +		return Flux.fromIterable(getViewResolvers()), +				.concatMap(resolver -> resolver.resolveViewName(viewName, locale)), +				.switchIfEmpty(Mono.error(, +						new IllegalStateException(, +								"Could not resolve view with name '" + viewName + "'."))), +				.asList(), +				.then(views -> {, +					views.addAll(getDefaultViews());, +, +					List<MediaType> producibleTypes = getProducibleMediaTypes(views);, +					MediaType bestMediaType = selectMediaType(exchange, producibleTypes);, +, +					if (bestMediaType != null) {, +						for (View view : views) {, +							for (MediaType supported : view.getSupportedMediaTypes()) {, +								if (supported.isCompatibleWith(bestMediaType)) {, +									return view.render(result, bestMediaType, exchange);, +								}, +							}, +						}, +					}, +, +					return Mono.error(new NotAcceptableStatusException(producibleTypes));, +				});, +	}, +, +	private List<MediaType> getProducibleMediaTypes(List<View> views) {, +		List<MediaType> result = new ArrayList<>();, +		views.forEach(view -> result.addAll(view.getSupportedMediaTypes()));, +		return result;, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/View.java, +	 * Return the list of media types this View supports, or an empty list., +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.java, +import org.springframework.http.MediaType;, +import org.springframework.web.reactive.accept.HeaderContentTypeResolver;, +import org.springframework.web.reactive.accept.RequestedContentTypeResolver;, +import org.springframework.web.reactive.result.ContentNegotiatingResultHandlerSupport;, +import org.springframework.web.server.NotAcceptableStatusException;, + * <p>By default this resolver is ordered at {@link Ordered#LOWEST_PRECEDENCE}, + * and generally needs to be late in the order since it interprets any String, + * return value as a view name while others may interpret the same otherwise, + * based on annotations (e.g. for {@code @ResponseBody})., +public class ViewResolutionResultHandler extends ContentNegotiatingResultHandlerSupport, +		implements HandlerResultHandler, Ordered {, +	private final List<View> defaultViews = new ArrayList<>(4);, +	 * Constructor with {@code ViewResolver}s and a {@code ConversionService} only, +	 * and creating a {@link HeaderContentTypeResolver}, i.e. using Accept header, +	 * to determine the requested content type., +	 * @param resolvers the resolver to use]