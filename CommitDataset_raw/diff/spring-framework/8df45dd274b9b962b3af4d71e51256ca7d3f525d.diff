[+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/Async.java, + * {@link java.util.concurrent.Future}. In the latter case, you may declare the, + * more specific {@link org.springframework.util.concurrent.ListenableFuture} or, + * {@link java.util.concurrent.CompletableFuture} types which allow for richer, + * interaction with the asynchronous task and for immediate composition with, + * further processing steps., + *, + * <p>A {@code Future} handle returned from the proxy will be an actual asynchronous, + * {@code Future} that can be used to track the result of the asynchronous method, + * execution. However, since the target method needs to implement the same signature,, + * it will have to return a temporary {@code Future} handle that just passes a value, + * through: e.g. Spring's {@link AsyncResult}, EJB 3.1's {@link javax.ejb.AsyncResult},, + * or {@link java.util.concurrent.CompletableFuture#completedFuture(Object)}., +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/Async.java, + * {@link java.util.concurrent.Future}. In the latter case, you may declare the, + * more specific {@link org.springframework.util.concurrent.ListenableFuture} or, + * {@link java.util.concurrent.CompletableFuture} types which allow for richer, + * interaction with the asynchronous task and for immediate composition with, + * further processing steps., + *, + * <p>A {@code Future} handle returned from the proxy will be an actual asynchronous, + * {@code Future} that can be used to track the result of the asynchronous method, + * execution. However, since the target method needs to implement the same signature,, + * it will have to return a temporary {@code Future} handle that just passes a value, + * through: e.g. Spring's {@link AsyncResult}, EJB 3.1's {@link javax.ejb.AsyncResult},, + * or {@link java.util.concurrent.CompletableFuture#completedFuture(Object)}., +++ b/src/asciidoc/integration.adoc, +, +, +, +, +behind the scenes for each annotated method, using a `JmsListenerContainerFactory`., +Such a container is not registered against the application context but can be easily, +[TIP], +====, +`@JmsListener` is a _repeatable_ annotation on Java 8, so it is possible to associate, +several JMS destinations to the same method by adding additional `@JmsListener`, +declarations to it. On Java 6 and 7, you can use the `@JmsListeners` annotation., +====, +[TIP], +====, +If you have several `@JmsListener`-annotated methods, you can also place the `@SendTo`, +annotation at the class level to share a default reply destination., +====, +=== JMS namespace support, +==== The @Scheduled annotation, +==== The @Async annotation, +[TIP], +====, +`@Async` methods may not only declare a regular `java.util.concurrent.Future` return type, +but also Spring's `org.springframework.util.concurrent.ListenableFuture` or, as of Spring, +4.2, JDK 8's `java.util.concurrent.CompletableFuture`: for richer interaction with the, +asynchronous task and for immediate composition with further processing steps., +====, +, +, +, +, +=== The task namespace]