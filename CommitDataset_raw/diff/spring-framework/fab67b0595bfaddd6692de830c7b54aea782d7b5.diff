[+++ b/spring-beans/src/main/java/org/springframework/beans/BeanUtils.java, + * Copyright 2002-2014 the original author or authors., +import java.util.Set;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final Set<Class<?>> unknownEditorTypes =, +			Collections.newSetFromMap(new ConcurrentReferenceHashMap<Class<?>, Boolean>(64));, +		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {, +				unknownEditorTypes.add(targetType);, +			unknownEditorTypes.add(targetType);, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanUtils.java, + * Copyright 2002-2014 the original author or authors., +import java.util.Set;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final Set<Class<?>> unknownEditorTypes =, +			Collections.newSetFromMap(new ConcurrentReferenceHashMap<Class<?>, Boolean>(64));, +		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {, +				unknownEditorTypes.add(targetType);, +			unknownEditorTypes.add(targetType);, +++ b/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java, +import java.util.Collections;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	static final Set<ClassLoader> acceptedClassLoaders =, +			Collections.newSetFromMap(new ConcurrentHashMap<ClassLoader, Boolean>(16));, +	 * Map keyed by Class containing CachedIntrospectionResults, strongly held., +	 * This variant is being used for cache-safe bean classes., +	static final Map<Class<?>, CachedIntrospectionResults> strongClassCache =, +			new ConcurrentHashMap<Class<?>, CachedIntrospectionResults>(64);, +, +	/**, +	 * Map keyed by Class containing CachedIntrospectionResults, softly held., +	 * This variant is being used for non-cache-safe bean classes., +	 */, +	static final Map<Class<?>, CachedIntrospectionResults> softClassCache =, +			new ConcurrentReferenceHashMap<Class<?>, CachedIntrospectionResults>(64);, +		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator(); it.hasNext();) {, +			Class<?> beanClass = it.next();, +			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {, +				it.remove();, +			}, +		}, +		for (Iterator<Class<?>> it = softClassCache.keySet().iterator(); it.hasNext();) {, +			Class<?> beanClass = it.next();, +			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {, +				it.remove();, +			}, +		CachedIntrospectionResults results = strongClassCache.get(beanClass);, +		if (results != null) {, +			return results;, +		results = softClassCache.get(beanClass);, +		if (results != null) {, +			return results;, +, +		results = new CachedIntrospectionResults(beanClass);, +			strongClassCache.put(beanClass, results);, +			softClassCache.put(beanClass, results);, +		for (ClassLoader acceptedLoader : acceptedClassLoaders) {, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanUtils.java, + * Copyright 2002-2014 the original author or authors., +import java.util.Set;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final Set<Class<?>> unknownEditorTypes =, +			Collections.newSetFromMap(new ConcurrentReferenceHashMap<Class<?>, Boolean>(64));, +		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {, +				unknownEditorTypes.add(targetType);, +			unknownEditorTypes.add(targetType);, +++ b/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java, +import java.util.Collections;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	static final Set<ClassLoader> acceptedClassLoaders =, +			Collections.newSetFromMap(new ConcurrentHashMap<ClassLoader, Boolean>(16));, +	 * Map keyed by Class containing CachedIntrospectionResults, strongly held., +	 * This variant is being used for cache-safe bean classes., +	static final Map<Class<?>, CachedIntrospectionResults> strongClassCache =, +			new ConcurrentHashMap<Class<?>, CachedIntrospectionResults>(64);, +, +	/**, +	 * Map keyed by Class containing CachedIntrospectionResults, softly held., +	 * This variant is being used for non-cache-safe bean classes., +	 */, +	static final Map<Class<?>, CachedIntrospectionResults> softClassCache =, +			new ConcurrentReferenceHashMap<Class<?>, CachedIntrospectionResults>(64);, +		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator(); it.hasNext();) {, +			Class<?> beanClass = it.next();, +			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {, +				it.remove();, +			}, +		}, +		for (Iterator<Class<?>> it = softClassCache.keySet().iterator(); it.hasNext();) {, +			Class<?> beanClass = it.next();, +			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {, +				it.remove();, +			}, +		CachedIntrospectionResults results = strongClassCache.get(beanClass);, +		if (results != null) {, +			return results;, +		results = softClassCache.get(beanClass);, +		if (results != null) {, +			return results;, +, +		results = new CachedIntrospectionResults(beanClass);]