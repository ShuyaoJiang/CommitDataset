[+++ b/src/docs/asciidoc/web/webflux.adoc, +The `spring-web` module contains the following foundational support for reactive web, +applications:, +* For server request processing there are two levels of support., +** <<webflux-httphandler,HttpHandler>>: Basic contract for HTTP request handling with, +non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty,, +Undertow, Tomcat, Jetty, and any Servlet 3.1+ container., +** <<webflux-web-handler-api>>: Slightly higher level, general-purpose web API for, +request handling, on top of which concrete programming models such as annotated, +controllers and functional endpoints are built., +* For the client side, there is a basic `ClientHttpConnector` contract to perform HTTP, +requests with non-blocking I/O and Reactive Streams back pressure, along with adapters for, +https://github.com/reactor/reactor-netty[Reactor Netty] and for the reactive, +https://github.com/jetty-project/jetty-reactive-httpclient[Jetty HtpClient]., +The higher level <<web-reactive.adoc#webflux-client,WebClient>> used in applications, +builds on this basic contract., +* For client and server, <<webflux-codecs,codecs>> to use to serialize and, +deserialize HTTP request and response content., +intentionally minimal, and its main, and only purpose is to be a minimal abstraction, +over different HTTP server APIs., +The following table describes server dependencies (also see, +The code snippets below show using the `HttpHandler` adapters with each server API:, +The `org.springframework.web.server` package builds on the <<webflux-httphandler>> contract, +to provide a general-purpose web API for processing requests through a chain of multiple, +{api-spring-framework}/web/server/WebExceptionHandler.html[`WebExceptionHandler`], multiple, +{api-spring-framework}/web/server/WebFilter.html[`WebFilter`], and a single, +{api-spring-framework}/web/server/WebHandler.html[`WebHandler`] component. The chain can, +be put together with `WebHttpHandlerBuilder` by simply pointing to a Spring, +`ApplicationContext` where components are, +<<webflux-web-handler-api-special-beans,auto-detected>>, and/or by registering components, +with the builder., +While `HttpHandler` has a simple goal to abstract the use of different HTTP servers, the, +`WebHandler` API aims to provide a broader set of features commonly used in web applications, +such as:, +* User session with attributes., +* Request attributes., +* Resolved `Locale` or `Principal` for the request., +* Access to parsed and cached form data., +* Abstractions for multipart data., +* and more.., +The table below lists the components that `WebHttpHandlerBuilder` can auto-detect in a, +Spring ApplicationContext, or that can be registered directly with it:, +The `spring-web` and `spring-core` modules provide support for serializing and, +deserializing byte content to and from higher level objects through non-blocking I/O with, +Reactive Streams back pressure. The following describes this support:, +, +* {api-spring-framework}/core/codec/Encoder.html[`Encoder`] and, +{api-spring-framework}/core/codec/Decoder.html[`Decoder`] are low level contracts to, +encode and decode content independent of HTTP., +* {api-spring-framework}/http/codec/HttpMessageReader.html[`HttpMessageReader`] and, +to encode and decode HTTP message content., +* An `Encoder` can be wrapped with `EncoderHttpMessageWriter` to adapt it for use in a web, +application, while a `Decoder` can be wrapped with `DecoderHttpMessageReader`., +* {api-spring-framework}/core/io/buffer/DataBuffer.html[`DataBuffer`] abstracts different, +byte buffer representations (e.g. Netty `ByteBuf`, `java.nio.ByteBuffer`, etc.) and is, +what all codecs work on. See <<core#databuffers, Data Buffers and Codecs>> in the, +"Spring Core" section for more on this topic., +The `spring-core` module provides `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource`, and, +`String` encoder and decoder implementations. The `spring-web` module provides Jackson, +JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with, +web-only HTTP message reader and writer implementations for form data, multipart content,, +server-sent events, and others., +`ClientCodecConfigurer` and `ServerCodecConfigurer` are typically used to configure and, +customize the codecs to use in an application. See the section on configuring, +<<webflux-config-message-codecs>>., +JSON and binary JSON (https://github.com/FasterXML/smile-format-specification[Smile]) are, +both supported when the Jackson library is present., +The `Jackson2Decoder` works as follows:, +, +* Jackson's asynchronous, non-blocking parser is used to aggregate a stream of byte chunks, +into ``TokenBuffer``'s each representing a JSON object., +* Each `TokenBuffer` is passed to Jackson's `ObjectMapper` to create a higher level object., +* When decoding to a single-value publisher (e.g. `Mono`), there is one `TokenBuffer`., +* When decoding to a multi-value publisher (e.g. `Flux`), each `TokenBuffer` is passed to, +the `ObjectMapper` as soon as enough bytes are received for a fully formed object. The, +input content can be a JSON array, or, +* For a single value publisher (e.g. `Mono`), simply serialize it through the, +`ObjectMapper`., +* For a multi-value publisher with "application/json", by default collect the values with, +* For SSE the `Jackson2Encoder` is invoked per event and the output is flushed to ensure, +delivery without delay., +[NOTE], +====, +By default both `Jackson2Encoder` and `Jackson2Decoder` do not support elements of type, +`String`. Instead the default assumption is that a string or a sequence of strings, +represent serialized JSON content, to be rendered by the `CharSequenceEncoder`. If what, +you need is to render a JSON array from `Flux<String>`, use `Flux#collectToList()` and, +encode a `Mono<List<String>>`., +====, +==== Sensitive Data, +<1> Using `@Valid` on a model attribute argument.]