[+++ b/spring-test/src/main/java/org/springframework/test/context/junit4/rules/SpringClassRule.java, +import java.util.Arrays;, +import java.util.Optional;, + *    public static final SpringClassRule springClassRule = new SpringClassRule();, +	 * Wrap the supplied {@link Statement} with a {@code RunBeforeTestClassCallbacks} statement., +	private Statement withBeforeTestClassCallbacks(Statement next, TestContextManager testContextManager) {, +		return new RunBeforeTestClassCallbacks(next, testContextManager);, +	 * Wrap the supplied {@link Statement} with a {@code RunAfterTestClassCallbacks} statement., +	private Statement withAfterTestClassCallbacks(Statement next, TestContextManager testContextManager) {, +		return new RunAfterTestClassCallbacks(next, testContextManager);, +	 * Wrap the supplied {@link Statement} with a {@code ProfileValueChecker} statement., +	private Statement withProfileValueCheck(Statement next, Class<?> testClass) {, +		return new ProfileValueChecker(next, testClass, null);, +	 * Wrap the supplied {@link Statement} with a {@code TestContextManagerCacheEvictor} statement., +	private Statement withTestContextManagerCacheEviction(Statement next, Class<?> testClass) {, +		return new TestContextManagerCacheEvictor(next, testClass);, +		Field ruleField = findSpringMethodRuleField(testClass).orElseThrow(() ->, +				new IllegalStateException(String.format(, +					"Consult the javadoc for SpringClassRule for details.", testClass.getName())));, +	private static Optional<Field> findSpringMethodRuleField(Class<?> testClass) {, +		return Arrays.stream(testClass.getFields()), +				.filter(field -> !Modifier.isStatic(field.getModifiers())), +				.filter(field -> Modifier.isPublic(field.getModifiers())), +				.filter(field -> SpringMethodRule.class.isAssignableFrom(field.getType())), +				.findFirst();, +++ b/spring-test/src/main/java/org/springframework/test/context/junit4/rules/SpringClassRule.java, +import java.util.Arrays;, +import java.util.Optional;, + *    public static final SpringClassRule springClassRule = new SpringClassRule();, +	 * Wrap the supplied {@link Statement} with a {@code RunBeforeTestClassCallbacks} statement., +	private Statement withBeforeTestClassCallbacks(Statement next, TestContextManager testContextManager) {, +		return new RunBeforeTestClassCallbacks(next, testContextManager);, +	 * Wrap the supplied {@link Statement} with a {@code RunAfterTestClassCallbacks} statement., +	private Statement withAfterTestClassCallbacks(Statement next, TestContextManager testContextManager) {, +		return new RunAfterTestClassCallbacks(next, testContextManager);, +	 * Wrap the supplied {@link Statement} with a {@code ProfileValueChecker} statement., +	private Statement withProfileValueCheck(Statement next, Class<?> testClass) {, +		return new ProfileValueChecker(next, testClass, null);, +	 * Wrap the supplied {@link Statement} with a {@code TestContextManagerCacheEvictor} statement., +	private Statement withTestContextManagerCacheEviction(Statement next, Class<?> testClass) {, +		return new TestContextManagerCacheEvictor(next, testClass);, +		Field ruleField = findSpringMethodRuleField(testClass).orElseThrow(() ->, +				new IllegalStateException(String.format(, +					"Consult the javadoc for SpringClassRule for details.", testClass.getName())));, +	private static Optional<Field> findSpringMethodRuleField(Class<?> testClass) {, +		return Arrays.stream(testClass.getFields()), +				.filter(field -> !Modifier.isStatic(field.getModifiers())), +				.filter(field -> Modifier.isPublic(field.getModifiers())), +				.filter(field -> SpringMethodRule.class.isAssignableFrom(field.getType())), +				.findFirst();, +++ b/spring-test/src/main/java/org/springframework/test/context/junit4/rules/SpringMethodRule.java, +import java.lang.reflect.Method;, +import java.util.Arrays;, +import java.util.Optional;, +		Method testMethod = frameworkMethod.getMethod();, +			logger.debug("Applying SpringMethodRule to test method [" + testMethod + "]");, +		statement = withBeforeTestMethodCallbacks(statement, testMethod, testInstance, testContextManager);, +		statement = withAfterTestMethodCallbacks(statement, testMethod, testInstance, testContextManager);, +		statement = withPotentialRepeat(statement, testMethod, testInstance);, +		statement = withPotentialTimeout(statement, testMethod, testInstance);, +		statement = withProfileValueCheck(statement, testMethod, testInstance);, +	private Statement withBeforeTestMethodCallbacks(Statement next, Method testMethod,, +				next, testInstance, testMethod, testContextManager);, +	private Statement withAfterTestMethodCallbacks(Statement next, Method testMethod,, +				next, testInstance, testMethod, testContextManager);, +	private Statement withTestInstancePreparation(Statement next, Object testInstance,, +		return new RunPrepareTestInstanceCallbacks(next, testInstance, testContextManager);, +	private Statement withPotentialRepeat(Statement next, Method testMethod, Object testInstance) {, +		return new SpringRepeat(next, testMethod);, +	private Statement withPotentialTimeout(Statement next, Method testMethod, Object testInstance) {, +		return new SpringFailOnTimeout(next, testMethod);, +	private Statement withProfileValueCheck(Statement next, Method testMethod, Object testInstance) {, +		return new ProfileValueChecker(next, testInstance.getClass(), testMethod);, +		Field ruleField = findSpringClassRuleField(testClass).orElseThrow(() -> , +				new IllegalStateException(String.format(, +					"Consult the javadoc for SpringClassRule for details.", testClass.getName())));, +	private static Optional<Field> findSpringClassRuleField(Class<?> testClass) {, +		return Arrays.stream(testClass.getFields()), +				.filter(ReflectionUtils::isPublicStaticFinal), +				.filter(field -> SpringClassRule.class.isAssignableFrom(field.getType())), +				.findFirst();]