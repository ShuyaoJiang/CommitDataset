[+++ b/org.springframework.web/src/main/java/org/springframework/web/util/UriUtils.java, +import java.util.EnumMap;, +import java.util.Map;, + * Utility class for URI encoding and decoding based on RFC 3986. Offers encoding methods for the various URI, + * components., + * <p>All {@code encode*(String, String} methods in this class operate in a similar way: <ul> <li>Valid characters for, + * the specific URI component as defined in RFC 3986 stay the same. <li>All other characters are converted into one or, + * more bytes in the given encoding scheme. Each of the resulting bytes is written as a hexadecimal string in the, + * "<code>%<i>xy</i></code>" format. </ul>, + * @since 3.0, +			"^" + HTTP_PATTERN + "(//(" + USERINFO_PATTERN + "@)?" + HOST_PATTERN + "(:" + PORT_PATTERN + ")?" + ")?" +, +					PATH_PATTERN + "(\\?" + LAST_PATTERN + ")?");, +	// Parsing, +, +	 * Parses the given source URI into a mapping of URI components to string values., +	 *, +	 * <p>The returned map will contain keys for, +	 * <ul>, +	 *     <li>{@link UriComponent#SCHEME}</li>, +	 *     <li>{@link UriComponent#AUTHORITY}</li>, +	 *     <li>{@link UriComponent#USER_INFO}</li>, +	 *     <li>{@link UriComponent#HOST}</li>, +	 *     <li>{@link UriComponent#PORT}</li>, +	 *     <li>{@link UriComponent#PATH}</li>, +	 *     <li>{@link UriComponent#QUERY}</li>, +	 *     <li>{@link UriComponent#FRAGMENT}</li>, +	 * </ul>, +	 * though the values assigned to these keys is {@code null} if they do not occur in the given source URI., +	 *, +	 * <p><strong>Note</strong> that the returned map will never contain mappings for {@link UriComponent#PATH_SEGMENT},, +	 * nor {@link UriComponent#QUERY_PARAM}, since those components can occur multiple times in the URI., +	 *, +	 * @param uri the source URI, +	 * @return the URI components of the URI, +	public static Map<UriComponent, String> parseUriComponents(String uri) {, +			Map<UriComponent, String> result = new EnumMap<UriComponent, String>(UriComponent.class);, +			result.put(UriComponent.SCHEME, m.group(2));, +			result.put(UriComponent.AUTHORITY, m.group(3));, +			result.put(UriComponent.USER_INFO, m.group(5));, +			result.put(UriComponent.HOST, m.group(6));, +			result.put(UriComponent.PORT, m.group(8));, +			result.put(UriComponent.PATH, m.group(9));, +			result.put(UriComponent.QUERY, m.group(11));, +			result.put(UriComponent.FRAGMENT, m.group(13));, +, +			return result;, +	 * Parses the given source HTTP URL into a mapping of URI components to string values., +	 *, +	 *, +	 * <p>The returned map will contain keys for, +	 * <ul>, +	 *     <li>{@link UriComponent#SCHEME}</li>, +	 *     <li>{@link UriComponent#AUTHORITY}</li>, +	 *     <li>{@link UriComponent#USER_INFO}</li>, +	 *     <li>{@link UriComponent#HOST}</li>, +	 *     <li>{@link UriComponent#PORT}</li>, +	 *     <li>{@link UriComponent#PATH}</li>, +	 *     <li>{@link UriComponent#QUERY}</li>, +	 *     <li>{@link UriComponent#FRAGMENT}</li>, +	 * </ul>, +	 * though the values assigned to these keys is {@code null} if they do not occur in the given source URI., +	 *, +	 * <p><strong>Note</strong> that the returned map will never contain mappings for {@link UriComponent#PATH_SEGMENT},, +	 * nor {@link UriComponent#QUERY_PARAM}, since those components can occur multiple times in the URI., +	 *, +	 * <p><strong>Note</strong> that this method does not support fragments ({@code #}), as these are not supposed to be, +	 * sent to the server, but retained by the client., +	 *, +	 * @param httpUrl the source URI, +	 * @return the URI components of the URI, +	public static Map<UriComponent, String> parseHttpUrlComponents(String httpUrl) {, +			Map<UriComponent, String> result = new EnumMap<UriComponent, String>(UriComponent.class);, +			result.put(UriComponent.SCHEME, m.group(1));, +			result.put(UriComponent.AUTHORITY, m.group(2));, +			result.put(UriComponent.USER_INFO, m.group(4));, +			result.put(UriComponent.HOST, m.group(5));, +			result.put(UriComponent.PORT, m.group(7));, +			result.put(UriComponent.PATH, m.group(8));, +			result.put(UriComponent.QUERY, m.group(10));, +, +			return result;, +	// building, +, +	 * Builds a URI from the given URI components. The given map should contain at least one entry., +	 *, +	 * <p><strong>Note</strong> that {@link UriComponent#PATH_SEGMENT} and {@link UriComponent#QUERY_PARAM} keys (if any), +	 * will not be used to build the URI, in favor of {@link UriComponent#PATH} and {@link UriComponent#QUERY}, +	 * respectively., +	 *, +	 * @param uriComponents the components to build the URI out of, +	 * @return the URI created from the given components, +	 */, +	public static String buildUri(Map<UriComponent, String> uriComponents) {, +		Assert.notEmpty(uriComponents, "'uriComponents' must not be empty");, +, +		return buildUri(uriComponents.get(UriComponent.SCHEME), uriComponents.get(UriComponent.AUTHORITY),, +				uriComponents.get(UriComponent.USER_INFO), uriComponents.get(UriComponent.HOST),, +				uriComponents.get(UriComponent.PORT), uriComponents.get(UriComponent.PATH),, +				uriComponents.get(UriComponent.QUERY), uriComponents.get(UriComponent.FRAGMENT));, +	}]