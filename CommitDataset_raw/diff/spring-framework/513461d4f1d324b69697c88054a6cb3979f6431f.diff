[+++ b/src/docs/asciidoc/web/websocket.adoc, +content is undefined. The defines a mechanism for client and server to negotiate a, +sub-protocol -- i.e. a higher level messaging protocol, to use on top of WebSocket to, +define what kind of messages each can send, what is the format and content for each, +message, and so on. The use of a sub-protocol is optional but either way client and, +server will need to agree on some protocol that defines message content., +http://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] is a simple,, +designed to address a minimal subset of commonly used messaging patterns. STOMP can be, +used over any reliable, 2-way streaming network protocol such as TCP and WebSocket., +Although STOMP is a text-oriented protocol, message payloads can be, +[[websocket-stomp-benefits]], +=== Benefits, +, +Use of STOMP as a sub-protocol enables the Spring Framework and Spring Security to, +provide a richer programming model vs using raw WebSockets. The same point can be, +made about how HTTP vs raw TCP and how it enables Spring MVC and other web frameworks, +to provide rich functionality. The following is a list of benefits:, +, +* No need to invent a custom messaging protocol and message format., +* STOMP clients are available including a <<websocket-stomp-client,Java client>>, +in the Spring Framework., +* Message brokers such as RabbitMQ, ActiveMQ, and others can be used (optionally) to, +manage subscriptions and broadcast messages., +* Application logic can be organized in any number of ``@Controller``'s and messages, +routed to them based on the STOMP destination header vs handling raw WebSocket messages, +with a single `WebSocketHandler` for a given connection., +* Use Spring Security to secure messages based on STOMP destinations and message types., +STOMP over WebSocket support is available in the `spring-messaging` and the, +`spring-websocket` modules. Once you have those dependencies, you can expose a STOMP, +endpoints, over WebSocket with <<websocket-fallback>>, as shown below:, +			registry.addEndpoint("/portfolio").withSockJS();  // <1>, +			config.setApplicationDestinationPrefixes("/app"); // <2>, +			config.enableSimpleBroker("/topic", "/queue"); // <3>, +<1> `"/portfolio"` is the HTTP URL for the endpoint to which a WebSocket (or SockJS), +client will need to connect to for the WebSocket handshake., +<2> STOMP messages whose destination header begins with `"/app"` are routed to, +`@MessageMapping` methods in `@Controller` classes., +<3> Use the built-in, message broker for subscriptions and broadcasting;, +Route messages whose destination header begins with "/topic" or "/queue" to the broker., +, +The same configuration in XML:, +For the built-in, simple broker the "/topic" and "/queue" prefixes do not have any special, +meaning. They're merely a convention to differentiate between pub-sub vs point-to-point, +messaging (i.e. many subscribers vs one consumer). When using an external broker, please, +check the STOMP page of the broker to understand what kind of STOMP destinations and, +prefixes it supports., +Once a STOMP endpoint is exposed, the Spring application becomes a STOMP broker for, +connected clients. This section describes the flow of messages on the server side., +The `spring-messaging` module contains foundational support for messaging applications, +that originated in https://spring.io/spring-integration[Spring Integration] and was, +later extracted and incorporated into the Spring Framework for broader use across many, +https://spring.io/projects[Spring projects] and application scenarios., +Below is a list of a few of the available messaging abstractions:, +simple representation for a message including headers and payload., +contract for handling a message., +contract for sending a message that enables loose coupling between producers and consumers., +`MessageChannel` with `MessageHandler` subscribers., +`SubscribableChannel` that uses an `Executor` for delivering messages., +Both the Java config (i.e. `@EnableWebSocketMessageBroker`) and the XML namespace config, +(i.e. `<websocket:message-broker>`) use the above components to assemble a message, +workflow. The diagram below shows the components used when the simple, built-in message, +broker is enabled:, +There are 3 message channels in the above diagram:, +* `"clientInboundChannel"` -- for passing messages received from WebSocket clients., +* `"clientOutboundChannel"` -- for sending server messages to WebSocket clients., +* `"brokerChannel"` -- for sending messages to the message broker from within, +server-side, application code., +The next diagram shows the components used when an external broker (e.g. RabbitMQ), +is configured for managing subscriptions and broadcasting messages:, +The main difference in the above diagram is the use of the "broker relay" for passing, +messages up to the external STOMP broker over TCP, and for passing messages down from the, +broker to subscribed clients., +When messages are received from a WebSocket connectin, they're decoded to STOMP frames,, +then turned into a Spring `Message` representation, and sent to the, +`"clientInboundChannel"` for further processing. For example STOMP messages whose, +destination header starts with `"/app"` may be routed to `@MessageMapping` methods in, +annotated controllers, while `"/topic"` and `"/queue"` messages may be routed directly, +to the message broker., +An annotated `@Controller` handling a STOMP message from a client may send a message to, +the message broker through the `"brokerChannel"`, and the broker will broadcast the, +message to matching subscribers through the `"clientOutboundChannel"`. The same, +controller can also do the same in response to HTTP requests, so a client may perform an, +HTTP POST and then an `@PostMapping` method can send a message to the message broker, +to broadcast to subscribed clients., +, +Let's trace the flow through a simple example. Given the following server setup:, +. Client connects to `"http://localhost:8080/portfolio"` and once a WebSocket connection, +is established, STOMP frames begin to flow on it., +. Client sends SUBSCRIBE frame with destination header `"/topic/greeting"`. Once received, +and decoded, the message is sent to the `"clientInboundChannel"`, then routed to the, +message broker which stores the client subscription., +. Client sends SEND frame to `"/app/greeting"`. The `"/app"` prefix helps to route it to, +annotated controllers. After the `"/app"` prefix is stripped, the remaining `"/greeting"`, +part of the destination is mapped to the `@MessageMapping` method in `GreetingController`., +. The value returned from `GreetingController` is turned into a Spring `Message` with, +a payload based on the return value and a default destination header of, +`"/topic/greeting"` (derived from the input destination with `"/app"` replaced by, +`"/topic"`). The resulting message is sent to the "brokerChannel" and handled, +by the message broker., +. The message broker finds all matching subscribers, and sends a MESSAGE frame to each]