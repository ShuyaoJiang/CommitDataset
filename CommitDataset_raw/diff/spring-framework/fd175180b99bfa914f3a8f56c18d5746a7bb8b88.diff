[+++ b/src/asciidoc/index.adoc, +module also contains key abstractions formerly from the, +==== WebSocket Fallback Options, +==== A Messaging Architecture, +==== Sub-Protocol Support in WebSocket, +==== Should I Use WebSocket?, +=== WebSocket API, +==== CORS Headers for SockJS, +=== STOMP Over WebSocket Messaging Architecture, +==== Enable STOMP over WebSocket, +==== Flow of Messages, +When a STOMP endpoint is configured, the Spring application becomes the broker to, +connected clients. It handles incoming messages and broadcasts messages back., +This section provides the big picture of how messages are handled and how, +they flow inside the application., +The `spring-messaging` module contains a number of abstractions for use in, +messaging applications which originated in the, +https://spring.io/spring-integration[Spring Integration] project and, +have been in use for a long time but are now part of the Spring Framework., +Listed below are some of the main building blocks:, +* {javadoc-baseurl}/org/springframework/messaging/Message.html[Message], +represents a message with headers and a payload., +* {javadoc-baseurl}/org/springframework/messaging/MessageHandler.html[MessageHandler], +a simple contract components that handle a message., +* {javadoc-baseurl}/org/springframework/messaging/MessageChannel.html[MessageChannel], +a simple contract for sending a message that enables loose coupling between, +senders and receivers., +* {javadoc-baseurl}/org/springframework/messaging/SubscribableChannel.html[SubscribableChannel], +extends `MessageChannel` and sends messages to registered `MessageHandler` subscribers., +* {javadoc-baseurl}/org/springframework/messaging/support/ExecutorSubscribableChannel.html[ExecutorSubscribableChannel], +a concrete implementation of `SubscribableChannel` that can deliver messages, +asynchronously using threads from a thread pool., +The above building blocks can be used to construct a message flow., +The provided configuration for STOMP over WebSocket, both Java config and XML namespace,, +assemble just such a concrete message flow that consists of the following 3, +subscribable channels:, +* `"clientInboundChannel"` for messages from WebSocket clients; every incoming, +WebSocket message that is decoded and turned into a Spring Message representing, +a STOMP frame is passed through this channel., +* `"clientOutboundChannel"` for messages to WebSocket clients; every outgoing, +Spring Message representing a STOMP frame that is encoded and sent as a, +WebSocket message is passed through this channel., +* `"brokerChannel"` for messages to the broker from within the application and, +ultimately intended to reach connected clients; every message that the application, +wants to send to clients passes through this channel., +Messages through `"clientInboundChannel"` can flow to annotated, +methods for application handling (e.g. a stock trade execution request) or can, +be forwarded to the broker (e.g. client subscribing for stock quotes)., +The STOMP destination is used for simple prefix-based routing. For example, +the "/app" prefix routes messages annotated methods while the "/topic" or, +"/queue" prefix route messages to the broker., +, +When a message-handling annotated method has a return type, its return, +value is sent as the payload of a Spring Message to the `"brokerChannel"`., +The broker in turn broadcasts the message to clients. Sending an object as, +the payload of a Message to a specific destination can also easily be done, +from anywhere in the application with the help of a messaging template., +For example a an HTTP POST handling method can broadcast a message to, +connected clients or a service component may periodically broadcast, +stock quotes., +, +Below is a simple example to illustrate the flow of messages:, +			registry.addEndpoint("/portfolio");, +			registry.enableSimpleBroker("/topic/");, +		@MessageMapping("/greeting") {, +The following explains how messages flow given the above:, +, +* WebSocket clients connect to the WebSocket endpoint at "/portfolio"., +* Subscriptions to "/topic/greeting" pass through the "clientInboundChannel", +and are forwarded to the broker., +* Greetings sent to "/app/greeting" pass through the "clientInboundChannel", +and are forwarded to the `GreetingController`. The controller adds the current, +time and the return value is passed through the "brokerChannel" as message, +to "/topic/greeting" (destination is selected based on a convention but can be, +overridden via `@SendTo`)., +* The broker in turn broadcasts messages to subscribers and they pass through, +the `"clientOutboundChannel"`., +, +The next section provides more details on annotated methods including the, +kinds of arguments and return values supported., +, +==== Annotation Message Handling, +==== Sending Messages, +==== Simple Broker, +==== Full-Featured Broker, +==== Connections To Full-Featured Broker, +==== Authentication and User Destinations, +, +, +==== Testing Annotated Controller Methods]