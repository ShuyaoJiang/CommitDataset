[+++ /dev/null, +++ /dev/null, +++ b/spring-messaging/src/test/java/org/springframework/messaging/handler/invocation/MethodMessageHandlerTests.java, +/*, + * Copyright 2002-2014 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.messaging.handler.invocation;, +, +import org.hamcrest.Matchers;, +import org.junit.Before;, +import org.junit.Test;, +, +import org.springframework.context.support.StaticApplicationContext;, +import org.springframework.messaging.Message;, +import org.springframework.messaging.handler.DestinationPatternsMessageCondition;, +import org.springframework.messaging.handler.HandlerMethod;, +import org.springframework.messaging.handler.HandlerMethodSelector;, +import org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolver;, +import org.springframework.messaging.support.MessageBuilder;, +import org.springframework.util.AntPathMatcher;, +import org.springframework.util.PathMatcher;, +import org.springframework.util.ReflectionUtils.MethodFilter;, +, +import java.lang.reflect.Method;, +import java.util.*;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertThat;, +, +/**, + * Test fixture for, + * {@link org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler}., + *, + * @author Brian Clozel, + * @author Rossen Stoyanchev, + */, +public class MethodMessageHandlerTests {, +, +	private static final String DESTINATION_HEADER = "destination";, +, +	private TestMethodMessageHandler messageHandler;, +, +	private TestController testController;, +, +, +	@Before, +	public void setup() {, +, +		List<String> destinationPrefixes = Arrays.asList("/test");, +, +		this.messageHandler = new TestMethodMessageHandler();, +		this.messageHandler.setApplicationContext(new StaticApplicationContext());, +		this.messageHandler.setDestinationPrefixes(destinationPrefixes);, +		this.messageHandler.afterPropertiesSet();, +, +		this.testController = new TestController();, +		this.messageHandler.registerHandler(this.testController);, +	}, +, +	@Test(expected=IllegalStateException.class), +	public void duplicateMapping() {, +		this.messageHandler.registerHandler(new DuplicateMappingsController());, +	}, +, +	@Test, +	public void registeredMappings() {, +, +		Map<String, HandlerMethod> handlerMethods = this.messageHandler.getHandlerMethods();, +, +		assertNotNull(handlerMethods);, +		assertThat(handlerMethods.keySet(), Matchers.hasSize(3));, +	}, +, +	@Test, +	public void antPatchMatchWildcard() throws Exception {, +, +		Method method = this.testController.getClass().getMethod("handlerPathMatchWildcard");, +		this.messageHandler.registerHandlerMethod(this.testController, method, "/handlerPathMatch*");, +, +		this.messageHandler.handleMessage(toDestination("/test/handlerPathMatchFoo"));, +, +		assertEquals("pathMatchWildcard", this.testController.method);, +	}, +, +	@Test, +	public void bestMatchWildcard() throws Exception {]