[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +/*, + * Copyright 2002-2013 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.core;, +, +import java.lang.reflect.Array;, +import java.lang.reflect.Constructor;, +import java.lang.reflect.Field;, +import java.lang.reflect.GenericArrayType;, +import java.lang.reflect.Method;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.lang.reflect.TypeVariable;, +import java.lang.reflect.WildcardType;, +import java.util.Collection;, +import java.util.Map;, +, +import org.springframework.util.Assert;, +import org.springframework.util.ConcurrentReferenceHashMap;, +import org.springframework.util.ObjectUtils;, +import org.springframework.util.StringUtils;, +, +/**, + * Encapsulates a Java {@link java.lang.reflect.Type}, providing access to, + * {@link #getSuperType() supertypes} , {@link #getInterfaces() interfaces} and, + * {@link #getGeneric(int...) generic parameters} along with the ability to ultimately, + * {@link #resolve() resolve} to a {@link java.lang.Class}., + *, + * <p>{@code ResolvableTypes} may be obtained from {@link #forField(Field) fields},, + * {@link #forMethodParameter(Method, int) method parameters},, + * {@link #forMethodReturn(Method) method returns}, {@link #forClass(Class) classes} or, + * directly from a {@link #forType(Type) java.lang.reflect.Type}. Most methods on this class, + * will themselves return {@link ResolvableType}s, allowing easy navigation. For example:, + * <pre class="code">, + * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;, + *, + * public void example() {, + *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField("myMap"));, + *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;, + *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;, + *     t.getGeneric(0).resolve(); // Integer, + *     t.getGeneric(1).resolve(); // List, + *     t.getGeneric(1); // List&lt;String&gt;, + *     t.resolveGeneric(1, 0); // String, + * }, + * </pre>, + *, + * @author Phillip Webb, + * @since 4.0, + * @see TypeVariableResolver, + * @see #forField(Field), + * @see #forMethodParameter(Method, int), + * @see #forMethodReturn(Method), + * @see #forConstructorParameter(Constructor, int), + * @see #forClass(Class), + * @see #forType(Type), + */, +public final class ResolvableType implements TypeVariableResolver {, +, +	private static ConcurrentReferenceHashMap<ResolvableType, ResolvableType> cache =, +			new ConcurrentReferenceHashMap<ResolvableType, ResolvableType>();, +, +, +	/**, +	 * {@code ResolvableType} returned when no value is available. {@code NONE} is used, +	 * in preference to {@code null} so that multiple method calls can be safely chained., +	 */, +	public static final ResolvableType NONE = new ResolvableType(null, null);, +, +, +	private static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0];, +, +, +	/**, +	 * The underlying java type being managed (only ever {@code null} for {@link #NONE}), +	 */, +	private final Type type;, +, +	/**, +	 * The {@link TypeVariableResolver} to use or {@code null} if no resolver is availble., +	 */, +	private final TypeVariableResolver variableResolver;, +, +	/**, +	 * Stored copy of the resolved value or {@code null} if the resolve method has not, +	 * yet been called. {@code void.class} is used when the resolve method failed.]