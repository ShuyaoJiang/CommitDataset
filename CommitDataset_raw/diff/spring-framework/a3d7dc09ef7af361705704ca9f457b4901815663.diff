[+++ b/spring-jms/src/main/java/org/springframework/jms/connection/CachedMessageProducer.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.InvocationHandler;, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +import java.lang.reflect.Proxy;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ReflectionUtils;, +, +	private static final Method setDeliveryDelayMethod =, +			ClassUtils.getMethodIfAvailable(MessageProducer.class, "setDeliveryDelay", long.class);, +, +	private static final Method getDeliveryDelayMethod =, +			ClassUtils.getMethodIfAvailable(MessageProducer.class, "getDeliveryDelay");, +, +	private static Class completionListenerClass;, +, +	private static Method sendWithCompletionListenerMethod;, +, +	private static Method sendWithDestinationAndCompletionListenerMethod;, +, +	static {, +		try {, +			completionListenerClass = ClassUtils.forName(, +					"javax.jms.CompletionListener", CachedMessageProducer.class.getClassLoader());, +			sendWithCompletionListenerMethod = MessageProducer.class.getMethod(, +					"send", Message.class, int.class, int.class, long.class, completionListenerClass);, +			sendWithDestinationAndCompletionListenerMethod = MessageProducer.class.getMethod(, +					"send", Destination.class, Message.class, int.class, int.class, long.class, completionListenerClass);, +		}, +		catch (Exception ex) {, +			// No JMS 2.0 API available, +			completionListenerClass = null;, +		}, +	}, +, +, +	private Long originalDeliveryDelay;, +, +			this.originalDisableMessageID = this.target.getDisableMessageID();, +			this.originalDisableMessageTimestamp = this.target.getDisableMessageTimestamp();, +	public void setDeliveryDelay(long deliveryDelay) {, +		if (this.originalDeliveryDelay == null) {, +			this.originalDeliveryDelay = (Long) ReflectionUtils.invokeMethod(getDeliveryDelayMethod, this.target);, +		}, +		ReflectionUtils.invokeMethod(setDeliveryDelayMethod, this.target, deliveryDelay);, +	}, +, +	public long getDeliveryDelay() {, +		return (Long) ReflectionUtils.invokeMethod(getDeliveryDelayMethod, this.target);, +	}, +, +			this.target.setDisableMessageID(this.originalDisableMessageID);, +			this.target.setDisableMessageTimestamp(this.originalDisableMessageTimestamp);, +		if (this.originalDeliveryDelay != null) {, +			ReflectionUtils.invokeMethod(setDeliveryDelayMethod, this.target, this.originalDeliveryDelay);, +			this.originalDeliveryDelay = null;, +	}, +, +	/**, +	 * Build a dynamic proxy that reflectively adapts to JMS 2.0 API methods, if necessary., +	 * Otherwise simply return this CachedMessageProducer instance itself., +	 */, +	public MessageProducer getProxyIfNecessary() {, +		if (completionListenerClass != null) {, +			return (MessageProducer) Proxy.newProxyInstance(CachedMessageProducer.class.getClassLoader(),, +					new Class[] {MessageProducer.class, QueueSender.class, TopicPublisher.class},, +					new Jms2MessageProducerInvocationHandler());, +		}, +		else {, +			return this;, +		}, +	}, +, +, +	/**, +	 * Reflective InvocationHandler which adapts to JMS 2.0 API methods that we, +	 * cannot statically compile against while preserving JMS 1.1 compatibility, +	 * (due to the new {@code javax.jms.CompletionListener} type in the signatures)., +	 */, +	private class Jms2MessageProducerInvocationHandler implements InvocationHandler {, +, +		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {, +			try {, +				if (method.getName().equals("send") && args != null &&, +						completionListenerClass.equals(method.getParameterTypes()[args.length - 1])) {, +					if (args.length == 2) {, +						return sendWithCompletionListenerMethod.invoke(, +								target, args[0], deliveryMode, priority, timeToLive, args[1]);, +					}, +					else if (args.length == 3) {, +						return sendWithDestinationAndCompletionListenerMethod.invoke(, +								target, args[0], args[1], deliveryMode, priority, timeToLive, args[2]);, +					}, +				}, +				return method.invoke(target, args);, +			}, +			catch (InvocationTargetException ex) {, +				throw ex.getTargetException();, +			}]