[+++ b/spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +	private final List<ResolvableType> declaredEventTypes;, +	private EventListener eventListener;, +, +		this.declaredEventTypes = resolveDeclaredEventTypes();, +		ResolvableType declaredEventType = getResolvableType(event);, +		if (declaredEventType == null) {, +			return null;, +		if (this.method.getParameters().length == 0) {, +			return new Object[0];, +		}, +		if (!ApplicationEvent.class.isAssignableFrom(declaredEventType.getRawClass()), +				&& event instanceof PayloadApplicationEvent) {, +			return new Object[] {((PayloadApplicationEvent) event).getPayload()};, +		for (ResolvableType declaredEventType : this.declaredEventTypes) {, +			if (declaredEventType.isAssignableFrom(eventType)) {, +				if (declaredEventType.isAssignableFrom(payloadType)) {, +					return true;, +			}, +		}, +		return eventType.hasUnresolvableGenerics();, +	protected EventListener getEventListener() {, +		if (this.eventListener == null) {, +			this.eventListener = AnnotatedElementUtils.findMergedAnnotation(this.method, EventListener.class);, +		}, +		return this.eventListener;, +	}, +, +	private ResolvableType getResolvableType(ApplicationEvent event) {, +		ResolvableType payloadType = null;, +		if (event instanceof PayloadApplicationEvent) {, +			PayloadApplicationEvent<?> payloadEvent = (PayloadApplicationEvent<?>) event;, +			payloadType = payloadEvent.getResolvableType().as(, +					PayloadApplicationEvent.class).getGeneric(0);, +		}, +		for (ResolvableType declaredEventType : this.declaredEventTypes) {, +			if (!ApplicationEvent.class.isAssignableFrom(declaredEventType.getRawClass()), +					&& payloadType != null) {, +				if (declaredEventType.isAssignableFrom(payloadType)) {, +					return declaredEventType;, +				}, +			}, +			if (declaredEventType.getRawClass().isAssignableFrom(event.getClass())) {, +				return declaredEventType;, +			}, +		}, +		return null;, +	}, +, +	private List<ResolvableType> resolveDeclaredEventTypes() {, +		if (count > 1) {, +			throw new IllegalStateException("Maximum one parameter is allowed " +, +		EventListener ann = getEventListener();, +		if (ann != null && ann.classes().length > 0) {, +			List<ResolvableType> types = new ArrayList<ResolvableType>();, +			for (Class<?> eventType : ann.classes()) {, +				types.add(ResolvableType.forClass(eventType));, +			}, +			return types;, +		}, +		else {, +			if (count == 0) {, +				throw new IllegalStateException("Event parameter is mandatory " +, +						"for event listener method: " + method);, +			}, +			return Collections.singletonList(ResolvableType.forMethodParameter(this.method, 0));, +		}, +++ b/spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +	private final List<ResolvableType> declaredEventTypes;, +	private EventListener eventListener;, +, +		this.declaredEventTypes = resolveDeclaredEventTypes();, +		ResolvableType declaredEventType = getResolvableType(event);, +		if (declaredEventType == null) {, +			return null;, +		if (this.method.getParameters().length == 0) {, +			return new Object[0];, +		}, +		if (!ApplicationEvent.class.isAssignableFrom(declaredEventType.getRawClass()), +				&& event instanceof PayloadApplicationEvent) {, +			return new Object[] {((PayloadApplicationEvent) event).getPayload()};, +		for (ResolvableType declaredEventType : this.declaredEventTypes) {, +			if (declaredEventType.isAssignableFrom(eventType)) {, +				if (declaredEventType.isAssignableFrom(payloadType)) {, +					return true;, +			}, +		}, +		return eventType.hasUnresolvableGenerics();, +	protected EventListener getEventListener() {, +		if (this.eventListener == null) {, +			this.eventListener = AnnotatedElementUtils.findMergedAnnotation(this.method, EventListener.class);, +		}, +		return this.eventListener;, +	}]