[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., + * {@code HandlerMethodArgumentResolver} for {@link Message} method arguments., + * Validates that the generic type of the payload matches to the message value., +			String actual = ClassUtils.getQualifiedName(message.getClass());, +			String expected = ClassUtils.getQualifiedName(paramType);, +			throw new MethodArgumentTypeMismatchException(message, parameter, "The actual message type " +, +					"[" + actual + "] does not match the expected type [" + expected + "]");, +		Class<?> targetPayloadType = getPayloadType(parameter);, +		if (payload != null && !targetPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(targetPayloadType) +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., + * {@code HandlerMethodArgumentResolver} for {@link Message} method arguments., + * Validates that the generic type of the payload matches to the message value., +			String actual = ClassUtils.getQualifiedName(message.getClass());, +			String expected = ClassUtils.getQualifiedName(paramType);, +			throw new MethodArgumentTypeMismatchException(message, parameter, "The actual message type " +, +					"[" + actual + "] does not match the expected type [" + expected + "]");, +		Class<?> targetPayloadType = getPayloadType(parameter);, +		if (payload != null && !targetPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(targetPayloadType) +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/PayloadArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., +			if (this.converter instanceof SmartMessageConverter) {, +				SmartMessageConverter smartConverter = (SmartMessageConverter) this.converter;, +				payload = smartConverter.fromMessage(message, targetClass, parameter);, +			}, +			else {, +				payload = this.converter.fromMessage(message, targetClass);, +			}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., + * {@code HandlerMethodArgumentResolver} for {@link Message} method arguments., + * Validates that the generic type of the payload matches to the message value., +			String actual = ClassUtils.getQualifiedName(message.getClass());, +			String expected = ClassUtils.getQualifiedName(paramType);, +			throw new MethodArgumentTypeMismatchException(message, parameter, "The actual message type " +, +					"[" + actual + "] does not match the expected type [" + expected + "]");, +		Class<?> targetPayloadType = getPayloadType(parameter);, +		if (payload != null && !targetPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(targetPayloadType) +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/PayloadArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., +			if (this.converter instanceof SmartMessageConverter) {, +				SmartMessageConverter smartConverter = (SmartMessageConverter) this.converter;, +				payload = smartConverter.fromMessage(message, targetClass, parameter);, +			}, +			else {, +				payload = this.converter.fromMessage(message, targetClass);, +			}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/AbstractMethodMessageHandler.java, +, +	protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {, +		logger.debug("No matching methods.");, +	}, +, +	protected abstract AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(, +			Class<?> beanType);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., + * {@code HandlerMethodArgumentResolver} for {@link Message} method arguments., + * Validates that the generic type of the payload matches to the message value., +			String actual = ClassUtils.getQualifiedName(message.getClass());, +			String expected = ClassUtils.getQualifiedName(paramType);, +			throw new MethodArgumentTypeMismatchException(message, parameter, "The actual message type " +, +					"[" + actual + "] does not match the expected type [" + expected + "]");, +		Class<?> targetPayloadType = getPayloadType(parameter);, +		if (payload != null && !targetPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(targetPayloadType) +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/PayloadArgumentResolver.java, + * Copyright 2002-2016 the original author or authors., +			if (this.converter instanceof SmartMessageConverter) {, +				SmartMessageConverter smartConverter = (SmartMessageConverter) this.converter;, +				payload = smartConverter.fromMessage(message, targetClass, parameter);, +			}, +			else {, +				payload = this.converter.fromMessage(message, targetClass);, +			}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/AbstractMethodMessageHandler.java, +, +	protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {, +		logger.debug("No matching methods.");, +	}, +, +	protected abstract AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(, +			Class<?> beanType);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SimpAnnotationMethodMessageHandler.java, + * Copyright 2002-2016 the original author or authors., +		SendToMethodReturnValueHandler sendToHandler =, +		sendToHandler.setHeaderInitializer(this.headerInitializer);, +		handlers.add(sendToHandler);, +		SubscriptionMethodReturnValueHandler subscriptionHandler =, +		subscriptionHandler.setHeaderInitializer(this.headerInitializer);, +		handlers.add(subscriptionHandler);, +		sendToHandler = new SendToMethodReturnValueHandler(this.brokerTemplate, false);, +		sendToHandler.setHeaderInitializer(this.headerInitializer);, +		handlers.add(sendToHandler);]