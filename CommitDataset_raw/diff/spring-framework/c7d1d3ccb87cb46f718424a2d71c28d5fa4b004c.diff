[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, +			Comparator<String> pathComparator = pathMatcher.getPatternComparator(lookupPath);, +					List<String> matchedPaths = new ArrayList<String>(mappingInfo.paths.length);					, +								matchedPaths.add(mappedPath);, +					Collections.sort(matchedPaths, pathComparator);, +					mappingInfo.matchedPaths = matchedPaths.toArray(new String[matchedPaths.size()]);					, +			if (!targetHandlerMethods.isEmpty()) {, +				List<RequestMappingInfo> matches = new ArrayList<RequestMappingInfo>(targetHandlerMethods.keySet());, +				RequestMappingInfoComparator requestMappingInfoComparator = new RequestMappingInfoComparator(pathComparator);, +				Collections.sort(matches, requestMappingInfoComparator);, +				RequestMappingInfo bestMappingMatch = matches.get(0);, +				if (bestMappingMatch.matchedPaths.length > 0) {, +					extractHandlerMethodUriTemplates(bestMappingMatch.matchedPaths[0], lookupPath, request);, +	static class RequestMappingInfo {, +		String[] paths = new String[0];, +		String[] matchedPaths = new String[0];, +		RequestMethod[] methods = new RequestMethod[0];, +, +		String[] params = new String[0];, +, +		String bestMatchedPath() {, +			return matchedPaths.length > 0 ? matchedPaths[0] : null;, +		}, +	/**, +	 * Comparator capable of sorting {@link RequestMappingInfo}s (RHIs) so that sorting a list with this comparator will, +	 * result in:, +	 * <ul>, +	 * <li>RHIs with {@linkplain RequestMappingInfo#matchedPaths better matched paths} take prescedence over those with, +	 * a weaker match (as expressed by the {@linkplain PathMatcher#getPatternComparator(String) path pattern, +	 * comparator}.) Typically, this means that patterns without wild chards and uri templates will be ordered before those without.</li>, +	 * <li>RHIs with one single {@linkplain RequestMappingInfo#methods request method} will be ordered before those, +	 * without a method, or with more than one method.</li>, +	 * <li>RHIs with more {@linkplain RequestMappingInfo#params request parameters} will be ordered before those with, +	 * less parameters</li>, +	 * </ol>, +	 */, +	static class RequestMappingInfoComparator implements Comparator<RequestMappingInfo> {, +, +		private final Comparator<String> pathComparator;, +, +		RequestMappingInfoComparator(Comparator<String> pathComparator) {, +			this.pathComparator = pathComparator;, +		}, +, +		public int compare(RequestMappingInfo info1, RequestMappingInfo info2) {, +			int pathComparison = pathComparator.compare(info1.bestMatchedPath(), info2.bestMatchedPath());, +			if (pathComparison != 0) {, +				return pathComparison;, +			}, +			int info1MethodCount = info1.methods.length;, +			int info2MethodCount = info2.methods.length;, +			if (info1MethodCount == 0 && info2MethodCount > 0) {, +				return 1;, +			}, +			else if (info2MethodCount == 0 && info1MethodCount > 0) {, +				return -1;, +			}, +			else if (info1MethodCount == 1 & info2MethodCount > 1) {, +				return -1;, +, +			}, +			else if (info2MethodCount == 1 & info1MethodCount > 1) {, +				return 1;, +			}, +			int info1ParamCount = info1.params.length;, +			int info2ParamCount = info2.params.length;, +			return (info1ParamCount < info2ParamCount ? 1 : (info1ParamCount == info2ParamCount ? 0 : -1));, +		}, +	}, +	, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, +			Comparator<String> pathComparator = pathMatcher.getPatternComparator(lookupPath);, +					List<String> matchedPaths = new ArrayList<String>(mappingInfo.paths.length);					, +								matchedPaths.add(mappedPath);, +					Collections.sort(matchedPaths, pathComparator);, +					mappingInfo.matchedPaths = matchedPaths.toArray(new String[matchedPaths.size()]);					, +			if (!targetHandlerMethods.isEmpty()) {, +				List<RequestMappingInfo> matches = new ArrayList<RequestMappingInfo>(targetHandlerMethods.keySet());, +				RequestMappingInfoComparator requestMappingInfoComparator = new RequestMappingInfoComparator(pathComparator);, +				Collections.sort(matches, requestMappingInfoComparator);, +				RequestMappingInfo bestMappingMatch = matches.get(0);, +				if (bestMappingMatch.matchedPaths.length > 0) {, +					extractHandlerMethodUriTemplates(bestMappingMatch.matchedPaths[0], lookupPath, request);, +	static class RequestMappingInfo {, +		String[] paths = new String[0];, +		String[] matchedPaths = new String[0];, +		RequestMethod[] methods = new RequestMethod[0];, +, +		String[] params = new String[0];, +, +		String bestMatchedPath() {, +			return matchedPaths.length > 0 ? matchedPaths[0] : null;]