[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, + * Copyright 2002-2016 the original author or authors., + * Wrap a {@link org.springframework.web.socket.WebSocketSession WebSocketSession}, + * to guarantee only one thread can send messages at a time., + * <p>If a send is slow, subsequent attempts to send more messages from other, + * threads will not be able to acquire the flush lock and messages will be, + * buffered instead -- at that time, the specified buffer-size limit and, + * send-time limit will be checked and the session closed if the limits are, + * exceeded., +	private final int sendTimeLimit;, +	private final Queue<WebSocketMessage<?>> buffer = new LinkedBlockingQueue<WebSocketMessage<?>>();, +, +	private final AtomicInteger bufferSize = new AtomicInteger();, +, +	private volatile boolean closeInProgress;, +		if (shouldNotSend()) {, +					String text = String.format("Another send already in progress: " +, +							"session id '%s':, \"in-progress\" send time %d (ms), buffer size %d bytes",, +							getId(), getTimeSinceSendStarted(), this.bufferSize.get());, +					logger.trace(text);, +		while (!this.buffer.isEmpty() && !shouldNotSend());, +	private boolean shouldNotSend() {, +		return (this.limitExceeded || this.closeInProgress);, +					WebSocketMessage<?> message = this.buffer.poll();, +					if (message == null || shouldNotSend()) {, +					this.bufferSize.addAndGet(message.getPayloadLength() * -1);, +					getDelegate().sendMessage(message);, +		if (!shouldNotSend() && this.closeLock.tryLock()) {, +					String format = "Message send time %d (ms) for session '%s' exceeded the allowed limit %d";, +					String reason = String.format(format, getTimeSinceSendStarted(), getId(), this.sendTimeLimit);, +					setLimitExceeded(reason);, +					String format = "The send buffer size %d bytes for session '%s' exceeded the allowed limit %d";, +					String reason = String.format(format, this.bufferSize.get(), getId(), this.bufferSizeLimit);, +					setLimitExceeded(reason);, +	private void setLimitExceeded(String reason) {, +		throw new SessionLimitExceededException(reason, CloseStatus.SESSION_NOT_RELIABLE);, +		this.closeInProgress = true;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, + * Copyright 2002-2016 the original author or authors., + * Wrap a {@link org.springframework.web.socket.WebSocketSession WebSocketSession}, + * to guarantee only one thread can send messages at a time., + * <p>If a send is slow, subsequent attempts to send more messages from other, + * threads will not be able to acquire the flush lock and messages will be, + * buffered instead -- at that time, the specified buffer-size limit and, + * send-time limit will be checked and the session closed if the limits are, + * exceeded., +	private final int sendTimeLimit;, +	private final Queue<WebSocketMessage<?>> buffer = new LinkedBlockingQueue<WebSocketMessage<?>>();, +, +	private final AtomicInteger bufferSize = new AtomicInteger();, +, +	private volatile boolean closeInProgress;, +		if (shouldNotSend()) {, +					String text = String.format("Another send already in progress: " +, +							"session id '%s':, \"in-progress\" send time %d (ms), buffer size %d bytes",, +							getId(), getTimeSinceSendStarted(), this.bufferSize.get());, +					logger.trace(text);, +		while (!this.buffer.isEmpty() && !shouldNotSend());, +	private boolean shouldNotSend() {, +		return (this.limitExceeded || this.closeInProgress);, +					WebSocketMessage<?> message = this.buffer.poll();, +					if (message == null || shouldNotSend()) {, +					this.bufferSize.addAndGet(message.getPayloadLength() * -1);, +					getDelegate().sendMessage(message);, +		if (!shouldNotSend() && this.closeLock.tryLock()) {, +					String format = "Message send time %d (ms) for session '%s' exceeded the allowed limit %d";, +					String reason = String.format(format, getTimeSinceSendStarted(), getId(), this.sendTimeLimit);, +					setLimitExceeded(reason);, +					String format = "The send buffer size %d bytes for session '%s' exceeded the allowed limit %d";, +					String reason = String.format(format, this.bufferSize.get(), getId(), this.bufferSizeLimit);, +					setLimitExceeded(reason);, +	private void setLimitExceeded(String reason) {, +		throw new SessionLimitExceededException(reason, CloseStatus.SESSION_NOT_RELIABLE);, +		this.closeInProgress = true;, +++ b/spring-websocket/src/test/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecoratorTests.java, + * Copyright 2002-2016 the original author or authors., +, +		Executors.newSingleThreadExecutor().submit((Runnable) () -> {, +			TextMessage message = new TextMessage("slow message");, +				concurrentSession.sendMessage(message);, +		blockingSession.setId("123");, +		Executors.newSingleThreadExecutor().submit((Runnable) () -> {, +			TextMessage message = new TextMessage("slow message");, +				concurrentSession.sendMessage(message);, +			String actual = ex.getMessage();, +			String regex = "Message send time [\\d]+ \\(ms\\) for session '123' exceeded the allowed limit 100";, +			assertTrue("Unexpected message: " + actual, actual.matches(regex));, +		blockingSession.setId("123");, +		Executors.newSingleThreadExecutor().submit((Runnable) () -> {, +			TextMessage message = new TextMessage("slow message");, +				concurrentSession.sendMessage(message);, +			String actual = ex.getMessage();, +			String regex = "The send buffer size [\\d]+ bytes for session '123' exceeded the allowed limit 1024";, +			assertTrue("Unexpected message: " + actual, actual.matches(regex));, +			assertEquals(CloseStatus.SESSION_NOT_RELIABLE, ex.getStatus());]