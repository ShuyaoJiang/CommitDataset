[+++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java, + * Checks SpelCompiler behavior. This should cover compilation all compiled node types., +		// Code gen is different for -1 .. 6 because there are bytecode instructions specifically for those values, +		assertEquals("Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Three",, +				getAst().getExitDescriptor());, +		SpelParserConfiguration spc = new SpelParserConfiguration(, +				SpelCompilerMode.IMMEDIATE,getClass().getClassLoader());, +		// This next call was failing because the isCompilable check in Indexer, +		// did not check on the key being compilable (and also generateCode in the, +		// Indexer was missing the optimization that it didn't need necessarily, +		// need to call generateCode for that accessor), +	@Test, +	public void repeatedCompilation() throws Exception {, +		// Verifying that after a number of compilations, the classloaders, +		// used to load the compiled expressions are discarded/replaced., +		// See SpelCompiler.loadClass(), +		Field f = SpelExpression.class.getDeclaredField("compiledAst");, +		Set<Object> classloadersUsed = new HashSet<>();, +		for (int i = 0; i < 1500; i++) {  // 1500 is greater than SpelCompiler.CLASSES_DEFINED_LIMIT, +			expression = parser.parseExpression("4 + 5");, +			assertEquals(9, (int) expression.getValue(Integer.class));, +			assertCanCompile(expression);, +			f.setAccessible(true);, +			CompiledExpression cEx = (CompiledExpression) f.get(expression);, +			classloadersUsed.add(cEx.getClass().getClassLoader());, +			assertEquals(9, (int) expression.getValue(Integer.class));, +		}, +		assertTrue(classloadersUsed.size() > 1);, +	}, +, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java, + * Checks SpelCompiler behavior. This should cover compilation all compiled node types., +		// Code gen is different for -1 .. 6 because there are bytecode instructions specifically for those values, +		assertEquals("Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Three",, +				getAst().getExitDescriptor());, +		SpelParserConfiguration spc = new SpelParserConfiguration(, +				SpelCompilerMode.IMMEDIATE,getClass().getClassLoader());, +		// This next call was failing because the isCompilable check in Indexer, +		// did not check on the key being compilable (and also generateCode in the, +		// Indexer was missing the optimization that it didn't need necessarily, +		// need to call generateCode for that accessor), +	@Test, +	public void repeatedCompilation() throws Exception {, +		// Verifying that after a number of compilations, the classloaders, +		// used to load the compiled expressions are discarded/replaced., +		// See SpelCompiler.loadClass(), +		Field f = SpelExpression.class.getDeclaredField("compiledAst");, +		Set<Object> classloadersUsed = new HashSet<>();, +		for (int i = 0; i < 1500; i++) {  // 1500 is greater than SpelCompiler.CLASSES_DEFINED_LIMIT, +			expression = parser.parseExpression("4 + 5");, +			assertEquals(9, (int) expression.getValue(Integer.class));, +			assertCanCompile(expression);, +			f.setAccessible(true);, +			CompiledExpression cEx = (CompiledExpression) f.get(expression);, +			classloadersUsed.add(cEx.getClass().getClassLoader());, +			assertEquals(9, (int) expression.getValue(Integer.class));, +		}, +		assertTrue(classloadersUsed.size() > 1);, +	}, +, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationPerformanceTests.java, + * Copyright 2002-2017 the original author or authors., + *, + * <p>By default these tests are marked @Ignore since they can fail on a busy machine, + * because they compare relative performance of interpreted vs compiled., +	int count = 50000;  // number of evaluations that are timed in one run, +, +	int iterations = 10;  // number of times to repeat 'count' evaluations (for averaging), +, +		double averageInterpreted = interpretedTotal / iterations;, +		double averageCompiled = compiledTotal / iterations;, +		logln(">>" + title + ": average for " + count + ": compiled=" + averageCompiled +, +				"ms interpreted=" + averageInterpreted + "ms: compiled takes " +, +				((int) ratio) + "% of the interpreted time");, +			if (message.length > 0) {, +, +, +	public static class Payload {, +, +		Two[] DR = new Two[]{new Two()};, +, +		public Two[] getDR() {, +			return DR;, +		}, +	}, +, +, +	public static class Two {, +, +		Three DRFixedSection = new Three();, +, +		public Three getDRFixedSection() {, +			return DRFixedSection;, +		}, +	}, +, +, +	public static class Three {, +, +		double duration = 0.4d;]