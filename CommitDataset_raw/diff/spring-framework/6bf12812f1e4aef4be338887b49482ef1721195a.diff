[+++ b/src/asciidoc/web-reactive.adoc, +This section provides basic information on the reactive programming, +support for Web applications in Spring Framework 5., +=== What is Reactive Programming?, +and event-driven and require a small number of threads to scale vertically (i.e. within the, +JVM) rather than horizontally (i.e. through clustering)., +A key aspect of the reactive applications is the concept of backpressure which is, +a mechanism to ensure producers don't overwhelm consumers. For example in a pipeline, +of reactive components extending from the database to the HTTP connection when the, +HTTP client is slow the data repository also slows down or stops until capacity frees up., +, +Reactive programming also involves a major shift from imperative style logic, +to declarative async composition of logic. It is comparable to using `CompletableFuture`, +in Java 8 and composing follow-up actions via lambda expressions., +=== Reactive API and Building Blocks, +Spring Framework 5 includes a new `spring-web-reactive` module. The module contains support, +for reactive HTTP and WebSocket clients as well as for reactive server web applications, +including REST, HTML browser, and WebSocket style interactions., +=== Server-Side Reactive Web Support, +On the server-side the new reactive module supports 2 distinct programming models:, +* Annotation-based with `@Controller` and the other annotations supported also with Spring MVC, +* Functional, Java 8 lambda style routing and handling, +Both programming models are executed on the same reactive foundation that adapts, +non-blocking HTTP runtimes to the Reactive Streams API. The diagram, +below shows the server-side stack including traditional, Servlet-based, +Spring MVC on the left from the `spring-web-mvc` module and also the, +reactive stack on the right from the `spring-web-reactive` module., +The new reactive stack can run on Servlet containers with support for the, +Servlet 3.1 Non-Blocking IO API as well as on other async runtimes such as, +Netty and Undertow. Each runtime is adapted to a reactive, +`ServerHttpRequest` and `ServerHttpResponse` exposing the body of the, +request and response as `Flux<DataBuffer>`, rather than, +`InputStream` and `OutputStream`, with reactive backpressure., +REST-style JSON and XML serialization and deserialization is supported on top, +as a `Flux<Object>`, and so is HTML view rendering and Server-Sent Events., +==== Annotation-based Programming Model, +The same `@Controller` programming model and the same annotations used in Spring MVC, +are also supported on the reactive side. The main difference is that the framework, +contracts underneath -- i.e. `HandlerMapping`, `HandlerAdapter`, are, +non-blocking and operate on the reactive `ServerHttpRequest` and `ServerHttpResponse`, +rather than on the `HttpServletRequest` and `HttpServletResponse`., +Below is an example with a reactive controller:, +==== Functional Programming Model, +The functional programming model uses Java 8 lambda style routing and request, +handling instead of annotations. The main API contracts are functional interfaces named, +`RouterFunction` and `HandlerFunction`. They are simple but powerful building blocks, +for creating web applications. Below is an example of functional request handling:, +For more on the functional programming model see the, +https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework[M3 release blog post]., +, +, +=== Client-Side Reactive Web Support, +Spring Framework 5 includes a functional, reactive `WebClient` that offers a fully, +non-blocking and reactive alternative to the `RestTemplate`. It exposes network, +input and output as a reactive `ClientHttpRequest` and `ClientHttpRespones` where, +the body of the request and response is a `Flux<DataBuffer>` rather than an, +`InputStream` and `OutputStream`. In addition it supports the same reactive JSON, XML,, +and SSE serialization mechanism as on the server side so you can work with typed objects., +Below is an example of using the `WebClient` which requires a `ClientHttpConnector`, +implementation to plug in a specific HTTP client such as Reactor Netty:, +WebClient client = WebClient.create(new ReactorClientHttpConnector());, +ClientRequest<Void> request = ClientRequest, +		.GET("http://example.com/accounts/{id}", 1L), +		.accept(APPLICATION_JSON), +		.build();, +Mono<Account> account = client, +, +[NOTE], +====, +The `AsyncRestTemplate` also supports non-blocking interactions. The main difference, +is it can't support non-blocking streaming, like for example, +https://dev.twitter.com/streaming/overview[Twitter one], because fundamentally it's, +still based and relies on `InputStream` and `OutputStream`., +====, +, +=== Encoding and Decoding the Request and Response Body, +For example the request body can be one of the following way and it will be decoded, +automatically in both the annotation and the functional programming models:, +* `Account account` -- the account is deserialized without blocking before the controller is invoked., +* `Mono<Account> account` -- the controller can use the `Mono` to declare logic to be executed after the account is deserialized., +The response body can be one of the following:, +* `Account` -- serialize without blocking the given Account; implies a synchronous, non-blocking controller method., +[[web-reactive-websocket-support]], +=== Reactive WebSocket Support, +, +The Spring Framework 5 `spring-web-reactive` module includes reactive WebSocket, +client and server support. Both client and server are supported on the Java WebSocket API, +(JSR-356), Jetty, Undertow, Reactor Netty, and RxNetty., +, +On the server side, declare a `WebSocketHandlerAdapter` and then simply add, +mappings to `WebSocketHandler`-based endpoints:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +@Bean, +public HandlerMapping webSocketMapping() {, +	Map<String, WebSocketHandler> map = new HashMap<>();, +	map.put("/foo", new FooWebSocketHandler());, +	map.put("/bar", new BarWebSocketHandler());]