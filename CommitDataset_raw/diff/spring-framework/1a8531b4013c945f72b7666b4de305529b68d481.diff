[+++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/LocalSessionFactoryBean.java, +import org.hibernate.SessionFactory;, +++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/LocalSessionFactoryBean.java, +import org.hibernate.SessionFactory;, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanDelegate.java, +import javax.sql.DataSource;, +, +		builder.logger.info("Closing Hibernate SessionFactory");, +		DataSource dataSource = builder.getDataSource();, +		if (dataSource != null) {, +			// Make given DataSource available for potential SchemaExport,, +			// which unfortunately reinstantiates a ConnectionProvider., +			SessionFactoryBuilderSupport.configTimeDataSourceHolder.set(dataSource);, +		}, +		try {, +			builder.beforeSessionFactoryDestruction();, +		}, +		finally {, +			this.sessionFactory.close();, +			if (dataSource != null) {, +				// Reset DataSource holder., +				SessionFactoryBuilderSupport.configTimeDataSourceHolder.remove();, +			}, +		}, +++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/LocalSessionFactoryBean.java, +import org.hibernate.SessionFactory;, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanDelegate.java, +import javax.sql.DataSource;, +, +		builder.logger.info("Closing Hibernate SessionFactory");, +		DataSource dataSource = builder.getDataSource();, +		if (dataSource != null) {, +			// Make given DataSource available for potential SchemaExport,, +			// which unfortunately reinstantiates a ConnectionProvider., +			SessionFactoryBuilderSupport.configTimeDataSourceHolder.set(dataSource);, +		}, +		try {, +			builder.beforeSessionFactoryDestruction();, +		}, +		finally {, +			this.sessionFactory.close();, +			if (dataSource != null) {, +				// Reset DataSource holder., +				SessionFactoryBuilderSupport.configTimeDataSourceHolder.remove();, +			}, +		}, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanOperations.java, +++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/LocalSessionFactoryBean.java, +import org.hibernate.SessionFactory;, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanDelegate.java, +import javax.sql.DataSource;, +, +		builder.logger.info("Closing Hibernate SessionFactory");, +		DataSource dataSource = builder.getDataSource();, +		if (dataSource != null) {, +			// Make given DataSource available for potential SchemaExport,, +			// which unfortunately reinstantiates a ConnectionProvider., +			SessionFactoryBuilderSupport.configTimeDataSourceHolder.set(dataSource);, +		}, +		try {, +			builder.beforeSessionFactoryDestruction();, +		}, +		finally {, +			this.sessionFactory.close();, +			if (dataSource != null) {, +				// Reset DataSource holder., +				SessionFactoryBuilderSupport.configTimeDataSourceHolder.remove();, +			}, +		}, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanOperations.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBuilderSupport.java, +	 * Wrap the given SessionFactory with a proxy, if demanded., +	 * <p>The default implementation simply returns the given SessionFactory as-is., +	 * Subclasses may override this to implement transaction awareness through, +	 * a SessionFactory proxy, for example., +	 * @param rawSf the raw SessionFactory as built by {@link #buildSessionFactory()}, +	 * @return the SessionFactory reference to expose, +	protected SessionFactory wrapSessionFactoryIfNecessary(SessionFactory rawSf) {, +		return rawSf;, +++ b/org.springframework.integration-tests/src/test/java/org/springframework/orm/hibernate3/HibernateSessionFactoryConfigurationTests.java, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/LocalSessionFactoryBean.java, +import org.hibernate.SessionFactory;, +++ b/org.springframework.orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryBeanDelegate.java, +import javax.sql.DataSource;, +, +		builder.logger.info("Closing Hibernate SessionFactory");, +		DataSource dataSource = builder.getDataSource();, +		if (dataSource != null) {, +			// Make given DataSource available for potential SchemaExport,, +			// which unfortunately reinstantiates a ConnectionProvider., +			SessionFactoryBuilderSupport.configTimeDataSourceHolder.set(dataSource);, +		}, +		try {, +			builder.beforeSessionFactoryDestruction();, +		}]