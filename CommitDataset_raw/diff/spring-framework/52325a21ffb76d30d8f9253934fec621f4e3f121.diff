[+++ b/spring-web-reactive/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodySubscriber.java, +/*, + * Copyright 2002-2016 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.http.server.reactive;, +, +import java.io.IOException;, +import java.nio.channels.Channel;, +import java.util.concurrent.atomic.AtomicReference;, +import javax.servlet.WriteListener;, +, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.reactivestreams.Subscriber;, +import org.reactivestreams.Subscription;, +import reactor.core.util.BackpressureUtils;, +, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.core.io.buffer.FlushingDataBuffer;, +import org.springframework.core.io.buffer.support.DataBufferUtils;, +import org.springframework.util.Assert;, +, +/**, + * Abstract base class for {@code Subscriber} implementations that bridge between, + * event-listener APIs and Reactive Streams. Specifically, base class for the Servlet 3.1, + * and Undertow support., + * @author Arjen Poutsma, + * @see ServletServerHttpRequest, + * @see UndertowHttpHandlerAdapter, + */, +abstract class AbstractResponseBodySubscriber implements Subscriber<DataBuffer> {, +, +	protected final Log logger = LogFactory.getLog(getClass());, +, +	private final AtomicReference<State> state =, +			new AtomicReference<>(State.UNSUBSCRIBED);, +, +	private volatile DataBuffer currentBuffer;, +, +	private volatile boolean subscriptionCompleted;, +, +	private Subscription subscription;, +, +	@Override, +	public final void onSubscribe(Subscription subscription) {, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onSubscribe: " + subscription);, +		}, +		this.state.get().onSubscribe(this, subscription);, +	}, +, +	@Override, +	public final void onNext(DataBuffer dataBuffer) {, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onNext: " + dataBuffer);, +		}, +		this.state.get().onNext(this, dataBuffer);, +	}, +, +	@Override, +	public final void onError(Throwable t) {, +		if (logger.isErrorEnabled()) {, +			logger.error(this.state + " onError: " + t, t);, +		}, +		this.state.get().onError(this, t);, +	}, +, +	@Override, +	public final void onComplete() {, +		if (logger.isTraceEnabled()) {, +			logger.trace(this.state + " onComplete");, +		}, +		this.state.get().onComplete(this);, +	}, +, +	/**, +	 * Called via a listener interface to indicate that writing is possible., +	 * @see WriteListener#onWritePossible(), +	 * @see org.xnio.ChannelListener#handleEvent(Channel), +	 */, +	protected final void onWritePossible() {, +		this.state.get().onWritePossible(this);, +	}, +, +	/**, +	 * Called when a {@link DataBuffer} is received via {@link Subscriber#onNext(Object)}, +	 * @param dataBuffer the buffer that was received.]