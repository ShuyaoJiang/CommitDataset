[+++ b/spring-beans/src/main/java/org/springframework/beans/DirectFieldAccessor.java, +		PropertyMatches matches = PropertyMatches.forField(propertyName, getRootClass());, +				getRootClass(), getNestedPath() + propertyName,, +				matches.buildErrorMessage(), matches.getPossibleMatches());, +++ b/spring-beans/src/main/java/org/springframework/beans/DirectFieldAccessor.java, +		PropertyMatches matches = PropertyMatches.forField(propertyName, getRootClass());, +				getRootClass(), getNestedPath() + propertyName,, +				matches.buildErrorMessage(), matches.getPossibleMatches());, +++ b/spring-beans/src/main/java/org/springframework/beans/PropertyMatches.java, + * Copyright 2002-2015 the original author or authors., +import java.lang.reflect.Field;, +import org.springframework.util.ReflectionUtils;, + * @author Stephane Nicoll, +abstract class PropertyMatches {, +		return new BeanPropertyMatches(propertyName, beanClass, maxDistance);, +	}, +, +	/**, +	 * Create PropertyMatches for the given field property., +	 * @param propertyName the name of the field to find possible matches for, +	 * @param beanClass the bean class to search for matches, +	 */, +	public static PropertyMatches forField(String propertyName, Class<?> beanClass) {, +		return forField(propertyName, beanClass, DEFAULT_MAX_DISTANCE);, +	}, +, +	/**, +	 * Create PropertyMatches for the given field property., +	 * @param propertyName the name of the field to find possible matches for, +	 * @param beanClass the bean class to search for matches, +	 * @param maxDistance the maximum property distance allowed for matches, +	 */, +	public static PropertyMatches forField(String propertyName, Class<?> beanClass, int maxDistance) {, +		return new FieldPropertyMatches(propertyName, beanClass, maxDistance);, +	 * Create a new PropertyMatches instance for the given property and possible matches., +	private PropertyMatches(String propertyName, String[] possibleMatches) {, +		this.possibleMatches = possibleMatches;, +	/**, +	 * Return the name of the requested property., +	 */, +	public String getPropertyName() {, +		return propertyName;, +	}, +	public abstract String buildErrorMessage();, +	private static int calculateStringDistance(String s1, String s2) {, +	private static class BeanPropertyMatches extends PropertyMatches {, +, +		private BeanPropertyMatches(String propertyName, Class<?> beanClass, int maxDistance) {, +			super(propertyName, calculateMatches(propertyName,, +					BeanUtils.getPropertyDescriptors(beanClass), maxDistance));, +		}, +, +		/**, +		 * Generate possible property alternatives for the given property and, +		 * class. Internally uses the {@code getStringDistance} method, which, +		 * in turn uses the Levenshtein algorithm to determine the distance between, +		 * two Strings., +		 * @param propertyDescriptors the JavaBeans property descriptors to search, +		 * @param maxDistance the maximum distance to accept, +		 */, +		private static String[] calculateMatches(String propertyName, PropertyDescriptor[] propertyDescriptors, int maxDistance) {, +			List<String> candidates = new ArrayList<String>();, +			for (PropertyDescriptor pd : propertyDescriptors) {, +				if (pd.getWriteMethod() != null) {, +					String possibleAlternative = pd.getName();, +					if (calculateStringDistance(propertyName, possibleAlternative) <= maxDistance) {, +						candidates.add(possibleAlternative);, +					}, +				}, +			}, +			Collections.sort(candidates);, +			return StringUtils.toStringArray(candidates);, +		}, +, +, +		@Override, +		public String buildErrorMessage() {, +			String propertyName = getPropertyName();, +			String[] possibleMatches = getPossibleMatches();, +			StringBuilder msg = new StringBuilder();, +			msg.append("Bean property '");, +			msg.append(propertyName);, +			msg.append("' is not writable or has an invalid setter method. ");, +, +			if (ObjectUtils.isEmpty(possibleMatches)) {, +				msg.append("Does the parameter type of the setter match the return type of the getter?");, +			}, +			else {, +				msg.append("Did you mean ");, +				for (int i = 0; i < possibleMatches.length; i++) {, +					msg.append('\'');, +					msg.append(possibleMatches[i]);, +					if (i < possibleMatches.length - 2) {, +						msg.append("', ");, +					}, +					else if (i == possibleMatches.length - 2) {, +						msg.append("', or ");, +					}, +				}, +				msg.append("'?");]