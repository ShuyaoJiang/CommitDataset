[+++ b/org.springframework.web.portlet/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.portlet/com.springsource.javax.portlet/2.0.0/com.springsource.javax.portlet-2.0.0.jar"/>, +++ b/org.springframework.web.portlet/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.portlet/com.springsource.javax.portlet/2.0.0/com.springsource.javax.portlet-2.0.0.jar"/>, +++ b/org.springframework.web.portlet/ivy.xml, +		<dependency org="javax.portlet" name="com.springsource.javax.portlet" rev="2.0.0" conf="provided->compile"/>, +++ b/org.springframework.web.portlet/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.portlet/com.springsource.javax.portlet/2.0.0/com.springsource.javax.portlet-2.0.0.jar"/>, +++ b/org.springframework.web.portlet/ivy.xml, +		<dependency org="javax.portlet" name="com.springsource.javax.portlet" rev="2.0.0" conf="provided->compile"/>, +++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/DispatcherPortlet.java, + * Copyright 2002-2009 the original author or authors., +import javax.portlet.EventRequest;, +import javax.portlet.EventResponse;, +import javax.portlet.MimeResponse;, +import javax.portlet.ResourceRequest;, +import javax.portlet.ResourceResponse;, + * Default is a {@link org.springframework.web.portlet.mvc.annotation.DefaultAnnotationHandlerMapping}., + * HandlerMapping objects can be defined as beans in the portlet's application context,, + * implementing the HandlerMapping interface, overriding the default HandlerMapping if present., + * HandlerMappings can be given any bean name (they are tested by type)., + * A default {@link org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter}, +	 * Processes the actual dispatching to the handler for resource requests., +	 * <p>The handler will be obtained by applying the portlet's HandlerMappings in order., +	 * The HandlerAdapter will be obtained by querying the portlet's installed, +	 * HandlerAdapters to find the first that supports the handler class., +	 * @param request current portlet render request, +	 * @param response current portlet render response, +	 * @throws Exception in case of any kind of processing failure, +	@Override, +	protected void doResourceService(ResourceRequest request, ResourceResponse response) throws Exception {, +		if (logger.isDebugEnabled()) {, +			logger.debug("DispatcherPortlet with name '" + getPortletName() + "' received resource request");, +		HandlerExecutionChain mappedHandler = null;, +		int interceptorIndex = -1;, +, +		try {, +			ModelAndView mv = null;, +			try {, +				// Check for forwarded exception from the action phase, +				PortletSession session = request.getPortletSession(false);, +				if (session != null) {, +					if (request.getParameter(ACTION_EXCEPTION_RENDER_PARAMETER) != null) {, +						Exception ex = (Exception) session.getAttribute(ACTION_EXCEPTION_SESSION_ATTRIBUTE);, +						if (ex != null) {, +							logger.debug("Render phase found exception caught during action phase - rethrowing it");, +							throw ex;, +						}, +					}, +					else {, +						session.removeAttribute(ACTION_EXCEPTION_SESSION_ATTRIBUTE);, +					}, +				}, +, +				// Determine handler for the current request., +				mappedHandler = getHandler(request, false);, +				if (mappedHandler == null || mappedHandler.getHandler() == null) {, +					noHandlerFound(request, response);, +					return;, +				}, +, +				// Apply preHandle methods of registered interceptors., +				HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();, +				if (interceptors != null) {, +					for (int i = 0; i < interceptors.length; i++) {, +						HandlerInterceptor interceptor = interceptors[i];, +						if (!interceptor.preHandleResource(request, response, mappedHandler.getHandler())) {, +							triggerAfterResourceCompletion(mappedHandler, interceptorIndex, request, response, null);, +							return;, +						}, +						interceptorIndex = i;, +					}, +				}, +, +				// Actually invoke the handler., +				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());, +				mv = ha.handleResource(request, response, mappedHandler.getHandler());, +, +				// Apply postHandle methods of registered interceptors., +				if (interceptors != null) {, +					for (int i = interceptors.length - 1; i >= 0; i--) {, +						HandlerInterceptor interceptor = interceptors[i];, +						interceptor.postHandleResource(request, response, mappedHandler.getHandler(), mv);, +					}, +				}, +			}, +			catch (ModelAndViewDefiningException ex) {, +				logger.debug("ModelAndViewDefiningException encountered", ex);, +				mv = ex.getModelAndView();, +			}, +			catch (Exception ex) {, +				Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);, +				mv = processHandlerException(request, response, handler, ex);, +			}, +, +			// Did the handler return a view to render?, +			if (mv != null && !mv.isEmpty()) {, +				render(mv, request, response);, +			}, +			else {]