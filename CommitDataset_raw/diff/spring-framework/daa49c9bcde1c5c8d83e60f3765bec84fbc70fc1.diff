[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java, +			boolean headerComplete = false;, +			while (buffer.hasRemaining()) {, +				if (tryConsumeEndOfLine(buffer)) {, +					headerComplete = true;, +					break;, +				}, +			if (headerStream.size() > 0 && headerComplete) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java, +			boolean headerComplete = false;, +			while (buffer.hasRemaining()) {, +				if (tryConsumeEndOfLine(buffer)) {, +					headerComplete = true;, +					break;, +				}, +			if (headerStream.size() > 0 && headerComplete) {, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/stomp/BufferingStompDecoderTests.java, + * Copyright 2002-2015 the original author or authors., +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.fail;, +	// SPR-13416, +, +	@Test, +	public void incompleteHeaderWithPartialEscapeSequence() throws Exception {, +		BufferingStompDecoder stompDecoder = new BufferingStompDecoder(STOMP_DECODER, 128);, +		String chunk = "SEND\na:long\\";, +, +		List<Message<byte[]>> messages = stompDecoder.decode(toByteBuffer(chunk));, +		assertEquals(0, messages.size());, +	}, +, +	@Test(expected = StompConversionException.class), +	public void invalidEscapeSequence() {, +		BufferingStompDecoder stompDecoder = new BufferingStompDecoder(STOMP_DECODER, 128);, +		String payload = "SEND\na:alpha\\x\\n\nMessage body\0";, +		stompDecoder.decode(toByteBuffer(payload));, +	}, +, +	@Test(expected = StompConversionException.class), +	public void invalidEscapeSequenceWithSingleSlashAtEndOfHeaderValue() {]