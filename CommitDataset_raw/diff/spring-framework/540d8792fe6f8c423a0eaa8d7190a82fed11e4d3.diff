[+++ b/spring-core/src/main/java/org/springframework/util/DigestUtils.java, + * @author Craig Andrews, +, +, +	 * Create a new {@link MessageDigest} with the given algorithm., +	 * Necessary because {@code MessageDigest} is not thread-safe., +		}, +		else{, +	private static StringBuilder appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder), +			throws IOException {, +, +++ b/spring-core/src/main/java/org/springframework/util/DigestUtils.java, + * @author Craig Andrews, +, +, +	 * Create a new {@link MessageDigest} with the given algorithm., +	 * Necessary because {@code MessageDigest} is not thread-safe., +		}, +		else{, +	private static StringBuilder appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder), +			throws IOException {, +, +++ b/spring-core/src/main/java/org/springframework/util/FastByteArrayOutputStream.java, + *, + * <p>Unlike {@link java.io.ByteArrayOutputStream}, this implementation is backed, + * by a {@link java.util.LinkedList} of {@code byte[]} instead of 1 constantly, + * resizing {@code byte[]}. It does not copy buffers when it gets expanded., + * There is also no copying of the internal buffer if its contents is extracted, + * with the {@link #writeTo(OutputStream)} method., +, +	// The buffers used to store the content bytes, +	// The size, in bytes, to use when allocating the first byte[], +	private final int initialBlockSize;, +	// The size, in bytes, to use when allocating the next next byte[], +	private int nextBlockSize = 0;, +	// The number of bytes in previous buffers., +	// (The number of bytes in the current buffer is in 'index'.), +	// The index in the byte[] found at buffers.getLast() to be written next, +	private int index = 0;, +, +	// Is the stream closed?, +	private boolean closed = false;, +, +	 * with the default initial capacity of 256 bytes., +		this.nextBlockSize = initialBlockSize;, +, +	// Overridden methods, +, +		if (this.closed) {, +			if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {, +			this.buffers.getLast()[this.index++] = (byte) datum;, +		else if (offset < 0 || offset + length > data.length || length < 0) {, +		else if (this.closed) {, +			if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {, +			if (this.index + length > this.buffers.getLast().length) {, +				int pos = offset;, +					if (this.index == this.buffers.getLast().length) {, +					int copyLength = this.buffers.getLast().length - this.index;, +					System.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);, +					pos += copyLength;, +					this.index += copyLength;, +				}, +				while (length > 0);, +				// copy in the sub-array, +				System.arraycopy(data, offset, this.buffers.getLast(), this.index, length);, +				this.index += length;, +		this.closed = true;, +	 * Convert the buffer's contents into a string decoding bytes using the, +	 * platform's default character set. The length of the new <tt>String</tt>, +	 * is a function of the character set, and hence may not be equal to the, +	 * size of the buffer., +	 * <p>This method always replaces malformed-input and unmappable-character, +	 * sequences with the default replacement string for the platform's, +	 * default character set. The {@linkplain java.nio.charset.CharsetDecoder}, +	 * class should be used when more control over the decoding process is, +	 * required., +	 * @return a String decoded from the buffer's contents, +	 */, +	@Override, +	public String toString() {, +		return new String(toByteArrayUnsafe());, +	}, +, +, +	// Custom methods, +, +	/**, +	 * Return the number of bytes stored in this <code>FastByteArrayOutputStream</code>., +		return (this.alreadyBufferedSize + this.index);, +	 * if the byte array is being made anyways, mind as well as use it. This approach, +	 * also means that if this method is called twice without any writes in between,, +	 * <p>This method is "unsafe" as it returns the internal buffer., +	 * Callers should not modify the returned buffer., +		return this.buffers.getFirst();, +	 * Reset the contents of this <code>FastByteArrayOutputStream</code>., +	 * The output stream can be used again., +		this.buffers.clear();, +		this.nextBlockSize = this.initialBlockSize;, +		this.closed = false;, +		this.index = 0;]