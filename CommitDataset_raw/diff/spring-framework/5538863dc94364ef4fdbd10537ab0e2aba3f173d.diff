[+++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractPromiseToListenableFutureAdapter.java, +		if (!this.promise.isComplete()) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/AbstractPromiseToListenableFutureAdapter.java, +		if (!this.promise.isComplete()) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/Reactor2TcpClient.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +	private final NioEventLoopGroup eventLoopGroup;, +, +	private boolean stopping;, +, +		this.eventLoopGroup = initEventLoopGroup();, +	private static NioEventLoopGroup initEventLoopGroup() {, +		this.eventLoopGroup = null;, +, +		TcpClient<Message<P>, Message<P>> tcpClient;, +		synchronized (this.tcpClients) {, +			if (this.stopping) {, +				IllegalStateException ex = new IllegalStateException("Shutting down.");, +				connectionHandler.afterConnectFailure(ex);, +				return new PassThroughPromiseToListenableFutureAdapter<Void>(Promises.<Void>error(ex));, +			}, +			tcpClient = NetStreams.tcpClient(REACTOR_TCP_CLIENT_TYPE, this.tcpClientSpecFactory);, +			this.tcpClients.add(tcpClient);, +		}, +, +		Promise<Void> promise = tcpClient.start(new MessageChannelStreamHandler<P>(connectionHandler));, +, +		TcpClient<Message<P>, Message<P>> tcpClient;, +		synchronized (this.tcpClients) {, +			if (this.stopping) {, +				IllegalStateException ex = new IllegalStateException("Shutting down.");, +				connectionHandler.afterConnectFailure(ex);, +				return new PassThroughPromiseToListenableFutureAdapter<Void>(Promises.<Void>error(ex));, +			}, +			tcpClient = NetStreams.tcpClient(REACTOR_TCP_CLIENT_TYPE, this.tcpClientSpecFactory);, +			this.tcpClients.add(tcpClient);, +		}, +, +		Stream<Tuple2<InetSocketAddress, Integer>> stream = tcpClient.start(, +			this.stopping = true;, +		Promise<Void> promise = Streams.from(this.tcpClients), +		if (this.eventLoopGroup != null) {, +			final Promise<Void> eventLoopPromise = Promises.prepare();, +			promise.onComplete(new Consumer<Promise<Void>>() {, +				@Override, +				public void accept(Promise<Void> voidPromise) {, +					eventLoopGroup.shutdownGracefully().addListener(new FutureListener<Object>() {, +						@Override, +						public void operationComplete(Future<Object> future) throws Exception {, +							if (future.isSuccess()) {, +								eventLoopPromise.onComplete();, +							}, +							else {, +								eventLoopPromise.onError(future.cause());, +							}, +						}, +					});, +				}, +			});, +			promise = eventLoopPromise;, +		}]