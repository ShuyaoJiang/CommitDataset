[+++ b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +import org.springframework.core.annotation.AnnotatedElementUtils;, +		Collection<Cacheable> cacheables = AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class);, +		if (!cacheables.isEmpty()) {, +		Collection<CacheEvict> evicts = AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class);, +		if (!evicts.isEmpty()) {, +		Collection<CachePut> puts = AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class);, +		if (!puts.isEmpty()) {, +		Collection<Caching> cachings = AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class);, +		if (!cachings.isEmpty()) {, +++ b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +import org.springframework.core.annotation.AnnotatedElementUtils;, +		Collection<Cacheable> cacheables = AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class);, +		if (!cacheables.isEmpty()) {, +		Collection<CacheEvict> evicts = AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class);, +		if (!evicts.isEmpty()) {, +		Collection<CachePut> puts = AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class);, +		if (!puts.isEmpty()) {, +		Collection<Caching> cachings = AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class);, +		if (!cachings.isEmpty()) {, +++ b/spring-context/src/test/java/org/springframework/cache/annotation/AnnotationCacheOperationSourceTests.java, + * Copyright 2002-2016 the original author or authors., +		Collection<CacheOperation> ops = getOps(AnnotatedClass.class, "singleComposed", 2);, +		assertThat(cacheOperation.getCacheNames(), equalTo(Collections.singleton("directly declared")));, +		assertThat(cacheOperation.getKey(), equalTo(""));, +, +		cacheOperation = it.next();, +		assertThat(cacheOperation, instanceOf(CacheableOperation.class));, +		assertThat(cacheOperation.getKey(), equalTo("composedKey"));, +	}, +, +	@Test, +	public void multipleComposedAnnotations() throws Exception {, +		Collection<CacheOperation> ops = getOps(AnnotatedClass.class, "multipleComposed", 4);, +		Iterator<CacheOperation> it = ops.iterator();, +, +		CacheOperation cacheOperation = it.next();, +		assertThat(cacheOperation, instanceOf(CacheableOperation.class));, +		assertThat(cacheOperation.getCacheNames(), equalTo(Collections.singleton("directly declared")));, +		assertThat(cacheOperation.getKey(), equalTo(""));, +, +		cacheOperation = it.next();, +		assertThat(cacheOperation, instanceOf(CacheableOperation.class));, +		assertThat(cacheOperation.getCacheNames(), equalTo(Collections.singleton("composedCache")));, +		assertThat(cacheOperation.getKey(), equalTo("composedKey"));, +		assertThat(cacheOperation.getKey(), equalTo(""));, +		assertThat(cacheOperation.getCacheNames(), equalTo(Collections.singleton("composedCacheEvict")));, +		assertThat(cacheOperation.getKey(), equalTo("composedEvictionKey"));, +		@Cacheable("directly declared"), +		@ComposedCacheable(cacheNames = "composedCache", key = "composedKey"), +		@Cacheable("directly declared"), +		@ComposedCacheEvict(cacheNames = "composedCacheEvict", key = "composedEvictionKey"), +	@CacheConfig(keyGenerator = "classKeyGenerator", cacheManager = "classCacheManager", cacheResolver = "classCacheResolver"), +	@interface ComposedCacheable {, +		@AliasFor(annotation = Cacheable.class), +		@AliasFor(annotation = Cacheable.class), +		@AliasFor(annotation = Cacheable.class), +	@interface ComposedCacheEvict {, +		@AliasFor(annotation = CacheEvict.class), +		@AliasFor(annotation = CacheEvict.class), +		@AliasFor(annotation = CacheEvict.class)]