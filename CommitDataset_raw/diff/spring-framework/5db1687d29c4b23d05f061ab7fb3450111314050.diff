[+++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +, +		return getType() != null ? ClassUtils.resolvePrimitiveIfNecessary(getType()) : null;, +		return getType() != null ? ClassUtils.getQualifiedName(getType()) : null;, +		return getType() != null && getType().isPrimitive();, +		return getType() != null && Collection.class.isAssignableFrom(getType());, +		return getType() != null && getType().isArray();, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Collection or Array, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Collection or Array, +		if (!isCollection() && !isArray()) {, +			throw new IllegalStateException("Not a java.util.Collection or Array");, +		}, +	/**, +	 * Returns a copy of this type descriptor that has its elementType populated from the specified Collection., +	 * This property will be set by calculating the "common element type" of the specified Collection., +	 * For example, if the collection contains String elements, the returned TypeDescriptor will have its elementType set to String., +	 * This method is designed to be used when converting values read from Collection fields or method return values that are not parameterized e.g. Collection vs. Collection<String>, +	 * In this scenario the elementType will be Object.class before invoking this method., +	 * @param colection the collection to derive the elementType from, +	 * @return a new TypeDescriptor with the resolved elementType property, +	 * @throws IllegalArgumentException if this is not a type descriptor for a java.util.Collection., +	 */, +	public TypeDescriptor resolveCollectionElementType(Collection<?> collection) {, +		if (!isCollection()) {, +			throw new IllegalStateException("Not a java.util.Collection");, +		}		, +		return new TypeDescriptor(type, CommonElement.typeDescriptor(collection), mapKeyType, mapValueType, annotations);, +	}, +, +		return getType() != null && Map.class.isAssignableFrom(getType());, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Map, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Map, +		if (!isMap()) {, +			throw new IllegalStateException("Not a map");, +		}, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Map, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Map, +		if (!isMap()) {, +			throw new IllegalStateException("Not a map");, +		}, +	/**, +	 * Returns a copy of this type descriptor that has its mapKeyType and mapValueType properties populated from the specified Map., +	 * These properties will be set by calculating the "common element type" of the specified Map's keySet and values collection., +	 * For example, if the Map contains String keys and Integer values, the returned TypeDescriptor will have its mapKeyType set to String and its mapValueType to Integer., +	 * This method is designed to be used when converting values read from Map fields or method return values that are not parameterized e.g. Map vs. Map<String, Integer>., +	 * In this scenario the key and value types will be Object.class before invoking this method., +	 * @param map the map to derive key and value types from, +	 * @return a new TypeDescriptor with the resolved mapKeyType and mapValueType properties, +	 * @throws IllegalArgumentException if this is not a type descriptor for a java.util.Map., +	 */, +	public TypeDescriptor resolveMapKeyValueTypes(Map<?, ?> map) {, +		if (!isMap()) {, +			throw new IllegalStateException("Not a java.util.Map");, +		}, +		return new TypeDescriptor(type, elementType, CommonElement.typeDescriptor(map.keySet()), CommonElement.typeDescriptor(map.values()), annotations);, +	}, +	, +		if (!(obj instanceof TypeDescriptor)) {, +		boolean annotatedTypeEquals = ObjectUtils.nullSafeEquals(getType(), other.getType()) && ObjectUtils.nullSafeEquals(getAnnotations(), other.getAnnotations());, +		if (!annotatedTypeEquals) {, +			return false;, +		}, +		if (isCollection() || isArray()) {, +			return ObjectUtils.nullSafeEquals(getElementType(), other.getElementType());, +			return ObjectUtils.nullSafeEquals(getMapKeyType(), other.getMapKeyType()) && ObjectUtils.nullSafeEquals(getMapValueType(), other.getMapValueType());, +			return true;, +		this(collectionType, elementType, TypeDescriptor.NULL, TypeDescriptor.NULL, EMPTY_ANNOTATION_ARRAY);, +		this(mapType, TypeDescriptor.NULL, keyType, valueType, EMPTY_ANNOTATION_ARRAY);, +		this(null, TypeDescriptor.NULL, TypeDescriptor.NULL, TypeDescriptor.NULL, EMPTY_ANNOTATION_ARRAY);, +	private TypeDescriptor(Class<?> type, TypeDescriptor elementType, TypeDescriptor mapKeyType, TypeDescriptor mapValueType, Annotation[] annotations) {, +		this.annotations = annotations;, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +, +		return getType() != null ? ClassUtils.resolvePrimitiveIfNecessary(getType()) : null;, +		return getType() != null ? ClassUtils.getQualifiedName(getType()) : null;, +		return getType() != null && getType().isPrimitive();, +		return getType() != null && Collection.class.isAssignableFrom(getType());, +		return getType() != null && getType().isArray();, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Collection or Array, +	 * @throws IllegalStateException if this descriptor is not for a java.util.Collection or Array, +		if (!isCollection() && !isArray()) {, +			throw new IllegalStateException("Not a java.util.Collection or Array");, +		}, +	/**, +	 * Returns a copy of this type descriptor that has its elementType populated from the specified Collection., +	 * This property will be set by calculating the "common element type" of the specified Collection., +	 * For example, if the collection contains String elements, the returned TypeDescriptor will have its elementType set to String., +	 * This method is designed to be used when converting values read from Collection fields or method return values that are not parameterized e.g. Collection vs. Collection<String>, +	 * In this scenario the elementType will be Object.class before invoking this method., +	 * @param colection the collection to derive the elementType from, +	 * @return a new TypeDescriptor with the resolved elementType property, +	 * @throws IllegalArgumentException if this is not a type descriptor for a java.util.Collection., +	 */, +	public TypeDescriptor resolveCollectionElementType(Collection<?> collection) {, +		if (!isCollection()) {, +			throw new IllegalStateException("Not a java.util.Collection");, +		}		, +		return new TypeDescriptor(type, CommonElement.typeDescriptor(collection), mapKeyType, mapValueType, annotations);]