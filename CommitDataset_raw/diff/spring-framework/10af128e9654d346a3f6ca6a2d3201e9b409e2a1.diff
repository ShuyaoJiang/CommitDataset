[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java, +import java.util.Collections;, +import java.util.concurrent.AbstractExecutorService;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.RejectedExecutionHandler;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +		ChannelRegistration reg = getClientInboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientInboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getClientOutboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientOutboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ExecutorSubscribableChannel channel = reg.hasTaskExecutor() ?, +				new ExecutorSubscribableChannel(brokerChannelExecutor()) : new ExecutorSubscribableChannel();, +		channel.setInterceptors(reg.getInterceptors());, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ThreadPoolTaskExecutor executor;, +		if (reg.hasTaskExecutor()) {, +			executor = reg.taskExecutor().getTaskExecutor();, +		}, +		else {, +			// Should never be used, +			executor = new ThreadPoolTaskExecutor();, +			executor.setCorePoolSize(0);, +			executor.setMaxPoolSize(1);, +			executor.setQueueCapacity(0);, +		}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java, +import java.util.Collections;, +import java.util.concurrent.AbstractExecutorService;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.RejectedExecutionHandler;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +		ChannelRegistration reg = getClientInboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientInboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getClientOutboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientOutboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ExecutorSubscribableChannel channel = reg.hasTaskExecutor() ?, +				new ExecutorSubscribableChannel(brokerChannelExecutor()) : new ExecutorSubscribableChannel();, +		channel.setInterceptors(reg.getInterceptors());, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ThreadPoolTaskExecutor executor;, +		if (reg.hasTaskExecutor()) {, +			executor = reg.taskExecutor().getTaskExecutor();, +		}, +		else {, +			// Should never be used, +			executor = new ThreadPoolTaskExecutor();, +			executor.setCorePoolSize(0);, +			executor.setMaxPoolSize(1);, +			executor.setQueueCapacity(0);, +		}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ChannelRegistration.java, + * Copyright 2002-2014 the original author or authors., +	private TaskExecutorRegistration registration;, +	private final List<ChannelInterceptor> interceptors = new ArrayList<ChannelInterceptor>();, +	 * Configure the thread pool backing this message channel., +		if (this.registration == null) {, +			this.registration = new TaskExecutorRegistration();, +		}, +		return this.registration;, +		return (this.registration != null);, +	protected TaskExecutorRegistration getTaskExecRegistration() {, +		return this.registration;, +	}, +, +	protected TaskExecutorRegistration getOrCreateTaskExecRegistration() {, +		return taskExecutor();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java, +import java.util.Collections;, +import java.util.concurrent.AbstractExecutorService;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.RejectedExecutionHandler;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +		ChannelRegistration reg = getClientInboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientInboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getClientOutboundChannelRegistration();, +		channel.setInterceptors(reg.getInterceptors());, +		TaskExecutorRegistration reg = getClientOutboundChannelRegistration().getOrCreateTaskExecRegistration();, +		ThreadPoolTaskExecutor executor = reg.getTaskExecutor();, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ExecutorSubscribableChannel channel = reg.hasTaskExecutor() ?, +				new ExecutorSubscribableChannel(brokerChannelExecutor()) : new ExecutorSubscribableChannel();, +		channel.setInterceptors(reg.getInterceptors());, +		ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();, +		ThreadPoolTaskExecutor executor;, +		if (reg.hasTaskExecutor()) {]