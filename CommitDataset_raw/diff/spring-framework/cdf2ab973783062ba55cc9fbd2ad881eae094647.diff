[+++ b/src/docs/asciidoc/web/webflux-functional.adoc, +Spring WebFlux includes a lightweight, functional programming model in which functions, +are used to route and handle requests and contracts are designed for immutability., +It is an alternative to the annotated-based programming model but otherwise running on, +the same <<web-reactive.adoc#webflux-reactive-spring-web>> foundation, +takes a `ServerRequest` and returns a `Mono<ServerResponse>`. If you're familiar with the, +annotation-based programming model, a handler function is the equivalent of an, +`@RequestMapping` method., +types; the response accepts any Reactive Streams `Publisher` as body. The rational for this, +is explained in <<web-reactive.adoc#webflux-reactive-libraries,Reactive Libraries>>., +the method, URI, query parameters, and headers (via a separate `ServerRequest.Headers`, +interface. Access to the body is provided through the `body` methods. For instance, this is, +The `bodyToMono` and `bodyToFlux` used above are in fact convenience methods that use the, +examples can also be written as follows:, +		Mono<Person> personMono = repository.getPerson(personId);, +particular route, a handler function is returned, or otherwise an empty `Mono` is returned., +`RouterFunction` has a similar purpose as the `@RequestMapping` annotation in the, +annotation-based programming model., +How do you run a router function in an HTTP server? A simple option is to convert a router, +function to an `HttpHandler` using one of the following:, +* `RouterFunctions.toHttpHandler(RouterFunction)`, +* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`, +, +The returned `HttpHandler` can then be used with a number of servers adapters by following, +<<web-reactive.adoc#webflux-httphandler,HttpHandler>> for server-specific instructions., +, +A more advanced option is to run with a, +<<web-reactive.adoc#webflux-dispatcher-handler,DispatcherHandler>>-based setup through the, +<<web-reactive.adoc#webflux-config>> which uses Spring configuration to declare the, +components process requests. The WebFlux Java config declares the following components, +related to functional endpoints:, +, +* `RouterFunctionMapping` -- this detects one or more `RouterFunction<?>` beans in the, +Spring configuration, combines them via `RouterFunction.andOther`, and routes requests to, +the resulting, composed `RouterFunction`., +* `HandlerFunctionAdapter` -- simple adapter to invoke a `HandlerFunction` selected to, +handle a request., +* `ServerResponseResultHandler` -- invokes the `writeTo` method of the `ServerResponse`, +returned by the `HandlerFunction`., +, +The above allows functional endpoints to fit within the `DispatcherHandler` request, +processing lifecycle, and potentially to run side by side with annotated controllers, if, +any are declared. This is also the mechanism used in the Spring Boot WebFlux starter., +, +Below is example WebFlux Java config (see, +<<web-reactive.adoc#webflux-dispatcher-handler,DispatcherHandler>> for how to run):, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +@Configuration, +@EnableWebFlux, +public class WebConfig implements WebFluxConfigurer {, +, +	@Bean, +	public RouterFunction<?> routerFunctionA() {, +		// ..., +	}, +, +	@Bean, +	public RouterFunction<?> routerFunctionB() {, +		// ..., +	}, +, +	// ..., +, +	@Override, +	public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {, +		// configure message conversion..., +	}, +, +	@Override, +	default void addCorsMappings(CorsRegistry registry) {, +		// configure CORS..., +	}, +, +	@Override, +	public void configureViewResolvers(ViewResolverRegistry registry) {, +		// configure view resolution for HTML rendering..., +	}, +}, +----]