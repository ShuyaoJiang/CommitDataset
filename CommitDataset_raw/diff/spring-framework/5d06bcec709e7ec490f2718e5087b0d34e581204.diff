[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +	 * @param suppliedArgTypes the array of types that are being supplied at the point of invocation, +	 * @return a MatchInfo object indicating what kind of match it was or null if it was not a match, +		return (match != null ? new ArgumentsMatchInfo(match) : null);, +		for (int i = 0; i < paramTypes.size(); i++) {, +			TypeDescriptor argType = argTypes.get(i);, +			else {, +				Class<?> paramTypeClazz = paramType.getType();, +				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {, +				Class<?> superClass = argType.getType().getSuperclass();, +					if (paramTypeClazz.equals(superClass)) {, +			// Now... we have the final argument in the method we are checking as a match and we have 0, +			// or more other arguments left to pass to it., +			Class<?> varargsParamType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType();, +					if (varargsParamType.isPrimitive()) {, +				}, +				else {, +					if (varargsParamType != suppliedArg.getType()) {, +						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {, +						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {, +		return (match != null ? new ArgumentsMatchInfo(match) : null);, +			Integer varargsPosition) throws EvaluationException {, +, +		}, +		else {, +			}, +			else {, +	public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method), +			throws SpelEvaluationException {, +, +		for (int argPos = 0; argPos < arguments.length; argPos++) {, +			if (varargsPosition != null && argPos >= varargsPosition) {, +				targetType = new TypeDescriptor(new MethodParameter(method, argPos));, +				Object argument = arguments[argPos];, +						throw new SpelEvaluationException(, +								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType);, +					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);, +					throw new SpelEvaluationException(ex,, +							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType);, +			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);, +, +				Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize);, +				System.arraycopy(args, parameterCount - 1, repackagedArguments, 0, arraySize);, +, +		/** An exact match is where the parameter types exactly match what the method/constructor being invoked is expecting */, +, +		/** A close match is where the parameter types either exactly match or are assignment compatible with the method/constructor being invoked */, +, +		/** A conversion match is where the type converter must be used to transform some of the parameter types */, +	 * An instance of ArgumentsMatchInfo describes what kind of match was achieved between two sets of arguments -, +	 * the set that a method/constructor is expecting and the set that are being supplied at the point of invocation., +	 * If the kind indicates that conversion is required for some of the arguments then the arguments that require, +	 * conversion are listed in the argsRequiringConversion array., +			return "ArgumentMatchInfo: " + this.kind;, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +	 * @param suppliedArgTypes the array of types that are being supplied at the point of invocation, +	 * @return a MatchInfo object indicating what kind of match it was or null if it was not a match, +		return (match != null ? new ArgumentsMatchInfo(match) : null);, +		for (int i = 0; i < paramTypes.size(); i++) {, +			TypeDescriptor argType = argTypes.get(i);, +			else {, +				Class<?> paramTypeClazz = paramType.getType();, +				if (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {, +				Class<?> superClass = argType.getType().getSuperclass();, +					if (paramTypeClazz.equals(superClass)) {, +			// Now... we have the final argument in the method we are checking as a match and we have 0, +			// or more other arguments left to pass to it., +			Class<?> varargsParamType = expectedArgTypes.get(expectedArgTypes.size() - 1).getElementTypeDescriptor().getType();, +					if (varargsParamType.isPrimitive()) {, +				}, +				else {, +					if (varargsParamType != suppliedArg.getType()) {, +						if (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {, +						else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {, +		return (match != null ? new ArgumentsMatchInfo(match) : null);, +			Integer varargsPosition) throws EvaluationException {, +, +		}, +		else {, +			}, +			else {, +	public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method), +			throws SpelEvaluationException {, +, +		for (int argPos = 0; argPos < arguments.length; argPos++) {, +			if (varargsPosition != null && argPos >= varargsPosition) {, +				targetType = new TypeDescriptor(new MethodParameter(method, argPos));, +				Object argument = arguments[argPos];, +						throw new SpelEvaluationException(, +								SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType);, +					arguments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);, +					throw new SpelEvaluationException(ex,, +							SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPos].getClass().getName(), targetType);, +			System.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);, +, +				Object[] repackagedArguments = (Object[]) Array.newInstance(componentType, arraySize);, +				System.arraycopy(args, parameterCount - 1, repackagedArguments, 0, arraySize);, +, +		/** An exact match is where the parameter types exactly match what the method/constructor being invoked is expecting */, +]