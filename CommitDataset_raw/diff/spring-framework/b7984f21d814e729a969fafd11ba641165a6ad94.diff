[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, +			// Fallback: target bean at least found by bean name - probably a manually registered singleton., +					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!");, +				// Ignore - can't compare qualifiers for a manually registered singleton object, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, +			// Fallback: target bean at least found by bean name - probably a manually registered singleton., +					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!");, +				// Ignore - can't compare qualifiers for a manually registered singleton object, +++ b/spring-context-support/src/main/java/org/springframework/cache/guava/GuavaCache.java, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * @param allowNullValues whether to accept and convert {@code null}, +	 * values for this cache, +		}, +		catch (ExecutionException ex) {, +			throw new IllegalStateException(ex);, +, +		private boolean called;, +, +		public PutIfAbsentCallable(Object value) {, +			this.called = true;, +			return toStoreValue(this.value);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, +			// Fallback: target bean at least found by bean name - probably a manually registered singleton., +					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!");, +				// Ignore - can't compare qualifiers for a manually registered singleton object, +++ b/spring-context-support/src/main/java/org/springframework/cache/guava/GuavaCache.java, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * @param allowNullValues whether to accept and convert {@code null}, +	 * values for this cache, +		}, +		catch (ExecutionException ex) {, +			throw new IllegalStateException(ex);, +, +		private boolean called;, +, +		public PutIfAbsentCallable(Object value) {, +			this.called = true;, +			return toStoreValue(this.value);, +++ b/spring-context/src/main/java/org/springframework/cache/Cache.java, +	 * Atomically associate the specified value with the specified key in this cache, +	 * if it is not set already., +	 * except that the action is performed atomically. While all out-of-the-box, +	 * {@link CacheManager} implementations are able to perform the put atomically,, +	 * the operation may also be implemented in two steps, e.g. with a check for, +	 * presence and a subsequent put, in a non-atomic way. Check the documentation, +	 * of the native cache implementation that you are using for more details., +	 * @return the value to which this cache maps the specified key (which may be, +	 * {@code null} itself), or also {@code null} if the cache did not contain any, +	 * mapping for that key prior to this call. Returning {@code null} is therefore, +	 * an indicator that the given {@code value} has been associated with the key., +	 * @since 4.1, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java, +			// Fallback: target bean at least found by bean name - probably a manually registered singleton., +					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!");, +				// Ignore - can't compare qualifiers for a manually registered singleton object, +++ b/spring-context-support/src/main/java/org/springframework/cache/guava/GuavaCache.java, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * Create a {@link GuavaCache} instance with the specified name and the, +	 * given internal {@link com.google.common.cache.Cache} to use., +	 * @param cache the backing Guava Cache instance, +	 * @param allowNullValues whether to accept and convert {@code null}, +	 * values for this cache, +		}, +		catch (ExecutionException ex) {, +			throw new IllegalStateException(ex);, +, +		private boolean called;, +, +		public PutIfAbsentCallable(Object value) {, +			this.called = true;, +			return toStoreValue(this.value);, +++ b/spring-context/src/main/java/org/springframework/cache/Cache.java, +	 * Atomically associate the specified value with the specified key in this cache, +	 * if it is not set already., +	 * except that the action is performed atomically. While all out-of-the-box, +	 * {@link CacheManager} implementations are able to perform the put atomically,, +	 * the operation may also be implemented in two steps, e.g. with a check for, +	 * presence and a subsequent put, in a non-atomic way. Check the documentation, +	 * of the native cache implementation that you are using for more details., +	 * @return the value to which this cache maps the specified key (which may be, +	 * {@code null} itself), or also {@code null} if the cache did not contain any, +	 * mapping for that key prior to this call. Returning {@code null} is therefore, +	 * an indicator that the given {@code value} has been associated with the key., +	 * @since 4.1, +++ b/spring-context/src/main/java/org/springframework/cache/concurrent/ConcurrentMapCache.java, +	 * @param allowNullValues whether to accept and convert {@code null}, +	 * values for this cache, +	 * given internal {@link ConcurrentMap} to use.]