[+++ b/build.gradle, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +++ b/build.gradle, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.net.InetSocketAddress;, +import reactor.core.composable.Composable;, +import reactor.tcp.Reconnect;, +import reactor.tuple.Tuple;, +import reactor.tuple.Tuple2;, +, +, +			@Override, +			protected Composable<TcpConnection<String, String>> openConnection() {, +				return tcpClient.open(new Reconnect() {, +					@Override, +					public Tuple2<InetSocketAddress, Long> reconnect(InetSocketAddress currentAddress, int attempt) {, +						return Tuple.of(currentAddress, 5000L);, +					}, +				});, +			}, +, +		private volatile TcpConnection<String, String> connection = null;, +			Composable<TcpConnection<String, String>> connectionComposable = openConnection();, +			connectionComposable.consume(new Consumer<TcpConnection<String, String>>() {, +				public void accept(TcpConnection<String, String> newConnection) {, +					isConnected = false;, +					connection = newConnection;, +					newConnection.in().consume(new Consumer<String>() {, +					forwardInternal(message);, +, +			connectionComposable.when(Throwable.class, new Consumer<Throwable>() {, +		protected Composable<TcpConnection<String, String>> openConnection() {, +			return tcpClient.open();, +		}, +, +					flushMessages();, +			disconnect();, +		private void disconnect() {, +			this.isConnected = false;, +			this.connection.close();, +			this.connection = null;, +, +			brokerUnavailable();, +		}, +, +							logger.trace("Not connected, message queued. Queue size=" + this.messageQueue.size());, +				forwardInternal(message);, +				flushMessages();, +		private boolean forwardInternal(final Message<?> message) {, +			TcpConnection<String, String> localConnection = this.connection;, +, +			if (localConnection != null) {, +				String payload = new String(bytes, Charset.forName("UTF-8"));, +				localConnection.send(payload, new Consumer<Boolean>() {, +			} else {, +				return false;, +			}, +		private void flushMessages() {, +				if (!forwardInternal(message)) {, +++ b/build.gradle, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.net.InetSocketAddress;, +import reactor.core.composable.Composable;, +import reactor.tcp.Reconnect;, +import reactor.tuple.Tuple;, +import reactor.tuple.Tuple2;, +, +, +			@Override, +			protected Composable<TcpConnection<String, String>> openConnection() {, +				return tcpClient.open(new Reconnect() {, +					@Override, +					public Tuple2<InetSocketAddress, Long> reconnect(InetSocketAddress currentAddress, int attempt) {, +						return Tuple.of(currentAddress, 5000L);, +					}, +				});, +			}, +, +		private volatile TcpConnection<String, String> connection = null;, +			Composable<TcpConnection<String, String>> connectionComposable = openConnection();, +			connectionComposable.consume(new Consumer<TcpConnection<String, String>>() {, +				public void accept(TcpConnection<String, String> newConnection) {, +					isConnected = false;, +					connection = newConnection;, +					newConnection.in().consume(new Consumer<String>() {, +					forwardInternal(message);, +, +			connectionComposable.when(Throwable.class, new Consumer<Throwable>() {, +		protected Composable<TcpConnection<String, String>> openConnection() {, +			return tcpClient.open();, +		}, +]