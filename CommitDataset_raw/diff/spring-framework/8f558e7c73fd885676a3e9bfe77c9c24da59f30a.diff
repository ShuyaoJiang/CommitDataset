[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +	private final MappingRegistry mappingRegistry = new MappingRegistry();, +	 * Return a (read-only) map with all mappings and HandlerMethod's., +		this.mappingRegistry.acquireReadLock();, +		try {, +			return Collections.unmodifiableMap(this.mappingRegistry.getMappings());, +		}, +		finally {, +			this.mappingRegistry.releaseReadLock();, +		}, +	 * <p>Invoked at startup for each detected handler method. May also be, +	 * invoked at runtime after initialization is complete., +	public void registerHandlerMethod(Object handler, Method method, T mapping) {, +	 * Un-register a handler method., +	 * <p>This method may be invoked at runtime after initialization has completed., +	 * @param handlerMethod the handler method to be unregistered, +	 */, +	public void unregisterHandlerMethod(HandlerMethod handlerMethod) {, +		this.mappingRegistry.unregister(handlerMethod);, +	}, +, +	/**, +		this.mappingRegistry.acquireReadLock();, +		try {, +		finally {, +			this.mappingRegistry.releaseReadLock();, +		}, +	}, +			addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);, +			return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);, +	private class MappingRegistry {, +		private final Map<String, List<HandlerMethod>> mappingNameLookup =, +		private final Map<Method, MappingDefinition<T>> methodLookup =, +				new ConcurrentHashMap<Method, MappingDefinition<T>>();, +, +, +		private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();, +, +		 * Return all mappings and handler methods. Not thread-safe., +		 * @see #acquireReadLock(), +			return this.mappingLookup;, +		/**, +		 * Return matches for the given URL path. Not thread-safe., +		 * @see #acquireReadLock(), +		 */, +		/**, +		 * Return the handler method for the mapping key. Not thread-safe., +		 * @see #acquireReadLock(), +		 */, +		 * Return handler methods by mapping name. Thread-safe for concurrent use., +			return this.mappingNameLookup.get(mappingName);, +		 * Return CORS configuration. Thread-safe for concurrent use., +			MappingDefinition<T> definition = this.methodLookup.get(method);, +		/**, +		 * Acquire the read lock when using getMappings and getMappingKeysByUrl., +		 */, +		public void acquireReadLock() {, +			this.readWriteLock.readLock().lock();, +		}, +, +		/**, +		 * Release the read lock after using getMappings and getMappingKeysByUrl., +		 */, +		public void releaseReadLock() {, +			this.readWriteLock.readLock().unlock();, +		}, +, +			this.readWriteLock.writeLock().lock();, +			try {, +				assertUniqueMethodMapping(handlerMethod, mapping);, +				List<String> directUrls = getDirectUrls(mapping);, +					addMappingName(name, handlerMethod);, +				this.methodLookup.put(method,, +			finally {, +				this.readWriteLock.writeLock().unlock();, +			}, +		}, +		private void assertUniqueMethodMapping(HandlerMethod newHandlerMethod, T mapping) {, +			HandlerMethod handlerMethod = this.mappingLookup.get(mapping);, +			if (handlerMethod != null && !handlerMethod.equals(newHandlerMethod)) {, +						"Ambiguous mapping. Cannot map '" +	newHandlerMethod.getBean() + "' method \n" +, +								newHandlerMethod + "\nto " +	mapping + ": There is already '" +, +								handlerMethod.getBean() + "' bean method\n" + handlerMethod + " mapped.");, +			}, +			MappingDefinition<T> definition = this.methodLookup.get(newHandlerMethod.getMethod());, +			if (definition != null) {, +				throw new IllegalStateException("Cannot map " + newHandlerMethod.getMethod() +, +						"\nto " + mapping + ".\n It is already mapped to " + definition.getMapping());, +		private List<String> getDirectUrls(T mapping) {, +		private void addMappingName(String name, HandlerMethod handlerMethod) {, +			List<HandlerMethod> oldList = this.mappingNameLookup.containsKey(name) ?, +					this.mappingNameLookup.get(name) : Collections.<HandlerMethod>emptyList();, +			for (HandlerMethod current : oldList) {, +				if (handlerMethod.getMethod().equals(current.getMethod())) {, +			List<HandlerMethod> newList = new ArrayList<HandlerMethod>(oldList.size() + 1);, +			newList.addAll(oldList);, +			newList.add(handlerMethod);, +			this.mappingNameLookup.put(name, newList);, +			if (newList.size() > 1) {]