[+++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ConcurrentTaskExecutor.java, + * Copyright 2002-2013 the original author or authors., +import java.util.HashMap;, +import java.util.Map;, +import javax.enterprise.concurrent.ManagedExecutors;, +import javax.enterprise.concurrent.ManagedTask;, +import org.springframework.scheduling.SchedulingAwareRunnable;, +import org.springframework.util.ClassUtils;, + * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedExecutorService}, + * in order to expose {@link javax.enterprise.concurrent.ManagedTask} adapters for it,, + * exposing a long-running hint based on {@link SchedulingAwareRunnable} and an, + * identity name based on the given Runnable/Callable's {@code toString()}., + *, +	private static Class<?> managedExecutorService;, +, +	static {, +		try {, +			managedExecutorService = ClassUtils.forName(, +					"javax.enterprise.concurrent.ManagedExecutorService",, +					ConcurrentTaskScheduler.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// JSR-236 API not available..., +			managedExecutorService = null;, +		}, +	}, +, +	 * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedExecutorService}, +	 * in order to expose {@link javax.enterprise.concurrent.ManagedTask} adapters for it., +	 * <p>Autodetects a JSR-236 {@link javax.enterprise.concurrent.ManagedExecutorService}, +	 * in order to expose {@link javax.enterprise.concurrent.ManagedTask} adapters for it., +		if (concurrentExecutor != null) {, +			this.concurrentExecutor = concurrentExecutor;, +			if (managedExecutorService != null && managedExecutorService.isInstance(concurrentExecutor)) {, +				this.adaptedExecutor = new ManagedTaskExecutorAdapter(concurrentExecutor);, +			}, +			else {, +				this.adaptedExecutor = new TaskExecutorAdapter(concurrentExecutor);, +			}, +		}, +		else {, +			this.concurrentExecutor = Executors.newSingleThreadExecutor();, +	}, +, +	/**, +	 * TaskExecutorAdapter subclass that wraps all provided Runnables and Callables, +	 * with a JSR-236 ManagedTask, exposing a long-running hint based on, +	 * {@link SchedulingAwareRunnable} and an identity name based on the task's, +	 * {@code toString()} representation., +	 */, +	private static class ManagedTaskExecutorAdapter extends TaskExecutorAdapter {, +, +		public ManagedTaskExecutorAdapter(Executor concurrentExecutor) {, +			super(concurrentExecutor);, +		}, +, +		@Override, +		public void execute(Runnable task) {, +			super.execute(ManagedTaskBuilder.buildManagedTask(task, task.toString()));, +		}, +, +		@Override, +		public Future<?> submit(Runnable task) {, +			return super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString()));, +		}, +, +		@Override, +		public <T> Future<T> submit(Callable<T> task) {, +			return super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString()));, +		}, +	}, +, +, +	/**, +	 * Delegate that wraps a given Runnable/Callable  with a JSR-236 ManagedTask,, +	 * exposing a long-running hint based on {@link SchedulingAwareRunnable}, +	 * and a given identity name., +	 */, +	protected static class ManagedTaskBuilder {, +, +		public static Runnable buildManagedTask(Runnable task, String identityName) {, +			Map<String, String> properties = new HashMap<String, String>(2);, +			if (task instanceof SchedulingAwareRunnable) {, +				properties.put(ManagedTask.LONGRUNNING_HINT,, +						Boolean.toString(((SchedulingAwareRunnable) task).isLongLived()));, +			}, +			properties.put(ManagedTask.IDENTITY_NAME, identityName);, +			return ManagedExecutors.managedTask(task, properties, null);, +		}, +, +		public static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {, +			Map<String, String> properties = new HashMap<String, String>(1);, +			properties.put(ManagedTask.IDENTITY_NAME, identityName);, +			return ManagedExecutors.managedTask(task, properties, null);, +		}, +	}, +, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ConcurrentTaskExecutor.java, + * Copyright 2002-2013 the original author or authors., +import java.util.HashMap;]