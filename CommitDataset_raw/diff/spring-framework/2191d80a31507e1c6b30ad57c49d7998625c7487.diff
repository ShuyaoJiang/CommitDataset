[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java, +	private final Map<String, Principal> stompAuthentications = new ConcurrentHashMap<String, Principal>();, +, +				headerAccessor.setUser(getUser(session));, +				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand());, +				if (isConnect) {, +					if (sent) {, +						if (isConnect) {, +							Principal user = headerAccessor.getUser();, +							if (user != null && user != session.getPrincipal()) {, +								this.stompAuthentications.put(session.getId(), user);, +							}, +						}, +						if (this.eventPublisher != null) {, +							if (isConnect) {, +								publishEvent(new SessionConnectEvent(this, message, getUser(session)));, +								publishEvent(new SessionSubscribeEvent(this, message, getUser(session)));, +								publishEvent(new SessionUnsubscribeEvent(this, message, getUser(session)));, +							}, +	private Principal getUser(WebSocketSession session) {, +		Principal user = this.stompAuthentications.get(session.getId());, +		return user != null ? user : session.getPrincipal();, +	}, +, +					Principal user = getUser(session);, +		Principal principal = getUser(session);, +				Principal user = getUser(session);, +			this.stompAuthentications.remove(session.getId());, +		headerAccessor.setUser(getUser(session));, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java, +	private final Map<String, Principal> stompAuthentications = new ConcurrentHashMap<String, Principal>();, +, +				headerAccessor.setUser(getUser(session));, +				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand());, +				if (isConnect) {, +					if (sent) {, +						if (isConnect) {, +							Principal user = headerAccessor.getUser();, +							if (user != null && user != session.getPrincipal()) {, +								this.stompAuthentications.put(session.getId(), user);, +							}, +						}, +						if (this.eventPublisher != null) {, +							if (isConnect) {, +								publishEvent(new SessionConnectEvent(this, message, getUser(session)));, +								publishEvent(new SessionSubscribeEvent(this, message, getUser(session)));, +								publishEvent(new SessionUnsubscribeEvent(this, message, getUser(session)));, +							}, +	private Principal getUser(WebSocketSession session) {, +		Principal user = this.stompAuthentications.get(session.getId());, +		return user != null ? user : session.getPrincipal();, +	}, +, +					Principal user = getUser(session);, +		Principal principal = getUser(session);, +				Principal user = getUser(session);, +			this.stompAuthentications.remove(session.getId());, +		headerAccessor.setUser(getUser(session));, +++ b/spring-websocket/src/test/java/org/springframework/web/socket/messaging/StompSubProtocolHandlerTests.java, +import java.security.Principal;, +import org.springframework.messaging.MessageHandler;, +import org.springframework.messaging.MessagingException;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertArrayEquals;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.reset;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.verifyNoMoreInteractions;, +import static org.mockito.Mockito.verifyZeroInteractions;, +import static org.mockito.Mockito.when;, +	private static final byte[] EMPTY_PAYLOAD = new byte[0];, +		when(sockJsSession.getId()).thenReturn("s1");, +		verify(sockJsSession).getId();, +		when(sockJsSession.getId()).thenReturn("s1");, +		verify(sockJsSession).getId();, +	@Test // SPR-14690, +	public void handleMessageFromClientWithTokenAuthentication() {, +		ExecutorSubscribableChannel channel = new ExecutorSubscribableChannel();, +		channel.addInterceptor(new AuthenticationInterceptor("__pete__@gmail.com"));, +		channel.addInterceptor(new ImmutableMessageChannelInterceptor());, +, +		TestMessageHandler messageHandler = new TestMessageHandler();, +		channel.subscribe(messageHandler);, +, +		StompSubProtocolHandler handler = new StompSubProtocolHandler();, +		handler.afterSessionStarted(this.session, channel);, +, +		TextMessage wsMessage = StompTextMessageBuilder.create(StompCommand.CONNECT).build();, +		handler.handleMessageFromClient(this.session, wsMessage, channel);, +, +		assertEquals(1, messageHandler.getMessages().size());, +		Message<?> message = messageHandler.getMessages().get(0);, +		Principal user = SimpMessageHeaderAccessor.getUser(message.getHeaders());, +		assertNotNull(user);]