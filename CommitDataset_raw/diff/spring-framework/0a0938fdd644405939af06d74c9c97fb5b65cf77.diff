[+++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;, +	private ModelAndViewResolver[] customModelAndViewResolvers;, +, +	 * Set a custom WebArgumentResolvers to use for special method parameter types., +	 * Such a custom WebArgumentResolver will kick in first, having a chance to, +	 * Set one or more custom WebArgumentResolvers to use for special method, +	 * parameter types. Any such custom WebArgumentResolver will kick in first,, +	/**, +	 * Set a custom ModelAndViewResolvers to use for special method return types. Such a custom ModelAndViewResolver will kick, +	 * in first, having a chance to resolve an return value before the standard ModelAndView handling kicks in., +	 */, +	public void setCustomModelAndViewResolver(ModelAndViewResolver customModelAndViewResolver) {, +		this.customModelAndViewResolvers = new ModelAndViewResolver[]{customModelAndViewResolver};, +	}, +, +	/**, +	 * Set one or more custom ModelAndViewResolvers to use for special method return types. Any such custom ModelAndViewResolver, +	 * will kick in first, having a chance to resolve an return value before the standard ModelAndView handling kicks in., +	 */, +	public void setCustomModelAndViewResolvers(ModelAndViewResolver[] customModelAndViewResolvers) {, +		this.customModelAndViewResolvers = customModelAndViewResolvers;, +	}, +, +		ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel,, +				webRequest);, +		public ModelAndView getModelAndView(Method handlerMethod, Class handlerType, Object returnValue, ExtendedModelMap implicitModel,, +				PortletWebRequest webRequest) {, +			// Invoke custom resolvers if present..., +			if (customModelAndViewResolvers != null) {, +				for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {, +					org.springframework.web.servlet.ModelAndView smav = mavResolver, +							.resolveModelAndView(handlerMethod, handlerType, returnValue, implicitModel, webRequest);, +					if (smav != ModelAndViewResolver.UNRESOLVED) {, +						return (smav.isReference() ?, +								new ModelAndView(smav.getViewName(), smav.getModelMap()) :, +								new ModelAndView(smav.getView(), smav.getModelMap()));, +					}, +				}, +			}, +++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;, +	private ModelAndViewResolver[] customModelAndViewResolvers;, +, +	 * Set a custom WebArgumentResolvers to use for special method parameter types., +	 * Such a custom WebArgumentResolver will kick in first, having a chance to, +	 * Set one or more custom WebArgumentResolvers to use for special method, +	 * parameter types. Any such custom WebArgumentResolver will kick in first,, +	/**, +	 * Set a custom ModelAndViewResolvers to use for special method return types. Such a custom ModelAndViewResolver will kick, +	 * in first, having a chance to resolve an return value before the standard ModelAndView handling kicks in., +	 */, +	public void setCustomModelAndViewResolver(ModelAndViewResolver customModelAndViewResolver) {, +		this.customModelAndViewResolvers = new ModelAndViewResolver[]{customModelAndViewResolver};, +	}, +, +	/**, +	 * Set one or more custom ModelAndViewResolvers to use for special method return types. Any such custom ModelAndViewResolver, +	 * will kick in first, having a chance to resolve an return value before the standard ModelAndView handling kicks in., +	 */, +	public void setCustomModelAndViewResolvers(ModelAndViewResolver[] customModelAndViewResolvers) {, +		this.customModelAndViewResolvers = customModelAndViewResolvers;, +	}, +, +		ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel,, +				webRequest);, +		public ModelAndView getModelAndView(Method handlerMethod, Class handlerType, Object returnValue, ExtendedModelMap implicitModel,, +				PortletWebRequest webRequest) {, +			// Invoke custom resolvers if present..., +			if (customModelAndViewResolvers != null) {, +				for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {, +					org.springframework.web.servlet.ModelAndView smav = mavResolver, +							.resolveModelAndView(handlerMethod, handlerType, returnValue, implicitModel, webRequest);, +					if (smav != ModelAndViewResolver.UNRESOLVED) {, +						return (smav.isReference() ?, +								new ModelAndView(smav.getViewName(), smav.getModelMap()) :, +								new ModelAndView(smav.getView(), smav.getModelMap()));, +					}, +				}, +			}, +++ b/org.springframework.web.portlet/src/test/java/org/springframework/web/portlet/mvc/annotation/PortletAnnotationControllerTests.java, + * Copyright 2002-2009 the original author or authors., +import java.lang.reflect.Method;, +import javax.servlet.http.HttpServletRequest;, +import javax.servlet.http.HttpServletResponse;, +import org.springframework.web.servlet.View;, +import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;, +	public void testMavResolver() throws Exception {, +		@SuppressWarnings("serial") DispatcherPortlet portlet = new DispatcherPortlet() {, +			@Override, +			protected ApplicationContext createPortletApplicationContext(ApplicationContext parent) throws BeansException {, +				GenericWebApplicationContext wac = new GenericWebApplicationContext();, +				wac.registerBeanDefinition("controller",, +						new RootBeanDefinition(ModelAndViewResolverController.class));, +				RootBeanDefinition adapterDef = new RootBeanDefinition(AnnotationMethodHandlerAdapter.class);, +				adapterDef.getPropertyValues(), +						.addPropertyValue("customModelAndViewResolver", new MyModelAndViewResolver());, +				wac.registerBeanDefinition("handlerAdapter", adapterDef);, +				wac.refresh();, +				return wac;]