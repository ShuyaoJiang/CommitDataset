[+++ b/spring-web/src/main/java/org/springframework/web/context/request/async/AsyncExecutionChain.java, +	public void startDeferredResultProcessing(final DeferredResult<?> deferredResult) {, +		this.asyncWebRequest.setTimeoutHandler(deferredResult.getTimeoutHandler());, +++ b/spring-web/src/main/java/org/springframework/web/context/request/async/AsyncExecutionChain.java, +	public void startDeferredResultProcessing(final DeferredResult<?> deferredResult) {, +		this.asyncWebRequest.setTimeoutHandler(deferredResult.getTimeoutHandler());, +++ b/spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResult.java, +public final class DeferredResult<V> {, +	private V result;, +	private final V timeoutValue;, +	private final boolean timeoutValueSet;, +, +	private boolean timeoutValueUsed;, +, +	private final CountDownLatch initializationLatch = new CountDownLatch(1);, +, +	private final ReentrantLock setLock = new ReentrantLock();, +		this.timeoutValue = null;, +		this.timeoutValueSet = false;, +	 * Create a new instance also providing a default value to set if a timeout, +	 * occurs before {@link #set(Object)} is called., +	public DeferredResult(V timeoutValue) {, +		this.timeoutValue = timeoutValue;, +		this.timeoutValueSet = true;, +	 * Complete async processing with the given value. If the DeferredResult is, +	 * not fully initialized yet, this method will block and wait for that to, +	public void set(V value) throws StaleAsyncWebRequestException {, +		if (this.setLock.tryLock() && (!this.timeoutValueUsed)) {, +				handle(value);, +				this.setLock.unlock();, +			// A timeout is in progress or has already occurred, +			throw new StaleAsyncWebRequestException("Async request timed out");, +	 * An alternative to {@link #set(Object)} that absorbs a potential, +	public boolean trySet(V result) throws StaleAsyncWebRequestException {, +	private void handle(V result) throws StaleAsyncWebRequestException {, +		this.timeoutValueUsed = (this.timeoutValueSet && (this.result == this.timeoutValue));, +			this.initializationLatch.await(10, TimeUnit.SECONDS);, +	/**, +	 * Return a handler to use to complete processing using the default timeout value, +	 * provided via {@link #DeferredResult(Object)} or {@code null} if no timeout, +	 * value was provided., +	 */, +	Runnable getTimeoutHandler() {, +		if (!this.timeoutValueSet) {, +			return null;, +		}, +		return new Runnable() {, +			public void run() { useTimeoutValue(); }, +		};, +	}, +, +	private void useTimeoutValue() {, +		this.setLock.lock();, +		try {, +			if (this.result == null) {, +				handle(this.timeoutValue);, +				this.timeoutValueUsed = true;, +			}, +		} finally {, +			this.setLock.unlock();, +		}, +	}, +, +		this.initializationLatch.countDown();, +++ b/spring-web/src/main/java/org/springframework/web/context/request/async/AsyncExecutionChain.java, +	public void startDeferredResultProcessing(final DeferredResult<?> deferredResult) {, +		this.asyncWebRequest.setTimeoutHandler(deferredResult.getTimeoutHandler());, +++ b/spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResult.java, +public final class DeferredResult<V> {, +	private V result;, +	private final V timeoutValue;, +	private final boolean timeoutValueSet;, +, +	private boolean timeoutValueUsed;, +, +	private final CountDownLatch initializationLatch = new CountDownLatch(1);, +, +	private final ReentrantLock setLock = new ReentrantLock();, +		this.timeoutValue = null;, +		this.timeoutValueSet = false;, +	 * Create a new instance also providing a default value to set if a timeout, +	 * occurs before {@link #set(Object)} is called., +	public DeferredResult(V timeoutValue) {, +		this.timeoutValue = timeoutValue;, +		this.timeoutValueSet = true;, +	 * Complete async processing with the given value. If the DeferredResult is, +	 * not fully initialized yet, this method will block and wait for that to, +	public void set(V value) throws StaleAsyncWebRequestException {, +		if (this.setLock.tryLock() && (!this.timeoutValueUsed)) {, +				handle(value);, +				this.setLock.unlock();, +			// A timeout is in progress or has already occurred, +			throw new StaleAsyncWebRequestException("Async request timed out");, +	 * An alternative to {@link #set(Object)} that absorbs a potential, +	public boolean trySet(V result) throws StaleAsyncWebRequestException {, +	private void handle(V result) throws StaleAsyncWebRequestException {, +		this.timeoutValueUsed = (this.timeoutValueSet && (this.result == this.timeoutValue));, +			this.initializationLatch.await(10, TimeUnit.SECONDS);, +	/**, +	 * Return a handler to use to complete processing using the default timeout value]