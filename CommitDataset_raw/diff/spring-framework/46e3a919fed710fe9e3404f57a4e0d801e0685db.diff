[+++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +			// Common cases, +			if (target == classLoader || target == null) {, +			if (classLoader == null) {, +			// Check for match in ancestors -> positive, +			ClassLoader current = classLoader;, +			while (current != null) {, +				current = current.getParent();, +				if (current == target) {, +			// Check for match in children -> negative, +			while (target != null) {, +				target = target.getParent();, +				if (target == classLoader) {, +					return false;, +				}, +			}, +		}, +		catch (SecurityException ex) {, +			// Fall through to Class reference comparison below, +		}, +, +		try {, +			// Fallback for ClassLoaders without parent/child relationship:, +			// safe if same Class can be loaded from given ClassLoader, +			return (clazz == forName(clazz.getName(), classLoader));, +		}, +		catch (ClassNotFoundException ex) {, +			return false;, +		}, +	}, +++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +			// Common cases, +			if (target == classLoader || target == null) {, +			if (classLoader == null) {, +			// Check for match in ancestors -> positive, +			ClassLoader current = classLoader;, +			while (current != null) {, +				current = current.getParent();, +				if (current == target) {, +			// Check for match in children -> negative, +			while (target != null) {, +				target = target.getParent();, +				if (target == classLoader) {, +					return false;, +				}, +			}, +		}, +		catch (SecurityException ex) {, +			// Fall through to Class reference comparison below, +		}, +, +		try {, +			// Fallback for ClassLoaders without parent/child relationship:, +			// safe if same Class can be loaded from given ClassLoader, +			return (clazz == forName(clazz.getName(), classLoader));, +		}, +		catch (ClassNotFoundException ex) {, +			return false;, +		}, +	}, +++ b/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java, +import java.io.Externalizable;, +, +	public void clearStatics() {, +, +	public void testIsPresent() {, +	public void testIsCacheSafe() {, +		ClassLoader childLoader1 = new ClassLoader(classLoader) {};, +		ClassLoader childLoader2 = new ClassLoader(classLoader) {};, +		ClassLoader childLoader3 = new ClassLoader(classLoader) {, +			@Override, +			public Class<?> loadClass(String name) throws ClassNotFoundException {, +				return childLoader1.loadClass(name);, +			}, +		};, +		Class<?> composite = ClassUtils.createCompositeInterface(, +				new Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);, +, +		assertTrue(ClassUtils.isCacheSafe(String.class, null));, +		assertTrue(ClassUtils.isCacheSafe(String.class, classLoader));, +		assertTrue(ClassUtils.isCacheSafe(String.class, childLoader1));, +		assertTrue(ClassUtils.isCacheSafe(String.class, childLoader2));, +		assertTrue(ClassUtils.isCacheSafe(String.class, childLoader3));, +		assertFalse(ClassUtils.isCacheSafe(InnerClass.class, null));, +		assertTrue(ClassUtils.isCacheSafe(InnerClass.class, classLoader));, +		assertTrue(ClassUtils.isCacheSafe(InnerClass.class, childLoader1));, +		assertTrue(ClassUtils.isCacheSafe(InnerClass.class, childLoader2));, +		assertTrue(ClassUtils.isCacheSafe(InnerClass.class, childLoader3));, +		assertFalse(ClassUtils.isCacheSafe(composite, null));, +		assertFalse(ClassUtils.isCacheSafe(composite, classLoader));, +		assertTrue(ClassUtils.isCacheSafe(composite, childLoader1));, +		assertFalse(ClassUtils.isCacheSafe(composite, childLoader2));, +		assertTrue(ClassUtils.isCacheSafe(composite, childLoader3));, +	}, +, +	@Test, +	public void testHasMethod() {, +	public void testGetMethodIfAvailable() {, +		assertEquals("java/lang/reflect", result);, +		List<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));]