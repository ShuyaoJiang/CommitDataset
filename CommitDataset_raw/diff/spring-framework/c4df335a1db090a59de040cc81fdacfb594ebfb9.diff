[+++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +			if (superclass != null && superclass != Object.class) {, +	 * @param targetClass the target class for the current invocation, +	 * (may be {@code null} or may not even implement the method), +	 * {@code targetClass} does not implement it, +	 * @see #getInterfaceMethodIfPossible, +	 * Determine a corresponding interface method for the given method handle, if possible., +	 * <p>This is particularly useful for arriving at a public exported type on Jigsaw, +	 * which can be reflectively invoked without an illegal access warning., +	 * @param method the method to be invoked, potentially from an implementation class, +	 * @return the corresponding interface method, or the original method if none found, +	 * @since 5.1, +	 * @see #getMostSpecificMethod, +	 */, +	public static Method getInterfaceMethodIfPossible(Method method) {, +		if (Modifier.isPublic(method.getModifiers()) && !method.getDeclaringClass().isInterface()) {, +			Class<?> current = method.getDeclaringClass();, +			while (current != null && current != Object.class) {, +				Class<?>[] ifcs = current.getInterfaces();, +				for (Class<?> ifc : ifcs) {, +					try {, +						return ifc.getMethod(method.getName(), method.getParameterTypes());, +					}, +					catch (NoSuchMethodException ex) {, +						// ignore, +					}, +				}, +				current = current.getSuperclass();, +			}, +		}, +		return method;, +	}, +, +	/**, +++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +			if (superclass != null && superclass != Object.class) {, +	 * @param targetClass the target class for the current invocation, +	 * (may be {@code null} or may not even implement the method), +	 * {@code targetClass} does not implement it, +	 * @see #getInterfaceMethodIfPossible, +	 * Determine a corresponding interface method for the given method handle, if possible., +	 * <p>This is particularly useful for arriving at a public exported type on Jigsaw, +	 * which can be reflectively invoked without an illegal access warning., +	 * @param method the method to be invoked, potentially from an implementation class, +	 * @return the corresponding interface method, or the original method if none found, +	 * @since 5.1, +	 * @see #getMostSpecificMethod, +	 */, +	public static Method getInterfaceMethodIfPossible(Method method) {, +		if (Modifier.isPublic(method.getModifiers()) && !method.getDeclaringClass().isInterface()) {, +			Class<?> current = method.getDeclaringClass();, +			while (current != null && current != Object.class) {, +				Class<?>[] ifcs = current.getInterfaces();, +				for (Class<?> ifc : ifcs) {, +					try {, +						return ifc.getMethod(method.getName(), method.getParameterTypes());, +					}, +					catch (NoSuchMethodException ex) {, +						// ignore, +					}, +				}, +				current = current.getSuperclass();, +			}, +		}, +		return method;, +	}, +, +	/**, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		if (methodResolvers.size() != 1 || !(methodResolvers.get(0) instanceof ReflectiveMethodResolver)) {, +++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +			if (superclass != null && superclass != Object.class) {, +	 * @param targetClass the target class for the current invocation, +	 * (may be {@code null} or may not even implement the method), +	 * {@code targetClass} does not implement it, +	 * @see #getInterfaceMethodIfPossible, +	 * Determine a corresponding interface method for the given method handle, if possible., +	 * <p>This is particularly useful for arriving at a public exported type on Jigsaw, +	 * which can be reflectively invoked without an illegal access warning., +	 * @param method the method to be invoked, potentially from an implementation class, +	 * @return the corresponding interface method, or the original method if none found, +	 * @since 5.1, +	 * @see #getMostSpecificMethod, +	 */, +	public static Method getInterfaceMethodIfPossible(Method method) {, +		if (Modifier.isPublic(method.getModifiers()) && !method.getDeclaringClass().isInterface()) {, +			Class<?> current = method.getDeclaringClass();, +			while (current != null && current != Object.class) {, +				Class<?>[] ifcs = current.getInterfaces();, +				for (Class<?> ifc : ifcs) {, +					try {, +						return ifc.getMethod(method.getName(), method.getParameterTypes());, +					}, +					catch (NoSuchMethodException ex) {, +						// ignore, +					}, +				}, +				current = current.getSuperclass();, +			}, +		}]