[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java, +import java.io.IOException;, +import java.util.concurrent.locks.ReentrantLock;, +	/**, +	 * Sessions connected to this handler use a sub-protocol. Hence we expect to, +	 * receive some client messages. If we don't receive any within a minute, the, +	 * connection isn't doing well (proxy issue, slow network?) and can be closed., +	 * @see #checkSessions(), +	 */, +	private final int TIME_TO_FIRST_MESSAGE = 60 * 1000;, +, +, +, +	private final Map<String, WebSocketSessionHolder> sessions = new ConcurrentHashMap<String, WebSocketSessionHolder>();, +	private volatile long lastSessionCheckTime = System.currentTimeMillis();, +, +	private final ReentrantLock sessionCheckLock = new ReentrantLock();, +, +			for (WebSocketSessionHolder holder : this.sessions.values()) {, +					holder.getSession().close(CloseStatus.GOING_AWAY);, +					logger.error("Failed to close '" + holder.getSession() + "': " + t.getMessage());, +		this.sessions.put(session.getId(), new WebSocketSessionHolder(session));, +			logger.debug("Started session " + session.getId() + ", number of sessions=" + this.sessions.size());, +		SubProtocolHandler protocolHandler = findProtocolHandler(session);, +		protocolHandler.handleMessageFromClient(session, message, this.clientInboundChannel);, +		WebSocketSessionHolder holder = this.sessions.get(session.getId());, +		if (holder != null) {, +			holder.setHasHandledMessages();, +		}, +		else {, +			// Should never happen, +			throw new IllegalStateException("Session not found: " + session);, +		}, +		checkSessions();, +		WebSocketSessionHolder holder = this.sessions.get(sessionId);, +		if (holder == null) {, +		WebSocketSession session = holder.getSession();, +				logger.error("Terminating '" + session + "'", ex);, +				logger.error("Exception terminating '" + sessionId + "'", secondException);, +			logger.error("Failed to send message to client " + message + " in " + session, e);, +	/**, +	 * Periodically check sessions to ensure they have received at least one, +	 * message or otherwise close them., +	 */, +	private void checkSessions() throws IOException {, +		long currentTime = System.currentTimeMillis();, +		if (!isRunning() && currentTime - this.lastSessionCheckTime < TIME_TO_FIRST_MESSAGE) {, +			return;, +		}, +		try {, +			if (this.sessionCheckLock.tryLock()) {, +				for (WebSocketSessionHolder holder : this.sessions.values()) {, +					if (holder.hasHandledMessages()) {, +						continue;, +					}, +					long timeSinceCreated = currentTime - holder.getCreateTime();, +					if (holder.hasHandledMessages() || timeSinceCreated < TIME_TO_FIRST_MESSAGE) {, +						continue;, +					}, +					WebSocketSession session = holder.getSession();, +					if (logger.isErrorEnabled()) {, +						logger.error("No messages received after " + timeSinceCreated + " ms. Closing " + holder);, +					}, +					try {, +						session.close(CloseStatus.PROTOCOL_ERROR);, +					}, +					catch (Throwable t) {, +						logger.error("Failed to close " + session, t);, +					}, +				}, +			}, +		}, +		finally {, +			this.sessionCheckLock.unlock();, +		}, +	}, +, +, +	private static class WebSocketSessionHolder {, +, +		private final WebSocketSession session;, +, +		private final long createTime = System.currentTimeMillis();, +, +		private volatile boolean handledMessages;, +, +, +		private WebSocketSessionHolder(WebSocketSession session) {, +			this.session = session;, +		}, +, +		public WebSocketSession getSession() {, +			return this.session;, +		}, +, +		public long getCreateTime() {, +			return this.createTime;, +		}, +, +		public void setHasHandledMessages() {]