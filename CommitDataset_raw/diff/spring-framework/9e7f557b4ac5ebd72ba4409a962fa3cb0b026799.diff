[+++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, + * Copyright 2002-2019 the original author or authors., +		while (true) {, +				if (Instant.now().isAfter(start.plus(duration))) {, +					throw ex;, +				}, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, + * Copyright 2002-2019 the original author or authors., +		while (true) {, +				if (Instant.now().isAfter(start.plus(duration))) {, +					throw ex;, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractMethodMessageHandler.java, +				HandlerMethod m1 = bestMatch.handlerMethod;, +				HandlerMethod m2 = secondBestMatch.handlerMethod;, +						destination + "': {" + m1.getShortLogMessage() + ", " + m2.getShortLogMessage() + "}");, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, + * Copyright 2002-2019 the original author or authors., +		while (true) {, +				if (Instant.now().isAfter(start.plus(duration))) {, +					throw ex;, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractMethodMessageHandler.java, +				HandlerMethod m1 = bestMatch.handlerMethod;, +				HandlerMethod m2 = secondBestMatch.handlerMethod;, +						destination + "': {" + m1.getShortLogMessage() + ", " + m2.getShortLogMessage() + "}");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +					payloadMono.map(this::retainDataAndReleasePayload), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::retainDataAndReleasePayload).concatMap(dataBuffer ->, +		private DataBuffer retainDataAndReleasePayload(Payload payload) {, +			return PayloadUtils.retainDataAndReleasePayload(payload, strategies.dataBufferFactory());, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, + * Copyright 2002-2019 the original author or authors., +		while (true) {, +				if (Instant.now().isAfter(start.plus(duration))) {, +					throw ex;, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractMethodMessageHandler.java, +				HandlerMethod m1 = bestMatch.handlerMethod;, +				HandlerMethod m2 = secondBestMatch.handlerMethod;, +						destination + "': {" + m1.getShortLogMessage() + ", " + m2.getShortLogMessage() + "}");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +					payloadMono.map(this::retainDataAndReleasePayload), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::retainDataAndReleasePayload).concatMap(dataBuffer ->, +		private DataBuffer retainDataAndReleasePayload(Payload payload) {, +			return PayloadUtils.retainDataAndReleasePayload(payload, strategies.dataBufferFactory());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketStrategies.java, +import org.springframework.core.io.buffer.DefaultDataBufferFactory;, +import org.springframework.util.Assert;, +		private ReactiveAdapterRegistry adapterRegistry = ReactiveAdapterRegistry.getSharedInstance();, +		private DataBufferFactory dataBufferFactory;, +			Assert.notNull(registry, "ReactiveAdapterRegistry is required");, +			this.dataBufferFactory = bufferFactory;, +			return new DefaultRSocketStrategies(this.encoders, this.decoders, this.adapterRegistry,, +					this.dataBufferFactory != null ? this.dataBufferFactory : new DefaultDataBufferFactory());, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/AbstractDataBufferAllocatingTestCase.java, + * Copyright 2002-2019 the original author or authors., +		while (true) {, +				if (Instant.now().isAfter(start.plus(duration))) {, +					throw ex;, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractMethodMessageHandler.java, +				HandlerMethod m1 = bestMatch.handlerMethod;, +				HandlerMethod m2 = secondBestMatch.handlerMethod;, +						destination + "': {" + m1.getShortLogMessage() + ", " + m2.getShortLogMessage() + "}");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +					payloadMono.map(this::retainDataAndReleasePayload), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::retainDataAndReleasePayload).concatMap(dataBuffer ->, +		private DataBuffer retainDataAndReleasePayload(Payload payload) {, +			return PayloadUtils.retainDataAndReleasePayload(payload, strategies.dataBufferFactory());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketStrategies.java, +import org.springframework.core.io.buffer.DefaultDataBufferFactory;, +import org.springframework.util.Assert;, +		private ReactiveAdapterRegistry adapterRegistry = ReactiveAdapterRegistry.getSharedInstance();, +		private DataBufferFactory dataBufferFactory;, +			Assert.notNull(registry, "ReactiveAdapterRegistry is required");, +			this.dataBufferFactory = bufferFactory;, +			return new DefaultRSocketStrategies(this.encoders, this.decoders, this.adapterRegistry,, +					this.dataBufferFactory != null ? this.dataBufferFactory : new DefaultDataBufferFactory());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingRSocket.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.springframework.core.io.buffer.NettyDataBuffer;, +		// frameDecoder does not apply to connectionSetupPayload, +		// so retain here since handle expects it.., +		payload.retain();, +		String destination = getDestination(payload);, +		MessageHeaders headers = createHeaders(destination, null);, +		DataBuffer dataBuffer = retainDataAndReleasePayload(payload);, +		int refCount = refCount(dataBuffer);, +		Message<?> message = MessageBuilder.createMessage(dataBuffer, headers);, +		return Mono.defer(() -> this.handler.apply(message)), +				.doFinally(s -> {, +					if (refCount(dataBuffer) == refCount) {, +						DataBufferUtils.release(dataBuffer);, +					}, +				});, +	}, +	private int refCount(DataBuffer dataBuffer) {, +		return dataBuffer instanceof NettyDataBuffer ?, +				((NettyDataBuffer) dataBuffer).getNativeBuffer().refCnt() : 1;]