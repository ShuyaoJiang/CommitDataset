[+++ b/spring-core/src/main/java/org/apache/commons/logging/LogFactory.java, +import java.util.logging.LogRecord;, + * providing just the common {@link Log} lookup methods. This is inspired, + * by the JCL-over-SLF4J bridge and should be source as well as binary, + * compatible with all common use of the Commons Logging API (in particular:, + * with {@code LogFactory.getLog(Class/String)} field initializers)., + * <p>This implementation does not support Commons Logging's original provider, + * detection. It rather only checks for the presence of the Log4j 2.x API, + * and the SLF4J 1.7 API in the Spring Framework classpath, falling back to, + * delegates to {@code java.util.logging} in such a scenario., + * infrastructure logging purposes in the core framework and in extensions.</b>, + * It also serves as a common bridge for third-party libraries using the, + * Commons Logging API, e.g. Apache HttpClient, Castor and HtmlUnit, bringing, + * them into the same consistent arrangement without any extra bridge jars., + *, + * <p><b>For logging need in application code, prefer direct use of Log4j 2.x, + * or SLF4J or {@code java.util.logging}.</b> Simply put Log4j 2.x or Logback, + * (or another SLF4J provider) onto your classpath, without any extra bridges,, + * and let the framework auto-adapt to your choice., +			// Try Log4j 2.x API, +		catch (ClassNotFoundException ex1) {, +				// Defensively use lazy-initializing delegate class here as well since the, +				// java.logging module is not present by default on JDK 9. We are requiring, +				// its presence if neither Log4j nor SLF4J is available; however, in the, +				// case of Log4j or SLF4J, we are trying to prevent early initialization, +				// of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly, +				// trying to parse the bytecode for all the cases of this switch clause., +				return JavaUtilDelegate.createLog(name);, +	private static class JavaUtilDelegate {, +, +		public static Log createLog(String name) {, +			return new JavaUtilLog(name);, +		}, +	}, +, +, +		public boolean isFatalEnabled() {, +			return logger.isEnabled(Level.FATAL, null, null);, +		public boolean isWarnEnabled() {, +			return logger.isEnabled(Level.WARN, null, null);, +		public boolean isDebugEnabled() {, +			return logger.isEnabled(Level.DEBUG, null, null);, +		}, +, +		@Override, +		public void error(Object message) {, +			logger.logIfEnabled(FQCN, Level.ERROR, null, message, null);, +		public void error(Object message, Throwable exception) {, +			logger.logIfEnabled(FQCN, Level.ERROR, null, message, exception);, +, +		@Override, +		public void info(Object message) {, +			logger.logIfEnabled(FQCN, Level.INFO, null, message, null);, +		}, +, +		@Override, +		public void info(Object message, Throwable exception) {, +			logger.logIfEnabled(FQCN, Level.INFO, null, message, exception);, +		}, +, +		@Override, +		public void debug(Object message) {, +			logger.logIfEnabled(FQCN, Level.DEBUG, null, message, null);, +		}, +, +		@Override, +		public void debug(Object message, Throwable exception) {, +			logger.logIfEnabled(FQCN, Level.DEBUG, null, message, exception);, +		}, +, +		@Override, +		public void trace(Object message) {, +			logger.logIfEnabled(FQCN, Level.TRACE, null, message, null);, +		}, +, +		@Override, +		public void trace(Object message, Throwable exception) {, +			logger.logIfEnabled(FQCN, Level.TRACE, null, message, exception);, +		}, +		public boolean isFatalEnabled() {, +			return isErrorEnabled();, +		public boolean isWarnEnabled() {, +			return this.logger.isWarnEnabled();, +		public boolean isDebugEnabled() {, +			return this.logger.isDebugEnabled();, +		}, +, +		public void fatal(Object message) {, +			error(message);, +		public void fatal(Object message, Throwable exception) {, +			error(message, exception);, +		public void warn(Object message) {, +			if (message instanceof String || this.logger.isWarnEnabled()) {, +				this.logger.warn(String.valueOf(message));, +			}, +		public void warn(Object message, Throwable exception) {, +			if (message instanceof String || this.logger.isWarnEnabled()) {, +				this.logger.warn(String.valueOf(message), exception);, +			}, +		public void debug(Object message) {]