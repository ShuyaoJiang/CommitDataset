[+++ b/org.springframework.aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.java, +		BeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + ".TARGET");, +		BeanDefinitionReaderUtils.registerBeanDefinition(, +				new BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);, +			proxyDefinition.setScope(targetDefinition.getScope());, +			proxyDefinition.setDecoratedDefinition(targetHolder);, +			proxyDefinition.getPropertyValues().add("target", targetHolder);, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.java, +		BeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + ".TARGET");, +		BeanDefinitionReaderUtils.registerBeanDefinition(, +				new BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);, +			proxyDefinition.setScope(targetDefinition.getScope());, +			proxyDefinition.setDecoratedDefinition(targetHolder);, +			proxyDefinition.getPropertyValues().add("target", targetHolder);, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +import org.springframework.beans.factory.config.BeanDefinitionHolder;, +			// Retrieve corresponding bean definition., +, +			// Check decorated bean definition, if any: We assume it'll be easier, +			// to determine the decorated bean's type than the proxy's type., +			BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();, +			if (dbd != null) {, +				RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);, +				Class targetClass = predictBeanType(dbd.getBeanName(), tbd, FactoryBean.class, typeToMatch);, +				if (targetClass != null && !FactoryBean.class.isAssignableFrom(targetClass)) {, +					return typeToMatch.isAssignableFrom(targetClass);, +				}, +			}, +, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.java, +		BeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + ".TARGET");, +		BeanDefinitionReaderUtils.registerBeanDefinition(, +				new BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);, +			proxyDefinition.setScope(targetDefinition.getScope());, +			proxyDefinition.setDecoratedDefinition(targetHolder);, +			proxyDefinition.getPropertyValues().add("target", targetHolder);, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +import org.springframework.beans.factory.config.BeanDefinitionHolder;, +			// Retrieve corresponding bean definition., +, +			// Check decorated bean definition, if any: We assume it'll be easier, +			// to determine the decorated bean's type than the proxy's type., +			BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();, +			if (dbd != null) {, +				RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);, +				Class targetClass = predictBeanType(dbd.getBeanName(), tbd, FactoryBean.class, typeToMatch);, +				if (targetClass != null && !FactoryBean.class.isAssignableFrom(targetClass)) {, +					return typeToMatch.isAssignableFrom(targetClass);, +				}, +			}, +, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java, +import org.springframework.beans.factory.config.BeanDefinitionHolder;, +	private BeanDefinitionHolder decoratedDefinition;, +, +			RootBeanDefinition originalRbd = (RootBeanDefinition) original;, +			this.decoratedDefinition = originalRbd.decoratedDefinition;, +			this.isFactoryMethodUnique = originalRbd.isFactoryMethodUnique;, +	public void setDecoratedDefinition(BeanDefinitionHolder decoratedDefinition) {, +		this.decoratedDefinition = decoratedDefinition;, +	}, +, +	public BeanDefinitionHolder getDecoratedDefinition() {, +		return this.decoratedDefinition;, +	}, +, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.java, +		BeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + ".TARGET");, +		BeanDefinitionReaderUtils.registerBeanDefinition(, +				new BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);, +			proxyDefinition.setScope(targetDefinition.getScope());, +			proxyDefinition.setDecoratedDefinition(targetHolder);, +			proxyDefinition.getPropertyValues().add("target", targetHolder);, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +import org.springframework.beans.factory.config.BeanDefinitionHolder;, +			// Retrieve corresponding bean definition., +, +			// Check decorated bean definition, if any: We assume it'll be easier, +			// to determine the decorated bean's type than the proxy's type., +			BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();, +			if (dbd != null) {, +				RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);, +				Class targetClass = predictBeanType(dbd.getBeanName(), tbd, FactoryBean.class, typeToMatch);, +				if (targetClass != null && !FactoryBean.class.isAssignableFrom(targetClass)) {, +					return typeToMatch.isAssignableFrom(targetClass);, +				}, +			}, +, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java, +import org.springframework.beans.factory.config.BeanDefinitionHolder;, +	private BeanDefinitionHolder decoratedDefinition;, +, +			RootBeanDefinition originalRbd = (RootBeanDefinition) original;, +			this.decoratedDefinition = originalRbd.decoratedDefinition;, +			this.isFactoryMethodUnique = originalRbd.isFactoryMethodUnique;, +	public void setDecoratedDefinition(BeanDefinitionHolder decoratedDefinition) {, +		this.decoratedDefinition = decoratedDefinition;, +	}, +, +	public BeanDefinitionHolder getDecoratedDefinition() {]