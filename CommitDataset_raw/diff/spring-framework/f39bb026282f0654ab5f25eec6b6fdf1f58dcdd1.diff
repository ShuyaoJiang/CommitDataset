[+++ b/spring-beans-groovy/src/main/java/org/springframework/beans/factory/groovy/GroovyBeanDefinitionReader.java, +	 * @param closure the block or closure, +	public GroovyBeanDefinitionReader beans(Closure closure) {, +		return invokeBeanDefiningClosure(closure);, +			Class<?> beanClass = (args[0] instanceof Class ? (Class) args[0] : args[0].getClass());, +				Class<?> parameterType = callable.getParameterTypes()[0];, +		public Object value;, +++ b/spring-beans-groovy/src/main/java/org/springframework/beans/factory/groovy/GroovyBeanDefinitionReader.java, +	 * @param closure the block or closure, +	public GroovyBeanDefinitionReader beans(Closure closure) {, +		return invokeBeanDefiningClosure(closure);, +			Class<?> beanClass = (args[0] instanceof Class ? (Class) args[0] : args[0].getClass());, +				Class<?> parameterType = callable.getParameterTypes()[0];, +		public Object value;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, +, +	private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);, +	private static final Log logger = LogFactory.getLog(ConfigurationClassEnhancer.class);, +, +, +	 * Uses enhancer to generate a subclass of superclass,, +	 * ensuring that callbacks are registered for the new subclass., +		// Registering callbacks statically (as opposed to thread-local), +		// is critical for usage in an OSGi environment (SPR-5932)..., +, +, +	private static class DisposableBeanMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +			return candidateMethod.getName().equals("setBeanFactory") &&, +					candidateMethod.getParameterTypes().length == 1 &&, +					candidateMethod.getParameterTypes()[0].equals(BeanFactory.class) &&, +					BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +			Assert.state(beanFactory != null, "BeanFactory has not been injected into @Configuration class");, +			Assert.state(beanFactory instanceof ConfigurableBeanFactory, "Injected BeanFactory is not a ConfigurableBeanFactory");, +++ b/spring-beans-groovy/src/main/java/org/springframework/beans/factory/groovy/GroovyBeanDefinitionReader.java, +	 * @param closure the block or closure, +	public GroovyBeanDefinitionReader beans(Closure closure) {, +		return invokeBeanDefiningClosure(closure);, +			Class<?> beanClass = (args[0] instanceof Class ? (Class) args[0] : args[0].getClass());, +				Class<?> parameterType = callable.getParameterTypes()[0];, +		public Object value;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, +, +	private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);, +	private static final Log logger = LogFactory.getLog(ConfigurationClassEnhancer.class);, +, +, +	 * Uses enhancer to generate a subclass of superclass,, +	 * ensuring that callbacks are registered for the new subclass., +		// Registering callbacks statically (as opposed to thread-local), +		// is critical for usage in an OSGi environment (SPR-5932)..., +, +, +	private static class DisposableBeanMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +			return candidateMethod.getName().equals("setBeanFactory") &&, +					candidateMethod.getParameterTypes().length == 1 &&, +					candidateMethod.getParameterTypes()[0].equals(BeanFactory.class) &&, +					BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +			Assert.state(beanFactory != null, "BeanFactory has not been injected into @Configuration class");, +			Assert.state(beanFactory instanceof ConfigurableBeanFactory, "Injected BeanFactory is not a ConfigurableBeanFactory");, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AbstractAsyncConfiguration.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.util.CollectionUtils;, +, +, +				"@EnableAsync is not present on importing class " + importMetadata.getClassName());, +		if (CollectionUtils.isEmpty(configurers)) {, +			throw new IllegalStateException("Only one AsyncConfigurer may exist");, +++ b/spring-beans-groovy/src/main/java/org/springframework/beans/factory/groovy/GroovyBeanDefinitionReader.java, +	 * @param closure the block or closure, +	public GroovyBeanDefinitionReader beans(Closure closure) {, +		return invokeBeanDefiningClosure(closure);, +			Class<?> beanClass = (args[0] instanceof Class ? (Class) args[0] : args[0].getClass());, +				Class<?> parameterType = callable.getParameterTypes()[0];, +		public Object value;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, +, +	private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);, +	private static final Log logger = LogFactory.getLog(ConfigurationClassEnhancer.class);, +, +, +	 * Uses enhancer to generate a subclass of superclass,, +	 * ensuring that callbacks are registered for the new subclass., +		// Registering callbacks statically (as opposed to thread-local), +		// is critical for usage in an OSGi environment (SPR-5932)..., +, +, +	private static class DisposableBeanMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {, +			return candidateMethod.getName().equals("setBeanFactory") &&, +					candidateMethod.getParameterTypes().length == 1 &&, +					candidateMethod.getParameterTypes()[0].equals(BeanFactory.class) &&, +					BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +				public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {]