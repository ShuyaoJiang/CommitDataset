[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, +import java.lang.reflect.Proxy;, +			// Try to build the most specific interface possible for inherited methods to be, +			// considered for sub-interface matches as well, in particular for proxy classes., +			// Note: AspectJ is only going to take Method.getDeclaringClass() into account., +						if (targetMethod != originalMethod && (shadowMatch == null ||, +								(shadowMatch.neverMatches() && Proxy.isProxyClass(targetMethod.getDeclaringClass())))) {, +							// Fall back to the plain original method in case of no resolvable match or a, +							// negative match on a proxy class (which doesn't carry any annotations on its, +							// redeclared methods)., +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, +import java.lang.reflect.Proxy;, +			// Try to build the most specific interface possible for inherited methods to be, +			// considered for sub-interface matches as well, in particular for proxy classes., +			// Note: AspectJ is only going to take Method.getDeclaringClass() into account., +						if (targetMethod != originalMethod && (shadowMatch == null ||, +								(shadowMatch.neverMatches() && Proxy.isProxyClass(targetMethod.getDeclaringClass())))) {, +							// Fall back to the plain original method in case of no resolvable match or a, +							// negative match on a proxy class (which doesn't carry any annotations on its, +							// redeclared methods)., +++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.java, +import org.springframework.aop.framework.ProxyFactory;, +	public void testMatchVarargs() throws Exception {, +	public void testMatchAnnotationOnClassWithAtWithin() throws Exception {, +	public void testMatchAnnotationOnClassWithoutBinding() throws Exception {, +	public void testMatchAnnotationOnClassWithSubpackageWildcard() throws Exception {, +	public void testMatchAnnotationOnClassWithExactPackageWildcard() throws Exception {, +	private AspectJExpressionPointcut testMatchAnnotationOnClass(String expression) throws Exception {, +	public void testAnnotationOnMethodWithFQN() throws Exception {, +	public void testAnnotationOnCglibProxyMethod() throws Exception {, +		String expression = "@annotation(test.annotation.transaction.Tx)";, +		AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut();, +		ajexp.setExpression(expression);, +, +		ProxyFactory factory = new ProxyFactory(new BeanA());, +		factory.setProxyTargetClass(true);, +		BeanA proxy = (BeanA) factory.getProxy();, +		assertTrue(ajexp.matches(BeanA.class.getMethod("getAge"), proxy.getClass()));, +	}, +, +	@Test, +	public void testAnnotationOnDynamicProxyMethod() throws Exception {, +		String expression = "@annotation(test.annotation.transaction.Tx)";, +		AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut();, +		ajexp.setExpression(expression);, +, +		ProxyFactory factory = new ProxyFactory(new BeanA());, +		factory.setProxyTargetClass(false);, +		IBeanA proxy = (IBeanA) factory.getProxy();, +		assertTrue(ajexp.matches(IBeanA.class.getMethod("getAge"), proxy.getClass()));, +	}, +, +	@Test, +	public void testAnnotationOnMethodWithWildcard() throws Exception {, +	public void testAnnotationOnMethodArgumentsWithFQN() throws Exception {, +	public void testAnnotationOnMethodArgumentsWithWildcards() throws Exception {, +	interface IBeanA {, +, +		@Tx, +		int getAge();, +	}, +, +, +	static class BeanA implements IBeanA {, +		@Override]