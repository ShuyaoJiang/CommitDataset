[+++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractEncoder.java, +	/**, +	 * Hint key to use with a {@link FlushingStrategy} value., +	 */, +	public static final String FLUSHING_STRATEGY_HINT = AbstractEncoder.class.getName() + ".flushingStrategy";, +, +	public enum FlushingStrategy { AUTO, AFTER_EACH_ELEMENT }, +, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractEncoder.java, +	/**, +	 * Hint key to use with a {@link FlushingStrategy} value., +	 */, +	public static final String FLUSHING_STRATEGY_HINT = AbstractEncoder.class.getName() + ".flushingStrategy";, +, +	public enum FlushingStrategy { AUTO, AFTER_EACH_ELEMENT }, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +import static org.springframework.core.codec.AbstractEncoder.FLUSHING_STRATEGY_HINT;, +import static org.springframework.core.codec.AbstractEncoder.FlushingStrategy.AFTER_EACH_ELEMENT;, +		return (hints.get(FLUSHING_STRATEGY_HINT) == AFTER_EACH_ELEMENT ?, +				outputMessage.writeAndFlushWith(body.map(Flux::just)) : outputMessage.writeWith(body));, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractEncoder.java, +	/**, +	 * Hint key to use with a {@link FlushingStrategy} value., +	 */, +	public static final String FLUSHING_STRATEGY_HINT = AbstractEncoder.class.getName() + ".flushingStrategy";, +, +	public enum FlushingStrategy { AUTO, AFTER_EACH_ELEMENT }, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +import static org.springframework.core.codec.AbstractEncoder.FLUSHING_STRATEGY_HINT;, +import static org.springframework.core.codec.AbstractEncoder.FlushingStrategy.AFTER_EACH_ELEMENT;, +		return (hints.get(FLUSHING_STRATEGY_HINT) == AFTER_EACH_ELEMENT ?, +				outputMessage.writeAndFlushWith(body.map(Flux::just)) : outputMessage.writeWith(body));, +++ b/spring-web/src/main/java/org/springframework/http/codec/Jackson2ServerHttpMessageWriter.java, +import org.reactivestreams.Publisher;, +import static org.springframework.core.codec.AbstractEncoder.FLUSHING_STRATEGY_HINT;, +import static org.springframework.core.codec.AbstractEncoder.FlushingStrategy.AFTER_EACH_ELEMENT;, +import reactor.core.publisher.Mono;, +import org.springframework.core.codec.AbstractEncoder;, +import org.springframework.http.ReactiveHttpOutputMessage;, +import org.springframework.http.server.reactive.ServerHttpResponse;, + * Jackson {@link ServerHttpMessageWriter} that resolves {@code @JsonView} annotated handler, + * method and deals with {@link AbstractEncoder#FLUSHING_STRATEGY_HINT}., +	@Override, +	public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType, MediaType mediaType,, +			ReactiveHttpOutputMessage outputMessage, Map<String, Object> hints) {, +, +		if ((mediaType != null) && mediaType.isCompatibleWith(MediaType.APPLICATION_STREAM_JSON)) {, +			Map<String, Object> hintsWithFlush =  new HashMap<>(hints);, +			hintsWithFlush.put(FLUSHING_STRATEGY_HINT, AFTER_EACH_ELEMENT);, +			return super.write(inputStream, elementType, mediaType, outputMessage, hintsWithFlush);, +		}, +		return super.write(inputStream, elementType, mediaType, outputMessage, hints);, +	}, +, +	@Override, +	public Mono<Void> write(Publisher<?> inputStream, ResolvableType streamType, ResolvableType elementType,, +			MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {, +, +		if ((mediaType != null) && mediaType.isCompatibleWith(MediaType.APPLICATION_STREAM_JSON)) {, +			Map<String, Object> hintsWithFlush =  new HashMap<>(hints);, +			hintsWithFlush.put(FLUSHING_STRATEGY_HINT, AFTER_EACH_ELEMENT);, +			return super.write(inputStream, streamType, elementType, mediaType, request, response, hintsWithFlush);, +		}, +		return super.write(inputStream, streamType, elementType, mediaType, request, response, hints);, +	}, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractEncoder.java, +	/**, +	 * Hint key to use with a {@link FlushingStrategy} value., +	 */, +	public static final String FLUSHING_STRATEGY_HINT = AbstractEncoder.class.getName() + ".flushingStrategy";, +, +	public enum FlushingStrategy { AUTO, AFTER_EACH_ELEMENT }, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +import static org.springframework.core.codec.AbstractEncoder.FLUSHING_STRATEGY_HINT;, +import static org.springframework.core.codec.AbstractEncoder.FlushingStrategy.AFTER_EACH_ELEMENT;, +		return (hints.get(FLUSHING_STRATEGY_HINT) == AFTER_EACH_ELEMENT ?, +				outputMessage.writeAndFlushWith(body.map(Flux::just)) : outputMessage.writeWith(body));, +++ b/spring-web/src/main/java/org/springframework/http/codec/Jackson2ServerHttpMessageWriter.java, +import org.reactivestreams.Publisher;, +import static org.springframework.core.codec.AbstractEncoder.FLUSHING_STRATEGY_HINT;, +import static org.springframework.core.codec.AbstractEncoder.FlushingStrategy.AFTER_EACH_ELEMENT;, +import reactor.core.publisher.Mono;, +import org.springframework.core.codec.AbstractEncoder;, +import org.springframework.http.ReactiveHttpOutputMessage;, +import org.springframework.http.server.reactive.ServerHttpResponse;, + * Jackson {@link ServerHttpMessageWriter} that resolves {@code @JsonView} annotated handler, + * method and deals with {@link AbstractEncoder#FLUSHING_STRATEGY_HINT}., +	@Override, +	public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType, MediaType mediaType,, +			ReactiveHttpOutputMessage outputMessage, Map<String, Object> hints) {, +, +		if ((mediaType != null) && mediaType.isCompatibleWith(MediaType.APPLICATION_STREAM_JSON)) {, +			Map<String, Object> hintsWithFlush =  new HashMap<>(hints);, +			hintsWithFlush.put(FLUSHING_STRATEGY_HINT, AFTER_EACH_ELEMENT);, +			return super.write(inputStream, elementType, mediaType, outputMessage, hintsWithFlush);, +		}, +		return super.write(inputStream, elementType, mediaType, outputMessage, hints);]