[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath);, +			if (bestMatch != null) {, +					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath);, +			if (bestMatch != null) {, +					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathMatchResult.java, +import org.jetbrains.annotations.NotNull;, +, + * Result of path match performed through a {@link PathPatternRegistry}., + * Each result contains the matched pattern and handler of type {@code T}., +public class PathMatchResult<T> implements Comparable<PathMatchResult<T>> {, +, +	@Override, +	public int compareTo(@NotNull PathMatchResult<T> other) {, +		int index = this.pattern.compareTo(other.pattern);, +		return (index != 0 ? index : this.getPatternString().compareTo(other.getPatternString()));, +	}, +, +	private String getPatternString() {, +		return this.pattern.getPatternString();, +	}, +, +	@Override, +	public String toString() {, +		return "PathMatchResult{pattern=" + this.pattern + ", handler=" + this.handler + "]";, +	}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath);, +			if (bestMatch != null) {, +					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathMatchResult.java, +import org.jetbrains.annotations.NotNull;, +, + * Result of path match performed through a {@link PathPatternRegistry}., + * Each result contains the matched pattern and handler of type {@code T}., +public class PathMatchResult<T> implements Comparable<PathMatchResult<T>> {, +, +	@Override, +	public int compareTo(@NotNull PathMatchResult<T> other) {, +		int index = this.pattern.compareTo(other.pattern);, +		return (index != 0 ? index : this.getPatternString().compareTo(other.getPatternString()));, +	}, +, +	private String getPatternString() {, +		return this.pattern.getPatternString();, +	}, +, +	@Override, +	public String toString() {, +		return "PathMatchResult{pattern=" + this.pattern + ", handler=" + this.handler + "]";, +	}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathPatternRegistry.java, +	private static String prependLeadingSlash(String pattern) {, +	/**, +	 * Return patterns matching the given {@code lookupPath}., +	 * <p>The returned set sorted with the most specific, +	 * patterns first, according to the given {@code lookupPath}., +	 * @param lookupPath the URL lookup path to be matched against, +	 */, +	public SortedSet<PathMatchResult<T>> findMatches(String lookupPath) {, +		return this.patternsMap.entrySet().stream(), +				.filter(entry -> entry.getKey().matches(lookupPath)), +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.map(entry -> new PathMatchResult<>(entry.getKey(), entry.getValue())), +				.collect(Collectors.toCollection(TreeSet::new));, +	/**, +	 * Return, if any, the most specific {@code PathPattern} matching the given {@code lookupPath}., +	 * @param lookupPath the URL lookup path to be matched against, +	 */, +	@Nullable, +	public PathMatchResult<T> findFirstMatch(String lookupPath) {, +		return this.patternsMap.entrySet().stream(), +				.filter(entry -> entry.getKey().matches(lookupPath)), +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +				.map(entry -> new PathMatchResult<>(entry.getKey(), entry.getValue())), +				.orElse(null);, +, +	/**, +	 * Remove all {@link PathPattern}s from this registry, +	 */, +	public void clear() {, +		this.patternsMap.clear();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath);, +			if (bestMatch != null) {, +					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/PathMatchResult.java, +import org.jetbrains.annotations.NotNull;, +, + * Result of path match performed through a {@link PathPatternRegistry}., + * Each result contains the matched pattern and handler of type {@code T}., +public class PathMatchResult<T> implements Comparable<PathMatchResult<T>> {, +, +	@Override]