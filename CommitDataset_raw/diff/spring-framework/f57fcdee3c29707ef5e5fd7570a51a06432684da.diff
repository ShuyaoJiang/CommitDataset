[+++ b/spring-beans/src/main/java/org/springframework/beans/PropertyMatches.java, + * Copyright 2002-2018 the original author or authors., +	private final String[] possibleMatches;, +		int[][] d = new int[s1.length() + 1][s2.length() + 1];, +			char c1 = s1.charAt(i - 1);, +				char c2 = s2.charAt(j - 1);, +				if (c1 == c2) {, +				d[i][j] = Math.min(Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1), d[i - 1][j - 1] + cost);, +			super(propertyName,, +					calculateMatches(propertyName, BeanUtils.getPropertyDescriptors(beanClass), maxDistance));, +		 * Generate possible property alternatives for the given property and class., +		 * Internally uses the {@code getStringDistance} method, which in turn uses, +		 * the Levenshtein algorithm to determine the distance between two Strings., +		 * @param descriptors the JavaBeans property descriptors to search, +		private static String[] calculateMatches(String name, PropertyDescriptor[] descriptors, int maxDistance) {, +			for (PropertyDescriptor pd : descriptors) {, +					if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(160);, +			msg.append("Bean property '").append(getPropertyName()).append(, +					"' is not writable or has an invalid setter method. ");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				appendHintMessage(msg);, +				msg.append("Does the parameter type of the setter match the return type of the getter?");, +		private static String[] calculateMatches(final String name, Class<?> clazz, final int maxDistance) {, +			ReflectionUtils.doWithFields(clazz, field -> {, +				if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(80);, +			msg.append("Bean property '").append(getPropertyName()).append("' has no matching field.");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				msg.append(' ');, +++ b/spring-beans/src/main/java/org/springframework/beans/PropertyMatches.java, + * Copyright 2002-2018 the original author or authors., +	private final String[] possibleMatches;, +		int[][] d = new int[s1.length() + 1][s2.length() + 1];, +			char c1 = s1.charAt(i - 1);, +				char c2 = s2.charAt(j - 1);, +				if (c1 == c2) {, +				d[i][j] = Math.min(Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1), d[i - 1][j - 1] + cost);, +			super(propertyName,, +					calculateMatches(propertyName, BeanUtils.getPropertyDescriptors(beanClass), maxDistance));, +		 * Generate possible property alternatives for the given property and class., +		 * Internally uses the {@code getStringDistance} method, which in turn uses, +		 * the Levenshtein algorithm to determine the distance between two Strings., +		 * @param descriptors the JavaBeans property descriptors to search, +		private static String[] calculateMatches(String name, PropertyDescriptor[] descriptors, int maxDistance) {, +			for (PropertyDescriptor pd : descriptors) {, +					if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(160);, +			msg.append("Bean property '").append(getPropertyName()).append(, +					"' is not writable or has an invalid setter method. ");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				appendHintMessage(msg);, +				msg.append("Does the parameter type of the setter match the return type of the getter?");, +		private static String[] calculateMatches(final String name, Class<?> clazz, final int maxDistance) {, +			ReflectionUtils.doWithFields(clazz, field -> {, +				if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(80);, +			msg.append("Bean property '").append(getPropertyName()).append("' has no matching field.");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				msg.append(' ');, +++ b/spring-context/src/main/resources/org/springframework/cache/config/spring-cache.xsd, +	Indicates that cache configuration is defined by annotations on bean classes,, +	and that proxies are automatically to be created for the relevant annotated beans., +	The default annotations supported are Spring's @Cacheable, @CachePut and @CacheEvict., +	If spring-context-support and the JSR-107 API are on the classpath, additional proxies, +	are automatically created for JSR-107 annotated beans, that is @CacheResult, @CachePut,, +	See org.springframework.cache.annotation.EnableCaching javadoc for information on, +	code-based alternatives to this XML element., +	Defines the cache semantics of the AOP advice that is to be executed., +++ b/spring-beans/src/main/java/org/springframework/beans/PropertyMatches.java, + * Copyright 2002-2018 the original author or authors., +	private final String[] possibleMatches;, +		int[][] d = new int[s1.length() + 1][s2.length() + 1];, +			char c1 = s1.charAt(i - 1);, +				char c2 = s2.charAt(j - 1);, +				if (c1 == c2) {, +				d[i][j] = Math.min(Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1), d[i - 1][j - 1] + cost);, +			super(propertyName,, +					calculateMatches(propertyName, BeanUtils.getPropertyDescriptors(beanClass), maxDistance));, +		 * Generate possible property alternatives for the given property and class., +		 * Internally uses the {@code getStringDistance} method, which in turn uses, +		 * the Levenshtein algorithm to determine the distance between two Strings., +		 * @param descriptors the JavaBeans property descriptors to search, +		private static String[] calculateMatches(String name, PropertyDescriptor[] descriptors, int maxDistance) {, +			for (PropertyDescriptor pd : descriptors) {, +					if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(160);, +			msg.append("Bean property '").append(getPropertyName()).append(, +					"' is not writable or has an invalid setter method. ");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				appendHintMessage(msg);, +				msg.append("Does the parameter type of the setter match the return type of the getter?");, +		private static String[] calculateMatches(final String name, Class<?> clazz, final int maxDistance) {, +			ReflectionUtils.doWithFields(clazz, field -> {, +				if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {, +			StringBuilder msg = new StringBuilder(80);, +			msg.append("Bean property '").append(getPropertyName()).append("' has no matching field.");, +			if (!ObjectUtils.isEmpty(getPossibleMatches())) {, +				msg.append(' ');, +++ b/spring-context/src/main/resources/org/springframework/cache/config/spring-cache.xsd]