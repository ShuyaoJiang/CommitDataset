[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.util.Arrays;, +import java.util.HashSet;, +		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());, +		if (imports != null && !imports.isEmpty()) {, +			processImport(configClass, imports.toArray(new String[imports.size()]), true);, +	 * Recursively collect all declared {@code @Import} values. Unlike most, +	 * meta-annotations it is valid to have several {@code @Import}s declared with, +	 * different values, the usual process or returning values from the first, +	 * meta-annotation on a class is not sufficient., +	 * <p>For example, it is common for a {@code @Configuration} class to declare direct, +	 * {@code @Import}s in addition to meta-imports originating from an {@code @Enable}, +	 * annotation., +	 * @param className the class name to search, +	 * @param imports the imports collected so far or {@code null}, +	 * @param visited used to track visited classes to prevent infinite recursion (must not be null), +	 * @return a set of all {@link Import#value() import values} or {@code null}, +	 * @throws IOException if there is any problem reading metadata from the named class, +	private Set<String> getImports(String className, Set<String> imports,, +			Set<String> visited) throws IOException {, +		if (visited.add(className)) {, +			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata();, +			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true);, +			if (attributes != null) {, +				String[] value = (String[]) attributes.get("value");, +				if (value != null && value.length > 0) {, +					imports = (imports == null ? new LinkedHashSet<String>() : imports);, +					imports.addAll(Arrays.asList(value));, +				}, +			}, +				getImports(annotationType, imports, visited);, +		return imports;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.util.Arrays;, +import java.util.HashSet;, +		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());, +		if (imports != null && !imports.isEmpty()) {, +			processImport(configClass, imports.toArray(new String[imports.size()]), true);, +	 * Recursively collect all declared {@code @Import} values. Unlike most, +	 * meta-annotations it is valid to have several {@code @Import}s declared with, +	 * different values, the usual process or returning values from the first, +	 * meta-annotation on a class is not sufficient., +	 * <p>For example, it is common for a {@code @Configuration} class to declare direct, +	 * {@code @Import}s in addition to meta-imports originating from an {@code @Enable}, +	 * annotation., +	 * @param className the class name to search, +	 * @param imports the imports collected so far or {@code null}, +	 * @param visited used to track visited classes to prevent infinite recursion (must not be null), +	 * @return a set of all {@link Import#value() import values} or {@code null}, +	 * @throws IOException if there is any problem reading metadata from the named class, +	private Set<String> getImports(String className, Set<String> imports,, +			Set<String> visited) throws IOException {, +		if (visited.add(className)) {, +			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata();, +			Map<String, Object> attributes = metadata.getAnnotationAttributes(Import.class.getName(), true);, +			if (attributes != null) {, +				String[] value = (String[]) attributes.get("value");, +				if (value != null && value.length > 0) {, +					imports = (imports == null ? new LinkedHashSet<String>() : imports);, +					imports.addAll(Arrays.asList(value));, +				}, +			}, +				getImports(annotationType, imports, visited);, +		return imports;, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ImportAwareTests.java, +import org.springframework.beans.factory.config.BeanDefinition;, +import org.springframework.beans.factory.support.BeanDefinitionRegistry;, +import org.springframework.beans.factory.support.GenericBeanDefinition;, +import org.springframework.util.Assert;, +	@Test, +	public void importRegistrar() throws Exception {, +		ImportedRegistrar.called = false;, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ImportingRegistrarConfig.class);, +		ctx.refresh();, +		assertNotNull(ctx.getBean("registrarImportedBean"));, +	}, +, +	@Test, +	public void importRegistrarWithImport() throws Exception {, +		ImportedRegistrar.called = false;, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ImportingRegistrarConfigWithImport.class);, +		ctx.refresh();, +		assertNotNull(ctx.getBean("registrarImportedBean"));, +		assertNotNull(ctx.getBean(ImportedConfig.class));, +	}, +, +	@Configuration, +	@EnableImportRegistrar, +	static class ImportingRegistrarConfig {, +	}, +, +	@Configuration, +	@EnableImportRegistrar, +	@Import(ImportedConfig.class), +	static class ImportingRegistrarConfigWithImport {, +	}, +, +	@Target(ElementType.TYPE)]