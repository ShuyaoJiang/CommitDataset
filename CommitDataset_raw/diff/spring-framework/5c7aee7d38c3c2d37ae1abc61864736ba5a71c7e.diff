[+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/incrementer/MySQLMaxValueIncrementer.java, + * Copyright 2002-2017 the original author or authors., + * table that needs an auto-generated key. The storage engine used by the sequence table, + * can be MYISAM or INNODB since the sequences are allocated using a separate connection , + * without being affected by any other transactions that might be in progress., + * create table tab_sequence (value int not null);, + * <p>It is possible to avoid acquiring a new connection for the incrementer by setting the, + * "useNewConnection" property to false. In this case you <i>MUST</i> use a non-transactional, + * storage engine like MYISAM when defining the incrementer table., + *, +	/**, +	 * Whether or not to use a new connection for the incrementer. Defaults to true, +	 * in order to support transactional storage engines. Set this to false if the storage engine, +	 * for the  incrementer table is non-transactional like MYISAM and you prefer to not acquire, +	 * an additional database connection, +	 */, +	private boolean useNewConnection = true;, +, +	/**, +	 * Convenience constructor for setting whether to use a new connection for the incrementer., +	 * @param dataSource the DataSource to use, +	 * @param incrementerName the name of the sequence/table to use, +	 * @param columnName the name of the column in the sequence table to use, +	 * @param useNewConnection whether to use a new connection for the incrementer, +	 */, +	public MySQLMaxValueIncrementer(DataSource dataSource, String incrementerName, String columnName,, +	                                boolean useNewConnection) {, +		super(dataSource, incrementerName, columnName);, +		this.useNewConnection = useNewConnection;, +	}, +, +, +	/**, +	 * Return whether to use a new connection for the incrementer., +	 */, +	public boolean isUseNewConnection() {, +		return useNewConnection;, +	}, +, +	/**, +	 * Set whether to use a new connection for the incrementer., +	 */, +	public void setUseNewConnection(boolean useNewConnection) {, +		this.useNewConnection = useNewConnection;, +	}, +			* If useNewConnection is true, then we obtain a non-managed connection so our modifications, +			* are handled in a separate transaction. If it is false, then we use the current transaction's, +			* connection relying on the use of a non-transactional storage engine like MYISAM for the, +			* incrementer table. We also use straight JDBC code because we need to make sure that the insert, +			* and select are performed on the same connection (otherwise we can't be sure that last_insert_id(), +			* returned the correct value)., +			Connection con = null;, +			boolean mustRestoreAutoCommit = false;, +				if (useNewConnection) {, +					con = getDataSource().getConnection();, +					if (con.getAutoCommit()) {, +						mustRestoreAutoCommit = true;, +						con.setAutoCommit(false);, +					}, +				}, +				else {, +					con = DataSourceUtils.getConnection(getDataSource());, +				}, +				if (!useNewConnection) {, +				}, +				try {, +				}, +				catch (SQLException ex) {, +					throw new DataAccessResourceFailureException("Could not increment " + columnName + " for " +, +							getIncrementerName() + " sequence table", ex);, +				}, +				if (useNewConnection) {, +					try {, +						con.commit();, +						if (mustRestoreAutoCommit) {, +							con.setAutoCommit(true);, +						}, +					}, +					catch (SQLException ignore) {, +						throw new DataAccessResourceFailureException(, +								"Unable to commit new sequence value changes for " + getIncrementerName());, +					}, +					try {, +						con.close();, +					} catch (SQLException ignore) {}, +				}, +				else {, +		}]