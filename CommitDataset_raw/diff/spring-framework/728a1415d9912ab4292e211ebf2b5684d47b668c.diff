[+++ b/org.springframework.context/src/main/java/org/springframework/ui/format/FormatterRegistry.java, +	void addFormatterByType(Formatter<?> formatter);, +	void addFormatterByAnnotation(AnnotationFormatterFactory<?, ?> factory);, +++ b/org.springframework.context/src/main/java/org/springframework/ui/format/FormatterRegistry.java, +	void addFormatterByType(Formatter<?> formatter);, +	void addFormatterByAnnotation(AnnotationFormatterFactory<?, ?> factory);, +++ b/org.springframework.context/src/main/java/org/springframework/ui/format/support/GenericFormatterRegistry.java, +import java.lang.reflect.Method;, +import java.lang.reflect.Modifier;, +import org.springframework.util.ReflectionUtils;, + * @see #setFormatters(Set), + * @see #setFormatterMap(Map), + * @see #setAnnotationFormatterMap(Map), + * @see #setAnnotationFormatterFactories(Set), + * @see #addFormatterByType(Formatter), + * @see #addFormatterByType(Class, Formatter), + * @see #addFormatterByAnnotation(Class, Formatter), + * @see #addFormatterByAnnotation(AnnotationFormatterFactory) , +	private final Map<Class, FormatterHolder> typeFormatters = new ConcurrentHashMap<Class, FormatterHolder>();, +	private final Map<Class, AnnotationFormatterFactoryHolder> annotationFormatters = new ConcurrentHashMap<Class, AnnotationFormatterFactoryHolder>();, +	private ConversionService conversionService;, +		if (this.conversionService == null, +				&& context.containsBean(ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME)) {, +			this.conversionService = context.getBean(ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME,, +					ConversionService.class);, +		if (formattedObjectType != null && !type.isAssignableFrom(formattedObjectType)) {, +			if (this.conversionService == null) {, +				throw new IllegalStateException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; unable to convert from [" + formattedObjectType.getName(), +						+ "] parsed by Formatter because this.conversionService is null");, +			}, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert from [" + formattedObjectType.getName(), +						+ "] to parse");, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert to [" + formattedObjectType.getName(), +						+ "] to format");, +		}, +		this.typeFormatters.put(type, new FormatterHolder(formattedObjectType, formatter));, +	public void addFormatterByType(Formatter<?> formatter) {, +		if (formattedObjectType == null) {, +			throw new IllegalArgumentException("Unable to register Formatter " + formatter, +					+ "; cannot determine parameterized object type <T>");, +		}, +		this.typeFormatters.put(formattedObjectType, new FormatterHolder(formattedObjectType, formatter));, +		Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		SimpleAnnotationFormatterFactory factory = new SimpleAnnotationFormatterFactory(formatter);, +		this.annotationFormatters.put(annotationType,, +				new AnnotationFormatterFactoryHolder(formattedObjectType, factory));, +	public void addFormatterByAnnotation(AnnotationFormatterFactory<?, ?> factory) {, +		Class[] typeArgs = GenericTypeResolver.resolveTypeArguments(factory.getClass(),, +				AnnotationFormatterFactory.class);, +		if (typeArgs == null || typeArgs.length != 2) {, +					"Unable to extract parameterized type arguments from AnnotationFormatterFactory [", +							+ factory.getClass().getName(), +							+ "]; does the factory parameterize the <A> and <T> generic types?");, +		this.annotationFormatters.put(typeArgs[0], new AnnotationFormatterFactoryHolder(typeArgs[1], factory));, +		FormatterHolder holder = findFormatterHolderForAnnotatedProperty(type.getAnnotations());, +		if (holder == null) {, +			holder = findFormatterHolderForType(type.getType());, +		if (holder == null) {, +			holder = getDefaultFormatterHolder(type);, +		}, +		if (holder == null) {, +			return null;, +		}, +		Class formattedObjectType = holder.getFormattedObjectType();, +		if (formattedObjectType != null && !type.getType().isAssignableFrom(formattedObjectType)) {, +			if (this.conversionService != null) {, +				return new ConvertingFormatter(type, holder);, +			} else {, +				return null;, +			}, +		} else {, +			return holder.getFormatter();, +	private FormatterHolder findFormatterHolderForAnnotatedProperty(Annotation[] annotations) {, +		for (Annotation annotation : annotations) {, +			FormatterHolder holder = findFormatterHolderForAnnotation(annotation);, +			if (holder != null) {, +				return holder;, +	private FormatterHolder findFormatterHolderForAnnotation(Annotation annotation) {, +		Class<? extends Annotation> annotationType = annotation.annotationType();, +		AnnotationFormatterFactoryHolder factory = this.annotationFormatters.get(annotationType);, +		if (factory != null) {, +			return factory.getFormatterHolder(annotation);, +		} else {, +			Formatted formattedAnnotation = annotationType.getAnnotation(Formatted.class);, +			if (formattedAnnotation != null) {, +				// annotation has @Formatted meta-annotation, +				Formatter formatter = createFormatter(formattedAnnotation.value());, +				addFormatterByAnnotation(annotationType, formatter);, +				return findFormatterHolderForAnnotation(annotation);, +			} else {, +				return null;, +			}, +		}, +	private FormatterHolder findFormatterHolderForType(Class type) {, +			FormatterHolder holder = this.typeFormatters.get(currentClass);, +			if (holder != null) {, +				return holder;]