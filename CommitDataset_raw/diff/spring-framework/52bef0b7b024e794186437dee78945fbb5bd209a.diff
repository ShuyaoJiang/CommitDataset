[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Bean.java, + * intuitive, but if explicit naming is desired, the {@code name()} attribute may be used., + * Also note that {@code name()} accepts an array of Strings. This is in order to allow, + * <h3>A note on {@code BeanFactoryPostProcessor}-returning {@code @Bean} methods</h3>, + * <p>Special consideration must be taken for {@code @Bean} methods that return Spring, + * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}, + * ({@code BFPP}) types. Because {@code BFPP} objects must be instantiated very early in the, + * container lifecycle, they can interfere with processing of annotations such as {@code @Autowired},, + * {@code @Value}, and {@code @PostConstruct} within {@code @Configuration} classes. To avoid these, + * lifecycle issues, mark {@code BFPP}-returning {@code @Bean} methods as {@code static}. For example:, + * <pre class="code">, + *     &#064;Bean, + *     public static PropertyPlaceholderConfigurer ppc() {, + *         // instantiate, configure and return ppc ..., + *     }, + * </pre>, + * By marking this method as {@code static}, it can be invoked without causing instantiation of its, + * declaring {@code @Configuration} class, thus avoiding the above-mentioned lifecycle conflicts., + * Note however that {@code static} {@code @Bean} methods will not be enhanced for scoping and AOP, + * semantics as mentioned above. This works out in {@code BFPP} cases, as they are not typically, + * referenced by other {@code @Bean} methods. As a reminder, a WARN-level log message will be, + * issued for any non-static {@code @Bean} methods having a return type assignable to, + * {@code BeanFactoryPostProcessor}., + *, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Bean.java, + * intuitive, but if explicit naming is desired, the {@code name()} attribute may be used., + * Also note that {@code name()} accepts an array of Strings. This is in order to allow, + * <h3>A note on {@code BeanFactoryPostProcessor}-returning {@code @Bean} methods</h3>, + * <p>Special consideration must be taken for {@code @Bean} methods that return Spring, + * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}, + * ({@code BFPP}) types. Because {@code BFPP} objects must be instantiated very early in the, + * container lifecycle, they can interfere with processing of annotations such as {@code @Autowired},, + * {@code @Value}, and {@code @PostConstruct} within {@code @Configuration} classes. To avoid these, + * lifecycle issues, mark {@code BFPP}-returning {@code @Bean} methods as {@code static}. For example:, + * <pre class="code">, + *     &#064;Bean, + *     public static PropertyPlaceholderConfigurer ppc() {, + *         // instantiate, configure and return ppc ..., + *     }, + * </pre>, + * By marking this method as {@code static}, it can be invoked without causing instantiation of its, + * declaring {@code @Configuration} class, thus avoiding the above-mentioned lifecycle conflicts., + * Note however that {@code static} {@code @Bean} methods will not be enhanced for scoping and AOP, + * semantics as mentioned above. This works out in {@code BFPP} cases, as they are not typically, + * referenced by other {@code @Bean} methods. As a reminder, a WARN-level log message will be, + * issued for any non-static {@code @Bean} methods having a return type assignable to, + * {@code BeanFactoryPostProcessor}., + *, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/BeanMethod.java, +		if (getMetadata().isStatic()) {, +			// static @Bean methods have no constraints to validate -> return immediately, +			return;, +		}, +, +				// instance @Bean methods within @Configuration classes must be overridable to accommodate CGLIB, +, +			super(String.format("@Bean method '%s' must not be private or final; change the method's modifiers to continue",, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Bean.java, + * intuitive, but if explicit naming is desired, the {@code name()} attribute may be used., + * Also note that {@code name()} accepts an array of Strings. This is in order to allow, + * <h3>A note on {@code BeanFactoryPostProcessor}-returning {@code @Bean} methods</h3>, + * <p>Special consideration must be taken for {@code @Bean} methods that return Spring, + * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}, + * ({@code BFPP}) types. Because {@code BFPP} objects must be instantiated very early in the, + * container lifecycle, they can interfere with processing of annotations such as {@code @Autowired},, + * {@code @Value}, and {@code @PostConstruct} within {@code @Configuration} classes. To avoid these, + * lifecycle issues, mark {@code BFPP}-returning {@code @Bean} methods as {@code static}. For example:, + * <pre class="code">, + *     &#064;Bean, + *     public static PropertyPlaceholderConfigurer ppc() {, + *         // instantiate, configure and return ppc ..., + *     }, + * </pre>, + * By marking this method as {@code static}, it can be invoked without causing instantiation of its, + * declaring {@code @Configuration} class, thus avoiding the above-mentioned lifecycle conflicts., + * Note however that {@code static} {@code @Bean} methods will not be enhanced for scoping and AOP, + * semantics as mentioned above. This works out in {@code BFPP} cases, as they are not typically, + * referenced by other {@code @Bean} methods. As a reminder, a WARN-level log message will be, + * issued for any non-static {@code @Bean} methods having a return type assignable to, + * {@code BeanFactoryPostProcessor}., + *, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/BeanMethod.java, +		if (getMetadata().isStatic()) {, +			// static @Bean methods have no constraints to validate -> return immediately, +			return;, +		}, +, +				// instance @Bean methods within @Configuration classes must be overridable to accommodate CGLIB, +, +			super(String.format("@Bean method '%s' must not be private or final; change the method's modifiers to continue",, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +		if (metadata.isStatic()) {, +			// static @Bean method, +			beanDef.setBeanClassName(configClass.getMetadata().getClassName());, +			beanDef.setFactoryMethodName(metadata.getMethodName());, +		}, +		else {, +			// instance @Bean method, +		}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Bean.java]