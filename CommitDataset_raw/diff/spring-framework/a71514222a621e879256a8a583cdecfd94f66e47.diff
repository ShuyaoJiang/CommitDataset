[+++ b/org.springframework.context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +, +import java.util.ArrayList;, +import java.util.List;, +	public void testFormatCollectionFieldForAnnotation() throws Exception {, +		formattingService.addConverter(new Converter<Date, Long>() {, +			public Long convert(Date source) {, +				return source.getTime();, +			}, +		});, +		formattingService.addConverter(new Converter<DateTime, Date>() {, +			public Date convert(DateTime source) {, +				return source.toDate();, +			}, +		});, +		formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory());, +		List<Date> dates = new ArrayList<Date>();, +		dates.add(new LocalDate(2009, 10, 31).toDateTimeAtCurrentTime().toDate());, +		dates.add(new LocalDate(2009, 11, 1).toDateTimeAtCurrentTime().toDate());, +		dates.add(new LocalDate(2009, 11, 2).toDateTimeAtCurrentTime().toDate());, +		String formatted = (String) formattingService.convert(dates, new TypeDescriptor(Model.class.getField("dates")), TypeDescriptor.valueOf(String.class));, +		assertEquals("10/31/09,11/1/09,11/2/09", formatted);, +		dates = (List<Date>) formattingService.convert("10/31/09,11/1/09,11/2/09", TypeDescriptor.valueOf(String.class), new TypeDescriptor(Model.class.getField("dates")));, +		assertEquals(new LocalDate(2009, 10, 31), new LocalDate(dates.get(0)));, +		assertEquals(new LocalDate(2009, 11, 1), new LocalDate(dates.get(1)));, +		assertEquals(new LocalDate(2009, 11, 2), new LocalDate(dates.get(2)));, +	}, +	, +	@Test, +		@SuppressWarnings("unused"), +		@org.springframework.format.annotation.DateTimeFormat(style="S-"), +		public List<Date> dates;, +, +++ b/org.springframework.context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +, +import java.util.ArrayList;, +import java.util.List;, +	public void testFormatCollectionFieldForAnnotation() throws Exception {, +		formattingService.addConverter(new Converter<Date, Long>() {, +			public Long convert(Date source) {, +				return source.getTime();, +			}, +		});, +		formattingService.addConverter(new Converter<DateTime, Date>() {, +			public Date convert(DateTime source) {, +				return source.toDate();, +			}, +		});, +		formattingService.addFormatterForFieldAnnotation(new JodaDateTimeFormatAnnotationFormatterFactory());, +		List<Date> dates = new ArrayList<Date>();, +		dates.add(new LocalDate(2009, 10, 31).toDateTimeAtCurrentTime().toDate());, +		dates.add(new LocalDate(2009, 11, 1).toDateTimeAtCurrentTime().toDate());, +		dates.add(new LocalDate(2009, 11, 2).toDateTimeAtCurrentTime().toDate());, +		String formatted = (String) formattingService.convert(dates, new TypeDescriptor(Model.class.getField("dates")), TypeDescriptor.valueOf(String.class));, +		assertEquals("10/31/09,11/1/09,11/2/09", formatted);, +		dates = (List<Date>) formattingService.convert("10/31/09,11/1/09,11/2/09", TypeDescriptor.valueOf(String.class), new TypeDescriptor(Model.class.getField("dates")));, +		assertEquals(new LocalDate(2009, 10, 31), new LocalDate(dates.get(0)));, +		assertEquals(new LocalDate(2009, 11, 1), new LocalDate(dates.get(1)));, +		assertEquals(new LocalDate(2009, 11, 2), new LocalDate(dates.get(2)));, +	}, +	, +	@Test, +		@SuppressWarnings("unused"), +		@org.springframework.format.annotation.DateTimeFormat(style="S-"), +		public List<Date> dates;, +, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +	, +		typeDescriptorCache.put(int.class, new TypeDescriptor(int.class));, +		typeDescriptorCache.put(Integer.class, new TypeDescriptor(Integer.class));, +		typeDescriptorCache.put(long.class, new TypeDescriptor(long.class));, +		typeDescriptorCache.put(Long.class, new TypeDescriptor(Long.class));, +		typeDescriptorCache.put(float.class, new TypeDescriptor(float.class));, +		typeDescriptorCache.put(Float.class, new TypeDescriptor(Float.class));, +		typeDescriptorCache.put(double.class, new TypeDescriptor(double.class));, +		typeDescriptorCache.put(Double.class, new TypeDescriptor(Double.class));, +	private Object value;, +, +	 * @param type the specific type to expose (may be an array/collection element), +	// static factory methods, +, +	 * Create a new type descriptor for the class of the given object., +	 * @param object the object, +	 * @return the type descriptor, +	public static TypeDescriptor forObject(Object object) {, +		if (object == null) {, +			return NULL;, +		}, +		else if (object instanceof Collection<?> || object instanceof Map<?, ?>) {, +			return new TypeDescriptor(object);, +		}, +		else {, +			return valueOf(object.getClass());, +		}, +	 * Create a new type descriptor for the given class.]