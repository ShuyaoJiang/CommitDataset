[+++ b/src/asciidoc/index.adoc, +The easiest way to do that is to have a `SimpMessagingTemplate` injected, and, +that takes no destination argument uses the default destination., +==== Using Source-Level Metadata (Java annotations), +provides a default implementation which uses Java annotations, namely, +the main open-source JMX implementation, MX4J, and the one provided with the JDK, +interface. In fact, its primary reason for existence was to abstract away the need for, +* `SimpleAsyncTaskExecutor`, +  This implementation does not reuse any threads, rather it starts up a new thread, +  for each invocation. However, it does support a concurrency limit which will block, +  any invocations that are over the limit until a slot has been freed up. If you, +  re looking for true pooling, keep scrolling further down the page., +* `SyncTaskExecutor`, +  This implementation doesn't execute invocations asynchronously. Instead, each, +  invocation takes place in the calling thread. It is primarily used in situations, +  where multi-threading isn't necessary such as simple test cases., +* `ConcurrentTaskExecutor`, +  This implementation is an adapter for a `java.util.concurrent.Executor` object., +  There is an alternative, `ThreadPoolTaskExecutor, that exposes the `Executor`, +  configuration parameters as bean properties. It is rare to need to use the, +  `ConcurrentTaskExecutor` but if the <<threadPoolTaskExecutor, `ThreadPoolTaskExecutor`>>, +  isn't flexible enough for your needs, the `ConcurrentTaskExecutor` is an alternative., +* `SimpleThreadPoolTaskExecutor`, +  This implementation is actually a subclass of Quartz's `SimpleThreadPool` which, +  listens to Spring's lifecycle callbacks. This is typically used when you have a, +  thread pool that may need to be shared by both Quartz and non-Quartz components., +  This implementation is the most commonly used one. It exposes bean properties for, +  configuring a java.util.concurrent.ThreadPoolExecutor` and wraps it in a `TaskExecutor`., +  If you need to adapt to a different kind of `java.util.concurrent.Executor`, it is, +  recommended that you use a <<concurrentTaskExecutor, `ConcurrentTaskExecutor`>> instead., +* `TimerTaskExecutor`, +  This implementation uses a single `TimerTask` as its backing implementation., +  It's different from the <<syncTaskExecutor, `SyncTaskExecutor`>> in that the method, +  invocations are executed in a separate thread, although they are effectively, +  synchronously batched in that thread., +context. Similar to the <<simpleThreadPoolTaskExecutor, `SimpleThreadPoolTaskExecutor`>>,, +this class implements the WorkManager interface and therefore can be used directly as a, +WorkManager as well.]