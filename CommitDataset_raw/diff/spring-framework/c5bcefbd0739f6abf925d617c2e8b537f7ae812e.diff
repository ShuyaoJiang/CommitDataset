[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ControllerMethodResolver.java, +import java.util.function.Function;, +import java.util.function.Supplier;, +import java.util.stream.Collectors;, +import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;, +import org.springframework.context.ConfigurableApplicationContext;, +import org.springframework.core.ReactiveAdapterRegistry;, +import org.springframework.http.codec.HttpMessageReader;, +import org.springframework.util.Assert;, + * resolving, initializing, and caching annotated methods declared in, + * {@code @Controller} and {@code @ControllerAdvice} components:, + * <ul>, + * <li>{@code @InitBinder}, + * <li>{@code @ModelAttribute}, + * <li>{@code @RequestMapping}, + * <li>{@code @ExceptionHandler}, + * </ul>, +	private final List<SyncHandlerMethodArgumentResolver> initBinderResolvers;, +	private final List<HandlerMethodArgumentResolver> modelAttributeResolvers;, +, +	private final List<HandlerMethodArgumentResolver> requestMappingResolvers;, +, +	private final List<HandlerMethodArgumentResolver> exceptionHandlerResolvers;, +	private final Map<Class<?>, Set<Method>> initBinderMethodCache = new ConcurrentHashMap<>(64);, +	private final Map<Class<?>, Set<Method>> modelAttributeMethodCache = new ConcurrentHashMap<>(64);, +	private final Map<Class<?>, ExceptionHandlerMethodResolver> exceptionHandlerCache = new ConcurrentHashMap<>(64);, +	private final Map<ControllerAdviceBean, Set<Method>> initBinderAdviceCache = new LinkedHashMap<>(64);, +	private final Map<ControllerAdviceBean, Set<Method>> modelAttributeAdviceCache = new LinkedHashMap<>(64);, +	ControllerMethodResolver(List<HandlerMethodArgumentResolver> customResolvers,, +			List<HttpMessageReader<?>> messageReaders, ReactiveAdapterRegistry reactiveRegistry,, +			ConfigurableApplicationContext applicationContext) {, +		Assert.notNull(customResolvers, "'customResolvers' should not be null");, +		Assert.notNull(reactiveRegistry, "ReactiveAdapterRegistry is required");, +		Assert.notNull(applicationContext, "ConfigurableApplicationContext is required");, +, +		ResolverRegistrar registrar = ResolverRegistrar.customResolvers(customResolvers).basic();, +		addResolversTo(registrar, reactiveRegistry, applicationContext);, +		this.initBinderResolvers = registrar.getSyncResolvers();, +, +		registrar = ResolverRegistrar.customResolvers(customResolvers).modelAttributeSupport();, +		addResolversTo(registrar, reactiveRegistry, applicationContext);, +		this.modelAttributeResolvers = registrar.getResolvers();, +, +		registrar = ResolverRegistrar.customResolvers(customResolvers).fullSupport(messageReaders);, +		addResolversTo(registrar, reactiveRegistry, applicationContext);, +		this.requestMappingResolvers = registrar.getResolvers();, +, +		registrar = ResolverRegistrar.customResolvers(customResolvers).basic();, +		addResolversTo(registrar, reactiveRegistry, applicationContext);, +		this.exceptionHandlerResolvers = registrar.getResolvers();, +	private void addResolversTo(ResolverRegistrar registrar,, +			ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context) {, +, +		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();, +, +		// Annotation-based..., +		registrar.add(new RequestParamMethodArgumentResolver(beanFactory, reactiveRegistry, false));, +		registrar.add(new RequestParamMapMethodArgumentResolver(reactiveRegistry));, +		registrar.add(new PathVariableMethodArgumentResolver(beanFactory, reactiveRegistry));, +		registrar.add(new PathVariableMapMethodArgumentResolver(reactiveRegistry));, +		registrar.addIfRequestBody(readers -> new RequestBodyArgumentResolver(readers, reactiveRegistry));, +		registrar.addIfModelAttribute(() -> new ModelAttributeMethodArgumentResolver(reactiveRegistry, false));, +		registrar.add(new RequestHeaderMethodArgumentResolver(beanFactory, reactiveRegistry));, +		registrar.add(new RequestHeaderMapMethodArgumentResolver(reactiveRegistry));, +		registrar.add(new CookieValueMethodArgumentResolver(beanFactory, reactiveRegistry));, +		registrar.add(new ExpressionValueMethodArgumentResolver(beanFactory, reactiveRegistry));, +		registrar.add(new SessionAttributeMethodArgumentResolver(beanFactory, reactiveRegistry));, +		registrar.add(new RequestAttributeMethodArgumentResolver(beanFactory, reactiveRegistry));, +, +		// Type-based..., +		registrar.addIfRequestBody(readers -> new HttpEntityArgumentResolver(readers, reactiveRegistry));, +		registrar.add(new ModelArgumentResolver(reactiveRegistry));, +		registrar.addIfModelAttribute(() -> new ErrorsMethodArgumentResolver(reactiveRegistry));, +		registrar.add(new ServerWebExchangeArgumentResolver(reactiveRegistry));, +		registrar.add(new PrincipalArgumentResolver(reactiveRegistry));, +		registrar.add(new WebSessionArgumentResolver(reactiveRegistry));, +, +		// Custom..., +		registrar.addCustomResolvers();, +, +		// Catch-all..., +		registrar.add(new RequestParamMethodArgumentResolver(beanFactory, reactiveRegistry, true));, +		registrar.addIfModelAttribute(() -> new ModelAttributeMethodArgumentResolver(reactiveRegistry, true));, +	}, +, +				this.modelAttributeAdviceCache.put(bean, attrMethods);, +				this.initBinderAdviceCache.put(bean, binderMethods);, +	 * Return an {@link InvocableHandlerMethod} for the given, +	 * {@code @RequestMapping} method initialized with argument resolvers., +	public InvocableHandlerMethod getRequestMappingMethod(HandlerMethod handlerMethod) {, +		InvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);, +		invocable.setArgumentResolvers(this.requestMappingResolvers);, +		return invocable;, +	}, +, +	/**, +	 * Find {@code @InitBinder} methods in {@code @ControllerAdvice} components, +	 * or in the controller of the given {@code @RequestMapping} method., +	 */, +	public List<SyncInvocableHandlerMethod> getInitBinderMethods(HandlerMethod handlerMethod) {]