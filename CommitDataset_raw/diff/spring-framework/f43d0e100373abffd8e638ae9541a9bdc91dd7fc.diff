[+++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +	 * If the object is not a collection or map, simply calls {@link #valueOf(Class)}., +	 * If the object is a collection or map, this factory method will derive the element type(s) by introspecting the collection or map., +		Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();, +			Class<?> superClass = currentClass.getSuperclass();, +			if (superClass != null && superClass != Object.class) {, +			for (Class<?> interfaceType : currentClass.getInterfaces()) {, +				addInterfaceHierarchy(interfaceType, interfaces);, +		}, +		for (Class<?> interfaceType : interfaces) {, +			if (interfaceType.isAssignableFrom(valueClass)) {, +				return interfaceType;, +			}			, +		}, +		return Object.class;, +	private static void addInterfaceHierarchy(Class<?> interfaceType, Set<Class<?>> interfaces) {, +		interfaces.add(interfaceType);, +		for (Class<?> inheritedInterface : interfaceType.getInterfaces()) {, +			addInterfaceHierarchy(inheritedInterface, interfaces);, +	private TypeDescriptor(Class<?> mapType, CommonElement commonKey, CommonElement commonValue) {, +	private TypeDescriptor(Class<?> collectionType, CommonElement commonElement) {, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +	 * If the object is not a collection or map, simply calls {@link #valueOf(Class)}., +	 * If the object is a collection or map, this factory method will derive the element type(s) by introspecting the collection or map., +		Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();, +			Class<?> superClass = currentClass.getSuperclass();, +			if (superClass != null && superClass != Object.class) {, +			for (Class<?> interfaceType : currentClass.getInterfaces()) {, +				addInterfaceHierarchy(interfaceType, interfaces);, +		}, +		for (Class<?> interfaceType : interfaces) {, +			if (interfaceType.isAssignableFrom(valueClass)) {, +				return interfaceType;, +			}			, +		}, +		return Object.class;, +	private static void addInterfaceHierarchy(Class<?> interfaceType, Set<Class<?>> interfaces) {, +		interfaces.add(interfaceType);, +		for (Class<?> inheritedInterface : interfaceType.getInterfaces()) {, +			addInterfaceHierarchy(inheritedInterface, interfaces);, +	private TypeDescriptor(Class<?> mapType, CommonElement commonKey, CommonElement commonValue) {, +	private TypeDescriptor(Class<?> collectionType, CommonElement commonElement) {, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java, +import java.util.HashSet;, +import java.util.LinkedHashSet;, +					logger.trace("Searching for converters indexed by source interface [" + currentClass.getName() + "]");, +		else if (sourceObjectType.isArray()) {, +					logger.trace("Searching for converters indexed by source array type [" + currentClass.getName() + "]");, +		} else {, +			HashSet<Class<?>> interfaces = new LinkedHashSet<Class<?>>();, +			LinkedList<Class<?>> classQueue = new LinkedList<Class<?>>();, +			classQueue.addFirst(sourceObjectType);, +			while (!classQueue.isEmpty()) {, +				Class<?> currentClass = classQueue.removeLast();, +				if (logger.isTraceEnabled()) {, +					logger.trace("Searching for converters indexed by source class [" + currentClass.getName() + "]");, +				}, +				Map<Class<?>, MatchableConverters> converters = getTargetConvertersForSource(currentClass);, +				GenericConverter converter = getMatchingConverterForTarget(sourceType, targetType, converters);, +				if (converter != null) {, +					return converter;, +				}, +				Class<?> superClass = currentClass.getSuperclass();, +				if (superClass != null && superClass != Object.class) {, +					classQueue.addFirst(superClass);, +				}, +				for (Class<?> interfaceType : currentClass.getInterfaces()) {, +					addInterfaceHierarchy(interfaceType, interfaces);, +				}, +			}, +			for (Class<?> interfaceType : interfaces) {, +				if (logger.isTraceEnabled()) {, +					logger.trace("Searching for converters indexed by source interface [" + interfaceType.getName() + "]");, +				}, +				Map<Class<?>, MatchableConverters> converters = getTargetConvertersForSource(interfaceType);, +				GenericConverter converter = getMatchingConverterForTarget(sourceType, targetType, converters);, +				if (converter != null) {, +					return converter;, +				}, +			}, +			Map<Class<?>, MatchableConverters> objectConverters = getTargetConvertersForSource(Object.class);, +			return getMatchingConverterForTarget(sourceType, targetType, objectConverters);				, +					logger.trace("and indexed by target class [" + currentClass.getName() + "]");, +		} else if (targetObjectType.isArray()) {, +					logger.trace("and indexed by target array type [" + currentClass.getName() + "]");, +		else {, +			Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();, +			LinkedList<Class<?>> classQueue = new LinkedList<Class<?>>();, +			classQueue.addFirst(targetObjectType);, +			while (!classQueue.isEmpty()) {, +				Class<?> currentClass = classQueue.removeLast();, +				if (logger.isTraceEnabled()) {, +					logger.trace("and indexed by target class [" + currentClass.getName() + "]");, +				}				, +				MatchableConverters matchable = converters.get(currentClass);, +				GenericConverter converter = matchConverter(matchable, sourceType, targetType);]