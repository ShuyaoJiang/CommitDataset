[+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, + * Copyright 2002-2014 the original author or authors., +import java.util.LinkedList;, + * @author Stephane Nicoll, +		// Check if we have a cached item matching the conditions, +		Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));, +		// Collect puts from any @Cacheable miss, if no cached item is found, +		List<CachePutRequest> cachePutRequests = new LinkedList<CachePutRequest>();, +		if (cacheHit == null) {, +			collectPutRequests(contexts.get(CacheableOperation.class), ExpressionEvaluator.NO_RESULT, cachePutRequests);, +		}, +		Cache.ValueWrapper result = null;, +, +		// If there are no put requests, just use the cache hit, +			result = cacheHit;, +		collectPutRequests(contexts.get(CachePutOperation.class), result.get(), cachePutRequests);, +	/**, +	 * Find a cached item only for {@link CacheableOperation} that passes the condition., +	 * @param contexts the cacheable operations, +	 * @return a {@link Cache.ValueWrapper} holding the cached item,, +	 * or {@code null} if none is found, +	 */, +	private Cache.ValueWrapper findCachedItem(Collection<CacheOperationContext> contexts) {, +		Object result = ExpressionEvaluator.NO_RESULT;, +		for (CacheOperationContext context : contexts) {, +			if (isConditionPassing(context, result)) {, +				Object key = generateKey(context, result);, +				Cache.ValueWrapper cached = findInCaches(context, key);, +				if (cached != null) {, +					return cached;, +				}, +			}, +		}, +		return null;, +	}, +, +	/**, +	 * Collect the {@link CachePutRequest} for all {@link CacheOperation} using, +	 * the specified result item., +	 * @param contexts the contexts to handle, +	 * @param result the result item (never {@code null}), +	 * @param putRequests the collection to update, +	 */, +			Object result, Collection<CachePutRequest> putRequests) {, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, + * Copyright 2002-2014 the original author or authors., +import java.util.LinkedList;, + * @author Stephane Nicoll, +		// Check if we have a cached item matching the conditions, +		Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));, +		// Collect puts from any @Cacheable miss, if no cached item is found, +		List<CachePutRequest> cachePutRequests = new LinkedList<CachePutRequest>();, +		if (cacheHit == null) {, +			collectPutRequests(contexts.get(CacheableOperation.class), ExpressionEvaluator.NO_RESULT, cachePutRequests);, +		}, +		Cache.ValueWrapper result = null;, +, +		// If there are no put requests, just use the cache hit, +			result = cacheHit;, +		collectPutRequests(contexts.get(CachePutOperation.class), result.get(), cachePutRequests);, +	/**, +	 * Find a cached item only for {@link CacheableOperation} that passes the condition., +	 * @param contexts the cacheable operations, +	 * @return a {@link Cache.ValueWrapper} holding the cached item,, +	 * or {@code null} if none is found, +	 */, +	private Cache.ValueWrapper findCachedItem(Collection<CacheOperationContext> contexts) {, +		Object result = ExpressionEvaluator.NO_RESULT;, +		for (CacheOperationContext context : contexts) {, +			if (isConditionPassing(context, result)) {, +				Object key = generateKey(context, result);, +				Cache.ValueWrapper cached = findInCaches(context, key);, +				if (cached != null) {, +					return cached;, +				}, +			}, +		}, +		return null;, +	}, +, +	/**, +	 * Collect the {@link CachePutRequest} for all {@link CacheOperation} using, +	 * the specified result item., +	 * @param contexts the contexts to handle, +	 * @param result the result item (never {@code null}), +	 * @param putRequests the collection to update, +	 */, +			Object result, Collection<CachePutRequest> putRequests) {, +++ b/spring-context/src/test/java/org/springframework/cache/CacheReproTests.java, + * Copyright 2002-2014 the original author or authors., +import java.util.Arrays;, +import org.mockito.Mockito;, +import org.springframework.cache.concurrent.ConcurrentMapCache;, +import org.springframework.cache.support.SimpleCacheManager;, +import static org.mockito.Mockito.*;, + * @author Stephane Nicoll, +	@Test, +	public void spr11595GetSimple() {, +		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Spr11595Config.class);, +		Spr11595Service bean = context.getBean(Spr11595Service.class);]