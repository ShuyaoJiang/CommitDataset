[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, + * @author Juergen Hoeller, +	 * Should preferably return an {@link AsyncListenableTaskExecutor} implementation., +			executor = (executorToUse instanceof AsyncListenableTaskExecutor ?, +					(AsyncListenableTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, + * @author Juergen Hoeller, +	 * Should preferably return an {@link AsyncListenableTaskExecutor} implementation., +			executor = (executorToUse instanceof AsyncListenableTaskExecutor ?, +					(AsyncListenableTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, +import org.springframework.util.concurrent.ListenableFuture;, +		Callable<Object> task = new Callable<Object>() {, +		};, +		Class<?> returnType = invocation.getMethod().getReturnType();, +		if (ListenableFuture.class.isAssignableFrom(returnType)) {, +			return ((AsyncListenableTaskExecutor) executor).submitListenable(task);, +		}, +		else if (Future.class.isAssignableFrom(returnType)) {, +			return executor.submit(task);, +			executor.submit(task);, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, + * @author Juergen Hoeller, +	 * Should preferably return an {@link AsyncListenableTaskExecutor} implementation., +			executor = (executorToUse instanceof AsyncListenableTaskExecutor ?, +					(AsyncListenableTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, +import org.springframework.util.concurrent.ListenableFuture;, +		Callable<Object> task = new Callable<Object>() {, +		};, +		Class<?> returnType = invocation.getMethod().getReturnType();, +		if (ListenableFuture.class.isAssignableFrom(returnType)) {, +			return ((AsyncListenableTaskExecutor) executor).submitListenable(task);, +		}, +		else if (Future.class.isAssignableFrom(returnType)) {, +			return executor.submit(task);, +			executor.submit(task);, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncResult.java, + * Copyright 2002-2014 the original author or authors., +import org.springframework.util.concurrent.ListenableFuture;, +import org.springframework.util.concurrent.ListenableFutureCallback;, +, + * which are declared with a {@code Future} return type for asynchronous execution., + *, + * <p>As of Spring 4.1, this class implements {@link ListenableFuture}, not just, + * plain {@link java.util.concurrent.Future}, along with the corresponding support, + * in {@code @Async} processing., +public class AsyncResult<V> implements ListenableFuture<V> {, +, +	@Override, +	public void addCallback(ListenableFutureCallback<? super V> callback) {, +		callback.onSuccess(this.value);, +	}, +, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, + * @author Juergen Hoeller, +	 * Should preferably return an {@link AsyncListenableTaskExecutor} implementation., +			executor = (executorToUse instanceof AsyncListenableTaskExecutor ?, +					(AsyncListenableTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, +import org.springframework.core.task.AsyncListenableTaskExecutor;, +import org.springframework.util.concurrent.ListenableFuture;, +		Callable<Object> task = new Callable<Object>() {, +		};, +		Class<?> returnType = invocation.getMethod().getReturnType();, +		if (ListenableFuture.class.isAssignableFrom(returnType)) {, +			return ((AsyncListenableTaskExecutor) executor).submitListenable(task);, +		}, +		else if (Future.class.isAssignableFrom(returnType)) {, +			return executor.submit(task);, +			executor.submit(task);, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncResult.java, + * Copyright 2002-2014 the original author or authors., +import org.springframework.util.concurrent.ListenableFuture;, +import org.springframework.util.concurrent.ListenableFutureCallback;, +, + * which are declared with a {@code Future} return type for asynchronous execution., + *, + * <p>As of Spring 4.1, this class implements {@link ListenableFuture}, not just, + * plain {@link java.util.concurrent.Future}, along with the corresponding support, + * in {@code @Async} processing., +public class AsyncResult<V> implements ListenableFuture<V> {, +, +	@Override, +	public void addCallback(ListenableFutureCallback<? super V> callback) {, +		callback.onSuccess(this.value);, +	}, +, +++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java, +import org.springframework.util.concurrent.ListenableFuture;, +		ListenableFuture<String> listenableFuture = asyncTest.returnSomethingListenable(20);, +		assertEquals("20", listenableFuture.get());, +		ListenableFuture<String> listenableFuture = asyncTest.returnSomethingListenable(20);, +		assertEquals("20", listenableFuture.get());]