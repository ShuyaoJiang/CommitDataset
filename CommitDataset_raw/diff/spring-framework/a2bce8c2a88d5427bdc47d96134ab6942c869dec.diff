[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/QualifiedIdentifier.java, +				Object value = children[i].getValueInternal(state).getValue();, +				if (i > 0 && !value.toString().startsWith("$")) {, +				sb.append(value);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/QualifiedIdentifier.java, +				Object value = children[i].getValueInternal(state).getValue();, +				if (i > 0 && !value.toString().startsWith("$")) {, +				sb.append(value);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +			SpelNodeImpl node = eatPossiblyQualifiedId(true);, +	/**, +	 * Eat an identifier, possibly qualified (meaning that it is dotted).  If the dollarAllowed parameter is true then, +	 * it will process any dollar characters found between names, and this allows it to support inner type references, +	 * correctly.  For example 'com.foo.bar.Outer$Inner' will produce the identifier sequence com, foo, bar, Outer, $Inner,, +	 * note that the $ has been prefixed onto the Inner identifier.  The code in TypeReference which reforms this into, +	 * a typename copes with the $ prefixed identifiers., +	 * TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c), +	 */, +	private SpelNodeImpl eatPossiblyQualifiedId(boolean dollarAllowed) {, +		boolean dollar = false;, +		while (peekToken(TokenKind.DOT,true) || (dollarAllowed && (dollar = peekToken(TokenKind.DOLLAR,true)))) {, +			if (dollar) {, +				qualifiedIdPieces.add(new Identifier("$"+node.stringValue(),((node.startpos-1)<<16)+node.endpos));			, +			} else {, +		}, +			SpelNodeImpl possiblyQualifiedConstructorName = eatPossiblyQualifiedId(true);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/QualifiedIdentifier.java, +				Object value = children[i].getValueInternal(state).getValue();, +				if (i > 0 && !value.toString().startsWith("$")) {, +				sb.append(value);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +			SpelNodeImpl node = eatPossiblyQualifiedId(true);, +	/**, +	 * Eat an identifier, possibly qualified (meaning that it is dotted).  If the dollarAllowed parameter is true then, +	 * it will process any dollar characters found between names, and this allows it to support inner type references, +	 * correctly.  For example 'com.foo.bar.Outer$Inner' will produce the identifier sequence com, foo, bar, Outer, $Inner,, +	 * note that the $ has been prefixed onto the Inner identifier.  The code in TypeReference which reforms this into, +	 * a typename copes with the $ prefixed identifiers., +	 * TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c), +	 */, +	private SpelNodeImpl eatPossiblyQualifiedId(boolean dollarAllowed) {, +		boolean dollar = false;, +		while (peekToken(TokenKind.DOT,true) || (dollarAllowed && (dollar = peekToken(TokenKind.DOLLAR,true)))) {, +			if (dollar) {, +				qualifiedIdPieces.add(new Identifier("$"+node.stringValue(),((node.startpos-1)<<16)+node.endpos));			, +			} else {, +		}, +			SpelNodeImpl possiblyQualifiedConstructorName = eatPossiblyQualifiedId(true);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/SpringEL300Tests.java, +			if (typename.equals("Outer")) {, +				return Outer.class;, +			}, +	@Test, +	public void testSPR5905_InnerTypeReferences() throws Exception {, +		StandardEvaluationContext eContext = new StandardEvaluationContext(new Spr5899Class());, +		Expression expr = new SpelExpressionParser().parse("T(java.util.Map$Entry)");, +		Assert.assertEquals(Map.Entry.class,expr.getValue(eContext));, +, +		expr = new SpelExpressionParser().parse("T(org.springframework.expression.spel.SpringEL300Tests$Outer$Inner).run()");, +		Assert.assertEquals(12,expr.getValue(eContext));, +, +		expr = new SpelExpressionParser().parse("new org.springframework.expression.spel.SpringEL300Tests$Outer$Inner().run2()");, +		Assert.assertEquals(13,expr.getValue(eContext));, +}, +	, +	static class Outer {, +		static class Inner {, +			public Inner() {}, +			public static int run() {, +				return 12;, +			}, +			public int run2() {, +				return 13;, +			}, +		}, +	}, +]