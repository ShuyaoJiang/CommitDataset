[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, + * Copyright 2002-2013 the original author or authors., +	public final String getName() {, +		return this.name;, +				arguments[i] = this.children[i].getValueInternal(state).getValue();, +			if (this.nullSafe) {, +						FormatHelper.formatMethodForMessage(this.name, getTypes(arguments)));, +				arguments[i] = this.children[i].getValueInternal(state).getValue();, +						FormatHelper.formatMethodForMessage(this.name, getTypes(arguments)));, +		}, +		catch (AccessException ae) {, +		sb.append(this.name).append("(");, +	private MethodExecutor findAccessorForMethod(String name, List<TypeDescriptor> argumentTypes, ExpressionState state), +, +					MethodExecutor cEx = methodResolver.resolve(eContext, contextObject, name, argumentTypes);, +					throw new SpelEvaluationException(getStartPosition(),ex, SpelMessage.PROBLEM_LOCATING_METHOD,, +							name, contextObject.getClass());, +		throw new SpelEvaluationException(getStartPosition(),SpelMessage.METHOD_NOT_FOUND,, +				FormatHelper.formatMethodForMessage(name, argumentTypes),, +, +	private class MethodValueRef implements ValueRef {, +, +		private final ExpressionState state;, +, +		private final EvaluationContext evaluationContext;, +, +		private final Object target;, +, +		private final Object[] arguments;, +, +		MethodValueRef(ExpressionState state, EvaluationContext evaluationContext, Object object, Object[] arguments) {, +			this.state = state;, +			this.evaluationContext = evaluationContext;, +			this.target = object;, +			this.arguments = arguments;, +		}, +, +		public TypedValue getValue() {, +			MethodExecutor executorToUse = cachedExecutor;, +			if (executorToUse != null) {, +				try {, +					return executorToUse.execute(this.evaluationContext, this.target, this.arguments);, +				}, +				catch (AccessException ae) {, +					// Two reasons this can occur:, +					// 1. the method invoked actually threw a real exception, +					// 2. the method invoked was not passed the arguments it expected and has become 'stale', +, +					// In the first case we should not retry, in the second case we should see if there is a, +					// better suited method., +, +					// To determine which situation it is, the AccessException will contain a cause., +					// If the cause is an InvocationTargetException, a user exception was thrown inside the method., +					// Otherwise the method could not be invoked., +					throwSimpleExceptionIfPossible(this.state, ae);, +, +					// at this point we know it wasn't a user problem so worth a retry if a better candidate can be found, +					cachedExecutor = null;, +				}, +			}, +, +			// either there was no accessor or it no longer existed, +			executorToUse = findAccessorForMethod(name, getTypes(this.arguments), this.target, this.evaluationContext);, +			cachedExecutor = executorToUse;, +			try {, +				return executorToUse.execute(this.evaluationContext, this.target, this.arguments);, +			}, +			catch (AccessException ae) {, +				// Same unwrapping exception handling as above in above catch block, +				throwSimpleExceptionIfPossible(this.state, ae);, +				throw new SpelEvaluationException( getStartPosition(), ae, SpelMessage.EXCEPTION_DURING_METHOD_INVOCATION,, +						name, this.state.getActiveContextObject().getValue().getClass().getName(), ae.getMessage());, +			}, +		}, +, +		public void setValue(Object newValue) {, +			throw new IllegalAccessError();, +		}, +, +		public boolean isWritable() {, +			return false;, +		}, +	}, +]