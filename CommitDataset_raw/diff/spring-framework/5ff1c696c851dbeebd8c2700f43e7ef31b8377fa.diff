[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	 * Determine whether this {@code ResolvableType} is assignable from the, +	 * specified other type., +	 * <p>Attempts to follow the same rules as the Java compiler, considering, +	 * whether both the {@link #resolve() resolved} {@code Class} is, +	 * {@link Class#isAssignableFrom(Class) assignable from} the given type, +	 * as well as whether all {@link #getGenerics() generics} are assignable., +	 * @param other the type to be checked against, +	 * @return {@code true} if the specified other type can be assigned to this, +	 * {@code ResolvableType}; {@code false} otherwise, +	public boolean isAssignableFrom(ResolvableType other) {, +		return isAssignableFrom(other, null);, +	private boolean isAssignableFrom(ResolvableType other, Map<Type, Type> matchedBefore) {, +		Assert.notNull(other, "ResolvableType must not be null");, +		if (this == NONE || other == NONE) {, +			return (other.isArray() && getComponentType().isAssignableFrom(other.getComponentType()));, +		if (matchedBefore != null && matchedBefore.get(this.type) == other.type) {, +		WildcardBounds typeBounds = WildcardBounds.get(other);, +			return ourBounds.isAssignableFrom(other);, +				if (other.variableResolver != null) {, +					ResolvableType resolved = other.variableResolver.resolveVariable(variable);, +		Class<?> otherResolved = other.resolve(Object.class);, +		if (exactMatch ? !ourResolved.equals(otherResolved) : !ClassUtils.isAssignable(ourResolved, otherResolved)) {, +			ResolvableType[] typeGenerics = other.as(ourResolved).getGenerics();, +				matchedBefore = new IdentityHashMap<Type, Type>(1);, +			matchedBefore.put(this.type, other.type);, +	 * Convenience method that will {@link #getGenerics() get} and, +	 * {@link #resolve() resolve} generic parameters., +	 * @return an array of resolved generic parameters (the resulting array, +	 * will never be {@code null}, but it may contain {@code null} elements})]