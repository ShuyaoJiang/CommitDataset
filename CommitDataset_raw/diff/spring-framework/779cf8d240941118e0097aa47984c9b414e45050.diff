[+++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, +	private volatile Set<Map.Entry<K, V>> entrySet;, +	public ConcurrentReferenceHashMap(, +			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {, +		int hash = (o != null ? o.hashCode() : 0);, +		Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);, +		return (ref != null ? ref.get() : null);, +			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {, +			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {, +					if (ref != null) {, +						ref.release();, +			protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {, +					if (ref != null) {, +						ref.release();, +			protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {, +			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {, +	public boolean isEmpty() {, +		for (Segment segment : this.segments) {, +			if (segment.getCount() > 0) {, +				return false;, +		}, +		return true;, +	}, +, +	@Override, +	public Set<Map.Entry<K, V>> entrySet() {, +		Set<Map.Entry<K, V>> entrySet = this.entrySet;, +		if (entrySet == null) {, +			entrySet = new EntrySet();, +			this.entrySet = entrySet;, +		}, +		return entrySet;, +				Reference<K, V> ref = findInChain(head, key, hash);, +				Entry<K, V> entry = (ref != null ? ref.get() : null);, +				return task.execute(ref, entry, entries);, +			boolean needsResize = (this.count > 0 && this.count >= this.resizeThreshold);, +			Reference<K, V> ref = this.referenceManager.pollForPurge();, +			if (ref != null || (needsResize && allowResize)) {, +					if (ref != null) {, +						while (ref != null) {, +							toPurge.add(ref);, +							ref = this.referenceManager.pollForPurge();, +					Reference<K, V>[] restructured =, +							(resizing ? createReferenceArray(restructureSize) : this.references);, +						ref = this.references[i];, +						while (ref != null) {, +							if (!toPurge.contains(ref)) {, +								Entry<K, V> entry = ref.get();, +									int index = getIndex(ref.getHash(), restructured);, +											entry, ref.getHash(), restructured[index]);, +							ref = ref.getNext();, +		private Reference<K, V> findInChain(Reference<K, V> ref, @Nullable Object key, int hash) {, +			Reference<K, V> currRef = ref;, +		 * @param ref the found reference (or {@code null}), +		 * @param entry the found entry (or {@code null}), +		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {, +			return execute(ref, entry);, +		 * @param ref the found reference (or {@code null}), +		 * @param entry the found entry (or {@code null}), +		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {, +				Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;, +				Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);, +				Entry<K, V> otherEntry = (ref != null ? ref.get() : null);, +	 * Internal {@link Reference} implementation for {@link SoftReference SoftReferences}., +	 * Internal {@link Reference} implementation for {@link WeakReference WeakReferences}.]