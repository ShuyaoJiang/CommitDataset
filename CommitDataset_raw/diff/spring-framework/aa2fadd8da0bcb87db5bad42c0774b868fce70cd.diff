[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	/**, +	 * Copy of the resolved value., +	 */, +	private final Class<?> resolved;, +, +		this.resolved = resolveClass();, +		return (source != null ? source : this.type);, +		// In the from X is assignable to <? extends Number>, +		// In the form <? extends Number> is assignable to X..., +		// Main assignability check about to follow, +		boolean checkGenerics = true;, +		Class<?> ourResolved = null;, +		if (this.type instanceof TypeVariable) {, +			TypeVariable<?> variable = (TypeVariable<?>) this.type;, +			// Try default variable resolution, +			if (this.variableResolver != null) {, +				ResolvableType resolved = this.variableResolver.resolveVariable(variable);, +				if (resolved != null) {, +					ourResolved = resolved.resolve();, +				}, +			}, +			if (ourResolved == null) {, +				// Try variable resolution against target type, +				if (type.variableResolver != null) {, +					ResolvableType resolved = type.variableResolver.resolveVariable(variable);, +					if (resolved != null) {, +						ourResolved = resolved.resolve();, +						checkGenerics = false;, +					}, +				}, +			}, +		}, +		if (ourResolved == null) {, +			ourResolved = resolve(Object.class);, +		}, +		Class<?> typeResolved = type.resolve(Object.class);, +		if (checkingGeneric ? !ourResolved.equals(typeResolved) : !ourResolved.isAssignableFrom(typeResolved)) {, +			return false;, +		if (checkGenerics) {, +			// Recursively check each generic, +			ResolvableType[] ourGenerics = getGenerics();, +			ResolvableType[] typeGenerics = type.as(ourResolved).getGenerics();, +			if (ourGenerics.length != typeGenerics.length) {, +				return false;, +			}, +			for (int i = 0; i < ourGenerics.length; i++) {, +				if (!ourGenerics[i].isAssignableFrom(typeGenerics[i], true)) {, +					return false;, +				}, +			}, +		}, +, +		return true;, +	 * Return {@code true} if this type resolves to a Class that represents an array., +		return (((this.type instanceof Class && ((Class<?>) this.type).isArray())) ||, +				this.type instanceof GenericArrayType || resolveType().isArray());, +	 * <p>Note: The returned {@link ResolvableType} should only be used as an intermediary, +	 * as it cannot be serialized., +	 * Return a String representation of this type in its fully resolved form, +		if (this.resolved == null) {, +			return "?";, +		}, +		if (this.type instanceof TypeVariable) {, +			TypeVariable<?> variable = (TypeVariable<?>) this.type;, +			if (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {, +				// Don't bother with variable boundaries for toString()..., +				// Can cause infinite recursions in case of self-references, +				return "?";, +			}, +		}, +		StringBuilder result = new StringBuilder(this.resolved.getName());, +		return ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), other.getSource());, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	/**, +	 * Copy of the resolved value., +	 */, +	private final Class<?> resolved;, +, +		this.resolved = resolveClass();, +		return (source != null ? source : this.type);, +		// In the from X is assignable to <? extends Number>, +		// In the form <? extends Number> is assignable to X..., +		// Main assignability check about to follow, +		boolean checkGenerics = true;, +		Class<?> ourResolved = null;, +		if (this.type instanceof TypeVariable) {, +			TypeVariable<?> variable = (TypeVariable<?>) this.type;, +			// Try default variable resolution, +			if (this.variableResolver != null) {, +				ResolvableType resolved = this.variableResolver.resolveVariable(variable);, +				if (resolved != null) {, +					ourResolved = resolved.resolve();, +				}, +			}, +			if (ourResolved == null) {, +				// Try variable resolution against target type, +				if (type.variableResolver != null) {, +					ResolvableType resolved = type.variableResolver.resolveVariable(variable);, +					if (resolved != null) {]