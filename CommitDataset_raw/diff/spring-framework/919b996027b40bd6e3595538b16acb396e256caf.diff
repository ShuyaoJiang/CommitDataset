[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.java, +	private Map<Class<?>, PropertyEditor> defaultEditors;, +	private Map<Class<?>, PropertyEditor> overriddenDefaultEditors;, +	private Map<Class<?>, PropertyEditor> customEditors;, +	private Map<Class<?>, PropertyEditor> customEditorCache;, +	public void overrideDefaultEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +			this.overriddenDefaultEditors = new HashMap<Class<?>, PropertyEditor>();, +	public PropertyEditor getDefaultEditor(Class<?> requiredType) {, +		this.defaultEditors = new HashMap<Class<?>, PropertyEditor>(64);, +	public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public void registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor) {, +				this.customEditors = new LinkedHashMap<Class<?>, PropertyEditor>(16);, +	public void registerSharedEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public PropertyEditor findCustomEditor(Class<?> requiredType, String propertyPath) {, +		Class<?> requiredTypeToUse = requiredType;, +	public boolean hasCustomEditorForElement(Class<?> elementType, String propertyPath) {, +	protected Class<?> getPropertyType(String propertyPath) {, +	private PropertyEditor getCustomEditor(String propertyName, Class<?> requiredType) {, +	private PropertyEditor getCustomEditor(Class<?> requiredType) {, +				for (Iterator<Class<?>> it = this.customEditors.keySet().iterator(); it.hasNext() && editor == null;) {, +					Class<?> key = it.next();, +							this.customEditorCache = new HashMap<Class<?>, PropertyEditor>();, +	protected Class<?> guessPropertyTypeFromEditors(String propertyName) {, +			for (Map.Entry<Class<?>, PropertyEditor> entry : this.customEditors.entrySet()) {, +		private final Class<?> registeredType;, +		private CustomEditorHolder(PropertyEditor propertyEditor, Class<?> registeredType) {, +		private Class<?> getRegisteredType() {, +		private PropertyEditor getPropertyEditor(Class<?> requiredType) {, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.java, +	private Map<Class<?>, PropertyEditor> defaultEditors;, +	private Map<Class<?>, PropertyEditor> overriddenDefaultEditors;, +	private Map<Class<?>, PropertyEditor> customEditors;, +	private Map<Class<?>, PropertyEditor> customEditorCache;, +	public void overrideDefaultEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +			this.overriddenDefaultEditors = new HashMap<Class<?>, PropertyEditor>();, +	public PropertyEditor getDefaultEditor(Class<?> requiredType) {, +		this.defaultEditors = new HashMap<Class<?>, PropertyEditor>(64);, +	public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public void registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor) {, +				this.customEditors = new LinkedHashMap<Class<?>, PropertyEditor>(16);, +	public void registerSharedEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public PropertyEditor findCustomEditor(Class<?> requiredType, String propertyPath) {, +		Class<?> requiredTypeToUse = requiredType;, +	public boolean hasCustomEditorForElement(Class<?> elementType, String propertyPath) {, +	protected Class<?> getPropertyType(String propertyPath) {, +	private PropertyEditor getCustomEditor(String propertyName, Class<?> requiredType) {, +	private PropertyEditor getCustomEditor(Class<?> requiredType) {, +				for (Iterator<Class<?>> it = this.customEditors.keySet().iterator(); it.hasNext() && editor == null;) {, +					Class<?> key = it.next();, +							this.customEditorCache = new HashMap<Class<?>, PropertyEditor>();, +	protected Class<?> guessPropertyTypeFromEditors(String propertyName) {, +			for (Map.Entry<Class<?>, PropertyEditor> entry : this.customEditors.entrySet()) {, +		private final Class<?> registeredType;, +		private CustomEditorHolder(PropertyEditor propertyEditor, Class<?> registeredType) {, +		private Class<?> getRegisteredType() {, +		private PropertyEditor getPropertyEditor(Class<?> requiredType) {, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/support/ResourceEditorRegistrar.java, +	 * {@link #ResourceEditorRegistrar(ResourceLoader, Environment)}, +	 * Populate the given <code>registry</code> with the following resource editors:, +	 * ResourceEditor, InputStreamEditor, InputSourceEditor, FileEditor, URLEditor,, +	 * URIEditor, ClassEditor, ClassArrayEditor., +	 * <p>If this registrar has been configured with a {@link ResourcePatternResolver},, +	 * @see org.springframework.beans.propertyeditors.InputSourceEditor, +	 * @see org.springframework.beans.propertyeditors.ClassEditor, +	 * @see org.springframework.beans.propertyeditors.ClassArrayEditor, +	private void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.java, +	private Map<Class<?>, PropertyEditor> defaultEditors;, +	private Map<Class<?>, PropertyEditor> overriddenDefaultEditors;, +	private Map<Class<?>, PropertyEditor> customEditors;, +	private Map<Class<?>, PropertyEditor> customEditorCache;, +	public void overrideDefaultEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +			this.overriddenDefaultEditors = new HashMap<Class<?>, PropertyEditor>();, +	public PropertyEditor getDefaultEditor(Class<?> requiredType) {, +		this.defaultEditors = new HashMap<Class<?>, PropertyEditor>(64);, +	public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public void registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor) {, +				this.customEditors = new LinkedHashMap<Class<?>, PropertyEditor>(16);, +	public void registerSharedEditor(Class<?> requiredType, PropertyEditor propertyEditor) {, +	public PropertyEditor findCustomEditor(Class<?> requiredType, String propertyPath) {, +		Class<?> requiredTypeToUse = requiredType;, +	public boolean hasCustomEditorForElement(Class<?> elementType, String propertyPath) {, +	protected Class<?> getPropertyType(String propertyPath) {, +	private PropertyEditor getCustomEditor(String propertyName, Class<?> requiredType) {, +	private PropertyEditor getCustomEditor(Class<?> requiredType) {, +				for (Iterator<Class<?>> it = this.customEditors.keySet().iterator(); it.hasNext() && editor == null;) {, +					Class<?> key = it.next();, +							this.customEditorCache = new HashMap<Class<?>, PropertyEditor>();, +	protected Class<?> guessPropertyTypeFromEditors(String propertyName) {, +			for (Map.Entry<Class<?>, PropertyEditor> entry : this.customEditors.entrySet()) {, +		private final Class<?> registeredType;, +		private CustomEditorHolder(PropertyEditor propertyEditor, Class<?> registeredType) {, +		private Class<?> getRegisteredType() {, +		private PropertyEditor getPropertyEditor(Class<?> requiredType) {, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/support/ResourceEditorRegistrar.java, +	 * {@link #ResourceEditorRegistrar(ResourceLoader, Environment)}, +	 * Populate the given <code>registry</code> with the following resource editors:, +	 * ResourceEditor, InputStreamEditor, InputSourceEditor, FileEditor, URLEditor,, +	 * URIEditor, ClassEditor, ClassArrayEditor., +	 * <p>If this registrar has been configured with a {@link ResourcePatternResolver},]