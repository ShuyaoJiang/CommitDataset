[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +import org.springframework.util.ClassUtils;, +		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);, +		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);, +, +		Future<?> result = determineAsyncExecutor(specificMethod).submit(, +, +	 * This implementation is a no-op for compatibility in Spring 3.1.2., +	 * Subclasses may override to provide support for extracting qualifier information,, +	 * e.g. via an annotation on the given method., +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +import org.springframework.util.ClassUtils;, +		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);, +		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);, +, +		Future<?> result = determineAsyncExecutor(specificMethod).submit(, +, +	 * This implementation is a no-op for compatibility in Spring 3.1.2., +	 * Subclasses may override to provide support for extracting qualifier information,, +	 * e.g. via an annotation on the given method., +++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj, + * @author Juergen Hoeller, +	 * Construct the aspect using the given transaction metadata retrieval strategy., +	 * transaction metadata for each joinpoint. Implement the subclass to pass in, +	 * {@code null} if it is intended to be configured through Setter Injection., +	Object around(final Object txObject): transactionalMethodExecution(txObject) {, +		// Adapt to TransactionAspectSupport's invokeWithinTransaction..., +			return invokeWithinTransaction(methodSignature.getMethod(), txObject.getClass(), new InvocationCallback() {, +				public Object proceedWithInvocation() throws Throwable {, +					return proceed(txObject);, +			});, +		catch (RuntimeException ex) {, +			throw ex;, +		catch (Error err) {, +			throw err;, +		catch (Throwable thr) {, +			Rethrower.rethrow(thr);, +			throw new IllegalStateException("Should never get here", thr);]