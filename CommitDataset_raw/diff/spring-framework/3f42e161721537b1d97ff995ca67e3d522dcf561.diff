[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/HandlerMethod.java, +import java.util.stream.Collectors;, +import java.util.stream.IntStream;, +import org.springframework.util.ObjectUtils;, +import org.springframework.util.StringUtils;, +	// Support methods for use in "InvocableHandlerMethod" sub-class variants.., +, +	@Nullable, +	protected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {, +		if (!ObjectUtils.isEmpty(providedArgs)) {, +			for (Object providedArg : providedArgs) {, +				if (parameter.getParameterType().isInstance(providedArg)) {, +					return providedArg;, +				}, +			}, +		}, +		return null;, +	}, +, +	protected static String formatArgumentError(MethodParameter param, String message) {, +		return "Could not resolve parameter [" + param.getParameterIndex() + "] in " +, +				param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? ": " + message : "");, +	}, +, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual endpoint instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). Endpoint classes that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	protected void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String text = "The mapped handler method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual endpoint bean class '" +, +					targetBeanClass.getName() + "'. If the endpoint requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalStateException(formatInvokeError(text, args));, +		}, +	}, +, +	protected String formatInvokeError(String text, Object[] args) {, +, +		String formattedArgs = IntStream.range(0, args.length), +				.mapToObj(i -> (args[i] != null ?, +						"[" + i + "] [type=" + args[i].getClass().getName() + "] [value=" + args[i] + "]" :, +						"[" + i + "] [null]")), +				.collect(Collectors.joining(",\n", " ", " "));, +, +		return text + "\n" +, +				"Endpoint [" + getBeanType().getName() + "]\n" +, +				"Method [" + getBridgedMethod().toGenericString() + "] " +, +				"with argument values:\n" + formattedArgs;, +	}, +, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/HandlerMethod.java, +import java.util.stream.Collectors;, +import java.util.stream.IntStream;, +import org.springframework.util.ObjectUtils;, +import org.springframework.util.StringUtils;, +	// Support methods for use in "InvocableHandlerMethod" sub-class variants.., +, +	@Nullable, +	protected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {, +		if (!ObjectUtils.isEmpty(providedArgs)) {, +			for (Object providedArg : providedArgs) {, +				if (parameter.getParameterType().isInstance(providedArg)) {, +					return providedArg;, +				}, +			}, +		}, +		return null;, +	}, +, +	protected static String formatArgumentError(MethodParameter param, String message) {, +		return "Could not resolve parameter [" + param.getParameterIndex() + "] in " +, +				param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? ": " + message : "");, +	}, +, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual endpoint instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). Endpoint classes that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	protected void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String text = "The mapped handler method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual endpoint bean class '" +, +					targetBeanClass.getName() + "'. If the endpoint requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalStateException(formatInvokeError(text, args));, +		}, +	}]