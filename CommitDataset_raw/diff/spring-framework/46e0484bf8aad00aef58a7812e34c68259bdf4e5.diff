[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, + * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},, +				searchWithGetSemantics(annotation.annotationType(), annotationType, null, null,, +					new SimpleAnnotationProcessor<Object>() {, +				searchWithGetSemantics(annotation.annotationType(), null, annotationName, null,, +					new SimpleAnnotationProcessor<Object>() {, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>The container type that holds the repeatable annotations will be looked up, +	 * via {@link java.lang.annotation.Repeatable}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @return the set of all merged repeatable {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #getMergedAnnotation(AnnotatedElement, Class), +	 * @see #getAllMergedAnnotations(AnnotatedElement, Class), +	 * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class), +	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}, +	 * is {@code null}, or if the container type cannot be resolved, +	 */, +	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +, +		return getMergedRepeatableAnnotations(element, annotationType, null);, +	}, +, +	/**, +	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @param containerType the type of the container that holds the annotations;, +	 * may be {@code null} if the container type should be looked up via, +	 * {@link java.lang.annotation.Repeatable}, +	 * @return the set of all merged repeatable {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #getMergedAnnotation(AnnotatedElement, Class), +	 * @see #getAllMergedAnnotations(AnnotatedElement, Class), +	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}, +	 * is {@code null}, or if the container type cannot be resolved, +	 * @throws AnnotationConfigurationException if the supplied {@code containerType}, +	 * is not a valid container annotation for the supplied {@code annotationType}, +	 */, +	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType, Class<? extends Annotation> containerType) {, +, +		Assert.notNull(element, "AnnotatedElement must not be null");, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		if (containerType == null) {, +			containerType = resolveContainerType(annotationType);, +		}, +		else {, +			validateRepeatableContainerType(annotationType, containerType);, +		}, +, +		MergedAnnotationAttributesProcessor processor =, +				new MergedAnnotationAttributesProcessor(annotationType, null, false, false, true);, +		searchWithGetSemantics(element, annotationType, null, containerType, processor);, +		return postProcessAndSynthesizeAggregatedResults(element, annotationType, processor.getAggregatedResults());, +	}, +, +	/**, +	private static <T> T searchWithGetSemantics(AnnotatedElement element, Class<? extends Annotation> annotationType,, +			String annotationName, Processor<T> processor) {, +, +		return searchWithGetSemantics(element, annotationType, annotationName, null, processor);, +	}, +, +	/**, +	 * Search for annotations of the specified {@code annotationName} or, +	 * {@code annotationType} on the specified {@code element}, following, +	 * <em>get semantics</em>., +	 * @param element the annotated element, +	 * @param annotationType the annotation type to find, +	 * @param annotationName the fully qualified class name of the annotation, +	 * type to find (as an alternative to {@code annotationType}), +	 * @param containerType the type of the container that holds repeatable, +	 * annotations, or {@code null} if the annotation is not repeatable, +	 * @param processor the processor to delegate to, +	 * @return the result of the processor, potentially {@code null}]