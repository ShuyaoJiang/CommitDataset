[+++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpConnector.java, +import reactor.ipc.netty.http.client.HttpClientRequest;, +import reactor.ipc.netty.http.client.HttpClientResponse;, +	private static final Mono<ClientHttpResponse> NO_CLIENT_RESPONSE_ERROR = Mono.error(, +			new IllegalStateException("HttpClient completed without a response. " +, +					"As a temporary workaround try to disable connection pool. " +, +					"See https://github.com/reactor/reactor-netty/issues/138."));, +, +, +				.request(adaptHttpMethod(method),, +						request -> requestCallback.apply(adaptRequest(method, uri, request))), +				.map(this::adaptResponse), +				.switchIfEmpty(NO_CLIENT_RESPONSE_ERROR);, +	}, +, +	private io.netty.handler.codec.http.HttpMethod adaptHttpMethod(HttpMethod method) {, +		return io.netty.handler.codec.http.HttpMethod.valueOf(method.name());, +	}, +, +	private ReactorClientHttpRequest adaptRequest(HttpMethod method, URI uri, HttpClientRequest request) {, +		return new ReactorClientHttpRequest(method, uri, request);, +	}, +, +	private ClientHttpResponse adaptResponse(HttpClientResponse response) {, +		return new ReactorClientHttpResponse(response);, +++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpConnector.java, +import reactor.ipc.netty.http.client.HttpClientRequest;, +import reactor.ipc.netty.http.client.HttpClientResponse;, +	private static final Mono<ClientHttpResponse> NO_CLIENT_RESPONSE_ERROR = Mono.error(, +			new IllegalStateException("HttpClient completed without a response. " +, +					"As a temporary workaround try to disable connection pool. " +, +					"See https://github.com/reactor/reactor-netty/issues/138."));, +, +, +				.request(adaptHttpMethod(method),, +						request -> requestCallback.apply(adaptRequest(method, uri, request))), +				.map(this::adaptResponse), +				.switchIfEmpty(NO_CLIENT_RESPONSE_ERROR);, +	}, +, +	private io.netty.handler.codec.http.HttpMethod adaptHttpMethod(HttpMethod method) {, +		return io.netty.handler.codec.http.HttpMethod.valueOf(method.name());, +	}, +, +	private ReactorClientHttpRequest adaptRequest(HttpMethod method, URI uri, HttpClientRequest request) {, +		return new ReactorClientHttpRequest(method, uri, request);, +	}, +, +	private ClientHttpResponse adaptResponse(HttpClientResponse response) {, +		return new ReactorClientHttpResponse(response);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, +	private static final Mono<ClientResponse> NO_HTTP_CLIENT_RESPONSE_ERROR = Mono.error(, +			new IllegalStateException("The underlying HTTP client completed without emitting a response."));, +, +, +			return exchangeFunction.exchange(request).switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);, +++ b/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpConnector.java, +import reactor.ipc.netty.http.client.HttpClientRequest;, +import reactor.ipc.netty.http.client.HttpClientResponse;, +	private static final Mono<ClientHttpResponse> NO_CLIENT_RESPONSE_ERROR = Mono.error(, +			new IllegalStateException("HttpClient completed without a response. " +, +					"As a temporary workaround try to disable connection pool. " +, +					"See https://github.com/reactor/reactor-netty/issues/138."));, +, +, +				.request(adaptHttpMethod(method),, +						request -> requestCallback.apply(adaptRequest(method, uri, request))), +				.map(this::adaptResponse), +				.switchIfEmpty(NO_CLIENT_RESPONSE_ERROR);, +	}, +, +	private io.netty.handler.codec.http.HttpMethod adaptHttpMethod(HttpMethod method) {, +		return io.netty.handler.codec.http.HttpMethod.valueOf(method.name());, +	}, +, +	private ReactorClientHttpRequest adaptRequest(HttpMethod method, URI uri, HttpClientRequest request) {, +		return new ReactorClientHttpRequest(method, uri, request);, +	}, +, +	private ClientHttpResponse adaptResponse(HttpClientResponse response) {, +		return new ReactorClientHttpResponse(response);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, +	private static final Mono<ClientResponse> NO_HTTP_CLIENT_RESPONSE_ERROR = Mono.error(, +			new IllegalStateException("The underlying HTTP client completed without emitting a response."));, +, +, +			return exchangeFunction.exchange(request).switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/DefaultWebClientTests.java, +import java.time.Duration;, +import reactor.test.StepVerifier;, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verifyNoMoreInteractions;, +import static org.mockito.Mockito.when;, +	@Test, +	public void switchToErrorOnEmptyClientResponseMono() throws Exception {, +		StepVerifier.create(builder().build().get().uri("/path").exchange()), +				.expectErrorMessage("The underlying HTTP client completed without emitting a response."), +				.verify(Duration.ofSeconds(5));, +	}]