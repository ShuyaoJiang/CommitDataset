[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, + * Copyright 2002-2018 the original author or authors., +				if (fbDef instanceof AbstractBeanDefinition) {, +					AbstractBeanDefinition afbDef = (AbstractBeanDefinition) fbDef;, +					if (afbDef.hasBeanClass()) {, +						Class<?> result = getTypeForFactoryBeanFromMethod(afbDef.getBeanClass(), factoryMethodName);, +						if (result != null) {, +							return result;, +			Class<?> result = getTypeForFactoryBean(fb);, +			if (result != null) {, +				return result;, +		if (factoryBeanName == null && mbd.hasBeanClass()) {, +			// No early bean instantiation possible: determine FactoryBean's type from, +			// static factory method signature or from class inheritance hierarchy..., +			if (factoryMethodName != null) {, +				return getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);, +			}, +			else {, +				return GenericTypeResolver.resolveTypeArgument(mbd.getBeanClass(), FactoryBean.class);, +			}, +		}, +, +	 * Introspect the factory method signatures on the given bean class,, +	 * trying to find a common {@code FactoryBean} object type declared there., +	 * @param beanClass the bean class to find the factory method on, +	 * @param factoryMethodName the name of the factory method, +	 * @return the common {@code FactoryBean} object type, or {@code null} if none, +	 */, +	private Class<?> getTypeForFactoryBeanFromMethod(Class<?> beanClass, String factoryMethodName) {, +		class Holder { Class<?> value = null; }, +		final Holder objectType = new Holder();, +, +		// CGLIB subclass methods hide generic parameters; look at the original user class., +		Class<?> fbClass = ClassUtils.getUserClass(beanClass);, +		// Find the given factory method, taking into account that in the case of, +		// @Bean methods, there may be parameters present., +		ReflectionUtils.doWithMethods(fbClass,, +				new ReflectionUtils.MethodCallback() {, +					@Override, +					public void doWith(Method method) {, +						if (method.getName().equals(factoryMethodName) &&, +								FactoryBean.class.isAssignableFrom(method.getReturnType())) {, +							Class<?> currentType = GenericTypeResolver.resolveReturnTypeArgument(, +									method, FactoryBean.class);, +							if (currentType != null) {, +								objectType.value = ClassUtils.determineCommonAncestor(currentType, objectType.value);, +							}, +						}, +					}, +				});, +		return (objectType.value != null && Object.class != objectType.value ? objectType.value : null);, +	}, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, + * Copyright 2002-2018 the original author or authors., +				if (fbDef instanceof AbstractBeanDefinition) {, +					AbstractBeanDefinition afbDef = (AbstractBeanDefinition) fbDef;, +					if (afbDef.hasBeanClass()) {, +						Class<?> result = getTypeForFactoryBeanFromMethod(afbDef.getBeanClass(), factoryMethodName);, +						if (result != null) {, +							return result;, +			Class<?> result = getTypeForFactoryBean(fb);, +			if (result != null) {, +				return result;, +		if (factoryBeanName == null && mbd.hasBeanClass()) {, +			// No early bean instantiation possible: determine FactoryBean's type from, +			// static factory method signature or from class inheritance hierarchy..., +			if (factoryMethodName != null) {, +				return getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);, +			}, +			else {, +				return GenericTypeResolver.resolveTypeArgument(mbd.getBeanClass(), FactoryBean.class);, +			}, +		}, +, +	 * Introspect the factory method signatures on the given bean class,, +	 * trying to find a common {@code FactoryBean} object type declared there., +	 * @param beanClass the bean class to find the factory method on, +	 * @param factoryMethodName the name of the factory method, +	 * @return the common {@code FactoryBean} object type, or {@code null} if none, +	 */, +	private Class<?> getTypeForFactoryBeanFromMethod(Class<?> beanClass, String factoryMethodName) {, +		class Holder { Class<?> value = null; }, +		final Holder objectType = new Holder();, +, +		// CGLIB subclass methods hide generic parameters; look at the original user class., +		Class<?> fbClass = ClassUtils.getUserClass(beanClass);, +		// Find the given factory method, taking into account that in the case of, +		// @Bean methods, there may be parameters present., +		ReflectionUtils.doWithMethods(fbClass,, +				new ReflectionUtils.MethodCallback() {, +					@Override, +					public void doWith(Method method) {, +						if (method.getName().equals(factoryMethodName) &&, +								FactoryBean.class.isAssignableFrom(method.getReturnType())) {, +							Class<?> currentType = GenericTypeResolver.resolveReturnTypeArgument(, +									method, FactoryBean.class);, +							if (currentType != null) {, +								objectType.value = ClassUtils.determineCommonAncestor(currentType, objectType.value);]