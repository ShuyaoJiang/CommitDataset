[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +import java.util.Collection;, +import org.springframework.core.CollectionFactory;, +	private boolean autoGrowNestedPaths;, +	 * If this BeanWrapper should attempt to "autogrow" a nested path that contains a null value., +	 * If true, a null path location will be populated with a default object value and traversed instead of resulting in a {@link NullValueInNestedPathException}., +	 * Turning this flag on also enables auto-growth of collection elements when an index that is out of bounds is accessed., +	 */, +	public boolean getAutoGrowNestedPaths() {, +		return this.autoGrowNestedPaths;, +	}, +, +	/**, +	 * Sets if this BeanWrapper should attempt to "autogrow" a nested path that contains a null value., +	 * If true, a null path location will be populated with a default object value and traversed instead of resulting in a {@link NullValueInNestedPathException}., +	 * Turning this flag on also enables auto-growth of collection elements when an index that is out of bounds is accessed., +	 * Default is false., +	 */, +	public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {, +		this.autoGrowNestedPaths = autoGrowNestedPaths;, +	}, +, +	/**, +			if (autoGrowNestedPaths) {, +				propertyValue = setDefaultValue(tokens);, +			} else {, +		}, +	private Object setDefaultValue(String propertyName) {, +		PropertyTokenHolder tokens = new PropertyTokenHolder();, +		tokens.actualName = propertyName;, +		tokens.canonicalName = propertyName;, +		setPropertyValue(tokens, createDefaultPropertyValue(tokens));, +		return getPropertyValue(tokens);, +	}, +, +	private Object setDefaultValue(PropertyTokenHolder tokens) {, +		setPropertyValue(tokens, createDefaultPropertyValue(tokens));, +		return getPropertyValue(tokens);, +	}, +	, +	private PropertyValue createDefaultPropertyValue(PropertyTokenHolder tokens) {, +		PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(tokens.actualName);		, +		Object defaultValue = newValue(pd.getPropertyType(), tokens.canonicalName);, +		return new PropertyValue(tokens.canonicalName, defaultValue);, +	}, +	, +	private Object newValue(Class<?> type, String name) {, +		try {, +			if (type.isArray()) {, +				Class<?> componentType = type.getComponentType();, +				// TODO - only handles 2-dimensional arrays, +				if (componentType.isArray()) {, +					Object array = Array.newInstance(componentType, 1);, +					Array.set(array, 0, Array.newInstance(componentType.getComponentType(), 0));, +					return array;, +				} else {, +					return Array.newInstance(componentType, 0);, +				}, +			} else {, +				if (Collection.class.isAssignableFrom(type)) {, +					return CollectionFactory.createCollection(type, 16);, +				} else {, +					return type.newInstance();, +				}, +			}, +		} catch (InstantiationException e) {, +			throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + name, "Could not instantiate propertyType [" + type.getName() + "] to auto-grow nestd property path");, +		} catch (IllegalAccessException e) {, +			throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + name, "Could not instantiate propertyType [" + type.getName() + "] to auto-grow nested property path");, +		}, +	}, +	, +				if (value == null) {, +					if (autoGrowNestedPaths) {, +						value = setDefaultValue(tokens.actualName);, +					} else {, +						throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,, +								"Cannot access indexed value of property referenced in indexed " +, +								"property path '" + propertyName + "': returned null");							, +					}, +				}			, +				String indexedPropertyName = tokens.actualName;, +						int index = Integer.parseInt(key);, +						value = growArrayIfNecessary(value, index, indexedPropertyName);, +						value = Array.get(value, index);, +						int index = Integer.parseInt(key);						, +						growCollectionIfNecessary(list, index, indexedPropertyName, pd, i + 1);						, +						value = list.get(index);, +					indexedPropertyName += PROPERTY_KEY_PREFIX + key + PROPERTY_KEY_SUFFIX;					, +	private Object growArrayIfNecessary(Object array, int index, String name) {, +		if (!autoGrowNestedPaths) {, +			return array;, +		}, +		int length = Array.getLength(array);, +		if (index >= length) {, +			Class<?> componentType = array.getClass().getComponentType();, +			Object newArray = Array.newInstance(componentType, index + 1);, +			System.arraycopy(array, 0, newArray, 0, length);, +			for (int i = length; i < Array.getLength(newArray); i++) {, +				Array.set(newArray, i, newValue(componentType, name));]