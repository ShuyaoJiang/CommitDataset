[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Includes a set of {@link Bean} methods, including all such methods, + * defined in the ancestry of the class, in a 'flattened-out' manner., +	private final Set<BeanMethod> beanMethods = new LinkedHashSet<BeanMethod>();, +, +	private final Map<String, Class<? extends BeanDefinitionReader>> importedResources =, +			new LinkedHashMap<String, Class<? extends BeanDefinitionReader>>();, +, +		Assert.hasText(beanName, "Bean name must not be null");, +	public void setBeanName(String beanName) {, +		this.beanName = beanName;, +	}, +, +	public String getBeanName() {, +		return this.beanName;, +	}, +, +	public void addImportedResource(String importedResource, Class<? extends BeanDefinitionReader> readerClass) {, +, +		// An @Bean method may only be overloaded through inheritance. No single, +		// @Configuration class may declare two @Bean methods with the same name., +		Map<String, Integer> methodNameCounts = new HashMap<String, Integer>();, +		for (BeanMethod beanMethod : this.beanMethods) {, +			String fqMethodName = beanMethod.getFullyQualifiedMethodName();, +			Integer currentCount = methodNameCounts.get(fqMethodName);, +			int newCount = currentCount != null ? currentCount + 1 : 1;, +			methodNameCounts.put(fqMethodName, newCount);, +		}, +		for (String fqMethodName : methodNameCounts.keySet()) {, +			int count = methodNameCounts.get(fqMethodName);, +			if (count > 1) {, +				String shortMethodName = ConfigurationMethod.getShortMethodName(fqMethodName);, +				problemReporter.error(new BeanMethodOverloadingProblem(shortMethodName, count));, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Includes a set of {@link Bean} methods, including all such methods, + * defined in the ancestry of the class, in a 'flattened-out' manner., +	private final Set<BeanMethod> beanMethods = new LinkedHashSet<BeanMethod>();, +, +	private final Map<String, Class<? extends BeanDefinitionReader>> importedResources =, +			new LinkedHashMap<String, Class<? extends BeanDefinitionReader>>();, +, +		Assert.hasText(beanName, "Bean name must not be null");, +	public void setBeanName(String beanName) {, +		this.beanName = beanName;, +	}, +, +	public String getBeanName() {, +		return this.beanName;, +	}, +, +	public void addImportedResource(String importedResource, Class<? extends BeanDefinitionReader> readerClass) {, +, +		// An @Bean method may only be overloaded through inheritance. No single, +		// @Configuration class may declare two @Bean methods with the same name., +		Map<String, Integer> methodNameCounts = new HashMap<String, Integer>();, +		for (BeanMethod beanMethod : this.beanMethods) {, +			String fqMethodName = beanMethod.getFullyQualifiedMethodName();, +			Integer currentCount = methodNameCounts.get(fqMethodName);, +			int newCount = currentCount != null ? currentCount + 1 : 1;, +			methodNameCounts.put(fqMethodName, newCount);, +		}, +		for (String fqMethodName : methodNameCounts.keySet()) {, +			int count = methodNameCounts.get(fqMethodName);, +			if (count > 1) {, +				String shortMethodName = ConfigurationMethod.getShortMethodName(fqMethodName);, +				problemReporter.error(new BeanMethodOverloadingProblem(shortMethodName, count));, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +				public int compare(DeferredImportSelectorHolder o1, DeferredImportSelectorHolder o2) {, +					return AnnotationAwareOrderComparator.INSTANCE.compare(o1.getImportSelector(), o2.getImportSelector());, +, +	private final ComponentScanAnnotationParser componentScanParser;, +, +	private final Set<ConfigurationClass> configurationClasses = new LinkedHashSet<ConfigurationClass>();, +, +	private final Map<String, ConfigurationClass> knownSuperclasses = new HashMap<String, ConfigurationClass>();, +, +	private final Stack<PropertySource<?>> propertySources = new Stack<PropertySource<?>>();, +, +	private final ImportStack importStack = new ImportStack();, +, +	private final List<DeferredImportSelectorHolder> deferredImportSelectors = new LinkedList<DeferredImportSelectorHolder>();, +, +, +	public void parse(Class<?> clazz, String beanName) throws IOException {, +	protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {, +		if (ConditionalAnnotationHelper.shouldSkip(configClass, this.registry, this.environment, this.beanNameGenerator)) {, +			for (Iterator<ConfigurationClass> it = this.knownSuperclasses.values().iterator(); it.hasNext();) {, +				if (configClass.equals(it.next())) {, +					it.remove();, +			}, +		}, +, +		// Recursively process the configuration class and its superclass hierarchy., +		AnnotationMetadata metadata = configClass.getMetadata();]