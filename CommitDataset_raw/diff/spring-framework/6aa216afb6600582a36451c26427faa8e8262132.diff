[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.util.Assert;, +		SimpUserRegistry userRegistry = userRegistry();, +		Assert.isInstanceOf(MultiServerUserRegistry.class, userRegistry);, +		return new UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry,, +				brokerMessagingTemplate(), getBrokerRegistry().getUserRegistryBroadcast(),, +				messageBrokerTaskScheduler());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.util.Assert;, +		SimpUserRegistry userRegistry = userRegistry();, +		Assert.isInstanceOf(MultiServerUserRegistry.class, userRegistry);, +		return new UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry,, +				brokerMessagingTemplate(), getBrokerRegistry().getUserRegistryBroadcast(),, +				messageBrokerTaskScheduler());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/user/MultiServerUserRegistry.java, + * Copyright 2002-2016 the original author or authors., + * {@code SimpUserRegistry} that looks up users in a "local" user registry as, + * well as a set of "remote" user registries. The local registry is provided as, + * a constructor argument while remote registries are updated via broadcasts, + * handled by {@link UserRegistryMessageHandler} which in turn notifies this, + * registry when updates are received., +	private final Map<String, UserRegistrySnapshot> remoteRegistries = new ConcurrentHashMap<String, UserRegistrySnapshot>();, +	private final boolean delegateApplicationEvents;, +		this.localRegistry = localRegistry;, +		this.delegateApplicationEvents = this.localRegistry instanceof SmartApplicationListener;, +	public int getOrder() {, +		return (this.delegateApplicationEvents ?, +				((SmartApplicationListener) this.localRegistry).getOrder() : Ordered.LOWEST_PRECEDENCE);, +	}, +, +	// SmartApplicationListener methods, +, +	@Override, +	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {, +		return (this.delegateApplicationEvents &&, +				((SmartApplicationListener) this.localRegistry).supportsEventType(eventType));, +	}, +, +	@Override, +	public boolean supportsSourceType(Class<?> sourceType) {, +		return (this.delegateApplicationEvents &&, +				((SmartApplicationListener) this.localRegistry).supportsSourceType(sourceType));, +	}, +, +	@Override, +	public void onApplicationEvent(ApplicationEvent event) {, +		if (this.delegateApplicationEvents) {, +			((SmartApplicationListener) this.localRegistry).onApplicationEvent(event);, +		}, +	}, +, +	// SimpUserRegistry methods, +, +	@Override, +		for (UserRegistrySnapshot registry : this.remoteRegistries.values()) {, +			user = registry.getUserMap().get(userName);, +		Set<SimpUser> result = new HashSet<SimpUser>();, +		result.addAll(this.localRegistry.getUsers());, +		for (UserRegistrySnapshot registry : this.remoteRegistries.values()) {, +			result.addAll(registry.getUserMap().values());, +		Set<SimpSubscription> result = new HashSet<SimpSubscription>();, +		result.addAll(this.localRegistry.findSubscriptions(matcher));, +		for (UserRegistrySnapshot registry : this.remoteRegistries.values()) {, +	// Internal methods for UserRegistryMessageHandler to manage broadcasts, +		return new UserRegistrySnapshot(this.id, this.localRegistry);, +		UserRegistrySnapshot registry = (UserRegistrySnapshot) converter.fromMessage(message, UserRegistrySnapshot.class);, +		if (registry != null && !registry.getId().equals(this.id)) {, +			registry.init(expirationPeriod);, +			this.remoteRegistries.put(registry.getId(), registry);, +		Iterator<Map.Entry<String, UserRegistrySnapshot>> iterator = this.remoteRegistries.entrySet().iterator();, +			Map.Entry<String, UserRegistrySnapshot> entry = iterator.next();, +			if (entry.getValue().isExpired(now)) {, +, +	/**, +	 * Holds a copy of a SimpUserRegistry for the purpose of broadcasting to and, +	 * receiving broadcasts from other application servers., +	 */, +	private static class UserRegistrySnapshot {, +		private Map<String, TransferSimpUser> users;, +, +		/**, +		 * Default constructor for JSON deserialization., +		 */, +		public UserRegistrySnapshot() {, +		/**, +		 * Constructor to create DTO from a local user registry., +		 */, +		public UserRegistrySnapshot(String id, SimpUserRegistry registry) {, +			this.users = new HashMap<String, TransferSimpUser>(users.size());, +				this.users.put(user.getName(), new TransferSimpUser(user));, +, +		public void setUserMap(Map<String, TransferSimpUser> users) {, +		public Map<String, TransferSimpUser> getUserMap() {, +		public boolean isExpired(long now) {, +			return (now > this.expirationTime);, +		}, +, +]