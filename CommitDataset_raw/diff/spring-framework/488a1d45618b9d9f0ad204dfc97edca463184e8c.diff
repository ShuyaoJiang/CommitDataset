[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +		return Flux.create(sink -> {, +			WritableByteChannelSubscriber subscriber =, +					new WritableByteChannelSubscriber(sink, channel);, +			sink.onDispose(subscriber);, +			flux.subscribe(subscriber);, +		});, +		return Flux.create(sink -> {, +			AsynchronousFileChannelWriteCompletionHandler completionHandler =, +					new AsynchronousFileChannelWriteCompletionHandler(sink, channel, position);, +			sink.onDispose(completionHandler);, +			flux.subscribe(completionHandler);, +		});, +	static void closeChannel(@Nullable Channel channel) {, +	private static class WritableByteChannelSubscriber extends BaseSubscriber<DataBuffer> {, +, +		private final FluxSink<DataBuffer> sink;, +, +		private final WritableByteChannel channel;, +, +		public WritableByteChannelSubscriber(FluxSink<DataBuffer> sink, WritableByteChannel channel) {, +			this.sink = sink;, +			this.channel = channel;, +		}, +, +		@Override, +		protected void hookOnSubscribe(Subscription subscription) {, +			request(1);, +		}, +, +		@Override, +		protected void hookOnNext(DataBuffer dataBuffer) {, +			try {, +				ByteBuffer byteBuffer = dataBuffer.asByteBuffer();, +				while (byteBuffer.hasRemaining()) {, +					this.channel.write(byteBuffer);, +				}, +				this.sink.next(dataBuffer);, +				request(1);, +			}, +			catch (IOException ex) {, +				this.sink.next(dataBuffer);, +				this.sink.error(ex);, +			}, +		}, +, +		@Override, +		protected void hookOnError(Throwable throwable) {, +			this.sink.error(throwable);, +		}, +, +		@Override, +		protected void hookOnComplete() {, +			this.sink.complete();, +		}, +	}, +, +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +		return Flux.create(sink -> {, +			WritableByteChannelSubscriber subscriber =, +					new WritableByteChannelSubscriber(sink, channel);, +			sink.onDispose(subscriber);, +			flux.subscribe(subscriber);, +		});, +		return Flux.create(sink -> {, +			AsynchronousFileChannelWriteCompletionHandler completionHandler =, +					new AsynchronousFileChannelWriteCompletionHandler(sink, channel, position);, +			sink.onDispose(completionHandler);, +			flux.subscribe(completionHandler);, +		});, +	static void closeChannel(@Nullable Channel channel) {, +	private static class WritableByteChannelSubscriber extends BaseSubscriber<DataBuffer> {, +, +		private final FluxSink<DataBuffer> sink;, +, +		private final WritableByteChannel channel;, +, +		public WritableByteChannelSubscriber(FluxSink<DataBuffer> sink, WritableByteChannel channel) {, +			this.sink = sink;, +			this.channel = channel;, +		}, +, +		@Override, +		protected void hookOnSubscribe(Subscription subscription) {, +			request(1);, +		}, +, +		@Override, +		protected void hookOnNext(DataBuffer dataBuffer) {, +			try {, +				ByteBuffer byteBuffer = dataBuffer.asByteBuffer();, +				while (byteBuffer.hasRemaining()) {, +					this.channel.write(byteBuffer);, +				}, +				this.sink.next(dataBuffer);, +				request(1);, +			}, +			catch (IOException ex) {, +				this.sink.next(dataBuffer);]