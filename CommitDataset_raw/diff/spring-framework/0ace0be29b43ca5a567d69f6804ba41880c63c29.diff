[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +	private final int[] annotationValueMappings;, +, +	private final AnnotationTypeMapping[] annotationValueSource;, +, +		this.annotationValueMappings = filledIntArray(this.attributes.size(), -1);, +		this.annotationValueSource = new AnnotationTypeMapping[this.attributes.size()];, +		addConventionAnnotationValues();, +				processAliases(i, aliases);, +	private void processAliases(int attributeIndex, List<Method> aliases) {, +			if (mapping.annotation != null) {, +				int[] resolvedMirrors = mapping.mirrorSets.resolve(null,, +						mapping.annotation, ReflectionUtils::invokeMethod);, +				for (int i = 0; i < mapping.attributes.size(); i++) {, +					if (aliases.contains(mapping.attributes.get(i))) {, +						this.annotationValueMappings[attributeIndex] = resolvedMirrors[i];, +						this.annotationValueSource[attributeIndex] = mapping;, +					}, +				}, +			}, +	private void addConventionAnnotationValues() {, +		for (int i = 0; i < this.attributes.size(); i++) {, +			Method attribute = this.attributes.get(i);, +			AnnotationTypeMapping mapping = this;, +			while (mapping.depth > 0) {, +				int mapped = mapping.getAttributes().indexOf(attribute.getName());, +				if (mapped != -1 && (this.annotationValueMappings[i] == -1, +						|| this.annotationValueSource[i].depth > mapping.depth)) {, +					this.annotationValueMappings[i] = mapped;, +					this.annotationValueSource[i] = mapping;, +				}, +				mapping = mapping.parent;, +			}, +		}, +	}, +, +	 * Return a mapped attribute value from the most suitable, +	 * {@link #getAnnotation() meta-annotation}. The resulting value is obtained, +	 * from the closest meta-annotation, taking into consideration both, +	 * convention and alias based mapping rules. For root mappings, this method, +	 * will always return {@code null}., +	 * @param attributeIndex the attribute index of the source attribute, +	 * @return the mapped annotation value, or {@code null}, +	 */, +	@Nullable, +	Object getMappedAnnotationValue(int attributeIndex) {, +		int mapped = this.annotationValueMappings[attributeIndex];, +		if (mapped == -1) {, +			return null;, +		}, +		AnnotationTypeMapping source = this.annotationValueSource[attributeIndex];, +		return ReflectionUtils.invokeMethod(source.attributes.get(mapped),, +				source.annotation);, +	}, +, +	/**, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +	private final int[] annotationValueMappings;, +, +	private final AnnotationTypeMapping[] annotationValueSource;, +, +		this.annotationValueMappings = filledIntArray(this.attributes.size(), -1);, +		this.annotationValueSource = new AnnotationTypeMapping[this.attributes.size()];, +		addConventionAnnotationValues();, +				processAliases(i, aliases);, +	private void processAliases(int attributeIndex, List<Method> aliases) {, +			if (mapping.annotation != null) {, +				int[] resolvedMirrors = mapping.mirrorSets.resolve(null,, +						mapping.annotation, ReflectionUtils::invokeMethod);, +				for (int i = 0; i < mapping.attributes.size(); i++) {, +					if (aliases.contains(mapping.attributes.get(i))) {, +						this.annotationValueMappings[attributeIndex] = resolvedMirrors[i];, +						this.annotationValueSource[attributeIndex] = mapping;, +					}, +				}, +			}, +	private void addConventionAnnotationValues() {, +		for (int i = 0; i < this.attributes.size(); i++) {, +			Method attribute = this.attributes.get(i);, +			AnnotationTypeMapping mapping = this;, +			while (mapping.depth > 0) {, +				int mapped = mapping.getAttributes().indexOf(attribute.getName());, +				if (mapped != -1 && (this.annotationValueMappings[i] == -1, +						|| this.annotationValueSource[i].depth > mapping.depth)) {, +					this.annotationValueMappings[i] = mapped;, +					this.annotationValueSource[i] = mapping;, +				}, +				mapping = mapping.parent;, +			}, +		}, +	}, +, +	 * Return a mapped attribute value from the most suitable, +	 * {@link #getAnnotation() meta-annotation}. The resulting value is obtained, +	 * from the closest meta-annotation, taking into consideration both, +	 * convention and alias based mapping rules. For root mappings, this method, +	 * will always return {@code null}., +	 * @param attributeIndex the attribute index of the source attribute, +	 * @return the mapped annotation value, or {@code null}, +	 */]