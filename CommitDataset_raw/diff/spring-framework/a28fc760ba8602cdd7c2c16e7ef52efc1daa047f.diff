[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +			this.children[i].generateCode(mv, cf);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +			this.children[i].generateCode(mv, cf);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		if (descriptor == null) {, +			if (!isStaticMethod) {, +				// Nothing on the stack but something is needed, +		} else {, +			if (isStaticMethod) {, +				// Something on the stack when nothing is needed, +				mv.visitInsn(POP);, +			}, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +			this.children[i].generateCode(mv, cf);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		if (descriptor == null) {, +			if (!isStaticMethod) {, +				// Nothing on the stack but something is needed, +		} else {, +			if (isStaticMethod) {, +				// Something on the stack when nothing is needed, +				mv.visitInsn(POP);, +			}, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java, +			} else {, +				if (descriptor != null) {, +					// A static field/method call will not consume what is on the stack,, +					// it needs to be popped off., +					mv.visitInsn(POP);, +				}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +			this.children[i].generateCode(mv, cf);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		if (descriptor == null) {, +			if (!isStaticMethod) {, +				// Nothing on the stack but something is needed, +		} else {, +			if (isStaticMethod) {, +				// Something on the stack when nothing is needed, +				mv.visitInsn(POP);, +			}, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java, +			} else {, +				if (descriptor != null) {, +					// A static field/method call will not consume what is on the stack,, +					// it needs to be popped off., +					mv.visitInsn(POP);, +				}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java, +, +	/**, +	 * Test variants of using T(...) and static/non-static method/property/field references., +	 */, +	@Test, +	public void constructorReference_SPR13781() {, +		// Static field access on a T() referenced type, +		expression = parser.parseExpression("T(java.util.Locale).ENGLISH");, +		assertEquals("en",expression.getValue().toString());, +		assertCanCompile(expression);, +		assertEquals("en",expression.getValue().toString());, +, +		// The actual expression from the bug report. It fails if the ENGLISH reference fails, +		// to pop the type reference for Locale off the stack (if it isn't popped then, +		// toLowerCase() will be called with a Locale parameter). In this situation the, +		// code generation for ENGLISH should notice there is something on the stack that, +		// is not required and pop it off., +		expression = parser.parseExpression("#userId.toString().toLowerCase(T(java.util.Locale).ENGLISH)");, +		StandardEvaluationContext context =, +				new StandardEvaluationContext();, +		context.setVariable("userId", "RoDnEy");, +		assertEquals("rodney",expression.getValue(context));, +		assertCanCompile(expression);, +		assertEquals("rodney",expression.getValue(context));, +, +		// Property access on a class object, +		expression = parser.parseExpression("T(String).name");, +		assertEquals("java.lang.String",expression.getValue());, +		assertCanCompile(expression);, +		assertEquals("java.lang.String",expression.getValue());, +, +		// Now the type reference isn't on the stack, and needs loading, +		context = new StandardEvaluationContext(String.class);, +		expression = parser.parseExpression("name");, +		assertEquals("java.lang.String",expression.getValue(context));, +		assertCanCompile(expression);, +		assertEquals("java.lang.String",expression.getValue(context));, +, +		expression = parser.parseExpression("T(String).getName()");, +		assertEquals("java.lang.String",expression.getValue());, +		assertCanCompile(expression);, +		assertEquals("java.lang.String",expression.getValue());, +		, +		// These tests below verify that the chain of static accesses (either method/property or field), +		// leave the right thing on top of the stack for processing by any outer consuming code., +		// Here the consuming code is the String.valueOf() function.  If the wrong thing were on, +		// the stack (for example if the compiled code for static methods wasn't popping the ]