[+++ b/spring-context/src/main/java/org/springframework/context/expression/StandardBeanExpressionResolver.java, + * Copyright 2002-2018 the original author or authors., +	private final Map<BeanExpressionContext, StandardEvaluationContext> evaluationCache = new ConcurrentHashMap<>(8);, +				sec = new StandardEvaluationContext(evalContext);, +++ b/spring-context/src/main/java/org/springframework/context/expression/StandardBeanExpressionResolver.java, + * Copyright 2002-2018 the original author or authors., +	private final Map<BeanExpressionContext, StandardEvaluationContext> evaluationCache = new ConcurrentHashMap<>(8);, +				sec = new StandardEvaluationContext(evalContext);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, + * Copyright 2002-2018 the original author or authors., +	@Nullable, +	private String originalPrimitiveExitTypeDescriptor;, +		if ((descriptor != null || !isStaticMethod) && this.nullSafe) {, +		String classDesc;, +		if (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {, +, +		if (this.originalPrimitiveExitTypeDescriptor != null) {, +			CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);, +++ b/spring-context/src/main/java/org/springframework/context/expression/StandardBeanExpressionResolver.java, + * Copyright 2002-2018 the original author or authors., +	private final Map<BeanExpressionContext, StandardEvaluationContext> evaluationCache = new ConcurrentHashMap<>(8);, +				sec = new StandardEvaluationContext(evalContext);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, + * Copyright 2002-2018 the original author or authors., +	@Nullable, +	private String originalPrimitiveExitTypeDescriptor;, +		if ((descriptor != null || !isStaticMethod) && this.nullSafe) {, +		String classDesc;, +		if (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {, +, +		if (this.originalPrimitiveExitTypeDescriptor != null) {, +			CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, + * Copyright 2002-2018 the original author or authors., +	private String originalPrimitiveExitTypeDescriptor;, +, +	@Nullable, +, +		if (this.nullSafe) {, +, +, +		if (this.originalPrimitiveExitTypeDescriptor != null) {, +			CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);, +++ b/spring-context/src/main/java/org/springframework/context/expression/StandardBeanExpressionResolver.java, + * Copyright 2002-2018 the original author or authors., +	private final Map<BeanExpressionContext, StandardEvaluationContext> evaluationCache = new ConcurrentHashMap<>(8);, +				sec = new StandardEvaluationContext(evalContext);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, + * Copyright 2002-2018 the original author or authors., +	@Nullable, +	private String originalPrimitiveExitTypeDescriptor;, +		if ((descriptor != null || !isStaticMethod) && this.nullSafe) {, +		String classDesc;, +		if (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {, +, +		if (this.originalPrimitiveExitTypeDescriptor != null) {, +			CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, + * Copyright 2002-2018 the original author or authors., +	private String originalPrimitiveExitTypeDescriptor;, +, +	@Nullable, +, +		if (this.nullSafe) {, +, +, +		if (this.originalPrimitiveExitTypeDescriptor != null) {, +			CodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/StandardEvaluationContext.java, +	private TypedValue rootObject;, +	/**, +	 * Create a {@code StandardEvaluationContext} with a null root object., +	 */, +		this.rootObject = TypedValue.NULL;, +	/**, +	 * Create a {@code StandardEvaluationContext} with the given root object., +	 * @param rootObject the root object to use, +	 * @see #setRootObject, +	 */, +		this.rootObject = new TypedValue(rootObject);]