[+++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +	@Nullable, +	private volatile String toStringValue;, +		String value = this.toStringValue;, +		if (value == null) {, +			value = builder.toString();, +			this.toStringValue = value;, +		return value;, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +	@Nullable, +	private volatile String toStringValue;, +		String value = this.toStringValue;, +		if (value == null) {, +			value = builder.toString();, +			this.toStringValue = value;, +		return value;, +++ b/spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java, +	public static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new MimeType.SpecificityComparator<>();, +, +	private static final ConcurrentLruCache<String, MimeType> cachedMimeTypes =, +			new ConcurrentLruCache<>(32, MimeTypeUtils::parseMimeTypeInternal);, +, +, +		return cachedMimeTypes.get(mimeType);, +, +, +	 * <p>This implementation is backed by a {@code ConcurrentHashMap} for storing, +	 * the cached values and a {@code ConcurrentLinkedQueue} for ordering the keys, +	 * and choosing the least recently used key when the cache is at full capacity., +	private static class ConcurrentLruCache<K, V> {, +		public ConcurrentLruCache(int maxSize, Function<K, V> generator) {, +		public V get(K key) {, +					if (leastUsed != null) {, +				}]