[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +import org.springframework.http.HttpStatus;, +		return (clazz != null && ((HttpEntity.class.isAssignableFrom(clazz) &&, +				!RequestEntity.class.isAssignableFrom(clazz)) ||, +				HttpHeaders.class.isAssignableFrom(clazz)));, +			HttpEntity<?> httpEntity;, +			if (returnValue instanceof HttpEntity) {, +				httpEntity = (HttpEntity<?>) returnValue;, +			}, +			else if (returnValue instanceof HttpHeaders) {, +				httpEntity = new ResponseEntity<Void>((HttpHeaders) returnValue, HttpStatus.OK);, +			}, +			else {, +				throw new IllegalArgumentException(, +						"HttpEntity or HttpHeaders expected but got: " + returnValue.getClass());, +			}, +, +			if(httpEntity.getBody() == null || returnValue instanceof HttpHeaders) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +import org.springframework.http.HttpStatus;, +		return (clazz != null && ((HttpEntity.class.isAssignableFrom(clazz) &&, +				!RequestEntity.class.isAssignableFrom(clazz)) ||, +				HttpHeaders.class.isAssignableFrom(clazz)));, +			HttpEntity<?> httpEntity;, +			if (returnValue instanceof HttpEntity) {, +				httpEntity = (HttpEntity<?>) returnValue;, +			}, +			else if (returnValue instanceof HttpHeaders) {, +				httpEntity = new ResponseEntity<Void>((HttpHeaders) returnValue, HttpStatus.OK);, +			}, +			else {, +				throw new IllegalArgumentException(, +						"HttpEntity or HttpHeaders expected but got: " + returnValue.getClass());, +			}, +, +			if(httpEntity.getBody() == null || returnValue instanceof HttpHeaders) {, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandlerTests.java, +import java.util.LinkedHashSet;, +import org.springframework.http.HttpMethod;, +		returnType = on(TestController.class).resolveReturnType(HttpHeaders.class);, +		assertTrue(this.resultHandler.supports(handlerResult(value, returnType)));, +, +	public void responseEntityStatusCode() throws Exception {, +	public void httpHeaders() throws Exception {, +		HttpHeaders headers = new HttpHeaders();, +		headers.setAllow(new LinkedHashSet<>(Arrays.asList(HttpMethod.GET, HttpMethod.POST, HttpMethod.OPTIONS)));, +		MethodParameter returnType = on(TestController.class).resolveReturnType(entity(Void.class));, +		HandlerResult result = handlerResult(headers, returnType);, +		MockServerWebExchange exchange = get("/path").toExchange();, +		this.resultHandler.handleResult(exchange, result).block(Duration.ofSeconds(5));, +, +		assertEquals(HttpStatus.OK, exchange.getResponse().getStatusCode());, +		assertEquals(1, exchange.getResponse().getHeaders().size());, +		assertEquals("GET,POST,OPTIONS", exchange.getResponse().getHeaders().getFirst("Allow"));, +		assertResponseBodyIsEmpty(exchange);, +	}, +, +	@Test, +	public void responseEntityHeaders() throws Exception {, +		HttpHeaders httpHeaders() { return null; }, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +import org.springframework.http.HttpStatus;, +		return (clazz != null && ((HttpEntity.class.isAssignableFrom(clazz) &&, +				!RequestEntity.class.isAssignableFrom(clazz)) ||, +				HttpHeaders.class.isAssignableFrom(clazz)));, +			HttpEntity<?> httpEntity;, +			if (returnValue instanceof HttpEntity) {, +				httpEntity = (HttpEntity<?>) returnValue;, +			}, +			else if (returnValue instanceof HttpHeaders) {, +				httpEntity = new ResponseEntity<Void>((HttpHeaders) returnValue, HttpStatus.OK);, +			}, +			else {, +				throw new IllegalArgumentException(, +						"HttpEntity or HttpHeaders expected but got: " + returnValue.getClass());, +			}, +, +			if(httpEntity.getBody() == null || returnValue instanceof HttpHeaders) {, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandlerTests.java, +import java.util.LinkedHashSet;, +import org.springframework.http.HttpMethod;, +		returnType = on(TestController.class).resolveReturnType(HttpHeaders.class);, +		assertTrue(this.resultHandler.supports(handlerResult(value, returnType)));, +, +	public void responseEntityStatusCode() throws Exception {, +	public void httpHeaders() throws Exception {, +		HttpHeaders headers = new HttpHeaders();, +		headers.setAllow(new LinkedHashSet<>(Arrays.asList(HttpMethod.GET, HttpMethod.POST, HttpMethod.OPTIONS)));, +		MethodParameter returnType = on(TestController.class).resolveReturnType(entity(Void.class));, +		HandlerResult result = handlerResult(headers, returnType);, +		MockServerWebExchange exchange = get("/path").toExchange();, +		this.resultHandler.handleResult(exchange, result).block(Duration.ofSeconds(5));, +, +		assertEquals(HttpStatus.OK, exchange.getResponse().getStatusCode());, +		assertEquals(1, exchange.getResponse().getHeaders().size());, +		assertEquals("GET,POST,OPTIONS", exchange.getResponse().getHeaders().getFirst("Allow"));, +		assertResponseBodyIsEmpty(exchange);, +	}, +]