[+++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.web.reactive.function.BodyExtractors;, +		public FluxExchangeResult<DataBuffer> returnResult() {, +			return this.result.decodeToFlux(BodyExtractors.toDataBuffers());, +		}, +, +		@Override, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.web.reactive.function.BodyExtractors;, +		public FluxExchangeResult<DataBuffer> returnResult() {, +			return this.result.decodeToFlux(BodyExtractors.toDataBuffers());, +		}, +, +		@Override, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/FluxExchangeResult.java, +import java.util.function.Consumer;, +	/**, +	 * Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}, +	 * passing {@code "this"} instance to it. This method allows the following,, +	 * without leaving the {@code WebTestClient} chain of calls:, +	 * <pre class="code">, +	 *	client.get(), +	 * 		.uri("/persons"), +	 * 		.accept(TEXT_EVENT_STREAM), +	 * 		.exchange(), +	 * 		.expectStatus().isOk(), +	 *	 	.returnResult(), +	 *	 	.consumeWith(result -> assertThat(...);, +	 * </pre>, +	 * @param consumer consumer for {@code "this"} instance, +	 */, +	public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {, +		assertWithDiagnostics(() -> consumer.accept(this));, +	}, +, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.web.reactive.function.BodyExtractors;, +		public FluxExchangeResult<DataBuffer> returnResult() {, +			return this.result.decodeToFlux(BodyExtractors.toDataBuffers());, +		}, +, +		@Override, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/FluxExchangeResult.java, +import java.util.function.Consumer;, +	/**, +	 * Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}, +	 * passing {@code "this"} instance to it. This method allows the following,, +	 * without leaving the {@code WebTestClient} chain of calls:, +	 * <pre class="code">, +	 *	client.get(), +	 * 		.uri("/persons"), +	 * 		.accept(TEXT_EVENT_STREAM), +	 * 		.exchange(), +	 * 		.expectStatus().isOk(), +	 *	 	.returnResult(), +	 *	 	.consumeWith(result -> assertThat(...);, +	 * </pre>, +	 * @param consumer consumer for {@code "this"} instance, +	 */, +	public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {, +		assertWithDiagnostics(() -> consumer.accept(this));, +	}, +, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/WebTestClient.java, +import org.springframework.core.io.buffer.DataBuffer;, +, +		/**, +		 * Return the exchange result with the body decoded to, +		 * {@code Flux<DataBuffer>}. Use this option for infinite streams and, +		 * consume the stream with the {@code StepVerifier} from the Reactor Add-Ons., +		 *, +		 * @return, +		 */, +		FluxExchangeResult<DataBuffer> returnResult();]