[+++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		inspectCacheEvicts(evictions, false);, +		inspectCacheEvicts(evictions, true);, +	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());, +		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		inspectCacheEvicts(evictions, false);, +		inspectCacheEvicts(evictions, true);, +	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());, +		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java, +		result.append(getClass().getSimpleName());, +		result.append("[");, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		inspectCacheEvicts(evictions, false);, +		inspectCacheEvicts(evictions, true);, +	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());, +		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java, +		result.append(getClass().getSimpleName());, +		result.append("[");, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java, +	private Map<String, Expression> conditionCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Expression> keyCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Method> targetMethodCache = new ConcurrentHashMap<String, Method>();, +		String key = toString(method, conditionExpression);, +		Expression condExp = this.conditionCache.get(key);, +			this.conditionCache.put(key, condExp);, +		String key = toString(method, keyExpression);, +		Expression keyExp = this.keyCache.get(key);, +			this.keyCache.put(key, keyExp);, +	private String toString(Method method, String expression) {, +		StringBuilder sb = new StringBuilder();, +		sb.append(method.getDeclaringClass().getName());, +		sb.append("#");, +		sb.append(method.toString());, +		sb.append("#");, +		sb.append(expression);, +		return sb.toString();, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		inspectCacheEvicts(evictions, false);, +		inspectCacheEvicts(evictions, true);, +	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());, +		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java, +		result.append(getClass().getSimpleName());, +		result.append("[");, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java, +	private Map<String, Expression> conditionCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Expression> keyCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Method> targetMethodCache = new ConcurrentHashMap<String, Method>();, +		String key = toString(method, conditionExpression);, +		Expression condExp = this.conditionCache.get(key);, +			this.conditionCache.put(key, condExp);, +		String key = toString(method, keyExpression);, +		Expression keyExp = this.keyCache.get(key);, +			this.keyCache.put(key, keyExp);, +	private String toString(Method method, String expression) {, +		StringBuilder sb = new StringBuilder();, +		sb.append(method.getDeclaringClass().getName());, +		sb.append("#");, +		sb.append(method.toString());, +		sb.append("#");, +		sb.append(expression);, +		return sb.toString();, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/LazyParamAwareEvaluationContext.java, +	private final Map<String, Method> methodCache;, +			Object[] args, Class<?> targetClass, Map<String, Method> methodCache) {, +		String mKey = toString(this.method);, +		Method targetMethod = this.methodCache.get(mKey);, +			this.methodCache.put(mKey, targetMethod);, +	private String toString(Method m) {, +		StringBuilder sb = new StringBuilder();, +		sb.append(m.getDeclaringClass().getName());, +		sb.append("#");, +		sb.append(m.toString());, +		return sb.toString();, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		inspectCacheEvicts(evictions, false);, +		inspectCacheEvicts(evictions, true);, +	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());, +		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java, +		result.append(getClass().getSimpleName());, +		result.append("[");, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java, +	private Map<String, Expression> conditionCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Expression> keyCache = new ConcurrentHashMap<String, Expression>();, +	private Map<String, Method> targetMethodCache = new ConcurrentHashMap<String, Method>();, +		String key = toString(method, conditionExpression);, +		Expression condExp = this.conditionCache.get(key);, +			this.conditionCache.put(key, condExp);]