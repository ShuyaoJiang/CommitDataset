[+++ b/spring-web/src/test/java/org/springframework/web/method/ResolvableMethod.java, +import org.springframework.core.LocalVariableTableParameterNameDiscoverer;, +import org.springframework.core.ParameterNameDiscoverer;, +import org.springframework.util.ObjectUtils;, + * Convenience class to resolve method parameters from hints., + * combination with variables for reflection metadata., + * but to use hints to zero in on method parameters. Such hints can be strongly, + * typed and explicit about what is being tested., + * When testing return types it's likely to have many methods with a unique, + * on(TestController.class).resolveReturnType(List.class, Foo.class);, + * on(TestController.class).resolveReturnType(Mono.class, responseEntity(Foo.class));, + * // Annotation with attributes, +	private static final ParameterNameDiscoverer nameDiscoverer =, +			new LocalVariableTableParameterNameDiscoverer();, +, +	 * @param generics optional array of generic types, +	public MethodParameter arg(Class<?> type, Class<?>... generics) {, +		return new ArgResolver().arg(type, generics);, +	}, +, +	/**, +	 * Find a unique argument matching the given type., +	 * @param type the expected type, +	 * @param generic at least one generic type, +	 * @param generics optional array of generic types, +	 */, +	public MethodParameter arg(Class<?> type, ResolvableType generic, ResolvableType... generics) {, +		return new ArgResolver().arg(type, generic, generics);, +	private static ResolvableType toResolvableType(Class<?> type, Class<?>... generics) {, +		return ObjectUtils.isEmpty(generics) ?, +				ResolvableType.forClass(type) :, +				ResolvableType.forClassWithGenerics(type, generics);, +	}, +, +	private static ResolvableType toResolvableType(Class<?> type, ResolvableType generic, ResolvableType... generics) {, +		ResolvableType[] genericTypes = new ResolvableType[generics.length + 1];, +		genericTypes[0] = generic;, +		System.arraycopy(generics, 0, genericTypes, 1, generics.length);, +		return ResolvableType.forClassWithGenerics(type, genericTypes);, +	}, +, +		 * @param returnType the return type, +		 * @param generics optional array of generic types, +		public Builder returning(Class<?> returnType, Class<?>... generics) {, +			return returning(toResolvableType(returnType, generics));, +		}, +, +		/**, +		 * Filter on methods returning the given type with generics., +		 * @param returnType the return type, +		 * @param generic at least one generic type, +		 * @param generics optional extra generic types, +		 */, +		public Builder returning(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {, +			return returning(toResolvableType(returnType, generic, generics));, +		 * @param returnType the return type, +		public Builder returning(ResolvableType returnType) {, +			String expected = returnType.toString();, +		// Build & resolve shortcuts..., +		 * @param returnType the return type, +		 * @param generics optional array of generic types, +		public MethodParameter resolveReturnType(Class<?> returnType, Class<?>... generics) {, +			return returning(returnType, generics).build().returnType();, +		 * @param returnType the return type, +		 * @param generic at least one generic type, +		 * @param generics optional extra generic types, +		public MethodParameter resolveReturnType(Class<?> returnType, ResolvableType generic,, +				ResolvableType... generics) {, +, +			return returning(returnType, generic, generics).build().returnType();, +		}, +, +		public MethodParameter arg(Class<?> type, Class<?>... generics) {, +			return arg(toResolvableType(type, generics));, +		}, +, +		/**, +		 * Resolve the argument also matching to the given type., +		 * @param type the expected type, +		 */, +		public MethodParameter arg(Class<?> type, ResolvableType generic, ResolvableType... generics) {, +			return arg(toResolvableType(type, generic, generics));, +				param.initParameterNameDiscovery(nameDiscoverer);, +	@SuppressWarnings("unchecked"), +	private static <T> T initProxy(Class<?> type, MethodInvocationInterceptor interceptor) {, +		Assert.notNull(type, "'type' must not be null");, +		if (type.isInterface()) {, +			ProxyFactory factory = new ProxyFactory(EmptyTargetSource.INSTANCE);, +			factory.addInterface(type);, +			factory.addInterface(Supplier.class);, +			factory.addAdvice(interceptor);, +			return (T) factory.getProxy();, +		}, +, +		else {, +			Enhancer enhancer = new Enhancer();, +			enhancer.setSuperclass(type);, +			enhancer.setInterfaces(new Class<?>[] {Supplier.class});, +			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);, +			enhancer.setCallbackType(org.springframework.cglib.proxy.MethodInterceptor.class);]