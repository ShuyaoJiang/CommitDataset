[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		updateExitTypeDescriptor();, +	private MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value,, +			TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +, +	private void updateExitTypeDescriptor() {, +		CachedMethodExecutor executorToCheck = this.cachedExecutor;, +		if (executorToCheck.get() instanceof ReflectiveMethodExecutor) {, +			Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();, +			this.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());, +		}, +	}, +, +	/**, +	 * A method reference is compilable if it has been resolved to a reflectively accessible method, +	 * and the child nodes (arguments to the method) are also compilable., +	 */, +	@Override, +	public boolean isCompilable() {, +		CachedMethodExecutor executorToCheck = this.cachedExecutor;, +		if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {, +			return false;, +		}, +, +		for (SpelNodeImpl child : this.children) {, +			if (!child.isCompilable()) {, +				return false;, +			}, +		}, +, +		ReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) executorToCheck.get();, +		Method method = executor.getMethod();, +		if (!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {, +			return false;, +		}, +		if (method.isVarArgs()) {, +			return false;, +		}, +		if (executor.didArgumentConversionOccur()) {, +			return false;, +		}, +, +		return true;, +	}, +, +	@Override, +	public void generateCode(MethodVisitor mv, CodeFlow codeflow) {, +		CachedMethodExecutor executorToCheck = this.cachedExecutor;, +		if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {, +			throw new IllegalStateException("No applicable cached executor found: " + executorToCheck);, +		}, +, +		Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();, +		boolean isStaticMethod = Modifier.isStatic(method.getModifiers());, +		String descriptor = codeflow.lastDescriptor();, +, +		if (descriptor == null && !isStaticMethod) {, +			codeflow.loadTarget(mv);, +		}, +, +		boolean itf = method.getDeclaringClass().isInterface();, +		String methodDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.', '/');, +		if (!isStaticMethod) {, +			if (descriptor == null || !descriptor.equals(methodDeclaringClassSlashedDescriptor)) {, +				mv.visitTypeInsn(CHECKCAST, methodDeclaringClassSlashedDescriptor);, +			}, +		}, +		String[] paramDescriptors = CodeFlow.toParamDescriptors(method);, +		for (int i = 0; i < this.children.length;i++) {, +			SpelNodeImpl child = this.children[i];, +			codeflow.enterCompilationScope();, +			child.generateCode(mv, codeflow);, +			// Check if need to box it for the method reference?, +			if (CodeFlow.isPrimitive(codeflow.lastDescriptor()) && paramDescriptors[i].charAt(0) == 'L') {, +				CodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));, +			}, +			else if (!codeflow.lastDescriptor().equals(paramDescriptors[i])) {, +				// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in), +				CodeFlow.insertCheckCast(mv, paramDescriptors[i]);, +			}, +			codeflow.exitCompilationScope();, +		}, +		mv.visitMethodInsn(isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL,, +				methodDeclaringClassSlashedDescriptor, method.getName(), CodeFlow.createSignatureDescriptor(method), itf);, +		codeflow.pushDescriptor(this.exitTypeDescriptor);, +	}, +, +			TypedValue result = MethodReference.this.getValueInternal(, +					this.evaluationContext, this.value, this.targetType, this.arguments);, +			updateExitTypeDescriptor();, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		updateExitTypeDescriptor();, +	private MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value,, +			TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +, +	private void updateExitTypeDescriptor() {, +		CachedMethodExecutor executorToCheck = this.cachedExecutor;, +		if (executorToCheck.get() instanceof ReflectiveMethodExecutor) {, +			Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();, +			this.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());]