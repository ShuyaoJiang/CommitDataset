[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandler.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.springframework.core.task.TaskExecutor;, +	private static Log logger = LogFactory.getLog(ReactiveTypeHandler.class);, +, +	private final TaskExecutor taskExecutor;, +, +	ReactiveTypeHandler(ReactiveAdapterRegistry registry, TaskExecutor executor,, +			ContentNegotiationManager manager) {, +, +		Assert.notNull(executor, "TaskExecutor is required");, +		this.taskExecutor = executor;, +				new SseEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);, +				new JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);, +				new TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);, +		private static final Object COMPLETE_SIGNAL = new Object();, +, +, +		private final TaskExecutor taskExecutor;, +, +		private final Queue<Object> queue = new ConcurrentLinkedQueue<>();, +		private final AtomicBoolean executing = new AtomicBoolean(false);, +, +		private volatile boolean done;, +, +, +		protected AbstractEmitterSubscriber(ResponseBodyEmitter emitter, TaskExecutor executor) {, +			this.taskExecutor = executor;, +, +		public final void onSubscribe(Subscription subscription) {, +			if (logger.isDebugEnabled()) {, +				logger.debug("Subscribed to Publisher for " + this.emitter);, +			}, +			this.emitter.onTimeout(() -> {, +				if (logger.isDebugEnabled()) {, +					logger.debug("Connection timed out for " + this.emitter);, +				}, +				terminate();, +				this.emitter.complete();, +			});, +		public final void onNext(Object element) {, +			this.queue.offer(element);, +			trySchedule();, +		}, +, +		@Override, +		public final void onError(Throwable ex) {, +			this.queue.offer(ex);, +			trySchedule();, +		}, +, +		@Override, +		public final void onComplete() {, +			this.queue.offer(COMPLETE_SIGNAL);, +			trySchedule();, +		}, +, +		private void trySchedule() {, +			if (this.executing.compareAndSet(false, true)) {, +					this.taskExecutor.execute(() -> {, +						try {, +							Object signal = this.queue.poll();, +							if (!this.done) {, +								handle(signal);, +							}, +						}, +						finally {, +							this.executing.set(false);, +							if(!this.queue.isEmpty()), +								trySchedule();, +						}, +					});, +				}, +				catch (Throwable ex) {, +					try {, +						terminate();, +					}, +					finally {, +						this.executing.set(false);, +						this.queue.clear();, +					}, +				}, +			}, +		}, +, +		private void handle(Object signal) {, +			if (signal instanceof Throwable) {, +				if (logger.isDebugEnabled()) {, +					logger.debug("Publisher error for " + this.emitter, (Throwable) signal);, +				}, +				this.done = true;, +				this.emitter.completeWithError((Throwable) signal);, +			}, +			else if (signal == COMPLETE_SIGNAL) {, +				if (logger.isDebugEnabled()) {, +					logger.debug("Publishing completed for " + this.emitter);]