[+++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractCacheInterceptor.java, +import org.springframework.util.CollectionUtils;, +, +, +	protected abstract Object invoke(CacheOperationInvocationContext<O> context, CacheOperationInvoker invoker), +			throws Throwable;, +, +		if (CollectionUtils.isEmpty(caches)) {, +			throw new IllegalStateException("Unsupported cache resolution result " + caches +, +					": JSR-107 only supports a single cache.");, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractCacheInterceptor.java, +import org.springframework.util.CollectionUtils;, +, +, +	protected abstract Object invoke(CacheOperationInvocationContext<O> context, CacheOperationInvoker invoker), +			throws Throwable;, +, +		if (CollectionUtils.isEmpty(caches)) {, +			throw new IllegalStateException("Unsupported cache resolution result " + caches +, +					": JSR-107 only supports a single cache.");, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AnnotationJCacheOperationSource.java, +, +		CacheDefaults defaults = getCacheDefaults(method, targetType);, +	protected CacheResultOperation createCacheResultOperation(Method method, CacheDefaults defaults, CacheResult ann) {, +	protected CachePutOperation createCachePutOperation(Method method, CacheDefaults defaults, CachePut ann) {, +	protected CacheRemoveOperation createCacheRemoveOperation(Method method, CacheDefaults defaults, CacheRemove ann) {, +	protected CacheRemoveAllOperation createCacheRemoveAllOperation(Method method, CacheDefaults defaults, CacheRemoveAll ann) {, +	private <A extends Annotation> CacheMethodDetails<A> createMethodDetails(Method method, A annotation, String cacheName) {, +, +, +	protected KeyGenerator determineKeyGenerator(CacheDefaults defaults, Class<? extends CacheKeyGenerator> candidate) {, +		List<String> parameters = new ArrayList<String>(parameterTypes.length);, +		StringBuilder sb = new StringBuilder(method.getDeclaringClass().getName());, +		sb.append(".").append(method.getName());, +		sb.append("(").append(StringUtils.collectionToCommaDelimitedString(parameters)).append(")");, +		for (Object instance : instances) {, +			if (instance != null) {, +, +, +	/**, +	 * Locate or create an instance of the specified cache strategy {@code type}., +	 * @param type the type of the bean to manage, +	 * @return the required bean, +	 */, +	protected abstract <T> T getBean(Class<T> type);, +, +	/**, +	 * Return the default {@link CacheResolver} if none is set., +	 */, +	protected abstract CacheResolver getDefaultCacheResolver();, +, +	/**, +	 * Return the default exception {@link CacheResolver} if none is set., +	 */, +	protected abstract CacheResolver getDefaultExceptionCacheResolver();, +, +	/**, +	 * Return the default {@link KeyGenerator} if none is set., +	 */, +	protected abstract KeyGenerator getDefaultKeyGenerator();, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractCacheInterceptor.java, +import org.springframework.util.CollectionUtils;, +, +, +	protected abstract Object invoke(CacheOperationInvocationContext<O> context, CacheOperationInvoker invoker), +			throws Throwable;, +, +		if (CollectionUtils.isEmpty(caches)) {, +			throw new IllegalStateException("Unsupported cache resolution result " + caches +, +					": JSR-107 only supports a single cache.");, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AnnotationJCacheOperationSource.java, +, +		CacheDefaults defaults = getCacheDefaults(method, targetType);, +	protected CacheResultOperation createCacheResultOperation(Method method, CacheDefaults defaults, CacheResult ann) {, +	protected CachePutOperation createCachePutOperation(Method method, CacheDefaults defaults, CachePut ann) {, +	protected CacheRemoveOperation createCacheRemoveOperation(Method method, CacheDefaults defaults, CacheRemove ann) {, +	protected CacheRemoveAllOperation createCacheRemoveAllOperation(Method method, CacheDefaults defaults, CacheRemoveAll ann) {, +	private <A extends Annotation> CacheMethodDetails<A> createMethodDetails(Method method, A annotation, String cacheName) {, +, +, +	protected KeyGenerator determineKeyGenerator(CacheDefaults defaults, Class<? extends CacheKeyGenerator> candidate) {, +		List<String> parameters = new ArrayList<String>(parameterTypes.length);, +		StringBuilder sb = new StringBuilder(method.getDeclaringClass().getName());, +		sb.append(".").append(method.getName());, +		sb.append("(").append(StringUtils.collectionToCommaDelimitedString(parameters)).append(")");, +		for (Object instance : instances) {, +			if (instance != null) {, +, +, +	/**, +	 * Locate or create an instance of the specified cache strategy {@code type}., +	 * @param type the type of the bean to manage, +	 * @return the required bean, +	 */, +	protected abstract <T> T getBean(Class<T> type);, +, +	/**, +	 * Return the default {@link CacheResolver} if none is set., +	 */]