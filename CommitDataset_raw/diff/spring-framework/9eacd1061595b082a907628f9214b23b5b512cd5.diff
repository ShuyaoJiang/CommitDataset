[+++ b/spring-framework-reference/src/aop-api.xml, +    <para>The previous chapter described the Spring 2.0 and later version's, +    support for AOP using @AspectJ and schema-based aspect definitions. In, +    this chapter we discuss the lower-level Spring AOP APIs and the AOP, +    support used in Spring 1.2 applications. For new applications, we, +    recommend the use of the Spring 2.0 and later AOP support described in the, +    previous chapter, but when working with existing applications, or when, +    reading books and articles, you may come across Spring 1.2 style examples., +    Spring 3.0 is backwards compatible with Spring 1.2 and everything, +    described in this chapter is fully supported in Spring 3.0.</para>, +    <para>Let's look at how Spring handles the crucial pointcut, +    concept.</para>, +      <programlisting language="java">public interface Pointcut {, +}</programlisting>, +      <para>Splitting the <interfacename>Pointcut</interfacename> interface, +      into two parts allows reuse of class and method matching parts, and, +      fine-grained composition operations (such as performing a "union" with, +      another method matcher).</para>, +      <para>The <interfacename>ClassFilter</interfacename> interface is used, +      to restrict the pointcut to a given set of target classes. If the, +      <programlisting language="java">public interface ClassFilter {, +}</programlisting>, +      <para>The <interfacename>MethodMatcher</interfacename> interface is, +      normally more important. The complete interface is shown below:</para>, +      <programlisting language="java">public interface MethodMatcher {, +}</programlisting>, +        framework to cache the results of pointcut evaluation when an AOP, +        proxy is created.</para>, +, +          <para>Intersection means the methods that both pointcuts, +          match.</para>, +, +, +          <emphasis>org.springframework.aop.support.Pointcuts</emphasis>, +          class, or using the <emphasis>ComposablePointcut</emphasis> class in, +          the same package. However, using AspectJ pointcut expressions is, +          usually a simpler approach.</para>, +      This is a pointcut that uses an AspectJ supplied library to parse an, +      AspectJ pointcut expression string.</para>, +      <para>See the previous chapter for a discussion of supported AspectJ, +      pointcut primitives.</para>, +        sufficient - <emphasis>and best</emphasis> - for most usages. It's, +        possible for Spring to evaluate a static pointcut only once, when a, +        method is first invoked: after that, there is no need to evaluate the, +        pointcut again with each method invocation.</para>, +          <literal>RegexpMethodPointcutAdvisor</literal> simplifies wiring, as, +          the one bean encapsulates both pointcut and advice, as shown, +          executes below a join point matched by another pointcut.) A control, +          flow pointcut matches the current call stack. For example, it might, +          fire if the join point was invoked by a method in the, +          <literal>com.mycompany.web</literal> package, or by the, +          <literal>SomeCaller</literal> class. Control flow pointcuts are, +          specified using the, +              evaluate at runtime than even other dynamic pointcuts. In Java, +              1.4, the cost is about 5 times that of other dynamic, +              pointcuts.</para>, +      <para>Each advice is a Spring bean. An advice instance can be shared, +      across all advised objects, or unique to each advised object. This, +      corresponds to <emphasis>per-class</emphasis> or, +      <emphasis>per-instance</emphasis> advice.</para>, +        <methodname>invoke()</methodname> method exposes the method being, +        invoked; the target join point; the AOP proxy; and the arguments to, +        the method. The <methodname>invoke()</methodname> method should return, +        the invocation's result: the return value of the join point.</para>, +        interceptor chain towards the join point. Most interceptors will, +        invoke this method, and return its return value. However, a, +        <note>, +          <para>MethodInterceptors offer interoperability with other AOP, +          concepts, but in a Spring-specific way. While there is an advantage, +          in using the most specific advice type, stick with MethodInterceptor, +          pointcut interfaces.</para>, +        </note>, +        <para>Note the return type is <literal>void</literal>. Before advice, +        can insert custom behavior before the join point executes, but cannot, +        change the return value. If a before advice throws an exception, this, +        will abort further execution of the interceptor chain. The exception, +        will propagate back up the interceptor chain. If it is unchecked, or, +        on the signature of the invoked method, it will be passed directly to, +        the client; otherwise it will be wrapped in an unchecked exception by, +        the AOP proxy.</para>, +        <tip>, +          <para>Before advice can be used with any pointcut.</para>, +        </tip>, +        <para>The advice below is invoked if a, +        <exceptionname>RemoteException</exceptionname> is thrown (including, +        subclasses):</para>, +        <programlisting language="java">public class RemoteThrowsAdvice implements ThrowsAdvice {, +        <lineannotation>// Do something with remote exception</lineannotation>, +}</programlisting>, +        <exceptionname>ServletException</exceptionname> is thrown. Unlike the, +        above advice, it declares 4 arguments, so that it has access to the, +        invoked method, method arguments and target object:</para>, +        <programlisting language="java">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {, +        <lineannotation>// Do something with all arguments</lineannotation>, +}</programlisting>, +        <para><emphasis>Note:</emphasis> If a throws-advice method throws an, +        exception itself, it will override the original exception (i.e. change, +        the exception thrown to the user). The overriding exception will, +        typically be a RuntimeException; this is compatible with any method, +        signature. However, if a throws-advice method throws a checked]