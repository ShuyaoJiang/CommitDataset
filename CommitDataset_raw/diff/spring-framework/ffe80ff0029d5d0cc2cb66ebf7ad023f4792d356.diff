[+++ b/src/docs/asciidoc/core/core-beans.adoc, +	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");, +		private static AccountService accountService = new AccountServiceImpl();, +, +, +, +, +			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");, +		public Object postProcessBeforeInitialization(Object bean, String beanName) {, +		public Object postProcessAfterInitialization(Object bean, String beanName) {, +As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is, +no longer necessary if the target bean only defines one constructor to begin with., +However, if several constructors are available, at least one must be annotated to, +teach the container which one to use., +[TIP], +====, +Make sure that your target components (e.g. `MovieCatalog`, `CustomerPreferenceDao`), +are consistently declared by the type that you are using for your `@Autowired`-annotated, +injection points. Otherwise injection may fail due to no type match found at runtime., +, +For XML-defined beans or component classes found through a classpath scan, the container, +usually knows the concrete type upfront. However, for `@Bean` factory methods, you need, +to make sure that the declared return type is sufficiently expressive. For components, +implementing several interfaces or for components potentially referred to by their, +implementation type, consider declaring the most specific return type on your factory, +method (at least as specific as required by the injection points referring to your bean)., +====, +, +, +		public TransferServiceImpl transferService() {, +You may also declare your `@Bean` method with an interface (or base class), +return type:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@Configuration, +	public class AppConfig {, +, +		@Bean, +		public TransferService transferService() {, +			return new TransferServiceImpl();, +		}, +	}, +----, +, +However, this limits the visibility for advance type prediction to the specified, +interface type (`TransferService`) then, with the full type (`TransferServiceImpl`), +only known to the container once the affected singleton bean has been instantiated., +Non-lazy singleton beans get instantiated according to their declaration order,, +so you may see different type matching results depending on when another component, +tries to match by a non-declared type (such as `@Autowired TransferServiceImpl`, +which will only resolve once the "transferService" bean has been instantiated)., +, +[TIP], +====, +If you consistently refer to your types by a declared service interface, your, +`@Bean` return types may safely join that design decision. However, for components, +implementing several interfaces or for components potentially referred to by their, +implementation type, it is safer to declare the most specific return type possible, +(at least as specific as required by the injection points referring to your bean)., +====, +, +, +, +, +, +]