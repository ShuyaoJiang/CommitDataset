[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +	private final Set<PropertyEditorRegistrar> propertyEditorRegistrars = new LinkedHashSet<>(4);, +, +	/** Custom PropertyEditors to apply to the beans of this factory */, +	private final Map<Class<?>, Class<? extends PropertyEditor>> customEditors = new HashMap<>(4);, +		setConversionService(otherFactory.getConversionService());, +			this.customEditors.putAll(otherAbstractFactory.customEditors);, +			this.typeConverter = otherAbstractFactory.typeConverter;, +			String[] otherScopeNames = otherFactory.getRegisteredScopeNames();, +			for (String scopeName : otherScopeNames) {, +				this.scopes.put(scopeName, otherFactory.getRegisteredScope(scopeName));, +			}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +	private final Set<PropertyEditorRegistrar> propertyEditorRegistrars = new LinkedHashSet<>(4);, +, +	/** Custom PropertyEditors to apply to the beans of this factory */, +	private final Map<Class<?>, Class<? extends PropertyEditor>> customEditors = new HashMap<>(4);, +		setConversionService(otherFactory.getConversionService());, +			this.customEditors.putAll(otherAbstractFactory.customEditors);, +			this.typeConverter = otherAbstractFactory.typeConverter;, +			String[] otherScopeNames = otherFactory.getRegisteredScopeNames();, +			for (String scopeName : otherScopeNames) {, +				this.scopes.put(scopeName, otherFactory.getRegisteredScope(scopeName));, +			}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.beans.BeanUtils;, +	 * @since 4.0, +	 * @since 4.0, +						((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.this);, +			this.dependencyComparator = otherListableFactory.dependencyComparator;, +			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware..., +			setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));, +			// Make resolvable dependencies (e.g. ResourceLoader) available here as well..., +			return this.frozenBeanDefinitionNames.clone();, +			if (result.isEmpty() && !(descriptor instanceof MultiElementDependencyDescriptor)) {, +				// Consider self references as a final pass..., +				// but not as collection elements, just for direct dependency declarations., +				// Probably a proxy interfering with target type match -> throw meaningful exception., +				if (!type.isAssignableFrom((beanType))) {, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +	private final Set<PropertyEditorRegistrar> propertyEditorRegistrars = new LinkedHashSet<>(4);, +, +	/** Custom PropertyEditors to apply to the beans of this factory */, +	private final Map<Class<?>, Class<? extends PropertyEditor>> customEditors = new HashMap<>(4);, +		setConversionService(otherFactory.getConversionService());, +			this.customEditors.putAll(otherAbstractFactory.customEditors);, +			this.typeConverter = otherAbstractFactory.typeConverter;, +			String[] otherScopeNames = otherFactory.getRegisteredScopeNames();, +			for (String scopeName : otherScopeNames) {, +				this.scopes.put(scopeName, otherFactory.getRegisteredScope(scopeName));, +			}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.beans.BeanUtils;, +	 * @since 4.0, +	 * @since 4.0, +						((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.this);, +			this.dependencyComparator = otherListableFactory.dependencyComparator;, +			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware..., +			setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));, +			// Make resolvable dependencies (e.g. ResourceLoader) available here as well..., +			return this.frozenBeanDefinitionNames.clone();, +			if (result.isEmpty() && !(descriptor instanceof MultiElementDependencyDescriptor)) {, +				// Consider self references as a final pass..., +				// but not as collection elements, just for direct dependency declarations., +				// Probably a proxy interfering with target type match -> throw meaningful exception., +				if (!type.isAssignableFrom((beanType))) {, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java, +		assertTrue(names != lbf.getBeanDefinitionNames());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +	private final Set<PropertyEditorRegistrar> propertyEditorRegistrars = new LinkedHashSet<>(4);, +, +	/** Custom PropertyEditors to apply to the beans of this factory */, +	private final Map<Class<?>, Class<? extends PropertyEditor>> customEditors = new HashMap<>(4);, +		setConversionService(otherFactory.getConversionService());, +			this.customEditors.putAll(otherAbstractFactory.customEditors);, +			this.typeConverter = otherAbstractFactory.typeConverter;, +			String[] otherScopeNames = otherFactory.getRegisteredScopeNames();, +			for (String scopeName : otherScopeNames) {, +				this.scopes.put(scopeName, otherFactory.getRegisteredScope(scopeName));, +			}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.beans.BeanUtils;, +	 * @since 4.0, +	 * @since 4.0, +						((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.this);, +			this.dependencyComparator = otherListableFactory.dependencyComparator;, +			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware..., +			setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));, +			// Make resolvable dependencies (e.g. ResourceLoader) available here as well..., +			return this.frozenBeanDefinitionNames.clone();, +			if (result.isEmpty() && !(descriptor instanceof MultiElementDependencyDescriptor)) {, +				// Consider self references as a final pass..., +				// but not as collection elements, just for direct dependency declarations., +				// Probably a proxy interfering with target type match -> throw meaningful exception., +				if (!type.isAssignableFrom((beanType))) {, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java, +		assertTrue(names != lbf.getBeanDefinitionNames());, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessorTests.java, +import java.util.LinkedList;, +		bf.registerBeanDefinition("annotatedBean", new RootBeanDefinition(SelfInjectionBean.class));]