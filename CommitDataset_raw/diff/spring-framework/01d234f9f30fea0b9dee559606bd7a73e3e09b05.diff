[+++ b/src/asciidoc/web-mvc.adoc, +	@GetMapping("/owners/{ownerId}"), +	@GetMapping("/owners/{ownerId}"), +detail. As long as your code is compiled with debugging information or the `-parameters`, +compiler flag on Java 8, Spring MVC will match the method argument name to the URI, +template variable name:, +	@GetMapping("/owners/{ownerId}"), +	@GetMapping("/owners/{ownerId}/pets/{petId}"), +A URI template can be assembled from type and method level __@RequestMapping__, +A `@PathVariable` argument can be of __any simple type__ such as `int`, `long`, `Date`, etc., +In addition to URI templates, the `@RequestMapping` annotation and all _composed_, +`@RequestMapping` variants also support Ant-style path patterns (for example,, +`/myPath/{asterisk}.do`). A combination of URI template variables and Ant-style globs is, +also supported (e.g. `/owners/{asterisk}/pets/{petId}`)., +Patterns in `@RequestMapping` annotations support `${...}` placeholders against local, +	@GetMapping("/pets/{petId}"), +	@GetMapping("/owners/{ownerId}/pets/{petId}"), +	@GetMapping("/pets/{petId}"), +	@GetMapping("/owners/{ownerId}/pets/{petId}"), +request will be matched only if the `Content-Type` request header matches the specified, +	@PostMapping(path = "/pets", **consumes = "application/json"**), +Consumable media type expressions can also be negated as in `!text/plain` to match to, +all requests other than those with `Content-Type` of `text/plain`. Also consider, +request will be matched only if the `Accept` request header matches one of these, +	@GetMapping(path = "/pets/{petId}", **produces = MediaType.APPLICATION_JSON_UTF8_VALUE**), +`!text/plain` to match to all requests other than those with an `Accept` header, +value of `text/plain`. Also consider using constants provided in `MediaType` such, +		@GetMapping(path = "/pets/{petId}", **params = "myParam=myValue"**), +		@GetMapping(path = "/pets", **headers = "myHeader=myValue"**), +is processed as if it were an HTTP GET except instead of writing the body only, +`@RequestMapping` methods have built-in support for HTTP OPTIONS. By default an, +HTTP method(s) that an `@RequestMapping` method is intended to handle, or alternatively, +use one of the dedicated _composed_ `@RequestMapping` variants (see, +<<mvc-ann-requestmapping-composed>>)., +`@RequestMapping` handler methods can have very flexible signatures. The supported, +arguments can be used in arbitrary order with the only exception being `BindingResult`, +	@PostMapping, +	@PostMapping, +		@GetMapping, +	@PutMapping("/something"), +The `@ResponseBody` annotation is similar to `@RequestBody`. This annotation can be placed, +	@GetMapping("/something"), +`@RequestMapping` methods with `@ResponseBody`, you can annotate your controller Class, +attribute rather than as a view name. The view name is then derived based on view name, +conventions instead, much like for methods returning `void` -- see <<mvc-coc-r2vnt>>., +	@PostMapping("/owners/{ownerId}/pets/{petId}/edit"), +	@PutMapping("/accounts/{account}"), +		// ..., +	@PostMapping("/owners/{ownerId}/pets/{petId}/edit"), +@PostMapping("update"), +	@PostMapping("/owners/{ownerId}/pets/{petId}/edit"), +	@PostMapping("/owners/{ownerId}/pets/{petId}/edit"), +Such init-binder methods support all arguments that `@RequestMapping` methods support,, +except for command/form objects and corresponding validation result objects. Init-binder, +		@GetMapping("/user"), +		@GetMapping("/user"), +	@PostMapping, +	@PostMapping("/files/{path}"), +		@GetMapping("/content"), +		@GetMapping("/bookings/{booking}"), +		@PostMapping("/form"), +		@PostMapping("/form"), +	@PostMapping("/someUrl"), +methods apply to exceptions raised by `@RequestMapping` methods of that controller (or, +As described in <<mvc-ann-httpentity>>, controllers can interact with the request/response using, +	@GetMapping("/book/{id}")]