[+++ b/spring-framework-reference/src/beans.xml, +          <para><link linkend="beans-java">Java-based, +  <section id="beans-java">, +    <section id="beans-java-basic-concepts">, +      <title>Basic concepts: <literal>@Configuration</literal> and <literal>@Bean</literal></title>, +      instantiation, configuration, and initialization logic for objects to, +      be managed by the Spring IoC container.</para>, +    @Bean, +    public void MyService myService() {, +        return new MyServiceImpl();, +    }, +      <para>For those more familiar with Spring <literal>&lt;beans/&gt;</literal>, +      XML, the <literal>AppConfig</literal> class above would be equivalent to:, +, +      <programlisting language="xml">&lt;beans&gt;, +    &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;, +&lt;/beans&gt;</programlisting>, +, +      As you can see, the <literal>@Bean</literal> annotation plays the same role, +      as the <literal>&lt;bean/&gt;</literal> element.  The <literal>@Bean</literal>, +      annotation will be discussed in depth in the sections below.  First, however,, +      we'll cover the various ways of creating a spring container using Java-based, +      configuration.</para>, +    <section id="beans-java-instantiating-container">, +      <title>Instantiating the Spring container using, +      <literal>AnnotationConfigApplicationContext</literal></title>, +, +      <para>The sections below document Spring's, +      <literal>AnnotationConfigApplicationContext</literal>, new in Spring 3.0., +      This versatile <literal>ApplicationContext</literal> implementation is, +      capable of accepting not only <literal>@Configuration</literal> classes, +      as input, but also plain <literal>@Component</literal> classes and classes, +      annotated with JSR-330 metadata.</para>, +, +      <para>When <literal>@Configuration</literal> classes are provided as input,, +      the <literal>@Configuration</literal> class itself is registered as a bean, +      definition, and all declared <literal>@Bean</literal> methods within the, +      class are also registered as bean definitions.</para>, +, +      <para>When <literal>@Component</literal> and JSR-330 classes are provided,, +      they are registered as bean definitions, and it is assumed that DI metadata, +      such as <literal>@Autowired</literal> or <literal>@Inject</literal> are used, +      within those classes where necessary.</para>, +, +      <section id="beans-java-instantiating-container-contstructor">, +        <title>Simple construction</title>, +          <para>In much the same way that Spring XML files are used as input when, +          instantiating a <literal>ClassPathXmlApplicationContext</literal>,, +          <literal>@Configuration</literal> classes may be used as input when, +          instantiating an <literal>AnnotationConfigApplicationContext</literal>., +          This allows for completely XML-free usage of the Spring container:, +          <programlisting language="java">public static void main(String[] args) {, +    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);, +    MyService myService = ctx.getBean(MyService.class);, +    myService.doStuff();, +}</programlisting>, +, +          As mentioned above, <literal>AnnotationConfigApplicationContext</literal>, +          is not limited to working only with <literal>@Configuration</literal>, +          classes. Any <literal>@Component</literal> or JSR-330 annotated class may, +          be supplied as input to the constructor.  For example:, +          <programlisting language="java">public static void main(String[] args) {, +    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);, +    MyService myService = ctx.getBean(MyService.class);, +    myService.doStuff();, +}</programlisting>, +, +The above assumes that <literal>MyServiceImpl</literal>, <literal>Dependency1</literal> and <literal>Dependency2</literal> use Spring dependency injection annotations such as <literal>@Autowired</literal>.</para>, +      </section>, +, +      <section id="beans-java-instantiating-container-register">, +        <title>Building the container programmatically using <literal>register(Class&lt;?&gt;...)</literal></title>, +        <para>An <literal>AnnotationConfigApplicationContext</literal> may be, +        instantiated using a no-arg constructor and then configured using the, +        <literal>register()</literal> method. This approach is particularly, +        useful when programmatically building an, +        <literal>AnnotationConfigApplicationContext</literal>., +        <programlisting language="java">public static void main(String[] args) {, +    ApplicationContext ctx = new AnnotationConfigApplicationContext();, +    ctx.register(AppConfig.class, OtherConfig.class);, +    ctx.register(AdditionalConfig.class);, +    ctx.refresh();, +    MyService myService = ctx.getBean(MyService.class);, +    myService.doStuff();, +}</programlisting></para>, +      </section>, +, +      <section id="beans-java-instantiating-container-scan">, +        <title>Enabling component scanning with <literal>scan(String...)</literal></title>, +        <para>Experienced Spring users will be familiar with the following, +        commonly-used XML declaration from Spring's <literal>context:</literal> namespace, +        <programlisting language="xml">&lt;beans&gt;, +    &lt;context:component-scan base-package="com.acme"/&gt;, +&lt;/beans&gt;</programlisting>, +, +        In the example above, the <literal>com.acme</literal> package will, +        be scanned, looking for any <literal>@Component</literal>-annotated, +        classes, and those classes will be registered as Spring bean, +        definitions within the container., +]