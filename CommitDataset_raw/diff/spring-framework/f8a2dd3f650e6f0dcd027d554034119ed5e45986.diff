[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, + * @author Clark Duplichien , +						if (clazz == targetType) {, +							specificAccessors.add( resolver);, +							break;, +						else if (clazz.isAssignableFrom(targetType)) { , +		generalAccessors.removeAll(specificAccessors);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, + * @author Clark Duplichien , +						if (clazz == targetType) {, +							specificAccessors.add( resolver);, +							break;, +						else if (clazz.isAssignableFrom(targetType)) { , +		generalAccessors.removeAll(specificAccessors);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/SpringEL300Tests.java, +import java.lang.reflect.Field;, + * @author Clark Duplichien, +	/**, +	 * We add property accessors in the order:, +	 * First, Second, Third, Fourth., +	 * They are not utilized in this order; preventing a priority or order of operations, +	 * in evaluation of SPEL expressions for a given context., +	 */, +	@Test, +	public void testPropertyAccessorOrder_8211() {, +		ExpressionParser expressionParser = new SpelExpressionParser();, +		StandardEvaluationContext evaluationContext = , +			new StandardEvaluationContext(new ContextObject());, +		, +		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("firstContext"));, +		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("secondContext"));, +		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("thirdContext"));, +		evaluationContext.addPropertyAccessor(new TestPropertyAccessor("fourthContext"));, +		, +		assertEquals("first", , +			expressionParser.parseExpression("shouldBeFirst").getValue(evaluationContext));, +		assertEquals("second", , +				expressionParser.parseExpression("shouldBeSecond").getValue(evaluationContext));, +		assertEquals("third", , +				expressionParser.parseExpression("shouldBeThird").getValue(evaluationContext));, +		assertEquals("fourth", , +				expressionParser.parseExpression("shouldBeFourth").getValue(evaluationContext));, +	, +	// test not quite complete, it doesn't check that the list of resolvers at the end of , +	// PropertyOrFieldReference.getPropertyAccessorsToTry() doesn't contain duplicates, which, +	// is what it is trying to test by having a property accessor that returns specific, +	// classes Integer and Number, +//	@Test, +//	public void testPropertyAccessorOrder_8211_2() {, +//		ExpressionParser expressionParser = new SpelExpressionParser();, +//		StandardEvaluationContext evaluationContext = , +//			new StandardEvaluationContext(new Integer(42));, +//		, +//		evaluationContext.addPropertyAccessor(new TestPropertyAccessor2());, +//		, +//		assertEquals("42", expressionParser.parseExpression("x").getValue(evaluationContext));, +//	}, +	, +	class TestPropertyAccessor implements PropertyAccessor {, +		private String mapName;, +		public TestPropertyAccessor(String mapName) {, +			this.mapName = mapName;, +		}, +		@SuppressWarnings("unchecked"), +		public Map<String, String> getMap(Object target) {, +			try {, +				Field f = target.getClass().getDeclaredField(mapName);, +				return (Map<String,String>) f.get(target);, +			} catch (Exception e) {, +			}, +			return null;, +		}, +		public boolean canRead(EvaluationContext context, Object target, String name), +				throws AccessException {, +			return getMap(target).containsKey(name);, +		}, +		public boolean canWrite(EvaluationContext context, Object target, String name), +				throws AccessException {, +			return getMap(target).containsKey(name);, +		}, +		public Class<?>[] getSpecificTargetClasses() {, +			return new Class[]{ContextObject.class};, +		}, +		public TypedValue read(EvaluationContext context, Object target, String name), +				throws AccessException {, +			return new TypedValue(getMap(target).get(name));, +		}, +		public void write(EvaluationContext context, Object target, String name, Object newValue), +			throws AccessException {, +			getMap(target).put(name, (String) newValue);, +		}, +, +	}, +	, +//	class TestPropertyAccessor2 implements PropertyAccessor {, +//, +//		public Class[] getSpecificTargetClasses() {, +//			return new Class[]{Integer.class,Number.class};, +//		}, +//]