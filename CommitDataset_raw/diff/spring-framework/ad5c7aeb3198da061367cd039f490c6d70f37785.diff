[+++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java, +	private int idleConsumerLimit = 1;, +, +	 * <p>Currently known servers that absolutely require CACHE_NONE for XA transaction, +	 * processing: JBoss 4. For any others, consider raising the cache level., +	public final int getMaxMessagesPerTask() {, +	 * Specify the limit for the number of consumers that are allowed to be idle, +	 * at any given time., +	 * <p>This limit is used by the {@link #scheduleNewInvokerIfAppropriate} method, +	 * to determine if a new invoker should be created. Increasing the limit causes, +	 * invokers to be created more aggressively. This can be useful to ramp up the, +	 * number of invokers faster., +	 * <p>The default is 1, only scheduling a new invoker (which is likely to, +	 * be idle initially) if none of the existing invokers is currently idle., +	 */, +	public void setIdleConsumerLimit(int idleConsumerLimit) {, +		Assert.isTrue(idleConsumerLimit > 0, "'idleConsumerLimit' must be 1 or higher");, +		synchronized (this.lifecycleMonitor) {, +			this.idleConsumerLimit = idleConsumerLimit;, +		}, +	}, +, +	/**, +	 * Return the limit for the number of idle consumers. , +	 */, +	public final int getIdleConsumerLimit() {, +		synchronized (this.lifecycleMonitor) {, +			return this.idleConsumerLimit;, +		}, +	}, +, +	/**, +	 * Specify the limit for idle executions of a consumer task, not having, +	 * <p>The default is 1, closing idle resources early once a task didn't, +	 * Return the limit for idle executions of a consumer task., +	public final int getIdleTaskExecutionLimit() {, +	 * if the specified "idleConsumerLimit" has not been reached either., +	 * <p>Called once a message has been received, in order to scale up while, +	 * @see #getIdleConsumerLimit(), +				if (this.scheduledInvokers.size() < this.maxConcurrentConsumers &&, +						getIdleInvokerCount() < this.idleConsumerLimit) {]