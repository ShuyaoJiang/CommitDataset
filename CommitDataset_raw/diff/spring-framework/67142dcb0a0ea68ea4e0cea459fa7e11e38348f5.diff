[+++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj, +				"Calls have been recorded, but playback state was never reached. Set expectations and then call ", +						+ this.getClass().getSimpleName() + ".playback();");, +++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj, +				"Calls have been recorded, but playback state was never reached. Set expectations and then call ", +						+ this.getClass().getSimpleName() + ".playback();");, +++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj, + * <h3>Usage</h3>, + * <li>In each test method, the {@code AnnotationDrivenStaticEntityMockingControl}, + * recording-mode invocation being followed by an invocation of either, + * {@link #expectReturn(Object)} or {@link #expectThrow(Throwable)} on the, + * {@code AnnotationDrivenStaticEntityMockingControl}., + * <li>Invoke the {@link #playback()} method., + * <li>Call the code you wish to test that uses the static methods on the, + * JPA-annotated {@code @Entity} classes., + * <li>Verification will occur automatically after the test method has executed, + * and returned. However, mock verification will not occur if the test method, + * throws an exception., +++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj, +				"Calls have been recorded, but playback state was never reached. Set expectations and then call ", +						+ this.getClass().getSimpleName() + ".playback();");, +++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj, + * <h3>Usage</h3>, + * <li>In each test method, the {@code AnnotationDrivenStaticEntityMockingControl}, + * recording-mode invocation being followed by an invocation of either, + * {@link #expectReturn(Object)} or {@link #expectThrow(Throwable)} on the, + * {@code AnnotationDrivenStaticEntityMockingControl}., + * <li>Invoke the {@link #playback()} method., + * <li>Call the code you wish to test that uses the static methods on the, + * JPA-annotated {@code @Entity} classes., + * <li>Verification will occur automatically after the test method has executed, + * and returned. However, mock verification will not occur if the test method, + * throws an exception., +++ b/spring-aspects/src/test/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControlTests.java, +		expectReturn(found);, +		playback();, +		expectThrow(new PersistenceException());, +		playback();, +	public void reentrantCallToPrivateMethod() {, +		privateMethod(found, id);, +	private void privateMethod(Person found, long id) {, +	@Test, +	public void reentrantCallToPublicMethod() {, +		final Long ID = 13L;, +		Person.findPerson(ID);, +		expectReturn(new Person());, +		playback();, +		try {, +			publicMethod();, +			fail("Should have thrown an IllegalStateException");, +		}, +		catch (IllegalStateException e) {, +			assertTrue(e.getMessage().contains("Calls have been recorded, but playback state was never reached."));, +		}, +, +		// Now to keep the mock for "this" method happy:, +		Person.findPerson(ID);, +	}, +, +	public void publicMethod() {, +		// At this point, since publicMethod() is a public method in a class, +		// annotated with @MockStaticEntityMethods, the current mock state is, +		// fresh. In other words, we are again in recording mode. As such, any, +		// call to a mocked method will return null. See the implementation of, +		// the <methodToMock() && cflowbelow(mockStaticsTestMethod())> around, +		// advice in AbstractMethodMockingControl for details., +		assertNull(Person.findPerson(99L));, +	}, +, +	public void unexpectedCall() {, +		playback();, +		expectReturn(found);, +		expectReturn(25);, +		playback();, +	public void noExpectationsAndNoPlayback() {, +		// Ensure that mock verification doesn't blow up if playback() was not invoked and, +		// no expectations were set., +	}, +, +	@Test, +	public void noExpectationsButWithPlayback() {, +		// Ensure that mock verification doesn't blow up if playback() was invoked but no, +		// expectations were set., +		playback();, +		playback();, +	 * Currently, the method mocking aspect will not verify the state of the, +	 * expectations within the mock if a test method throws an exception., +	 *, +	 * <p>The reason is that the {@code mockStaticsTestMethod()} advice in, +	 * {@link AbstractMethodMockingControl} is declared as, +	 * {@code after() returning} instead of simply {@code after()}., +	 *, +	 * <p>If the aforementioned advice is changed to a generic "after" advice,, +	 * this test method will fail with an {@link IllegalStateException} (thrown, +	 * by the mock aspect) instead of the {@link UnsupportedOperationException}, +	 * thrown by the test method itself., +	@Test(expected = UnsupportedOperationException.class), +	public void mockVerificationDoesNotOccurIfTestFailsWithAnExpectedException() {, +		playback();, +		// We intentionally do not execute any of the recorded method invocations in order]