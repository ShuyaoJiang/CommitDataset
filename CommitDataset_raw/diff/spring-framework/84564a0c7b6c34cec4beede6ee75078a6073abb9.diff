[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.springframework.util.Assert;, +	private final Log logger = LogFactory.getLog(getClass());, +, +	private final Set<String> propertySourceNames = new LinkedHashSet<String>();, +			if (!(this.environment instanceof ConfigurableEnvironment)) {, +				logger.warn("Ignoring @PropertySource annotation on ", +						+ sourceClass.getMetadata().getClassName(), +						+ "Reason: Environment must implement ConfigurableEnvironment");, +			} else {, +		}, +	 * @throws IOException if loading a property source failed, +	private void processPropertySource(AnnotationAttributes propertySource) throws IOException {, +		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");, +				processPropertySourceLocation(name, location);, +				if (!ignoreResourceNotFound) {, +				if (!ignoreResourceNotFound) {, +	}, +	private void processPropertySourceLocation(String name, String location) throws IOException, FileNotFoundException {, +		String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);, +		Resource resource = this.resourceLoader.getResource(resolvedLocation);, +		AnnotationPropertySource propertySource = (StringUtils.hasText(name) ?, +				new AnnotationPropertySource(name, resource) : new AnnotationPropertySource(resource));, +		addPropertySource(propertySource);, +	}, +, +	private void addPropertySource(AnnotationPropertySource propertySource) {, +		String name = propertySource.getName();, +		MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();, +		if (propertySources.contains(name) && this.propertySourceNames.contains(name)) {, +			// We've already added a version, we need to extend it, +			PropertySource<?> existing = propertySources.get(name);, +			if (existing instanceof CompositePropertySource) {, +				((CompositePropertySource) existing).addFirstPropertySource(, +						propertySource.resourceNamedPropertySource());, +				if (existing instanceof AnnotationPropertySource) {, +					existing = ((AnnotationPropertySource) existing).resourceNamedPropertySource();, +				CompositePropertySource composite = new CompositePropertySource(name);, +				composite.addPropertySource(propertySource.resourceNamedPropertySource());, +				composite.addPropertySource(existing);, +				propertySources.replace(name, composite);, +		else {, +			if(this.propertySourceNames.isEmpty()) {, +				propertySources.addLast(propertySource);, +			} else {, +				String firstProcessed = this.propertySourceNames.iterator().next();, +				propertySources.addBefore(firstProcessed, propertySource);, +			}, +		}, +		this.propertySourceNames.add(name);, +	}, +, +	private static class AnnotationPropertySource extends ResourcePropertySource {, +, +		/** The resource name or null if the same as getName() */, +		private final String resourceName;, +, +		public AnnotationPropertySource(Resource resource) throws IOException {, +			super(resource);, +			this.resourceName = null;, +		}, +, +		public AnnotationPropertySource(String name, Resource resource) throws IOException {, +			super(name, resource);, +			this.resourceName = getNameForResource(resource);, +		}, +, +		protected AnnotationPropertySource(String name, Map<String, Object> source) {, +			super(name, source);, +			this.resourceName = null;, +		}, +, +		public AnnotationPropertySource resourceNamedPropertySource() {, +			if (this.resourceName == null) {, +				return this;, +			}, +			return new AnnotationPropertySource(this.resourceName, getSource());, +		}, +, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.springframework.util.Assert;, +	private final Log logger = LogFactory.getLog(getClass());, +, +	private final Set<String> propertySourceNames = new LinkedHashSet<String>();, +			if (!(this.environment instanceof ConfigurableEnvironment)) {, +				logger.warn("Ignoring @PropertySource annotation on ", +						+ sourceClass.getMetadata().getClassName(), +						+ "Reason: Environment must implement ConfigurableEnvironment");, +			} else {, +		}, +	 * @throws IOException if loading a property source failed, +	private void processPropertySource(AnnotationAttributes propertySource) throws IOException {, +		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");, +				processPropertySourceLocation(name, location);]