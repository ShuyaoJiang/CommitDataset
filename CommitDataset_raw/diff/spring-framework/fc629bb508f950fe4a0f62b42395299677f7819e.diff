[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java, + * creates, and "specific" interceptors: unique per bean instance. There need not be any, + * common interceptors. If there are, they are set using the interceptorNames property., + * As with {@link org.springframework.aop.framework.ProxyFactoryBean}, interceptors names, + * in the current factory are used rather than bean references to allow correct handling, + * of prototype advisors and interceptors: for example, to support stateful mixins., + * Any advice type is supported for {@link #setInterceptorNames "interceptorNames"} entries., + * <p>Subclasses can apply any strategy to decide if a bean is to be proxied, e.g. by type,, + * by name, by definition details, etc. They can also return additional interceptors that, + * should just be applied to the specific bean instance. A simple concrete implementation is, + * {@link BeanNameAutoProxyCreator}, identifying the beans to be proxied via given names., + * a custom target source: for example, to pool prototype objects. Auto-proxying will, +	private final Set<String> targetSourcedBeans = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	private final Set<Object> earlyProxyReferences = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	 * Specify the {@link AdvisorAdapterRegistry} to use., +	 * <p>Default is the global {@link AdvisorAdapterRegistry}., +	 * Set custom {@code TargetSourceCreators} to be applied in this order., +	 * If the list is empty, or they all return null, a {@link SingletonTargetSource}, +	 * where no advices or advisors have been found. If a {@code TargetSourceCreator}, +	 * returns a {@link TargetSource} for a specific bean, that bean will be proxied, +	 * <p>{@code TargetSourceCreators} can only be invoked if this post processor is used, +	 * in a {@link BeanFactory} and its {@link BeanFactoryAware} callback is triggered., +	 * @param targetSourceCreators the list of {@code TargetSourceCreators}., +	 * Ordering is significant: The {@code TargetSource} returned from the first matching, +	 * {@code TargetSourceCreator} (that is, the first that returns non-null) will be used., +	 * Return the owning {@link BeanFactory}., +	 * May be {@code null}, as this post-processor doesn't need to belong to a bean factory., +++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java, + * creates, and "specific" interceptors: unique per bean instance. There need not be any, + * common interceptors. If there are, they are set using the interceptorNames property., + * As with {@link org.springframework.aop.framework.ProxyFactoryBean}, interceptors names, + * in the current factory are used rather than bean references to allow correct handling, + * of prototype advisors and interceptors: for example, to support stateful mixins., + * Any advice type is supported for {@link #setInterceptorNames "interceptorNames"} entries., + * <p>Subclasses can apply any strategy to decide if a bean is to be proxied, e.g. by type,, + * by name, by definition details, etc. They can also return additional interceptors that, + * should just be applied to the specific bean instance. A simple concrete implementation is, + * {@link BeanNameAutoProxyCreator}, identifying the beans to be proxied via given names., + * a custom target source: for example, to pool prototype objects. Auto-proxying will, +	private final Set<String> targetSourcedBeans = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	private final Set<Object> earlyProxyReferences = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	 * Specify the {@link AdvisorAdapterRegistry} to use., +	 * <p>Default is the global {@link AdvisorAdapterRegistry}., +	 * Set custom {@code TargetSourceCreators} to be applied in this order., +	 * If the list is empty, or they all return null, a {@link SingletonTargetSource}, +	 * where no advices or advisors have been found. If a {@code TargetSourceCreator}, +	 * returns a {@link TargetSource} for a specific bean, that bean will be proxied, +	 * <p>{@code TargetSourceCreators} can only be invoked if this post processor is used, +	 * in a {@link BeanFactory} and its {@link BeanFactoryAware} callback is triggered., +	 * @param targetSourceCreators the list of {@code TargetSourceCreators}., +	 * Ordering is significant: The {@code TargetSource} returned from the first matching, +	 * {@code TargetSourceCreator} (that is, the first that returns non-null) will be used., +	 * Return the owning {@link BeanFactory}., +	 * May be {@code null}, as this post-processor doesn't need to belong to a bean factory., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/MergedBeanDefinitionPostProcessor.java, + * Copyright 2002-2016 the original author or authors., + * {@link BeanPostProcessor} implementations may implement this sub-interface in order, + * to post-process the merged bean definition (a processed copy of the original bean, + * definition) that the Spring {@code BeanFactory} uses to create a bean instance., + * actual instances of a bean. It is also allowed to modify the bean definition but, + * <i>only</i> for definition properties which are actually intended for concurrent, + * modification. Essentially, this only applies to operations defined on the, + * {@link RootBeanDefinition} itself but not to the properties of its base classes., + * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#getMergedBeanDefinition, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java, + * creates, and "specific" interceptors: unique per bean instance. There need not be any, + * common interceptors. If there are, they are set using the interceptorNames property., + * As with {@link org.springframework.aop.framework.ProxyFactoryBean}, interceptors names, + * in the current factory are used rather than bean references to allow correct handling, + * of prototype advisors and interceptors: for example, to support stateful mixins., + * Any advice type is supported for {@link #setInterceptorNames "interceptorNames"} entries., + * <p>Subclasses can apply any strategy to decide if a bean is to be proxied, e.g. by type,, + * by name, by definition details, etc. They can also return additional interceptors that, + * should just be applied to the specific bean instance. A simple concrete implementation is, + * {@link BeanNameAutoProxyCreator}, identifying the beans to be proxied via given names., + * a custom target source: for example, to pool prototype objects. Auto-proxying will, +	private final Set<String> targetSourcedBeans = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	private final Set<Object> earlyProxyReferences = Collections.newSetFromMap(new ConcurrentHashMap<>(16));, +	 * Specify the {@link AdvisorAdapterRegistry} to use., +	 * <p>Default is the global {@link AdvisorAdapterRegistry}., +	 * Set custom {@code TargetSourceCreators} to be applied in this order., +	 * If the list is empty, or they all return null, a {@link SingletonTargetSource}, +	 * where no advices or advisors have been found. If a {@code TargetSourceCreator}, +	 * returns a {@link TargetSource} for a specific bean, that bean will be proxied, +	 * <p>{@code TargetSourceCreators} can only be invoked if this post processor is used, +	 * in a {@link BeanFactory} and its {@link BeanFactoryAware} callback is triggered., +	 * @param targetSourceCreators the list of {@code TargetSourceCreators}., +	 * Ordering is significant: The {@code TargetSource} returned from the first matching, +	 * {@code TargetSourceCreator} (that is, the first that returns non-null) will be used., +	 * Return the owning {@link BeanFactory}., +	 * May be {@code null}, as this post-processor doesn't need to belong to a bean factory., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/MergedBeanDefinitionPostProcessor.java, + * Copyright 2002-2016 the original author or authors., + * {@link BeanPostProcessor} implementations may implement this sub-interface in order, + * to post-process the merged bean definition (a processed copy of the original bean, + * definition) that the Spring {@code BeanFactory} uses to create a bean instance., + * actual instances of a bean. It is also allowed to modify the bean definition but, + * <i>only</i> for definition properties which are actually intended for concurrent, + * modification. Essentially, this only applies to operations defined on the, + * {@link RootBeanDefinition} itself but not to the properties of its base classes.]