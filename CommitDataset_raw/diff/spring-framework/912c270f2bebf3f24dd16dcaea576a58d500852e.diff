[+++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +		boolean ifcCheck = baseType.isInterface();, +		if (ifcCheck && ClassUtils.isJavaLanguageInterface(baseType)) {, +		Method[] methods = (ifcCheck ? baseType.getMethods() : baseType.getDeclaredMethods());, +				// Public methods on interfaces (including interface hierarchy),, +				// non-private (and therefore overridable) methods on base classes, +				if ((ifcCheck || !Modifier.isPrivate(baseMethod.getModifiers())) &&, +						hasSearchableAnnotations(baseMethod)) {, +++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +		boolean ifcCheck = baseType.isInterface();, +		if (ifcCheck && ClassUtils.isJavaLanguageInterface(baseType)) {, +		Method[] methods = (ifcCheck ? baseType.getMethods() : baseType.getDeclaredMethods());, +				// Public methods on interfaces (including interface hierarchy),, +				// non-private (and therefore overridable) methods on base classes, +				if ((ifcCheck || !Modifier.isPrivate(baseMethod.getModifiers())) &&, +						hasSearchableAnnotations(baseMethod)) {, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +	private void assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(, +			Class<?> clazz, String expected) {, +++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +		boolean ifcCheck = baseType.isInterface();, +		if (ifcCheck && ClassUtils.isJavaLanguageInterface(baseType)) {, +		Method[] methods = (ifcCheck ? baseType.getMethods() : baseType.getDeclaredMethods());, +				// Public methods on interfaces (including interface hierarchy),, +				// non-private (and therefore overridable) methods on base classes, +				if ((ifcCheck || !Modifier.isPrivate(baseMethod.getModifiers())) &&, +						hasSearchableAnnotations(baseMethod)) {, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +	private void assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(, +			Class<?> clazz, String expected) {, +++ b/spring-test/src/main/java/org/springframework/test/web/servlet/MockMvc.java, +, +++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +		boolean ifcCheck = baseType.isInterface();, +		if (ifcCheck && ClassUtils.isJavaLanguageInterface(baseType)) {, +		Method[] methods = (ifcCheck ? baseType.getMethods() : baseType.getDeclaredMethods());, +				// Public methods on interfaces (including interface hierarchy),, +				// non-private (and therefore overridable) methods on base classes, +				if ((ifcCheck || !Modifier.isPrivate(baseMethod.getModifiers())) &&, +						hasSearchableAnnotations(baseMethod)) {, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +	private void assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(, +			Class<?> clazz, String expected) {, +++ b/spring-test/src/main/java/org/springframework/test/web/servlet/MockMvc.java, +, +++ b/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java, +			if (c1 == c2 || (ignoreCase && (Character.toLowerCase(c1) == Character.toLowerCase(c2)))) {, +++ b/spring-context/src/test/java/org/springframework/scheduling/concurrent/AbstractSchedulingTaskExecutorTests.java, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +		future1.get(100, TimeUnit.MILLISECONDS);, +		future2.get(100, TimeUnit.MILLISECONDS);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +		boolean ifcCheck = baseType.isInterface();, +		if (ifcCheck && ClassUtils.isJavaLanguageInterface(baseType)) {, +		Method[] methods = (ifcCheck ? baseType.getMethods() : baseType.getDeclaredMethods());, +				// Public methods on interfaces (including interface hierarchy),, +				// non-private (and therefore overridable) methods on base classes, +				if ((ifcCheck || !Modifier.isPrivate(baseMethod.getModifiers())) &&, +						hasSearchableAnnotations(baseMethod)) {, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +	private void assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(, +			Class<?> clazz, String expected) {, +++ b/spring-test/src/main/java/org/springframework/test/web/servlet/MockMvc.java, +, +++ b/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java, +			if (c1 == c2 || (ignoreCase && (Character.toLowerCase(c1) == Character.toLowerCase(c2)))) {, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ResourceBundleViewResolver.java, +	/** The default basename if no other basename is supplied */, +	private int order = Ordered.LOWEST_PRECEDENCE;  // default: same as non-Ordered, +, +	 * @see ResourceBundle#getBundle(String), +	 * @see ResourceBundle#getBundle(String, Locale), +	 * @see ResourceBundle#getBundle(String), +	 * @see ResourceBundle#getBundle(String, Locale, ClassLoader)]