[+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/JdbcTransactionObjectSupport.java, + * Copyright 2002-2017 the original author or authors., + * Convenient base class for JDBC-aware transaction objects. Can contain a, + * {@link ConnectionHolder} with a JDBC {@code Connection}, and implements the, + * {@link SavepointManager} interface based on that {@code ConnectionHolder}., + * <p>Allows for programmatic management of JDBC {@link java.sql.Savepoint Savepoints}., + * Spring's {@link org.springframework.transaction.support.DefaultTransactionStatus}, + * automatically delegates to this, as it autodetects transaction objects which, + * implement the {@link SavepointManager} interface., + * @see DataSourceTransactionManager, +			if (conHolder.isRollbackOnly()) {, +				throw new CannotCreateTransactionException(, +						"Cannot create savepoint for transaction which is already marked as rollback-only");, +			}, +			conHolder.resetRollbackOnly();, +					"Cannot create nested transaction when not exposing a JDBC transaction");, +++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/JdbcTransactionObjectSupport.java, + * Copyright 2002-2017 the original author or authors., + * Convenient base class for JDBC-aware transaction objects. Can contain a, + * {@link ConnectionHolder} with a JDBC {@code Connection}, and implements the, + * {@link SavepointManager} interface based on that {@code ConnectionHolder}., + * <p>Allows for programmatic management of JDBC {@link java.sql.Savepoint Savepoints}., + * Spring's {@link org.springframework.transaction.support.DefaultTransactionStatus}, + * automatically delegates to this, as it autodetects transaction objects which, + * implement the {@link SavepointManager} interface., + * @see DataSourceTransactionManager, +			if (conHolder.isRollbackOnly()) {, +				throw new CannotCreateTransactionException(, +						"Cannot create savepoint for transaction which is already marked as rollback-only");, +			}, +			conHolder.resetRollbackOnly();, +					"Cannot create nested transaction when not exposing a JDBC transaction");, +++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceTransactionManagerTests.java, +	public void testExistingTransactionWithPropagationNestedAndRequiredRollback() throws Exception {, +		DatabaseMetaData md = mock(DatabaseMetaData.class);, +		Savepoint sp = mock(Savepoint.class);, +, +		given(md.supportsSavepoints()).willReturn(true);, +		given(con.getMetaData()).willReturn(md);, +		given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp);, +, +		final TransactionTemplate tt = new TransactionTemplate(tm);, +		tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED);, +		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));, +		assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive());, +, +		tt.execute(new TransactionCallbackWithoutResult() {, +			@Override, +			protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {, +				assertTrue("Is new transaction", status.isNewTransaction());, +				assertTrue("Isn't nested transaction", !status.hasSavepoint());, +				try {, +					tt.execute(new TransactionCallbackWithoutResult() {, +						@Override, +						protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {, +							assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds));, +							assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive());, +							assertTrue("Isn't new transaction", !status.isNewTransaction());, +							assertTrue("Is nested transaction", status.hasSavepoint());, +							TransactionTemplate ntt = new TransactionTemplate(tm);, +							ntt.execute(new TransactionCallbackWithoutResult() {, +								@Override, +								protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {, +									assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds));, +									assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive());, +									assertTrue("Isn't new transaction", !status.isNewTransaction());, +									assertTrue("Is regular transaction", !status.hasSavepoint());, +									throw new IllegalStateException();, +								}, +							});, +						}, +					});, +					fail("Should have thrown IllegalStateException");, +				}, +				catch (IllegalStateException ex) {, +					// expected, +				}, +				assertTrue("Is new transaction", status.isNewTransaction());, +				assertTrue("Isn't nested transaction", !status.hasSavepoint());, +			}, +		});, +, +		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));, +		verify(con).rollback(sp);, +		verify(con).releaseSavepoint(sp);, +		verify(con).commit();, +		verify(con).isReadOnly();, +		verify(con).close();, +	}, +, +	@Test, +	public void testExistingTransactionWithPropagationNestedAndRequiredRollbackOnly() throws Exception {, +		DatabaseMetaData md = mock(DatabaseMetaData.class);, +		Savepoint sp = mock(Savepoint.class);, +, +		given(md.supportsSavepoints()).willReturn(true);, +		given(con.getMetaData()).willReturn(md);, +		given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp);, +, +		final TransactionTemplate tt = new TransactionTemplate(tm);]