[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpResponse.java, +	 * a nonce for CSRF protection, or other., +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpResponse.java, +	 * a nonce for CSRF protection, or other., +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceTransformerSupport.java, +			return (urlProvider != null ? urlProvider.getForUriString(resourcePath, exchange) : Mono.empty());, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpResponse.java, +	 * a nonce for CSRF protection, or other., +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceTransformerSupport.java, +			return (urlProvider != null ? urlProvider.getForUriString(resourcePath, exchange) : Mono.empty());, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceUrlProvider.java, +	private final PathPatternParser patternParser = new PathPatternParser();, +	 * configured or auto-detected from Spring configuration., +, +	 * Manually configure resource handler mappings., +	 * <p><strong>Note:</strong> by default resource mappings are auto-detected, +	 * from the Spring {@code ApplicationContext}. If this property is used,, +	 * auto-detection is turned off., +	public void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {, +		this.handlerMap.clear();, +		handlerMap.forEach((rawPattern, resourceWebHandler) -> {, +			rawPattern = prependLeadingSlash(rawPattern);, +			PathPattern pattern = this.patternParser.parse(rawPattern);, +			this.handlerMap.put(pattern, resourceWebHandler);, +		});, +	private static String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {, +			return pattern;, +		}, +	}, +		if (this.handlerMap.isEmpty()) {, +			if(logger.isDebugEnabled()) {, +		List<SimpleUrlHandlerMapping> mappings = new ArrayList<>(map.values());, +		AnnotationAwareOrderComparator.sort(mappings);, +		mappings.forEach(mapping -> {, +	 * Get the public resource URL for the given URI string., +	 * <p>The URI string is expected to be a path and if it contains a query or, +	 * fragment those will be preserved in the resulting public resource URL., +	 * @param uriString the URI string to transform, +	 * @return the resolved public resource URL path, or empty if unresolved, +	public final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {, +			logger.trace("Getting resource URL for request URL \"" + uriString + "\"");, +		int queryIndex = getQueryIndex(uriString);, +		String lookupPath = uriString.substring(0, queryIndex);, +		String query = uriString.substring(queryIndex);, +		if (logger.isTraceEnabled()) {, +			logger.trace("Getting resource URL for lookup path \"" + lookupPath + "\"");, +		}, +		return resolveResourceUrl(parsedLookupPath).map(resolvedPath ->, +	private int getQueryIndex(String path) {, +		int suffixIndex = path.length();, +		int queryIndex = path.indexOf("?");, +		int hashIndex = path.indexOf("#");, +	private Mono<String> resolveResourceUrl(PathContainer lookupPath) {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpResponse.java, +	 * a nonce for CSRF protection, or other., +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceTransformerSupport.java, +			return (urlProvider != null ? urlProvider.getForUriString(resourcePath, exchange) : Mono.empty());, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceUrlProvider.java, +	private final PathPatternParser patternParser = new PathPatternParser();, +	 * configured or auto-detected from Spring configuration., +, +	 * Manually configure resource handler mappings., +	 * <p><strong>Note:</strong> by default resource mappings are auto-detected, +	 * from the Spring {@code ApplicationContext}. If this property is used,, +	 * auto-detection is turned off., +	public void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {, +		this.handlerMap.clear();, +		handlerMap.forEach((rawPattern, resourceWebHandler) -> {, +			rawPattern = prependLeadingSlash(rawPattern);, +			PathPattern pattern = this.patternParser.parse(rawPattern);, +			this.handlerMap.put(pattern, resourceWebHandler);, +		});, +	private static String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {, +			return pattern;, +		}, +	}, +		if (this.handlerMap.isEmpty()) {, +			if(logger.isDebugEnabled()) {, +		List<SimpleUrlHandlerMapping> mappings = new ArrayList<>(map.values());, +		AnnotationAwareOrderComparator.sort(mappings);, +		mappings.forEach(mapping -> {, +	 * Get the public resource URL for the given URI string., +	 * <p>The URI string is expected to be a path and if it contains a query or, +	 * fragment those will be preserved in the resulting public resource URL., +	 * @param uriString the URI string to transform, +	 * @return the resolved public resource URL path, or empty if unresolved, +	public final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {, +			logger.trace("Getting resource URL for request URL \"" + uriString + "\"");, +		int queryIndex = getQueryIndex(uriString);, +		String lookupPath = uriString.substring(0, queryIndex);, +		String query = uriString.substring(queryIndex);, +		if (logger.isTraceEnabled()) {]