[+++ /dev/null, +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSession.java, + * Copyright 2002-2017 the original author or authors., +import java.util.function.Function;, +import org.springframework.web.server.WebSession;, +class DefaultWebSession implements WebSession {, +	private final Function<WebSession, Mono<Void>> saveOperation;, +, +	private final Instant lastAccessTime;, +	private final AtomicReference<State> state;, +	 * Constructor for creating a brand, new session., +	DefaultWebSession(String id, Clock clock, Function<WebSession, Mono<Void>> saveOperation) {, +		this.saveOperation = saveOperation;, +		this.state = new AtomicReference<>(State.NEW);, +	 * Constructor to refresh an existing session for a new request., +	 * @param existingSession the session to recreate, +	 * @param saveOperation save operation for the current request, +	DefaultWebSession(DefaultWebSession existingSession, Instant lastAccessTime,, +			Function<WebSession, Mono<Void>> saveOperation) {, +		this.id = existingSession.id;, +		this.attributes = existingSession.attributes;, +		this.clock = existingSession.clock;, +		this.creationTime = existingSession.creationTime;, +		this.maxIdleTime = existingSession.maxIdleTime;, +		this.saveOperation = saveOperation;, +		this.state = existingSession.state;, +	}, +, +	/**, +	 * For testing purposes., +	 */, +	DefaultWebSession(DefaultWebSession existingSession, Instant lastAccessTime) {, +		this.id = existingSession.id;, +		this.attributes = existingSession.attributes;, +		this.clock = existingSession.clock;, +		this.creationTime = existingSession.creationTime;, +		this.lastAccessTime = lastAccessTime;, +		this.maxIdleTime = existingSession.maxIdleTime;, +		this.saveOperation = existingSession.saveOperation;, +		this.state = existingSession.state;, +		return this.saveOperation.apply(this);, +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSession.java, + * Copyright 2002-2017 the original author or authors., +import java.util.function.Function;, +import org.springframework.web.server.WebSession;, +class DefaultWebSession implements WebSession {, +	private final Function<WebSession, Mono<Void>> saveOperation;, +, +	private final Instant lastAccessTime;, +	private final AtomicReference<State> state;, +	 * Constructor for creating a brand, new session., +	DefaultWebSession(String id, Clock clock, Function<WebSession, Mono<Void>> saveOperation) {, +		this.saveOperation = saveOperation;, +		this.state = new AtomicReference<>(State.NEW);, +	 * Constructor to refresh an existing session for a new request., +	 * @param existingSession the session to recreate, +	 * @param saveOperation save operation for the current request, +	DefaultWebSession(DefaultWebSession existingSession, Instant lastAccessTime,, +			Function<WebSession, Mono<Void>> saveOperation) {, +		this.id = existingSession.id;, +		this.attributes = existingSession.attributes;, +		this.clock = existingSession.clock;, +		this.creationTime = existingSession.creationTime;, +		this.maxIdleTime = existingSession.maxIdleTime;, +		this.saveOperation = saveOperation;, +		this.state = existingSession.state;, +	}, +, +	/**, +	 * For testing purposes., +	 */, +	DefaultWebSession(DefaultWebSession existingSession, Instant lastAccessTime) {, +		this.id = existingSession.id;, +		this.attributes = existingSession.attributes;, +		this.clock = existingSession.clock;, +		this.creationTime = existingSession.creationTime;, +		this.lastAccessTime = lastAccessTime;, +		this.maxIdleTime = existingSession.maxIdleTime;, +		this.saveOperation = existingSession.saveOperation;, +		this.state = existingSession.state;, +		return this.saveOperation.apply(this);, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSessionManager.java, +						.map(session -> {, +							Instant lastAccessTime = Instant.now(getClock());, +							return new DefaultWebSession(session, lastAccessTime, s -> saveSession(exchange, s));, +						}), +						.switchIfEmpty(createSession(exchange)), +						.doOnNext(session -> exchange.getResponse().beforeCommit(session::save)));, +	private Mono<DefaultWebSession> retrieveSession(ServerWebExchange exchange) {, +				.cast(DefaultWebSession.class), +	private Mono<DefaultWebSession> removeSessionIfExpired(ServerWebExchange exchange, DefaultWebSession session) {, +			this.sessionIdResolver.expireSession(exchange);, +	private Mono<DefaultWebSession> createSession(ServerWebExchange exchange) {, +		return Mono.fromSupplier(() -> {, +			String id = UUID.randomUUID().toString();, +			return new DefaultWebSession(id, getClock(), sess -> saveSession(exchange, sess));, +		});, +	}]