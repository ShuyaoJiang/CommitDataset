[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +import java.util.LinkedList;, +import java.util.regex.Pattern;, +import org.springframework.util.StringUtils;, +	private static final Pattern VALID_QUALIFIED_ID_PATTERN = Pattern.compile("[\\p{L}\\p{N}_$]+");, +, +		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>();, +		Token node = peekToken();, +		while (isValidQualifiedId(node)) {, +			nextToken();, +			if(node.kind != TokenKind.DOT) {, +			node = peekToken();, +		}, +		if(qualifiedIdPieces.isEmpty()) {, +			if(node == null) {, +				raiseInternalException( expressionString.length(), SpelMessage.OOD);, +			}, +			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,, +					"qualified ID", node.getKind().toString().toLowerCase());, +		}, +		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition());, +		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]));, +	}, +, +	private boolean isValidQualifiedId(Token node) {, +		if(node == null || node.kind == TokenKind.LITERAL_STRING) {, +			return false;, +		}, +		if(node.kind == TokenKind.DOT || node.kind == TokenKind.IDENTIFIER) {, +			return true;, +		}, +		String value = node.stringValue();, +		return StringUtils.hasLength(value) && VALID_QUALIFIED_ID_PATTERN.matcher(value).matches();, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +import java.util.LinkedList;, +import java.util.regex.Pattern;, +import org.springframework.util.StringUtils;, +	private static final Pattern VALID_QUALIFIED_ID_PATTERN = Pattern.compile("[\\p{L}\\p{N}_$]+");, +, +		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>();, +		Token node = peekToken();, +		while (isValidQualifiedId(node)) {, +			nextToken();, +			if(node.kind != TokenKind.DOT) {, +			node = peekToken();, +		}, +		if(qualifiedIdPieces.isEmpty()) {, +			if(node == null) {, +				raiseInternalException( expressionString.length(), SpelMessage.OOD);, +			}, +			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,, +					"qualified ID", node.getKind().toString().toLowerCase());, +		}, +		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition());, +		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]));, +	}, +, +	private boolean isValidQualifiedId(Token node) {, +		if(node == null || node.kind == TokenKind.LITERAL_STRING) {, +			return false;, +		}, +		if(node.kind == TokenKind.DOT || node.kind == TokenKind.IDENTIFIER) {, +			return true;, +		}, +		String value = node.stringValue();, +		return StringUtils.hasLength(value) && VALID_QUALIFIED_ID_PATTERN.matcher(value).matches();, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/ParserErrorMessagesTests.java, + * Copyright 2002-2012 the original author or authors., +				"qualified ID","literal_string");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +import java.util.LinkedList;, +import java.util.regex.Pattern;, +import org.springframework.util.StringUtils;, +	private static final Pattern VALID_QUALIFIED_ID_PATTERN = Pattern.compile("[\\p{L}\\p{N}_$]+");, +, +		LinkedList<SpelNodeImpl> qualifiedIdPieces = new LinkedList<SpelNodeImpl>();, +		Token node = peekToken();, +		while (isValidQualifiedId(node)) {, +			nextToken();, +			if(node.kind != TokenKind.DOT) {, +			node = peekToken();, +		}, +		if(qualifiedIdPieces.isEmpty()) {, +			if(node == null) {, +				raiseInternalException( expressionString.length(), SpelMessage.OOD);, +			}, +			raiseInternalException(node.startpos, SpelMessage.NOT_EXPECTED_TOKEN,, +					"qualified ID", node.getKind().toString().toLowerCase());, +		}, +		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(), qualifiedIdPieces.getLast().getEndPosition());, +		return new QualifiedIdentifier(pos, qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]));, +	}, +, +	private boolean isValidQualifiedId(Token node) {, +		if(node == null || node.kind == TokenKind.LITERAL_STRING) {, +			return false;, +		}, +		if(node.kind == TokenKind.DOT || node.kind == TokenKind.IDENTIFIER) {, +			return true;, +		}]