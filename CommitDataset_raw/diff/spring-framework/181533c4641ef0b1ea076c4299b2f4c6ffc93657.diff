[+++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.HashSet;, + * @author Juergen Hoeller, +	/**, +	 * Copy constructor which allows for ignoring certain entries., +	 * Used for serialization without non-serializable entries., +	 * @param original the MessageHeaders to copy, +	 * @param keysToIgnore the keys of the entries to ignore, +	 */, +	private MessageHeaders(MessageHeaders original, Set<String> keysToIgnore) {, +		this.headers = new HashMap<String, Object>(original.headers.size() - keysToIgnore.size());, +		for (Map.Entry<String, Object> entry : original.headers.entrySet()) {, +			if (!keysToIgnore.contains(entry.getKey())) {, +				this.headers.put(entry.getKey(), entry.getValue());, +			}, +		}, +	}, +, +, +		Set<String> keysToIgnore = new HashSet<String>();, +				keysToIgnore.add(entry.getKey());, +, +		if (keysToIgnore.isEmpty()) {, +			// All entries are serializable -> serialize the regular MessageHeaders instance, +		else {, +			// Some non-serializable entries -> serialize a temporary MessageHeaders copy, +			if (logger.isDebugEnabled()) {, +				logger.debug("Ignoring non-serializable message headers: " + keysToIgnore);, +			}, +			out.writeObject(new MessageHeaders(this, keysToIgnore));, +		}, +	}, +, +	// equals, hashCode, toString, +, +	@Override, +	public boolean equals(Object other) {, +		return (this == other ||, +				(other instanceof MessageHeaders && this.headers.equals(((MessageHeaders) other).headers)));, +	}, +, +	@Override, +	public int hashCode() {, +		return this.headers.hashCode();, +	}, +, +	@Override, +	public String toString() {, +		return this.headers.toString();, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.HashSet;, + * @author Juergen Hoeller, +	/**, +	 * Copy constructor which allows for ignoring certain entries., +	 * Used for serialization without non-serializable entries., +	 * @param original the MessageHeaders to copy, +	 * @param keysToIgnore the keys of the entries to ignore, +	 */, +	private MessageHeaders(MessageHeaders original, Set<String> keysToIgnore) {, +		this.headers = new HashMap<String, Object>(original.headers.size() - keysToIgnore.size());, +		for (Map.Entry<String, Object> entry : original.headers.entrySet()) {, +			if (!keysToIgnore.contains(entry.getKey())) {, +				this.headers.put(entry.getKey(), entry.getValue());, +			}, +		}, +	}, +, +, +		Set<String> keysToIgnore = new HashSet<String>();, +				keysToIgnore.add(entry.getKey());, +, +		if (keysToIgnore.isEmpty()) {, +			// All entries are serializable -> serialize the regular MessageHeaders instance, +		else {, +			// Some non-serializable entries -> serialize a temporary MessageHeaders copy, +			if (logger.isDebugEnabled()) {, +				logger.debug("Ignoring non-serializable message headers: " + keysToIgnore);, +			}, +			out.writeObject(new MessageHeaders(this, keysToIgnore));, +		}, +	}, +, +	// equals, hashCode, toString, +, +	@Override, +	public boolean equals(Object other) {, +		return (this == other ||, +				(other instanceof MessageHeaders && this.headers.equals(((MessageHeaders) other).headers)));, +	}, +, +	@Override, +	public int hashCode() {, +		return this.headers.hashCode();, +	}, +, +	@Override, +	public String toString() {, +		return this.headers.toString();]