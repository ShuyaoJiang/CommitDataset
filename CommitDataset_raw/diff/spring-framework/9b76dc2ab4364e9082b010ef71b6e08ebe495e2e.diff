[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompEncoder.java, +import java.util.LinkedHashMap;, +	private static final int HEADER_KEY_CACHE_LIMIT = 32;, +, +	@SuppressWarnings("serial"), +	private final Map<String, byte[]> headerKeyCache =, +			new LinkedHashMap<String, byte[]>(HEADER_KEY_CACHE_LIMIT, 0.75f, true) {, +				@Override, +				protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {, +					return size() > HEADER_KEY_CACHE_LIMIT;, +				}, +			};, +			byte[] encodedKey = encodeHeaderKey(entry.getKey(), shouldEscape);, +				output.write(encodeHeaderValue(value, shouldEscape));, +	private byte[] encodeHeaderKey(String input, boolean escape) {, +		if (headerKeyCache.containsKey(inputToUse)) {, +			return headerKeyCache.get(inputToUse);, +		}, +		byte[] bytes = encodeHeaderString(inputToUse);, +		headerKeyCache.put(inputToUse, bytes);, +		return bytes;, +	}, +, +	private byte[] encodeHeaderValue(String input, boolean escape) {, +		String inputToUse = (escape ? escape(input) : input);, +		return encodeHeaderString(inputToUse);, +	}, +, +	private byte[] encodeHeaderString(String input) {, +		return input.getBytes(StandardCharsets.UTF_8);, +		StringBuilder sb = null;, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +			else if (sb != null){, +		return (sb != null ? sb.toString() : inString);, +	}, +, +	private StringBuilder getStringBuilder(StringBuilder sb, String inString, int i) {, +		if (sb == null) {, +			sb = new StringBuilder(inString.length());, +			sb.append(inString.substring(0, i));, +		}, +		return sb;, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompEncoder.java, +import java.util.LinkedHashMap;, +	private static final int HEADER_KEY_CACHE_LIMIT = 32;, +, +	@SuppressWarnings("serial"), +	private final Map<String, byte[]> headerKeyCache =, +			new LinkedHashMap<String, byte[]>(HEADER_KEY_CACHE_LIMIT, 0.75f, true) {, +				@Override, +				protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {, +					return size() > HEADER_KEY_CACHE_LIMIT;, +				}, +			};, +			byte[] encodedKey = encodeHeaderKey(entry.getKey(), shouldEscape);, +				output.write(encodeHeaderValue(value, shouldEscape));, +	private byte[] encodeHeaderKey(String input, boolean escape) {, +		if (headerKeyCache.containsKey(inputToUse)) {, +			return headerKeyCache.get(inputToUse);, +		}, +		byte[] bytes = encodeHeaderString(inputToUse);, +		headerKeyCache.put(inputToUse, bytes);, +		return bytes;, +	}, +, +	private byte[] encodeHeaderValue(String input, boolean escape) {, +		String inputToUse = (escape ? escape(input) : input);, +		return encodeHeaderString(inputToUse);, +	}, +, +	private byte[] encodeHeaderString(String input) {, +		return input.getBytes(StandardCharsets.UTF_8);, +		StringBuilder sb = null;, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +				sb = getStringBuilder(sb, inString, i);, +			else if (sb != null){, +		return (sb != null ? sb.toString() : inString);, +	}, +, +	private StringBuilder getStringBuilder(StringBuilder sb, String inString, int i) {, +		if (sb == null) {, +			sb = new StringBuilder(inString.length());, +			sb.append(inString.substring(0, i));, +		}, +		return sb;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/config/annotation/WebMvcStompEndpointRegistry.java, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompEncoder.java, +import java.util.LinkedHashMap;, +	private static final int HEADER_KEY_CACHE_LIMIT = 32;, +, +	@SuppressWarnings("serial"), +	private final Map<String, byte[]> headerKeyCache =, +			new LinkedHashMap<String, byte[]>(HEADER_KEY_CACHE_LIMIT, 0.75f, true) {, +				@Override, +				protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {]