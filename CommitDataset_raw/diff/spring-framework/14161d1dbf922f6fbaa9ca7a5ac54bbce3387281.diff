[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/view/UrlBasedViewResolver.java, +import org.springframework.context.ApplicationContextAware;, + * @author Juergen Hoeller, +public class UrlBasedViewResolver extends ViewResolverSupport, +		implements ViewResolver, ApplicationContextAware, InitializingBean {, +	private ApplicationContext applicationContext;, +, +	 * Set the view class to instantiate through {@link #createView(String)}., +	 * which by default is AbstractUrlBasedView, +	 * Set the name of the {@link RequestContext} attribute for all views., +	 * Return the name of the @link RequestContext} attribute for all views, if any., +	/**, +	 * Accept the containing {@code ApplicationContext}, if any., +	 * <p>To be used for the initialization of newly created {@link View} instances,, +	 * applying lifecycle callbacks and providing access to the containing environment., +	 * @see #setViewClass, +	 * @see #createView, +	 * @see #applyLifecycleMethods, +	 */, +	@Override, +	public void setApplicationContext(ApplicationContext applicationContext) {, +		this.applicationContext = applicationContext;, +	}, +, +	/**, +	 * Return the containing {@code ApplicationContext}, if any., +	 * @see #setApplicationContext, +	 */, +	@Nullable, +	public ApplicationContext getApplicationContext() {, +		return this.applicationContext;, +	}, +, +			urlBasedView = createView(viewName);, +	 * Indicates whether or not this {@link ViewResolver} can handle the supplied, +	 * view name. If not, an empty result is returned. The default implementation, +	 * checks against the configured {@link #setViewNames view names}., +	 * be called here: They will be automatically applied afterwards, provided, +	 * that an {@link #setApplicationContext ApplicationContext} is available., +	 * @see #getViewClass(), +	 * @see #applyLifecycleMethods, +	protected AbstractUrlBasedView createView(String viewName) {, +	/**, +	 * Apply the containing {@link ApplicationContext}'s lifecycle methods, +	 * to the given {@link View} instance, if such a context is available., +	 * @param viewName the name of the view, +	 * @param view the freshly created View instance, pre-configured with, +	 * {@link AbstractUrlBasedView}'s properties, +	 * @return the {@link View} instance to use (either the original one, +	 * or a decorated variant), +	 * @see #getApplicationContext(), +	 * @see ApplicationContext#getAutowireCapableBeanFactory(), +	 * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean, +	 */, +	protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/view/UrlBasedViewResolver.java, +import org.springframework.context.ApplicationContextAware;, + * @author Juergen Hoeller, +public class UrlBasedViewResolver extends ViewResolverSupport, +		implements ViewResolver, ApplicationContextAware, InitializingBean {, +	private ApplicationContext applicationContext;, +, +	 * Set the view class to instantiate through {@link #createView(String)}., +	 * which by default is AbstractUrlBasedView, +	 * Set the name of the {@link RequestContext} attribute for all views., +	 * Return the name of the @link RequestContext} attribute for all views, if any., +	/**, +	 * Accept the containing {@code ApplicationContext}, if any., +	 * <p>To be used for the initialization of newly created {@link View} instances,, +	 * applying lifecycle callbacks and providing access to the containing environment., +	 * @see #setViewClass, +	 * @see #createView, +	 * @see #applyLifecycleMethods, +	 */, +	@Override, +	public void setApplicationContext(ApplicationContext applicationContext) {, +		this.applicationContext = applicationContext;, +	}, +, +	/**, +	 * Return the containing {@code ApplicationContext}, if any., +	 * @see #setApplicationContext, +	 */, +	@Nullable, +	public ApplicationContext getApplicationContext() {, +		return this.applicationContext;, +	}, +, +			urlBasedView = createView(viewName);, +	 * Indicates whether or not this {@link ViewResolver} can handle the supplied, +	 * view name. If not, an empty result is returned. The default implementation, +	 * checks against the configured {@link #setViewNames view names}., +	 * be called here: They will be automatically applied afterwards, provided, +	 * that an {@link #setApplicationContext ApplicationContext} is available., +	 * @see #getViewClass(), +	 * @see #applyLifecycleMethods, +	protected AbstractUrlBasedView createView(String viewName) {, +	/**, +	 * Apply the containing {@link ApplicationContext}'s lifecycle methods, +	 * to the given {@link View} instance, if such a context is available.]