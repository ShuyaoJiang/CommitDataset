[+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +import java.util.Collections;, + * @author Phillip Webb, +	 * @deprecated as of Spring 4.0 use {@link MethodParameter#getGenericParameterType()}, +	@Deprecated, +		return methodParam.getGenericParameterType();, +		Assert.notNull(methodParam, "MethodParameter must not be null");, +		methodParam.resolveClass = clazz;, +		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam, clazz).resolve());, +		return methodParam.getParameterType();, +		return ResolvableType.forMethodReturn(method, clazz).resolve(method.getReturnType());, +		ResolvableType resolvableType = ResolvableType.forMethodReturn(method).as(genericIfc);, +		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {, +		return getSingleGeneric(resolvableType);, +		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc);, +		if (!resolvableType.hasGenerics()) {, +		return getSingleGeneric(resolvableType);, +	}, +, +	private static Class<?> getSingleGeneric(ResolvableType resolvableType) {, +		if (resolvableType.getGenerics().length > 1) {, +					resolvableType + "] but found " + resolvableType.getGenerics().length);, +		return resolvableType.getGeneric().resolve();, +, +		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc);, +		if(!type.hasGenerics()) {, +		return type.resolveGenerics();, +	 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}, +	@Deprecated, +		TypeVariableResolver variableResolver = new TypeVariableMapResolver(typeVariableMap);, +		Class<?> resolved = ResolvableType.forType(genericType, variableResolver).resolve();, +		return (resolved == null ? Object.class : resolved);, +, +	/**, +	 * Build a mapping of {@link TypeVariable#getName TypeVariable names} to, +	 * {@link Class concrete classes} for the specified {@link Class}. Searches, +	 * all super types, enclosing types and interfaces., +	 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}, +	 */, +	@Deprecated, +	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {, +		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz);, +		if (typeVariableMap == null) {, +			typeVariableMap = new HashMap<TypeVariable, Type>();, +			buildTypeVaraibleMap(ResolvableType.forClass(clazz), typeVariableMap);, +			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap));, +		}, +		return typeVariableMap;, +	}, +, +	private static void buildTypeVaraibleMap(ResolvableType type,, +			Map<TypeVariable, Type> typeVariableMap) {, +		if(type != ResolvableType.NONE) {, +			if(type.getType() instanceof ParameterizedType) {, +				TypeVariable<?>[] variables = type.resolve().getTypeParameters();, +				for (int i = 0; i < variables.length; i++) {, +					ResolvableType generic = type.getGeneric(i);, +					while (generic.getType() instanceof TypeVariable<?>) {, +						generic = generic.resolveType();, +					}, +					if (generic != ResolvableType.NONE) {, +						typeVariableMap.put(variables[i], generic.getType());, +					}, +				}, +			}, +			buildTypeVaraibleMap(type.getSuperType(), typeVariableMap);, +			for (ResolvableType interfaceType : type.getInterfaces()) {, +				buildTypeVaraibleMap(interfaceType, typeVariableMap);, +			}, +			if (type.resolve().isMemberClass()) {, +				buildTypeVaraibleMap(ResolvableType.forClass(type.resolve().getEnclosingClass()),, +						typeVariableMap);, +			}, +		}, +	@Deprecated, +	@Deprecated, +	 * Adapts a {@code typeVariableMap} to a {@link TypeVariableResolver}., +	private static class TypeVariableMapResolver implements TypeVariableResolver {, +, +		private Map<TypeVariable, Type> typeVariableMap;, +, +, +		public TypeVariableMapResolver(Map<TypeVariable, Type> typeVariableMap) {, +			Assert.notNull("TypeVariableMap must not be null");, +			this.typeVariableMap = typeVariableMap;, +, +, +		@Override, +		public Type resolveVariable(TypeVariable typeVariable) {, +			return typeVariableMap.get(typeVariable);, +, +		@Override, +		public int hashCode() {, +			return typeVariableMap.hashCode();, +, +		@Override, +		public boolean equals(Object obj) {, +			if(obj == this) {, +				return true;, +			if(obj instanceof TypeVariableMapResolver) {]