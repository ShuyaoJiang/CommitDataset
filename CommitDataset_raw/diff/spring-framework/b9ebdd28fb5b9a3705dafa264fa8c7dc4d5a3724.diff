[+++ b/org.springframework.context/src/main/java/org/springframework/format/FormatterRegistry.java, +	 * @since 3.1, +++ b/org.springframework.context/src/main/java/org/springframework/format/FormatterRegistry.java, +	 * @since 3.1, +++ b/org.springframework.context/src/main/java/org/springframework/format/support/FormattingConversionService.java, +		Class<?> fieldType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +			throw new IllegalArgumentException("Unable to extract parameterized field type argument from Formatter [" +, +					formatter.getClass().getName() + "]; does the formatter parameterize the <T> generic type?");, +	public void addFormatterForFieldAnnotation(AnnotationFormatterFactory annotationFormatterFactory) {, +, +, +, +	private class AnnotationPrinterConverter implements ConditionalGenericConverter {, +, +	private class AnnotationParserConverter implements ConditionalGenericConverter {, +, +	private static class AnnotationConverterKey {, +++ b/org.springframework.context/src/main/java/org/springframework/format/FormatterRegistry.java, +	 * @since 3.1, +++ b/org.springframework.context/src/main/java/org/springframework/format/support/FormattingConversionService.java, +		Class<?> fieldType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +			throw new IllegalArgumentException("Unable to extract parameterized field type argument from Formatter [" +, +					formatter.getClass().getName() + "]; does the formatter parameterize the <T> generic type?");, +	public void addFormatterForFieldAnnotation(AnnotationFormatterFactory annotationFormatterFactory) {, +, +, +, +	private class AnnotationPrinterConverter implements ConditionalGenericConverter {, +, +	private class AnnotationParserConverter implements ConditionalGenericConverter {, +, +	private static class AnnotationConverterKey {, +++ b/org.springframework.context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java, +	private boolean registerDefaultFormatters = true;, +	private FormattingConversionService conversionService;, +, +	 * {@link org.springframework.core.convert.converter.GenericConverter}, +	 * @param formatters instances of {@link Formatter} or {@link AnnotationFormatterFactory}, +	 * Indicate whether default formatters should be registered or not., +	 * <p>By default, built-in formatters are registered. This flag can be used, +	 * to  turn that off and rely on explicitly registered formatters only., +	public void setEmbeddedValueResolver(StringValueResolver embeddedValueResolver) {, +		this.embeddedValueResolver = embeddedValueResolver;, +	}, +	private void registerFormatters() {, +		if (this.formatters != null) {, +			for (Object formatter : this.formatters) {, +				if (formatter instanceof Formatter<?>) {, +					this.conversionService.addFormatter((Formatter<?>) formatter);, +				else if (formatter instanceof AnnotationFormatterFactory<?>) {, +					this.conversionService.addFormatterForFieldAnnotation((AnnotationFormatterFactory<?>) formatter);, +				else {, +					throw new IllegalArgumentException(, +							"Custom formatters must be implementations of Formatter or AnnotationFormatterFactory");, +			}, +		}, +		if (this.formatterRegistrars != null) {, +			for (FormatterRegistrar registrar : this.formatterRegistrars) {, +				registrar.registerFormatters(this.conversionService);, +			}, +		}, +		installFormatters(this.conversionService);, +	}, +	public FormattingConversionService getObject() {, +		return this.conversionService;, +, +	public Class<? extends FormattingConversionService> getObjectType() {, +		return FormattingConversionService.class;, +, +	public boolean isSingleton() {, +		return true;, +++ b/org.springframework.context/src/main/java/org/springframework/format/FormatterRegistry.java, +	 * @since 3.1, +++ b/org.springframework.context/src/main/java/org/springframework/format/support/FormattingConversionService.java, +		Class<?> fieldType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +			throw new IllegalArgumentException("Unable to extract parameterized field type argument from Formatter [" +, +					formatter.getClass().getName() + "]; does the formatter parameterize the <T> generic type?");, +	public void addFormatterForFieldAnnotation(AnnotationFormatterFactory annotationFormatterFactory) {, +, +, +, +	private class AnnotationPrinterConverter implements ConditionalGenericConverter {, +, +	private class AnnotationParserConverter implements ConditionalGenericConverter {, +, +	private static class AnnotationConverterKey {, +++ b/org.springframework.context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java, +	private boolean registerDefaultFormatters = true;, +	private FormattingConversionService conversionService;, +, +	 * {@link org.springframework.core.convert.converter.GenericConverter}, +	 * @param formatters instances of {@link Formatter} or {@link AnnotationFormatterFactory}, +	 * Indicate whether default formatters should be registered or not., +	 * <p>By default, built-in formatters are registered. This flag can be used, +	 * to  turn that off and rely on explicitly registered formatters only., +	public void setEmbeddedValueResolver(StringValueResolver embeddedValueResolver) {, +		this.embeddedValueResolver = embeddedValueResolver;, +	}, +	private void registerFormatters() {, +		if (this.formatters != null) {]