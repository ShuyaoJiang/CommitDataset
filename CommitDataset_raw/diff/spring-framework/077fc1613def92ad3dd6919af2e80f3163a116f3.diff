[+++ b/org.springframework.expression/readme.txt, +- MATCHES is now the thing that takes a java regex.  What does 'like' do? right now it is the SQL LIKE that supports, +  wildcards % and _.  It has a poor implementation but I need to know whether to keep it in the language before, +  fixing that., +++ b/org.springframework.expression/readme.txt, +- MATCHES is now the thing that takes a java regex.  What does 'like' do? right now it is the SQL LIKE that supports, +  wildcards % and _.  It has a poor implementation but I need to know whether to keep it in the language before, +  fixing that., +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessages.java, +			"Error occurred during expression parse: {0}"), INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR(Kind.ERROR,, +			1067, "First operand to matches operator must be a string.  ''{0}'' is not"), INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR(, +			Kind.ERROR, 1068, "Second operand to matches operator must be a string. ''{0}'' is not");, +++ b/org.springframework.expression/readme.txt, +- MATCHES is now the thing that takes a java regex.  What does 'like' do? right now it is the SQL LIKE that supports, +  wildcards % and _.  It has a poor implementation but I need to know whether to keep it in the language before, +  fixing that., +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessages.java, +			"Error occurred during expression parse: {0}"), INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR(Kind.ERROR,, +			1067, "First operand to matches operator must be a string.  ''{0}'' is not"), INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR(, +			Kind.ERROR, 1068, "Second operand to matches operator must be a string. ''{0}'' is not");, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/OperatorLike.java, +import org.springframework.expression.spel.ExpressionState;, + * Implements the like operator. The like operator behaves the same as the SQL LIKE operator. The first operand is, + * compared against the expression supplied as the second operand. This expression supports two wildcards: % meaning any, + * string of any length, and _ meaning any single character., +	public Boolean getValue(ExpressionState state) throws EvaluationException {, +		Object left = leftOp.getValue(state, String.class);, +			// Translate that pattern to a java regex, +			// not really the best option, what if the right operand already had regex related chars in it?, +			String likePattern = (String) right;, +			likePattern = likePattern.replace('_', '.');, +			likePattern = likePattern.replaceAll("%", ".*");, +			Pattern pattern = Pattern.compile(likePattern);, +++ b/org.springframework.expression/readme.txt, +- MATCHES is now the thing that takes a java regex.  What does 'like' do? right now it is the SQL LIKE that supports, +  wildcards % and _.  It has a poor implementation but I need to know whether to keep it in the language before, +  fixing that., +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessages.java, +			"Error occurred during expression parse: {0}"), INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR(Kind.ERROR,, +			1067, "First operand to matches operator must be a string.  ''{0}'' is not"), INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR(, +			Kind.ERROR, 1068, "Second operand to matches operator must be a string. ''{0}'' is not");, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/OperatorLike.java, +import org.springframework.expression.spel.ExpressionState;, + * Implements the like operator. The like operator behaves the same as the SQL LIKE operator. The first operand is, + * compared against the expression supplied as the second operand. This expression supports two wildcards: % meaning any, + * string of any length, and _ meaning any single character., +	public Boolean getValue(ExpressionState state) throws EvaluationException {, +		Object left = leftOp.getValue(state, String.class);, +			// Translate that pattern to a java regex, +			// not really the best option, what if the right operand already had regex related chars in it?, +			String likePattern = (String) right;, +			likePattern = likePattern.replace('_', '.');, +			likePattern = likePattern.replaceAll("%", ".*");, +			Pattern pattern = Pattern.compile(likePattern);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/OperatorMatches.java, +						SpelMessages.INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR, left);, +						SpelMessages.INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR, right);, +++ b/org.springframework.expression/readme.txt, +- MATCHES is now the thing that takes a java regex.  What does 'like' do? right now it is the SQL LIKE that supports, +  wildcards % and _.  It has a poor implementation but I need to know whether to keep it in the language before, +  fixing that., +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelMessages.java, +			"Error occurred during expression parse: {0}"), INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR(Kind.ERROR,, +			1067, "First operand to matches operator must be a string.  ''{0}'' is not"), INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR(, +			Kind.ERROR, 1068, "Second operand to matches operator must be a string. ''{0}'' is not");, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/OperatorLike.java, +import org.springframework.expression.spel.ExpressionState;, + * Implements the like operator. The like operator behaves the same as the SQL LIKE operator. The first operand is, + * compared against the expression supplied as the second operand. This expression supports two wildcards: % meaning any, + * string of any length, and _ meaning any single character., +	public Boolean getValue(ExpressionState state) throws EvaluationException {, +		Object left = leftOp.getValue(state, String.class);, +			// Translate that pattern to a java regex, +			// not really the best option, what if the right operand already had regex related chars in it?, +			String likePattern = (String) right;, +			likePattern = likePattern.replace('_', '.');, +			likePattern = likePattern.replaceAll("%", ".*");, +			Pattern pattern = Pattern.compile(likePattern);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/OperatorMatches.java, +						SpelMessages.INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR, left);, +						SpelMessages.INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR, right);, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java, +		evaluate("'Abc' like 'A%_'", "true", Boolean.class);, +	}, +	}, +		evaluateAndCheckError("null like '.'", SpelMessages.INVALID_FIRST_OPERAND_FOR_LIKE_OPERATOR);, +	public void testRelOperatorsLike05() {, +		evaluate("27 like '__'", "true", Boolean.class); // conversion int>string, +	}, +, +		evaluateAndCheckError("null matches '^.*$'", SpelMessages.INVALID_FIRST_OPERAND_FOR_MATCHES_OPERATOR, 0, null);, +		evaluateAndCheckError("'abc' matches null", SpelMessages.INVALID_SECOND_OPERAND_FOR_MATCHES_OPERATOR, 14, null);]