[+++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/Bean.java, + * @since 3.0, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/Bean.java, + * @since 3.0, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/BeanMethod.java, +			throw new IllegalStateException(, +				format("annotation %s not found on %s", annoType.getSimpleName(), this));, +		if (method.getAnnotation(ScopedProxy.class) == null), +			return;, +, +		Bean bean = method.getRequiredAnnotation(Bean.class);, +, +		if (bean.scope().equals(StandardScopes.SINGLETON), +				|| bean.scope().equals(StandardScopes.PROTOTYPE)), +			errors.add(new InvalidScopedProxyDeclarationError(method));, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/Bean.java, + * @since 3.0, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/BeanMethod.java, +			throw new IllegalStateException(, +				format("annotation %s not found on %s", annoType.getSimpleName(), this));, +		if (method.getAnnotation(ScopedProxy.class) == null), +			return;, +, +		Bean bean = method.getRequiredAnnotation(Bean.class);, +, +		if (bean.scope().equals(StandardScopes.SINGLETON), +				|| bean.scope().equals(StandardScopes.PROTOTYPE)), +			errors.add(new InvalidScopedProxyDeclarationError(method));, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/BeanRegistrar.java, +import org.springframework.aop.framework.autoproxy.AutoProxyUtils;, +import org.springframework.aop.scope.ScopedProxyFactoryBean;, +				logger.info(format("Skipping loading bean definition for %s: a definition for bean ", +					+ "'%s' already exists. This is likely due to an override in XML.", method, beanName));, +		ScopedProxy scopedProxy = method.getAnnotation(ScopedProxy.class);, +		if (scopedProxy != null) {, +			RootBeanDefinition targetDef = beanDef;, +			// Create a scoped proxy definition for the original bean name,, +			// "hiding" the target bean in an internal target definition., +			String targetBeanName = ScopedProxy.Util.resolveHiddenScopedProxyBeanName(beanName);, +			RootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);, +			scopedProxyDefinition.getPropertyValues().addPropertyValue("targetBeanName", targetBeanName);, +, +			if (scopedProxy.proxyTargetClass()), +				targetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);, +			// ScopedFactoryBean's "proxyTargetClass" default is TRUE, so we, +			// don't need to set it explicitly here., +			else, +				scopedProxyDefinition.getPropertyValues().addPropertyValue("proxyTargetClass", Boolean.FALSE);, +, +			// The target bean should be ignored in favor of the scoped proxy., +			targetDef.setAutowireCandidate(false);, +, +			// Register the target bean as separate bean in the factory, +			registry.registerBeanDefinition(targetBeanName, targetDef);, +, +			// replace the original bean definition with the target one, +			beanDef = scopedProxyDefinition;, +		}, +		logger.info(format("Registering bean definition for @Bean method %s.%s()",, +			configClass.getName(), beanName));, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/Bean.java, + * @since 3.0, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/BeanMethod.java, +			throw new IllegalStateException(, +				format("annotation %s not found on %s", annoType.getSimpleName(), this));, +		if (method.getAnnotation(ScopedProxy.class) == null), +			return;, +, +		Bean bean = method.getRequiredAnnotation(Bean.class);, +, +		if (bean.scope().equals(StandardScopes.SINGLETON), +				|| bean.scope().equals(StandardScopes.PROTOTYPE)), +			errors.add(new InvalidScopedProxyDeclarationError(method));, +++ b/org.springframework.config.java/src/main/java/org/springframework/config/java/BeanRegistrar.java, +import org.springframework.aop.framework.autoproxy.AutoProxyUtils;, +import org.springframework.aop.scope.ScopedProxyFactoryBean;, +				logger.info(format("Skipping loading bean definition for %s: a definition for bean ", +					+ "'%s' already exists. This is likely due to an override in XML.", method, beanName));, +		ScopedProxy scopedProxy = method.getAnnotation(ScopedProxy.class);, +		if (scopedProxy != null) {, +			RootBeanDefinition targetDef = beanDef;, +			// Create a scoped proxy definition for the original bean name,, +			// "hiding" the target bean in an internal target definition., +			String targetBeanName = ScopedProxy.Util.resolveHiddenScopedProxyBeanName(beanName);, +			RootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);, +			scopedProxyDefinition.getPropertyValues().addPropertyValue("targetBeanName", targetBeanName);, +, +			if (scopedProxy.proxyTargetClass()), +				targetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);, +			// ScopedFactoryBean's "proxyTargetClass" default is TRUE, so we, +			// don't need to set it explicitly here., +			else, +				scopedProxyDefinition.getPropertyValues().addPropertyValue("proxyTargetClass", Boolean.FALSE);, +, +			// The target bean should be ignored in favor of the scoped proxy., +			targetDef.setAutowireCandidate(false);, +, +			// Register the target bean as separate bean in the factory, +			registry.registerBeanDefinition(targetBeanName, targetDef);, +]