[+++ b/spring-websocket/src/main/java/org/springframework/sockjs/AbstractSockJsSession.java, +import java.io.IOException;, +	public void delegateConnectionEstablished() {, +		try {, +		catch (Throwable ex) {, +			tryCloseWithError(ex, null);, +		}, +	}, +	/**, +	 * Close due to unhandled runtime error from WebSocketHandler., +	 * @param closeStatus TODO, +	 */, +	private void tryCloseWithError(Throwable ex, CloseStatus closeStatus) {, +		logger.error("Unhandled error for " + this, ex);, +		try {, +			closeStatus = (closeStatus != null) ? closeStatus : CloseStatus.SERVER_ERROR;, +			close(closeStatus);, +		}, +		catch (Throwable t) {, +			destroyHandler();, +		}, +	}, +, +	private void destroyHandler() {, +		try {, +			if (this.handler != null) {, +				this.handlerProvider.destroy(this.handler);, +			}, +		}, +		catch (Throwable t) {, +			logger.warn("Error while destroying handler", t);, +		}, +		finally {, +			this.handler = null;, +		}, +	}, +, +	/**, +	 * Close due to error arising from SockJS transport handling., +	 */, +	protected void tryCloseWithSockJsTransportError(Throwable ex, CloseStatus closeStatus) {, +		delegateError(ex);, +		tryCloseWithError(ex, closeStatus);, +	}, +, +	public void delegateMessages(String[] messages) {, +		try {, +		catch (Throwable ex) {, +			tryCloseWithError(ex, null);, +		}, +	}, +	public void delegateError(Throwable ex) {, +		try {, +			this.handler.handleTransportError(ex, this);, +		}, +		catch (Throwable t) {, +			tryCloseWithError(t, null);, +		}, +	public final void delegateConnectionClosed(CloseStatus status) {, +				try {, +				finally {, +					destroyHandler();, +				}, +			}, +	public final void close() throws IOException {, +	public final void close(CloseStatus status) throws IOException {, +					destroyHandler();, +	protected abstract void closeInternal(CloseStatus status) throws IOException;, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/AbstractSockJsSession.java, +import java.io.IOException;, +	public void delegateConnectionEstablished() {, +		try {, +		catch (Throwable ex) {, +			tryCloseWithError(ex, null);, +		}, +	}, +	/**, +	 * Close due to unhandled runtime error from WebSocketHandler., +	 * @param closeStatus TODO, +	 */, +	private void tryCloseWithError(Throwable ex, CloseStatus closeStatus) {, +		logger.error("Unhandled error for " + this, ex);, +		try {, +			closeStatus = (closeStatus != null) ? closeStatus : CloseStatus.SERVER_ERROR;, +			close(closeStatus);, +		}, +		catch (Throwable t) {, +			destroyHandler();, +		}, +	}, +, +	private void destroyHandler() {, +		try {, +			if (this.handler != null) {, +				this.handlerProvider.destroy(this.handler);, +			}, +		}, +		catch (Throwable t) {, +			logger.warn("Error while destroying handler", t);, +		}]