[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +import java.lang.reflect.Proxy;, +		else if (Proxy.isProxyClass(type)) {, +			Set<Method> result = new LinkedHashSet<>();, +			// Expose interface methods (not proxy-declared overrides) for proper vararg introspection, +			for (Class<?> ifc : type.getInterfaces()) {, +				result.addAll(Arrays.asList(getMethods(ifc)));, +			}, +			return result;, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +import java.lang.reflect.Proxy;, +		else if (Proxy.isProxyClass(type)) {, +			Set<Method> result = new LinkedHashSet<>();, +			// Expose interface methods (not proxy-declared overrides) for proper vararg introspection, +			for (Class<?> ifc : type.getInterfaces()) {, +				result.addAll(Arrays.asList(getMethods(ifc)));, +			}, +			return result;, +		}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java, + * Copyright 2002-2017 the original author or authors., +import java.lang.reflect.Proxy;, +	public void conversionPriority_SPR8224() throws Exception {, +	public void wideningPrimitiveConversion_SPR8224() throws Exception {, +	public void varargsAgainstProxy_SPR16122() {, +		SpelExpressionParser parser = new SpelExpressionParser();, +		Expression expr = parser.parseExpression("process('a', 'b')");, +, +		VarargsReceiver receiver = new VarargsReceiver();, +		VarargsInterface proxy = (VarargsInterface) Proxy.newProxyInstance(, +				getClass().getClassLoader(), new Class<?>[]{VarargsInterface.class},, +				(proxy1, method, args) -> method.invoke(receiver, args));, +, +		assertEquals("OK", expr.getValue(new StandardEvaluationContext(receiver)));, +		assertEquals("OK", expr.getValue(new StandardEvaluationContext(proxy)));, +	}, +, +	@Test, +	public void reservedWords_SPR8228() {, +, +	public void reservedWordProperties_SPR9862() {, +	public void propertyAccessorOrder_SPR8211() {, +					return new Method[] {Integer.class.getDeclaredMethod("parseInt", String.class, Integer.TYPE)};, +		assertTrue(expression1.getValue(new BeanClass(new ListOf(1.1), new ListOf(2.2)), Boolean.class));, +		assertTrue(expression2.getValue(new BeanClass(new ListOf(1.1), new ListOf(-2.2)), Boolean.class));, +	static class MyTypeLocator extends StandardTypeLocator {, +, +		@Override, +		public Class<?> findType(String typeName) throws EvaluationException {, +			if (typeName.equals("Spr5899Class")) {, +				return Spr5899Class.class;, +			}, +			if (typeName.equals("Outer")) {, +				return Outer.class;, +			}, +			return super.findType(typeName);, +		}, +	}, +, +, +	static class Spr5899Class {, +, +		public Spr5899Class() {, +		}, +, +		public Spr5899Class(Integer i) {, +		}, +, +		public Spr5899Class(Integer i, String... s) {, +		}, +, +		public Integer tryToInvokeWithNull(Integer value) {, +			return value;, +		}, +, +		public Integer tryToInvokeWithNull2(int i) {, +			return new Integer(i);, +		}, +, +		public String tryToInvokeWithNull3(Integer value, String... strings) {, +			StringBuilder sb = new StringBuilder();, +			for (String string : strings) {, +				if (string == null) {, +					sb.append("null");, +				}, +				else {, +					sb.append(string);, +				}, +			}, +			return sb.toString();, +		}, +, +		@Override, +		public String toString() {, +			return "instance";, +		}, +	}, +, +]