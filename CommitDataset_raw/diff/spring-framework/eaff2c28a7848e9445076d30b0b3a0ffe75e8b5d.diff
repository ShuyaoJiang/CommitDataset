[+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.lang.reflect.Proxy;, +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +		private final Method targetMethod;, +, +		private final AnnotatedElementKey methodKey;, +, +			this.method = BridgeMethodResolver.findBridgedMethod(method);, +			this.targetMethod = (!Proxy.isProxyClass(targetClass) ?, +					AopUtils.getMostSpecificMethod(method, targetClass) : this.method);, +			this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);, +						this.metadata.methodKey, evaluationContext);, +				return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);, +					this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.lang.reflect.Proxy;, +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +		private final Method targetMethod;, +, +		private final AnnotatedElementKey methodKey;, +, +			this.method = BridgeMethodResolver.findBridgedMethod(method);, +			this.targetMethod = (!Proxy.isProxyClass(targetClass) ?, +					AopUtils.getMostSpecificMethod(method, targetClass) : this.method);, +			this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);, +						this.metadata.methodKey, evaluationContext);, +				return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);, +					this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheExpressionRootObject.java, + * Copyright 2002-2018 the original author or authors., +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.lang.reflect.Proxy;, +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +		private final Method targetMethod;, +, +		private final AnnotatedElementKey methodKey;, +, +			this.method = BridgeMethodResolver.findBridgedMethod(method);, +			this.targetMethod = (!Proxy.isProxyClass(targetClass) ?, +					AopUtils.getMostSpecificMethod(method, targetClass) : this.method);, +			this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);, +						this.metadata.methodKey, evaluationContext);, +				return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);, +					this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheExpressionRootObject.java, + * Copyright 2002-2018 the original author or authors., +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationExpressionEvaluator.java, + * Copyright 2002-2018 the original author or authors., +			Method method, Object[] args, Object target, Class<?> targetClass, Method targetMethod,, +			@Nullable Object result, @Nullable BeanFactory beanFactory) {, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.lang.reflect.Proxy;, +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +		private final Method targetMethod;, +, +		private final AnnotatedElementKey methodKey;, +, +			this.method = BridgeMethodResolver.findBridgedMethod(method);, +			this.targetMethod = (!Proxy.isProxyClass(targetClass) ?, +					AopUtils.getMostSpecificMethod(method, targetClass) : this.method);, +			this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);, +						this.metadata.methodKey, evaluationContext);, +				return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);, +					this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheExpressionRootObject.java, + * Copyright 2002-2018 the original author or authors., +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperationExpressionEvaluator.java, + * Copyright 2002-2018 the original author or authors., +			Method method, Object[] args, Object target, Class<?> targetClass, Method targetMethod,, +			@Nullable Object result, @Nullable BeanFactory beanFactory) {, +++ b/spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java, +import java.lang.reflect.Proxy;, +import org.springframework.aop.support.AopUtils;, +	private final Method targetMethod;, +	private final AnnotatedElementKey methodKey;, +		this.method = BridgeMethodResolver.findBridgedMethod(method);, +		this.targetMethod = (!Proxy.isProxyClass(targetClass) ?, +				AopUtils.getMostSpecificMethod(method, targetClass) : this.method);, +		this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);, +		EventListener ann = AnnotatedElementUtils.findMergedAnnotation(this.targetMethod, EventListener.class);, +, +		if (ann != null) {, +			Class<?>[] classes = ann.classes();, +			if (classes.length > 0) {, +				List<ResolvableType> types = new ArrayList<>(classes.length);, +				for (Class<?> eventType : classes) {, +		}, +, +			Assert.notNull(this.evaluator, "EventExpressionEvaluator must not be null");, +			return this.evaluator.condition(, +					condition, event, this.targetMethod, this.methodKey, args, this.applicationContext);, +		ReflectionUtils.makeAccessible(this.method);]