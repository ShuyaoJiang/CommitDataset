[+++ b/spring-framework-reference/src/beans.xml, +      </footnote>principle. IoC is also known as <emphasis>dependency, +    injection</emphasis> (DI). It is a process whereby objects define their, +    dependencies, that is, the other objects they work with, only through, +    constructor arguments, arguments to a factory method, or properties that, +    are set on the object instance after it is constructed or returned from a, +    factory method. The container then <emphasis>injects</emphasis> those, +    dependencies when it creates the bean. This process is fundamentally the, +    inverse, hence the name <emphasis>Inversion of Control</emphasis> (IoC),, +    of the bean itself controlling the instantiation or location of its, +    dependencies by using direct construction of classes, or a mechanism such, +    as the <emphasis>Service Locator</emphasis> pattern.</para>, +, +    <!--I copied and pasted preceding from "Injecting Dependencies" to give background on IoC, since that's what chapter is about. , +The footnote should x-ref to first section in that chapter but I can't find the file. The current xref doesn't work.-->, +    url="http://static.springframework.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></interfacename>, +    url="http://static.springframework.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink></literal>, +    Beans, and the <firstterm>dependencies</firstterm> among them, are, +    <!-- MLP: Beverly to review -->, +    metadata you can instruct the container to use Java annotations or code as the, +    declaratively enable support for these additional metadata, +      than one bean definition that the container must manage. XML-based, +      AspectJ to dependency-inject domain objects with Spring</link>.</para>, +        locations defined in a URI syntax. In particular, , +        <classname>Resource</classname> paths are used to construct applications, +      <literal>daos.xml</literal>) file:</para>, +          such absolute locations, for example, through "${...}" placeholders, +          that are resolved against JVM system properties at runtime.</para>, +    bean definition.</para>, +    definitions.</para>, +      <para>You are not required to supply a name or id for a bean. If no, +		<!-- MLP: Beverly to review -->, +        suffice. However, depending on what type of IoC you use for that, +        specific bean, you may need a default (empty) constructor.</para>, +      <!-- MLP: Beverly review the following two paragraphs -->, +      controlling the instantiation or location of its dependencies on its own, +    &lt;bean id="baz" class="x.y.Baz"/&gt;, +, +        <para>The <interfacename>ApplicationContext</interfacename> supports, +        constructor- and setter-based DI for the beans it manages. It also, +        supports setter-based DI after some dependencies are already injected, +        through the constructor approach. You configure the dependencies in, +        the form of a <interfacename>BeanDefinition</interfacename>, which you, +        use with <interfacename>PropertyEditor</interfacename> instances to, +        convert properties from one format to another. However, most Spring, +        users do not work with these classes directly (programmatically), but, +        rather with an XML definition file that is then converted internally, +        into instances of these classes, and used to load an entire Spring IoC, +        container instance.</para>, +, +        <!-- MLP: Beverly to review all list items-->, +        <para>The <literal>ref</literal> element is the final element, +        set the value of the specified property of a bean to be a reference to another, +      <!-- MLP: Beverly to review paragraph -->, +      <interfacename>ApplicationContextAware</interfacename> interface,, +      time bean A needs it. The following is an example of this, +      approach:</para>, +    <para>When you create a bean definition, you create a, +    <emphasis>recipe</emphasis> for creating actual instances of the class, +    recipe is important, because it means that, as with a class, you can, +    create many object instances from a single recipe.</para>, +    the objects created from a particular bean definition. This approach, +    powerful and flexible in that you can <emphasis>choose</emphasis> the, +    scope of the objects you create through configuration instead of having to, +    bake in the scope of an object at the Java class level. Beans can be, +    defined to be deployed in one of a number of scopes: out of the box, the, +    Spring Framework supports five scopes, three of which are available only, +    if you use a web-aware, +    <interfacename>ApplicationContext</interfacename>.</para>, +    <para>The following scopes are supported out of the box. You can also, +    create <link linkend="beans-factory-scopes-custom">a custom, +    scope.</link></para>, +            single HTTP request; that is, each HTTP request has its own, +            instance of a bean created off the back of a single bean, +      <para>Only one <emphasis>shared</emphasis> instance of a singleton bean, +      is managed, and all requests for beans with an id or ids matching that, +      bean definition result in that one specific bean instance being returned, +      by the Spring container.</para>, +      scoped as a singleton, the Spring IoC container creates, +      bean definition. This single instance is stored in a cache of such, +      references</emphasis> for that named bean return the cached, +      object.</para>, +      <para>Spring's concept of a singleton bean differs from the Singleton, +      pattern as defined in the Gang of Four (GoF) patterns book. The GoF, +      Singleton hard-codes the scope of an object such that one <emphasis>and, +      only one</emphasis> instance of a particular class is created<emphasis>, +      per <classname>ClassLoader</classname></emphasis>. The scope of the, +      Spring singleton is best described as <emphasis>per container and per, +      class in a single Spring container, then the Spring container creates, +      one <emphasis>and only one</emphasis> instance of the class defined by, +      that bean definition. <emphasis>The singleton scope is the default scope, +      in Spring</emphasis>. To define a bean as a singleton in XML, you would, +      write, for example:</para>, +      request for that specific bean is made. That is, the bean is injected, +      into another bean or you request it through a, +      <literal>getBean()</literal> method call on the container. As a rule,, +      use the prototype scope for all stateful beans and the singleton scope, +      for stateless beans.</para>, +      <emphasis>A data access object (DAO) is not typically configured as a, +      prototype, because a typical DAO does not hold any conversational state;]