[+++ b/spring-context/src/main/java/org/springframework/context/annotation/Conditional.java, + * Copyright 2002-2017 the original author or authors., +import java.lang.annotation.Documented;, +@Retention(RetentionPolicy.RUNTIME), +@Documented, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Conditional.java, + * Copyright 2002-2017 the original author or authors., +import java.lang.annotation.Documented;, +@Retention(RetentionPolicy.RUNTIME), +@Documented, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Profile.java, + * Copyright 2002-2017 the original author or authors., + * given {@code @Profile({"p1", "!p2"})}, registration will occur if profile 'p1' is active, + * or if profile 'p2' is <em>not</em> active., + * <p><b>NOTE:</b> With {@code @Profile} on {@code @Bean} methods, a special scenario may, + * apply: In the case of overloaded {@code @Bean} methods, all {@code @Profile} declarations, + * from all applicable factory methods for the same bean will be merged; as a consequence,, + * they all need to match for the bean to become registered. {@code @Profile} can therefore, + * not be used to select a particular overloaded method over another; resolution between, + * overloaded factory methods only follows Spring's constructor resolution algorithm., + *, +@Retention(RetentionPolicy.RUNTIME), +++ b/spring-context/src/main/java/org/springframework/context/annotation/Conditional.java, + * Copyright 2002-2017 the original author or authors., +import java.lang.annotation.Documented;, +@Retention(RetentionPolicy.RUNTIME), +@Documented, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Profile.java, + * Copyright 2002-2017 the original author or authors., + * given {@code @Profile({"p1", "!p2"})}, registration will occur if profile 'p1' is active, + * or if profile 'p2' is <em>not</em> active., + * <p><b>NOTE:</b> With {@code @Profile} on {@code @Bean} methods, a special scenario may, + * apply: In the case of overloaded {@code @Bean} methods, all {@code @Profile} declarations, + * from all applicable factory methods for the same bean will be merged; as a consequence,, + * they all need to match for the bean to become registered. {@code @Profile} can therefore, + * not be used to select a particular overloaded method over another; resolution between, + * overloaded factory methods only follows Spring's constructor resolution algorithm., + *, +@Retention(RetentionPolicy.RUNTIME), +++ b/src/docs/asciidoc/core/core-beans.adoc, +, +, +, +, +, +[TIP], +====, +If a `@Configuration` class is marked with `@Profile`, all of the `@Bean` methods and, +`@Import` annotations associated with that class will be bypassed unless one or more of, +the specified profiles are active. If a `@Component` or `@Configuration` class is marked, +with `@Profile({"p1", "p2"})`, that class will not be registered/processed unless, +profiles 'p1' and/or 'p2' have been activated. If a given profile is prefixed with the, +NOT operator (`!`), the annotated element will be registered if the profile is **not**, +active. For example, given `@Profile({"p1", "!p2"})`, registration will occur if profile, +'p1' is active or if profile 'p2' is not active., +====, +, +[NOTE], +With `@Profile` on `@Bean` methods, a special scenario may apply: In the case of, +overloaded `@Bean` methods, all `@Profile` declarations from all applicable factory, +methods for the same bean will be merged; as a consequence, they all need to match, +for the bean to become registered. `@Profile` can therefore not be used to select, +a particular overloaded method over another; resolution between overloaded factory, +methods only follows Spring's constructor resolution algorithm., +, +==== XML bean definition profiles]