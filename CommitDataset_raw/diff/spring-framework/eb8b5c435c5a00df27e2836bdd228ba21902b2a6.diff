[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, +, +				this.callbackTypes[i] = callbacks[i].getClass();, +			for (int i = 0; i < this.callbacks.length; i++) {, +				if (!(this.callbacks[i] instanceof ConditionalCallback) ||, +						((ConditionalCallback) this.callbacks[i]).isMatch(method)) {, +			throw new IllegalStateException("No callback available for method " + method.getName());, +			return this.callbackTypes;, +			// Does the actual (non-CGLIB) superclass actually implement DisposableBean?, +			// If so, call its dispose() method. If not, just exit., +		@Override, +		public boolean isMatch(Method candidateMethod) {, +			return candidateMethod.getName().equals("destroy") &&, +					candidateMethod.getParameterTypes().length == 0 &&, +					DisposableBean.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		}, +		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {, +			Field field = obj.getClass().getDeclaredField(BEAN_FACTORY_FIELD);, +			Assert.state(field != null, "Unable to find generated BeanFactory field");, +			field.set(obj, args[0]);, +, +			// Does the actual (non-CGLIB) superclass actually implement BeanFactoryAware?, +			// If so, call its setBeanFactory() method. If not, just exit., +			if (BeanFactoryAware.class.isAssignableFrom(obj.getClass().getSuperclass())) {, +				return proxy.invokeSuper(obj, args);, +			}, +			return null;, +		}, +, +		@Override, +			// Determine whether this bean is a scoped-proxy, +			// To handle the case of an inter-bean method reference, we must explicitly check the, +			// container for already cached instances., +			// First, check to see if the requested bean is a FactoryBean. If so, create a subclass, +			// This ensures that the semantics of calling a FactoryBean from within @Bean methods, +					// Pass through - scoped proxy factory beans are a special case and should not, +					// It is a candidate FactoryBean - go ahead with enhancement, +				// The factory is calling the bean method in order to instantiate and register the bean, +				// The user (i.e. not the factory) is requesting this bean through a, +, +, +		@Override, +		public boolean isMatch(Method candidateMethod) {, +			return BeanAnnotationHelper.isBeanAnnotated(candidateMethod);, +		}]