[+++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +import java.lang.reflect.Modifier;, +import org.springframework.core.MethodIntrospector;, +	 * Select an invocable method on the target type: either the given method itself, +	 * if actually exposed on the target type, or otherwise a corresponding method, +	 * on one of the target type's interfaces or on the target type itself., +	 * @param method the method to check, +	 * @param targetType the target type to search methods on (typically an AOP proxy), +	 * @return a corresponding invocable method on the target type, +	 * @throws IllegalStateException if the given method is not invocable on the given, +	 * target type (typically due to a proxy mismatch), +	 * @since 4.3, +	 * @see MethodIntrospector#selectInvocableMethod(Method, Class), +	 */, +	public static Method selectInvocableMethod(Method method, Class<?> targetType) {, +		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);, +		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&, +				SpringProxy.class.isAssignableFrom(targetType)) {, +			throw new IllegalStateException(String.format(, +					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +, +					"be delegated to target bean. Switch its visibility to package or protected.",, +					method.getName(), method.getDeclaringClass().getSimpleName()));, +		}, +		return methodToUse;, +	}, +, +	/**, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +import java.lang.reflect.Modifier;, +import org.springframework.core.MethodIntrospector;, +	 * Select an invocable method on the target type: either the given method itself, +	 * if actually exposed on the target type, or otherwise a corresponding method, +	 * on one of the target type's interfaces or on the target type itself., +	 * @param method the method to check, +	 * @param targetType the target type to search methods on (typically an AOP proxy), +	 * @return a corresponding invocable method on the target type, +	 * @throws IllegalStateException if the given method is not invocable on the given, +	 * target type (typically due to a proxy mismatch), +	 * @since 4.3, +	 * @see MethodIntrospector#selectInvocableMethod(Method, Class), +	 */, +	public static Method selectInvocableMethod(Method method, Class<?> targetType) {, +		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);, +		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&, +				SpringProxy.class.isAssignableFrom(targetType)) {, +			throw new IllegalStateException(String.format(, +					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +, +					"be delegated to target bean. Switch its visibility to package or protected.",, +					method.getName(), method.getDeclaringClass().getSimpleName()));, +		}, +		return methodToUse;, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/context/event/EventListenerMethodProcessor.java, +import org.springframework.aop.support.AopUtils;, +							Method methodToUse = AopUtils.selectInvocableMethod(, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +import java.lang.reflect.Modifier;, +import org.springframework.core.MethodIntrospector;, +	 * Select an invocable method on the target type: either the given method itself, +	 * if actually exposed on the target type, or otherwise a corresponding method, +	 * on one of the target type's interfaces or on the target type itself., +	 * @param method the method to check, +	 * @param targetType the target type to search methods on (typically an AOP proxy), +	 * @return a corresponding invocable method on the target type, +	 * @throws IllegalStateException if the given method is not invocable on the given, +	 * target type (typically due to a proxy mismatch), +	 * @since 4.3, +	 * @see MethodIntrospector#selectInvocableMethod(Method, Class), +	 */, +	public static Method selectInvocableMethod(Method method, Class<?> targetType) {, +		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);, +		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&, +				SpringProxy.class.isAssignableFrom(targetType)) {, +			throw new IllegalStateException(String.format(, +					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +, +					"be delegated to target bean. Switch its visibility to package or protected.",, +					method.getName(), method.getDeclaringClass().getSimpleName()));, +		}, +		return methodToUse;, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/context/event/EventListenerMethodProcessor.java, +import org.springframework.aop.support.AopUtils;, +							Method methodToUse = AopUtils.selectInvocableMethod(, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java, +			Method invocableMethod = AopUtils.selectInvocableMethod(method, bean.getClass());, +			Runnable runnable = new ScheduledMethodRunnable(bean, invocableMethod);, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +import java.lang.reflect.Modifier;, +import org.springframework.core.MethodIntrospector;, +	 * Select an invocable method on the target type: either the given method itself, +	 * if actually exposed on the target type, or otherwise a corresponding method, +	 * on one of the target type's interfaces or on the target type itself., +	 * @param method the method to check, +	 * @param targetType the target type to search methods on (typically an AOP proxy), +	 * @return a corresponding invocable method on the target type, +	 * @throws IllegalStateException if the given method is not invocable on the given]