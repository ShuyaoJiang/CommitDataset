[+++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +		Class<?> specificTargetClass = (targetClass != null && !Proxy.isProxyClass(targetClass) ?, +				ClassUtils.getUserClass(targetClass) : null);, +		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);, +		Set<Class<?>> classes = new LinkedHashSet<>();, +		if (!Proxy.isProxyClass(targetClass)) {, +			classes.add(ClassUtils.getUserClass(targetClass));, +		}, +		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));, +, +						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||, +						methodMatcher.matches(method, targetClass)) {, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +		Class<?> specificTargetClass = (targetClass != null && !Proxy.isProxyClass(targetClass) ?, +				ClassUtils.getUserClass(targetClass) : null);, +		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);, +		Set<Class<?>> classes = new LinkedHashSet<>();, +		if (!Proxy.isProxyClass(targetClass)) {, +			classes.add(ClassUtils.getUserClass(targetClass));, +		}, +		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));, +, +						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||, +						methodMatcher.matches(method, targetClass)) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.support.AopUtils;, +		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +		Class<?> specificTargetClass = (targetClass != null && !Proxy.isProxyClass(targetClass) ?, +				ClassUtils.getUserClass(targetClass) : null);, +		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);, +		Set<Class<?>> classes = new LinkedHashSet<>();, +		if (!Proxy.isProxyClass(targetClass)) {, +			classes.add(ClassUtils.getUserClass(targetClass));, +		}, +		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));, +, +						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||, +						methodMatcher.matches(method, targetClass)) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.support.AopUtils;, +		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/AbstractFallbackCacheOperationSource.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.support.AopUtils;, +		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +		Class<?> specificTargetClass = (targetClass != null && !Proxy.isProxyClass(targetClass) ?, +				ClassUtils.getUserClass(targetClass) : null);, +		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);, +		Set<Class<?>> classes = new LinkedHashSet<>();, +		if (!Proxy.isProxyClass(targetClass)) {, +			classes.add(ClassUtils.getUserClass(targetClass));, +		}, +		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));, +, +						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||, +						methodMatcher.matches(method, targetClass)) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.support.AopUtils;, +		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/AbstractFallbackCacheOperationSource.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.support.AopUtils;, +		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);, +++ b/spring-context/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJAutoProxyCreatorTests.java, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +, +, +, +, +, +, +, +, +, +, +, +	public void testRetryAspect() {, +, +	@Test, +	public void testWithBeanNameAutoProxyCreator() {, +		ClassPathXmlApplicationContext bf = newContext("withBeanNameAutoProxyCreator.xml");, +, +		ITestBean tb = (ITestBean) bf.getBean("adrian");, +		assertEquals(68, tb.getAge());, +	}, +, +, +		return String.format("%s-%s", getClass().getSimpleName(), fileSuffix);, +	}, +, +	private void assertStopWatchTimeLimit(final StopWatch sw, final long maxTimeMillis) {, +		long totalTimeMillis = sw.getTotalTimeMillis();, +		assertTrue("'" + sw.getLastTaskName() + "' took too long: expected less than<" + maxTimeMillis +, +				"> ms, actual<" + totalTimeMillis + "> ms.", totalTimeMillis < maxTimeMillis);]