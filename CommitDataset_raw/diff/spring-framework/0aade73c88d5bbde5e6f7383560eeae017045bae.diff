[+++ b/spring-web-reactive/src/main/java/org/springframework/http/server/reactive/ServletHttpHandlerAdapter.java, +import java.nio.ByteBuffer;, +import java.util.Arrays;, +import java.util.concurrent.atomic.AtomicLong;, +import javax.servlet.ReadListener;, +import javax.servlet.ServletInputStream;, +import javax.servlet.ServletOutputStream;, +import javax.servlet.WriteListener;, +import org.reactivestreams.Publisher;, +import org.springframework.util.Assert;, +	private static final int BUFFER_SIZE = 8192;, +, +	protected void service(HttpServletRequest servletRequest, HttpServletResponse servletResponse), +		AsyncContext context = servletRequest.startAsync();, +		RequestBodyPublisher requestBody = new RequestBodyPublisher(synchronizer, BUFFER_SIZE);, +		ServletServerHttpRequest request = new ServletServerHttpRequest(servletRequest, requestBody);, +		servletRequest.getInputStream().setReadListener(requestBody);, +		ResponseBodySubscriber responseBodySubscriber = new ResponseBodySubscriber(synchronizer);, +		ServletServerHttpResponse response = new ServletServerHttpResponse(servletResponse,, +				publisher -> subscriber -> publisher.subscribe(responseBodySubscriber));, +		servletResponse.getOutputStream().setWriteListener(responseBodySubscriber);, +		HandlerResultSubscriber resultSubscriber = new HandlerResultSubscriber(synchronizer, response);, +		this.handler.handle(request, response).subscribe(resultSubscriber);, +	private static class RequestBodyPublisher implements ReadListener, Publisher<ByteBuffer> {, +, +		private final ServletAsyncContextSynchronizer synchronizer;, +, +		private final byte[] buffer;, +, +		private final DemandCounter demand = new DemandCounter();, +, +		private Subscriber<? super ByteBuffer> subscriber;, +, +		private boolean stalled;, +, +		private boolean cancelled;, +, +, +		public RequestBodyPublisher(ServletAsyncContextSynchronizer synchronizer, int bufferSize) {, +			this.synchronizer = synchronizer;, +			this.buffer = new byte[bufferSize];, +		}, +, +, +		@Override, +		public void subscribe(Subscriber<? super ByteBuffer> subscriber) {, +			if (subscriber == null) {, +				throw new NullPointerException();, +			}, +			else if (this.subscriber != null) {, +				subscriber.onError(new IllegalStateException("Only one subscriber allowed"));, +			}, +			this.subscriber = subscriber;, +			this.subscriber.onSubscribe(new RequestBodySubscription());, +		}, +, +		@Override, +		public void onDataAvailable() throws IOException {, +			if (cancelled) {, +				return;, +			}, +			ServletInputStream input = this.synchronizer.getInputStream();, +			logger.debug("onDataAvailable: " + input);, +, +			while (true) {, +				logger.debug("Demand: " + this.demand);, +, +				if (!demand.hasDemand()) {, +					stalled = true;, +					break;, +				}, +, +				boolean ready = input.isReady();, +				logger.debug("Input ready: " + ready + " finished: " + input.isFinished());, +, +				if (!ready) {, +					break;, +				}, +, +				int read = input.read(buffer);, +				logger.debug("Input read:" + read);, +, +				if (read == -1) {, +					break;, +				}, +				else if (read > 0) {, +					this.demand.decrement();, +					byte[] copy = Arrays.copyOf(this.buffer, read);, +, +//				logger.debug("Next: " + new String(copy, UTF_8));, +, +					this.subscriber.onNext(ByteBuffer.wrap(copy));, +, +				}, +			}, +		}, +, +		@Override, +		public void onAllDataRead() throws IOException {, +			if (cancelled) {]