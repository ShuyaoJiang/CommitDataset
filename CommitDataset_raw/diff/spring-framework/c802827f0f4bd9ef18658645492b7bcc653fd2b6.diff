[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.function.Consumer;, +	private static final Consumer<DataBuffer> RELEASE_CONSUMER = DataBufferUtils::release;, +, +	//---------------------------------------------------------------------, +	// Reading, +	//---------------------------------------------------------------------, +, +	//---------------------------------------------------------------------, +	// Writing, +	//---------------------------------------------------------------------, +, +	 * <strong>not</strong> close the output stream when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source,, +	 * <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source,, +		return Flux.create(sink ->, +								sink.next(dataBuffer);, +						sink::complete));, +	 * Does <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel,, +		return Flux.create(sink -> {, +	//---------------------------------------------------------------------, +	// Various, +	//---------------------------------------------------------------------, +, +	/**, +	 * Returns a consumer that calls {@link #release(DataBuffer)} on all, +	 * passed data buffers., +	 */, +	public static Consumer<DataBuffer> releaseConsumer() {, +		return RELEASE_CONSUMER;, +	}, +, +		private final FluxSink<DataBuffer> sink;, +		private final AtomicBoolean completed = new AtomicBoolean();, +, +				FluxSink<DataBuffer> sink, AsynchronousFileChannel channel, long position) {, +			this.completed.set(true);, +				return;, +			}, +			else if (this.dataBuffer != null) {, +				this.sink.next(this.dataBuffer);, +			}, +			if (this.completed.get()) {, +				this.sink.complete();, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.function.Consumer;, +	private static final Consumer<DataBuffer> RELEASE_CONSUMER = DataBufferUtils::release;, +, +	//---------------------------------------------------------------------, +	// Reading, +	//---------------------------------------------------------------------, +, +	//---------------------------------------------------------------------, +	// Writing, +	//---------------------------------------------------------------------, +, +	 * <strong>not</strong> close the output stream when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source,, +	 * <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source,, +		return Flux.create(sink ->, +								sink.next(dataBuffer);, +						sink::complete));, +	 * Does <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a]