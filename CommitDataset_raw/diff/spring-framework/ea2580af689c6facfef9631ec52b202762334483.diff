[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +		if (peekToken(TokenKind.PLUS,TokenKind.MINUS,TokenKind.NOT)) {, +			if (t.kind==TokenKind.NOT) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +		if (peekToken(TokenKind.PLUS,TokenKind.MINUS,TokenKind.NOT)) {, +			if (t.kind==TokenKind.NOT) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"), DIV("/"), NOT("!"), MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	, +	public int getLength() {, +		return tokenChars.length;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +		if (peekToken(TokenKind.PLUS,TokenKind.MINUS,TokenKind.NOT)) {, +			if (t.kind==TokenKind.NOT) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"), DIV("/"), NOT("!"), MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	, +	public int getLength() {, +		return tokenChars.length;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +import java.util.Arrays;, +						pushCharToken(TokenKind.NOT);, +	// if this is changed, it must remain sorted, +	private static final String[] alternativeOperatorNames = { "DIV","EQ","GE","GT","LE","LT","MOD","NE","NOT"};, +		char[] subarray = subarray(start,pos);, +		, +		// Check if this is the alternative (textual) representation of an operator (see alternativeOperatorNames), +		if ((pos-start)==2 || (pos-start)==3) {, +			String asString = new String(subarray).toUpperCase();, +			int idx = Arrays.binarySearch(alternativeOperatorNames,asString);, +			if (idx>=0) {, +				pushOneCharOrTwoCharToken(TokenKind.valueOf(asString),start);, +				return;, +			}, +		}, +		tokens.add(new Token(TokenKind.IDENTIFIER,subarray,start,pos));, +	private void pushOneCharOrTwoCharToken(TokenKind kind, int pos) {, +		tokens.add(new Token(kind,pos,pos+kind.getLength()));, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +		if (peekToken(TokenKind.PLUS,TokenKind.MINUS,TokenKind.NOT)) {, +			if (t.kind==TokenKind.NOT) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"), DIV("/"), NOT("!"), MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	, +	public int getLength() {, +		return tokenChars.length;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +import java.util.Arrays;, +						pushCharToken(TokenKind.NOT);, +	// if this is changed, it must remain sorted, +	private static final String[] alternativeOperatorNames = { "DIV","EQ","GE","GT","LE","LT","MOD","NE","NOT"};, +		char[] subarray = subarray(start,pos);, +		, +		// Check if this is the alternative (textual) representation of an operator (see alternativeOperatorNames), +		if ((pos-start)==2 || (pos-start)==3) {, +			String asString = new String(subarray).toUpperCase();, +			int idx = Arrays.binarySearch(alternativeOperatorNames,asString);, +			if (idx>=0) {, +				pushOneCharOrTwoCharToken(TokenKind.valueOf(asString),start);, +				return;, +			}, +		}, +		tokens.add(new Token(TokenKind.IDENTIFIER,subarray,start,pos));, +	private void pushOneCharOrTwoCharToken(TokenKind kind, int pos) {, +		tokens.add(new Token(kind,pos,pos+kind.getLength()));, +	}, +, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/BooleanExpressionTests.java, +, +		evaluate("not false", Boolean.TRUE, Boolean.class);, +		evaluate("NoT true", Boolean.FALSE, Boolean.class);, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/SpelExpressionParser.java, +		if (peekToken(TokenKind.PLUS,TokenKind.MINUS,TokenKind.NOT)) {, +			if (t.kind==TokenKind.NOT) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, +	DOT("."), PLUS("+"), STAR("*"), DIV("/"), NOT("!"), MINUS("-"), SELECT_FIRST("^["), SELECT_LAST("$["), QMARK("?"), PROJECT("!["),, +	, +	public int getLength() {, +		return tokenChars.length;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +import java.util.Arrays;, +						pushCharToken(TokenKind.NOT);, +	// if this is changed, it must remain sorted, +	private static final String[] alternativeOperatorNames = { "DIV","EQ","GE","GT","LE","LT","MOD","NE","NOT"};, +		char[] subarray = subarray(start,pos);, +		, +		// Check if this is the alternative (textual) representation of an operator (see alternativeOperatorNames), +		if ((pos-start)==2 || (pos-start)==3) {, +			String asString = new String(subarray).toUpperCase();, +			int idx = Arrays.binarySearch(alternativeOperatorNames,asString);, +			if (idx>=0) {, +				pushOneCharOrTwoCharToken(TokenKind.valueOf(asString),start);, +				return;, +			}]