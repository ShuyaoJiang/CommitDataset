[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, +import java.lang.reflect.Field;, +import org.springframework.asm.Type;, +import org.springframework.beans.factory.BeanFactoryAware;, +import org.springframework.cglib.core.ClassGenerator;, +import org.springframework.cglib.core.Constants;, +import org.springframework.cglib.core.DefaultGeneratorStrategy;, +import org.springframework.cglib.transform.ClassEmitterTransformer;, +import org.springframework.cglib.transform.TransformingClassGenerator;, +import org.springframework.util.ReflectionUtils;, +	private static final Callback[] CALLBACKS = new Callback[] {, +		new BeanMethodInterceptor(),, +		new DisposableBeanMethodInterceptor(),, +		new BeanFactoryAwareMethodInterceptor(),, +		NoOp.INSTANCE, +	};, +	private static final ConditionalCallbackFilter CALLBACK_FILTER =, +			new ConditionalCallbackFilter(CALLBACKS);, +	private static final String BEAN_FACTORY_FIELD = "$$beanFactory";, +		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());, +		enhancer.setStrategy(new DefaultGeneratorStrategy() {, +			@Override, +			protected ClassGenerator transform(ClassGenerator cg) throws Exception {, +				ClassEmitterTransformer transformer = new ClassEmitterTransformer() {, +					@Override, +					public void end_class() {, +						declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD,, +								Type.getType(BeanFactory.class), null);, +						super.end_class();, +					}, +				};, +				return new TransformingClassGenerator(cg, transformer);, +			}, +		});, +		Enhancer.registerStaticCallbacks(subclass, CALLBACKS);, +	 * <p>Also extends {@link DisposableBean} and {@link BeanFactoryAware}, as all, +	 * enhanced {@code @Configuration} classes require access to the {@link BeanFactory}, +	 * that created them and must de-register static CGLIB callbacks on destruction,, +	 * which is handled by the (private) {@code DisposableBeanMethodInterceptor}., +	public interface EnhancedConfiguration extends DisposableBean, BeanFactoryAware {, +	 * Conditional {@link Callback}., +	 * @see ConditionalCallbackFilter, +	private static interface ConditionalCallback extends Callback {, +		boolean isMatch(Method candidateMethod);, +	 * A {@link CallbackFilter} that works by interrogating {@link Callback}s in the order, +	 * that they are defined via {@link ConditionalCallback}., +	private static class ConditionalCallbackFilter implements CallbackFilter {, +		private final Callback[] callbacks;, +		private final Class<?>[] callbackTypes;, +		public ConditionalCallbackFilter(Callback[] callbacks) {, +			this.callbacks = callbacks;, +			this.callbackTypes = new Class<?>[callbacks.length];, +			for (int i = 0; i < callbacks.length; i++) {, +				callbackTypes[i] = callbacks[i].getClass();, +		@Override, +		public int accept(Method method) {, +			for (int i = 0; i < callbacks.length; i++) {, +				if (!(callbacks[i] instanceof ConditionalCallback) ||, +						((ConditionalCallback) callbacks[i]).isMatch(method)) {, +					return i;, +				}, +			}, +			throw new IllegalStateException("No callback available for method ", +					+ method.getName());, +		}, +, +		public Class<?>[] getCallbackTypes() {, +			return callbackTypes;, +		}, +	}, +	private static class DisposableBeanMethodInterceptor implements MethodInterceptor,, +			ConditionalCallback {, +, +		public boolean isMatch(Method candidateMethod) {, +			return candidateMethod.getName().equals("destroy"), +					&& candidateMethod.getParameterTypes().length == 0, +					&& DisposableBean.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		}, +	}, +, +, +	/**, +	 * Intercepts the invocation of any, +	 * {@link BeanFactoryAware#setBeanFactory(BeanFactory)} on {@code @Configuration}, +	 * class instances for the purpose of recording the {@link BeanFactory}., +	 *, +	 * @see EnhancedConfiguration, +	 */, +	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor,, +			ConditionalCallback {, +, +		public boolean isMatch(Method candidateMethod) {, +			return candidateMethod.getName().equals("setBeanFactory"), +					&& candidateMethod.getParameterTypes().length == 1, +					&& candidateMethod.getParameterTypes()[0].equals(BeanFactory.class), +					&& BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass());, +		}, +, +		public Object intercept(Object obj, Method method, Object[] args,, +				MethodProxy proxy) throws Throwable {]