[+++ b/spring-framework-reference/src/testing.xml, +        in combination with JUnit, TestNG, or any other testing framework for, +        unit tests dealing with Spring MVC <classname>ModelAndView</classname>, +        objects.</para>, +      <para>The Spring Framework provides first-class support for integration, +      testing in the <filename class="libraryfile">spring-test</filename>, +      module. The name of the actual JAR file might include the release, +      version and might also be in the long, +      <filename>org.springframework.test</filename> form, depending on where, +      you get it from (see the <link linkend="dependency-management">section, +      on Dependency Management</link> for an explanation). This library, +      includes the <literal>org.springframework.test</literal> package, which, +      container. This testing does not rely on an application server or other, +      deployment environment. Such tests are slower to run than unit tests but, +      much faster than the equivalent Cactus tests or remote tests that rely, +      on deployment to an application server.</para>, +        <para>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy, +        (i.e.,, +        Any test classes based on this code should be migrated to the <link, +        linkend="testcontext-framework">Spring TestContext, +        Framework</link>.</para>, +        and <interfacename>@ExpectedException</interfacename> have been, +        officially deprecated and will be removed in a later release. Any test, +        classes based on this code should be migrated to the JUnit 4 or TestNG, +        support provided by the <link linkend="testcontext-framework">Spring, +        TestContext Framework</link>. Similarly, any test methods annotated, +        with <interfacename>@ExpectedException</interfacename> should be, +        modified to use the built-in support for expected exceptions in JUnit, +        and TestNG.</para>, +      <para>Spring's integration testing support has the following primary, +      goals:</para>, +          <para>To manage <link linkend="testing-ctx-management">Spring IoC, +          container caching</link> between test execution.</para>, +          <para>To provide <link linkend="testing-fixture-di">Dependency, +          Injection of test fixture instances</link>.</para>, +          <para>To provide <link linkend="testing-tx">transaction, +          management</link> appropriate to integration testing.</para>, +          <para>To supply <link, +          linkend="testing-support-classes">Spring-specific base, +          classes</link> that assist developers in writing integration, +        because startup time can become an issue — not because of the overhead, +        <!--TODO Modify the following paragraph regarding 3.1's support for @Configuration classes.-->, +, +        of XML configuration metadata — typically in the classpath — that is, +        test. Thus the setup cost is incurred only once (per test suite), and, +        subsequent test execution is much faster. In the unlikely case that a, +        test corrupts the application context and requires reloading — for, +        example, by modifying a bean definition or the state of an application, +        object — the TestContext framework can be configured to reload the, +        configuration and rebuild the application context before executing the, +        next test.</para>, +        duplicate complex test fixture set up for individual test, +        cases.</para>, +        <classname>HibernateTitleRepository</classname>, that performs data, +        access logic for say, the <classname>Title</classname> domain object., +        We want to write integration tests that test all of the following, +            <para>The logic of the, +            <classname>HibernateTitleRepository</classname>: does the, +            configured instance of this class perform as anticipated?</para>, +        Also, many operations — such as inserting or modifying persistent data, +        — cannot be performed (or verified) outside a transaction.</para>, +        <para>If you want a transaction to commit — unusual, but occasionally, +        database — the TestContext framework can be instructed to cause the, +            SQL statements to query the database. Such queries can be used to, +            confirm database state both <emphasis>prior to</emphasis> and, +            <emphasis>after</emphasis> execution of database-related, +            application code, and Spring ensures that such queries run in the, +            scope of the same transaction as the application code. When used, +            in conjunction with an ORM tool, be sure to avoid <link, +            linkend="testcontext-tx-false-positives">false, +            positives</link>.</para>, +      framework. Refer to the respective Javadoc for further information,, +          use for loading the context. Note, however, that you typically do, +          not need to explicitly configure the loader since the default loader, +          supports either resource <varname>locations</varname> or, +          configuration <varname>classes</varname>.</para>, +            management and caching</link> and Javadoc for an example and, +          <emphasis>dirtied</emphasis> (i.e., modified or corrupted in some, +          manner) during the execution of a test and should be closed,, +          <interfacename>@DirtiesContext</interfacename> is supported in the, +          following scenarios:</para>, +          and method-level annotation within the same test class. In such, +          scenarios, the <interfacename>ApplicationContext</interfacename> is, +          marked as <emphasis>dirty</emphasis> after any such annotated method, +          as well as after the entire class. If the, +          <classname>ClassMode</classname> is set to, +          <literal>AFTER_EACH_TEST_METHOD</literal>, the context is marked, +          dirty after each test method in the class.</para>, +          Typically, <interfacename>@TestExecutionListeners</interfacename> is, +          used in conjunction with, +          the Javadoc for an example and further details.</para>, +          bean name of the desired, +          <interfacename>PlatformTransactionManager</interfacename> is not, +          "transactionManager". In addition, you can change the, +            <para>If the default conventions are sufficient for your test, +            configuration, you can avoid using, +            altogether. In other words, if your transaction manager bean is, +            named "transactionManager" and if you want transactions to roll, +            back automatically, there is no need to annotate your test class, +            with]