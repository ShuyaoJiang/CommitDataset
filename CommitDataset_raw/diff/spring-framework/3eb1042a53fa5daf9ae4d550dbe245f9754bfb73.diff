[+++ b/src/docs/asciidoc/core/core-aop-api.adoc, +The previous chapter described the Spring's support for AOP with @AspectJ and schema-based, +aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common, +applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the, +previous chapter., +You can use custom pointcuts with any advice type., +There is little performance difference between CGLIB proxying and dynamic proxies., +prevent calling code removing a security interceptor)., +++ b/src/docs/asciidoc/core/core-aop-api.adoc, +The previous chapter described the Spring's support for AOP with @AspectJ and schema-based, +aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common, +applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the, +previous chapter., +You can use custom pointcuts with any advice type., +There is little performance difference between CGLIB proxying and dynamic proxies., +prevent calling code removing a security interceptor)., +++ b/src/docs/asciidoc/core/core-aop.adoc, +providing another way of thinking about program structure. The key unit of modularity, +in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects, +multiple types and objects. (Such concerns are often termed "`crosscutting`" concerns, +in AOP literature.), +.Spring AOP with AspectJ pointcuts, +Spring provides simple and powerful ways of writing custom aspects by using either a, +<<aop-schema, schema-based approach>> or the <<aop-ataspectj, @AspectJ annotation style>>., +Both of these styles offer fully typed advice and use of the AspectJ pointcut language, +while still using Spring AOP for weaving., +This chapter discusses the schema- and @AspectJ-based AOP support., +The lower-level AOP support is discussed in <<aop-api, the following chapter>>., +* Provide declarative enterprise services. The most important such service is, +All advice parameters are statically typed so that you work with advice parameters of, +the appropriate type (e.g. the type of the return value from a method execution) rather, +than `Object` arrays., +targeted independently of the object-oriented hierarchy. For example, you can apply an, +around advice providing declarative transaction management to a set of methods that span, +API. Spring AOP remains backward-compatible. See <<aop-api, the following chapter>>, +for a discussion of the Spring AOP APIs., +See <<aop-choosing>> for a more complete discussion of the "`whys and wherefores`" of, +each style., +NOTE: Using the AspectJ compiler and weaver enables use of the full AspectJ language and, +is discussed in <<aop-using-aspectj>>., +<<core.adoc#xsd-schemas, XML Schema-based configuration>>., +See <<core.adoc#xsd-schemas-aop, the AOP schema>> for how to, +import the tags in the `aop` namespace., +The first of the two example shows a regular bean definition in the application, +context that points to a bean class that has the `@Aspect` annotation:, +The second of the two examples shows the `NotVeryUsefulAspect` class definition,, +which is annotated with the `org.aspectj.lang.annotation.Aspect` annotation;, +Spring AOP and AspectJ, and this is discussed in the, +<<aop-ataspectj-advice-params, following section on advice parameters>>., +XML Schema-based configuration>>. See <<core.adoc#xsd-schemas-aop, the AOP schema>>, +<<aop-autoproxy, auto-proxying>> mechanism. This can cause issues (such as advice, +not being woven) if you already use explicit auto-proxying through the use of, +`BeanNameAutoProxyCreator` or something similar. The recommended usage pattern is to, +use either only the `<aop:config>` style or only the `AutoProxyCreator` style and, +never mix them., +language as described in <<aop-ataspectj>>. If you use the schema based declaration, +style, you can refer to named pointcuts defined in types (@Aspects) within the, +pointcut expression. Another way of defining the above pointcut would be as follows:, +the advantage that the @AspectJ aspects can be understood (and thus consumed) both by, +Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ, +to implement additional requirements, you can easily migrate to a classic AspectJ setup., +On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple, +configuration of enterprise services., +schema-defined `<aop:aspect>` aspects, `<aop:advisor>` declared advisors, and even proxies, +and interceptors in other styles in the same configuration. All of these are implemented, +by using the same underlying support mechanism and can co-exist without any difficulty., +target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common, +open-source class definition library (repackaged into `spring-core`)., +proxy is used. All of the interfaces implemented by the target type are proxied., +If the target object does not implement any interfaces, a CGLIB proxy is created., +defined for the target object, not only those implemented by its interfaces),, +you can do so. However, you should consider the following issues:, +* With CGLIB, `final` methods cannot be advised, as they cannot be overridden in, +  runtime-generated subclasses., +* As of Spring 4.0, the constructor of your proxied object is NOT called twice anymore,, +  since the CGLIB proxy instance is created through Objenesis. Only if your JVM does, +  not allow for constructor bypassing, you might see double invocations and, +To force the use of CGLIB proxies, set the value of the `proxy-target-class` attribute, +of the `<aop:config>` element to true, as follows:, +`proxy-target-class` attribute of the `<aop:aspectj-autoproxy>` element to `true`,, +as follows:, +The key thing to understand here is that the client code inside the `main(..)` method, +of the `Main` class has a reference to the proxy. This means that method calls on that, +object reference are calls on the proxy. As a result, the proxy can delegate to all of, +the interceptors (advice) that are relevant to that particular method call. However,, +once the call has finally reached the target object (the `SimplePojo`, reference in, +this case), any method calls that it may make on itself, such as `this.bar()` or, +`this.foo()`, are going to be invoked against the `this` reference, and not the proxy., +This has important implications. It means that self-invocation is not going to result, +in the advice associated with a method invocation getting a chance to execute., +Okay, so what is to be done about this? The best approach (the term, "`best,`" is used, +loosely here) is to refactor your code such that the self-invocation does not happen., +The next approach is absolutely horrendous, and we hesitate to point it out, precisely, +because it is so horrendous. You can (painful as it is to us) totally tie the logic, +within your class to Spring AOP, as the following example shows:, +In addition to declaring aspects in your configuration by using either `<aop:config>`, +or `<aop:aspectj-autoproxy>`, it is also possible to programmatically create proxies, +that advise target objects. For the full details of Spring's AOP API, see the, +<<aop-api, next chapter>>. Here, we want to focus on the ability to automatically, +create proxies by using @AspectJ aspects.]