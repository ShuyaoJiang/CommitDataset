[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +		Assert.notNull(descriptor, "Descriptor must not be null");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +		Assert.notNull(descriptor, "Descriptor must not be null");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +		for (SpelNodeImpl child: this.children) {, +		for (int i = 0; i < this.children.length;i++) {, +			SpelNodeImpl child = this.children[i];, +			if (child instanceof TypeReference && (i + 1) < this.children.length &&, +					this.children[i+1] instanceof MethodReference) {, +		codeflow.pushDescriptor(getExitDescriptor());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +		Assert.notNull(descriptor, "Descriptor must not be null");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +		for (SpelNodeImpl child: this.children) {, +		for (int i = 0; i < this.children.length;i++) {, +			SpelNodeImpl child = this.children[i];, +			if (child instanceof TypeReference && (i + 1) < this.children.length &&, +					this.children[i+1] instanceof MethodReference) {, +		codeflow.pushDescriptor(getExitDescriptor());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Elvis.java, +import org.springframework.util.StringUtils;, + * @author Juergen Hoeller, +	 * Evaluate the condition and if not null, return it., +	 * If it is null, return the other value., +	 * @throws EvaluationException if the condition does not evaluate correctly, +	 * to a boolean or there is a problem executing the chosen alternative, +		if (!StringUtils.isEmpty(value.getValue())) {, +			computeExitTypeDescriptor();, +		return getChild(0).toStringAST() + " ?: " + getChild(1).toStringAST();, +		return (condition.isCompilable() && ifNullValue.isCompilable() &&, +				condition.getExitDescriptor() != null && ifNullValue.getExitDescriptor() != null);, +	private void computeExitTypeDescriptor() {, +		if (this.exitTypeDescriptor == null && this.children[0].getExitDescriptor() != null &&, +				this.children[1].getExitDescriptor() != null) {, +			String conditionDescriptor = this.children[0].exitTypeDescriptor;, +			String ifNullValueDescriptor = this.children[1].exitTypeDescriptor;, +			if (conditionDescriptor.equals(ifNullValueDescriptor)) {, +				this.exitTypeDescriptor = conditionDescriptor;, +			}, +			else if (conditionDescriptor.equals("Ljava/lang/Object") && !CodeFlow.isPrimitive(ifNullValueDescriptor)) {, +				this.exitTypeDescriptor = ifNullValueDescriptor;, +			}, +			else if (ifNullValueDescriptor.equals("Ljava/lang/Object") && !CodeFlow.isPrimitive(conditionDescriptor)) {, +				this.exitTypeDescriptor = conditionDescriptor;, +			}, +			else {, +				// Use the easiest to compute common super type, +				this.exitTypeDescriptor = "Ljava/lang/Object";, +			}, +		}, +	}, +, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +		Assert.notNull(descriptor, "Descriptor must not be null");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java, +		for (SpelNodeImpl child: this.children) {, +		for (int i = 0; i < this.children.length;i++) {, +			SpelNodeImpl child = this.children[i];, +			if (child instanceof TypeReference && (i + 1) < this.children.length &&, +					this.children[i+1] instanceof MethodReference) {, +		codeflow.pushDescriptor(getExitDescriptor());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Elvis.java, +import org.springframework.util.StringUtils;, + * @author Juergen Hoeller, +	 * Evaluate the condition and if not null, return it., +	 * If it is null, return the other value., +	 * @throws EvaluationException if the condition does not evaluate correctly, +	 * to a boolean or there is a problem executing the chosen alternative, +		if (!StringUtils.isEmpty(value.getValue())) {, +			computeExitTypeDescriptor();, +		return getChild(0).toStringAST() + " ?: " + getChild(1).toStringAST();, +		return (condition.isCompilable() && ifNullValue.isCompilable() &&, +				condition.getExitDescriptor() != null && ifNullValue.getExitDescriptor() != null);, +	private void computeExitTypeDescriptor() {, +		if (this.exitTypeDescriptor == null && this.children[0].getExitDescriptor() != null &&, +				this.children[1].getExitDescriptor() != null) {, +			String conditionDescriptor = this.children[0].exitTypeDescriptor;, +			String ifNullValueDescriptor = this.children[1].exitTypeDescriptor;, +			if (conditionDescriptor.equals(ifNullValueDescriptor)) {, +				this.exitTypeDescriptor = conditionDescriptor;, +			}, +			else if (conditionDescriptor.equals("Ljava/lang/Object") && !CodeFlow.isPrimitive(ifNullValueDescriptor)) {, +				this.exitTypeDescriptor = ifNullValueDescriptor;, +			}, +			else if (ifNullValueDescriptor.equals("Ljava/lang/Object") && !CodeFlow.isPrimitive(conditionDescriptor)) {, +				this.exitTypeDescriptor = conditionDescriptor;, +			}, +			else {, +				// Use the easiest to compute common super type, +				this.exitTypeDescriptor = "Ljava/lang/Object";, +			}, +		}, +	}, +, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, +	// Captures the most recently used method for the function invocation *if* the method, +	// can safely be used for compilation (i.e. no argument conversion is going on), +, +		TypedValue value = state.lookupVariable(this.name);]