[+++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/FilePart.java, + * Copyright 2002-2018 the original author or authors., + * Specialization of {@link Part} that represents an uploaded file received in, + * a multipart request., +	 * Convenience method to copy the content of the file in this part to the, +	 * given destination file. If the destination file already exists, it will, +	 * be truncated first., +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/FilePart.java, + * Copyright 2002-2018 the original author or authors., + * Specialization of {@link Part} that represents an uploaded file received in, + * a multipart request., +	 * Convenience method to copy the content of the file in this part to the, +	 * given destination file. If the destination file already exists, it will, +	 * be truncated first., +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/SynchronossPartHttpMessageReader.java, +import java.nio.file.OpenOption;, +		private static final OpenOption[] FILE_CHANNEL_OPTIONS = {, +				StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE };, +, +				output = FileChannel.open(destination.toPath(), FILE_CHANNEL_OPTIONS);, +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/FilePart.java, + * Copyright 2002-2018 the original author or authors., + * Specialization of {@link Part} that represents an uploaded file received in, + * a multipart request., +	 * Convenience method to copy the content of the file in this part to the, +	 * given destination file. If the destination file already exists, it will, +	 * be truncated first., +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/SynchronossPartHttpMessageReader.java, +import java.nio.file.OpenOption;, +		private static final OpenOption[] FILE_CHANNEL_OPTIONS = {, +				StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE };, +, +				output = FileChannel.open(destination.toPath(), FILE_CHANNEL_OPTIONS);, +++ b/spring-web/src/test/java/org/springframework/http/codec/multipart/SynchronossPartHttpMessageReaderTests.java, +import java.io.File;, +import java.time.Duration;, +import reactor.core.publisher.Mono;, +import org.springframework.http.HttpMethod;, +import org.springframework.http.client.MultipartBodyBuilder;, +import org.springframework.mock.http.client.reactive.test.MockClientHttpRequest;, +import static java.util.Collections.*;, +import static org.springframework.core.ResolvableType.*;, +import static org.springframework.http.HttpHeaders.*;, +import static org.springframework.http.MediaType.*;, + * Unit tests for {@link SynchronossPartHttpMessageReader}., + *, + * @author Rossen Stoyanchev, +	public void resolveParts() {, +	@Test // SPR-16545, +	public void transferTo() {, +		ServerHttpRequest request = generateMultipartRequest();, +		ResolvableType elementType = forClassWithGenerics(MultiValueMap.class, String.class, Part.class);, +		MultiValueMap<String, Part> parts = this.reader.readMono(elementType, request, emptyMap()).block();, +, +		assertNotNull(parts);, +		FilePart part = (FilePart) parts.getFirst("fooPart");, +		assertNotNull(part);, +, +		File dest = new File(System.getProperty("java.io.tmpdir") + "/" + part.filename());, +		part.transferTo(dest).block(Duration.ofSeconds(5));, +, +		assertTrue(dest.exists());, +		assertEquals(12, dest.length());, +		assertTrue(dest.delete());, +	}, +, +	private ServerHttpRequest generateMultipartRequest() {, +, +		MultipartBodyBuilder partsBuilder = new MultipartBodyBuilder();, +		partsBuilder.part("fooPart", new ClassPathResource("org/springframework/http/codec/multipart/foo.txt"));, +		partsBuilder.part("barPart", "bar");, +, +		MockClientHttpRequest outputMessage = new MockClientHttpRequest(HttpMethod.POST, "/");, +		new MultipartHttpMessageWriter(), +				.write(Mono.just(partsBuilder.build()), null, MediaType.MULTIPART_FORM_DATA, outputMessage, null), +				.block(Duration.ofSeconds(5));, +, +		return MockServerHttpRequest.post("/"), +				.contentType(outputMessage.getHeaders().getContentType()), +				.body(outputMessage.getBody());, +		return MockServerHttpRequest.post("/")]