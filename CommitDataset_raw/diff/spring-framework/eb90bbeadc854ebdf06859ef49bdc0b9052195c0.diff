[+++ b/spring-framework-reference/src/oxm.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<chapter id="oxm">, +    <title>Marshalling XML using O/X Mappers</title>, +, +    <section id="oxm-introduction">, +        <title>Introduction</title>, +        <para>, +            In this chapter, we will describe Spring's Object/XML Mapping support. Object/XML Mapping, or O/X mapping, +            for short, is the act of converting an XML document to and from an object. This conversion process is also, +            known as XML Marshalling, or XML Serialization. This chapter uses these terms interchangeably., +        </para>, +        <para>, +            Within the field of O/X mapping, a <emphasis>marshaller</emphasis> is responsible for serializing an , +            object (graph) to XML. In similar fashion, an <emphasis>unmarshaller</emphasis> deserializes the XML to an, +            object graph. This XML can take the form of a DOM document, an input or output stream, or a SAX handler., +        </para>, +        <para>Some of the benefits of using Spring for your O/X mapping needs are:</para>, +        <formalpara>, +            <title>Ease of configuration</title>, +            <para>, +                Spring's bean factory makes it easy to configure marshallers, without needing to construct JAXB context,, +                JiBX binding factories, etc. The marshallers can be configured as any other bean in your application, +                context. Additionally, XML Schema-based configuration is available for a number of marshallers, making, +                the configuration even simpler., +            </para>, +        </formalpara>, +        <formalpara>, +            <title>Consistent Interfaces</title>, +            <para>, +                Spring's O/X mapping operates through two global interfaces: the , +                <interfacename>Marshaller</interfacename> and <interfacename>Unmarshaller</interfacename> interface. , +                These abstractions allow you to switch O/X mapping , +                frameworks with relative ease, with little or no changes required on the classes that do the , +                marshalling. This approach has the additional benefit of making it possible to do XML marshalling with , +                a mix-and-match approach (e.g. some marshalling performed using JAXB, other using XMLBeans) in a , +                non-intrusive fashion, leveraging the strength of each technology., +            </para>, +        </formalpara>, +        <formalpara>, +            <title>Consistent Exception Hierarchy</title>, +            <para>, +                Spring provides a conversion from exceptions from the underlying O/X mapping tool to its own exception, +                hierarchy with the <classname>XmlMappingException</classname> as the root exception. As can be expected,, +                these runtime exceptions wrap the original exception so no information is lost., +            </para>, +        </formalpara>, +    </section>, +    <section id="oxm-marshaller-unmarshaller">, +        <title>Marshaller and Unmarshaller</title>, +        <para>, +            As stated in the introduction, a <emphasis>marshaller</emphasis> serializes an object to XML, and an, +            <emphasis>unmarshaller</emphasis> deserializes XML stream to an object. In this section, we will describe, +            the two Spring interfaces used for this purpose., +        </para>, +        <section>, +            <title>Marshaller</title>, +            <para>, +                Spring abstracts all marshalling operations behind the , +                <interfacename>org.springframework.oxm.Marshaller</interfacename> interface, the main methods of which , +                is listed below., +                <programlisting><![CDATA[, +public interface Marshaller {, +, +    /**, +     * Marshals the object graph with the given root into the provided Result., +     */, +    void marshal(Object graph, Result result), +        throws XmlMappingException, IOException;, +}]]></programlisting>, +                The <interfacename>Marshaller</interfacename> interface has one main method, which marshals the given, +                object to a given <interfacename>javax.xml.transform.Result</interfacename>. Result is a tagging , +                interface that basically represents an XML output abstraction: concrete implementations wrap various XML, +                representations, as indicated in the table below., +                <informaltable>, +                    <tgroup cols="2">, +                        <thead>, +                            <row>, +                                <entry><interfacename>javax.xml.transform.Result</interfacename> implementation</entry>, +                                <entry>Wraps XML representation</entry>, +                            </row>, +                        </thead>, +                        <tbody>, +                            <row>, +                                <entry><classname>javax.xml.transform.dom.DOMResult</classname></entry>, +                                <entry><interfacename>org.w3c.dom.Node</interfacename></entry>, +                            </row>, +                            <row>, +                                <entry><classname>javax.xml.transform.sax.SAXResult</classname></entry>, +                                <entry><interfacename>org.xml.sax.ContentHandler</interfacename></entry>, +                            </row>, +                            <row>, +                                <entry><interfacename>javax.xml.transform.stream.StreamResult</interfacename></entry>, +                                <entry>, +                                    <classname>java.io.File</classname>,, +                                    <classname>java.io.OutputStream</classname>, or, +                                    <classname>java.io.Writer</classname>, +                                </entry>, +                            </row>, +                        </tbody>]