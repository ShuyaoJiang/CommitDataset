[+++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<DataBuffer> inputFlux = Flux.from(input);, +		return Jackson2Tokenizer.tokenize(inputFlux, factory, tokenizeArrayElements);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<DataBuffer> inputFlux = Flux.from(input);, +		return Jackson2Tokenizer.tokenize(inputFlux, factory, tokenizeArrayElements);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java, +import com.fasterxml.jackson.core.JsonFactory;, +import org.jetbrains.annotations.NotNull;, +class Jackson2Tokenizer {, +	private Jackson2Tokenizer(JsonParser parser, boolean tokenizeArrayElements) {, +	/**, +	 * Tokenize the given {@link DataBuffer} flux into a {@link TokenBuffer} flux, given the, +	 * parameters., +	 * @param dataBuffers the source data buffers, +	 * @param jsonFactory the factory to use, +	 * @param tokenizeArrayElements if {@code true} and the "top level" JSON, +	 * object is an array, each element is returned individually, immediately, +	 * after it is received., +	 * @return the result token buffers, +	 */, +	public static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,, +			boolean tokenizeArrayElements) {, +		try {, +			Jackson2Tokenizer tokenizer =, +					new Jackson2Tokenizer(jsonFactory.createNonBlockingByteArrayParser(),, +							tokenizeArrayElements);, +			return dataBuffers.flatMap(tokenizer::tokenize, Flux::error, tokenizer::endOfInput);, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +	private Flux<TokenBuffer> tokenize(DataBuffer dataBuffer) {, +			return parseTokenBufferFlux();, +		}, +		catch (JsonProcessingException ex) {, +			return Flux.error(new DecodingException(, +					"JSON decoding error: " + ex.getOriginalMessage(), ex));, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +, +	private Flux<TokenBuffer> endOfInput() {, +		this.inputFeeder.endOfInput();, +		try {, +			return parseTokenBufferFlux();, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +, +	@NotNull, +	private Flux<TokenBuffer> parseTokenBufferFlux() throws IOException {, +			if (token == null || token == JsonToken.NOT_AVAILABLE) {, +		if ((token.isStructEnd() || token.isScalarValue()) &&, +				this.objectDepth == 0 && this.arrayDepth == 0) {, +		if ((token == JsonToken.END_OBJECT &&  this.objectDepth == 0 && (this.arrayDepth == 1 || this.arrayDepth == 0)) ||, +				(token.isScalarValue()) && this.objectDepth == 0 && this.arrayDepth == 0) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java, +		Flux<DataBuffer> inputFlux = Flux.from(input);, +		return Jackson2Tokenizer.tokenize(inputFlux, factory, tokenizeArrayElements);, +++ b/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java, +import com.fasterxml.jackson.core.JsonFactory;, +import org.jetbrains.annotations.NotNull;, +class Jackson2Tokenizer {, +	private Jackson2Tokenizer(JsonParser parser, boolean tokenizeArrayElements) {, +	/**, +	 * Tokenize the given {@link DataBuffer} flux into a {@link TokenBuffer} flux, given the, +	 * parameters., +	 * @param dataBuffers the source data buffers, +	 * @param jsonFactory the factory to use, +	 * @param tokenizeArrayElements if {@code true} and the "top level" JSON, +	 * object is an array, each element is returned individually, immediately, +	 * after it is received., +	 * @return the result token buffers, +	 */, +	public static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,, +			boolean tokenizeArrayElements) {, +		try {, +			Jackson2Tokenizer tokenizer =, +					new Jackson2Tokenizer(jsonFactory.createNonBlockingByteArrayParser(),, +							tokenizeArrayElements);, +			return dataBuffers.flatMap(tokenizer::tokenize, Flux::error, tokenizer::endOfInput);, +		}, +		catch (IOException ex) {, +			return Flux.error(ex);, +		}, +	}, +	private Flux<TokenBuffer> tokenize(DataBuffer dataBuffer) {, +			return parseTokenBufferFlux();, +		}, +		catch (JsonProcessingException ex) {, +			return Flux.error(new DecodingException(, +					"JSON decoding error: " + ex.getOriginalMessage(), ex));, +		}, +		catch (IOException ex) {]