[+++ b/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java, + * Copyright 2002-2016 the original author or authors., +	 * <p>Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value), +	 * to indicate that a receive operation should check if a message is, +	 * immediately available without blocking., +	 * @see #receiveFromConsumer(MessageConsumer, long), +	 * @see javax.jms.MessageConsumer#receive(), +			Message message = receiveFromConsumer(consumer, timeout);, +			return receiveFromConsumer(consumer, getReceiveTimeout());, +++ b/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java, + * Copyright 2002-2016 the original author or authors., +	 * <p>Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value), +	 * to indicate that a receive operation should check if a message is, +	 * immediately available without blocking., +	 * @see #receiveFromConsumer(MessageConsumer, long), +	 * @see javax.jms.MessageConsumer#receive(), +			Message message = receiveFromConsumer(consumer, timeout);, +			return receiveFromConsumer(consumer, getReceiveTimeout());, +++ b/spring-jms/src/main/java/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.java, +	 * of course). 0 indicates no timeout at all; however, this is only, +	 * feasible if not running within a transaction manager and generally, +	 * discouraged since such a listener container cannot cleanly shut down., +	 * A negative value such as -1 indicates a no-wait receive operation., +	 * @see #receiveFromConsumer(MessageConsumer, long), +	 * @see javax.jms.MessageConsumer#receiveNoWait(), +		return receiveFromConsumer(consumer, getReceiveTimeout());, +++ b/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java, + * Copyright 2002-2016 the original author or authors., +	 * <p>Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value), +	 * to indicate that a receive operation should check if a message is, +	 * immediately available without blocking., +	 * @see #receiveFromConsumer(MessageConsumer, long), +	 * @see javax.jms.MessageConsumer#receive(), +			Message message = receiveFromConsumer(consumer, timeout);, +			return receiveFromConsumer(consumer, getReceiveTimeout());, +++ b/spring-jms/src/main/java/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.java, +	 * of course). 0 indicates no timeout at all; however, this is only, +	 * feasible if not running within a transaction manager and generally, +	 * discouraged since such a listener container cannot cleanly shut down., +	 * A negative value such as -1 indicates a no-wait receive operation., +	 * @see #receiveFromConsumer(MessageConsumer, long), +	 * @see javax.jms.MessageConsumer#receiveNoWait(), +		return receiveFromConsumer(consumer, getReceiveTimeout());, +++ b/spring-jms/src/main/java/org/springframework/jms/support/destination/JmsDestinationAccessor.java, + * Copyright 2002-2016 the original author or authors., +import javax.jms.Message;, +import javax.jms.MessageConsumer;, +	/**, +	 * Timeout value indicating that a receive operation should, +	 * check if a message is immediately available without blocking., +	 * @since 4.3, +	 */, +	public static final long RECEIVE_TIMEOUT_NO_WAIT = -1;, +, +	/**, +	 * Timeout value indicating a blocking receive without timeout., +	 * @since 4.3, +	 */, +	public static final long RECEIVE_TIMEOUT_INDEFINITE_WAIT = 0;, +, +, +	/**, +	 * Actually receive a message from the given consumer., +	 * @param consumer the JMS MessageConsumer to receive with, +	 * @param timeout the receive timeout (a negative value indicates, +	 * a no-wait receive; 0 indicates an indefinite wait attempt), +	 * @return the JMS Message received, or {@code null} if none, +	 * @throws JMSException if thrown by JMS API methods, +	 * @since 4.3, +	 * @see #RECEIVE_TIMEOUT_NO_WAIT, +	 * @see #RECEIVE_TIMEOUT_INDEFINITE_WAIT, +	 */, +	protected Message receiveFromConsumer(MessageConsumer consumer, long timeout) throws JMSException {, +		if (timeout > 0) {, +			return consumer.receive(timeout);, +		}, +		else if (timeout < 0) {, +			return consumer.receiveNoWait();, +		}, +		else {, +			return consumer.receive();, +		}, +	}, +]