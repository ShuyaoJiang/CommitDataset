[+++ b/spring-framework-reference/src/expressions.xml, +    is evaluated against a specific object instance (called the root object). , +    There are two options here and which to choose depends on whether the object , +    against which the expression is being evaluated will be changing with each , +    call to evaluate the expression.  In the following example, +    <programlisting language="java">// Create and set a calendar , +String name = (String) exp.getValue(context);</programlisting>, +<para>In the last, +    object the "name" property will be evaluated against.  This is the mechanism, +    to use if the root object is unlikely to change, it can simply be set once, +    in the evaluation context.  If the root object is likely to change, +    repeatedly, it can be supplied on each call to <literal>getValue</literal>, , +    as this next example shows:</para>, +    , +    <programlisting language="java">/ Create and set a calendar , +GregorianCalendar c = new GregorianCalendar();, +c.set(1856, 7, 9);, +, +//  The constructor arguments are name, birthday, and nationality., +Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");, +, +ExpressionParser parser = new SpelExpressionParser();, +Expression exp = parser.parseExpression("<emphasis role="bold">name</emphasis>");, +, +String name = (String) exp.getValue(tesla);, +    </programlisting><para>In this case the inventor <literal>tesla</literal> has been, +    supplied directly to <literal>getValue</literal> and the expression, +    evaluation infrastructure creates and manages a default evaluation context , +    internally - it did not require one to be supplied.</para>, +    , +    <para>The StandardEvaluationContext is relatively expensive to construct and, +    during repeated usage it builds up cached state that enables subsequent, +    expression evaluations to be performed more quickly.  For this reason it is, +    better to cache and reuse them where possible, rather than construct a new , +    one for each expression evaluation., +    </para>, +    <para>In some cases it can be desirable to use a configured evaluation context and, +    yet still supply a different root object on each call to <literal>getValue</literal>., +    <literal>getValue</literal> allows both to be specified on the same call., +    In these situations the root object passed on the call is considered to override, +    any (which maybe null) specified on the evaluation context.</para>, +        <para>In standalone usage of SpEL there is a need to create the parser,, +        parse expressions and perhaps provide evaluation contexts and a root, +        context object. However, more common usage, +        and any predefined variables are all set up implicitly, requiring, +        the user to specify nothing other than the expressions.</para>, +      may specify the root object to evaluate against via the method]