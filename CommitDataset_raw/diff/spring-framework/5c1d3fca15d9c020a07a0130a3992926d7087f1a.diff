[+++ b/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java, + * Copyright 2002-2016 the original author or authors., +, +	Object wrappedObject;, +			this.wrappedObject = OptionalUnwrapper.unwrap(object);, +			this.wrappedObject = object;, +		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : this.wrappedObject);, +		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);, +		return this.wrappedObject;, +		return (this.wrappedObject != null ? this.wrappedObject.getClass() : null);, +				ph.setValue(this.wrappedObject, valueToApply);, +			tokens.canonicalName += PROPERTY_KEY_PREFIX +, +		if (this.wrappedObject != null) {, +			sb.append(": wrapping object [").append(ObjectUtils.identityToString(this.wrappedObject)).append("]");, +++ b/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java, + * Copyright 2002-2016 the original author or authors., +, +	Object wrappedObject;, +			this.wrappedObject = OptionalUnwrapper.unwrap(object);, +			this.wrappedObject = object;, +		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : this.wrappedObject);, +		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);, +		return this.wrappedObject;, +		return (this.wrappedObject != null ? this.wrappedObject.getClass() : null);, +				ph.setValue(this.wrappedObject, valueToApply);, +			tokens.canonicalName += PROPERTY_KEY_PREFIX +, +		if (this.wrappedObject != null) {, +			sb.append(": wrapping object [").append(ObjectUtils.identityToString(this.wrappedObject)).append("]");, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, + * Copyright 2002-2016 the original author or authors., +	/**, +	 * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}., +	 * @param object the actual target object, +	 * @since 4.3, +	 * @see #setWrappedInstance(Object), +	 */, +	public void setBeanInstance(Object object) {, +		this.wrappedObject = object;, +		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);, +		setIntrospectionClass(object.getClass());, +	}, +, +		setIntrospectionClass(getWrappedClass());, +	}, +, +	/**, +	 * Set the class to introspect., +	 * Needs to be called when the target object changes., +	 * @param clazz the class to introspect, +	 */, +	protected void setIntrospectionClass(Class<?> clazz) {, +		if (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {, +			this.cachedIntrospectionResults = null;, +		}, +	}, +, +	/**, +	 * Obtain a lazily initializted CachedIntrospectionResults instance, +	 * for the wrapped object., +	 */, +	private CachedIntrospectionResults getCachedIntrospectionResults() {, +		Assert.state(getWrappedInstance() != null, "BeanWrapper does not hold a bean instance");, +		if (this.cachedIntrospectionResults == null) {, +			this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());, +		}, +		return this.cachedIntrospectionResults;, +++ b/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java, + * Copyright 2002-2016 the original author or authors., +, +	Object wrappedObject;, +			this.wrappedObject = OptionalUnwrapper.unwrap(object);, +			this.wrappedObject = object;, +		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : this.wrappedObject);, +		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);, +		return this.wrappedObject;, +		return (this.wrappedObject != null ? this.wrappedObject.getClass() : null);, +				ph.setValue(this.wrappedObject, valueToApply);, +			tokens.canonicalName += PROPERTY_KEY_PREFIX +, +		if (this.wrappedObject != null) {, +			sb.append(": wrapping object [").append(ObjectUtils.identityToString(this.wrappedObject)).append("]");, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, + * Copyright 2002-2016 the original author or authors., +	/**, +	 * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}., +	 * @param object the actual target object, +	 * @since 4.3, +	 * @see #setWrappedInstance(Object), +	 */, +	public void setBeanInstance(Object object) {, +		this.wrappedObject = object;, +		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);, +		setIntrospectionClass(object.getClass());, +	}, +, +		setIntrospectionClass(getWrappedClass());, +	}, +, +	/**, +	 * Set the class to introspect., +	 * Needs to be called when the target object changes.]