[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/MvcUriComponentsBuilder.java, +	 * Create a {@link UriComponentsBuilder} from the mapping of a controller class, +	 * and current request information including Servlet mapping. If the controller, +	 * contains multiple mappings, only the first one is used., +	 *, +	 * @param controllerType the controller to build a URI for, +	 * @return a UriComponentsBuilder instance, never {@code null}, +	private static String getTypeRequestMapping(Class<?> controllerType) {, +		Assert.notNull(controllerType, "'controllerType' must not be null");, +		RequestMapping annot = AnnotationUtils.findAnnotation(controllerType, RequestMapping.class);, +		if ((annot == null) || ObjectUtils.isEmpty(annot.value()) || StringUtils.isEmpty(annot.value()[0])) {, +			return "/";, +		}, +		if (annot.value().length > 1) {, +			if (logger.isWarnEnabled()) {, +				logger.warn("Multiple paths on controller " + controllerType.getName() + ", using first one");, +			}, +		}, +		return annot.value()[0];, +	}, +, +	 * Create a {@link UriComponentsBuilder} from the mapping of a controller method, +	 * and an array of method argument values. This method delegates to, +	 * {@link #fromMethod(java.lang.reflect.Method, Object...)}., +	 *, +	 * @param controllerType the controller, +	 * @param methodName the method name, +	 * @param argumentValues the argument values, +	 * @return a UriComponentsBuilder instance, never {@code null}, +	 *, +	 * @throws java.lang.IllegalStateException if there is no matching or more than, +	 * 	one matching method., +		Method method = getMethod(controllerType, methodName, argumentValues);, +		return fromMethod(method, argumentValues);, +	}, +, +	private static Method getMethod(Class<?> controllerType, String methodName, Object[] argumentValues) {, +		return match;, +	 * Create a {@link UriComponentsBuilder} by invoking a "mock" controller method., +	 * The controller method and the supplied argument values are then used to, +	 * delegate to {@link #fromMethod(java.lang.reflect.Method, Object...)}., +	 * <p>, +	 * For example given this controller:, +	 * A UriComponentsBuilder can be created:, +	 * // Inline style with static import of "MvcUriComponentsBuilder.on", +	 * 		on(CustomerController.class).showAddresses("US")).buildAndExpand(1);, +	 * // Longer form useful for repeated invocation (and void controller methods), +	 * CustomerController controller = MvcUriComponentsBuilder.on(CustomController.class);, +	 * builder = MvcUriComponentsBuilder.fromMethodCall(controller);, +	 * controller.getAddressesForCountry("US"), +	 * builder = MvcUriComponentsBuilder.fromMethodCall(controller);, +	 *, +	 * @param invocationInfo either the value returned from a "mock" controller, +	public static UriComponentsBuilder fromMethodCall(Object invocationInfo) {, +		Assert.isInstanceOf(MethodInvocationInfo.class, invocationInfo);, +		MethodInvocationInfo info = (MethodInvocationInfo) invocationInfo;, +		return fromMethod(info.getControllerMethod(), info.getArgumentValues());, +	}, +	/**, +	 * Create a {@link UriComponentsBuilder} from the mapping of a controller method, +	 * and an array of method argument values. The array of values  must match the, +	 * signature of the controller method. Values for {@code @RequestParam} and, +	 * {@code @PathVariable} are used for building the URI (via implementations of, +	 * {@link org.springframework.web.method.support.UriComponentsContributor}), +	 * while remaining argument values are ignored and can be {@code null}., +	 *, +	 * @param method the controller method, +	 * @param argumentValues argument values for the controller method, +	 * @return a UriComponentsBuilder instance, never {@code null}, +	 */, +	public static UriComponentsBuilder fromMethod(Method method, Object... argumentValues) {, +		String typePath = getTypeRequestMapping(method.getDeclaringClass());, +		String methodPath = uriComponents.getPath();, +		String path = pathMatcher.combine(typePath, methodPath);, +		return ServletUriComponentsBuilder.fromCurrentServletMapping().path(path), +				.queryParams(uriComponents.getQueryParams());, +			if (logger.isWarnEnabled()) {, +				logger.warn("Multiple paths on method " + method.toGenericString() + ", using first one");, +			}, +, +, +		String attributeName = DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE;, +		WebApplicationContext wac = (WebApplicationContext) request.getAttribute(attributeName);, +, +			return wac.getBean(MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME, CompositeUriComponentsContributor.class);, +	 * and the result can then be used to create a {@code UriComponentsBuilder}, +	 * via {@link #fromMethodCall(Object)}., +	 * <p>, +	 * Note that this is a shorthand version of {@link #controller(Class)} intended, +	 * for inline use (with a static import), for example:, +	 * MvcUriComponentsBuilder.fromMethodCall(on(FooController.class).getFoo(1)).build();, +	 * and the result can then be used to create {@code UriComponentsBuilder} via, +	 * <p>, +	 * This is a longer version of {@link #on(Class)}. It is needed with controller, +	 * methods returning void as well for repeated invocations., +, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/MvcUriComponentsBuilder.java, +	 * Create a {@link UriComponentsBuilder} from the mapping of a controller class, +	 * and current request information including Servlet mapping. If the controller, +	 * contains multiple mappings, only the first one is used.]