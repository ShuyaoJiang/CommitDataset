[+++ b/org.springframework.aspects/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-1.0.0.jar" sourcepath="/IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-sources-1.0.0.jar"/>, +++ b/org.springframework.aspects/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-1.0.0.jar" sourcepath="/IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-sources-1.0.0.jar"/>, +++ b/org.springframework.aspects/ivy.xml, +		<dependency org="javax.persistence" name="com.springsource.javax.persistence" rev="1.0.0" conf="provided, compile->compile"/>, +	, +++ b/org.springframework.aspects/.classpath, +	<classpathentry kind="var" path="IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-1.0.0.jar" sourcepath="/IVY_CACHE/javax.persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-sources-1.0.0.jar"/>, +++ b/org.springframework.aspects/ivy.xml, +		<dependency org="javax.persistence" name="com.springsource.javax.persistence" rev="1.0.0" conf="provided, compile->compile"/>, +	, +++ b/org.springframework.aspects/src/main/java/org/springframework/mock/static_mock/AbstractMethodMockingControl.aj, +package org.springframework.mock.static_mock;, +, +import java.util.Arrays;, +import java.util.LinkedList;, +import java.util.List;, +, +/**, + * Abstract aspect to enable mocking of methods picked out by a pointcut., + * Sub-aspects must define the mockStaticsTestMethod() pointcut to, + * indicate call stacks when mocking should be triggered, and the , + * methodToMock() pointcut to pick out a method invocations to mock., + * , + * @author Rod Johnson, + * @author Ramnivas Laddad, + *, + */, +public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMethod()) {, +, +	protected abstract pointcut mockStaticsTestMethod();, +, +	protected abstract pointcut methodToMock();, +, +	private boolean recording = true;, +, +	static enum CallResponse { nothing, return_, throw_ };, +, +	// Represents a list of expected calls to static entity methods, +	// Public to allow inserted code to access: is this normal??, +	public class Expectations {, +		, +		// Represents an expected call to a static entity method, +		private class Call {, +			private final String signature;, +			private final Object[] args;, +, +			private Object responseObject; // return value or throwable, +			private CallResponse responseType = CallResponse.nothing;, +			, +			public Call(String name, Object[] args) {, +				this.signature = name;, +				this.args = args;, +			}, +			, +			public boolean hasResponseSpecified() {, +				return responseType != CallResponse.nothing;, +			}, +			, +			public void setReturnVal(Object retVal) {, +				this.responseObject = retVal;, +				responseType = CallResponse.return_;, +			}, +			, +			public void setThrow(Throwable throwable) {, +				this.responseObject = throwable;, +				responseType = CallResponse.throw_;, +			}, +, +			public Object returnValue(String lastSig, Object[] args) {, +				checkSignature(lastSig, args);, +				return responseObject;, +			}, +, +			public Object throwException(String lastSig, Object[] args) {, +				checkSignature(lastSig, args);, +				throw (RuntimeException)responseObject;, +			}, +, +			private void checkSignature(String lastSig, Object[] args) {, +				if (!signature.equals(lastSig)) {, +					throw new IllegalArgumentException("Signature doesn't match");, +				}, +				if (!Arrays.equals(this.args, args)) {, +					throw new IllegalArgumentException("Arguments don't match");, +				}, +			}, +		}, +		, +		private List<Call> calls = new LinkedList<Call>();, +, +		// Calls already verified, +		private int verified;, +, +		public void verify() {, +			if (verified != calls.size()) {, +				throw new IllegalStateException("Expected " + calls.size(), +						+ " calls, received " + verified);, +			}]