[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, +							if (i == candidates.length - 1 && argsHolderToUse == null) {, +			if (explicitArgs == null && argsHolderToUse != null) {, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, +							if (i == candidates.length - 1 && argsHolderToUse == null) {, +			if (explicitArgs == null && argsHolderToUse != null) {, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2010 the original author or authors., +		// An @Bean method may only be overloaded through inheritance. No single, +		}, +, +, +	/**, +	 * Configuration classes must be non-final to accommodate CGLIB subclassing., +	 */, +, +	/**, +	 * Bean methods on configuration classes may only be overloaded through inheritance., +	 */, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, +							if (i == candidates.length - 1 && argsHolderToUse == null) {, +			if (explicitArgs == null && argsHolderToUse != null) {, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2010 the original author or authors., +		// An @Bean method may only be overloaded through inheritance. No single, +		}, +, +, +	/**, +	 * Configuration classes must be non-final to accommodate CGLIB subclassing., +	 */, +, +	/**, +	 * Bean methods on configuration classes may only be overloaded through inheritance., +	 */, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassMethod.java, + * Copyright 2002-2010 the original author or authors., +		return new Location(this.configurationClass.getResource(), this.metadata);, +		if (this.configurationClass.getMetadata().isAnnotated(Configuration.class.getName())) {, +			if (!getMetadata().isOverridable()) {, +		else {, +			if (getMetadata().isStatic()) {, +				problemReporter.error(new StaticMethodError());, +			}, +		}, +	}, +		return String.format("[%s:name=%s,declaringClass=%s]",, +	/**, +	 * {@link Bean} methods must at least not be static in the non-CGLIB case., +	 */, +	private class StaticMethodError extends Problem {, +, +		public StaticMethodError() {, +			super(String.format("Method '%s' must not be static; remove the method's static modifier to continue",, +					getMetadata().getMethodName()), getResourceLocation());, +		}, +	}, +]