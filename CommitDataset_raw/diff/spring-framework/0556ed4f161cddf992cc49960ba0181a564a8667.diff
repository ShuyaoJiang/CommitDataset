[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodArgumentResolver.java, +, +	private final RequestResponseBodyAdviceChain advice;, +, +	/**, +	 * Basic constructor with converters only., +	 */, +	public AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters) {, +		this(converters, null);, +	}, +, +	/**, +	 * Constructor with converters and {@code Request~} and {@code ResponseBodyAdvice}., +	 * @since 4.2, +	 */, +	public AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters,, +			List<Object> requestResponseBodyAdvice) {, +, +		Assert.notEmpty(converters, "'messageConverters' must not be empty");, +		this.messageConverters = converters;, +		this.allSupportedMediaTypes = getAllSupportedMediaTypes(converters);, +		this.advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);, +	 * Return the configured {@link RequestBodyAdvice} and, +	 * {@link RequestBodyAdvice} where each instance may be wrapped as a, +	 * {@link org.springframework.web.method.ControllerAdviceBean ControllerAdviceBean}., +	 */, +	protected RequestResponseBodyAdviceChain getAdvice() {, +		return this.advice;, +	}, +, +	/**, +	 * @param param the method parameter descriptor (may be {@code null}), +			MethodParameter param, Type targetType) throws IOException, HttpMediaTypeNotSupportedException {, +		Class<?> contextClass = (param != null ? param.getContainingClass() : null);, +			ResolvableType resolvableType = (param != null ?, +					ResolvableType.forMethodParameter(param) : ResolvableType.forType(targetType));, +			Class<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();, +						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");, +					inputMessage = getAdvice().beforeBodyRead(inputMessage, param, targetType, converterType);, +					T body = (T) genericConverter.read(targetType, contextClass, inputMessage);, +					return getAdvice().afterBodyRead(body, inputMessage, param, targetType, converterType);, +						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");, +					inputMessage = getAdvice().beforeBodyRead(inputMessage, param, targetType, converterType);, +					T body = ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);, +					return getAdvice().afterBodyRead(body, inputMessage, param, targetType, converterType);, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodArgumentResolver.java, +, +	private final RequestResponseBodyAdviceChain advice;, +, +	/**, +	 * Basic constructor with converters only., +	 */, +	public AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters) {, +		this(converters, null);, +	}, +, +	/**, +	 * Constructor with converters and {@code Request~} and {@code ResponseBodyAdvice}., +	 * @since 4.2, +	 */, +	public AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters,, +			List<Object> requestResponseBodyAdvice) {, +, +		Assert.notEmpty(converters, "'messageConverters' must not be empty");, +		this.messageConverters = converters;, +		this.allSupportedMediaTypes = getAllSupportedMediaTypes(converters);, +		this.advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);, +	 * Return the configured {@link RequestBodyAdvice} and, +	 * {@link RequestBodyAdvice} where each instance may be wrapped as a, +	 * {@link org.springframework.web.method.ControllerAdviceBean ControllerAdviceBean}., +	 */, +	protected RequestResponseBodyAdviceChain getAdvice() {, +		return this.advice;, +	}, +, +	/**, +	 * @param param the method parameter descriptor (may be {@code null}), +			MethodParameter param, Type targetType) throws IOException, HttpMediaTypeNotSupportedException {, +		Class<?> contextClass = (param != null ? param.getContainingClass() : null);, +			ResolvableType resolvableType = (param != null ?, +					ResolvableType.forMethodParameter(param) : ResolvableType.forType(targetType));, +			Class<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();, +						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");, +					inputMessage = getAdvice().beforeBodyRead(inputMessage, param, targetType, converterType);, +					T body = (T) genericConverter.read(targetType, contextClass, inputMessage);, +					return getAdvice().afterBodyRead(body, inputMessage, param, targetType, converterType);, +						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");, +					inputMessage = getAdvice().beforeBodyRead(inputMessage, param, targetType, converterType);, +					T body = ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);, +					return getAdvice().afterBodyRead(body, inputMessage, param, targetType, converterType);, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java, + * Copyright 2002-2015 the original author or authors., +, +	protected AbstractMessageConverterMethodProcessor(List<HttpMessageConverter<?>> converters) {, +		this(converters, null);, +	protected AbstractMessageConverterMethodProcessor(List<HttpMessageConverter<?>> converters,, +			ContentNegotiationManager contentNegotiationManager) {, +, +		this(converters, contentNegotiationManager, null);, +	protected AbstractMessageConverterMethodProcessor(List<HttpMessageConverter<?>> converters,]