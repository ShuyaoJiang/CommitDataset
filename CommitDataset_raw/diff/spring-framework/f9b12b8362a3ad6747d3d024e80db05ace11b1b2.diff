[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +import java.util.Collections;, +	private volatile CachedMethodExecutor cachedExecutor;, +		List<TypeDescriptor> argumentTypes = getTypes(arguments);, +						FormatHelper.formatMethodForMessage(this.name, argumentTypes));, +		MethodExecutor executorToUse = getCachedExecutor(argumentTypes);, +		executorToUse = findAccessorForMethod(this.name, argumentTypes, state);, +		this.cachedExecutor = new CachedMethodExecutor(executorToUse, argumentTypes);, +		return Collections.unmodifiableList(descriptors);, +	private MethodExecutor getCachedExecutor(List<TypeDescriptor> argumentTypes) {, +		if (this.cachedExecutor == null || !this.cachedExecutor.isSuitable(argumentTypes)) {, +			this.cachedExecutor = null;, +			return null;, +		}, +		return this.cachedExecutor.get();, +	}, +, +		private List<TypeDescriptor> argumentTypes;, +, +			this.argumentTypes = getTypes(this.arguments);, +			MethodExecutor executorToUse = getCachedExecutor(this.argumentTypes);, +			executorToUse = findAccessorForMethod(MethodReference.this.name, argumentTypes, this.target, this.evaluationContext);, +			MethodReference.this.cachedExecutor = new CachedMethodExecutor(executorToUse, this.argumentTypes);, +, +	private static class CachedMethodExecutor {, +, +		private final MethodExecutor methodExecutor;, +, +		private final List<TypeDescriptor> argumentTypes;, +, +, +		public CachedMethodExecutor(MethodExecutor methodExecutor,, +				List<TypeDescriptor> argumentTypes) {, +			this.methodExecutor = methodExecutor;, +			this.argumentTypes = argumentTypes;, +		}, +, +, +		public boolean isSuitable(List<TypeDescriptor> argumentTypes) {, +			return (this.methodExecutor != null && this.argumentTypes.equals(argumentTypes));, +		}, +, +		public MethodExecutor get() {, +			return this.methodExecutor;, +		}, +	}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +import java.util.Collections;, +	private volatile CachedMethodExecutor cachedExecutor;, +		List<TypeDescriptor> argumentTypes = getTypes(arguments);, +						FormatHelper.formatMethodForMessage(this.name, argumentTypes));, +		MethodExecutor executorToUse = getCachedExecutor(argumentTypes);, +		executorToUse = findAccessorForMethod(this.name, argumentTypes, state);, +		this.cachedExecutor = new CachedMethodExecutor(executorToUse, argumentTypes);, +		return Collections.unmodifiableList(descriptors);, +	private MethodExecutor getCachedExecutor(List<TypeDescriptor> argumentTypes) {, +		if (this.cachedExecutor == null || !this.cachedExecutor.isSuitable(argumentTypes)) {, +			this.cachedExecutor = null;, +			return null;, +		}, +		return this.cachedExecutor.get();, +	}, +, +		private List<TypeDescriptor> argumentTypes;, +, +			this.argumentTypes = getTypes(this.arguments);, +			MethodExecutor executorToUse = getCachedExecutor(this.argumentTypes);, +			executorToUse = findAccessorForMethod(MethodReference.this.name, argumentTypes, this.target, this.evaluationContext);, +			MethodReference.this.cachedExecutor = new CachedMethodExecutor(executorToUse, this.argumentTypes);, +, +	private static class CachedMethodExecutor {, +, +		private final MethodExecutor methodExecutor;, +, +		private final List<TypeDescriptor> argumentTypes;, +, +, +		public CachedMethodExecutor(MethodExecutor methodExecutor,, +				List<TypeDescriptor> argumentTypes) {, +			this.methodExecutor = methodExecutor;, +			this.argumentTypes = argumentTypes;, +		}, +, +, +		public boolean isSuitable(List<TypeDescriptor> argumentTypes) {, +			return (this.methodExecutor != null && this.argumentTypes.equals(argumentTypes));, +		}, +, +		public MethodExecutor get() {, +			return this.methodExecutor;, +		}, +	}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/CachedMethodExecutorTests.java, +/*, + * Copyright 2002-2012 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *]