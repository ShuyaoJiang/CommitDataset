[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2014 the original author or authors., +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, + * <p>When the return type is {@code java.util.concurrent.Future}, any exception thrown, + * during the execution can be accessed and managed by the caller. With {@code void}, + * return type however, such exceptions cannot be transmitted back. In that case an, + * {@link AsyncUncaughtExceptionHandler} can be registered to process such exceptions., + *, + * @author Stephane Nicoll, +	private final Log logger = LogFactory.getLog(getClass());, +, +	private AsyncUncaughtExceptionHandler exceptionHandler;, +, +	 * @param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}, +	 * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use, +	public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {, +		super(defaultExecutor);, +		this.exceptionHandler = exceptionHandler;, +	/**, +	 * Create a new instance with a default {@link AsyncUncaughtExceptionHandler}., +	 */, +	public AsyncExecutionInterceptor(Executor defaultExecutor) {, +		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler());, +	}, +, +	/**, +	 * Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions, +	 * thrown by invoking asynchronous methods with a {@code void} return type., +	 */, +	public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {, +		this.exceptionHandler = exceptionHandler;, +	}, +		Method tmp = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		final Method specificMethod = BridgeMethodResolver.findBridgedMethod(tmp);, +							handleError(ex, specificMethod, invocation.getArguments());, +	 * Handles a fatal error thrown while asynchronously invoking the specified, +	 * {@link Method}., +	 * <p>If the return type of the method is a {@link Future} object, the original, +	 * exception can be propagated by just throwing it at the higher level. However,, +	 * for all other cases, the exception will not be transmitted back to the client., +	 * In that later case, the current {@link AsyncUncaughtExceptionHandler} will be, +	 * used to manage such exception., +	 *, +	 * @param ex the exception to handle, +	 * @param method the method that was invoked, +	 * @param params the parameters used to invoke the method, +	 */, +	protected void handleError(Throwable ex, Method method, Object... params) throws Exception {, +		if (method.getReturnType().isAssignableFrom(Future.class)) {, +			ReflectionUtils.rethrowException(ex);, +		}, +		else { // Could not transmit the exception to the caller with default executor, +			try {, +				exceptionHandler.handleUncaughtException(ex, method, params);, +			}, +			catch (Exception e) {, +				logger.error("exception handler has thrown an unexpected " +, +						"exception while invoking '" + method.toGenericString() + "'", e);, +			}, +		}, +	}, +, +	/**, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2014 the original author or authors., +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, + * <p>When the return type is {@code java.util.concurrent.Future}, any exception thrown, + * during the execution can be accessed and managed by the caller. With {@code void}, + * return type however, such exceptions cannot be transmitted back. In that case an, + * {@link AsyncUncaughtExceptionHandler} can be registered to process such exceptions., + *, + * @author Stephane Nicoll, +	private final Log logger = LogFactory.getLog(getClass());, +, +	private AsyncUncaughtExceptionHandler exceptionHandler;, +, +	 * @param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}, +	 * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use, +	public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {, +		super(defaultExecutor);, +		this.exceptionHandler = exceptionHandler;, +	/**, +	 * Create a new instance with a default {@link AsyncUncaughtExceptionHandler}., +	 */, +	public AsyncExecutionInterceptor(Executor defaultExecutor) {, +		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler());, +	}, +, +	/**, +	 * Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions, +	 * thrown by invoking asynchronous methods with a {@code void} return type., +	 */, +	public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {, +		this.exceptionHandler = exceptionHandler;, +	}, +		Method tmp = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		final Method specificMethod = BridgeMethodResolver.findBridgedMethod(tmp);, +							handleError(ex, specificMethod, invocation.getArguments());]