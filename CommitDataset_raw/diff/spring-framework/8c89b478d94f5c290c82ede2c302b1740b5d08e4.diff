[+++ b/spring-web-reactive/src/main/java/org/springframework/http/server/reactive/WriteWithOperator.java, +/*, + * Copyright 2002-2015 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package org.springframework.http.server.reactive;, +, +import org.reactivestreams.Publisher;, +import org.reactivestreams.Subscriber;, +import org.reactivestreams.Subscription;, +import reactor.core.subscriber.SubscriberBarrier;, +import reactor.core.support.Assert;, +import reactor.fn.Function;, +, +, +/**, + * Given a write function that accepts a source {@code Publisher<T>} to write, + * with and returns {@code Publisher<Void>} for the result, this operator helps, + * to defer the invocation of the write function, until we know if the source, + * publisher will begin publishing without an error. If the first emission is, + * an error, the write function is bypassed, and the error is sent directly, + * through the result publisher. Otherwise the write function is invoked., + *, + * @author Rossen Stoyanchev, + */, +public class WriteWithOperator<T> implements Function<Subscriber<? super Void>, Subscriber<? super T>> {, +, +	private final java.util.function.Function<Publisher<T>, Publisher<Void>> writeFunction;, +, +, +	public WriteWithOperator(java.util.function.Function<Publisher<T>, Publisher<Void>> writeFunction) {, +		this.writeFunction = writeFunction;, +	}, +, +	@Override, +	public Subscriber<? super T> apply(Subscriber<? super Void> subscriber) {, +		return new WriteWithBarrier(subscriber);, +	}, +, +, +	private class WriteWithBarrier extends SubscriberBarrier<T, Void> implements Publisher<T> {, +, +		/**, +		 * We've at at least one emission, we've called the write function, the write, +		 * subscriber has subscribed and cached signals have been emitted to it., +		 * We're now simply passing data through to the write subscriber., +		 **/, +		private boolean readyToWrite = false;, +, +		/** No emission from upstream yet */, +		private boolean beforeFirstEmission = true;, +, +		/** Cached signal before readyToWrite */, +		private T item;, +, +		/** Cached 1st/2nd signal before readyToWrite */, +		private Throwable error;, +, +		/** Cached 1st/2nd signal before readyToWrite */, +		private boolean completed = false;, +, +		/** The actual writeSubscriber vs the downstream completion subscriber */, +		private Subscriber<? super T> writeSubscriber;, +, +, +		public WriteWithBarrier(Subscriber<? super Void> subscriber) {, +			super(subscriber);, +		}, +, +, +		@Override, +		protected void doOnSubscribe(Subscription subscription) {, +			super.doOnSubscribe(subscription);, +			((Subscription) super.upstream()).request(1); // bypass doRequest, +		}, +, +		@Override, +		public void doNext(T item) {, +			if (this.readyToWrite) {, +				this.writeSubscriber.onNext(item);, +				return;, +			}, +			synchronized (this) {, +				if (this.readyToWrite) {, +					this.writeSubscriber.onNext(item);, +				}, +				else if (this.beforeFirstEmission) {, +					this.item = item;, +					this.beforeFirstEmission = false;]