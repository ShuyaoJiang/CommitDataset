[+++ b/spring-core/src/main/java/org/springframework/core/MethodIntrospector.java, +/*, + * Copyright 2002-2015 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.core;, +, +import java.lang.reflect.Method;, +import java.lang.reflect.Proxy;, +import java.util.Arrays;, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.Map;, +import java.util.Set;, +, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ReflectionUtils;, +, +/**, + * Defines the algorithm for searching for metadata-associated methods exhaustively, + * including interfaces and parent classes while also dealing with parameterized methods, + * as well as common scenarios encountered with interface and class-based proxies., + *, + * <p>Typically, but not necessarily, used for finding annotated handler methods., + *, + * @author Juergen Hoeller, + * @author Rossen Stoyanchev, + * @since 4.2.3, + */, +public abstract class MethodIntrospector {, +, +	/**, +	 * Select methods on the given target type based on the lookup of associated metadata., +	 * <p>Callers define methods of interest through the {@link MetadataLookup} parameter,, +	 * allowing to collect the associated metadata into the result map., +	 * @param targetType the target type to search methods on, +	 * @param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,, +	 * returning non-null metadata to be associated with a given method if there is a match,, +	 * or {@code null} for no match, +	 * @return the selected methods associated with their metadata (in the order of retrieval),, +	 * or an empty map in case of no match, +	 */, +	public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {, +		final Map<Method, T> methodMap = new LinkedHashMap<Method, T>();, +		Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>();, +		Class<?> specificHandlerType = null;, +, +		if (!Proxy.isProxyClass(targetType)) {, +			handlerTypes.add(targetType);, +			specificHandlerType = targetType;, +		}, +		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()));, +, +		for (Class<?> currentHandlerType : handlerTypes) {, +			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);, +, +			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {, +				@Override, +				public void doWith(Method method) {, +					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);, +					T result = metadataLookup.inspect(specificMethod);, +					if (result != null) {, +						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);, +						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {, +							methodMap.put(specificMethod, result);, +						}, +					}, +				}, +			}, ReflectionUtils.USER_DECLARED_METHODS);, +		}, +, +		return methodMap;, +	}, +, +	/**, +	 * Select methods on the given target type based on a filter., +	 * <p>Callers define methods of interest through the, +	 * {@link ReflectionUtils.MethodFilter} parameter., +	 * @param targetType the target type to search methods on, +	 * @param methodFilter a {@link ReflectionUtils.MethodFilter} to help, +	 * recognize handler methods of interest, +	 * @return the selected methods, or an empty set in case of no match, +	 */, +	public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {, +		return selectMethods(targetType, new MetadataLookup<Boolean>() {, +			@Override, +			public Boolean inspect(Method method) {, +				return (methodFilter.matches(method) ? Boolean.TRUE : null);]