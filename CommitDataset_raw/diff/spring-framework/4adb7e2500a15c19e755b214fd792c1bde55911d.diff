[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.java, +import java.io.IOException;, +import java.io.ObjectInputStream;, +import java.io.Serializable;, +@SuppressWarnings("serial"), +public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable {, +	private final Class<?> declaringClass;, +	private final String methodName;, +, +	private final Class<?>[] parameterTypes;, +, +	protected transient Method aspectJAdviceMethod;, +	private Map<String, Integer> argumentBindings;, +		this.declaringClass = aspectJAdviceMethod.getDeclaringClass();, +		this.methodName = aspectJAdviceMethod.getName();, +		this.parameterTypes = aspectJAdviceMethod.getParameterTypes();, +		if (this.argumentNames != null) {, +			if (this.aspectJAdviceMethod.getParameterTypes().length == this.argumentNames.length + 1) {, +				Class<?> firstArgType = this.aspectJAdviceMethod.getParameterTypes()[0];, +					String[] oldNames = this.argumentNames;, +					this.argumentNames = new String[oldNames.length + 1];, +					this.argumentNames[0] = "THIS_JOIN_POINT";, +					System.arraycopy(oldNames, 0, this.argumentNames, 1, oldNames.length);, +		if (this.argumentsIntrospected || this.parameterTypes.length == 0) {, +		int numUnboundArgs = this.parameterTypes.length;, +			throw new IllegalStateException("Expecting to find " + numExpectedArgumentNames +, +					" arguments to bind by name in advice, but actually found " +, +		int argumentIndexOffset = this.parameterTypes.length - numArgumentsLeftToBind;, +				throw new IllegalStateException("Returning argument name '" + this.returningName +, +						"' was not bound in advice arguments");, +				throw new IllegalStateException("Throwing argument name '" + this.throwingName +, +						"' was not bound in advice arguments");, +		Object[] adviceInvocationArgs = new Object[this.parameterTypes.length];, +		if (numBound != this.parameterTypes.length) {, +			throw new IllegalStateException("Required to bind " + this.parameterTypes.length +, +					" arguments, but only bound " + numBound + " (JoinPointMatch " +, +					(jpMatch == null ? "was NOT" : "WAS") + " bound in invocation)");, +	private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {, +		inputStream.defaultReadObject();, +		try {, +			this.aspectJAdviceMethod = this.declaringClass.getMethod(this.methodName, this.parameterTypes);, +		}, +		catch (NoSuchMethodException ex) {, +			throw new IllegalStateException("Failed to find advice method on deserialization", ex);, +		}, +	}, +, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.java, +import java.io.IOException;, +import java.io.ObjectInputStream;, +import java.io.Serializable;, +@SuppressWarnings("serial"), +public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable {, +	private final Class<?> declaringClass;, +	private final String methodName;, +, +	private final Class<?>[] parameterTypes;, +, +	protected transient Method aspectJAdviceMethod;, +	private Map<String, Integer> argumentBindings;, +		this.declaringClass = aspectJAdviceMethod.getDeclaringClass();, +		this.methodName = aspectJAdviceMethod.getName();, +		this.parameterTypes = aspectJAdviceMethod.getParameterTypes();, +		if (this.argumentNames != null) {, +			if (this.aspectJAdviceMethod.getParameterTypes().length == this.argumentNames.length + 1) {, +				Class<?> firstArgType = this.aspectJAdviceMethod.getParameterTypes()[0];, +					String[] oldNames = this.argumentNames;, +					this.argumentNames = new String[oldNames.length + 1];, +					this.argumentNames[0] = "THIS_JOIN_POINT";, +					System.arraycopy(oldNames, 0, this.argumentNames, 1, oldNames.length);, +		if (this.argumentsIntrospected || this.parameterTypes.length == 0) {, +		int numUnboundArgs = this.parameterTypes.length;, +			throw new IllegalStateException("Expecting to find " + numExpectedArgumentNames +, +					" arguments to bind by name in advice, but actually found " +, +		int argumentIndexOffset = this.parameterTypes.length - numArgumentsLeftToBind;, +				throw new IllegalStateException("Returning argument name '" + this.returningName +, +						"' was not bound in advice arguments");, +				throw new IllegalStateException("Throwing argument name '" + this.throwingName +, +						"' was not bound in advice arguments");, +		Object[] adviceInvocationArgs = new Object[this.parameterTypes.length];, +		if (numBound != this.parameterTypes.length) {, +			throw new IllegalStateException("Required to bind " + this.parameterTypes.length +, +					" arguments, but only bound " + numBound + " (JoinPointMatch " +, +					(jpMatch == null ? "was NOT" : "WAS") + " bound in invocation)");, +	private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {, +		inputStream.defaultReadObject();, +		try {, +			this.aspectJAdviceMethod = this.declaringClass.getMethod(this.methodName, this.parameterTypes);, +		}, +		catch (NoSuchMethodException ex) {, +			throw new IllegalStateException("Failed to find advice method on deserialization", ex);, +		}, +	}, +, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterAdvice.java, + * Copyright 2002-2015 the original author or authors., +import java.io.Serializable;, +@SuppressWarnings("serial"), +public class AspectJAfterAdvice extends AbstractAspectJAdvice, +		implements MethodInterceptor, AfterAdvice, Serializable {]