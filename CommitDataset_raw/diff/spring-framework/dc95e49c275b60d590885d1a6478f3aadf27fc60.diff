[+++ b/spring-framework-reference/src/testing.xml, +          production <interfacename>ApplicationContext</interfacename> will be, +          the notion of environments and profiles (a.k.a., <emphasis>bean, +          definition profiles</emphasis>), and integration tests can now be, +          configured to activate particular bean definition profiles for, +          various testing scenarios. This is achieved by annotating a test, +          class with the new <interfacename>@ActiveProfiles</interfacename>, +          annotation and supplying a list of profiles that should be activated, +          when loading the <interfacename>ApplicationContext</interfacename>, +          for the test.</para>, +            <para><interfacename>@ActiveProfiles</interfacename> may be used, +            with any implementation of the new, +            <interfacename>SmartContextLoader</interfacename> SPI, but, +            <interfacename>@ActiveProfiles</interfacename> is not supported, +            with implementations of the older, +            <interfacename>ContextLoader</interfacename> SPI.</para>, +          <interfacename>@Configuration</interfacename> classes.</para>, +          <para>When <classname>TransferServiceTest</classname> is run, its, +          <interfacename>ApplicationContext</interfacename> will be loaded, +          from the <filename>app-config.xml</filename> configuration file in, +          the root of the classpath. If you inspect, +          <filename>app-config.xml</filename> you'll notice that the, +          <varname>accountRepository</varname> bean has a dependency on a, +          <varname>dataSource</varname> bean; however,, +          <varname>dataSource</varname> is not defined as a top-level bean., +          Instead, <varname>dataSource</varname> is defined twice: once in the, +          <emphasis>production</emphasis> profile and once in the, +          <emphasis>dev</emphasis> profile.</para>, +          <para>By annotating <classname>TransferServiceTest</classname> with, +          <interfacename>@ActiveProfiles("dev")</interfacename> we instruct, +          the Spring TestContext Framework to load the, +          <interfacename>ApplicationContext</interfacename> with the active, +          profiles set to <literal>{"dev"}</literal>. As a result, an embedded, +          database will be created, and the, +          <varname>accountRepository</varname> bean will be wired with a, +          reference to the development, +          <interfacename>DataSource</interfacename>. And that's likely what we, +          want in an integration test.</para>, +          same configuration and integration test but using, +          <interfacename>@Configuration</interfacename> classes instead of, +          XML.</para>, +          three independent <interfacename>@Configuration</interfacename>, +          classes:</para>, +              <para><classname>TransferServiceConfig</classname>: acquires a, +              <varname>dataSource</varname> via dependency injection using, +              <interfacename>@Autowired</interfacename></para>, +              <para><classname>StandaloneDataConfig</classname>: defines a, +              <varname>dataSource</varname> for an embedded database suitable, +              for developer tests</para>, +              <para><classname>JndiDataConfig</classname>: defines a, +              <varname>dataSource</varname> that is retrieved from JNDI in a, +              production environment</para>, +          <classname>TransferServiceTest</classname> with, +          <interfacename>@ActiveProfiles("dev")</interfacename>, but this time, +          we specify all three configuration classes via the, +          <interfacename>@ContextConfiguration </interfacename>annotation. The, +          body of the test class itself remains completely unchanged.</para>]