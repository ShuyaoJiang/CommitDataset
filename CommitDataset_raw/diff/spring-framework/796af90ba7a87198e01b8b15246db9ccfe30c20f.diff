[+++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java, +			this.attributes.put(this.attributeName,, +				this.allNestedAttributes.toArray(new AnnotationAttributes[this.allNestedAttributes.size()]));, +, +	public RecursiveAnnotationAttributesVisitor(String annotationType, AnnotationAttributes attributes,, +			ClassLoader classLoader) {, +			this.logger.debug("Failed to class-load type while reading annotation metadata. ", +					+ "This is a non-fatal error, but certain annotation metadata may be unavailable.", ex);, +		// Only do further scanning for public annotations; we'd run into, +		// IllegalAccessExceptions otherwise, and we don't want to mess with, +		// accessibility in a SecurityManager environment., +						defaultValue = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +							(Annotation) defaultValue, false, true));, +							mappedAnnotations[i] = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +								realAnnotations[i], false, true));, + * @author Sam Brannen, +	public AnnotationAttributesReadingVisitor(String annotationType,, +			MultiValueMap<String, AnnotationAttributes> attributesMap, Map<String, Set<String>> metaAnnotationMap,, +			ClassLoader classLoader) {, +			if (!AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotation)) {, +		}, +		String annotationName = annotation.annotationType().getName();, +		if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation) && visited.add(annotationName)) {, +			// Only do further scanning for public annotations; we'd run into, +			// IllegalAccessExceptions otherwise, and we don't want to mess with, +			// accessibility in a SecurityManager environment., +				this.attributesMap.add(annotationName, AnnotationUtils.getAnnotationAttributes(annotation, false, true));, +, +++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java, +			this.attributes.put(this.attributeName,, +				this.allNestedAttributes.toArray(new AnnotationAttributes[this.allNestedAttributes.size()]));, +, +	public RecursiveAnnotationAttributesVisitor(String annotationType, AnnotationAttributes attributes,, +			ClassLoader classLoader) {, +			this.logger.debug("Failed to class-load type while reading annotation metadata. ", +					+ "This is a non-fatal error, but certain annotation metadata may be unavailable.", ex);, +		// Only do further scanning for public annotations; we'd run into, +		// IllegalAccessExceptions otherwise, and we don't want to mess with, +		// accessibility in a SecurityManager environment., +						defaultValue = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +							(Annotation) defaultValue, false, true));, +							mappedAnnotations[i] = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +								realAnnotations[i], false, true));, + * @author Sam Brannen, +	public AnnotationAttributesReadingVisitor(String annotationType,, +			MultiValueMap<String, AnnotationAttributes> attributesMap, Map<String, Set<String>> metaAnnotationMap,, +			ClassLoader classLoader) {, +			if (!AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotation)) {, +		}, +		String annotationName = annotation.annotationType().getName();, +		if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation) && visited.add(annotationName)) {, +			// Only do further scanning for public annotations; we'd run into, +			// IllegalAccessExceptions otherwise, and we don't want to mess with, +			// accessibility in a SecurityManager environment., +				this.attributesMap.add(annotationName, AnnotationUtils.getAnnotationAttributes(annotation, false, true));, +, +++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationMetadataReadingVisitor.java, +	 * Declared as a {@link LinkedMultiValueMap} instead of a {@link MultiValueMap}, +	 * to ensure that the hierarchical ordering of the entries is preserved., +	protected final LinkedMultiValueMap<String, AnnotationAttributes> attributesMap = new LinkedMultiValueMap<String, AnnotationAttributes>(, +		return new AnnotationAttributesReadingVisitor(className, this.attributesMap, this.metaAnnotationMap, this.classLoader);, +		return this.attributesMap.containsKey(annotationType);, +		AnnotationAttributes raw = AnnotationReadingVisitorUtils.getMergedAnnotationAttributes(this.attributesMap,, +		List<AnnotationAttributes> attributes = this.attributesMap.get(annotationType);, +++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java, +			this.attributes.put(this.attributeName,, +				this.allNestedAttributes.toArray(new AnnotationAttributes[this.allNestedAttributes.size()]));, +, +	public RecursiveAnnotationAttributesVisitor(String annotationType, AnnotationAttributes attributes,, +			ClassLoader classLoader) {, +			this.logger.debug("Failed to class-load type while reading annotation metadata. ", +					+ "This is a non-fatal error, but certain annotation metadata may be unavailable.", ex);, +		// Only do further scanning for public annotations; we'd run into, +		// IllegalAccessExceptions otherwise, and we don't want to mess with, +		// accessibility in a SecurityManager environment., +						defaultValue = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +							(Annotation) defaultValue, false, true));, +							mappedAnnotations[i] = AnnotationAttributes.fromMap(AnnotationUtils.getAnnotationAttributes(, +								realAnnotations[i], false, true));, + * @author Sam Brannen, +	public AnnotationAttributesReadingVisitor(String annotationType,, +			MultiValueMap<String, AnnotationAttributes> attributesMap, Map<String, Set<String>> metaAnnotationMap,, +			ClassLoader classLoader) {, +			if (!AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotation)) {, +		}, +		String annotationName = annotation.annotationType().getName();, +		if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation) && visited.add(annotationName)) {, +			// Only do further scanning for public annotations; we'd run into, +			// IllegalAccessExceptions otherwise, and we don't want to mess with, +			// accessibility in a SecurityManager environment., +				this.attributesMap.add(annotationName, AnnotationUtils.getAnnotationAttributes(annotation, false, true));, +, +++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationMetadataReadingVisitor.java, +	 * Declared as a {@link LinkedMultiValueMap} instead of a {@link MultiValueMap}, +	 * to ensure that the hierarchical ordering of the entries is preserved., +	protected final LinkedMultiValueMap<String, AnnotationAttributes> attributesMap = new LinkedMultiValueMap<String, AnnotationAttributes>(, +		return new AnnotationAttributesReadingVisitor(className, this.attributesMap, this.metaAnnotationMap, this.classLoader);, +		return this.attributesMap.containsKey(annotationType);, +		AnnotationAttributes raw = AnnotationReadingVisitorUtils.getMergedAnnotationAttributes(this.attributesMap,, +		List<AnnotationAttributes> attributes = this.attributesMap.get(annotationType);]