[+++ b/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java, +, +, +import java.lang.reflect.Modifier;, +, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.Set;, +import static org.springframework.beans.PropertyDescriptorUtils.*;, + * Decorator for a standard {@link BeanInfo} object, e.g. as created by, + * {@link Introspector#getBeanInfo(Class)}, designed to discover and register non-void, + * returning setter methods. For example:, + * <pre>{@code, + * public class Bean {, + *     private Foo foo;, + *, + *     public Foo getFoo() {, + *         return this.foo;, + *     }, + *, + *     public Bean setFoo(Foo foo) {, + *         this.foo = foo;, + *         return this;, + *     }, + * }</pre>, + * The standard JavaBeans {@code Introspector} will discover the {@code getFoo} read, + * method, but will bypass the {@code #setFoo(Foo)} write method, because its non-void, + * returning signature does not comply with the JavaBeans specification., + * {@code ExtendedBeanInfo}, on the other hand, will recognize and include it. This is, + * designed to allow APIs with "builder" or method-chaining style setter signatures to be, + * used within Spring {@code <beans>} XML. {@link #getPropertyDescriptors()} returns all, + * existing property descriptors from the wrapped {@code BeanInfo} as well any added for, + * non-void returning setters. Both standard ("non-indexed") and, + * @see #ExtendedBeanInfo(BeanInfo), + * @see ExtendedBeanInfoFactory, +	private final Set<PropertyDescriptor> propertyDescriptors =, +	 * Wrap the given {@link BeanInfo} instance; copy all its existing property descriptors, +	 * locally, wrapping each in a custom {@link SimpleIndexedPropertyDescriptor indexed} or, +	 * {@link SimpleNonIndexedPropertyDescriptor non-indexed} {@code PropertyDescriptor}, +	 * variant that bypasses default JDK weak/soft reference management; then search, +	 * through its method descriptors to find any non-void returning write methods and, +	 * update or create the corresponding {@link PropertyDescriptor} for each one found., +	 * @param delegate the wrapped {@code BeanInfo}, which is never modified, +	 * @throws IntrospectionException if any problems occur creating and adding new, +	 * property descriptors, +			this.propertyDescriptors.add(pd instanceof IndexedPropertyDescriptor ?, +					new SimpleIndexedPropertyDescriptor((IndexedPropertyDescriptor) pd) :, +					new SimpleNonIndexedPropertyDescriptor(pd));, +		for (Method method : findNonVoidWriteMethods(delegate.getMethodDescriptors())) {, +			handleNonVoidWriteMethod(method);, +		}, +	}, +, +, +	private List<Method> findNonVoidWriteMethods(MethodDescriptor[] methodDescriptors) {, +		List<Method> matches = new ArrayList<Method>();, +		for (MethodDescriptor methodDescriptor : methodDescriptors) {, +			Method method = methodDescriptor.getMethod();, +			if (isNonVoidWriteMethod(method)) {, +				matches.add(method);, +			}, +		}, +		return matches;, +	}, +, +	public static boolean isNonVoidWriteMethod(Method method) {, +		String methodName = method.getName();, +		Class<?>[] parameterTypes = method.getParameterTypes();, +		int nParams = parameterTypes.length;, +		if (methodName.length() > 3 && methodName.startsWith("set") &&, +				Modifier.isPublic(method.getModifiers()) &&, +				!void.class.isAssignableFrom(method.getReturnType()) &&, +				(nParams == 1 || (nParams == 2 && parameterTypes[0].equals(int.class)))) {, +			return true;, +		}, +		return false;, +	}, +, +	private void handleNonVoidWriteMethod(Method method) throws IntrospectionException {, +		int nParams = method.getParameterTypes().length;, +		Class<?> propertyType = method.getParameterTypes()[nParams-1];, +		PropertyDescriptor existingPD = findExistingPropertyDescriptor(propertyName, propertyType);, +		if (nParams == 1) {, +			if (existingPD == null) {, +				this.propertyDescriptors.add(, +						new SimpleNonIndexedPropertyDescriptor(propertyName, null, method));, +			else {, +				existingPD.setWriteMethod(method);, +		}, +		else if (nParams == 2) {, +			if (existingPD == null) {, +				this.propertyDescriptors.add(, +						new SimpleIndexedPropertyDescriptor(, +								propertyName, null, null, null, method));, +			}, +			else if (existingPD instanceof IndexedPropertyDescriptor) {, +				((IndexedPropertyDescriptor)existingPD).setIndexedWriteMethod(method);, +			}, +			else {]