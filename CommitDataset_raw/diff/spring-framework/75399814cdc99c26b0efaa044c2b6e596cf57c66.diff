[+++ b/spring-web-reactive/build.gradle, +	optional("com.fasterxml:aalto-xml:1.0.0"), +	testCompile("xmlunit:xmlunit:1.6"), +++ b/spring-web-reactive/build.gradle, +	optional("com.fasterxml:aalto-xml:1.0.0"), +	testCompile("xmlunit:xmlunit:1.6"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/Jaxb2Decoder.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.function.Function;, +import javax.xml.XMLConstants;, +import javax.xml.bind.annotation.XmlSchema;, +import javax.xml.bind.annotation.XmlType;, +import javax.xml.namespace.QName;, +import javax.xml.stream.XMLEventReader;, +import javax.xml.stream.events.XMLEvent;, +import reactor.core.publisher.Mono;, +import org.springframework.util.ClassUtils;, + * @author Arjen Poutsma, +	/**, +	 * The default value for JAXB annotations., +	 * @see XmlRootElement#name(), +	 * @see XmlRootElement#namespace(), +	 * @see XmlType#name(), +	 * @see XmlType#namespace(), +	 */, +	private final static String JAXB_DEFAULT_ANNOTATION_VALUE = "##default";, +	private final XmlEventDecoder xmlEventDecoder = new XmlEventDecoder();, +, +	private final JaxbContextContainer jaxbContexts = new JaxbContextContainer();, +	@Override, +	public boolean canDecode(ResolvableType type, MimeType mimeType, Object... hints) {, +		if (super.canDecode(type, mimeType, hints)) {, +			Class<?> outputClass = type.getRawClass();, +			return outputClass.isAnnotationPresent(XmlRootElement.class) ||, +					outputClass.isAnnotationPresent(XmlType.class);, +		}, +		else {, +			return false;, +		}, +	}, +		Flux<XMLEvent> xmlEventFlux =, +				this.xmlEventDecoder.decode(inputStream, null, mimeType);, +, +		QName typeName = toQName(outputClass);, +		Flux<List<XMLEvent>> splitEvents = split(xmlEventFlux, typeName);, +, +		return splitEvents.map(events -> unmarshal(events, outputClass));, +	}, +, +	/**, +	 * Returns the qualified name for the given class, according to the mapping rules, +	 * in the JAXB specification., +	 */, +	QName toQName(Class<?> outputClass) {, +		String localPart;, +		String namespaceUri;, +, +			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class);, +			localPart = annotation.name();, +			namespaceUri = annotation.namespace();, +		}, +		else if (outputClass.isAnnotationPresent(XmlType.class)) {, +			XmlType annotation = outputClass.getAnnotation(XmlType.class);, +			localPart = annotation.name();, +			namespaceUri = annotation.namespace();, +			throw new IllegalArgumentException("Outputclass [" + outputClass + "] is " +, +					"neither annotated with @XmlRootElement nor @XmlType");, +		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {, +			localPart = ClassUtils.getShortNameAsProperty(outputClass);, +		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {, +			Package outputClassPackage = outputClass.getPackage();, +			if (outputClassPackage != null &&, +					outputClassPackage.isAnnotationPresent(XmlSchema.class)) {, +				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class);, +				namespaceUri = annotation.namespace();, +				namespaceUri = XMLConstants.NULL_NS_URI;, +		return new QName(namespaceUri, localPart);, +	}, +	/**, +	 * Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list for each, +	 * branch of the tree that starts with the given qualified name., +	 * That is, given the XMLEvents shown, +	 * {@linkplain XmlEventDecoder here},, +	 * and the {@code desiredName} "{@code child}", this method, +	 * returns a flux of two lists, each of which containing the events of a particular, +	 * branch of the tree that starts with "{@code child}"., +	 * <ol>, +	 * <li>The first list, dealing with the first branch of the tree, +	 * <ol>, +	 * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>, +	 * <li>{@link javax.xml.stream.events.Characters} {@code foo}</li>, +	 * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>, +	 * </ol>, +	 * <li>The second list, dealing with the second branch of the tree, +	 * <ol>, +	 * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>, +	 * <li>{@link javax.xml.stream.events.Characters} {@code bar}</li>, +	 * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>, +	 * </ol>]