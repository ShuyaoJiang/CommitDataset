[+++ b/spring-messaging/src/main/java/org/springframework/messaging/core/GenericMessagingTemplate.java, + * Copyright 2002-2017 the original author or authors., + * @author Gary Russell, +	public static final String DEFAULT_SEND_TIMEOUT_HEADER = "sendTimeout";, +, +	public static final String DEFAULT_RECEIVE_TIMEOUT_HEADER = "receiveTimeout";, +, +	private String sendTimeoutHeader = DEFAULT_SEND_TIMEOUT_HEADER;, +, +	private String receiveTimeoutHeader = DEFAULT_RECEIVE_TIMEOUT_HEADER;, +, +	 * Configure the default timeout value to use for send operations., +	 * May be overridden for individual messages., +	 * @see #setSendTimeoutHeader(String), +	 * Return the configured default send operation timeout value., +	 * Configure the default timeout value to use for receive operations., +	 * May be overridden for individual messages when using sendAndReceive, +	 * operations., +	 * @see #setReceiveTimeoutHeader(String), +, +	/**, +	 * Set the name of the header used to determine the send timeout (if present)., +	 * Default {@value #DEFAULT_SEND_TIMEOUT_HEADER}., +	 * The header is removed before sending the message to avoid propagation., +	 * @param sendTimeoutHeader the sendTimeoutHeader to set, +	 * @since 5.0, +	 */, +	public void setSendTimeoutHeader(String sendTimeoutHeader) {, +		Assert.notNull(sendTimeoutHeader, "'sendTimeoutHeader' cannot be null");, +		this.sendTimeoutHeader = sendTimeoutHeader;, +	}, +, +	/**, +	 * @return the configured sendTimeoutHeader., +	 * @since 5.0, +	 */, +	public String getSendTimeoutHeader() {, +		return sendTimeoutHeader;, +	}, +, +	/**, +	 * Set the name of the header used to determine the send timeout (if present)., +	 * Default {@value #DEFAULT_RECEIVE_TIMEOUT_HEADER}., +	 * The header is removed before sending the message to avoid propagation., +	 * @param receiveTimeoutHeader the receiveTimeoutHeader to set, +	 * @since 5.0, +	 */, +	public void setReceiveTimeoutHeader(String receiveTimeoutHeader) {, +		Assert.notNull(receiveTimeoutHeader, "'receiveTimeoutHeader' cannot be null");, +		this.receiveTimeoutHeader = receiveTimeoutHeader;, +	}, +, +	/**, +	 * @return the configured receiveTimeoutHeader, +	 * @since 5.0, +	 */, +	public String getReceiveTimeoutHeader() {, +		return receiveTimeoutHeader;, +	}, +, +		doSend(channel, message, sendTimeout(message));, +	protected final void doSend(MessageChannel channel, Message<?> message, long timeout) {, +		Assert.notNull(channel, "MessageChannel is required");, +, +		Message<?> messageToSend = message;, +		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +		if (accessor != null && accessor.isMutable()) {, +			accessor.removeHeader(this.sendTimeoutHeader);, +			accessor.removeHeader(this.receiveTimeoutHeader);, +			accessor.setImmutable();, +		}, +		else if (message.getHeaders().containsKey(this.sendTimeoutHeader), +				|| message.getHeaders().containsKey(this.receiveTimeoutHeader)) {, +			messageToSend = MessageBuilder.fromMessage(message), +					.setHeader(this.sendTimeoutHeader, null), +					.setHeader(this.receiveTimeoutHeader, null), +					.build();, +		}, +, +		boolean sent = (timeout >= 0 ? channel.send(messageToSend, timeout) : channel.send(messageToSend));, +		return doReceive(channel, this.receiveTimeout);, +	}, +, +	protected final Message<?> doReceive(MessageChannel channel, long timeout) {, +		long sendTimeout = sendTimeout(requestMessage);, +		long receiveTimeout = receiveTimeout(requestMessage);, +, +		TemporaryReplyChannel tempReplyChannel = new TemporaryReplyChannel(this.throwExceptionOnLateReply);, +		requestMessage = MessageBuilder.fromMessage(requestMessage).setReplyChannel(tempReplyChannel), +				.setHeader(this.sendTimeoutHeader, null), +				.setHeader(this.receiveTimeoutHeader, null), +				.setErrorChannel(tempReplyChannel).build();, +			doSend(channel, requestMessage, sendTimeout);, +		Message<?> replyMessage = this.doReceive(tempReplyChannel, receiveTimeout);, +		if (replyMessage != null && (originalReplyChannelHeader!= null || originalErrorChannelHeader != null)) {, +	private long sendTimeout(Message<?> requestMessage) {, +		Long sendTimeout = headerToLong(requestMessage.getHeaders().get(this.sendTimeoutHeader));, +		return sendTimeout == null ? this.sendTimeout : sendTimeout;, +	}, +]