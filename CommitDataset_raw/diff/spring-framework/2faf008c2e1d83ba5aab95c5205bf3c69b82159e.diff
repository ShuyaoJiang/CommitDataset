[+++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);, +	 * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;, +	 * by converting to a targetType built with this method:, +	 * The method call to construct such a TypeDescriptor would look something like:, +	 * <pre class="code">, +	 * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));, +	 * </pre>, +	 * <p>For example to create a {@code Map<String,String>[]} use:, +	 * <pre class="code">, +	 * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));, +	 * </pre>, +		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),, +	 * {@link MethodParameter} argument is not 1, or if the types up to the, +	 * specified nesting level are not of collection, array, or map types, +			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +, +					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal");, +	 * <p>Use this factory method to introspect a source object before asking the, +	 * conversion system to convert it to some another type., +	 * <p>If the provided object is null, returns null, else calls {@link #valueOf(Class)}, +	 * to build a TypeDescriptor from the object's class., +			}, +			else {, +++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);, +	 * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;, +	 * by converting to a targetType built with this method:, +	 * The method call to construct such a TypeDescriptor would look something like:, +	 * <pre class="code">, +	 * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));, +	 * </pre>, +	 * <p>For example to create a {@code Map<String,String>[]} use:, +	 * <pre class="code">, +	 * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));, +	 * </pre>, +		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),, +	 * {@link MethodParameter} argument is not 1, or if the types up to the, +	 * specified nesting level are not of collection, array, or map types, +			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +, +					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal");, +	 * <p>Use this factory method to introspect a source object before asking the, +	 * conversion system to convert it to some another type., +	 * <p>If the provided object is null, returns null, else calls {@link #valueOf(Class)}, +	 * to build a TypeDescriptor from the object's class., +			}, +			else {, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor.java, +, +		return HttpEntity.class.isAssignableFrom(returnType.getParameterType());, +	public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,, +		throw new IllegalArgumentException("HttpEntity parameter (" + parameter.getParameterName() +, +				") in method " + parameter.getMethod() + " is not parameterized or has more than one parameter");, +	public void handleReturnValue(Object returnValue, MethodParameter returnType,, +			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {, +			// Flush headers to the HttpServletResponse]