[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java, +import java.util.LinkedHashSet;, +import java.util.Map;, +, +	/**, +	 * Returns the media types supported by all provided message converters preserving their ordering and , +	 * further sorting by specificity via {@link MediaType#sortBySpecificity(List)}. , +	 */, +		Set<MediaType> allSupportedMediaTypes = new LinkedHashSet<MediaType>();, +		List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);, +		List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());, +		Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();, +		for (MediaType a : acceptableMediaTypes) {, +			for (MediaType p : producibleMediaTypes) {, +				if (a.isCompatibleWith(p)) {, +					compatibleMediaTypes.add(getMostSpecificMediaType(a, p));, +		if (compatibleMediaTypes.isEmpty()) {, +		, +		List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);, +		, +		, +	 * 	<li>The producible media types specified in the request mappings, or, +	 * 	<li>The media types supported by all configured message converters, or, +	protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request) {, +			return new ArrayList<MediaType>(mediaTypes);, +			return allSupportedMediaTypes;, +			return Collections.singletonList(MediaType.ALL);, +	private List<MediaType> getAcceptableMediaTypes(HttpInputMessage inputMessage) {, +		List<MediaType> result = inputMessage.getHeaders().getAccept();, +		return result.isEmpty() ? Collections.singletonList(MediaType.ALL) : result;, +	/**, +	 * Returns the more specific media type using the q-value of the first media type for both., +	 */, +		double quality = type1.getQualityValue();, +		Map<String, String> params = Collections.singletonMap("q", String.valueOf(quality));, +		MediaType t1 = new MediaType(type1, params);, +		MediaType t2 = new MediaType(type2, params);, +		return MediaType.SPECIFICITY_COMPARATOR.compare(t1, t2) <= 0 ? type1 : type2;, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java, +import java.util.LinkedHashSet;, +import java.util.Map;, +, +	/**, +	 * Returns the media types supported by all provided message converters preserving their ordering and , +	 * further sorting by specificity via {@link MediaType#sortBySpecificity(List)}. , +	 */, +		Set<MediaType> allSupportedMediaTypes = new LinkedHashSet<MediaType>();, +		List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);, +		List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());, +		Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();, +		for (MediaType a : acceptableMediaTypes) {, +			for (MediaType p : producibleMediaTypes) {, +				if (a.isCompatibleWith(p)) {, +					compatibleMediaTypes.add(getMostSpecificMediaType(a, p));, +		if (compatibleMediaTypes.isEmpty()) {, +		, +		List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);, +		, +		, +	 * 	<li>The producible media types specified in the request mappings, or, +	 * 	<li>The media types supported by all configured message converters, or, +	protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request) {, +			return new ArrayList<MediaType>(mediaTypes);, +			return allSupportedMediaTypes;, +			return Collections.singletonList(MediaType.ALL);, +	private List<MediaType> getAcceptableMediaTypes(HttpInputMessage inputMessage) {, +		List<MediaType> result = inputMessage.getHeaders().getAccept();, +		return result.isEmpty() ? Collections.singletonList(MediaType.ALL) : result;, +	/**, +	 * Returns the more specific media type using the q-value of the first media type for both., +	 */, +		double quality = type1.getQualityValue();, +		Map<String, String> params = Collections.singletonMap("q", String.valueOf(quality));, +		MediaType t1 = new MediaType(type1, params);, +		MediaType t2 = new MediaType(type2, params);, +		return MediaType.SPECIFICITY_COMPARATOR.compare(t1, t2) <= 0 ? type1 : type2;, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +import org.springframework.web.servlet.HandlerMapping;, +				List<MediaType> acceptableMediaTypes = MediaType.parseMediaTypes(acceptHeader);, +				List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request);, +, +				Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();, +				for (MediaType a : acceptableMediaTypes) {, +					for (MediaType p : producibleMediaTypes) {, +						if (a.isCompatibleWith(p)) {, +							compatibleMediaTypes.add(getMostSpecificMediaType(a, p));, +						}, +					}, +				}, +				, +				List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);, +, +					logger.debug("Requested media types are " + mediaTypes + " based on Accept header types " + , +							"and producible media types " + producibleMediaTypes + ")");, +	@SuppressWarnings("unchecked"), +	private List<MediaType> getProducibleMediaTypes(HttpServletRequest request) {, +		Set<MediaType> mediaTypes = (Set<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);, +		if (!CollectionUtils.isEmpty(mediaTypes)) {]