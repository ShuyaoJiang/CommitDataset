[+++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +	protected Object execute(Callable<Object> invocation, Object target, Method method, Object[] args) throws Exception {, +		final CacheDefinition cacheDef = getCacheDefinitionSource().getCacheDefinition(method, targetClass);, +			CacheOperationContext context = getOperationContext(cacheDef, method, args, targetClass);, +						// always get the value, +						// to avoid race-conditions of entries being removed between contains/get calls, +						if (cache.containsKey(key)) {, +							return retVal;, +						// to avoid the contains/get race condition we can:, +						// a. get the value in advanced (aka 'eagerGet'), +						// b. double check 'contains' before and after get, +						// a implies more calls in total if more then 3 caches are used (n*2 calls), +						// b uses less calls in total but is 1 call heavier for one cache (n+2 calls), +						// --, +						// for balance, a) is used for up to 3 caches, b for more then 4, +, +						boolean eagerGet = caches.size() <= 3;, +, +							if (eagerGet) {, +							}, +							if (cache.containsKey(key)) {, +								if (eagerGet) {, +								} else {, +									retVal = cache.get(key);, +									cacheHit = cache.containsKey(key);, +								}, +		public CacheOperationContext(CacheDefinition operationDefinition, Method method, Object[] args,, +				Class<?> targetClass) {, +			this.evalContext = evaluator.createEvaluationContext(caches, method, args, targetClass);, +				return evaluator.condition(definition.getCondition(), method, evalContext);]