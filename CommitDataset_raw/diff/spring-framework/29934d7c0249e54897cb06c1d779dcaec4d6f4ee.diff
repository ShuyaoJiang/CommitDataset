[+++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageDeliveryException.java, +	public MessageDeliveryException(Message<?> message, Throwable cause) {, +		super(message, cause);, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageDeliveryException.java, +	public MessageDeliveryException(Message<?> message, Throwable cause) {, +		super(message, cause);, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.util.concurrent.Callable;, +import org.springframework.messaging.support.tcp.FixedIntervalReconnectStrategy;, +import org.springframework.messaging.support.tcp.ReactorNettyTcpClient;, +import org.springframework.messaging.support.tcp.TcpConnection;, +import org.springframework.messaging.support.tcp.TcpConnectionHandler;, +import org.springframework.messaging.support.tcp.TcpOperations;, +import org.springframework.util.concurrent.ListenableFuture;, +import org.springframework.util.concurrent.ListenableFutureCallback;, +import org.springframework.util.concurrent.ListenableFutureTask;, + * provided to configure the "system" connection including the the, +	private static final byte[] EMPTY_PAYLOAD = new byte[0];, +, +	private static final Message<byte[]> HEARTBEAT_MESSAGE = MessageBuilder.withPayload(new byte[] {'\n'}).build();, +, +	private static final long HEARTBEAT_MULTIPLIER = 3;, +, +, +	private TcpOperations<byte[]> tcpClient;, +	private final Map<String, StompConnectionHandler> connectionHandlers =, +			new ConcurrentHashMap<String, StompConnectionHandler>();, +	 * Configure the TCP client to for managing STOMP over TCP connections to the message, +	 * broker. This is an optional property that can be used to replace the default, +	 * implementation used for example for testing purposes., +	 * <p>, +	 * By default an instance of {@link ReactorNettyTcpClient} is used., +	 */, +	public void setTcpClient(TcpOperations<byte[]> tcpClient) {, +		this.tcpClient = tcpClient;, +	}, +, +	/**, +	 * Set the interval, in milliseconds, at which the "system" connection will, in the, +	 * See class-level documentation for more information on the "system" connection., +	 * @return The interval, in milliseconds, at which the "system" connection will, +	 * Set the maximum interval, in milliseconds, at which the "system" connection, +	 * broker. A value of zero will configure the connection to expect not to receive, +	 * See class-level documentation for more information on the "system" connection., +	 * @return The interval, in milliseconds, at which the "system" connection expects, +	 * Set the login for the "system" connection used to send messages to the STOMP, +	 * See class-level documentation for more information on the "system" connection., +	 * @return the login used by the "system" connection to connect to the STOMP broker, +	 * Set the passcode for the "system" connection used to send messages to the STOMP, +	 * See class-level documentation for more information on the "system" connection., +	 * @return the passcode used by the "system" connection to connect to the STOMP broker, +, +		this.tcpClient = new ReactorNettyTcpClient<byte[]>(this.relayHost, this.relayPort, new StompCodec());, +		SystemStompConnectionHandler handler = new SystemStompConnectionHandler(headers);, +		this.connectionHandlers.put(handler.getSessionId(), handler);, +		this.tcpClient.connect(handler, new FixedIntervalReconnectStrategy(5000));, +		for (StompConnectionHandler handler : this.connectionHandlers.values()) {, +				handler.resetTcpConnection();, +				logger.error("Failed to close STOMP connection " + t.getMessage());, +			}, +			this.tcpClient.shutdown();, +			logger.error("Error while shutting down TCP client", t);, +			sessionId = (sessionId == null) ? SystemStompConnectionHandler.SESSION_ID : sessionId;, +			StompConnectionHandler handler = new StompConnectionHandler(sessionId, headers);, +			this.connectionHandlers.put(sessionId, handler);, +			this.tcpClient.connect(handler);, +			StompConnectionHandler handler = removeConnectionHandler(sessionId);, +			if (handler == null) {, +					logger.trace("Connection already removed for sessionId=" + sessionId);, +			handler.forward(message);, +			StompConnectionHandler handler = this.connectionHandlers.get(sessionId);, +			if (handler == null) {, +				logger.warn("Connection for sessionId=" + sessionId + " not found. Ignoring message: " + message);, +			handler.forward(message);, +	private StompConnectionHandler removeConnectionHandler(String sessionId) {, +		return SystemStompConnectionHandler.SESSION_ID.equals(sessionId), +				? null : this.connectionHandlers.remove(sessionId);, +	}, +	private class StompConnectionHandler implements TcpConnectionHandler<byte[]> {, +		private final StompHeaderAccessor connectHeaders;, +		private volatile TcpConnection<byte[]> tcpConnection;, +		private volatile boolean isStompConnected;, +		private StompConnectionHandler(String sessionId, StompHeaderAccessor connectHeaders) {, +			this(sessionId, connectHeaders, true);, +		private StompConnectionHandler(String sessionId, StompHeaderAccessor connectHeaders,, +				boolean isRemoteClientSession) {, +, +			Assert.notNull(connectHeaders, "connectHeaders is required");, +, +			this.connectHeaders = connectHeaders;, +		public String getSessionId() {, +		public void afterConnected(TcpConnection<byte[]> connection) {, +			this.tcpConnection = connection;, +			connection.send(MessageBuilder.withPayload(EMPTY_PAYLOAD).setHeaders(this.connectHeaders).build());, +		public void afterConnectFailure(Throwable ex) {, +			handleTcpConnectionFailure("Failed to connect to message broker", ex);]