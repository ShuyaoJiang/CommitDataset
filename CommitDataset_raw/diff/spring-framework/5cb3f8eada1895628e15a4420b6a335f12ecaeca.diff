[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, + * Copyright 2002-2014 the original author or authors., +				for (int i = 2; i <= this.nestingLevel; i++) {, +						type = args[args.length - 1];, +					}, +				}, +				if (type instanceof Class) {, +					return (Class<?>) type;, +				}, +				else if (type instanceof ParameterizedType) {, +					Type arg = ((ParameterizedType) type).getRawType();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, + * Copyright 2002-2014 the original author or authors., +				for (int i = 2; i <= this.nestingLevel; i++) {, +						type = args[args.length - 1];, +					}, +				}, +				if (type instanceof Class) {, +					return (Class<?>) type;, +				}, +				else if (type instanceof ParameterizedType) {, +					Type arg = ((ParameterizedType) type).getRawType();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.lang.UsesJava8;, +	private static Class<?> javaxInjectProviderClass = null;, +, +		try {, +			javaxInjectProviderClass =, +					ClassUtils.forName("javax.inject.Provider", DefaultListableBeanFactory.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// JSR-330 API not available - Provider interface simply not supported then., +		}, +		if (descriptor.getDependencyType().equals(javaUtilOptionalClass)) {, +			return new OptionalDependencyFactory().createOptionalDependency(descriptor, beanName);, +		}, +		else if (descriptor.getDependencyType().equals(ObjectFactory.class)) {, +	 * Separate inner class for avoiding a hard dependency on the {@code javax.inject} API., +	 */, +	@UsesJava8, +	private class OptionalDependencyFactory {, +, +		public Object createOptionalDependency(DependencyDescriptor descriptor, String beanName) {, +			DependencyDescriptor descriptorToUse = new DependencyDescriptor(descriptor) {, +				@Override, +				public boolean isRequired() {, +					return false;, +				}, +			};, +			descriptorToUse.increaseNestingLevel();, +			return Optional.ofNullable(doResolveDependency(descriptorToUse, beanName, null, null));, +		}, +	}, +, +, +	/**, +		private final boolean optional;, +, +			this.optional = this.descriptor.getDependencyType().equals(javaUtilOptionalClass);, +			if (this.optional) {, +				return new OptionalDependencyFactory().createOptionalDependency(this.descriptor, this.beanName);, +			}, +			else {, +	}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, + * Copyright 2002-2014 the original author or authors., +				for (int i = 2; i <= this.nestingLevel; i++) {, +						type = args[args.length - 1];, +					}, +				}, +				if (type instanceof Class) {, +					return (Class<?>) type;, +				}, +				else if (type instanceof ParameterizedType) {, +					Type arg = ((ParameterizedType) type).getRawType();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.lang.UsesJava8;, +	private static Class<?> javaxInjectProviderClass = null;, +, +		try {, +			javaxInjectProviderClass =, +					ClassUtils.forName("javax.inject.Provider", DefaultListableBeanFactory.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// JSR-330 API not available - Provider interface simply not supported then., +		}, +		if (descriptor.getDependencyType().equals(javaUtilOptionalClass)) {, +			return new OptionalDependencyFactory().createOptionalDependency(descriptor, beanName);, +		}, +		else if (descriptor.getDependencyType().equals(ObjectFactory.class)) {, +	 * Separate inner class for avoiding a hard dependency on the {@code javax.inject} API., +	 */, +	@UsesJava8, +	private class OptionalDependencyFactory {, +, +		public Object createOptionalDependency(DependencyDescriptor descriptor, String beanName) {, +			DependencyDescriptor descriptorToUse = new DependencyDescriptor(descriptor) {, +				@Override, +				public boolean isRequired() {, +					return false;]