[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2015 the original author or authors., +		if (Future.class.isAssignableFrom(method.getReturnType())) {, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2015 the original author or authors., +		if (Future.class.isAssignableFrom(method.getReturnType())) {, +++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessorTests.java, + * Copyright 2002-2015 the original author or authors., +import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;, +import org.springframework.context.annotation.AnnotationConfigApplicationContext;, +import org.springframework.context.annotation.Bean;, +import org.springframework.context.annotation.Configuration;, +import org.springframework.util.concurrent.ListenableFuture;, +		ConfigurableApplicationContext context =, +				new AnnotationConfigApplicationContext(ConfigWithExceptionHandler.class);, +, +		TestableAsyncUncaughtExceptionHandler exceptionHandler =, +				context.getBean("exceptionHandler", TestableAsyncUncaughtExceptionHandler.class);, +		assertFalse("handler should not have been called yet", exceptionHandler.isCalled());, +		Future<Object> result = testBean.failWithFuture();, +		assertFutureWithException(result, exceptionHandler);, +	}, +, +	@Test, +	public void handleExceptionWithListenableFuture() {, +		ConfigurableApplicationContext context =, +				new AnnotationConfigApplicationContext(ConfigWithExceptionHandler.class);, +		ITestBean testBean = context.getBean("target", ITestBean.class);, +, +		TestableAsyncUncaughtExceptionHandler exceptionHandler =, +				context.getBean("exceptionHandler", TestableAsyncUncaughtExceptionHandler.class);, +		assertFalse("handler should not have been called yet", exceptionHandler.isCalled());, +		Future<Object> result = testBean.failWithListenableFuture();, +		assertFutureWithException(result, exceptionHandler);, +	}, +, +	private void assertFutureWithException(Future<Object> result,, +			TestableAsyncUncaughtExceptionHandler exceptionHandler) {, +		assertFalse("handler should never be called with Future return type", exceptionHandler.isCalled());, +	private interface ITestBean {, +		ListenableFuture<Object> failWithListenableFuture();, +, +		@Override, +		@Override, +		public ListenableFuture<Object> failWithListenableFuture() {, +			throw new UnsupportedOperationException("failWithListenableFuture");, +		}, +, +		@Async, +		@Override, +	@Configuration, +	@EnableAsync, +	static class ConfigWithExceptionHandler extends AsyncConfigurerSupport {, +, +		@Bean, +		public ITestBean target() {, +			return new TestBean();, +		}, +, +		@Override, +		public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {, +			return exceptionHandler();, +		}, +, +		@Bean, +		public TestableAsyncUncaughtExceptionHandler exceptionHandler() {, +			return new TestableAsyncUncaughtExceptionHandler();, +		}, +	}, +, +]