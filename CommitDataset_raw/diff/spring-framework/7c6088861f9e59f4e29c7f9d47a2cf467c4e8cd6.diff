[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.core.env.ConfigurableEnvironment;, +import org.springframework.core.env.MutablePropertySources;, +	private final MultiValueMap<Object, PropertySourceDescriptor> propertySources =, +			new LinkedMultiValueMap<Object, PropertySourceDescriptor>();, +		// Recursively process any member (nested) classes first, +		// Process any @PropertySource annotations, +		// Register PropertySources with Environment, +		registerPropertySources();, +, +		// Process any @ComponentScan annotations, +		// Process any @Import annotations, +		// Process any @ImportResource annotations, +		// Process individual @Bean methods, +		// Process superclass, if any, +				// Superclass found, return its annotation metadata and recurse, +		// No superclass, processing is complete, +	private void processPropertySource(AnnotationAttributes propertySource) {, +			this.propertySources.add((StringUtils.hasText(name) ? name : this.propertySources.size()),, +					new PropertySourceDescriptor(location, ignoreResourceNotFound));, +		}, +	}, +, +	/**, +	 * Register all discovered property sources with the {@link Environment}., +	 * @throws IOException in case of property loading failure, +	 */, +	private void registerPropertySources() throws IOException {, +		if (!(this.environment instanceof ConfigurableEnvironment)) {, +			return;, +		}, +		MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();, +, +		String lastName = null;, +		for (Map.Entry<Object, List<PropertySourceDescriptor>> entry : this.propertySources.entrySet()) {, +			Object key = entry.getKey();, +			String name = (key instanceof String ? (String) key : null);, +, +			List<PropertySourceDescriptor> descriptors = entry.getValue();, +			List<ResourcePropertySource> resources = new ArrayList<ResourcePropertySource>(descriptors.size());, +, +			for (PropertySourceDescriptor descriptor : descriptors) {, +					String resolvedLocation = this.environment.resolveRequiredPlaceholders(descriptor.location);, +					resources.add(ps);, +					if (name == null) {, +						name = ps.getName();, +					}, +					if (!descriptor.ignoreResourceNotFound) {, +					if (!descriptor.ignoreResourceNotFound) {, +, +			PropertySource<?> ps = collatePropertySources(name, resources);, +			if (lastName != null) {, +				envPropertySources.addBefore(lastName, ps);, +			}, +			else {, +				envPropertySources.addLast(ps);, +			}, +			lastName = name;, +		}, +	private static class PropertySourceDescriptor {, +, +		public PropertySourceDescriptor(String location, boolean ignoreResourceNotFound) {, +			this.location = location;, +			this.ignoreResourceNotFound = ignoreResourceNotFound;, +		}, +, +		public final String location;, +, +		public final boolean ignoreResourceNotFound;, +	}, +, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.core.env.ConfigurableEnvironment;, +import org.springframework.core.env.MutablePropertySources;, +	private final MultiValueMap<Object, PropertySourceDescriptor> propertySources =, +			new LinkedMultiValueMap<Object, PropertySourceDescriptor>();, +		// Recursively process any member (nested) classes first, +		// Process any @PropertySource annotations, +		// Register PropertySources with Environment, +		registerPropertySources();, +, +		// Process any @ComponentScan annotations, +		// Process any @Import annotations, +		// Process any @ImportResource annotations, +		// Process individual @Bean methods, +		// Process superclass, if any, +				// Superclass found, return its annotation metadata and recurse, +		// No superclass, processing is complete, +	private void processPropertySource(AnnotationAttributes propertySource) {, +			this.propertySources.add((StringUtils.hasText(name) ? name : this.propertySources.size()),, +					new PropertySourceDescriptor(location, ignoreResourceNotFound));, +		}, +	}, +, +	/**, +	 * Register all discovered property sources with the {@link Environment}., +	 * @throws IOException in case of property loading failure, +	 */, +	private void registerPropertySources() throws IOException {]