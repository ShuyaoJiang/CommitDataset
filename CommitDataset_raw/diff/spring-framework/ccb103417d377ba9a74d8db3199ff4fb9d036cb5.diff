[+++ b/spring-framework-reference/src/mvc.xml, +        <para>The following code sample demonstrates how to get the value of, +        the <literal>JSESSIONID</literal> cookie:</para>, +        <para>Here is a sample request header:</para>, +        <para>The following code sample demonstrates how to get the value of, +        the <literal>Accept-Encoding</literal> and <literal>Keep-Alive</literal> headers:</para>, +          initialize the <classname>WebDataBinder</classname> that will be, +    override this default mapping, unless you need to override the default property values., +	<variablelist>, +		<varlistentry>, +			<term><literal>interceptors</literal></term>, +				<para>, +					List of interceptors to use., +					<xref linkend="mvc-handlermapping-interceptor" />., +				</para>, +		</varlistentry>, +		<varlistentry>, +			<term><literal>defaultHandler</literal></term>, +				<para>Default handler to use, when this handler mapping does not result, +				in a matching handler.</para>, +		</varlistentry>, +		<varlistentry>, +			<term><literal>order</literal></term>, +				<para>, +					Based on the value of the order property (see the, +					<literal>org.springframework.core.Ordered</literal>, +					and applies the first matching handler., +				</para>, +		</varlistentry>, +		<varlistentry>, +			<term><literal>alwaysUseFullPath</literal></term>, +				<para>, +					If <literal>true</literal> , Spring uses the full path within the current, +					servlet context to find an appropriate handler. If <literal>false</literal>, +					(the default), the path within the current servlet mapping is used. For, +					example, if a servlet is mapped using <literal>/testing/*</literal>, +					and the <literal>alwaysUseFullPath</literal> property is set to true,, +					property is set to false, <literal>/viewPage.html</literal> is used., +				</para>, +		</varlistentry>, +		<varlistentry>, +			<term><literal>urlDecode</literal></term>, +				<para>, +					Defaults to <literal>true</literal>, as of Spring 2.5. <!--OK, or do you mean 3.0?-->, +					If you prefer to compare encoded paths, set this flag to <literal>false</literal>., +					However, the <interfacename>HttpServletRequest</interfacename> always exposes the, +					servlet path in decoded form. Be aware that the servlet path will not match when, +					compared with encoded paths., +				</para>, +		</varlistentry>, +		<varlistentry>, +			<term><literal>lazyInitHandlers</literal></term>, +				<para>, +					Allows lazy initialization of <emphasis>singleton</emphasis>, +					handlers (prototype handlers are always lazy-initialized)., +					The default value is <literal>false</literal>., +				</para>, +		</varlistentry>, +	</variablelist>, +	<note>, +		<para>, +			The <literal>alwaysUseFullPath</literal>, <literal>urlDecode</literal>, and, +			<literal>lazyInitHandlers</literal> properties are only available to subclasses of, +			<interfacename>org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</interfacename>., +		</para>, +	</note>, +      the handler execution chain will continue; when it returns false, the, +      <para>As discussed in <xref linkend="mvc-controller" />, all handler, +      methods in the Spring Web MVC controllers must resolve to a logical, +      view name, either explicitly (e.g., by returning a <literal>String</literal>,, +      <literal>View</literal>, or <literal>ModelAndView</literal>) or implicitly, +      (i.e., based on conventions). Views in Spring are, +      addressed by a logical view name and are resolved by a view resolver. Spring, +              effects the direct resolution of logical view names to URLs,, +              your logical names match the names of your view resources in a, +              <entry>Convenient subclass of, +              and JSPs) and subclasses such as, +              <entry>Convenient subclass of, +      <para>When returning <literal>test</literal> as a logical view name, this view, +        of certain view technologies. It's possible to turn off the cache by, +      <literal>order</literal> property to specify ordering. Remember, the, +      two resolvers, an <classname>InternalResourceViewResolver</classname>,, +      they do not exist, Spring throws an <classname>Exception</classname>.</para>, +      through the combination of <classname>InternalResourceViewResolver</classname> and, +      issues an internal forward or include via the Servlet API's, +      <literal>RequestDispatcher.forward(..)</literal> method or, +      <literal>RequestDispatcher.include()</literal> method. For other view, +      writes the content directly to the response stream.</para>, +      client, before the view is rendered. This is desirable, for example, when, +      forward will mean that the other controller will also see the same, +      confuse it with other expected data. Another reason to perform a redirect, +      before displaying the result is to eliminate the possibility, +      of the user submitting the form data multiple times. In this scenario,, +      the browser will first send an initial <literal>POST</literal>; it will, +      then receive a response to redirect to a different URL; and finally, +      the browser will perform a subsequent <literal>GET</literal> for the, +      URL named in the redirect response. Thus, from the perspective of the, +      browser, the current page does not reflect the result of a, +      <literal>POST</literal> but rather of a <literal>GET</literal>. The, +      end effect is that there is no way the user can accidentally]