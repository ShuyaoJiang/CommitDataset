[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +		return isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +		return isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);, +		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +		return isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);, +		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java, +import java.io.Serializable;, +import java.util.concurrent.Callable;, +		lbf.registerBeanDefinition("factoryBean", new RootBeanDefinition(FactoryBeanThatShouldntBeCalled.class));, +		beanNames = lbf.getBeanNamesForType(Callable.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		beanNames = lbf.getBeanNamesForType(RepositoryFactoryInformation.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		lbf.registerBeanDefinition("factoryBean", new RootBeanDefinition(FactoryBeanThatShouldntBeCalled.class));, +		beanNames = lbf.getBeanNamesForType(Callable.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		beanNames = lbf.getBeanNamesForType(RepositoryFactoryInformation.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +	public interface Repository<T, ID extends Serializable> {, +	}, +, +, +	public interface RepositoryFactoryInformation<T, ID extends Serializable> {, +	}, +, +, +	public static abstract class RepositoryFactoryBeanSupport<T extends Repository<S, ID>, S, ID extends Serializable>, +			implements RepositoryFactoryInformation<S, ID>, FactoryBean<T> {, +	}, +, +, +	public static class FactoryBeanThatShouldntBeCalled<T extends Repository<S, ID>, S, ID extends Serializable>, +			extends RepositoryFactoryBeanSupport<T, S, ID> implements Runnable, Callable<T> {, +		public T getObject() {, +, +		@Override, +		public T call() throws Exception {, +			throw new IllegalStateException();, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +		return isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);, +		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java, +import java.io.Serializable;, +import java.util.concurrent.Callable;, +		lbf.registerBeanDefinition("factoryBean", new RootBeanDefinition(FactoryBeanThatShouldntBeCalled.class));, +		beanNames = lbf.getBeanNamesForType(Callable.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		beanNames = lbf.getBeanNamesForType(RepositoryFactoryInformation.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		lbf.registerBeanDefinition("factoryBean", new RootBeanDefinition(FactoryBeanThatShouldntBeCalled.class));, +		beanNames = lbf.getBeanNamesForType(Callable.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +		beanNames = lbf.getBeanNamesForType(RepositoryFactoryInformation.class, false, false);, +		assertEquals(1, beanNames.length);, +		assertEquals("&factoryBean", beanNames[0]);, +, +	public interface Repository<T, ID extends Serializable> {, +	}, +, +, +	public interface RepositoryFactoryInformation<T, ID extends Serializable> {, +	}, +, +, +	public static abstract class RepositoryFactoryBeanSupport<T extends Repository<S, ID>, S, ID extends Serializable>, +			implements RepositoryFactoryInformation<S, ID>, FactoryBean<T> {, +	}, +, +, +	public static class FactoryBeanThatShouldntBeCalled<T extends Repository<S, ID>, S, ID extends Serializable>, +			extends RepositoryFactoryBeanSupport<T, S, ID> implements Runnable, Callable<T> {, +		public T getObject() {, +, +		@Override, +		public T call() throws Exception {, +			throw new IllegalStateException();]