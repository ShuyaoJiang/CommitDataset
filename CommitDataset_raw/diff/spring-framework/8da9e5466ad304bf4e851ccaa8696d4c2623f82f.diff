[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +								match = ArgumentsMatchKind.CLOSE;, +							match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {, +, +			// Now sort out the final argument, which is the varargs one. Before entering this method,, +			// the arguments should have been converted to the box form of the required type., +			Object repackagedArgs = Array.newInstance(componentType, arraySize);, +				Array.set(repackagedArgs, i, args[parameterCount - 1 + i]);, +			newArgs[newArgs.length - 1] = repackagedArgs;, +	static enum ArgumentsMatchKind {, +		/** An exact match is where the parameter types exactly match what the method/constructor is expecting */, +		/** A close match is where the parameter types either exactly match or are assignment-compatible */, +	static class ArgumentsMatchInfo {, +		private final ArgumentsMatchKind kind;, +		ArgumentsMatchInfo(ArgumentsMatchKind kind) {, +			return (this.kind == ArgumentsMatchKind.EXACT);, +			return (this.kind == ArgumentsMatchKind.CLOSE);, +			return (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +								match = ArgumentsMatchKind.CLOSE;, +							match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {, +, +			// Now sort out the final argument, which is the varargs one. Before entering this method,, +			// the arguments should have been converted to the box form of the required type., +			Object repackagedArgs = Array.newInstance(componentType, arraySize);, +				Array.set(repackagedArgs, i, args[parameterCount - 1 + i]);, +			newArgs[newArgs.length - 1] = repackagedArgs;, +	static enum ArgumentsMatchKind {, +		/** An exact match is where the parameter types exactly match what the method/constructor is expecting */, +		/** A close match is where the parameter types either exactly match or are assignment-compatible */, +	static class ArgumentsMatchInfo {, +		private final ArgumentsMatchKind kind;, +		ArgumentsMatchInfo(ArgumentsMatchKind kind) {, +			return (this.kind == ArgumentsMatchKind.EXACT);, +			return (this.kind == ArgumentsMatchKind.CLOSE);, +			return (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveConstructorResolver.java, + * A constructor resolver that uses reflection to locate the constructor that should be invoked., +	 * <li>An exact match where the types of the arguments match the types of the constructor, +	 * <li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor, +	 * <li>A match where we are able to convert the arguments into those expected by the constructor, according to the, +	 * registered type converter., +					if (matchInfo.isExactMatch()) {, +					else if (matchInfo.isCloseMatch() || matchInfo.isMatchRequiringConversion()) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +		ArgumentsMatchKind match = ArgumentsMatchKind.EXACT;, +						if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +							match = ArgumentsMatchKind.CLOSE;, +						match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +							if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {, +								match = ArgumentsMatchKind.CLOSE;, +							match = ArgumentsMatchKind.REQUIRES_CONVERSION;, +						(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {, +, +			// Now sort out the final argument, which is the varargs one. Before entering this method,, +			// the arguments should have been converted to the box form of the required type., +			Object repackagedArgs = Array.newInstance(componentType, arraySize);, +				Array.set(repackagedArgs, i, args[parameterCount - 1 + i]);, +			newArgs[newArgs.length - 1] = repackagedArgs;, +	static enum ArgumentsMatchKind {, +		/** An exact match is where the parameter types exactly match what the method/constructor is expecting */, +		/** A close match is where the parameter types either exactly match or are assignment-compatible */, +	static class ArgumentsMatchInfo {, +		private final ArgumentsMatchKind kind;, +		ArgumentsMatchInfo(ArgumentsMatchKind kind) {, +			return (this.kind == ArgumentsMatchKind.EXACT);, +			return (this.kind == ArgumentsMatchKind.CLOSE);, +			return (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveConstructorResolver.java, + * A constructor resolver that uses reflection to locate the constructor that should be invoked., +	 * <li>An exact match where the types of the arguments match the types of the constructor, +	 * <li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor, +	 * <li>A match where we are able to convert the arguments into those expected by the constructor, according to the, +	 * registered type converter., +					if (matchInfo.isExactMatch()) {, +					else if (matchInfo.isCloseMatch() || matchInfo.isMatchRequiringConversion()) {]