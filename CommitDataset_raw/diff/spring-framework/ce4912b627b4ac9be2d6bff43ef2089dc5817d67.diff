[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, +	private transient ClassLoader pointcutClassLoader;, +, +			this.pointcutClassLoader = (this.beanFactory instanceof ConfigurableBeanFactory ?, +			this.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);, +		}, +			try {, +			catch (ReflectionWorldException ex) {, +				logger.debug("PointcutExpression matching rejected target class - trying fallback expression", ex);, +				PointcutExpression fallbackExpression = getFallbackPointcutExpression(targetClass);, +				if (fallbackExpression != null) {, +					return fallbackExpression.couldMatchJoinPointsInType(targetClass);, +		return false;, +	 * Get a new pointcut expression based on a target class's loader rather than the default., +		try {, +			if (classLoader != null && classLoader != this.pointcutClassLoader) {, +				return buildPointcutExpression(classLoader);, +			}, +		}, +		catch (Throwable ex) {, +			logger.debug("Failed to create fallback PointcutExpression", ex);, +		}, +		return null;, +				PointcutExpression fallbackExpression = null;, +				shadowMatch = this.shadowMatchCache.get(targetMethod);, +						shadowMatch = this.pointcutExpression.matchesMethodExecution(methodToMatch);, +					catch (ReflectionWorldException ex) {, +						// in a special ClassLoader. Let's try the declaring ClassLoader instead..., +							fallbackExpression = getFallbackPointcutExpression(methodToMatch.getDeclaringClass());, +							if (fallbackExpression != null) {, +								shadowMatch = fallbackExpression.matchesMethodExecution(methodToMatch);, +						catch (ReflectionWorldException ex2) {, +							fallbackExpression = null;, +					}, +					if (shadowMatch == null && targetMethod != originalMethod) {, +							shadowMatch = this.pointcutExpression.matchesMethodExecution(methodToMatch);, +						catch (ReflectionWorldException ex3) {, +							// Could neither introspect the target class nor the proxy class ->, +							// let's try the original method's declaring class before we give up..., +							try {, +								fallbackExpression = getFallbackPointcutExpression(methodToMatch.getDeclaringClass());, +								if (fallbackExpression != null) {, +									shadowMatch = fallbackExpression.matchesMethodExecution(methodToMatch);, +								}, +							}, +							catch (ReflectionWorldException ex4) {, +								fallbackExpression = null;, +							}, +						}, +					}, +					if (shadowMatch == null) {, +					else if (shadowMatch.maybeMatches() && fallbackExpression != null) {, +								fallbackExpression.matchesMethodExecution(methodToMatch));]