[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/AbstractNamedValueMethodArgumentResolver.java, +		Object arg = resolveArgumentInternal(parameter, message, namedValueInfo.name);, +		if (arg == null) {, +				arg = resolveDefaultValue(namedValueInfo.defaultValue);, +			else if (namedValueInfo.required && !parameter.getParameterType().getName().equals("java.util.Optional")) {, +			arg = handleNullValue(namedValueInfo.name, arg, paramType);, +		else if ("".equals(arg) && namedValueInfo.defaultValue != null) {, +			arg = resolveDefaultValue(namedValueInfo.defaultValue);, +		if (!ClassUtils.isAssignableValue(paramType, arg)) {, +			arg = this.conversionService.convert(, +					arg, TypeDescriptor.valueOf(arg.getClass()), new TypeDescriptor(parameter));, +		handleResolvedValue(arg, namedValueInfo.name, parameter, message);, +		return arg;, +			if (name == null) {, +				throw new IllegalArgumentException("Name for argument type [" + parameter.getParameterType().getName() +, +						"] not available, and parameter name information not found in class file either.");, +		}, +		String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/AbstractNamedValueMethodArgumentResolver.java, +		Object arg = resolveArgumentInternal(parameter, message, namedValueInfo.name);, +		if (arg == null) {, +				arg = resolveDefaultValue(namedValueInfo.defaultValue);, +			else if (namedValueInfo.required && !parameter.getParameterType().getName().equals("java.util.Optional")) {, +			arg = handleNullValue(namedValueInfo.name, arg, paramType);, +		else if ("".equals(arg) && namedValueInfo.defaultValue != null) {, +			arg = resolveDefaultValue(namedValueInfo.defaultValue);, +		if (!ClassUtils.isAssignableValue(paramType, arg)) {, +			arg = this.conversionService.convert(, +					arg, TypeDescriptor.valueOf(arg.getClass()), new TypeDescriptor(parameter));, +		handleResolvedValue(arg, namedValueInfo.name, parameter, message);, +		return arg;, +			if (name == null) {, +				throw new IllegalArgumentException("Name for argument type [" + parameter.getParameterType().getName() +, +						"] not available, and parameter name information not found in class file either.");, +		}, +		String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/annotation/support/SimpAnnotationMethodMessageHandlerTests.java, +import java.util.Optional;, +, +import org.springframework.messaging.handler.annotation.DestinationVariable;, +import org.springframework.messaging.handler.annotation.Header;, +import org.springframework.messaging.handler.annotation.Headers;, +import org.springframework.messaging.handler.annotation.MessageExceptionHandler;, +import org.springframework.messaging.handler.annotation.MessageMapping;, +import org.springframework.messaging.handler.annotation.Payload;, +import static org.hamcrest.Matchers.*;, +	public void optionalHeaderArgumentResolutionWhenPresent() {, +		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();, +		headers.setSessionId("session1");, +		headers.setSessionAttributes(new ConcurrentHashMap<>());, +		headers.setDestination("/pre/optionalHeaders");, +		headers.setHeader("foo", "bar");, +		Message<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		this.messageHandler.handleMessage(message);, +, +		assertEquals("optionalHeaders", this.testController.method);, +		assertEquals("bar", this.testController.arguments.get("foo1"));, +		assertEquals("bar", this.testController.arguments.get("foo2"));, +	}, +, +	@Test, +	public void optionalHeaderArgumentResolutionWhenNotPresent() {, +		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();, +		headers.setSessionId("session1");, +		headers.setSessionAttributes(new ConcurrentHashMap<>());, +		headers.setDestination("/pre/optionalHeaders");, +		Message<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		this.messageHandler.handleMessage(message);, +, +		assertEquals("optionalHeaders", this.testController.method);, +		assertNull(this.testController.arguments.get("foo1"));, +		assertNull(this.testController.arguments.get("foo2"));, +	}, +, +	@Test, +		@MessageMapping("/optionalHeaders"), +		public void optionalHeaders(@Header(value="foo", required=false) String foo1, @Header(value="foo") Optional<String> foo2) {, +			this.method = "optionalHeaders";, +			this.arguments.put("foo1", foo1);, +			this.arguments.put("foo2", (foo2.isPresent() ? foo2.get() : null));, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/AbstractNamedValueMethodArgumentResolver.java, +		Object arg = resolveArgumentInternal(parameter, message, namedValueInfo.name);, +		if (arg == null) {, +				arg = resolveDefaultValue(namedValueInfo.defaultValue);, +			else if (namedValueInfo.required && !parameter.getParameterType().getName().equals("java.util.Optional")) {, +			arg = handleNullValue(namedValueInfo.name, arg, paramType);, +		else if ("".equals(arg) && namedValueInfo.defaultValue != null) {, +			arg = resolveDefaultValue(namedValueInfo.defaultValue);, +		if (!ClassUtils.isAssignableValue(paramType, arg)) {, +			arg = this.conversionService.convert(, +					arg, TypeDescriptor.valueOf(arg.getClass()), new TypeDescriptor(parameter));, +		handleResolvedValue(arg, namedValueInfo.name, parameter, message);, +		return arg;, +			if (name == null) {, +				throw new IllegalArgumentException("Name for argument type [" + parameter.getParameterType().getName() +, +						"] not available, and parameter name information not found in class file either.");, +		}, +		String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);]