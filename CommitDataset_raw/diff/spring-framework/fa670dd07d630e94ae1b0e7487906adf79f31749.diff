[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.Constructor;, +		Object target = context.getValue();, +		TypedValue indexValue;, +		Object index;, +		// This first part of the if clause prevents a 'double dereference' of the property (SPR-5847), +		if (target instanceof Map && (this.children[0] instanceof PropertyOrFieldReference)) {, +			// In case the map key is unqualified, we want it evaluated against the root object, +			// so temporarily push that on whilst evaluating the key, +		// Raise a proper exception in case of a null target, +		if (target == null) {, +			throw new SpelEvaluationException(getStartPosition(), SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);, +		}, +		// At this point, we need a TypeDescriptor for a non-null target object, +		Assert.state(targetDescriptor != null, "No type descriptor");, +, +		if (target instanceof Map) {, +			return new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) target, key, targetDescriptor);, +		// If the object is something that looks indexable by an integer,, +		if (target.getClass().isArray() || target instanceof Collection || target instanceof String) {, +			if (target.getClass().isArray()) {, +				return new ArrayIndexingValueRef(state.getTypeConverter(), target, idx, targetDescriptor);, +			else if (target instanceof Collection) {, +				if (target instanceof List) {, +				return new CollectionIndexingValueRef((Collection<?>) target, idx, targetDescriptor,, +				return new StringIndexingLValue((String) target, idx, targetDescriptor);, +		// TODO: could call the conversion service to convert the value to a String, +			return new PropertyIndexingValueRef(, +					target, (String) index, state.getEvaluationContext(), targetDescriptor);, +			// If the string name is changing the accessor is clearly going to change (so no compilation possible), +			return (this.cachedReadAccessor != null &&, +					this.cachedReadAccessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor &&, +					getChild(0) instanceof StringLiteral);, +			mv.visitMethodInsn(, +					INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;", true);, +				throw new SpelEvaluationException(getStartPosition(), ex,, +						SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString());, +			throw new SpelEvaluationException(getStartPosition(),, +					SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString());, +				List<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(, +						contextObjectClass, this.evaluationContext.getPropertyAccessors());, +				throw new SpelEvaluationException(getStartPosition(), ex,, +						SpelMessage.EXCEPTION_DURING_PROPERTY_WRITE, this.name, ex.getMessage());, +		public CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryDescriptor,, +, +			this.collectionEntryDescriptor = collectionEntryDescriptor;, +					throw new SpelEvaluationException(, +							getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);, +					Constructor<?> ctor = ReflectionUtils.accessibleConstructor(elementType.getType());, +						this.collection.add(ctor.newInstance());, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.Constructor;, +		Object target = context.getValue();, +		TypedValue indexValue;, +		Object index;, +		// This first part of the if clause prevents a 'double dereference' of the property (SPR-5847), +		if (target instanceof Map && (this.children[0] instanceof PropertyOrFieldReference)) {, +			// In case the map key is unqualified, we want it evaluated against the root object, +			// so temporarily push that on whilst evaluating the key, +		// Raise a proper exception in case of a null target, +		if (target == null) {, +			throw new SpelEvaluationException(getStartPosition(), SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);, +		}, +		// At this point, we need a TypeDescriptor for a non-null target object, +		Assert.state(targetDescriptor != null, "No type descriptor");, +, +		if (target instanceof Map) {, +			return new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) target, key, targetDescriptor);, +		// If the object is something that looks indexable by an integer,, +		if (target.getClass().isArray() || target instanceof Collection || target instanceof String) {, +			if (target.getClass().isArray()) {, +				return new ArrayIndexingValueRef(state.getTypeConverter(), target, idx, targetDescriptor);, +			else if (target instanceof Collection) {, +				if (target instanceof List) {, +				return new CollectionIndexingValueRef((Collection<?>) target, idx, targetDescriptor,, +				return new StringIndexingLValue((String) target, idx, targetDescriptor);, +		// TODO: could call the conversion service to convert the value to a String, +			return new PropertyIndexingValueRef(, +					target, (String) index, state.getEvaluationContext(), targetDescriptor);, +			// If the string name is changing the accessor is clearly going to change (so no compilation possible), +			return (this.cachedReadAccessor != null &&, +					this.cachedReadAccessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor &&, +					getChild(0) instanceof StringLiteral);, +			mv.visitMethodInsn(, +					INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;", true);, +				throw new SpelEvaluationException(getStartPosition(), ex,, +						SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString());, +			throw new SpelEvaluationException(getStartPosition(),, +					SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE, this.targetObjectTypeDescriptor.toString());, +				List<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(, +						contextObjectClass, this.evaluationContext.getPropertyAccessors());, +				throw new SpelEvaluationException(getStartPosition(), ex,, +						SpelMessage.EXCEPTION_DURING_PROPERTY_WRITE, this.name, ex.getMessage());, +		public CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryDescriptor,, +, +			this.collectionEntryDescriptor = collectionEntryDescriptor;, +					throw new SpelEvaluationException(, +							getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);]