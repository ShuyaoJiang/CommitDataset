[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +	private transient volatile ResolvableType resolvableType;, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +	private transient volatile ResolvableType resolvableType;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		Class<?> resolved = resolve();, +		if (resolved == null || resolved == type) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +			superType = forType(resolved.getGenericSuperclass(), this);, +	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}., +		if (resolved == null) {, +			Type[] genericIfcs = resolved.getGenericInterfaces();, +			interfaces = new ResolvableType[genericIfcs.length];, +			for (int i = 0; i < genericIfcs.length; i++) {, +				interfaces[i] = forType(genericIfcs[i], this);, +			}, +				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();, +				generics = new ResolvableType[typeParams.length];, +				for (int i = 0; i < generics.length; i++) {, +					generics[i] = ResolvableType.forType(typeParams[i], this);, +				}, +		if (bounds.length == 0 || bounds[0] == Object.class) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * owner type., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +	private transient volatile ResolvableType resolvableType;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		Class<?> resolved = resolve();, +		if (resolved == null || resolved == type) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +			superType = forType(resolved.getGenericSuperclass(), this);, +	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}., +		if (resolved == null) {, +			Type[] genericIfcs = resolved.getGenericInterfaces();, +			interfaces = new ResolvableType[genericIfcs.length];, +			for (int i = 0; i < genericIfcs.length; i++) {, +				interfaces[i] = forType(genericIfcs[i], this);, +			}, +				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();, +				generics = new ResolvableType[typeParams.length];, +				for (int i = 0; i < generics.length; i++) {, +					generics[i] = ResolvableType.forType(typeParams[i], this);, +				}, +		if (bounds.length == 0 || bounds[0] == Object.class) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * owner type., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +++ b/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java, + * Alternatively, a regular {@link Class} can also be used as source., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +	private transient volatile ResolvableType resolvableType;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		Class<?> resolved = resolve();, +		if (resolved == null || resolved == type) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +			superType = forType(resolved.getGenericSuperclass(), this);, +	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}., +		if (resolved == null) {, +			Type[] genericIfcs = resolved.getGenericInterfaces();, +			interfaces = new ResolvableType[genericIfcs.length];, +			for (int i = 0; i < genericIfcs.length; i++) {, +				interfaces[i] = forType(genericIfcs[i], this);, +			}, +				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();, +				generics = new ResolvableType[typeParams.length];, +				for (int i = 0; i < generics.length; i++) {, +					generics[i] = ResolvableType.forType(typeParams[i], this);, +				}, +		if (bounds.length == 0 || bounds[0] == Object.class) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * owner type., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +++ b/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java, + * Alternatively, a regular {@link Class} can also be used as source., +++ b/spring-core/src/test/java/org/springframework/core/ResolvableTypeTests.java, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +	private transient volatile ResolvableType resolvableType;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		Class<?> resolved = resolve();, +		if (resolved == null || resolved == type) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}., +			superType = forType(resolved.getGenericSuperclass(), this);, +	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}., +		if (resolved == null) {, +			Type[] genericIfcs = resolved.getGenericInterfaces();, +			interfaces = new ResolvableType[genericIfcs.length];, +			for (int i = 0; i < genericIfcs.length; i++) {, +				interfaces[i] = forType(genericIfcs[i], this);, +			}, +				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();, +				generics = new ResolvableType[typeParams.length];, +				for (int i = 0; i < generics.length; i++) {, +					generics[i] = ResolvableType.forType(typeParams[i], this);, +				}, +		if (bounds.length == 0 || bounds[0] == Object.class) {, +	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.]