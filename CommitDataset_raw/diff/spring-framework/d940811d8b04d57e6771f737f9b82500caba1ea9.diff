[+++ b/org.springframework.core/src/main/java/org/springframework/core/GenericCollectionTypeResolver.java, + * Copyright 2002-2011 the original author or authors., +		return getGenericFieldType(collectionField, Collection.class, 0, null, 1);, +		return getGenericFieldType(collectionField, Collection.class, 0, null, nestingLevel);, +	}, +, +	/**, +	 * Determine the generic element type of the given Collection field., +	 * @param collectionField the collection field to introspect, +	 * @param nestingLevel the nesting level of the target type, +	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the, +	 * nested List, whereas 2 would indicate the element of the nested List), +	 * @param typeIndexesPerLevel Map keyed by nesting level, with each value, +	 * expressing the type index for traversal at that level, +	 * @return the generic type, or <code>null</code> if none, +	 */, +	public static Class<?> getCollectionFieldType(Field collectionField, int nestingLevel, Map<Integer, Integer> typeIndexesPerLevel) {, +		return getGenericFieldType(collectionField, Collection.class, 0, typeIndexesPerLevel, nestingLevel);, +		return getGenericFieldType(mapField, Map.class, 0, null, 1);, +		return getGenericFieldType(mapField, Map.class, 0, null, nestingLevel);, +	}, +, +	/**, +	 * Determine the generic key type of the given Map field., +	 * @param mapField the map field to introspect, +	 * @param nestingLevel the nesting level of the target type, +	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the, +	 * nested List, whereas 2 would indicate the element of the nested List), +	 * @param typeIndexesPerLevel Map keyed by nesting level, with each value, +	 * expressing the type index for traversal at that level, +	 * @return the generic type, or <code>null</code> if none, +	 */, +	public static Class<?> getMapKeyFieldType(Field mapField, int nestingLevel, Map<Integer, Integer> typeIndexesPerLevel) {, +		return getGenericFieldType(mapField, Map.class, 0, typeIndexesPerLevel, nestingLevel);, +		return getGenericFieldType(mapField, Map.class, 1, null, 1);, +		return getGenericFieldType(mapField, Map.class, 1, null, nestingLevel);, +	}, +, +	/**, +	 * Determine the generic value type of the given Map field., +	 * @param mapField the map field to introspect, +	 * @param nestingLevel the nesting level of the target type, +	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the, +	 * nested List, whereas 2 would indicate the element of the nested List), +	 * @param typeIndexesPerLevel Map keyed by nesting level, with each value, +	 * expressing the type index for traversal at that level, +	 * @return the generic type, or <code>null</code> if none, +	 */, +	public static Class<?> getMapValueFieldType(Field mapField, int nestingLevel, Map<Integer, Integer> typeIndexesPerLevel) {, +		return getGenericFieldType(mapField, Map.class, 1, typeIndexesPerLevel, nestingLevel);, +		return extractType(GenericTypeResolver.getTargetType(methodParam), source, typeIndex,, +				methodParam.typeVariableMap, methodParam.typeIndexesPerLevel, methodParam.getNestingLevel(), 1);, +	private static Class<?> getGenericFieldType(Field field, Class<?> source, int typeIndex,, +			Map<Integer, Integer> typeIndexesPerLevel, int nestingLevel) {, +		return extractType(field.getGenericType(), source, typeIndex, null, typeIndexesPerLevel, nestingLevel, 1);, +		return extractType(method.getGenericReturnType(), source, typeIndex, null, null, nestingLevel, 1);, +	private static Class<?> extractType(Type type, Class<?> source, int typeIndex,, +			Map<TypeVariable, Type> typeVariableMap, Map<Integer, Integer> typeIndexesPerLevel,, +			int nestingLevel, int currentLevel) {, +		if (type instanceof TypeVariable && typeVariableMap != null) {, +			Type mappedType = typeVariableMap.get((TypeVariable) type);, +			return extractTypeFromParameterizedType((ParameterizedType) resolvedType, source, typeIndex, typeVariableMap, typeIndexesPerLevel,, +					nestingLevel, currentLevel);, +			return extractTypeFromClass((Class) resolvedType, source, typeIndex, typeVariableMap, typeIndexesPerLevel,, +					nestingLevel, currentLevel);, +		}, +		else if (resolvedType instanceof GenericArrayType) {, +			Type compType = ((GenericArrayType) resolvedType).getGenericComponentType();, +			return extractType(compType, source, typeIndex, typeVariableMap, typeIndexesPerLevel, nestingLevel, currentLevel + 1);, +	private static Class<?> extractTypeFromParameterizedType(ParameterizedType ptype, Class<?> source, int typeIndex,, +			Map<TypeVariable, Type> typeVariableMap, Map<Integer, Integer> typeIndexesPerLevel,, +			int nestingLevel, int currentLevel) {, +			Integer currentTypeIndex = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(nextLevel) : null);, +			return extractType(paramType, source, typeIndex, typeVariableMap, typeIndexesPerLevel, nestingLevel, nextLevel);, +		Class fromSuperclassOrInterface = extractTypeFromClass(rawType, source, typeIndex, typeVariableMap, typeIndexesPerLevel,, +				nestingLevel, currentLevel);, +		if (paramType instanceof TypeVariable && typeVariableMap != null) {, +			Type mappedType = typeVariableMap.get((TypeVariable) paramType);, +		return extractTypeFromClass(clazz, source, typeIndex, null, null, 1, 1);, +	private static Class<?> extractTypeFromClass(Class<?> clazz, Class<?> source, int typeIndex,, +			Map<TypeVariable, Type> typeVariableMap, Map<Integer, Integer> typeIndexesPerLevel,, +			int nestingLevel, int currentLevel) {, +			return extractType(clazz.getGenericSuperclass(), source, typeIndex, typeVariableMap, typeIndexesPerLevel,, +					nestingLevel, currentLevel);, +					return extractType(ifc, source, typeIndex, typeVariableMap, typeIndexesPerLevel, nestingLevel, currentLevel);, +++ b/org.springframework.core/src/main/java/org/springframework/core/GenericCollectionTypeResolver.java, + * Copyright 2002-2011 the original author or authors., +		return getGenericFieldType(collectionField, Collection.class, 0, null, 1);, +		return getGenericFieldType(collectionField, Collection.class, 0, null, nestingLevel);, +	}, +, +	/**, +	 * Determine the generic element type of the given Collection field., +	 * @param collectionField the collection field to introspect, +	 * @param nestingLevel the nesting level of the target type, +	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the, +	 * nested List, whereas 2 would indicate the element of the nested List), +	 * @param typeIndexesPerLevel Map keyed by nesting level, with each value, +	 * expressing the type index for traversal at that level, +	 * @return the generic type, or <code>null</code> if none]