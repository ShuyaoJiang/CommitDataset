[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +			boolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());, +				if (mapped != -1  && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {, +	private boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute,, +			AnnotationTypeMapping mapping) {, +		if (this.annotationValueMappings[index] == -1) {, +			return true;, +		}, +		int existingDepth = this.annotationValueSource[index].depth;, +		return !isValueAttribute && existingDepth > mapping.depth;, +	}, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +			boolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());, +				if (mapped != -1  && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {, +	private boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute,, +			AnnotationTypeMapping mapping) {, +		if (this.annotationValueMappings[index] == -1) {, +			return true;, +		}, +		int existingDepth = this.annotationValueSource[index].depth;, +		return !isValueAttribute && existingDepth > mapping.depth;, +	}, +, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotatedElementUtilsTests.java, +	@Test // gh-22703, +	public void getMergedAnnotationOnThreeDeepMetaWithValue() {, +		ValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(, +				ValueAttributeMetaMetaClass.class, ValueAttribute.class);, +		assertThat(annotation.value()).containsExactly("FromValueAttributeMeta");, +	}, +, +, +	@Retention(RetentionPolicy.RUNTIME), +	static @interface ValueAttribute {, +, +		String[] value();, +, +	}, +, +	@Retention(RetentionPolicy.RUNTIME), +	@ValueAttribute("FromValueAttributeMeta"), +	static @interface ValueAttributeMeta {, +, +		@AliasFor("alias"), +		String[] value() default {};, +, +		@AliasFor("value"), +		String[] alias() default {};, +, +	}, +, +	@Retention(RetentionPolicy.RUNTIME), +	@ValueAttributeMeta("FromValueAttributeMetaMeta"), +	static @interface ValueAttributeMetaMeta {, +	}, +, +	@ValueAttributeMetaMeta, +	static class ValueAttributeMetaMetaClass {, +	}, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java, +			boolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());, +				if (mapped != -1  && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {, +	private boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute,, +			AnnotationTypeMapping mapping) {, +		if (this.annotationValueMappings[index] == -1) {, +			return true;, +		}, +		int existingDepth = this.annotationValueSource[index].depth;, +		return !isValueAttribute && existingDepth > mapping.depth;, +	}, +, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotatedElementUtilsTests.java, +	@Test // gh-22703, +	public void getMergedAnnotationOnThreeDeepMetaWithValue() {, +		ValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(, +				ValueAttributeMetaMetaClass.class, ValueAttribute.class);, +		assertThat(annotation.value()).containsExactly("FromValueAttributeMeta");, +	}, +, +, +	@Retention(RetentionPolicy.RUNTIME), +	static @interface ValueAttribute {, +, +		String[] value();, +, +	}, +, +	@Retention(RetentionPolicy.RUNTIME), +	@ValueAttribute("FromValueAttributeMeta"), +	static @interface ValueAttributeMeta {, +, +		@AliasFor("alias"), +		String[] value() default {};, +, +		@AliasFor("value"), +		String[] alias() default {};, +, +	}]