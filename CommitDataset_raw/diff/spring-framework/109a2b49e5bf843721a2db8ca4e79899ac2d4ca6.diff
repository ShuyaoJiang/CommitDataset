[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4);, +		if (ao.getAnnotations().length > 0) {  // autowiring annotations have to be local, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4);, +		if (ao.getAnnotations().length > 0) {  // autowiring annotations have to be local, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, + * Copyright 2002-2018 the original author or authors., +		if (annotationsToSearch.length > 0) {   // qualifier annotations have to be local, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4);, +		if (ao.getAnnotations().length > 0) {  // autowiring annotations have to be local, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, + * Copyright 2002-2018 the original author or authors., +		if (annotationsToSearch.length > 0) {   // qualifier annotations have to be local, +		}, +++ b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +	private static final Set<Class<? extends Annotation>> CACHE_OPERATION_ANNOTATIONS = new LinkedHashSet<>(8);, +, +	static {, +		CACHE_OPERATION_ANNOTATIONS.add(Cacheable.class);, +		CACHE_OPERATION_ANNOTATIONS.add(CacheEvict.class);, +		CACHE_OPERATION_ANNOTATIONS.add(CachePut.class);, +		CACHE_OPERATION_ANNOTATIONS.add(Caching.class);, +	}, +, +, +		DefaultCacheConfig defaultConfig = new DefaultCacheConfig(type);, +		DefaultCacheConfig defaultConfig = new DefaultCacheConfig(method.getDeclaringClass());, +		if (ops != null && ops.size() > 1) {, +		Collection<? extends Annotation> anns = (localOnly ?, +				AnnotatedElementUtils.getAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS) :, +				AnnotatedElementUtils.findAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS));, +		if (anns.isEmpty()) {, +			return null;, +		final Collection<CacheOperation> ops = new ArrayList<>(1);, +		anns.stream().filter(ann -> ann instanceof Cacheable).forEach(, +				ann -> ops.add(parseCacheableAnnotation(ae, cachingConfig, (Cacheable) ann)));, +		anns.stream().filter(ann -> ann instanceof CacheEvict).forEach(, +				ann -> ops.add(parseEvictAnnotation(ae, cachingConfig, (CacheEvict) ann)));, +		anns.stream().filter(ann -> ann instanceof CachePut).forEach(, +				ann -> ops.add(parsePutAnnotation(ae, cachingConfig, (CachePut) ann)));, +		anns.stream().filter(ann -> ann instanceof Caching).forEach(, +				ann -> parseCachingAnnotation(ae, cachingConfig, (Caching) ann, ops));, +	private CacheableOperation parseCacheableAnnotation(, +			AnnotatedElement ae, DefaultCacheConfig defaultConfig, Cacheable cacheable) {, +	private CacheEvictOperation parseEvictAnnotation(, +			AnnotatedElement ae, DefaultCacheConfig defaultConfig, CacheEvict cacheEvict) {, +, +	private CacheOperation parsePutAnnotation(, +			AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) {, +, +	private void parseCachingAnnotation(, +			AnnotatedElement ae, DefaultCacheConfig defaultConfig, Caching caching, Collection<CacheOperation> ops) {, +	private static class DefaultCacheConfig {, +, +		private final Class<?> target;, +		private String[] cacheNames;, +		private String keyGenerator;, +		private String cacheManager;, +		private String cacheResolver;, +		private boolean initialized = false;, +		public DefaultCacheConfig(Class<?> target) {, +			this.target = target;, +			if (!this.initialized) {, +				CacheConfig annotation = AnnotatedElementUtils.findMergedAnnotation(this.target, CacheConfig.class);, +				if (annotation != null) {, +					this.cacheNames = annotation.cacheNames();, +					this.keyGenerator = annotation.keyGenerator();, +					this.cacheManager = annotation.cacheManager();, +					this.cacheResolver = annotation.cacheResolver();, +				}, +				this.initialized = true;, +			}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4);, +		if (ao.getAnnotations().length > 0) {  // autowiring annotations have to be local, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, + * Copyright 2002-2018 the original author or authors., +		if (annotationsToSearch.length > 0) {   // qualifier annotations have to be local, +		}, +++ b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +	private static final Set<Class<? extends Annotation>> CACHE_OPERATION_ANNOTATIONS = new LinkedHashSet<>(8);, +, +	static {, +		CACHE_OPERATION_ANNOTATIONS.add(Cacheable.class);, +		CACHE_OPERATION_ANNOTATIONS.add(CacheEvict.class);, +		CACHE_OPERATION_ANNOTATIONS.add(CachePut.class);, +		CACHE_OPERATION_ANNOTATIONS.add(Caching.class);, +	}, +, +, +		DefaultCacheConfig defaultConfig = new DefaultCacheConfig(type);, +		DefaultCacheConfig defaultConfig = new DefaultCacheConfig(method.getDeclaringClass());]