[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/HandlerMethod.java, +		return getBeanType().getSimpleName() + "#" + this.method.getName() + "[" + args + " args]";, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/HandlerMethod.java, +		return getBeanType().getSimpleName() + "#" + this.method.getName() + "[" + args + " args]";, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/reactive/MessageMappingMessageHandler.java, +import java.util.Collections;, +import java.util.function.Predicate;, +import org.springframework.context.SmartLifecycle;, +import org.springframework.messaging.ReactiveSubscribableChannel;, + * Extension of {@link AbstractMethodMessageHandler} for reactive, non-blocking, + * handling of messages via {@link MessageMapping @MessageMapping} methods., + * By default such methods are detected in {@code @Controller} Spring beans but, + * that can be changed via {@link #setHandlerPredicate(Predicate)}., + * <p>Payloads for incoming messages are decoded through the configured, + * {@link #setDecoders(List)} decoders, with the help of, + * {@link PayloadMethodArgumentResolver}., + * <p>There is no default handling for return values but, + * {@link #setReturnValueHandlerConfigurer} can be used to configure custom, + * return value handlers. Sub-classes may also override, + * {@link #initReturnValueHandlers()} to set up default return value handlers., + * @see AbstractEncoderMethodReturnValueHandler, +		implements SmartLifecycle, EmbeddedValueResolverAware {, +	private final ReactiveSubscribableChannel inboundChannel;, +	private PathMatcher pathMatcher;, +	private volatile boolean running = false;, +	private final Object lifecycleMonitor = new Object();, +, +, +	public MessageMappingMessageHandler(ReactiveSubscribableChannel inboundChannel) {, +		Assert.notNull(inboundChannel, "`inboundChannel` is required");, +		this.inboundChannel = inboundChannel;, +		this.pathMatcher = new AntPathMatcher();, +		((AntPathMatcher) this.pathMatcher).setPathSeparator(".");, +		setHandlerPredicate(beanType -> AnnotatedElementUtils.hasAnnotation(beanType, Controller.class));, +	 * Configure the decoders to use for incoming payloads., +	 * Return the configured Validator instance., +	@Nullable, +	public Validator getValidator() {, +		return this.validator;, +	 * Set the PathMatcher implementation to use for matching destinations, +	 * against configured destination patterns., +	 * <p>By default, {@link AntPathMatcher} is used with separator set to "."., +	public void setPathMatcher(PathMatcher pathMatcher) {, +		Assert.notNull(pathMatcher, "PathMatcher must not be null");, +		this.pathMatcher = pathMatcher;, +	}, +, +	/**, +	 * Return the PathMatcher implementation to use for matching destinations., +	 */, +	public PathMatcher getPathMatcher() {, +		return this.pathMatcher;, +		return Collections.emptyList();, +	public final void start() {, +		synchronized (this.lifecycleMonitor) {, +			this.inboundChannel.subscribe(this);, +			this.running = true;, +	}, +, +	@Override, +	public final void stop() {, +		synchronized (this.lifecycleMonitor) {, +			this.running = false;, +			this.inboundChannel.unsubscribe(this);, +		}, +	}, +, +	@Override, +	public final void stop(Runnable callback) {, +		synchronized (this.lifecycleMonitor) {, +			stop();, +			callback.run();, +		}, +	}, +, +	@Override, +	public final boolean isRunning() {, +		return this.running;, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/HandlerMethod.java, +		return getBeanType().getSimpleName() + "#" + this.method.getName() + "[" + args + " args]";, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/reactive/MessageMappingMessageHandler.java, +import java.util.Collections;, +import java.util.function.Predicate;, +import org.springframework.context.SmartLifecycle;, +import org.springframework.messaging.ReactiveSubscribableChannel;, + * Extension of {@link AbstractMethodMessageHandler} for reactive, non-blocking, + * handling of messages via {@link MessageMapping @MessageMapping} methods., + * By default such methods are detected in {@code @Controller} Spring beans but, + * that can be changed via {@link #setHandlerPredicate(Predicate)}., + * <p>Payloads for incoming messages are decoded through the configured, + * {@link #setDecoders(List)} decoders, with the help of, + * {@link PayloadMethodArgumentResolver}., + * <p>There is no default handling for return values but, + * {@link #setReturnValueHandlerConfigurer} can be used to configure custom, + * return value handlers. Sub-classes may also override, + * {@link #initReturnValueHandlers()} to set up default return value handlers., + * @see AbstractEncoderMethodReturnValueHandler, +		implements SmartLifecycle, EmbeddedValueResolverAware {]