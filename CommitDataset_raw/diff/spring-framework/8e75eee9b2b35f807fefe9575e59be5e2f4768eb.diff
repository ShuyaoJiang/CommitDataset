[+++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2013 the original author or authors., +		processConstraintViolations(, +				this.targetValidator.validate(target, groups.toArray(new Class[groups.size()])), errors);, +					ConstraintDescriptor<?> cd = violation.getConstraintDescriptor();, +					String errorCode = cd.getAnnotation().annotationType().getSimpleName();, +					Object[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd);, +						// Can do custom FieldError registration with invalid value from ConstraintViolation,, +							if (field.contains(".") && !field.contains("[]")) {, +								// Possibly a bean constraint with property path: retrieve the actual property value., +								// However, explicitly avoid this for "address[]" style paths that we can't handle., +++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2013 the original author or authors., +		processConstraintViolations(, +				this.targetValidator.validate(target, groups.toArray(new Class[groups.size()])), errors);, +					ConstraintDescriptor<?> cd = violation.getConstraintDescriptor();, +					String errorCode = cd.getAnnotation().annotationType().getSimpleName();, +					Object[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd);, +						// Can do custom FieldError registration with invalid value from ConstraintViolation,, +							if (field.contains(".") && !field.contains("[]")) {, +								// Possibly a bean constraint with property path: retrieve the actual property value., +								// However, explicitly avoid this for "address[]" style paths that we can't handle., +++ b/spring-context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java, + * Copyright 2002-2013 the original author or authors., +import javax.validation.Payload;, +import org.springframework.validation.Errors;, +	@Test, +	public void testInnerBeanValidation() throws Exception {, +		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();, +		validator.afterPropertiesSet();, +, +		MainBean mainBean = new MainBean();, +		Errors errors = new BeanPropertyBindingResult(mainBean, "mainBean");, +		validator.validate(mainBean, errors);, +		Object rejected = errors.getFieldValue("inner.value");, +		assertNull(rejected);, +	}, +, +, +	public static class MainBean {, +, +		@InnerValid, +		private InnerBean inner = new InnerBean();, +, +		public InnerBean getInner() {, +			return inner;, +		}, +	}, +, +	public static class InnerBean {, +, +		private String value;, +, +		public String getValue() {, +			return value;, +		}, +		public void setValue(String value) {, +			this.value = value;, +		}, +	}, +, +	@Retention(RetentionPolicy.RUNTIME), +	@Target(ElementType.FIELD), +	@Constraint(validatedBy=InnerValidator.class), +	public static @interface InnerValid {, +		String message() default "NOT VALID";, +		Class<?>[] groups() default { };, +		Class<? extends Payload>[] payload() default {};, +	}, +, +	public static class InnerValidator implements ConstraintValidator<InnerValid, InnerBean> {, +, +		@Override, +		public void initialize(InnerValid constraintAnnotation) {, +		}, +, +		@Override, +		public boolean isValid(InnerBean bean, ConstraintValidatorContext context) {, +			context.disableDefaultConstraintViolation();, +			if (bean.getValue() == null) {, +				context.buildConstraintViolationWithTemplate("NULL"). addNode("value").addConstraintViolation();, +				return false;, +			}, +			return true;, +		}, +	}, +]