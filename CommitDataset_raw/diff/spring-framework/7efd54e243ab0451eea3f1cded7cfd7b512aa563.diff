[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	private ResolvableType superType;, +, +	private ResolvableType[] interfaces;, +, +	private ResolvableType[] generics;, +, +		if (this.superType == null) {, +			this.superType = forType(SerializableTypeWrapper.forGenericSuperclass(resolved),, +					asVariableResolver());, +		}, +		return this.superType;, +		if (this.interfaces == null) {, +			this.interfaces = forTypes(SerializableTypeWrapper.forGenericInterfaces(resolved),, +					asVariableResolver());, +		}, +		return this.interfaces;, +		if (this.generics == null) {, +				this.generics = forTypes(SerializableTypeWrapper.forTypeParameters(typeClass), this.variableResolver);, +			else if (this.type instanceof ParameterizedType) {, +				this.generics = generics;, +			else {, +				this.generics = resolveType().getGenerics();, +			}, +		}, +		return this.generics;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	private ResolvableType superType;, +, +	private ResolvableType[] interfaces;, +, +	private ResolvableType[] generics;, +, +		if (this.superType == null) {, +			this.superType = forType(SerializableTypeWrapper.forGenericSuperclass(resolved),, +					asVariableResolver());, +		}, +		return this.superType;, +		if (this.interfaces == null) {, +			this.interfaces = forTypes(SerializableTypeWrapper.forGenericInterfaces(resolved),, +					asVariableResolver());, +		}, +		return this.interfaces;, +		if (this.generics == null) {, +				this.generics = forTypes(SerializableTypeWrapper.forTypeParameters(typeClass), this.variableResolver);, +			else if (this.type instanceof ParameterizedType) {, +				this.generics = generics;, +			else {, +				this.generics = resolveType().getGenerics();, +			}, +		}, +		return this.generics;, +++ b/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final ConcurrentReferenceHashMap<Type, Type> cache =, +			new ConcurrentReferenceHashMap<Type, Type>(256);, +, +		Type cached = cache.get(provider.getType());, +		if(cached != null) {, +			return cached;, +		}, +				cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);, +				cache.put(provider.getType(), cached);, +				return cached;, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	private ResolvableType superType;, +, +	private ResolvableType[] interfaces;, +, +	private ResolvableType[] generics;, +, +		if (this.superType == null) {, +			this.superType = forType(SerializableTypeWrapper.forGenericSuperclass(resolved),, +					asVariableResolver());, +		}, +		return this.superType;, +		if (this.interfaces == null) {, +			this.interfaces = forTypes(SerializableTypeWrapper.forGenericInterfaces(resolved),, +					asVariableResolver());, +		}, +		return this.interfaces;, +		if (this.generics == null) {, +				this.generics = forTypes(SerializableTypeWrapper.forTypeParameters(typeClass), this.variableResolver);, +			else if (this.type instanceof ParameterizedType) {, +				this.generics = generics;, +			else {, +				this.generics = resolveType().getGenerics();, +			}, +		}, +		return this.generics;, +++ b/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private static final ConcurrentReferenceHashMap<Type, Type> cache =, +			new ConcurrentReferenceHashMap<Type, Type>(256);, +, +		Type cached = cache.get(provider.getType());, +		if(cached != null) {, +			return cached;, +		}, +				cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);]