[+++ b/spring-orm/src/main/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBean.java, + * Copyright 2002-2013 the original author or authors., +		else if (method.getName().equals("createEntityManager") && args != null && args.length > 0 &&, +				args[0] != null && args[0].getClass().isEnum() && "SYNCHRONIZED".equals(args[0].toString())) {, +			// JPA 2.1's createEntityManager(SynchronizationType, Map), +			// Redirect to plain createEntityManager and add synchronization semantics through Spring proxy, +			EntityManager rawEntityManager = (args.length > 1 ?, +					this.nativeEntityManagerFactory.createEntityManager((Map) args[1]) :, +					this.nativeEntityManagerFactory.createEntityManager());, +			return ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, true);, +		}, +, +		// Standard delegation to the native factory, just post-processing EntityManager return values, +			// Any other createEntityManager variant - expecting non-synchronized semantics, +			retVal = ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, false);, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBean.java, + * Copyright 2002-2013 the original author or authors., +		else if (method.getName().equals("createEntityManager") && args != null && args.length > 0 &&, +				args[0] != null && args[0].getClass().isEnum() && "SYNCHRONIZED".equals(args[0].toString())) {, +			// JPA 2.1's createEntityManager(SynchronizationType, Map), +			// Redirect to plain createEntityManager and add synchronization semantics through Spring proxy, +			EntityManager rawEntityManager = (args.length > 1 ?, +					this.nativeEntityManagerFactory.createEntityManager((Map) args[1]) :, +					this.nativeEntityManagerFactory.createEntityManager());, +			return ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, true);, +		}, +, +		// Standard delegation to the native factory, just post-processing EntityManager return values, +			// Any other createEntityManager variant - expecting non-synchronized semantics, +			retVal = ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, false);, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/EntityManagerFactoryUtils.java, +import java.lang.reflect.Method;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ReflectionUtils;, +	private static Method createEntityManagerWithSynchronizationTypeMethod;, +, +	private static Object synchronizationTypeUnsynchronized;, +, +	static {, +		try {, +			@SuppressWarnings("unchecked"), +			Class<Enum> synchronizationTypeClass = (Class<Enum>) ClassUtils.forName(, +					"javax.persistence.SynchronizationType", EntityManagerFactoryUtils.class.getClassLoader());, +			createEntityManagerWithSynchronizationTypeMethod = EntityManagerFactory.class.getMethod(, +					"createEntityManager", synchronizationTypeClass, Map.class);, +			synchronizationTypeUnsynchronized = Enum.valueOf(synchronizationTypeClass, "UNSYNCHRONIZED");, +		}, +		catch (Exception ex) {, +			// No JPA 2.1 API available, +			createEntityManagerWithSynchronizationTypeMethod = null;, +		}, +	}, +, +			return doGetTransactionalEntityManager(emf, properties, true);, +	public static EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map properties), +			throws PersistenceException {, +, +		return doGetTransactionalEntityManager(emf, properties, true);, +	}, +, +	/**, +	 * Obtain a JPA EntityManager from the given factory. Is aware of a, +	 * corresponding EntityManager bound to the current thread,, +	 * for example when using JpaTransactionManager., +	 * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException., +	 * @param emf EntityManagerFactory to create the EntityManager with, +	 * @param properties the properties to be passed into the {@code createEntityManager}, +	 * call (may be {@code null}), +	 * @param synchronizedWithTransaction whether to automatically join ongoing, +	 * transactions (according to the JPA 2.1 SynchronizationType rules), +	 * @return the EntityManager, or {@code null} if none found, +	 * @throws javax.persistence.PersistenceException if the EntityManager couldn't be created, +	 * @see #getTransactionalEntityManager(javax.persistence.EntityManagerFactory), +	 * @see JpaTransactionManager, +	 */, +			EntityManagerFactory emf, Map properties, boolean synchronizedWithTransaction) throws PersistenceException {, +			if (synchronizedWithTransaction) {, +						logger.debug("Could not join transaction because none was actually active", ex);, +							new TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, false));, +				// Use holder's reference count to track synchronizedWithTransaction access., +				// isOpen() check used below to find out about it., +				emHolder.requested();, +			else {, +				// unsynchronized EntityManager demanded, +				if (emHolder.isTransactionActive() && !emHolder.isOpen()) {, +						return null;, +					}, +					// EntityManagerHolder with an active transaction coming from JpaTransactionManager,, +					// with no synchronized EntityManager having been requested by application code before., +					// Unbind in order to register a new unsynchronized EntityManager instead., +					TransactionSynchronizationManager.unbindResource(emf);, +				}, +				else {, +					// Either a previously bound unsynchronized EntityManager, or the application, +					// has requested a synchronized EntityManager before and therefore upgraded, +					// this transaction's EntityManager to synchronized before., +					return emHolder.getEntityManager();, +				}, +			}, +		}]