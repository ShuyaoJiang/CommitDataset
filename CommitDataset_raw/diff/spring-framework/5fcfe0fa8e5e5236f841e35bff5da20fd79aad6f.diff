[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.IntroductionAwareMethodMatcher;, +		Advisor[] advisors = config.getAdvisors();, +		List<Object> interceptorList = new ArrayList<>(advisors.length);, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		Boolean hasIntroductions = null;, +		for (Advisor advisor : advisors) {, +					boolean match;, +					if (mm instanceof IntroductionAwareMethodMatcher) {, +						if (hasIntroductions == null) {, +							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);, +						}, +						match = ((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions);, +					}, +					else {, +						match = mm.matches(method, targetClass);, +					}, +					if (match) {, +						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);, +	private static boolean hasMatchingIntroductions(Advisor[] advisors, Class<?> actualClass) {, +		for (Advisor advisor : advisors) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.IntroductionAwareMethodMatcher;, +		Advisor[] advisors = config.getAdvisors();, +		List<Object> interceptorList = new ArrayList<>(advisors.length);, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		Boolean hasIntroductions = null;, +		for (Advisor advisor : advisors) {, +					boolean match;, +					if (mm instanceof IntroductionAwareMethodMatcher) {, +						if (hasIntroductions == null) {, +							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);, +						}, +						match = ((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions);, +					}, +					else {, +						match = mm.matches(method, targetClass);, +					}, +					if (match) {, +						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);, +	private static boolean hasMatchingIntroductions(Advisor[] advisors, Class<?> actualClass) {, +		for (Advisor advisor : advisors) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapterRegistry.java, +	 * Return an {@link Advisor} wrapping the given advice., +	 * @param advice an object that should be an advice, +	 * @return an Advisor wrapping the given advice (never {@code null};, +	 * if the advice parameter is an Advisor, it is to be returned as-is), +	 * <p>Don't worry about the pointcut associated with the {@link Advisor}, if it is, +	 * a {@link org.springframework.aop.PointcutAdvisor}: just return an interceptor., +	 * not understood by any registered AdvisorAdapter, +	 * Register the given {@link AdvisorAdapter}. Note that it is not necessary to register, +	 * automatically recognized by an {@code AdvisorAdapterRegistry} implementation., +	 * @param adapter an AdvisorAdapter that understands particular Advisor or Advice types, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.IntroductionAwareMethodMatcher;, +		Advisor[] advisors = config.getAdvisors();, +		List<Object> interceptorList = new ArrayList<>(advisors.length);, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		Boolean hasIntroductions = null;, +		for (Advisor advisor : advisors) {, +					boolean match;, +					if (mm instanceof IntroductionAwareMethodMatcher) {, +						if (hasIntroductions == null) {, +							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);, +						}, +						match = ((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions);, +					}, +					else {, +						match = mm.matches(method, targetClass);, +					}, +					if (match) {, +						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);, +	private static boolean hasMatchingIntroductions(Advisor[] advisors, Class<?> actualClass) {, +		for (Advisor advisor : advisors) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapterRegistry.java, +	 * Return an {@link Advisor} wrapping the given advice., +	 * @param advice an object that should be an advice, +	 * @return an Advisor wrapping the given advice (never {@code null};, +	 * if the advice parameter is an Advisor, it is to be returned as-is), +	 * <p>Don't worry about the pointcut associated with the {@link Advisor}, if it is, +	 * a {@link org.springframework.aop.PointcutAdvisor}: just return an interceptor., +	 * not understood by any registered AdvisorAdapter, +	 * Register the given {@link AdvisorAdapter}. Note that it is not necessary to register, +	 * automatically recognized by an {@code AdvisorAdapterRegistry} implementation., +	 * @param adapter an AdvisorAdapter that understands particular Advisor or Advice types, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/BeanFactoryJCacheOperationSourceAdvisor.java, +, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.aop.IntroductionAwareMethodMatcher;, +		Advisor[] advisors = config.getAdvisors();, +		List<Object> interceptorList = new ArrayList<>(advisors.length);, +		Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());, +		Boolean hasIntroductions = null;, +		for (Advisor advisor : advisors) {, +					boolean match;, +					if (mm instanceof IntroductionAwareMethodMatcher) {]