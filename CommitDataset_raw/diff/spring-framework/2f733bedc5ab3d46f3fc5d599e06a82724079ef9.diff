[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +	, +	/**, +	 * Based on {@link MethodInvoker.getTypeDifferenceWeight} but operates on TypeDescriptors., +	 */, +	public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {, +		int result = 0;, +		for (int i = 0,max=paramTypes.size(); i < max; i++) {, +			TypeDescriptor argType = argTypes.get(i);, +			TypeDescriptor paramType = paramTypes.get(i);, +			if (argType==TypeDescriptor.NULL) {, +				if (paramType.isPrimitive()) {, +					return Integer.MAX_VALUE;, +				}, +			}, +			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {, +				return Integer.MAX_VALUE;, +			}, +			if (argType != TypeDescriptor.NULL) {, +				Class paramTypeClazz = paramType.getType();, +				if (paramTypeClazz.isPrimitive()) {, +					paramTypeClazz = Object.class;, +			    }, +				Class superClass = argType.getClass().getSuperclass();, +				while (superClass != null) {, +					if (paramType.equals(superClass)) {, +						result = result + 2;, +						superClass = null;, +					}, +					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {, +						result = result + 2;, +						superClass = superClass.getSuperclass();, +					}, +					else {, +						superClass = null;, +					}, +				}, +				if (paramTypeClazz.isInterface()) {, +					result = result + 1;, +				}, +			}, +		}, +		return result;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +	, +	/**, +	 * Based on {@link MethodInvoker.getTypeDifferenceWeight} but operates on TypeDescriptors., +	 */, +	public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {, +		int result = 0;, +		for (int i = 0,max=paramTypes.size(); i < max; i++) {, +			TypeDescriptor argType = argTypes.get(i);, +			TypeDescriptor paramType = paramTypes.get(i);, +			if (argType==TypeDescriptor.NULL) {, +				if (paramType.isPrimitive()) {, +					return Integer.MAX_VALUE;, +				}, +			}, +			if (!ClassUtils.isAssignable(paramType.getClass(), argType.getClass())) {, +				return Integer.MAX_VALUE;, +			}, +			if (argType != TypeDescriptor.NULL) {, +				Class paramTypeClazz = paramType.getType();, +				if (paramTypeClazz.isPrimitive()) {, +					paramTypeClazz = Object.class;, +			    }, +				Class superClass = argType.getClass().getSuperclass();, +				while (superClass != null) {, +					if (paramType.equals(superClass)) {, +						result = result + 2;, +						superClass = null;, +					}, +					else if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {, +						result = result + 2;, +						superClass = superClass.getSuperclass();, +					}, +					else {, +						superClass = null;, +					}, +				}, +				if (paramTypeClazz.isInterface()) {, +					result = result + 1;, +				}, +			}, +		}, +		return result;, +	}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +	// Using distance will ensure a more accurate match is discovered, , +	// more closely following the Java rules., +	private boolean useDistance = false;, +, +	, +	public ReflectiveMethodResolver() {, +		, +	}, +	, +	/**, +	 * This constructors allows the ReflectiveMethodResolver to be configured such that it will]