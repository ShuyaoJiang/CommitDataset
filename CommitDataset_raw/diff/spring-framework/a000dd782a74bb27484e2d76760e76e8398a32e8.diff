[+++ b/spring-context/src/main/java/org/springframework/context/support/ReloadableResourceBundleMessageSource.java, + * Copyright 2002-2014 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.locks.ReentrantLock;, +public class ReloadableResourceBundleMessageSource extends AbstractMessageSource implements ResourceLoaderAware {, +	private boolean concurrentRefresh = true;, +, +	private final ConcurrentMap<String, Map<Locale, List<String>>> cachedFilenames =, +			new ConcurrentHashMap<String, Map<Locale, List<String>>>();, +	private final ConcurrentMap<String, PropertiesHolder> cachedProperties =, +			new ConcurrentHashMap<String, PropertiesHolder>();, +	private final ConcurrentMap<Locale, PropertiesHolder> cachedMergedProperties =, +			new ConcurrentHashMap<Locale, PropertiesHolder>();, +	 * Specify whether to allow for concurrent refresh behavior, i.e. one thread, +	 * locked in a refresh attempt for a specific cached properties file whereas, +	 * other threads keep returning the old properties for the time being, until, +	 * the refresh attempt has completed., +	 * <p>Default is "true": This behavior is new as of Spring Framework 4.1,, +	 * minimizing contention between threads. If you prefer the old behavior,, +	 * i.e. to fully block on refresh, switch this flag to "false"., +	 * @see #setCacheSeconds, +	 */, +	public void setConcurrentRefresh(boolean concurrentRefresh) {, +		this.concurrentRefresh = concurrentRefresh;, +	}, +, +	/**, +		PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder);, +		if (existing != null) {, +			mergedHolder = existing;, +		return mergedHolder;, +		if (localeMap == null) {, +			localeMap = new ConcurrentHashMap<Locale, List<String>>();, +			Map<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap);, +			if (existing != null) {, +				localeMap = existing;, +		localeMap.put(locale, filenames);, +		long originalTimestamp = -1;, +, +		if (propHolder != null) {, +			originalTimestamp = propHolder.getRefreshTimestamp();, +			if (originalTimestamp < 0 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {, +				// Up to date, +		}, +		else {, +			propHolder = new PropertiesHolder();, +			PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder);, +			if (existingHolder != null) {, +				propHolder = existingHolder;, +			}, +		}, +, +		// At this point, we need to refresh..., +		if (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {, +			// A populated but stale holder -> could keep using it., +			if (!propHolder.refreshLock.tryLock()) {, +				// Getting refreshed by another thread already ->, +				// let's return the existing properties for the time being., +				return propHolder;, +			}, +		}, +		else {, +			propHolder.refreshLock.lock();, +		}, +		try {, +			PropertiesHolder existingHolder = this.cachedProperties.get(filename);, +			if (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {, +				return existingHolder;, +			}, +		finally {, +			propHolder.refreshLock.unlock();, +		}, +						logger.debug(resource + " could not be resolved in the file system - assuming that it hasn't changed", ex);, +		private final Properties properties;, +		private final long fileTimestamp;, +		private volatile long refreshTimestamp = -2;, +, +		private final ReentrantLock refreshLock = new ReentrantLock();, +		private final ConcurrentMap<String, Map<Locale, MessageFormat>> cachedMessageFormats =, +				new ConcurrentHashMap<String, Map<Locale, MessageFormat>>();, +, +		public PropertiesHolder() {, +			this.properties = null;, +			this.fileTimestamp = -1;, +		}, +			return this.properties;, +			return this.fileTimestamp;, +			return this.refreshTimestamp;, +					localeMap = new ConcurrentHashMap<Locale, MessageFormat>();, +					Map<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);, +					if (existing != null) {, +						localeMap = existing;, +					}, +++ b/spring-context/src/main/java/org/springframework/context/support/ReloadableResourceBundleMessageSource.java, + * Copyright 2002-2014 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.locks.ReentrantLock;, +public class ReloadableResourceBundleMessageSource extends AbstractMessageSource implements ResourceLoaderAware {]