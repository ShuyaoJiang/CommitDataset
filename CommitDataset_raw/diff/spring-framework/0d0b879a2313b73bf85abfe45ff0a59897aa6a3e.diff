[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +import java.util.Set;, +		if (logger.isWarnEnabled()) {, +					doValidateClass(proxySuperClass, proxyClassLoader,, +							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass));, +	private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {, +						if (implementsInterface(method, ifcs)) {, +							logger.warn("Unable to proxy interface-implmenting method [" + method + "] because " +, +									"it is marked as final: Consider using interface-based proxies instead!");, +						}, +						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +, +								"Calls to this method will NOT be routed to the target instance and " +, +								"might lead to NPEs against uninitialized fields in the proxy instance.");, +						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +, +								"and cannot get proxied via CGLIB: Declare this method as public or protected " +, +								"if you need to support invocations through the proxy.");, +			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs);, +		// Parameters used for optimization choices..., +		// then we can make some optimizations by sending the AOP calls, +			// TODO: small memory optimization here (can skip creation for methods with no advice), +, +	@Override, +	public boolean equals(Object other) {, +		return (this == other || (other instanceof CglibAopProxy &&, +				AopProxyUtils.equalsInProxy(this.advised, ((CglibAopProxy) other).advised)));, +	}, +, +	@Override, +	public int hashCode() {, +		return CglibAopProxy.class.hashCode() * 13 + this.advised.getTargetSource().hashCode();, +	}, +, +, +	/**, +	 * Check whether the given method is declared on any of the given interfaces., +	 */, +	private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {, +		for (Class<?> ifc : ifcs) {, +			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +						logger.debug("Method has advice and optimizations are enabled: " + method);, +					// We know that we are optimizing so we can use the FixedStaticChainInterceptors., +						logger.debug("Unable to apply any optimizations to advised method: " + method);, +				// See if the return type of the method is outside the class hierarchy of the target type., +				// If so we know it never needs to have return type massage and can use a dispatcher., +				// If the proxy is being exposed, then must use the interceptor the correct one is already, +				// configured. If the target is not static, then we cannot use a dispatcher because the, +				// target needs to be explicitly released after the invocation., +				if (returnType.isAssignableFrom(targetClass)) {, +						logger.debug("Method return type is assignable from target type and " +, +								"may therefore return 'this' - using INVOKE_TARGET: " + method);, +						logger.debug("Method return type ensures 'this' cannot be returned - " +, +								"using DISPATCH_TARGET: " + method);, +					return DISPATCH_TARGET;]