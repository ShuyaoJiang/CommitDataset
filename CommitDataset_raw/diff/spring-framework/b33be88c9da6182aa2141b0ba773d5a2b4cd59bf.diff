[+++ b/org.springframework.core/src/main/java/org/springframework/core/convert/converter/ConverterFactory.java, + * @author Keith Donald, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/converter/ConverterFactory.java, + * @author Keith Donald, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/converter/ConverterRegistry.java, +/*, + * Copyright 2004-2009 the original author or authors., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + *      http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, + * For registering converters with a type conversion system., +	void addConverterFactory(ConverterFactory<?, ?> converterFactory);, +	void removeConverterFactory(ConverterFactory<?, ?> converterFactory);, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/converter/ConverterFactory.java, + * @author Keith Donald, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/converter/ConverterRegistry.java, +/*, + * Copyright 2004-2009 the original author or authors., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + *      http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, + * For registering converters with a type conversion system., +	void addConverterFactory(ConverterFactory<?, ?> converterFactory);, +	void removeConverterFactory(ConverterFactory<?, ?> converterFactory);, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericTypeConverter.java, +import org.springframework.core.convert.ConversionPoint;, +	public void addConverterFactory(ConverterFactory<?, ?> converterFactory) {, +		List typeInfo = getRequiredTypeInfo(converterFactory);, +		Class sourceType = (Class) typeInfo.get(0);, +		Class targetType = (Class) typeInfo.get(1);, +		Map sourceMap = getSourceMap(sourceType);, +		sourceMap.put(targetType, converterFactory);, +		List typeInfo = getRequiredTypeInfo(converter);, +		Class sourceType = (Class) typeInfo.get(0);, +		Class targetType = (Class) typeInfo.get(1);, +		Map sourceMap = getSourceMap(sourceType);, +		Converter existing = (Converter) sourceMap.get(targetType);, +		if (converter == existing) {, +			sourceMap.remove(targetType);, +		}, +	public void removeConverterFactory(ConverterFactory<?, ?> converter) {, +		List typeInfo = getRequiredTypeInfo(converter);, +		Class sourceType = (Class) typeInfo.get(0);, +		Class targetType = (Class) typeInfo.get(1);, +		Map sourceMap = getSourceMap(sourceType);, +		ConverterFactory existing = (ConverterFactory) sourceMap.get(targetType);, +		if (converter == existing) {, +			sourceMap.remove(targetType);, +		}, +					if (Converter.class.isAssignableFrom((Class) pInterface.getRawType()), +							|| ConverterFactory.class.isAssignableFrom((Class) pInterface.getRawType())) {, +				System.out.println("Source:" + currentClass);, +		if (targetType.isInterface()) {, +			LinkedList classQueue = new LinkedList();, +			classQueue.addFirst(targetType);, +			while (!classQueue.isEmpty()) {, +				Class currentClass = (Class) classQueue.removeLast();, +				Converter converter = getConverterImpl(converters, currentClass, targetType);, +				if (converter != null) {, +					return converter;, +				}, +				Class[] interfaces = currentClass.getInterfaces();, +				for (int i = 0; i < interfaces.length; i++) {, +					classQueue.addFirst(interfaces[i]);, +				}, +			}, +			return getConverterImpl(converters, Object.class, targetType);, +		} else {, +			LinkedList classQueue = new LinkedList();, +			classQueue.addFirst(targetType);, +			while (!classQueue.isEmpty()) {, +				Class currentClass = (Class) classQueue.removeLast();, +				Converter converter = getConverterImpl(converters, currentClass, targetType);, +				if (converter != null) {, +					return converter;, +				}, +				if (currentClass.getSuperclass() != null) {, +					classQueue.addFirst(currentClass.getSuperclass());, +				}, +				Class[] interfaces = currentClass.getInterfaces();]