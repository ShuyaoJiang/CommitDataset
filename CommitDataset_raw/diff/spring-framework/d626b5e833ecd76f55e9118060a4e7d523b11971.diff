[+++ b/spring-web-reactive/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +			return this.readPosition == other.readPosition &&, +					this.writePosition == other.writePosition &&, +					this.byteBuffer.equals(other.byteBuffer);, +++ b/spring-web-reactive/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +			return this.readPosition == other.readPosition &&, +					this.writePosition == other.writePosition &&, +					this.byteBuffer.equals(other.byteBuffer);, +++ b/spring-web-reactive/src/main/java/org/springframework/core/io/buffer/support/DataBufferUtils.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.nio.ByteBuffer;, +import java.nio.channels.ReadableByteChannel;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.function.Consumer;, +import org.reactivestreams.Subscriber;, +import org.reactivestreams.Subscription;, +import reactor.core.subscriber.SubscriberWithContext;, +import org.springframework.core.io.buffer.DataBufferAllocator;, +/**i, +	private static final Consumer<? extends Closeable> CLOSE_CONSUMER = closeable -> {, +		try {, +			if (closeable != null) {, +				closeable.close();, +		}, +		catch (IOException ignored) {, +		}, +	};, +	 * Reads the given {@code ReadableByteChannel} into a {@code Flux} of, +	 * {@code DataBuffer}s. Closes the channel when the flux is terminated., +	 * @param channel the channel to read from, +	 * @param allocator the allocator to create data buffers with, +	 * @param bufferSize the maximum size of the data buffers, +	 * @return a flux of data buffers read from the given channel, +	 */, +	public static Flux<DataBuffer> read(ReadableByteChannel channel,, +			DataBufferAllocator allocator, int bufferSize) {, +		Assert.notNull(channel, "'channel' must not be null");, +		Assert.notNull(allocator, "'allocator' must not be null");, +, +		return Flux.create(new ReadableByteChannelConsumer(allocator, bufferSize),, +				subscriber -> channel, closeConsumer());, +	}, +, +	/**, +	 * Reads the given {@code InputStream} into a {@code Flux} of, +	 * {@code DataBuffer}s. Closes the stream when the flux inputStream terminated., +	 * @param inputStream the input stream to read from, +	 * @param allocator the allocator to create data buffers with, +	 * @param bufferSize the maximum size of the data buffers, +	 * @return a flux of data buffers read from the given channel, +	 */, +	public static Flux<DataBuffer> read(InputStream inputStream,, +			DataBufferAllocator allocator, int bufferSize) {, +		Assert.notNull(inputStream, "'inputStream' must not be null");, +		Assert.notNull(allocator, "'allocator' must not be null");, +, +		return Flux.create(new InputStreamConsumer(allocator, bufferSize),, +				subscriber -> inputStream, closeConsumer());, +	}, +, +	@SuppressWarnings("unchecked"), +	private static <T extends Closeable> Consumer<T> closeConsumer() {, +		return (Consumer<T>) CLOSE_CONSUMER;, +	}, +, +	/**, +	 * Relays buffers from the given {@link Publisher} until the total, +	 * {@linkplain DataBuffer#readableByteCount() byte count} reaches the given maximum, +	 * byte count, or until the publisher is complete., +	 * @param publisher the publisher to filter, +	 * @param maxByteCount the maximum byte count, +	 * @return a flux whose maximum byte count is {@code maxByteCount}, +	 */, +	public static Flux<DataBuffer> takeUntilByteCount(Publisher<DataBuffer> publisher,, +			long maxByteCount) {, +		Assert.notNull(publisher, "'publisher' must not be null");, +		Assert.isTrue(maxByteCount >= 0, "'maxByteCount' must be a positive number");, +, +		return Flux.from(publisher).lift(subscriber -> new Subscriber<DataBuffer>() {, +, +			private Subscription subscription;, +, +			private final AtomicLong byteCount = new AtomicLong();, +, +			@Override, +			public void onSubscribe(Subscription s) {, +				this.subscription = s;, +				subscriber.onSubscribe(s);, +			}, +, +			@Override, +			public void onNext(DataBuffer dataBuffer) {, +				long currentCount =, +						this.byteCount.addAndGet(dataBuffer.readableByteCount());, +				if (currentCount > maxByteCount) {, +					int size = (int) (currentCount - maxByteCount + 1);, +					ByteBuffer byteBuffer =, +							(ByteBuffer) dataBuffer.asByteBuffer().limit(size);, +					DataBuffer partialBuffer =]