[+++ b/spring-expression/src/main/java/org/springframework/expression/TypedValue.java, + * Encapsulates an object and a type descriptor that describes it., + * The type descriptor can hold generic information that would not be, + * accessible through a simple {@code getClass()} call on the object., +		str.append("TypedValue: '").append(this.value).append("' of [").append(getTypeDescriptor()).append("]");, +++ b/spring-expression/src/main/java/org/springframework/expression/TypedValue.java, + * Encapsulates an object and a type descriptor that describes it., + * The type descriptor can hold generic information that would not be, + * accessible through a simple {@code getClass()} call on the object., +		str.append("TypedValue: '").append(this.value).append("' of [").append(getTypeDescriptor()).append("]");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		return getValueInternal(evaluationContext, value, targetType, arguments);, +			Object value, TypeDescriptor targetType, Object[] arguments) {, +		MethodExecutor executorToUse = getCachedExecutor(value, targetType, argumentTypes);, +				// At this point we know it wasn't a user problem so worth a retry if a, +		this.cachedExecutor = new CachedMethodExecutor(, +				executorToUse, (value instanceof Class ? (Class<?>) value : null), targetType, argumentTypes);, +			// Make the root object the active context again for evaluating the parameter expressions, +	private MethodExecutor getCachedExecutor(Object value, TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +		if (executorToCheck != null && executorToCheck.isSuitable(value, target, argumentTypes)) {, +	private MethodExecutor findAccessorForMethod(String name, List<TypeDescriptor> argumentTypes,, +			Object targetObject, EvaluationContext evaluationContext) throws SpelEvaluationException {, +							evaluationContext, targetObject, name, argumentTypes);, +							SpelMessage.PROBLEM_LOCATING_METHOD, name, targetObject.getClass());, +						targetObject instanceof Class ? ((Class<?>) targetObject) : targetObject.getClass()));, +			return getValueInternal(this.evaluationContext, this.value, this.targetType, this.arguments);, +		private final Class<?> staticClass;, +, +		public CachedMethodExecutor(MethodExecutor methodExecutor, Class<?> staticClass,, +				TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +			this.staticClass = staticClass;, +		public boolean isSuitable(Object value, TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +			return ((this.staticClass == null || this.staticClass.equals(value)) &&, +++ b/spring-expression/src/main/java/org/springframework/expression/TypedValue.java, + * Encapsulates an object and a type descriptor that describes it., + * The type descriptor can hold generic information that would not be, + * accessible through a simple {@code getClass()} call on the object., +		str.append("TypedValue: '").append(this.value).append("' of [").append(getTypeDescriptor()).append("]");, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		return getValueInternal(evaluationContext, value, targetType, arguments);, +			Object value, TypeDescriptor targetType, Object[] arguments) {, +		MethodExecutor executorToUse = getCachedExecutor(value, targetType, argumentTypes);, +				// At this point we know it wasn't a user problem so worth a retry if a, +		this.cachedExecutor = new CachedMethodExecutor(, +				executorToUse, (value instanceof Class ? (Class<?>) value : null), targetType, argumentTypes);, +			// Make the root object the active context again for evaluating the parameter expressions, +	private MethodExecutor getCachedExecutor(Object value, TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +		if (executorToCheck != null && executorToCheck.isSuitable(value, target, argumentTypes)) {, +	private MethodExecutor findAccessorForMethod(String name, List<TypeDescriptor> argumentTypes,, +			Object targetObject, EvaluationContext evaluationContext) throws SpelEvaluationException {, +							evaluationContext, targetObject, name, argumentTypes);, +							SpelMessage.PROBLEM_LOCATING_METHOD, name, targetObject.getClass());, +						targetObject instanceof Class ? ((Class<?>) targetObject) : targetObject.getClass()));, +			return getValueInternal(this.evaluationContext, this.value, this.targetType, this.arguments);, +		private final Class<?> staticClass;, +, +		public CachedMethodExecutor(MethodExecutor methodExecutor, Class<?> staticClass,, +				TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +			this.staticClass = staticClass;, +		public boolean isSuitable(Object value, TypeDescriptor target, List<TypeDescriptor> argumentTypes) {, +			return ((this.staticClass == null || this.staticClass.equals(value)) &&, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java, +import java.lang.reflect.Array;, +, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.*;, +, +	@Test, +	public void SPR_10452() throws Exception {, +		SpelParserConfiguration configuration = new SpelParserConfiguration(false, false);, +		ExpressionParser parser = new SpelExpressionParser(configuration);, +, +		StandardEvaluationContext context = new StandardEvaluationContext();, +		Expression spel = parser.parseExpression("#enumType.values()");, +, +		context.setVariable("enumType", ABC.class);, +		Object result = spel.getValue(context);, +		assertNotNull(result);, +		assertTrue(result.getClass().isArray());, +		assertEquals(ABC.A, Array.get(result, 0));, +		assertEquals(ABC.B, Array.get(result, 1));, +		assertEquals(ABC.C, Array.get(result, 2));, +, +		context.setVariable("enumType", XYZ.class);, +		result = spel.getValue(context);, +		assertNotNull(result);, +		assertTrue(result.getClass().isArray());, +		assertEquals(XYZ.X, Array.get(result, 0));, +		assertEquals(XYZ.Y, Array.get(result, 1));, +		assertEquals(XYZ.Z, Array.get(result, 2));, +	}, +, +, +, +	private static enum ABC {A, B, C}, +, +	private static enum XYZ {X, Y, Z}, +, +]