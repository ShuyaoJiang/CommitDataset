[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandler.java, +			if (CharSequence.class.isAssignableFrom(elementClass)) {, +				ResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));, +				new TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);, +				return emitter;, +			}, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandler.java, +			if (CharSequence.class.isAssignableFrom(elementClass)) {, +				ResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));, +				new TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);, +				return emitter;, +			}, +++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandlerTests.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.stream.Collectors;, +import static org.springframework.core.ResolvableType.forClass;, +		testDeferredResultSubscriber(mono, Mono.class, forClass(String.class), () -> mono.onNext("foo"), "foo");, +		testDeferredResultSubscriber(monoEmpty, Mono.class, forClass(String.class), monoEmpty::onComplete, null);, +		testDeferredResultSubscriber(single, Single.class, forClass(String.class), () -> ref.get().onSuccess("foo"), "foo");, +		testDeferredResultSubscriber(single2, io.reactivex.Single.class, forClass(String.class), () -> ref2.get().onSuccess("foo"), "foo");, +		testDeferredResultSubscriber(monoEmpty, Mono.class, forClass(String.class), monoEmpty::onComplete, null);, +		Bar bar1 = new Bar("foo");, +		Bar bar2 = new Bar("bar");, +, +		EmitterProcessor<Bar> emitter = EmitterProcessor.create();, +		testDeferredResultSubscriber(emitter, Flux.class, forClass(Bar.class), () -> {, +			emitter.onNext(bar1);, +			emitter.onNext(bar2);, +		}, Arrays.asList(bar1, bar2));, +		testDeferredResultSubscriber(mono, Mono.class, forClass(String.class), () -> mono.onError(ex), ex);, +		testDeferredResultSubscriber(single, Single.class, forClass(String.class), () -> ref.get().onError(ex), ex);, +		testDeferredResultSubscriber(single2, io.reactivex.Single.class, forClass(String.class), () -> ref2.get().onError(ex), ex);, +		ResponseBodyEmitter emitter = handleValue(Flux.empty(), Flux.class, forClass(String.class));, +		SseEmitter sseEmitter = (SseEmitter) handleValue(processor, Flux.class, forClass(String.class));, +		assertEquals("data:foo\n\ndata:bar\n\ndata:baz\n\n", emitterHandler.getValuesAsText());, +	public void writeServerSentEventsWithBuilder() throws Exception {, +				emitterHandler.getValuesAsText());, +		EmitterProcessor<Bar> processor = EmitterProcessor.create();, +		ResponseBodyEmitter emitter = handleValue(processor, Flux.class, forClass(Bar.class));, +		Bar bar1 = new Bar("foo");, +		Bar bar2 = new Bar("bar");, +, +		processor.onNext(bar1);, +		processor.onNext(bar2);, +		assertEquals(Arrays.asList(bar1, "\n", bar2, "\n"), emitterHandler.getValues());, +		ResponseBodyEmitter emitter = handleValue(processor, Flux.class, forClass(String.class));, +		assertEquals("The quick brown fox jumps over the lazy dog", emitterHandler.getValuesAsText());, +	public void writeFluxOfString() throws Exception {, +		// Default to "text/plain", +		testEmitterContentType("text/plain");, +, +		// Same if no concrete media type, +		this.servletRequest.addHeader("Accept", "text/*");, +		testEmitterContentType("text/plain");, +, +		// Otherwise pick concrete media type, +		// Any concrete media type, +		// Including json, +		this.servletRequest.addHeader("Accept", "*/*, text/*, application/json");, +		testEmitterContentType("application/json");, +		ResponseBodyEmitter emitter = handleValue(Flux.empty(), Flux.class, forClass(String.class));, +			ResolvableType elementType, Runnable produceTask, Object expected) throws Exception {, +		ResponseBodyEmitter emitter = handleValue(returnValue, asyncType, elementType);, +		Flux<Bar> handleFlux() { return null; }, +, +		Flux<String> handleFluxString() { return null; }, +		private final List<Object> values = new ArrayList<>();, +		public List<?> getValues() {, +			return this.values;, +		}, +, +		public String getValuesAsText() {, +			return this.values.stream().map(Object::toString).collect(Collectors.joining());, +			this.values.add(data);, +	private static class Bar {, +, +		private final String value;, +, +		public Bar(String value) {, +			this.value = value;, +		}, +, +		public String getValue() {, +			return this.value;, +		}, +	}]