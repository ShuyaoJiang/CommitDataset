[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/ReactorNettyWebSocketSession.java, + * Copyright 2002-2018 the original author or authors., +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +import reactor.core.publisher.MonoProcessor;, +	private final MonoProcessor<WebSocketFrame> closeMono = MonoProcessor.create();, +, +		WebSocketFrame closeFrame = new CloseWebSocketFrame(status.getCode(), status.getReason());, +		return getDelegate().getOutbound().sendObject(closeFrame).then();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/ReactorNettyWebSocketSession.java, + * Copyright 2002-2018 the original author or authors., +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +import reactor.core.publisher.MonoProcessor;, +	private final MonoProcessor<WebSocketFrame> closeMono = MonoProcessor.create();, +, +		WebSocketFrame closeFrame = new CloseWebSocketFrame(status.getCode(), status.getReason());, +		return getDelegate().getOutbound().sendObject(closeFrame).then();, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/socket/WebSocketIntegrationTests.java, + * Copyright 2002-2018 the original author or authors., +	@Test, +	public void sessionClosing() throws Exception {, +		this.client.execute(getUrl("/close"),, +				session -> {, +					logger.debug("Starting..");, +					return session.receive(), +							.doOnNext(s -> logger.debug("inbound " + s)), +							.then(), +							.doFinally(signalType -> {, +								logger.debug("Completed with: " + signalType);, +							});, +				}), +				.block(Duration.ofMillis(5000));, +	}, +, +			map.put("/close", new SessionClosingHandler());, +	private static class SessionClosingHandler implements WebSocketHandler {, +, +		@Override, +		public Mono<Void> handle(WebSocketSession session) {, +			return Flux.never().mergeWith(session.close(CloseStatus.GOING_AWAY)).then();, +		}, +	}, +]