[+++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractSingleValueEncoder.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.io.buffer.PooledDataBuffer;, +		return Flux.from(inputStream), +				.take(1), +				.concatMap(value -> encode(value, bufferFactory, elementType, mimeType, hints)), +				.doOnDiscard(PooledDataBuffer.class, PooledDataBuffer::release);, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractSingleValueEncoder.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.io.buffer.PooledDataBuffer;, +		return Flux.from(inputStream), +				.take(1), +				.concatMap(value -> encode(value, bufferFactory, elementType, mimeType, hints)), +				.doOnDiscard(PooledDataBuffer.class, PooledDataBuffer::release);, +++ b/spring-core/src/main/java/org/springframework/core/codec/ResourceRegionEncoder.java, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +			byte[] contentType = mimeType != null ? getAsciiBytes("Content-Type: " + mimeType + "\r\n") : new byte[0];, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +		return Flux.just(, +				bufferFactory.wrap(startBoundary),, +				bufferFactory.wrap(contentType),, +				bufferFactory.wrap(getContentRangeHeader(region))); // only wrapping, no allocation, +		return Flux.just(bufferFactory.wrap(endBoundary));, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractSingleValueEncoder.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.io.buffer.PooledDataBuffer;, +		return Flux.from(inputStream), +				.take(1), +				.concatMap(value -> encode(value, bufferFactory, elementType, mimeType, hints)), +				.doOnDiscard(PooledDataBuffer.class, PooledDataBuffer::release);, +++ b/spring-core/src/main/java/org/springframework/core/codec/ResourceRegionEncoder.java, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +			byte[] contentType = mimeType != null ? getAsciiBytes("Content-Type: " + mimeType + "\r\n") : new byte[0];, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +		return Flux.just(, +				bufferFactory.wrap(startBoundary),, +				bufferFactory.wrap(contentType),, +				bufferFactory.wrap(getContentRangeHeader(region))); // only wrapping, no allocation, +		return Flux.just(bufferFactory.wrap(endBoundary));, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, + * Copyright 2002-2019 the original author or authors., +	 * @param bufferFactory the factory to create data buffers with, +			Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {, +		Assert.notNull(bufferFactory, "'dataBufferFactory' must not be null");, +				channel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),, +				DataBufferUtils::closeChannel);, +, +		// No doOnDiscard as operators used do not cache, +	 * @param bufferFactory the factory to create data buffers with, +			Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {, +		return readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);, +	 * @param bufferFactory the factory to create data buffers with, +			long position, DataBufferFactory bufferFactory, int bufferSize) {, +		Assert.notNull(bufferFactory, "'dataBufferFactory' must not be null");, +		Flux<DataBuffer> flux = Flux.using(channelSupplier,, +					ReadCompletionHandler handler =, +							new ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize);, +					DataBuffer dataBuffer = bufferFactory.allocateBuffer(bufferSize);, +					ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, bufferSize);, +					channel.read(byteBuffer, position, dataBuffer, handler);, +					sink.onDispose(handler::dispose);, +		return flux.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);, +			WritableByteChannelSubscriber subscriber = new WritableByteChannelSubscriber(sink, channel);, +			WriteCompletionHandler handler = new WriteCompletionHandler(sink, channel, position);, +			sink.onDispose(handler);, +			flux.subscribe(handler);, +, +		// No doOnDiscard as operators used do not cache (and drop) buffers, +	private static class ReadCompletionHandler implements CompletionHandler<Integer, DataBuffer> {, +		public ReadCompletionHandler(AsynchronousFileChannel channel,, +	private static class WriteCompletionHandler extends BaseSubscriber<DataBuffer>, +		public WriteCompletionHandler(, +++ b/spring-core/src/main/java/org/springframework/core/codec/AbstractSingleValueEncoder.java, + * Copyright 2002-2019 the original author or authors., +import org.springframework.core.io.buffer.PooledDataBuffer;, +		return Flux.from(inputStream), +				.take(1), +				.concatMap(value -> encode(value, bufferFactory, elementType, mimeType, hints)), +				.doOnDiscard(PooledDataBuffer.class, PooledDataBuffer::release);, +++ b/spring-core/src/main/java/org/springframework/core/codec/ResourceRegionEncoder.java, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +			byte[] contentType = mimeType != null ? getAsciiBytes("Content-Type: " + mimeType + "\r\n") : new byte[0];, +							return Flux.error(new EncodingException(, +									"Resource " + region.getResource() + " is not readable"));, +		return Flux.just(, +				bufferFactory.wrap(startBoundary),, +				bufferFactory.wrap(contentType),, +				bufferFactory.wrap(getContentRangeHeader(region))); // only wrapping, no allocation, +		return Flux.just(bufferFactory.wrap(endBoundary));, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, + * Copyright 2002-2019 the original author or authors., +	 * @param bufferFactory the factory to create data buffers with, +			Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {, +		Assert.notNull(bufferFactory, "'dataBufferFactory' must not be null");, +				channel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),]