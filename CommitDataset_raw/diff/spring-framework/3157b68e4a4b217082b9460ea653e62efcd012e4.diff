[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +	private final String name;, +, +, +	public MethodReference(boolean nullSafe, String methodName, int pos,, +			SpelNodeImpl... arguments) {, +		this.name = methodName;, +, +		Object[] arguments = getArguments(state);, +		if (state.getActiveContextObject().getValue() == null) {, +			throwIfNotNullSafe(getArgumentTypes(arguments));, +		return new MethodValueRef(state);, +		EvaluationContext evaluationContext = state.getEvaluationContext();, +		Object value = state.getActiveContextObject().getValue();, +		TypeDescriptor targetType = state.getActiveContextObject().getTypeDescriptor();, +		Object[] arguments = getArguments(state);, +		return getValueInternal(evaluationContext, value, arguments, targetType);, +	private TypedValue getValueInternal(EvaluationContext evaluationContext,, +			Object value, Object[] arguments, TypeDescriptor targetType) {, +		List<TypeDescriptor> argumentTypes = getArgumentTypes(arguments);, +, +		if (value == null) {, +			throwIfNotNullSafe(argumentTypes);, +			return TypedValue.NULL;, +		}, +, +		MethodExecutor executorToUse = getCachedExecutor(targetType, argumentTypes);, +, +				return executorToUse.execute(evaluationContext, value, arguments);, +				// 2. the method invoked was not passed the arguments it expected and, +				//    has become 'stale', +				// In the first case we should not retry, in the second case we should see, +				// if there is a better suited method., +				// To determine the situation, the AccessException will contain a cause., +				// If the cause is an InvocationTargetException, a user exception was, +				// thrown inside the method., +				throwSimpleExceptionIfPossible(value, ae);, +				// at this point we know it wasn't a user problem so worth a retry if a, +				// better candidate can be found, +		executorToUse = findAccessorForMethod(this.name, argumentTypes, value, evaluationContext);, +		this.cachedExecutor = new CachedMethodExecutor(executorToUse, targetType,, +				argumentTypes);, +			return executorToUse.execute(evaluationContext,, +					value, arguments);, +		catch (AccessException ex) {, +			throwSimpleExceptionIfPossible(value, ex);, +			throw new SpelEvaluationException(getStartPosition(), ex,, +					SpelMessage.EXCEPTION_DURING_METHOD_INVOCATION, this.name,, +					value.getClass().getName(),, +					ex.getMessage());, +	private void throwIfNotNullSafe(List<TypeDescriptor> argumentTypes) {, +		if (!this.nullSafe) {, +			throw new SpelEvaluationException(getStartPosition(),, +					SpelMessage.METHOD_CALL_ON_NULL_OBJECT_NOT_ALLOWED,, +					FormatHelper.formatMethodForMessage(this.name, argumentTypes));, +		}, +	}, +, +	private Object[] getArguments(ExpressionState state) {, +		Object[] arguments = new Object[getChildCount()];, +		for (int i = 0; i < arguments.length; i++) {, +			// Make the root object the active context again for evaluating the parameter, +			// expressions, +			try {, +				state.pushActiveContextObject(state.getRootContextObject());, +				arguments[i] = this.children[i].getValueInternal(state).getValue();, +			}, +			finally {, +				state.popActiveContextObject();, +			}, +		}, +		return arguments;, +	}, +, +	private List<TypeDescriptor> getArgumentTypes(Object... arguments) {, +		List<TypeDescriptor> descriptors = new ArrayList<TypeDescriptor>(arguments.length);, +		for (Object argument : arguments) {, +			descriptors.add(TypeDescriptor.forObject(argument));, +		}, +		return Collections.unmodifiableList(descriptors);, +	}, +, +	private MethodExecutor getCachedExecutor(TypeDescriptor target,, +			List<TypeDescriptor> argumentTypes) {, +		if (this.cachedExecutor != null && this.cachedExecutor.isSuitable(target, argumentTypes)) {, +			return this.cachedExecutor.get();, +		}, +		this.cachedExecutor = null;, +		return null;, +	}, +, +	private MethodExecutor findAccessorForMethod(String name,, +			List<TypeDescriptor> argumentTypes, Object contextObject,, +			EvaluationContext evaluationContext) throws SpelEvaluationException {, +, +		List<MethodResolver> methodResolvers = evaluationContext.getMethodResolvers();, +		if (methodResolvers != null) {, +			for (MethodResolver methodResolver : methodResolvers) {, +				try {, +					MethodExecutor methodExecutor = methodResolver.resolve(]