[+++ b/spring-web-reactive/src/main/java/org/springframework/reactive/io/ByteBufferPublisherInputStream.java, +import org.reactivestreams.Publisher;, +import org.reactivestreams.Subscription;, +import org.springframework.util.Assert;, +import reactor.Publishers;, +import reactor.core.error.CancelException;, +, + *, + * @author Stephane Maldini, +	private final BlockingQueue<ByteBuffer> queue;, +	 *, +	 *, +	 * on the publisher bound to Integer MAX, +	public ByteBufferPublisherInputStream(Publisher<ByteBuffer> publisher, int requestSize) {, +		this.queue = Publishers.toReadQueue(publisher, requestSize);, +			} else {, +				// take() blocks until next or complete() then return null, but that's OK since this is a *blocking* InputStream, +				ByteBuffer signal = this.queue.take();, +				if(signal == null){, +				this.currentStream = new ByteBufferInputStream(signal);, +				return this.currentStream;, +		}, +		catch (CancelException ce) {, +			this.completed = true;, +			return null;, +		}, +		catch (InterruptedException ex) {, +			Thread.currentThread().interrupt();, +		}, +		catch (Throwable error ){, +			this.completed = true;, +++ b/spring-web-reactive/src/main/java/org/springframework/reactive/io/ByteBufferPublisherInputStream.java, +import org.reactivestreams.Publisher;, +import org.reactivestreams.Subscription;, +import org.springframework.util.Assert;, +import reactor.Publishers;, +import reactor.core.error.CancelException;, +, + *, + * @author Stephane Maldini, +	private final BlockingQueue<ByteBuffer> queue;, +	 *, +	 *, +	 * on the publisher bound to Integer MAX, +	public ByteBufferPublisherInputStream(Publisher<ByteBuffer> publisher, int requestSize) {, +		this.queue = Publishers.toReadQueue(publisher, requestSize);, +			} else {, +				// take() blocks until next or complete() then return null, but that's OK since this is a *blocking* InputStream, +				ByteBuffer signal = this.queue.take();, +				if(signal == null){, +				this.currentStream = new ByteBufferInputStream(signal);, +				return this.currentStream;, +		}, +		catch (CancelException ce) {, +			this.completed = true;, +			return null;, +		}, +		catch (InterruptedException ex) {, +			Thread.currentThread().interrupt();, +		}, +		catch (Throwable error ){, +			this.completed = true;, +++ /dev/null]