[+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {, +		return type.resolveGenerics();, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {, +		return type.resolveGenerics();, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		return (this.resolved != null ? this.resolved : fallback);, +			return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {, +		return type.resolveGenerics();, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		return (this.resolved != null ? this.resolved : fallback);, +			return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);, +++ b/spring-core/src/test/java/org/springframework/core/GenericTypeResolverTests.java, +	public void getGenericsCannotBeResolved() throws Exception {, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);, +		assertNull(resolved);, +	}, +, +	@Test, +	public void getRawMapTypeCannotBeResolved() throws Exception {, +		// SPR-11052, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);, +		assertNull(resolved);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {, +		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {, +		return type.resolveGenerics();, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +		return (this.resolved != null ? this.resolved : fallback);, +			return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);, +++ b/spring-core/src/test/java/org/springframework/core/GenericTypeResolverTests.java, +	public void getGenericsCannotBeResolved() throws Exception {, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);, +		assertNull(resolved);, +	}, +, +	@Test, +	public void getRawMapTypeCannotBeResolved() throws Exception {, +		// SPR-11052, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);, +		assertNull(resolved);, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/adapter/ConvertingEncoderDecoderSupport.java, + * @param <T> the type being converted to (for Encoder) or from (for Decoder), + * @param <M> the WebSocket message type ({@link String} or {@link ByteBuffer}), +		Assert.state(applicationContext != null, "Unable to locate the Spring ApplicationContext");, +			throw new IllegalStateException("Unable to find ConversionService: please configure a '" +, +					CONVERSION_SERVICE_BEAN_NAME + "' or override the getConversionService() method", ex);, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(getClass(), ConvertingEncoderDecoderSupport.class);, +		if (resolved == null) {, +			throw new IllegalStateException("ConvertingEncoderDecoderSupport's generic types T and M " +, +					"need to be substituted in subclass: " + getClass());, +		}, +		return resolved;, +				throw new DecodeException((String) message,, +						"Unable to decode websocket message using ConversionService", ex);, +				throw new DecodeException((ByteBuffer) message,, +						"Unable to decode websocket message using ConversionService", ex);, +	 * A binary {@link javax.websocket.Encoder.Binary javax.websocket.Encoder} that delegates, +	 * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details., +	 * @param <T> the type that this Encoder can convert to, +	public static abstract class BinaryEncoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>, +			implements Encoder.Binary<T> {, +	 * A binary {@link javax.websocket.Encoder.Binary javax.websocket.Encoder} that delegates, +	 * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details., +	 * @param <T> the type that this Decoder can convert from, +	 */, +	public static abstract class BinaryDecoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>, +			implements Decoder.Binary<T> {, +	}, +, +, +	/**, +	 * A text {@link javax.websocket.Encoder.Text javax.websocket.Encoder} that delegates, +	 * @param <T> the type that this Encoder can convert to, +	public static abstract class TextEncoder<T> extends ConvertingEncoderDecoderSupport<T, String>, +			implements Encoder.Text<T> {, +	 * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details., +	 * @param <T> the type that this Decoder can convert from, +	public static abstract class TextDecoder<T> extends ConvertingEncoderDecoderSupport<T, String>, +			implements Decoder.Text<T> {]