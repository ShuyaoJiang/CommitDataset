[+++ b/src/docs/asciidoc/images/spring-mvc-and-webflux-venn.png, +++ b/src/docs/asciidoc/images/spring-mvc-and-webflux-venn.png, +++ b/src/docs/asciidoc/web/webflux.adoc, +=== Motivation, +, +Why was Spring WebFlux created?, +=== Define "reactive", +We touched on non-blocking and functional but what does reactive mean?, +=== Applicability, +Spring MVC or WebFlux?, +A natural question to ask but one that sets up an unsound dichotomy. It's actually both, +working together to expand the range of available options. The two are designed for, +continuity and consistency with each other, they are available side by side, and feedback, +from each side benefits both sides. The diagram below shows how the two relate, what they, +have in common, and what each supports uniquely:, +, +image::images/spring-mvc-and-webflux-venn.png[], +, +Below are some specific points to consider:, +, +* If you have a Spring MVC application that works fine, there is no need to change., +* If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same, +* If you are interested in a lightweight, functional web framework for use with Java 8 lambdas, +* In a microservice architecture you can have a mix of applications with either Spring MVC, +* A simple way to evaluate an application is to check its dependencies. If you have blocking, +* If you have a Spring MVC application with calls to remote services, try the reactive `WebClient`., +* If you have a large team, keep in mind the steep learning curve in the shift to non-blocking,, +We expect that for a wide range of applications the shift is unnecessary. If you are, +unsure what benefits to look for, start by learning about how non-blocking I/O works, +(e.g. concurrency on single-threaded Node.js) and its effects., +=== Servers, +Spring WebFlux is supported on Tomcat, Jetty, Servlet 3.1+ containers, as well as on, +non-Servlet runtimes such as Netty and Undertow. All servers are adapted to a low-level,, +<<webflux-httphandler,common API>> so that higher level, +<<webflux-programming-models,programming models>> can be supported across servers., +Spring WebFlux does not have built-in support to start or stop a server. However it is, +easy to <<webflux-web-handler-api,assemble>> an application from Spring configuration, and, +<<webflux-config,WebFlux infrastructure>>, and <<webflux-httphandler,run it>> with a few, +lines of code., +Spring Boot has a WebFlux starter that automates these steps. By default the starter uses, +Netty but it is easy to switch to Tomcat, Jetty, or Undertow simply by changing your, +Maven or Gradle dependencies. Spring Boot defaults to Netty because it is more widely, +used in the async, non-blocking space, and provides a client and a server share resources., +Tomcat and Jetty can be used with both Spring MVC and WebFlux. Keep in mind however that, +the way they're used is very differently. Spring MVC relies on Servlet blocking I/O and, +allows applications to use the Servlet API directly if they need to. Spring WebFlux, +relies on Servlet 3.1 non-blocking I/O and uses the Servlet API behind a low-level, +adapter and not exposed for direct use., +, +For Undertow, Spring WebFlux uses Undertow APIs directly without the Servlet API., +[[webflux-concurrency-model]], +=== Concurrency Model, +, +Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key, +difference in the concurrency model and default assumptions for blocking and threads., +, +In Spring MVC, and servlet applications in general, it is assumed that applications _may, +block_ the current thread, e.g. for remote calls, and for this reason servlet containers, +use a large thread pool, to absorb potential blocking during request handling., +, +In Spring WebFlux, and non-blocking servers in general, it is assumed that applications, +_will not block_, and therefore non-blocking servers use  a small, fixed-size thread pool, +(event loop workers) to handle requests., +, +[TIP], +====, +To "scale" and "small number of threads" may sound contradictory but to never block the, +current thread, and rely on callbacks instead, means you don't need extra threads as, +there are no blocking calls to absorb., +====, +, +_Invoking a Blocking API_, +, +What if you do need to use a blocking library? Both Reactor and RxJava provide the, +`publishOn` operator to continue processing on a different thread. That means there is an, +easy escape latch. Keep in mind however that blocking APIs are not a good fit for, +this concurrency model., +, +_Mutable State_, +, +In Reactor and RxJava, logic is declared through operators, and at runtime, a reactive, +pipeline is formed where data is processed sequentially, in distinct stages. A key benefit, +of that is that it frees applications from having to protect mutable state because, +application code within that pipeline is never invoked concurrently., +, +_Threading Model_, +, +What threads should you expect to see on a server running with Spring WebFlux?, +, +* On a "vanilla" Spring WebFlux server (e.g. no data access, nor other optional, +dependencies), you can expect one thread for the server, and several others for request, +processing (typically as many as the number of CPU cores). Servlet containers, however,, +may start with more threads (e.g. 10 on Tomcat), in support of both servlet, blocking I/O, +and servlet 3.1, non-blocking I/O usage., +, +* The reactive `WebClient` operates in event loop style. So you'll see a small, fixed, +number of processing threads related to that, e.g. "reactor-http-nio-" with the Reactor, +Netty connector. However if Reactor Netty is used for both client and server, the two, +will share event loop resources by default., +]