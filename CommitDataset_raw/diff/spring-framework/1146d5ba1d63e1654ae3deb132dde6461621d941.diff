[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java, + * Copyright 2002-2014 the original author or authors., + * <li>if {@code a} and {@code b} are defined in different aspects, then the advice, + * in the aspect with the lowest order value has the highest precedence</li>, + * <li>if {@code a} and {@code b} are defined in the same aspect, then if one of, + * {@code a} or {@code b} is a form of after advice, then the advice declared last, + * in the aspect has the highest precedence. If neither {@code a} nor {@code b} is, + * a form of after advice, then the advice declared first in the aspect has the, + * highest precedence.</li>, +, +, +, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java, + * Copyright 2002-2014 the original author or authors., + * <li>if {@code a} and {@code b} are defined in different aspects, then the advice, + * in the aspect with the lowest order value has the highest precedence</li>, + * <li>if {@code a} and {@code b} are defined in the same aspect, then if one of, + * {@code a} or {@code b} is a form of after advice, then the advice declared last, + * in the aspect has the highest precedence. If neither {@code a} nor {@code b} is, + * a form of after advice, then the advice declared first in the aspect has the, + * highest precedence.</li>, +, +, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * Copyright 2002-2014 the original author or authors., + * <li>&#064;Configuration classes must have a default/no-arg constructor and may not use, + * {@link Autowired @Autowired} constructor parameters. Any nested configuration classes, + * must be {@code static}., +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java, + * Copyright 2002-2014 the original author or authors., + * <li>if {@code a} and {@code b} are defined in different aspects, then the advice, + * in the aspect with the lowest order value has the highest precedence</li>, + * <li>if {@code a} and {@code b} are defined in the same aspect, then if one of, + * {@code a} or {@code b} is a form of after advice, then the advice declared last, + * in the aspect has the highest precedence. If neither {@code a} nor {@code b} is, + * a form of after advice, then the advice declared first in the aspect has the, + * highest precedence.</li>, +, +, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * Copyright 2002-2014 the original author or authors., + * <li>&#064;Configuration classes must have a default/no-arg constructor and may not use, + * {@link Autowired @Autowired} constructor parameters. Any nested configuration classes, + * must be {@code static}., +++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +	/** The path separator character '/' */, +	private static final char PATH_SEPARATOR = '/';, +, +			int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);, +				String innerClassName =, +						name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);, +					// Swallow - let original exception get through, +		int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);, +		return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);, +		return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);, +		int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);, +		return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java, + * Copyright 2002-2014 the original author or authors., + * <li>if {@code a} and {@code b} are defined in different aspects, then the advice, + * in the aspect with the lowest order value has the highest precedence</li>, + * <li>if {@code a} and {@code b} are defined in the same aspect, then if one of, + * {@code a} or {@code b} is a form of after advice, then the advice declared last, + * in the aspect has the highest precedence. If neither {@code a} nor {@code b} is, + * a form of after advice, then the advice declared first in the aspect has the, + * highest precedence.</li>, +, +, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * Copyright 2002-2014 the original author or authors., + * <li>&#064;Configuration classes must have a default/no-arg constructor and may not use, + * {@link Autowired @Autowired} constructor parameters. Any nested configuration classes, + * must be {@code static}., +++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +	/** The path separator character '/' */, +	private static final char PATH_SEPARATOR = '/';, +, +			int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);, +				String innerClassName =, +						name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);, +					// Swallow - let original exception get through, +		int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);, +		return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);, +		return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);, +		int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);, +		return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/SpelExpression.java, +	// The default context is used if no override is supplied by the user, +		Assert.notNull(context, "EvaluationContext is required");, +				return this.compiledAst.getValue(contextRoot != null ? contextRoot.getValue() : null, context);, +		Assert.notNull(context, "EvaluationContext is required");, +		Assert.notNull(context, "EvaluationContext is required");, +		ExpressionState expressionState = new ExpressionState(context, this.configuration);, +		TypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor();, +		ExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);, +		TypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor();, +		ExpressionState expressionState =]