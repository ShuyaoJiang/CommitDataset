[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionConstructorExecutor.java, +import org.springframework.expression.EvaluationException;, +		c = constructor;, +			try {, +				ReflectionUtils.convertArguments(c.getParameterTypes(), c.isVarArgs(), context.getTypeUtils(), +						.getTypeConverter(), argsRequiringConversion, arguments);, +			} catch (EvaluationException ex) {, +				throw new AccessException("Problem invoking constructor on '" + c + "': " + ex.getMessage(), ex);, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionConstructorExecutor.java, +import org.springframework.expression.EvaluationException;, +		c = constructor;, +			try {, +				ReflectionUtils.convertArguments(c.getParameterTypes(), c.isVarArgs(), context.getTypeUtils(), +						.getTypeConverter(), argsRequiringConversion, arguments);, +			} catch (EvaluationException ex) {, +				throw new AccessException("Problem invoking constructor on '" + c + "': " + ex.getMessage(), ex);, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionMethodExecutor.java, +import org.springframework.expression.EvaluationException;, +		m = theMethod;, +		argsRequiringConversion = argumentsRequiringConversion;, +			try {, +				ReflectionUtils.convertArguments(m.getParameterTypes(), m.isVarArgs(), context.getTypeUtils(), +						.getTypeConverter(), argsRequiringConversion, arguments);, +			} catch (EvaluationException ex) {, +				throw new AccessException("Problem invoking method '" + m.getName() + "' on '" + target.getClass(), +						+ "': " + ex.getMessage(), ex);, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionConstructorExecutor.java, +import org.springframework.expression.EvaluationException;, +		c = constructor;, +			try {, +				ReflectionUtils.convertArguments(c.getParameterTypes(), c.isVarArgs(), context.getTypeUtils(), +						.getTypeConverter(), argsRequiringConversion, arguments);, +			} catch (EvaluationException ex) {, +				throw new AccessException("Problem invoking constructor on '" + c + "': " + ex.getMessage(), ex);, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionMethodExecutor.java, +import org.springframework.expression.EvaluationException;, +		m = theMethod;, +		argsRequiringConversion = argumentsRequiringConversion;, +			try {, +				ReflectionUtils.convertArguments(m.getParameterTypes(), m.isVarArgs(), context.getTypeUtils(), +						.getTypeConverter(), argsRequiringConversion, arguments);, +			} catch (EvaluationException ex) {, +				throw new AccessException("Problem invoking method '" + m.getName() + "' on '" + target.getClass(), +						+ "': " + ex.getMessage(), ex);, +			}, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/reflection/ReflectionUtils.java, +					matchInfo = compareArgumentsVarargs(method.getParameterTypes(), argumentTypes, typeConverter,, +							conversionAllowed);, +					matchInfo = compareArguments(method.getParameterTypes(), argumentTypes, typeConverter,, +							conversionAllowed);, +				// Basically.. we have to have all parameters match up until the varargs one, then the rest of what is, +				// being provided should be, +				// the same type whilst the final argument to the method must be an array of that (oh, how easy...not) -, +				// or the final parameter, +				ArgumentsMatchInfo matchInfo = compareArgumentsVarargs(ctor.getParameterTypes(), argumentTypes,, +						typeConverter, conversionAllowed);, +	private static ArgumentsMatchInfo compareArgumentsVarargs(Class[] expectedArgTypes, Class[] suppliedArgTypes,, +			TypeConverter typeConverter, boolean conversionAllowed) {, +		// Special case: there is one parameter left and it is an array and it matches the varargs expected argument -, +		// that is a match, the caller has already built the array, +		if (suppliedArgTypes.length == expectedArgTypes.length, +				&& expectedArgTypes[expectedArgTypes.length - 1] == suppliedArgTypes[suppliedArgTypes.length - 1]) {, +			// Now... we have the final argument in the method we are checking as a match and we have 0 or more other, +			// arguments left to pass to it., +					if (varargsParameterType.isAssignableFrom(suppliedArg), +							|| areBoxingCompatible(varargsParameterType, suppliedArg), +			argsRequiringConversion = integers;, +			argumentsRequiringConversion = argsToConvert;, +			argumentsRequiringConversion = argsToConvert;, +	static void convertArguments(Class[] parameterTypes, boolean isVarargs, TypeConverter converter,, +			Integer[] argsRequiringConversion, Object... arguments) throws EvaluationException {, +			// try {, +			// } catch (EvaluationException e) {, +			// throw new SpelException(e, SpelMessages.PROBLEM_DURING_TYPE_CONVERSION, "Converter failed to convert '", +			// + arguments[argPosition] + " to type '" + targetType + "'");, +			// }, +	static void convertArguments(Class[] parameterTypes, boolean isVarargs, TypeConverter converter,, +			Object... arguments) throws EvaluationException {, +				throw new SpelException(e, SpelMessages.PROBLEM_DURING_TYPE_CONVERSION, "Converter failed to convert '", +						+ arguments[i] + " to type '" + targetType + "'");, +	 * Package up the arguments so that they correctly match what is expected in parameterTypes. For example, if, +	 * parameterTypes is (int, String[]) because the second parameter was declared String... then if arguments is, +	 * [1,"a","b"] then it must be repackaged as [1,new String[]{"a","b"}] in order to match the expected, +	 * parameterTypes., +		if (nParams != arguments.length, +				|| parameterTypes[nParams - 1] != (arguments[nArgs - 1] == null ? null : arguments[nArgs - 1], +						.getClass())) {, +			Object[] repackagedArguments = (Object[]) Array.newInstance(parameterTypes[nParams - 1].getComponentType(),, +					arraySize);, +	public static Object[] prepareArguments(TypeConverter converter, Method m, Object[] arguments), +			throws EvaluationException {]