[+++ b/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageWriter.java, + * Copyright 2002-2017 the original author or authors., +import org.springframework.core.codec.ResourceRegionEncoder;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import static java.util.Collections.emptyMap;, +, + * {@code HttpMessageWriter} that can write a {@link Resource}., + * <p>Also an implementation of {@code ServerHttpMessageWriter} with support, + * for writing one or more {@link ResourceRegion}'s based on the HTTP ranges, + * specified in the request., + *, + * <p>For reading to a Resource, use {@link ResourceDecoder} wrapped with, + * @author Rossen Stoyanchev, + * @see ResourceEncoder, + * @see ResourceRegionEncoder, + * @see HttpRange, +public class ResourceHttpMessageWriter implements ServerHttpMessageWriter<Resource> {, +	private static final ResolvableType REGION_TYPE = ResolvableType.forClass(ResourceRegion.class);, +, +	private final ResourceEncoder encoder;, +, +	private final ResourceRegionEncoder regionEncoder;, +, +	private final List<MediaType> mediaTypes;, +		this(ResourceEncoder.DEFAULT_BUFFER_SIZE);, +		this.encoder = new ResourceEncoder(bufferSize);, +		this.regionEncoder = new ResourceRegionEncoder(bufferSize);, +		this.mediaTypes = MediaType.asMediaTypes(this.encoder.getEncodableMimeTypes());, +	public boolean canWrite(ResolvableType elementType, MediaType mediaType) {, +		return this.encoder.canEncode(elementType, mediaType);, +	}, +	@Override, +	public List<MediaType> getWritableMediaTypes() {, +		return this.mediaTypes;, +, +, +	// HttpMessageWriter (client and server): single Resource, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		return Mono.from(inputStream).then(resource ->, +				writeResource(resource, elementType, mediaType, message, hints));, +	private Mono<Void> writeResource(Resource resource, ResolvableType type, MediaType mediaType,, +			ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		HttpHeaders headers = message.getHeaders();, +		MediaType resourceMediaType = getResourceMediaType(mediaType, resource);, +		headers.setContentType(resourceMediaType);, +			lengthOf(resource).ifPresent(headers::setContentLength);, +		return zeroCopy(resource, null, message), +				.orElseGet(() -> {, +					Mono<Resource> input = Mono.just(resource);, +					DataBufferFactory factory = message.bufferFactory();, +					Flux<DataBuffer> body = this.encoder.encode(input, factory, type, resourceMediaType, hints);, +					return message.writeWith(body);, +				});, +	}, +, +	private static MediaType getResourceMediaType(MediaType type, Resource resource) {, +		if (type != null && type.isConcrete() && !type.equals(MediaType.APPLICATION_OCTET_STREAM)) {, +			return type;, +		}, +		type = MediaTypeFactory.getMediaType(resource);, +		return type != null ? type : MediaType.APPLICATION_OCTET_STREAM;, +	}, +, +	private static OptionalLong lengthOf(Resource resource) {, +		// Don't consume InputStream..., +	private static Optional<Mono<Void>> zeroCopy(Resource resource, ResourceRegion region,, +			ReactiveHttpOutputMessage message) {, +		if (message instanceof ZeroCopyHttpOutputMessage) {, +					File file = resource.getFile();, +					long pos = region != null ? region.getPosition() : 0;, +					long count = region != null ? region.getCount() : file.length();, +					return Optional.of(((ZeroCopyHttpOutputMessage) message).writeWith(file, pos, count));, +		}, +, +	// ServerHttpMessageWriter (server only): single Resource or sub-regions, +, +	@Override, +	@SuppressWarnings("unchecked"), +	public Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType streamType,, +			ResolvableType elementType, MediaType mediaType, ServerHttpRequest request,, +			ServerHttpResponse response, Map<String, Object> hints) {, +, +		HttpHeaders headers = response.getHeaders();, +		headers.set(HttpHeaders.ACCEPT_RANGES, "bytes");, +, +		List<HttpRange> ranges;, +		try {, +			ranges = request.getHeaders().getRange();, +		}, +		catch (IllegalArgumentException ex) {, +			response.setStatusCode(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE);, +			return response.setComplete();, +		}, +, +		return Mono.from(inputStream).then(resource -> {, +, +			if (ranges.isEmpty()) {, +				return writeResource(resource, elementType, mediaType, response, hints);, +			}]