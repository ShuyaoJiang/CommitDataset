[+++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/JacksonJsonEncoder.java, +import reactor.Mono;, +		Publisher<ByteBuffer> stream = (inputStream instanceof Mono ?, +				((Mono<?>)inputStream).map(this::serialize) :, +				Flux.from(inputStream).map(this::serialize));, +		return (this.postProcessor == null ? Flux.from(stream) : this.postProcessor.encode(stream, type, mimeType, hints));, +	}, +, +	private ByteBuffer serialize(Object value) {, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/JacksonJsonEncoder.java, +import reactor.Mono;, +		Publisher<ByteBuffer> stream = (inputStream instanceof Mono ?, +				((Mono<?>)inputStream).map(this::serialize) :, +				Flux.from(inputStream).map(this::serialize));, +		return (this.postProcessor == null ? Flux.from(stream) : this.postProcessor.encode(stream, type, mimeType, hints));, +	}, +, +	private ByteBuffer serialize(Object value) {, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/JsonObjectEncoder.java, +import reactor.Mono;, + * Encode a byte stream of individual JSON element to a byte stream representing:, + *  - the same JSON object than the input stream if it is a {@link Mono}, + *  - a JSON array for other kinds of {@link Publisher}, +	public Flux<ByteBuffer> encode(Publisher<? extends ByteBuffer> inputStream,, +		if (inputStream instanceof Mono) {, +			return Flux.from(inputStream);, +		}, +		return Flux.from(inputStream).lift(s -> new JsonArrayEncoderBarrier(s));, +	private static class JsonArrayEncoderBarrier extends SubscriberBarrier<ByteBuffer, ByteBuffer> {, +		static final AtomicLongFieldUpdater<JsonArrayEncoderBarrier> REQUESTED =, +				AtomicLongFieldUpdater.newUpdater(JsonArrayEncoderBarrier.class, "requested");, +		static final AtomicIntegerFieldUpdater<JsonArrayEncoderBarrier> TERMINATED =, +				AtomicIntegerFieldUpdater.newUpdater(JsonArrayEncoderBarrier.class, "terminated");, +		public JsonArrayEncoderBarrier(Subscriber<? super ByteBuffer> subscriber) {, +			if (this.count == 1) {, +			if (tmp != null) {, +			}, +			if (this.count > 1) {, +			}, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/JacksonJsonEncoder.java, +import reactor.Mono;, +		Publisher<ByteBuffer> stream = (inputStream instanceof Mono ?, +				((Mono<?>)inputStream).map(this::serialize) :, +				Flux.from(inputStream).map(this::serialize));, +		return (this.postProcessor == null ? Flux.from(stream) : this.postProcessor.encode(stream, type, mimeType, hints));, +	}, +, +	private ByteBuffer serialize(Object value) {, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/support/JsonObjectEncoder.java, +import reactor.Mono;, + * Encode a byte stream of individual JSON element to a byte stream representing:, + *  - the same JSON object than the input stream if it is a {@link Mono}, + *  - a JSON array for other kinds of {@link Publisher}, +	public Flux<ByteBuffer> encode(Publisher<? extends ByteBuffer> inputStream,, +		if (inputStream instanceof Mono) {, +			return Flux.from(inputStream);, +		}, +		return Flux.from(inputStream).lift(s -> new JsonArrayEncoderBarrier(s));, +	private static class JsonArrayEncoderBarrier extends SubscriberBarrier<ByteBuffer, ByteBuffer> {, +		static final AtomicLongFieldUpdater<JsonArrayEncoderBarrier> REQUESTED =, +				AtomicLongFieldUpdater.newUpdater(JsonArrayEncoderBarrier.class, "requested");, +		static final AtomicIntegerFieldUpdater<JsonArrayEncoderBarrier> TERMINATED =, +				AtomicIntegerFieldUpdater.newUpdater(JsonArrayEncoderBarrier.class, "terminated");, +		public JsonArrayEncoderBarrier(Subscriber<? super ByteBuffer> subscriber) {, +			if (this.count == 1) {, +			if (tmp != null) {, +			}, +			if (this.count > 1) {, +			}, +++ b/spring-web-reactive/src/test/java/org/springframework/reactive/codec/encoder/JsonObjectEncoderTests.java, +import reactor.Flux;, +import reactor.Mono;, +	public void encodeSingleElementFlux() throws InterruptedException {, +		Flux<ByteBuffer> source = Flux.just(Buffer.wrap("{\"foo\": \"foofoo\", \"bar\": \"barbar\"}").byteBuffer());, +		Iterable<String> results = Flux.from(encoder.encode(source, null, null)).map(chunk -> {, +		}).toIterable();, +		String result = String.join("", results);, +		assertEquals("[{\"foo\": \"foofoo\", \"bar\": \"barbar\"}]", result);, +	}, +, +	@Test, +	public void encodeSingleElementMono() throws InterruptedException {, +		JsonObjectEncoder encoder = new JsonObjectEncoder();, +		Mono<ByteBuffer> source = Mono.just(Buffer.wrap("{\"foo\": \"foofoo\", \"bar\": \"barbar\"}").byteBuffer());, +		Iterable<String> results = Flux.from(encoder.encode(source, null, null)).map(chunk -> {, +			byte[] b = new byte[chunk.remaining()];, +			chunk.get(b);, +			return new String(b, StandardCharsets.UTF_8);, +		}).toIterable();, +	public void encodeTwoElementsFlux() throws InterruptedException {, +		Flux<ByteBuffer> source = Flux.just(, +		Iterable<String> results = Flux.from(encoder.encode(source, null, null)).map(chunk -> {, +		}).toIterable();, +	public void encodeThreeElementsFlux() throws InterruptedException {, +		Flux<ByteBuffer> source = Flux.just(, +		Iterable<String> results = Flux.from(encoder.encode(source, null, null)).map(chunk -> {, +		}).toIterable();]