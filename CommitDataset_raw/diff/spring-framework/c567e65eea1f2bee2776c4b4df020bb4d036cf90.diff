[+++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/WiretapConnector.java, +					this.request.getRecorder().getContent(), this.response.getRecorder().getContent(), uriTemplate);, +		}, +	}, +, +, +	/**, +	 * Tap into a Publisher of data buffers to save the content., +	 */, +	final static class WiretapRecorder {, +, +		private static final DataBufferFactory bufferFactory = new DefaultDataBufferFactory();, +, +		public static final byte[] EMPTY_CONTENT = new byte[0];, +, +, +		@Nullable, +		private final Publisher<? extends DataBuffer> publisher;, +, +		@Nullable, +		private final Publisher<? extends Publisher<? extends DataBuffer>> publisherNested;, +, +		private final DataBuffer buffer;, +, +		private final MonoProcessor<byte[]> content;, +, +, +		private WiretapRecorder(@Nullable Publisher<? extends DataBuffer> publisher,, +				@Nullable Publisher<? extends Publisher<? extends DataBuffer>> publisherNested) {, +, +			if (publisher != null && publisherNested != null) {, +				throw new IllegalArgumentException("At most one publisher expected");, +			}, +, +			this.publisher = publisher != null ?, +					Flux.from(publisher), +							.doOnNext(this::handleOnNext), +							.doOnError(this::handleOnError), +							.doOnCancel(this::handleOnComplete), +							.doOnComplete(this::handleOnComplete) : null;, +, +			this.publisherNested = publisherNested != null ?, +					Flux.from(publisherNested), +							.map(p -> Flux.from(p).doOnNext(this::handleOnNext).doOnError(this::handleOnError)), +							.doOnError(this::handleOnError), +							.doOnCancel(this::handleOnComplete), +							.doOnComplete(this::handleOnComplete) : null;, +, +			this.buffer =  bufferFactory.allocateBuffer();, +			this.content = MonoProcessor.create();, +, +			if (this.publisher == null && this.publisherNested == null) {, +				this.content.onNext(EMPTY_CONTENT);, +			}, +		}, +, +, +		public Publisher<? extends DataBuffer> getPublisherToUse() {, +			Assert.notNull(this.publisher, "Publisher not in use.");, +			return this.publisher;, +		}, +, +		public Publisher<? extends Publisher<? extends DataBuffer>> getNestedPublisherToUse() {, +			Assert.notNull(this.publisherNested, "Nested publisher not in use.");, +			return this.publisherNested;, +		}, +, +		public MonoProcessor<byte[]> getContent() {, +			return this.content;, +		}, +, +, +		private void handleOnNext(DataBuffer nextBuffer) {, +			this.buffer.write(nextBuffer);, +		}, +, +		private void handleOnError(Throwable ex) {, +			if (!this.content.isTerminated()) {, +				this.content.onError(ex);, +			}, +		}, +, +		private void handleOnComplete() {, +			if (!this.content.isTerminated()) {, +				byte[] bytes = new byte[this.buffer.readableByteCount()];, +				this.buffer.read(bytes);, +				this.content.onNext(bytes);, +			}, +		@Nullable, +		private WiretapRecorder recorder;, +		public WiretapRecorder getRecorder() {, +			Assert.notNull(this.recorder, "No WiretapRecorder: was the client request written?");, +			return this.recorder;, +			this.recorder = new WiretapRecorder(publisher, null);, +			return super.writeWith(this.recorder.getPublisherToUse());, +			this.recorder = new WiretapRecorder(null, publisher);, +			return super.writeAndFlushWith(this.recorder.getNestedPublisherToUse());, +			this.recorder = new WiretapRecorder(null, null);, +		private final WiretapRecorder recorder;, +			this.recorder = new WiretapRecorder(super.getBody(), null);]