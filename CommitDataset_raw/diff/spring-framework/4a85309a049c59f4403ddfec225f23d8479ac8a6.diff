[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.beans.factory.BeanNotOfRequiredTypeException;, +					raiseNoMatchingBeanFound(type, descriptor.getResolvableType().toString(), descriptor);, +	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException, +	 * for an unresolvable dependency., +	private void raiseNoMatchingBeanFound(, +			Class<?> type, String dependencyDescription, DependencyDescriptor descriptor) throws BeansException {, +, +		checkBeanNotOfRequiredType(type, descriptor);, +	/**, +	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,, +	 * i.e. if the target type of the bean would match but an exposed proxy doesn't., +	 */, +	private void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {, +		for (String beanName : this.beanDefinitionNames) {, +			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);, +			Class<?> targetType = mbd.getTargetType();, +			if (targetType != null && type.isAssignableFrom(targetType) &&, +					isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {, +				// Probably a poxy interfering with target type match -> throw meaningful exception., +				Object beanInstance = getSingleton(beanName, false);, +				Class<?> beanType = (beanInstance != null ? beanInstance.getClass() : predictBeanType(beanName, mbd));, +				if (type != beanType) {, +					throw new BeanNotOfRequiredTypeException(beanName, type, beanType);, +				}, +			}, +		}, +, +		if (getParentBeanFactory() instanceof DefaultListableBeanFactory) {, +			((DefaultListableBeanFactory) getParentBeanFactory()).checkBeanNotOfRequiredType(type, descriptor);, +		}, +	}, +, +	/**, +	 * Create an {@link Optional} wrapper for the specified dependency., +	 */, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +import org.springframework.beans.factory.BeanNotOfRequiredTypeException;, +					raiseNoMatchingBeanFound(type, descriptor.getResolvableType().toString(), descriptor);, +	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException, +	 * for an unresolvable dependency., +	private void raiseNoMatchingBeanFound(, +			Class<?> type, String dependencyDescription, DependencyDescriptor descriptor) throws BeansException {, +, +		checkBeanNotOfRequiredType(type, descriptor);, +	/**, +	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,, +	 * i.e. if the target type of the bean would match but an exposed proxy doesn't., +	 */, +	private void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {, +		for (String beanName : this.beanDefinitionNames) {, +			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);, +			Class<?> targetType = mbd.getTargetType();, +			if (targetType != null && type.isAssignableFrom(targetType) &&, +					isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {, +				// Probably a poxy interfering with target type match -> throw meaningful exception., +				Object beanInstance = getSingleton(beanName, false);, +				Class<?> beanType = (beanInstance != null ? beanInstance.getClass() : predictBeanType(beanName, mbd));, +				if (type != beanType) {, +					throw new BeanNotOfRequiredTypeException(beanName, type, beanType);, +				}, +			}, +		}, +, +		if (getParentBeanFactory() instanceof DefaultListableBeanFactory) {, +			((DefaultListableBeanFactory) getParentBeanFactory()).checkBeanNotOfRequiredType(type, descriptor);, +		}, +	}, +, +	/**, +	 * Create an {@link Optional} wrapper for the specified dependency., +	 */, +++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/EnableAsyncTests.java, +import org.springframework.beans.factory.BeanNotOfRequiredTypeException;, +import org.springframework.beans.factory.UnsatisfiedDependencyException;, +import org.springframework.stereotype.Component;, +	public void properExceptionForExistingProxyDependencyMismatch() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(AsyncConfig.class, AsyncBeanWithInterface.class, AsyncBeanUser.class);, +, +		try {, +			ctx.refresh();, +			fail("Should have thrown UnsatisfiedDependencyException");, +		}, +		catch (UnsatisfiedDependencyException ex) {, +			ex.printStackTrace();, +			assertTrue(ex.getCause() instanceof BeanNotOfRequiredTypeException);, +		}, +	}, +, +	@Test, +	public void properExceptionForResolvedProxyDependencyMismatch() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(AsyncConfig.class, AsyncBeanUser.class, AsyncBeanWithInterface.class);, +, +		try {, +			ctx.refresh();, +			fail("Should have thrown UnsatisfiedDependencyException");, +		}, +		catch (UnsatisfiedDependencyException ex) {]