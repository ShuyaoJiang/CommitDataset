[+++ b/spring-web/src/main/java/org/springframework/web/context/request/ServletWebRequest.java, +import java.text.ParseException;, +import java.text.SimpleDateFormat;, +import java.util.Arrays;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.TimeZone;, +, +	private static final String ETAG = "ETag";, +	private static final String IF_MODIFIED_SINCE = "If-Modified-Since";, +	private static final String IF_UNMODIFIED_SINCE = "If-Unmodified-Since";, +	private static final String IF_NONE_MATCH = "If-None-Match";, +	private static final String LAST_MODIFIED = "Last-Modified";, +	private static final List<String> SAFE_METHODS = Arrays.asList("GET", "HEAD");, +	/**, +	 * Date formats as specified in the HTTP RFC, +	 * @see <a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.1">Section 7.1.1.1 of RFC 7231</a>, +	 */, +	private static final String[] DATE_FORMATS = new String[] {, +			"EEE, dd MMM yyyy HH:mm:ss zzz",, +			"EEE, dd-MMM-yy HH:mm:ss zzz",, +			"EEE MMM dd HH:mm:ss yyyy", +	};, +, +	private static TimeZone GMT = TimeZone.getTimeZone("GMT");, +		return checkNotModified(null, lastModifiedTimestamp);, +		return checkNotModified(etag, -1);, +		if (this.notModified || HttpStatus.OK.value() != response.getStatus()) {, +			return this.notModified;, +, +		// Evaluate conditions in order of precedence., +		// See https://tools.ietf.org/html/rfc7232#section-6, +, +		if (validateIfUnmodifiedSince(lastModifiedTimestamp)) {, +				response.setStatus(HttpStatus.PRECONDITION_FAILED.value());, +		boolean validated = validateIfNoneMatch(etag);, +, +		if (!validated) {, +			validateIfModifiedSince(lastModifiedTimestamp);, +		}, +, +		// Update response, +, +		boolean isHttpGetOrHead = SAFE_METHODS.contains(getRequest().getMethod());, +		if (this.notModified) {, +			response.setStatus(isHttpGetOrHead ?, +					HttpStatus.NOT_MODIFIED.value() : HttpStatus.PRECONDITION_FAILED.value());, +		}, +		if (isHttpGetOrHead) {, +			if(lastModifiedTimestamp > 0 && parseDateValue(response.getHeader(LAST_MODIFIED)) == -1) {, +				response.setDateHeader(LAST_MODIFIED, lastModifiedTimestamp);, +			}, +			if (StringUtils.hasLength(etag) && response.getHeader(ETAG) == null) {, +				response.setHeader(ETAG, padEtagIfNecessary(etag));, +			}, +		}, +, +		return this.notModified;, +	}, +, +	private boolean validateIfUnmodifiedSince(long lastModifiedTimestamp) {, +		if (lastModifiedTimestamp < 0) {, +			return false;, +		}, +		long ifUnmodifiedSince = parseDateHeader(IF_UNMODIFIED_SINCE);, +		if (ifUnmodifiedSince == -1) {, +			return false;, +		}, +		// We will perform this validation..., +		this.notModified = (ifUnmodifiedSince < (lastModifiedTimestamp / 1000 * 1000));, +		return true;, +	}, +, +	private boolean validateIfNoneMatch(String etag) {, +		if (!StringUtils.hasLength(etag)) {, +			return false;, +		}, +		Enumeration<String> ifNoneMatch;, +		try {, +			ifNoneMatch = getRequest().getHeaders(IF_NONE_MATCH);, +		}, +		catch (IllegalArgumentException ex) {, +			return false;, +		}, +		if (!ifNoneMatch.hasMoreElements()) {, +			return false;, +		}, +		// We will perform this validation..., +		etag = padEtagIfNecessary(etag);, +		while (ifNoneMatch.hasMoreElements()) {, +			String clientETags = ifNoneMatch.nextElement();, +, +			Matcher eTagMatcher = ETAG_HEADER_VALUE_PATTERN.matcher(clientETags);, +			// Compare weak/strong ETags as per https://tools.ietf.org/html/rfc7232#section-2.3, +			while (eTagMatcher.find()) {, +				if (StringUtils.hasLength(eTagMatcher.group()), +						&& etag.replaceFirst("^W/", "").equals(eTagMatcher.group(3))) {, +					this.notModified = true;, +					break;, +				}]