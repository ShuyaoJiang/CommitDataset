[+++ b/spring-test/src/main/java/org/springframework/test/context/MetaAnnotationUtils.java, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +				T annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +					return new AnnotationDescriptor<T>(clazz, composedAnnotation, annotation);, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +					Annotation annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +						return new UntypedAnnotationDescriptor(clazz, composedAnnotation, annotation);, +	 * the {@linkplain #getComposedAnnotation() composed annotation} on which the, +	 * annotation is present. In such cases, the <em>root declaring class</em> is, +	 * not directly annotated with the annotation but rather indirectly via the, +	 * composed annotation., +	 *   <li>composedAnnotation: {@code null}</li>, +	 *   <li>composedAnnotation: instance of the {@code RepositoryTests} annotation</li>, +		private final Annotation composedAnnotation;, +		public AnnotationDescriptor(Class<?> rootDeclaringClass, Annotation composedAnnotation, T annotation) {, +			this.declaringClass = (composedAnnotation != null) ? composedAnnotation.annotationType(), +					: rootDeclaringClass;, +			this.composedAnnotation = composedAnnotation;, +		public Annotation getComposedAnnotation() {, +			return this.composedAnnotation;, +		public Class<? extends Annotation> getComposedAnnotationType() {, +			return this.composedAnnotation == null ? null : this.composedAnnotation.annotationType();, +			.append("composedAnnotation", composedAnnotation)//, +		public UntypedAnnotationDescriptor(Class<?> declaringClass, Annotation composedAnnotation, Annotation annotation) {, +			super(declaringClass, composedAnnotation, annotation);, +++ b/spring-test/src/main/java/org/springframework/test/context/MetaAnnotationUtils.java, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +				T annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +					return new AnnotationDescriptor<T>(clazz, composedAnnotation, annotation);, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +					Annotation annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +						return new UntypedAnnotationDescriptor(clazz, composedAnnotation, annotation);, +	 * the {@linkplain #getComposedAnnotation() composed annotation} on which the, +	 * annotation is present. In such cases, the <em>root declaring class</em> is, +	 * not directly annotated with the annotation but rather indirectly via the, +	 * composed annotation., +	 *   <li>composedAnnotation: {@code null}</li>, +	 *   <li>composedAnnotation: instance of the {@code RepositoryTests} annotation</li>, +		private final Annotation composedAnnotation;, +		public AnnotationDescriptor(Class<?> rootDeclaringClass, Annotation composedAnnotation, T annotation) {, +			this.declaringClass = (composedAnnotation != null) ? composedAnnotation.annotationType(), +					: rootDeclaringClass;, +			this.composedAnnotation = composedAnnotation;, +		public Annotation getComposedAnnotation() {, +			return this.composedAnnotation;, +		public Class<? extends Annotation> getComposedAnnotationType() {, +			return this.composedAnnotation == null ? null : this.composedAnnotation.annotationType();, +			.append("composedAnnotation", composedAnnotation)//, +		public UntypedAnnotationDescriptor(Class<?> declaringClass, Annotation composedAnnotation, Annotation annotation) {, +			super(declaringClass, composedAnnotation, annotation);, +++ b/spring-test/src/test/java/org/springframework/test/context/MetaAnnotationUtilsTests.java, +			Class<? extends Annotation> composedAnnotationType) {, +		assertNotNull(descriptor.getComposedAnnotation());, +		assertEquals(composedAnnotationType, descriptor.getComposedAnnotationType());, +			String name, Class<? extends Annotation> composedAnnotationType) {, +		assertNotNull(descriptor.getComposedAnnotation());, +		assertEquals(composedAnnotationType, descriptor.getComposedAnnotationType());, +		assertNull(descriptor.getComposedAnnotation());, +		assertNull(descriptor.getComposedAnnotationType());, +		assertEquals(, +			InheritedAnnotationClass.class,, +		assertEquals(, +			NonInheritedAnnotationInterface.class,, +		assertNull(descriptor.getComposedAnnotation());, +		assertNull(descriptor.getComposedAnnotationType());, +		assertNotNull(descriptor.getComposedAnnotation());, +		assertEquals(MetaConfig.class, descriptor.getComposedAnnotationType());, +		assertNotNull(descriptor.getComposedAnnotation());, +		assertEquals(MetaConfig.class, descriptor.getComposedAnnotationType());, +++ b/spring-test/src/main/java/org/springframework/test/context/MetaAnnotationUtils.java, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +				T annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +					return new AnnotationDescriptor<T>(clazz, composedAnnotation, annotation);, +		// Declared on a composed annotation (i.e., as a meta-annotation)?, +			for (Annotation composedAnnotation : clazz.getAnnotations()) {, +					Annotation annotation = composedAnnotation.annotationType().getAnnotation(annotationType);, +						return new UntypedAnnotationDescriptor(clazz, composedAnnotation, annotation);, +	 * the {@linkplain #getComposedAnnotation() composed annotation} on which the, +	 * annotation is present. In such cases, the <em>root declaring class</em> is, +	 * not directly annotated with the annotation but rather indirectly via the, +	 * composed annotation., +	 *   <li>composedAnnotation: {@code null}</li>, +	 *   <li>composedAnnotation: instance of the {@code RepositoryTests} annotation</li>, +		private final Annotation composedAnnotation;, +		public AnnotationDescriptor(Class<?> rootDeclaringClass, Annotation composedAnnotation, T annotation) {, +			this.declaringClass = (composedAnnotation != null) ? composedAnnotation.annotationType(), +					: rootDeclaringClass;, +			this.composedAnnotation = composedAnnotation;, +		public Annotation getComposedAnnotation() {, +			return this.composedAnnotation;, +		public Class<? extends Annotation> getComposedAnnotationType() {, +			return this.composedAnnotation == null ? null : this.composedAnnotation.annotationType();, +			.append("composedAnnotation", composedAnnotation)//, +		public UntypedAnnotationDescriptor(Class<?> declaringClass, Annotation composedAnnotation, Annotation annotation) {, +			super(declaringClass, composedAnnotation, annotation);]