[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * @see AnnotationUtils#retrieveAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean), +			return (found ? AnnotationUtils.retrieveAnnotationAttributes(annotatedElement, annotation,, +					this.classValuesAsString, this.nestedAnnotationsAsMap) : null);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * @see AnnotationUtils#retrieveAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean), +			return (found ? AnnotationUtils.retrieveAnnotationAttributes(annotatedElement, annotation,, +					this.classValuesAsString, this.nestedAnnotationsAsMap) : null);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +import java.util.LinkedHashMap;, +		AnnotationAttributes attributes =, +				retrieveAnnotationAttributes(annotatedElement, annotation, classValuesAsString, nestedAnnotationsAsMap);, +		postProcessAnnotationAttributes(annotatedElement, attributes, classValuesAsString, nestedAnnotationsAsMap);, +		return attributes;, +	 * only intended for use within the framework. The following special rules apply:, +	 * <li>Default values will be replaced with default value placeholders.</li>, +	static AnnotationAttributes retrieveAnnotationAttributes(AnnotatedElement annotatedElement, Annotation annotation,, +			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +		AnnotationAttributes attributes = new AnnotationAttributes(annotationType);, +, +				Object attributeValue = method.invoke(annotation);, +				if (defaultValue != null && ObjectUtils.nullSafeEquals(attributeValue, defaultValue)) {, +					attributeValue = new DefaultValueHolder(defaultValue);, +				attributes.put(method.getName(),, +						adaptValue(annotatedElement, attributeValue, classValuesAsString, nestedAnnotationsAsMap));, +, +		return attributes;, +					mappedAnnotations[i] =, +							getAnnotationAttributes(annotatedElement, annotations[i], classValuesAsString, true);, +	 * Post-process the supplied {@link AnnotationAttributes}., +	 * <p>Specifically, this method enforces <em>attribute alias</em> semantics, +	 * for annotation attributes that are annotated with {@link AliasFor @AliasFor}, +	 * and replaces default value placeholders with their original default values., +	 * @param annotatedElement the element that is annotated with an annotation or, +	 * annotation hierarchy from which the supplied attributes were created;, +	 * may be {@code null} if unknown, +	 * @param attributes the annotation attributes to post-process, +	 * @param classValuesAsString whether to convert Class references into Strings (for, +	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata}), +	 * or to preserve them as Class references, +	 * @param nestedAnnotationsAsMap whether to convert nested annotations into, +	 * {@link AnnotationAttributes} maps (for compatibility with, +	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as, +	 * {@code Annotation} instances, +	 * @since 4.2, +	 * @see #retrieveAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean), +	 * @see #getDefaultValue(Class, String), +	 */, +	static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement,, +			AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +, +		// Abort?, +		if (attributes == null) {, +			return;, +		}, +, +		Class<? extends Annotation> annotationType = attributes.annotationType();, +, +		// Track which attribute values have already been replaced so that we can short, +		// circuit the search algorithms., +		Set<String> valuesAlreadyReplaced = new HashSet<String>();, +, +		// Validate @AliasFor configuration, +		Map<String, List<String>> aliasMap = getAttributeAliasMap(annotationType);, +		for (String attributeName : aliasMap.keySet()) {, +			if (valuesAlreadyReplaced.contains(attributeName)) {, +				continue;, +			}, +			Object value = attributes.get(attributeName);, +			boolean valuePresent = (value != null && !(value instanceof DefaultValueHolder));, +, +			for (String aliasedAttributeName : aliasMap.get(attributeName)) {, +				if (valuesAlreadyReplaced.contains(aliasedAttributeName)) {, +					continue;, +				}, +, +				Object aliasedValue = attributes.get(aliasedAttributeName);, +				boolean aliasPresent = (aliasedValue != null && !(aliasedValue instanceof DefaultValueHolder));, +, +				// Something to validate or replace with an alias?, +				if (valuePresent || aliasPresent) {, +					if (valuePresent && aliasPresent) {, +						// Since annotation attributes can be arrays, we must use ObjectUtils.nullSafeEquals()., +						if (!ObjectUtils.nullSafeEquals(value, aliasedValue)) {, +							String elementAsString = (annotatedElement != null ? annotatedElement.toString() : "unknown element");, +							throw new AnnotationConfigurationException(String.format(, +									"In AnnotationAttributes for annotation [%s] declared on %s, " +, +											"attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " +, +											"but only one is permitted.", annotationType.getName(), elementAsString,, +									attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value),, +									ObjectUtils.nullSafeToString(aliasedValue)));, +						}, +					}, +					else if (aliasPresent) {, +						// Replace value with aliasedValue, +						attributes.put(attributeName,, +								adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap));, +						valuesAlreadyReplaced.add(attributeName);, +					}, +					else {]