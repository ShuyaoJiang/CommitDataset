[+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.java, +import java.lang.reflect.Method;, +, +import javax.servlet.ServletContext;, +, +import org.springframework.mock.web.MockHttpServletRequest;, +import org.springframework.test.web.servlet.MvcResult;, +import org.springframework.util.ReflectionUtils;, +	/**, +	 * Create a {@link RequestBuilder} for an async dispatch from the, +	 * {@link MvcResult} of the request that started async processing., +	 *, +	 * <p>Usage involves performing one request first that starts async processing:, +	 * <pre>, +	 * MvcResult mvcResult = this.mockMvc.perform(get("/1")), +	 *	.andExpect(request().asyncStarted()), +	 *	.andReturn();, +	 *  </pre>, +	 *, +	 * <p>And then performing the async dispatch re-using the {@code MvcResult}:, +	 * <pre>, +	 * this.mockMvc.perform(asyncDispatch(mvcResult)), +	 * 	.andExpect(status().isOk()), +	 * 	.andExpect(content().contentType(MediaType.APPLICATION_JSON)), +	 * 	.andExpect(content().string("{\"name\":\"Joe\",\"someDouble\":0.0,\"someBoolean\":false}"));, +	 * </pre>, +	 *, +	 * @param mvcResult the result from the request that started async processing, +	 */, +	public static RequestBuilder asyncDispatch(final MvcResult mvcResult) {, +		return new RequestBuilder() {, +			public MockHttpServletRequest buildRequest(ServletContext servletContext) {, +				MockHttpServletRequest request = mvcResult.getRequest();, +				Method method = ReflectionUtils.findMethod(request.getClass(), "setAsyncStarted", boolean.class);, +				method.setAccessible(true);, +				ReflectionUtils.invokeMethod(method, request, false);, +				return request;, +			}, +		};, +	}, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.java, +import java.lang.reflect.Method;, +, +import javax.servlet.ServletContext;, +, +import org.springframework.mock.web.MockHttpServletRequest;, +import org.springframework.test.web.servlet.MvcResult;, +import org.springframework.util.ReflectionUtils;, +	/**, +	 * Create a {@link RequestBuilder} for an async dispatch from the, +	 * {@link MvcResult} of the request that started async processing., +	 *, +	 * <p>Usage involves performing one request first that starts async processing:, +	 * <pre>, +	 * MvcResult mvcResult = this.mockMvc.perform(get("/1")), +	 *	.andExpect(request().asyncStarted()), +	 *	.andReturn();, +	 *  </pre>, +	 *, +	 * <p>And then performing the async dispatch re-using the {@code MvcResult}:, +	 * <pre>, +	 * this.mockMvc.perform(asyncDispatch(mvcResult)), +	 * 	.andExpect(status().isOk()), +	 * 	.andExpect(content().contentType(MediaType.APPLICATION_JSON)), +	 * 	.andExpect(content().string("{\"name\":\"Joe\",\"someDouble\":0.0,\"someBoolean\":false}"));, +	 * </pre>, +	 *, +	 * @param mvcResult the result from the request that started async processing, +	 */, +	public static RequestBuilder asyncDispatch(final MvcResult mvcResult) {, +		return new RequestBuilder() {, +			public MockHttpServletRequest buildRequest(ServletContext servletContext) {, +				MockHttpServletRequest request = mvcResult.getRequest();, +				Method method = ReflectionUtils.findMethod(request.getClass(), "setAsyncStarted", boolean.class);, +				method.setAccessible(true);, +				ReflectionUtils.invokeMethod(method, request, false);, +				return request;, +			}, +		};, +	}, +, +++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/standalone/AsyncTests.java, +import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.asyncDispatch;, +import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;, +import java.util.Collection;, +import java.util.concurrent.CopyOnWriteArrayList;, +import org.springframework.http.MediaType;, +import org.springframework.test.web.servlet.MvcResult;, +import org.springframework.ui.Model;, +import org.springframework.web.bind.annotation.ResponseBody;, +	private AsyncController asyncController;, +, +, +		this.asyncController = new AsyncController();, +		this.mockMvc = standaloneSetup(this.asyncController).build();, +		MvcResult mvcResult = this.mockMvc.perform(get("/1").param("callable", "true")), +			.andExpect(request().asyncResult(new Person("Joe"))), +			.andReturn();, +]