[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, +		/** Map from destination -> <sessionId, subscriptionId> for fast look-ups */, +		private final Map<String, MultiValueMap<String, String>> accessCache =, +				new ConcurrentHashMap<String, MultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT);, +, +		/** Map from destination -> <sessionId, subscriptionId> with locking */, +		private final Map<String, MultiValueMap<String, String>> updateCache =, +			return this.accessCache.get(destination);, +			synchronized (this.updateCache) {, +				this.updateCache.put(destination, subscriptions);, +				this.accessCache.put(destination, new LinkedMultiValueMap<String, String>(subscriptions));, +			synchronized(this.updateCache) {, +				for (String cachedDestination : this.updateCache.keySet()) {, +						MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +						subs.add(sessionId, subsId);, +						this.accessCache.put(cachedDestination, new LinkedMultiValueMap<String, String>(subs));, +			synchronized(this.updateCache) {, +				for (String cachedDestination : this.updateCache.keySet()) {, +						MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +						List<String> subsIds = subs.get(sessionId);, +							subs.remove(sessionId);, +						if (subs.isEmpty()) {, +							this.updateCache.remove(cachedDestination);, +							this.accessCache.remove(cachedDestination);, +						}, +						else {, +							this.accessCache.put(cachedDestination, new LinkedMultiValueMap<String, String>(subs));, +			synchronized(this.updateCache) {, +					for (String cachedDestination : this.updateCache.keySet()) {, +							MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +							subs.remove(info.getSessionId());, +							if (subs.isEmpty()) {, +								this.updateCache.remove(cachedDestination);, +								this.accessCache.remove(cachedDestination);, +							}, +							else {, +								this.accessCache.put(cachedDestination,new LinkedMultiValueMap<String, String>(subs));, +			return "[cache=" + this.accessCache + "]";, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, +		/** Map from destination -> <sessionId, subscriptionId> for fast look-ups */, +		private final Map<String, MultiValueMap<String, String>> accessCache =, +				new ConcurrentHashMap<String, MultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT);, +, +		/** Map from destination -> <sessionId, subscriptionId> with locking */, +		private final Map<String, MultiValueMap<String, String>> updateCache =, +			return this.accessCache.get(destination);, +			synchronized (this.updateCache) {, +				this.updateCache.put(destination, subscriptions);, +				this.accessCache.put(destination, new LinkedMultiValueMap<String, String>(subscriptions));, +			synchronized(this.updateCache) {, +				for (String cachedDestination : this.updateCache.keySet()) {, +						MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +						subs.add(sessionId, subsId);, +						this.accessCache.put(cachedDestination, new LinkedMultiValueMap<String, String>(subs));, +			synchronized(this.updateCache) {, +				for (String cachedDestination : this.updateCache.keySet()) {, +						MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +						List<String> subsIds = subs.get(sessionId);, +							subs.remove(sessionId);, +						if (subs.isEmpty()) {, +							this.updateCache.remove(cachedDestination);, +							this.accessCache.remove(cachedDestination);, +						}, +						else {, +							this.accessCache.put(cachedDestination, new LinkedMultiValueMap<String, String>(subs));, +			synchronized(this.updateCache) {, +					for (String cachedDestination : this.updateCache.keySet()) {, +							MultiValueMap<String, String> subs = this.updateCache.get(cachedDestination);, +							subs.remove(info.getSessionId());, +							if (subs.isEmpty()) {, +								this.updateCache.remove(cachedDestination);, +								this.accessCache.remove(cachedDestination);, +							}, +							else {, +								this.accessCache.put(cachedDestination,new LinkedMultiValueMap<String, String>(subs));, +			return "[cache=" + this.accessCache + "]";, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryTests.java, +		actual = this.registry.findSubscriptions(message("/topic/PRICE.STOCK.NASDAQ.IBM"));, +		actual = this.registry.findSubscriptions(message("/topic/PRICE.STOCK.NASDAQ.IBM"));]