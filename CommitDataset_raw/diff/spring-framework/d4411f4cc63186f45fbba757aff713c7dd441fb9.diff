[+++ b/spring-web/src/main/java/org/springframework/http/client/reactive/AbstractClientHttpRequest.java, +import java.util.stream.Collectors;, +import reactor.core.publisher.Flux;, +	/**, +	 * COMMITTING -> COMMITTED is the period after doCommit is called but before, +	 * the response status and headers have been applied to the underlying, +	 * response during which time pre-commit actions can still make changes to, +	 * the response status and headers., +	 */, +	private enum State {NEW, COMMITTING, COMMITTED}, +, +	private final List<Supplier<? extends Mono<Void>>> commitActions = new ArrayList<>(4);, +		if (State.COMMITTED.equals(this.state.get())) {, +		if (State.COMMITTED.equals(this.state.get())) {, +	/**, +	 * A variant of {@link #doCommit(Supplier)} for a request without body., +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit() {, +		return (this.state.get() == State.NEW ? doCommit(null) : Mono.empty());, +, +	/**, +	 * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the, +	 * request headers/cookies, and write the request body., +	 * @param writeAction the action to write the request body or {@code null}, +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit(Supplier<? extends Mono<Void>> writeAction) {, +, +		if (!this.state.compareAndSet(AbstractClientHttpRequest.State.NEW, AbstractClientHttpRequest.State.COMMITTING)) {, +		}, +, +		this.commitActions.add(() -> {, +			applyHeaders();, +			applyCookies();, +			this.state.set(AbstractClientHttpRequest.State.COMMITTED);, +, +		if (writeAction != null) {, +			this.commitActions.add(writeAction);, +, +		List<? extends Mono<Void>> actions = this.commitActions.stream(), +				.map(Supplier::get).collect(Collectors.toList());, +, +		return Flux.concat(actions).next();, +		this.commitActions.add(action);, +	/**, +	 * Implement this method to apply header changes from {@link #getHeaders()}, +	 * to the underlying response. This method is called once only., +	 */, +	protected abstract void applyHeaders();, +	/**, +	 * Implement this method to add cookies from {@link #getHeaders()} to the, +	 * underlying response. This method is called once only., +	 */, +	protected abstract void applyCookies();, +, +++ b/spring-web/src/main/java/org/springframework/http/client/reactive/AbstractClientHttpRequest.java, +import java.util.stream.Collectors;, +import reactor.core.publisher.Flux;, +	/**, +	 * COMMITTING -> COMMITTED is the period after doCommit is called but before, +	 * the response status and headers have been applied to the underlying, +	 * response during which time pre-commit actions can still make changes to, +	 * the response status and headers., +	 */, +	private enum State {NEW, COMMITTING, COMMITTED}, +, +	private final List<Supplier<? extends Mono<Void>>> commitActions = new ArrayList<>(4);, +		if (State.COMMITTED.equals(this.state.get())) {, +		if (State.COMMITTED.equals(this.state.get())) {, +	/**, +	 * A variant of {@link #doCommit(Supplier)} for a request without body., +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit() {, +		return (this.state.get() == State.NEW ? doCommit(null) : Mono.empty());, +, +	/**, +	 * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the, +	 * request headers/cookies, and write the request body., +	 * @param writeAction the action to write the request body or {@code null}, +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit(Supplier<? extends Mono<Void>> writeAction) {, +, +		if (!this.state.compareAndSet(AbstractClientHttpRequest.State.NEW, AbstractClientHttpRequest.State.COMMITTING)) {, +		}, +, +		this.commitActions.add(() -> {, +			applyHeaders();, +			applyCookies();, +			this.state.set(AbstractClientHttpRequest.State.COMMITTED);, +, +		if (writeAction != null) {, +			this.commitActions.add(writeAction);, +, +		List<? extends Mono<Void>> actions = this.commitActions.stream(), +				.map(Supplier::get).collect(Collectors.toList());, +, +		return Flux.concat(actions).next();]