[+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +import org.springframework.util.ClassUtils;, +		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);, +		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);, +, +		Future<?> result = determineAsyncExecutor(specificMethod).submit(, +, +	 * This implementation is a no-op for compatibility in Spring 3.1.2., +	 * Subclasses may override to provide support for extracting qualifier information,, +	 * e.g. via an annotation on the given method., +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");, +			executor = (executorToUse instanceof AsyncTaskExecutor ?, +					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));, +			this.executors.put(method, executor);, +		return executor;, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.BridgeMethodResolver;, +import org.springframework.util.ClassUtils;, +		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);, +		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);, +		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);, +, +		Future<?> result = determineAsyncExecutor(specificMethod).submit(, +, +	 * This implementation is a no-op for compatibility in Spring 3.1.2., +	 * Subclasses may override to provide support for extracting qualifier information,, +	 * e.g. via an annotation on the given method., +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java, + * Copyright 2002-2013 the original author or authors., +	 * executor has been qualified at the method level using {@link Async#value()}, +		return (async != null ? async.value() : null);, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2013 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);, +		this.defaultExecutor = defaultExecutor;, +		AsyncTaskExecutor executor = this.executors.get(method);, +		if (executor == null) {, +			Executor executorToUse = this.defaultExecutor;, +				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +, +						" to access qualified executor '" + qualifier + "'");, +				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			else if (executorToUse == null) {, +				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +, +						getClass().getSimpleName() + " either");]