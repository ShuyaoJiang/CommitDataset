[+++ b/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java, +import java.util.regex.Pattern;, +		// Pattern used to split the path into segments: '/' if not preceded by '{',, +		// using negative look-behind, +		private static final Pattern DELIMITER_PATTERN = Pattern.compile("(?<!\\{)/");, +, +, +		private final List<PartialPath> partialPaths;, +, +, +			this.partialPaths = PartialPath.parse(path);, +		private FullPathComponent(List<PartialPath> partialPaths) {, +			this.partialPaths = partialPaths;, +			this.path = PartialPath.getPath(partialPaths);, +		}, +, +			String[] pathSegments = DELIMITER_PATTERN.split(getPath());, +			List<String> result = new ArrayList<String>(pathSegments.length);, +			for (String pathSegment : pathSegments) {, +				if (StringUtils.hasLength(pathSegment)) {, +					result.add(pathSegment);, +				}, +			}, +			return Collections.unmodifiableList(result);, +			List<PartialPath> encodedPath =, +					PartialPath.encode(this.partialPaths, encoding);, +			verifyUriComponent(getPath(), Type.PATH);, +			List<PartialPath> expandedPath =, +					PartialPath.expand(this.partialPaths, uriVariables);, +, +		/**, +		 * Represents a part of the full path, with a separate encoding type., +		 * Required because of {/...} uri variables, which need to encoded as PATH_SEGMENT, +		 * rather than PATH., +		 */, +		static final class PartialPath implements Serializable {, +, +			final String value;, +, +			final Type type;, +, +			private PartialPath(String value, Type type) {, +				Assert.hasLength(value);, +				Assert.isTrue(Type.PATH == type || Type.PATH_SEGMENT == type);, +				this.value = value;, +				this.type = type;, +			}, +, +			private PartialPath expand(UriTemplateVariables uriVariables) {, +				String expandedValue = expandUriComponent(this.value, uriVariables);, +				return new PartialPath(expandedValue, this.type);, +			}, +, +			private PartialPath encode(String encoding), +					throws UnsupportedEncodingException {, +				String encodedPath = encodeUriComponent(this.value, encoding, this.type);, +				return new PartialPath(encodedPath, this.type);, +			}, +, +			@Override, +			public String toString() {, +				return value;, +			}, +, +			public static List<PartialPath> parse(String path) {, +				List<PartialPath> result = new ArrayList<PartialPath>();, +				int startIdx;, +				int endIdx = 0;, +				while ((startIdx = path.indexOf("{/", endIdx)) != -1) {, +					if (startIdx > endIdx) {, +						String prevPart = path.substring(endIdx, startIdx);, +						result.add(new PartialPath(prevPart, Type.PATH));, +					}, +					endIdx = path.indexOf('}', startIdx + 2) + 1;, +					if (endIdx == -1) {, +						throw new IllegalArgumentException("Path \"" + path + "\" has no " +, +								"closing \"}\" after \"{/\" at index " + startIdx);, +					}, +					String part = path.substring(startIdx, endIdx);, +					result.add(new PartialPath(part, Type.PATH_SEGMENT));, +				}, +				if (endIdx < path.length()) {, +					String endPart = path.substring(endIdx);, +					result.add(new PartialPath(endPart, Type.PATH));, +				}, +				return Collections.unmodifiableList(result);, +			}, +, +			public static String getPath(List<PartialPath> partialPaths) {, +				StringBuilder builder = new StringBuilder();, +				for (PartialPath partialPath : partialPaths) {, +					builder.append(partialPath.value);, +				}, +				return builder.toString();, +			}, +, +			public static List<PartialPath> expand(, +					List<PartialPath> partialPaths,, +					UriTemplateVariables uriVariables) {, +				List<PartialPath> result = new ArrayList<PartialPath>();]