[+++ b/spring-context/src/main/java/org/springframework/context/event/AbstractApplicationEventMulticaster.java, +		ListenerCacheKey cacheKey = new ListenerCacheKey(event.getClass(), sourceType);, +, +		// Quick check for existing entry on ConcurrentHashMap..., +, +		if (this.beanClassLoader == null ||, +				(ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &&, +						(sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) {, +			// Fully synchronized building and caching of a ListenerRetriever, +			synchronized (this.defaultRetriever) {, +				retriever = this.retrieverCache.get(cacheKey);, +				if (retriever != null) {, +					return retriever.getApplicationListeners();, +				}, +				Collection<ApplicationListener<?>> listeners = retrieveApplicationListeners(event, sourceType, retriever);, +				this.retrieverCache.put(cacheKey, retriever);, +				return listeners;, +			}, +		}, +		else {, +			// No ListenerRetriever caching -> no synchronization necessary, +			return retrieveApplicationListeners(event, sourceType, null);, +		}, +	}, +, +	/**, +	 * Actually retrieve the application listeners for the given event and source type., +	 * @param event the application event, +	 * @param sourceType the event source type, +	 * @param retriever the ListenerRetriever, if supposed to populate one (for caching purposes), +	 * @return the pre-filtered list of application listeners for the given event and source type, +	 */, +	private Collection<ApplicationListener<?>> retrieveApplicationListeners(, +			ApplicationEvent event, Class<?> sourceType, ListenerRetriever retriever) {, +, +			if (supportsEvent(listener, event.getClass(), sourceType)) {, +						if (!allListeners.contains(listener) && supportsEvent(listener, event.getClass(), sourceType)) {]