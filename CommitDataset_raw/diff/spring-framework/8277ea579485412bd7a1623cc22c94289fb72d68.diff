[+++ b/src/docs/asciidoc/core/core-beans.adoc, +annotation that defines a <<expressions,`SpEL` expression>> that should match to actually, +invoke the method for a particular event., +For instance, our notifier can be rewritten to be only invoked if the `content` attribute, +of the event is equal to `foo`:, +	@EventListener(condition = "#blEvent.content == 'foo'"), +Each `SpEL` expression evaluates against a dedicated context. The next table lists the, +items made available to the context so one can use them for conditional event processing:, +	public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {, +The `BeanFactory` API provides the underlying basis for Spring's IoC functionality., +Its specific contracts are mostly used in integration with other parts of Spring and, +related third-party frameworks, and its `DefaultListableBeanFactory` implementation, +is a key delegate within the higher-level `GenericApplicationContext` container., +`BeanFactory` and related interfaces such as `BeanFactoryAware`, `InitializingBean`,, +`DisposableBean` are important integration points for other framework components:, +not requiring any annotations or even reflection, they allow for very efficient, +interaction between the container and its components. Application-level beans may, +use the same callback interfaces but will typically prefer declarative dependency, +injection instead, either via annotations or through programmatic configuration., +, +Note that the core `BeanFactory` API level and its `DefaultListableBeanFactory`, +implementation do not make assumptions about the configuration format or any, +component annotations to be used. All of these flavors come in through extensions, +such as `XmlBeanDefinitionReader` and `AutowiredAnnotationBeanPostProcessor`,, +operating on shared `BeanDefinition` objects as a core metadata representation., +This is the essence of what makes Spring's container so flexible and extensible., +, +The following section explains the differences between the `BeanFactory` and, +`ApplicationContext` container levels and the implications on bootstrapping., +Use an `ApplicationContext` unless you have a good reason for not doing so, with, +`GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext`, +as the common implementations for custom bootstrapping. These are the primary entry, +points to Spring's core container for all common purposes: loading of configuration, +files, triggering a classpath scan, programmatically registering bean definitions, +and annotated classes, and as of 5.0 also registering functional bean definitions., +Because an `ApplicationContext` includes all functionality of a `BeanFactory`, it is, +generally recommended over a plain `BeanFactory`, except for a scenarios where full, +control over bean processing is needed. Within an `ApplicationContext` such as the, +`GenericApplicationContext` implementation, several kinds of beans will be detected, +by convention (i.e. by bean name or by bean type), in particular post-processors,, +whereas a plain `DefaultListableBeanFactory` is agnostic about any special beans., +, +For many extended container features such as annotation processing and AOP proxying,, +the <<beans-factory-extension-bpp,`BeanPostProcessor` extension point>> is essential., +If you use only a plain `DefaultListableBeanFactory`, such post-processors will not, +get detected and activated by default. This situation could be confusing because, +nothing is actually wrong with your bean configuration; it is rather the container, +which needs to be fully bootstrapped through additional setup in such a scenario., +| Integrated lifecycle management, +| No, +| Yes, +, +| Convenient `MessageSource` access (for internalization), +| Built-in `ApplicationEvent` publication mechanism, +To explicitly register a bean post-processor with a `DefaultListableBeanFactory`,, +you need to programmatically call `addBeanPostProcessor`:, +	factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());, +	factory.addBeanPostProcessor(new MyBeanPostProcessor());, +To apply a `BeanFactoryPostProcessor` to a plain `DefaultListableBeanFactory`,, +you need to call its `postProcessBeanFactory` method:, +In both cases, the explicit registration steps are inconvenient, which is, +why the various `ApplicationContext` variants are preferred over a plain, +`DefaultListableBeanFactory` in Spring-backed applications, especially when, +relying on ``BeanFactoryPostProcessor``s and ``BeanPostProcessor``s for extended, +container functionality in a typical enterprise setup., +, +[NOTE], +====, +An `AnnotationConfigApplicationContext` has all common annotation post-processors, +registered out of the box and may bring in additional processors underneath the, +covers through configuration annotations such as `@EnableTransactionManagement`., +At the abstraction level of Spring's annotation-based configuration model,, +the notion of bean post-processors becomes a mere internal container detail., +====]