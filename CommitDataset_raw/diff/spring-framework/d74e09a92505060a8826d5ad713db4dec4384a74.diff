[+++ b/spring-test/src/main/java/org/springframework/mock/http/client/reactive/MockClientHttpRequest.java, +	private Function<Flux<DataBuffer>, Mono<Void>> writeHandler;, +		this.writeHandler = body -> {, +	/**, +	 * Configure a custom handler for writing the request body., +	 *, +	 * <p>The default write handler consumes and caches the request body so it, +	 * may be accessed subsequently, e.g. in test assertions. Use this property, +	 * when the request body is an infinite stream., +	 *, +	 * @param writeHandler the write handler to use returning {@code Mono<Void>}, +	 * when the body has been "written" (i.e. consumed)., +	 */, +	public void setWriteHandler(Function<Flux<DataBuffer>, Mono<Void>> writeHandler) {, +		Assert.notNull(writeHandler, "'writeHandler' is required");, +		this.writeHandler = writeHandler;, +	}, +, +, +	@Override, +	protected void applyHeaders() {, +	}, +, +	@Override, +	protected void applyCookies() {, +		getCookies().values().stream().flatMap(Collection::stream), +				.forEach(cookie -> getHeaders().add(HttpHeaders.COOKIE, cookie.toString()));, +	}, +, +	@Override, +	public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {, +		return doCommit(() -> Mono.defer(() -> this.writeHandler.apply(Flux.from(body))));, +	}, +, +	@Override, +	public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {, +		return writeWith(Flux.from(body).flatMap(p -> p));, +	}, +, +	@Override, +	public Mono<Void> setComplete() {, +		return writeWith(Flux.empty());, +	}, +, +, +++ b/spring-test/src/main/java/org/springframework/mock/http/client/reactive/MockClientHttpRequest.java, +	private Function<Flux<DataBuffer>, Mono<Void>> writeHandler;, +		this.writeHandler = body -> {, +	/**, +	 * Configure a custom handler for writing the request body., +	 *, +	 * <p>The default write handler consumes and caches the request body so it, +	 * may be accessed subsequently, e.g. in test assertions. Use this property, +	 * when the request body is an infinite stream., +	 *, +	 * @param writeHandler the write handler to use returning {@code Mono<Void>}, +	 * when the body has been "written" (i.e. consumed)., +	 */, +	public void setWriteHandler(Function<Flux<DataBuffer>, Mono<Void>> writeHandler) {, +		Assert.notNull(writeHandler, "'writeHandler' is required");, +		this.writeHandler = writeHandler;, +	}, +, +, +	@Override, +	protected void applyHeaders() {, +	}, +, +	@Override, +	protected void applyCookies() {, +		getCookies().values().stream().flatMap(Collection::stream), +				.forEach(cookie -> getHeaders().add(HttpHeaders.COOKIE, cookie.toString()));, +	}, +, +	@Override, +	public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {, +		return doCommit(() -> Mono.defer(() -> this.writeHandler.apply(Flux.from(body))));, +	}, +, +	@Override, +	public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {, +		return writeWith(Flux.from(body).flatMap(p -> p));, +	}, +, +	@Override, +	public Mono<Void> setComplete() {, +		return writeWith(Flux.empty());, +	}, +, +, +++ b/spring-web/src/test/java/org/springframework/mock/http/client/reactive/test/MockClientHttpRequest.java, +	private Function<Flux<DataBuffer>, Mono<Void>> writeHandler;, +		this.writeHandler = body -> {, +	/**, +	 * Configure a custom handler for writing the request body., +	 *, +	 * <p>The default write handler consumes and caches the request body so it, +	 * may be accessed subsequently, e.g. in test assertions. Use this property, +	 * when the request body is an infinite stream., +	 *]