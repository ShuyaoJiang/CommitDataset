[+++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.LinkedHashMap;, +		Map<String, Object> map = new LinkedHashMap<String, Object>(this.headers);, +		map.put(ID,  map.remove(ID)); // remove and add again at the end, +		map.put(TIMESTAMP, map.remove(TIMESTAMP));, +		return map.toString();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.LinkedHashMap;, +		Map<String, Object> map = new LinkedHashMap<String, Object>(this.headers);, +		map.put(ID,  map.remove(ID)); // remove and add again at the end, +		map.put(TIMESTAMP, map.remove(TIMESTAMP));, +		return map.toString();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/method/HandlerMethodReturnValueHandlerComposite.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +	private static Log logger = LogFactory.getLog(HandlerMethodReturnValueHandlerComposite.class);, +, +				if (logger.isTraceEnabled()) {, +					logger.trace("Processing return value with " + handler);, +				}, +		Assert.notNull(handler, "No handler for return value type [" + returnType.getParameterType().getName() + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.LinkedHashMap;, +		Map<String, Object> map = new LinkedHashMap<String, Object>(this.headers);, +		map.put(ID,  map.remove(ID)); // remove and add again at the end, +		map.put(TIMESTAMP, map.remove(TIMESTAMP));, +		return map.toString();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/method/HandlerMethodReturnValueHandlerComposite.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +	private static Log logger = LogFactory.getLog(HandlerMethodReturnValueHandlerComposite.class);, +, +				if (logger.isTraceEnabled()) {, +					logger.trace("Processing return value with " + handler);, +				}, +		Assert.notNull(handler, "No handler for return value type [" + returnType.getParameterType().getName() + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/method/InvocableHandlerMethod.java, +			StringBuilder sb = new StringBuilder("Invoking [");, +			sb.append(this.getBeanType().getSimpleName()).append(".");, +			sb.append(this.getMethod().getName()).append("] method with arguments ");, +			sb.append(Arrays.asList(args));, +			logger.trace(sb.toString());, +			logger.trace("Method returned [" + returnValue + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +import java.util.LinkedHashMap;, +		Map<String, Object> map = new LinkedHashMap<String, Object>(this.headers);, +		map.put(ID,  map.remove(ID)); // remove and add again at the end, +		map.put(TIMESTAMP, map.remove(TIMESTAMP));, +		return map.toString();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/method/HandlerMethodReturnValueHandlerComposite.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +	private static Log logger = LogFactory.getLog(HandlerMethodReturnValueHandlerComposite.class);, +, +				if (logger.isTraceEnabled()) {, +					logger.trace("Processing return value with " + handler);, +				}, +		Assert.notNull(handler, "No handler for return value type [" + returnType.getParameterType().getName() + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/method/InvocableHandlerMethod.java, +			StringBuilder sb = new StringBuilder("Invoking [");, +			sb.append(this.getBeanType().getSimpleName()).append(".");, +			sb.append(this.getMethod().getName()).append("] method with arguments ");, +			sb.append(Arrays.asList(args));, +			logger.trace(sb.toString());, +			logger.trace("Method returned [" + returnValue + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/ReplyToMethodReturnValueHandler.java, +import java.lang.annotation.Annotation;, +, +import org.springframework.core.annotation.AnnotationUtils;, +import org.springframework.util.ObjectUtils;, +	private final boolean annotationRequired;, +, +	public ReplyToMethodReturnValueHandler(SimpMessageSendingOperations messagingTemplate, boolean annotationRequired) {, +		this.annotationRequired = annotationRequired;, +		if ((returnType.getMethodAnnotation(ReplyTo.class) != null) ||, +				(returnType.getMethodAnnotation(ReplyToUser.class) != null)) {, +			return true;, +		}, +		return (!this.annotationRequired);, +			for (String destination : getDestinations(replyToUser, inputHeaders.getDestination())) {, +			return;, +, +		ReplyTo replyTo = returnType.getMethodAnnotation(ReplyTo.class);, +		if (replyTo != null) {, +			for (String destination : getDestinations(replyTo, inputHeaders.getDestination())) {, +				this.messagingTemplate.convertAndSend(destination, returnValue, postProcessor);, +			}, +			return;, +		}, +, +		this.messagingTemplate.convertAndSend(inputHeaders.getDestination(), returnValue, postProcessor);, +	}, +, +	private String[] getDestinations(Annotation annot, String inputDestination) {, +		String[] destinations = (String[]) AnnotationUtils.getValue(annot);, +		return ObjectUtils.isEmpty(destinations) ? new String[] { inputDestination } : destinations;, +, +	@Override, +	public String toString() {, +		return "ReplyToMethodReturnValueHandler [annotationRequired=" + annotationRequired + "]";]