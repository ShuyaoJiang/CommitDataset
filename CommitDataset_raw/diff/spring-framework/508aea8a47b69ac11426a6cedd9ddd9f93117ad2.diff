[+++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, +	 * <p><b>Notes:</b>, +	 * <ul>, +	 * <li>Assumes that {@link #matches} returns {@code true} for, +	 * <li>Duplicate occurrences of separators within the returned result are removed, +	 * <li>Leading and trailing separators are removed from the returned result, +	 * </ul>, +		List<Element> pathElements = path.elements();, +		int pathElementsCount = pathElements.size();, +		int startIndex = 0;, +		// Find first path element that is not a separator or a literal (i.e. the first pattern based element), +			startIndex++;, +			// There is no pattern piece, +			return PathContainer.parsePath("");, +		// Skip leading separators that would be in the result, +		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {, +			startIndex++;, +		, +		int endIndex = pathElements.size();, +		// Skip trailing separators that would be in the result, +		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {, +			endIndex--;, +		, +		boolean multipleAdjacentSeparators = false;, +		for (int i = startIndex; i < (endIndex - 1); i++) {, +			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {, +				multipleAdjacentSeparators=true;, +				break;, +		PathContainer resultPath = null;, +		if (multipleAdjacentSeparators) {, +			// Need to rebuild the path without the duplicate adjacent separators, +			StringBuilder buf = new StringBuilder();, +			int i = startIndex;, +			while (i < endIndex) {, +				Element e = pathElements.get(i++);, +				buf.append(e.value());, +				if (e instanceof Separator) {, +					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {, +						i++;, +			resultPath = PathContainer.parsePath(buf.toString());, +		} else if (startIndex >= endIndex) {, +			resultPath = PathContainer.parsePath("");, +		else {, +			resultPath = path.subPath(startIndex, endIndex);, +		return resultPath;, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, +	 * <p><b>Notes:</b>, +	 * <ul>, +	 * <li>Assumes that {@link #matches} returns {@code true} for, +	 * <li>Duplicate occurrences of separators within the returned result are removed, +	 * <li>Leading and trailing separators are removed from the returned result, +	 * </ul>, +		List<Element> pathElements = path.elements();, +		int pathElementsCount = pathElements.size();, +		int startIndex = 0;, +		// Find first path element that is not a separator or a literal (i.e. the first pattern based element), +			startIndex++;, +			// There is no pattern piece, +			return PathContainer.parsePath("");, +		// Skip leading separators that would be in the result, +		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {, +			startIndex++;, +		, +		int endIndex = pathElements.size();, +		// Skip trailing separators that would be in the result, +		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {, +			endIndex--;, +		, +		boolean multipleAdjacentSeparators = false;, +		for (int i = startIndex; i < (endIndex - 1); i++) {, +			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {, +				multipleAdjacentSeparators=true;, +				break;, +		PathContainer resultPath = null;, +		if (multipleAdjacentSeparators) {, +			// Need to rebuild the path without the duplicate adjacent separators, +			StringBuilder buf = new StringBuilder();, +			int i = startIndex;, +			while (i < endIndex) {, +				Element e = pathElements.get(i++);, +				buf.append(e.value());, +				if (e instanceof Separator) {, +					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {, +						i++;, +			resultPath = PathContainer.parsePath(buf.toString());, +		} else if (startIndex >= endIndex) {, +			resultPath = PathContainer.parsePath("");, +		else {, +			resultPath = path.subPath(startIndex, endIndex);, +		return resultPath;, +++ b/spring-web/src/test/java/org/springframework/web/util/pattern/PathPatternTests.java, +		checkExtractPathWithinPattern("/**","//","");, +		checkExtractPathWithinPattern("/*/**", "/docs/cvs/commit///", "docs/cvs/commit");, +		checkExtractPathWithinPattern("/*/**", "/docs/cvs/commit/", "docs/cvs/commit");, +		checkExtractPathWithinPattern("/aaa/bbb/**", "/aaa///","");, +		checkExtractPathWithinPattern("/aaa/bbb/**", "/aaa//","");, +		checkExtractPathWithinPattern("/aaa/bbb/**", "/aaa/","");, +		checkExtractPathWithinPattern("/docs/**", "/docs/cvs/commit///", "cvs/commit");, +		checkExtractPathWithinPattern("/docs/**", "/docs/cvs/commit/", "cvs/commit");]