[+++ b/spring-beans/src/main/java/org/springframework/beans/TypeMismatchException.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.util.Assert;, +	private String propertyName;, +, +	@Nullable, +		this.propertyName = propertyChangeEvent.getPropertyName();, +	 * @see #initPropertyName, +	 * @see #initPropertyName, +	 * Initialize this exception's property name for exposure through {@link #getPropertyName()},, +	 * as an alternative to having it initialized via a {@link PropertyChangeEvent}., +	 * @param propertyName the property name to expose, +	 * @since 5.0.4, +	 * @see #TypeMismatchException(Object, Class), +	 * @see #TypeMismatchException(Object, Class, Throwable), +	 */, +	public void initPropertyName(String propertyName) {, +		Assert.state(this.propertyName == null, "Property name already initialized");, +		this.propertyName = propertyName;, +	}, +, +	/**, +	 * Return the name of the affected property, if available., +	 */, +	@Nullable, +	public String getPropertyName() {, +		return this.propertyName;, +	}, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/TypeMismatchException.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.util.Assert;, +	private String propertyName;, +, +	@Nullable, +		this.propertyName = propertyChangeEvent.getPropertyName();, +	 * @see #initPropertyName, +	 * @see #initPropertyName, +	 * Initialize this exception's property name for exposure through {@link #getPropertyName()},, +	 * as an alternative to having it initialized via a {@link PropertyChangeEvent}., +	 * @param propertyName the property name to expose, +	 * @since 5.0.4, +	 * @see #TypeMismatchException(Object, Class), +	 * @see #TypeMismatchException(Object, Class, Throwable), +	 */, +	public void initPropertyName(String propertyName) {, +		Assert.state(this.propertyName == null, "Property name already initialized");, +		this.propertyName = propertyName;, +	}, +, +	/**, +	 * Return the name of the affected property, if available., +	 */, +	@Nullable, +	public String getPropertyName() {, +		return this.propertyName;, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/validation/AbstractBindingResult.java, + * Copyright 2002-2018 the original author or authors., +import java.util.HashMap;, +	private final Map<String, Class<?>> fieldTypes = new HashMap<>(0);, +, +	private final Map<String, Object> fieldValues = new HashMap<>(0);, +, +, +		// Use rejected value in case of error, current field value otherwise., +		if (fieldError != null) {, +			Object value = fieldError.getRejectedValue();, +			// Do not apply formatting on binding failures like type mismatches., +			return (fieldError.isBindingFailure() ? value : formatFieldValue(field, value));, +		else if (getTarget() != null) {, +			Object value = getActualFieldValue(fixedField(field));, +			return formatFieldValue(field, value);, +		}, +		else {, +			return this.fieldValues.get(field);, +		}, +		if (getTarget() != null) {, +		}, +		return this.fieldTypes.get(field);, +		return (getTarget() != null ? getActualFieldValue(fixedField(field)) : null);, +	@Override, +	public String[] resolveMessageCodes(String errorCode) {, +		return getMessageCodesResolver().resolveMessageCodes(errorCode, getObjectName());, +	}, +, +	@Override, +	public String[] resolveMessageCodes(String errorCode, @Nullable String field) {, +		Class<?> fieldType = (getTarget() != null ? getFieldType(field) : null);, +		return getMessageCodesResolver().resolveMessageCodes(, +				errorCode, getObjectName(), fixedField(field), fieldType);, +	}, +, +	@Override, +	public void addError(ObjectError error) {, +		this.errors.add(error);, +	}]