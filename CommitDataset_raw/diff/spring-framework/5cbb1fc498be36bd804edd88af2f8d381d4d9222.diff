[+++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SessionFactoryUtils.java, + * Copyright 2002-2014 the original author or authors., +			if (cp != null) {, +		}, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SessionFactoryUtils.java, + * Copyright 2002-2014 the original author or authors., +			if (cp != null) {, +		}, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SpringSessionContext.java, + * Copyright 2002-2014 the original author or authors., +import javax.transaction.Status;, +import javax.transaction.SystemException;, +import javax.transaction.TransactionManager;, +import org.apache.commons.logging.LogFactory;, +	private TransactionManager transactionManager;, +, +			this.transactionManager = (TransactionManager) ReflectionUtils.invokeMethod(rtmMethod, jtaPlatform);, +			if (this.transactionManager != null) {, +			LogFactory.getLog(SpringSessionContext.class).warn(, +					"Could not introspect Hibernate JtaPlatform for SpringJtaSessionContext", ex);, +						new SpringSessionSynchronization(sessionHolder, this.sessionFactory, false));, +, +		if (this.transactionManager != null) {, +			try {, +				if (this.transactionManager.getStatus() == Status.STATUS_ACTIVE) {, +			}, +			catch (SystemException ex) {, +				throw new HibernateException("JTA TransactionManager found but status check failed", ex);, +			}, +		}, +, +		if (TransactionSynchronizationManager.isSynchronizationActive()) {, +			Session session = this.sessionFactory.openSession();, +			if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {, +				session.setFlushMode(FlushMode.MANUAL);, +			}, +			SessionHolder sessionHolder = new SessionHolder(session);, +			TransactionSynchronizationManager.registerSynchronization(, +					new SpringSessionSynchronization(sessionHolder, this.sessionFactory, true));, +			TransactionSynchronizationManager.bindResource(this.sessionFactory, sessionHolder);, +			sessionHolder.setSynchronizedWithTransaction(true);, +			return session;, +		}, +			throw new HibernateException("Could not obtain transaction-synchronized Session for current thread");, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SessionFactoryUtils.java, + * Copyright 2002-2014 the original author or authors., +			if (cp != null) {, +		}, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SpringSessionContext.java, + * Copyright 2002-2014 the original author or authors., +import javax.transaction.Status;, +import javax.transaction.SystemException;, +import javax.transaction.TransactionManager;, +import org.apache.commons.logging.LogFactory;, +	private TransactionManager transactionManager;, +, +			this.transactionManager = (TransactionManager) ReflectionUtils.invokeMethod(rtmMethod, jtaPlatform);, +			if (this.transactionManager != null) {, +			LogFactory.getLog(SpringSessionContext.class).warn(, +					"Could not introspect Hibernate JtaPlatform for SpringJtaSessionContext", ex);, +						new SpringSessionSynchronization(sessionHolder, this.sessionFactory, false));, +, +		if (this.transactionManager != null) {, +			try {, +				if (this.transactionManager.getStatus() == Status.STATUS_ACTIVE) {, +			}, +			catch (SystemException ex) {, +				throw new HibernateException("JTA TransactionManager found but status check failed", ex);, +			}, +		}, +, +		if (TransactionSynchronizationManager.isSynchronizationActive()) {, +			Session session = this.sessionFactory.openSession();, +			if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {, +				session.setFlushMode(FlushMode.MANUAL);, +			}, +			SessionHolder sessionHolder = new SessionHolder(session);, +			TransactionSynchronizationManager.registerSynchronization(, +					new SpringSessionSynchronization(sessionHolder, this.sessionFactory, true));, +			TransactionSynchronizationManager.bindResource(this.sessionFactory, sessionHolder);, +			sessionHolder.setSynchronizedWithTransaction(true);, +			return session;, +		}, +			throw new HibernateException("Could not obtain transaction-synchronized Session for current thread");, +++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/SpringSessionSynchronization.java, + * Copyright 2002-2014 the original author or authors., +	private final boolean newSession;, +, +	public SpringSessionSynchronization(SessionHolder sessionHolder, SessionFactory sessionFactory, boolean newSession) {, +		this.newSession = newSession;, +, +		// Unbind at this point if it's a new Session..., +		if (this.newSession) {, +			TransactionSynchronizationManager.unbindResource(this.sessionFactory);, +			this.holderActive = false;, +		}, +			// Call close() at this point if it's a new Session..., +			if (this.newSession) {, +				SessionFactoryUtils.closeSession(this.sessionHolder.getSession());, +			}]