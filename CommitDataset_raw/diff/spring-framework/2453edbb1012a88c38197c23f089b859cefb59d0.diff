[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement, String)} instead., +	@Deprecated, +	public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element, String annotationName) {, +		return getMergedAnnotationAttributes(element, annotationName);, +	/**, +	 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)} instead., +	 */, +	@Deprecated, +	public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element, String annotationName,, +			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {, +, +		return getMergedAnnotationAttributes(element, annotationName, classValuesAsString, nestedAnnotationsAsMap);, +	 * Get the first annotation of the specified {@code annotationType} within, +	 * the annotation hierarchy <em>above</em> the supplied {@code element},, +	 * merge that annotation's attributes with <em>matching</em> attributes from, +	 * annotations in lower levels of the annotation hierarchy, and synthesize, +	 * the result back into an annotation of the specified {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both, +	 * within a single annotation and within the annotation hierarchy., +	 * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, Class)}, +	 * and {@link AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)}., +	 * @param element the annotated element, +	 * @param annotationType the annotation type to find, +	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found, +	 * @since 4.2, +	 * @see #getMergedAnnotationAttributes(AnnotatedElement, Class), +	 * @see #findMergedAnnotation(AnnotatedElement, Class), +	 * @see AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement), +	 */, +	public static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		// Shortcut: directly present on the element, with no merging needed?, +		if (!(element instanceof Class)) {, +			// Do not use this shortcut against a Class: Inherited annotations, +			// would get preferred over locally declared composed annotations., +			A annotation = element.getAnnotation(annotationType);, +			if (annotation != null) {, +				return AnnotationUtils.synthesizeAnnotation(annotation, element);, +			}, +		}, +, +		// Exhaustive retrieval of merged annotation attributes..., +		AnnotationAttributes attributes = getMergedAnnotationAttributes(element, annotationType);, +		return AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element);, +	}, +, +	/**, +	 * Get the annotation attributes of <strong>all</strong> annotations of the specified, +	 * {@code annotationName} in the annotation hierarchy above the supplied, +	 * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}., +	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},, +	 * this method does <em>not</em> support attribute overrides., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element, +	 * @param annotationName the fully qualified class name of the annotation type to find, +	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation, +	 * attributes from all annotations found, or {@code null} if not found, +	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean), +	 */, +	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName) {, +		return getAllAnnotationAttributes(element, annotationName, false, false);, +	}, +, +	/**, +	 * Get the annotation attributes of <strong>all</strong> annotations of, +	 * the specified {@code annotationName} in the annotation hierarchy above, +	 * the supplied {@link AnnotatedElement} and store the results in a, +	 * {@link MultiValueMap}., +	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},, +	 * this method does <em>not</em> support attribute overrides., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element, +	 * @param annotationName the fully qualified class name of the annotation type to find, +	 * @param classValuesAsString whether to convert Class references into Strings or to, +	 * preserve them as Class references, +	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into, +	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances, +	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation, +	 * attributes from all annotations found, or {@code null} if not found, +	 */, +	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,, +			final String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {, +, +		final MultiValueMap<String, Object> attributesMap = new LinkedMultiValueMap<String, Object>();, +, +		searchWithGetSemantics(element, null, annotationName, new SimpleAnnotationProcessor<Void>() {, +			@Override, +			public Void process(AnnotatedElement annotatedElement, Annotation annotation, int metaDepth) {, +				boolean found = annotation.annotationType().getName().equals(annotationName);, +				if (found) {, +					AnnotationAttributes annotationAttributes = AnnotationUtils.getAnnotationAttributes(, +							annotation, classValuesAsString, nestedAnnotationsAsMap);, +					for (Map.Entry<String, Object> entry : annotationAttributes.entrySet()) {, +						attributesMap.add(entry.getKey(), entry.getValue());, +					}, +				}]