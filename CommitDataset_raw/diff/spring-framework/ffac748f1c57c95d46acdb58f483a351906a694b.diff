[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, + * thread will fail to acquire the flushLock and the messages will be buffered instead --, +	private final int bufferSizeLimit;, +, +, +	private final int sendTimeLimit;, +	private volatile boolean sessionLimitExceeded;, +, +	private final Lock flushLock = new ReentrantLock();, +, +	private final Lock closeLock = new ReentrantLock();, +, +, +	public ConcurrentWebSocketSessionDecorator(WebSocketSession delegate, int sendTimeLimit, int bufferSizeLimit) {, +		super(delegate);, +	public long getTimeSinceSendStarted() {, +		if (this.sessionLimitExceeded) {, +			return;, +		}, +, +				if (logger.isDebugEnabled()) {, +					logger.debug("Another send already in progress, session id '" +, +							getId() + "'" + ", in-progress send time " + getTimeSinceSendStarted() +, +							" (ms)" + ", buffer size " + this.bufferSize + " bytes");, +				}, +		if (this.flushLock.tryLock() && !this.sessionLimitExceeded) {, +				flushLock.unlock();, +		if (this.closeLock.tryLock() && !this.sessionLimitExceeded) {, +			try {, +				if (getTimeSinceSendStarted() > this.sendTimeLimit) {, +					sessionLimitReached(, +							"Message send time " + getTimeSinceSendStarted() +, +									" (ms) exceeded the allowed limit " + this.sendTimeLimit);, +					sessionLimitReached(, +							"The send buffer size " + this.bufferSize.get() + " bytes for " +, +							"session '" + getId() + " exceeded the allowed limit " + this.bufferSizeLimit);, +				}, +			}, +			finally {, +				this.closeLock.unlock();, +			}, +	private void sessionLimitReached(String reason) {, +		this.sessionLimitExceeded = true;, +		throw new SessionLimitExceededException(reason);, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, + * thread will fail to acquire the flushLock and the messages will be buffered instead --, +	private final int bufferSizeLimit;, +, +, +	private final int sendTimeLimit;, +	private volatile boolean sessionLimitExceeded;, +, +	private final Lock flushLock = new ReentrantLock();, +, +	private final Lock closeLock = new ReentrantLock();, +, +, +	public ConcurrentWebSocketSessionDecorator(WebSocketSession delegate, int sendTimeLimit, int bufferSizeLimit) {, +		super(delegate);, +	public long getTimeSinceSendStarted() {, +		if (this.sessionLimitExceeded) {, +			return;, +		}, +, +				if (logger.isDebugEnabled()) {, +					logger.debug("Another send already in progress, session id '" +, +							getId() + "'" + ", in-progress send time " + getTimeSinceSendStarted() +, +							" (ms)" + ", buffer size " + this.bufferSize + " bytes");, +				}, +		if (this.flushLock.tryLock() && !this.sessionLimitExceeded) {, +				flushLock.unlock();, +		if (this.closeLock.tryLock() && !this.sessionLimitExceeded) {, +			try {, +				if (getTimeSinceSendStarted() > this.sendTimeLimit) {, +					sessionLimitReached(, +							"Message send time " + getTimeSinceSendStarted() +, +									" (ms) exceeded the allowed limit " + this.sendTimeLimit);, +					sessionLimitReached(, +							"The send buffer size " + this.bufferSize.get() + " bytes for " +, +							"session '" + getId() + " exceeded the allowed limit " + this.bufferSizeLimit);, +				}, +			}, +			finally {, +				this.closeLock.unlock();, +			}, +	private void sessionLimitReached(String reason) {, +		this.sessionLimitExceeded = true;, +		throw new SessionLimitExceededException(reason);, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/SessionLimitExceededException.java, +/*, + * Copyright 2002-2014 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,]