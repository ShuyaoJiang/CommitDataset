[+++ b/spring-core/src/main/java/org/springframework/util/concurrent/SettableListenableFuture.java, +import java.util.concurrent.Callable;, +import java.util.concurrent.atomic.AtomicReference;, + * A {@link org.springframework.util.concurrent.ListenableFuture ListenableFuture}, + * whose value can be set via {@link #set(Object)} or, + * @author Rossen Stoyanchev, +	private final SettableTask<T> settableTask;, +	private final ListenableFutureTask<T> listenableFuture;, +, +, +	public SettableListenableFuture() {, +		this.settableTask = new SettableTask<T>();, +		this.listenableFuture = new ListenableFutureTask<T>(this.settableTask);, +	}, +		boolean success = this.settableTask.setValue(value);, +		if (success) {, +			this.listenableFuture.run();, +		return success;, +		Assert.notNull(exception, "'exception' must not be null");, +		boolean success = this.settableTask.setValue(exception);, +		if (success) {, +			this.listenableFuture.run();, +		return success;, +		this.listenableFuture.addCallback(callback);, +		this.settableTask.setCancelled();, +		boolean cancelled = this.listenableFuture.cancel(mayInterruptIfRunning);, +		return this.listenableFuture.isCancelled();, +		return this.listenableFuture.isDone();, +	 * <p>Will return the value if it has been set via {@link #set(Object)},, +	 * throw an {@link java.util.concurrent.ExecutionException} if it has been, +	 * set via {@link #setException(Throwable)} or  throw a, +	 * {@link java.util.concurrent.CancellationException} if it has been cancelled., +		return this.listenableFuture.get();, +	 * <p>Will return the value if it has been set via {@link #set(Object)},, +	 * throw an {@link java.util.concurrent.ExecutionException} if it has been, +	 * set via {@link #setException(Throwable)} or  throw a, +	 * {@link java.util.concurrent.CancellationException} if it has been cancelled., +		return this.listenableFuture.get(timeout, unit);, +	private static class SettableTask<T> implements Callable<T> {, +		private static final String NO_VALUE = SettableListenableFuture.class.getName() + ".NO_VALUE";, +, +		private final AtomicReference<Object> value = new AtomicReference<Object>(NO_VALUE);, +, +		private volatile boolean cancelled = false;, +		public boolean setValue(Object value) {, +			if (this.cancelled) {, +			return this.value.compareAndSet(NO_VALUE, value);, +, +		public void setCancelled() {, +			this.cancelled = true;, +		public T call() throws Exception {, +			if (value.get() instanceof Exception) {, +				throw (Exception) value.get();, +			return (T) value.get();, +++ b/spring-core/src/main/java/org/springframework/util/concurrent/SettableListenableFuture.java, +import java.util.concurrent.Callable;, +import java.util.concurrent.atomic.AtomicReference;, + * A {@link org.springframework.util.concurrent.ListenableFuture ListenableFuture}, + * whose value can be set via {@link #set(Object)} or, + * @author Rossen Stoyanchev, +	private final SettableTask<T> settableTask;, +	private final ListenableFutureTask<T> listenableFuture;, +, +, +	public SettableListenableFuture() {, +		this.settableTask = new SettableTask<T>();, +		this.listenableFuture = new ListenableFutureTask<T>(this.settableTask);, +	}, +		boolean success = this.settableTask.setValue(value);, +		if (success) {, +			this.listenableFuture.run();, +		return success;, +		Assert.notNull(exception, "'exception' must not be null");, +		boolean success = this.settableTask.setValue(exception);, +		if (success) {, +			this.listenableFuture.run();, +		return success;, +		this.listenableFuture.addCallback(callback);, +		this.settableTask.setCancelled();, +		boolean cancelled = this.listenableFuture.cancel(mayInterruptIfRunning);, +		return this.listenableFuture.isCancelled();, +		return this.listenableFuture.isDone();, +	 * <p>Will return the value if it has been set via {@link #set(Object)},, +	 * throw an {@link java.util.concurrent.ExecutionException} if it has been, +	 * set via {@link #setException(Throwable)} or  throw a, +	 * {@link java.util.concurrent.CancellationException} if it has been cancelled., +		return this.listenableFuture.get();, +	 * <p>Will return the value if it has been set via {@link #set(Object)},, +	 * throw an {@link java.util.concurrent.ExecutionException} if it has been, +	 * set via {@link #setException(Throwable)} or  throw a, +	 * {@link java.util.concurrent.CancellationException} if it has been cancelled., +		return this.listenableFuture.get(timeout, unit);, +	private static class SettableTask<T> implements Callable<T> {, +		private static final String NO_VALUE = SettableListenableFuture.class.getName() + ".NO_VALUE";, +, +		private final AtomicReference<Object> value = new AtomicReference<Object>(NO_VALUE);, +, +		private volatile boolean cancelled = false;, +		public boolean setValue(Object value) {, +			if (this.cancelled) {]