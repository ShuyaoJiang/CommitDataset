[+++ b/spring-framework-reference/src/mvc.xml, +              See <xref linkend="mvc-multipart-forms-non-browsers" /> and, +              <xref linkend="mvc-multipart"/>.</para>, +      provides one <interfacename>MultipartResolver</interfacename> implementation, +      for use with <ulink url="http://jakarta.apache.org/commons/fileupload">, +      <emphasis>Commons FileUpload</emphasis></ulink> and another for use, +      with Servlet 3.0 multipart request parsing.</para>, +    <section id="mvc-multipart-resolver-commons">, +      <title>Using a <interfacename>MultipartResolver</interfacename> , +      with <emphasis>Commons FileUpload</emphasis></title>, +    <section id="mvc-multipart-resolver-standard">, +      <title>Using a <interfacename>MultipartResolver</interfacename> , +      with <emphasis>Servlet 3.0</emphasis></title>, +      , +      <para>In order to use Servlet 3.0 based multipart parsing,, +      you need to mark the <classname>DispatcherServlet</classname> with a , +      <literal>"multipart-config"</literal> section in, +      <filename>web.xml</filename>, or with a , +      <classname>javax.servlet.MultipartConfigElement</classname> in , +      programmatic servlet registration, or in case of a custom servlet class, +      possibly with a <classname>javax.servlet.annotation.MultipartConfig</classname> , +      annotation on your servlet class. Configuration settings such as , +      maximum sizes or storage locations need to be applied at that , +      servlet registration level as Servlet 3.0 does not allow for , +      those settings to be done from the MultipartResolver.</para>, +, +      <para>Once Servlet 3.0 multipart parsing has been enabled , +      in one of the above mentioned ways you can add the, +      <classname>StandardServletMultipartResolver</classname>, +      to your Spring configuration:</para>, +      , +      <programlisting language="xml">&lt;bean id="multipartResolver", +    class="org.springframework.web.multipart.support.StandardServletMultipartResolver"&gt;, +&lt;/bean&gt;</programlisting>, +, +	</section>, +, +      <para>When using Servlet 3.0 multipart parsing you can also use, +      <classname>javax.servlet.http.Part</classname> for the method parameter:, +      <programlisting language="java">@Controller, +public class FileUpoadController {, +    @RequestMapping(value = "/form", method = RequestMethod.POST), +    public String handleFormUpload(@RequestParam("name") String name,, +        @RequestParam("file") Part file) {, +        InputStream inputStream = file.getInputStream();, +        <lineannotation>// store bytes from uploaded file somewhere</lineannotation>, +        , +        return "redirect:uploadSuccess";, +    }, +, +}</programlisting></para>, +, +    , +    <section id="mvc-multipart-forms-non-browsers">, +      <title>Handling a file upload request from programmatic clients</title>, +    , +      <para>Multipart requests can also be submitted from non-browser clients in, +      a RESTful service scenario. All of the above examples and configuration , +      apply here as well. However, unlike browsers that typically submit files, +      and simple form fields, a programmatic client can also send more complex , +      data of a specific content type -- for exmaple a multipart request with , +      a file and second part with JSON formatted data:, +      <programlisting language="xml">, +POST /someUrl, +Content-Type: multipart/mixed, + , +--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp, +Content-Disposition: form-data; name="meta-data", +Content-Type: application/json; charset=UTF-8, +Content-Transfer-Encoding: 8bit, + , +{, +  "name": "value", +}, +--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp, +Content-Disposition: form-data; name="file-data"; filename="file.properties", +Content-Type: text/xml, +Content-Transfer-Encoding: 8bit, +... File Data ..., +      </programlisting></para>, +      , +      <para>You could access the part named "meta-data" with, +      <interfacename>@RequestParam("meta-data") String metadata</interfacename>, +      controller method argument. However, you would probably , +      prefer to accept a strongly typed object initialized , +      from the JSON formatted data in the body of the request , +      part, very similar to the way , +      <interfacename>@RequestBody</interfacename> converts , +      the body of a non-multipart requests to a target object, +      with the help of an <classname>HttpMessageConverter</classname>.</para>, +      , +      <para>You can use the <interfacename>@RequestPart</interfacename> , +      annotation instead of the <interfacename>@RequestParam</interfacename>, +      annotation for this purpose. It allows you to have the , +      content of a specific multipart passed through an , +      <classname>HttpMessageConverter</classname>, +      taking into consideration the <literal>'Content-Type'</literal>, +      header of the multipart:, +      <programlisting language="java">, +@RequestMapping(value="/someUrl", method = RequestMethod.POST)]