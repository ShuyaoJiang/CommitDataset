[+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		private final MethodCacheKey methodCacheKey;, +, +			this.methodCacheKey = new MethodCacheKey(metadata.method, metadata.targetClass);, +				return evaluator.condition(this.metadata.operation.getCondition(), this.methodCacheKey, evaluationContext);, +				return !evaluator.unless(unless, this.methodCacheKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.methodCacheKey, evaluationContext);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		private final MethodCacheKey methodCacheKey;, +, +			this.methodCacheKey = new MethodCacheKey(metadata.method, metadata.targetClass);, +				return evaluator.condition(this.metadata.operation.getCondition(), this.methodCacheKey, evaluationContext);, +				return !evaluator.unless(unless, this.methodCacheKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.methodCacheKey, evaluationContext);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +import org.springframework.util.ObjectUtils;, + * <p>Performs internal caching for performance reasons, + * using {@link MethodCacheKey}., + * @author Stephane Nicoll, +	private final Map<ExpressionKey, Expression> keyCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<ExpressionKey, Expression> conditionCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<ExpressionKey, Expression> unlessCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<MethodCacheKey, Method> targetMethodCache = new ConcurrentHashMap<MethodCacheKey, Method>(64);, +	public Object key(String keyExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.keyCache, keyExpression, methodKey).getValue(evalContext);, +	public boolean condition(String conditionExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.conditionCache, conditionExpression, methodKey).getValue(, +	public boolean unless(String unlessExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.unlessCache, unlessExpression, methodKey).getValue(, +	private Expression getExpression(Map<ExpressionKey, Expression> cache, String expression, MethodCacheKey methodKey) {, +		ExpressionKey key = createKey(methodKey, expression);, +	private ExpressionKey createKey(MethodCacheKey methodCacheKey, String expression) {, +		return new ExpressionKey(methodCacheKey, expression);, +, +, +	private static class ExpressionKey {, +		private final MethodCacheKey methodCacheKey;, +		private final String expression;, +, +		private ExpressionKey(MethodCacheKey methodCacheKey, String expression) {, +			this.methodCacheKey = methodCacheKey;, +			this.expression = expression;, +		}, +, +		@Override, +		public boolean equals(Object other) {, +			if (this == other) {, +				return true;, +			}, +			if (!(other instanceof ExpressionKey)) {, +				return false;, +			}, +			ExpressionKey otherKey = (ExpressionKey) other;, +			return (this.methodCacheKey.equals(otherKey.methodCacheKey), +					&& ObjectUtils.nullSafeEquals(this.expression, otherKey.expression));, +		}, +, +		@Override, +		public int hashCode() {, +			return this.methodCacheKey.hashCode() * 29 + (this.expression != null ? this.expression.hashCode() : 0);, +		}, +	}, +, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +		private final MethodCacheKey methodCacheKey;, +, +			this.methodCacheKey = new MethodCacheKey(metadata.method, metadata.targetClass);, +				return evaluator.condition(this.metadata.operation.getCondition(), this.methodCacheKey, evaluationContext);, +				return !evaluator.unless(unless, this.methodCacheKey, evaluationContext);, +				return evaluator.key(this.metadata.operation.getKey(), this.methodCacheKey, evaluationContext);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +import org.springframework.util.ObjectUtils;, + * <p>Performs internal caching for performance reasons, + * using {@link MethodCacheKey}., + * @author Stephane Nicoll, +	private final Map<ExpressionKey, Expression> keyCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<ExpressionKey, Expression> conditionCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<ExpressionKey, Expression> unlessCache, +			= new ConcurrentHashMap<ExpressionKey, Expression>(64);, +	private final Map<MethodCacheKey, Method> targetMethodCache = new ConcurrentHashMap<MethodCacheKey, Method>(64);, +	public Object key(String keyExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.keyCache, keyExpression, methodKey).getValue(evalContext);, +	public boolean condition(String conditionExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.conditionCache, conditionExpression, methodKey).getValue(, +	public boolean unless(String unlessExpression, MethodCacheKey methodKey, EvaluationContext evalContext) {, +		return getExpression(this.unlessCache, unlessExpression, methodKey).getValue(, +	private Expression getExpression(Map<ExpressionKey, Expression> cache, String expression, MethodCacheKey methodKey) {, +		ExpressionKey key = createKey(methodKey, expression);, +	private ExpressionKey createKey(MethodCacheKey methodCacheKey, String expression) {, +		return new ExpressionKey(methodCacheKey, expression);, +, +, +	private static class ExpressionKey {]