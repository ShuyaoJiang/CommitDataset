[+++ b/src/docs/asciidoc/web/webflux-functional.adoc, +[[webflux-fn-overview]], +== Overview, +, +An HTTP request is handled with a **`HandlerFunction`** that takes `ServerRequest` and, +returns `Mono<ServerResponse>`, both of which are immutable contracts that offer JDK-8, +friendly access to the HTTP request and response. `HandlerFunction` is the equivalent of, +an `@RequestMapping` method in the annotation-based programming model., +, +Requests are routed to a `HandlerFunction` with a **`RouterFunction`** that takes, +`ServerRequest` and returns `Mono<HandlerFunction>`. When a request is matched to a, +particular route, the `HandlerFunction` mapped to the route is used. `RouterFunction` is, +the equivalent of an `@RequestMapping` annotation., +, +`RouterFunctions.route(RequestPredicate, HandlerFunction)` provides a router function, +default implementation that can be used with a number of built-in request predicates., +For example:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +import static org.springframework.http.MediaType.APPLICATION_JSON;, +import static org.springframework.web.reactive.function.server.RequestPredicates.*;, +, +PersonRepository repository = ..., +PersonHandler handler = new PersonHandler(repository);, +, +RouterFunction<ServerResponse> route =, +	route(GET("/person/{id}").and(accept(APPLICATION_JSON)), handler::getPerson), +		.andRoute(GET("/person").and(accept(APPLICATION_JSON)), handler::listPeople), +		.andRoute(POST("/person"), handler::createPerson);, +, +, +public class PersonHandler {, +, +	// ..., +, +	public Mono<ServerResponse> listPeople(ServerRequest request) {, +		// ..., +	}, +, +	public Mono<ServerResponse> createPerson(ServerRequest request) {, +		// ..., +	}, +, +	public Mono<ServerResponse> getPerson(ServerRequest request) {, +		// ..., +	}, +}, +----, +, +One way to run a `RouterFunction` is to turn it into an `HttpHandler` and install it, +through one of the built-in <<web-reactive.adoc#webflux-httphandler,server adapters>>:, +, +* `RouterFunctions.toHttpHandler(RouterFunction)`, +* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`, +, +, +Most applications will run through the WebFlux Java config, see <<webflux-fn-running>>., +, +, +, +, +`ServerRequest` and `ServerResponse` are immutable interfaces that offer JDK-8 friendly, +access to the HTTP request and response with, +http://www.reactive-streams.org[Reactive Streams] back pressure against the request, +and response body stream. The request body is represented with a Reactor `Flux` or `Mono`., +The response body is represented with any Reactive Streams `Publisher`, including `Flux`, +and `Mono`. For more on that see, +<<web-reactive.adoc#webflux-reactive-libraries,Reactive Libraries>>., +, +[[webflux-fn-request]], +=== ServerRequest, +, +`ServerRequest` provides access to the HTTP method, URI, headers, and query parameters, +while access to the body is provided through the `body` methods. This is how to extract, +the request body to a `Mono<String>`:, +This is how to extract the body into a `Flux`, where `Person` is a class that can be, +deserialised, e.g. from JSON or XML:, +`bodyToMono` and `bodyToFlux` are convenience methods that use the generic, +`ServerRequest.body(BodyExtractor)` method. `BodyExtractor` is a functional strategy, +interface that you can use to write your own extraction logic, but common `BodyExtractor`, +instances can be obtained through the `BodyExtractors` utility class. The above examples, +can also be written as follows:, +, +, +[[webflux-fn-response]], +=== ServerResponse, +, +`ServerResponse` provides access to the HTTP response and since it is immutable, you use, +a build to create it. The builder can be used to set the response status, to add response, +headers, or to provide a body. Below is an example with a 200 (OK) response with JSON, +content:, +This is how to build a 201 (CREATED) response with `"Location"` header, and no body:, +, +[[webflux-fn-handler-classes]], +=== Handler Classes, +, +We can write a handler function as a lambda. For example:, +That is convenient but in an application we need multiple functions and useful to group]