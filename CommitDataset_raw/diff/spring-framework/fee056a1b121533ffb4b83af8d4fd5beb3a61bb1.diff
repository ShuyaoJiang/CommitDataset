[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	/**, +	 * {@code null} constant used to denote that the search algorithm should continue., +	 */, +	private static final Processor<Boolean> alwaysTrueAnnotationProcessor = new AlwaysTrueBooleanAnnotationProcessor();, +, +, +		return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));, +, +		return getMetaAnnotationTypes(element, AnnotationUtils.getAnnotation(element, annotationName));, +	}, +, +	private static Set<String> getMetaAnnotationTypes(AnnotatedElement element, Annotation composed) {, +		if (composed == null) {, +			return null;, +		}, +			final Set<String> types = new LinkedHashSet<String>();, +			searchWithGetSemantics(composed.annotationType(), null, null, null, new SimpleAnnotationProcessor<Object>(true) {, +			return (!types.isEmpty() ? types : null);, +	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {, +		return hasMetaAnnotationTypes(element, annotationType, null);, +	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {, +		return hasMetaAnnotationTypes(element, null, annotationName);, +	}, +, +	private static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType,, +			String annotationName) {, +, +		return Boolean.TRUE.equals(, +			searchWithGetSemantics(element, annotationType, annotationName, new SimpleAnnotationProcessor<Boolean>() {, +, +					return (metaDepth > 0 ? Boolean.TRUE : CONTINUE);, +	public static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {, +		return Boolean.TRUE.equals(searchWithGetSemantics(element, annotationType, null, alwaysTrueAnnotationProcessor));, +	public static boolean isAnnotated(AnnotatedElement element, String annotationName) {, +		return Boolean.TRUE.equals(searchWithGetSemantics(element, null, annotationName, alwaysTrueAnnotationProcessor));, +				new MergedAnnotationAttributesProcessor());, +				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(false, false, true);, +			validateContainerType(annotationType, containerType);, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(false, false, true);, +			String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {, +		searchWithGetSemantics(element, null, annotationName, new SimpleAnnotationProcessor<Object>() {, +			public Object process(AnnotatedElement annotatedElement, Annotation annotation, int metaDepth) {, +				return CONTINUE;, +	public static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {, +		return Boolean.TRUE.equals(searchWithFindSemantics(element, annotationType, null, alwaysTrueAnnotationProcessor));, +		AnnotationAttributes attributes = searchWithFindSemantics(element, annotationType, null,, +				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));, +				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(false, false, true);, +		searchWithFindSemantics(element, annotationType, null, processor);, +			validateContainerType(annotationType, containerType);, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(false, false, true);, +		searchWithFindSemantics(element, annotationType, null, containerType, processor);, +	 * @param element the element that is annotated with the supplied, +	private static <T> T searchWithGetSemanticsInAnnotations(AnnotatedElement element,, +				if ((annotation.annotationType() == annotationType, +						|| annotation.annotationType().getName().equals(annotationName)), +						|| processor.alwaysProcesses()) {, +					T result = processor.process(element, annotation, metaDepth);, +				// Repeatable annotations in container?, +				else if (annotation.annotationType() == containerType) {, +					for (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) {, +						T result = processor.process(element, contained, metaDepth);, +						if (result != null) {, +							// No need to post-process since repeatable annotations within a, +							// container cannot be composed annotations., +							processor.getAggregatedResults().add(result);, +						}, +					}, +				}, +					processor.postProcess(element, annotation, result);, +	 * @since 4.3, +	 * @param element the annotated element; never {@code null}, +								|| annotation.annotationType().getName().equals(annotationName), +								|| processor.alwaysProcesses()) {, +				else if (element instanceof Class) {, +	private static void validateContainerType(Class<? extends Annotation> annotationType,, +		 * <p>The supplied annotation will be an actual target annotation, +		 * that has been found by the search algorithm, unless this processor, +		 * is configured to {@linkplain #alwaysProcesses always process}, +		 * annotations in which case it may be some other annotation within an, +		 * will have a value greater than {@code 0}. In any case, it is, +		 * Determine if this processor always processes annotations regardless of, +		 * whether or not the target annotation has been found., +		 * @return {@code true} if this processor always processes annotations, +		 * @since 4.3, +		 */, +		boolean alwaysProcesses();, +, +		/**, +		private final boolean alwaysProcesses;, +, +, +		public SimpleAnnotationProcessor() {, +			this(false);, +		}, +, +		public SimpleAnnotationProcessor(boolean alwaysProcesses) {]