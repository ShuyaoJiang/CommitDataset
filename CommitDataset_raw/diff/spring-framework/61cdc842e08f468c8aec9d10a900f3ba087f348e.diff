[+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessor.java, +import java.util.Optional;, +import org.springframework.beans.TypeMismatchException;, +import org.springframework.validation.BindingResult;, +import org.springframework.validation.FieldError;, +		Object attribute = null;, +		BindingResult bindingResult = null;, +, +		if (mavContainer.containsAttribute(name)) {, +			attribute = mavContainer.getModel().get(name);, +		}, +		else {, +			// Create attribute instance, +			try {, +				attribute = createAttribute(name, parameter, binderFactory, webRequest);, +			}, +			catch (BindException ex) {, +				if (isBindExceptionRequired(parameter)) {, +					// No BindingResult parameter -> fail with BindException, +					throw ex;, +				}, +				// Otherwise, expose null/empty value and associated BindingResult, +				if (parameter.getParameterType() == Optional.class) {, +					attribute = Optional.empty();, +				}, +				bindingResult = ex.getBindingResult();, +			}, +		}, +, +		if (bindingResult == null) {, +			// Bean property binding and validation;, +			// skipped in case of binding failure on construction., +			// Value type adaptation, also covering java.util.Optional, +			if (!parameter.getParameterType().isInstance(attribute)) {, +				attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);, +			}, +			bindingResult = binder.getBindingResult();, +		}, +		Map<String, Object> bindingResultModel = bindingResult.getModel();, +		return attribute;, +	 * <p>The default implementation typically uses the unique public no-arg constructor, +	 * if available but also handles a "primary constructor" approach for data classes:, +	 * It understands the JavaBeans {@link ConstructorProperties} annotation as well as, +	 * runtime-retained parameter names in the bytecode, associating request parameters, +	 * with constructor arguments by name. If no such constructor is found, the default, +	 * constructor will be used (even if not public), assuming subsequent bean property, +	 * bindings through setter methods., +	 * @throws BindException in case of constructor argument binding failure, +	 * @throws Exception in case of constructor invocation failure, +	 * @see #constructAttribute(Constructor, String, WebDataBinderFactory, NativeWebRequest), +	 * @see BeanUtils#findPrimaryConstructor(Class), +		MethodParameter nestedParameter = parameter.nestedIfOptional();, +		Class<?> type = nestedParameter.getNestedParameterType();, +		Object attribute = constructAttribute(ctor, attributeName, binderFactory, webRequest);, +		if (parameter != nestedParameter) {, +			attribute = Optional.of(attribute);, +		}, +		return attribute;, +	}, +, +	/**, +	 * Construct a new attribute instance with the given constructor., +	 * <p>Called from, +	 * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}, +	 * after constructor resolution., +	 * @param ctor the constructor to use, +	 * @param attributeName the name of the attribute (never {@code null}), +	 * @param binderFactory for creating WebDataBinder instance, +	 * @param webRequest the current request, +	 * @return the created model attribute (never {@code null}), +	 * @throws BindException in case of constructor argument binding failure, +	 * @throws Exception in case of constructor invocation failure, +	 * @since 5.0, +	 */, +	protected Object constructAttribute(Constructor<?> ctor, String attributeName,, +			WebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {, +, +		boolean bindingFailure = false;, +			String[] paramValues = webRequest.getParameterValues(paramNames[i]);, +			try {, +				args[i] = (paramValues != null ?, +						binder.convertIfNecessary(paramValues, paramTypes[i], new MethodParameter(ctor, i)) : null);, +			}, +			catch (TypeMismatchException ex) {, +				bindingFailure = true;, +				binder.getBindingResult().addError(new FieldError(, +						binder.getObjectName(), paramNames[i], ex.getValue(), true,, +						new String[] {ex.getErrorCode()}, null, ex.getLocalizedMessage()));, +			}, +		}, +		if (bindingFailure) {, +			throw new BindException(binder.getBindingResult());, +	 * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}., +	 * @return {@code true} if the next method parameter is not of type {@link Errors}, +	 * @see #isBindExceptionRequired(MethodParameter), +		return isBindExceptionRequired(parameter);, +	}, +, +	/**, +	 * Whether to raise a fatal bind exception on validation errors.]