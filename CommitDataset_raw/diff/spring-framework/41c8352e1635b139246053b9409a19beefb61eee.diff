[+++ b/spring-framework-reference/src/beans.xml, +, +          <para>Using Java-configuration support we can easily create a, +++ b/spring-framework-reference/src/beans.xml, +, +          <para>Using Java-configuration support we can easily create a, +++ b/spring-framework-reference/src/expressions.xml, +    expression language that can be used across all the products in the Spring, +    expression language implementations to be integrated should the need, +    requires creating a few bootstrapping infrastructure classes such as the, +    API, and its language syntax. In several places an Inventor and Inventor's, +    <para>The expression language supports the following functionality</para>, +    '<literal>exp.getValue</literal>' respectfully.</para>, +    <para>SpEL supports a wide range of features, such as calling methods,, +, +// invokes 'getBytes()', +Expression exp = parser.parseExpression("<emphasis role="bold">'Hello World'.bytes</emphasis>");  , +, +    <para>SpEL also supports nested properties using standard 'dot' notation,, +    i.e. prop1.prop2.prop3 and the setting of property values</para>, +, +// invokes 'getBytes().length', +Expression exp = parser.parseExpression("<emphasis role="bold">'Hello World'.bytes.length</emphasis>");  , +, +        <para>By default SpEL uses the conversion service available in Spring, +        core, +        (<literal>org.springframework.core.convert.ConversionService</literal>)., +        This conversion service comes with many converters built in for common, +        conversions but is also fully extensible so custom conversions between, +        types can be added. Additionally it has the key capability that it is, +        generics aware. This means that when working with generic types in, +        expressions, SpEL will attempt conversions to maintain type, +        correctness for any objects it encounters.</para>, +        <para>What does this mean in practice? Suppose assignment, using, +        <literal>setValue()</literal>, is being used to set a, +        <literal>List</literal> property. The type of the property is actually, +        <literal>List&lt;Boolean&gt;</literal>. SpEL will recognize that the, +        elements of the list need to be converted to, +        <literal>Boolean</literal> before being placed in it. A simple, +        example:</para>, +                        @Value("#{ systemProperties['user.region']"} String defaultLocale) {, +                          @Value("#{ systemProperties['user.country']"} String defaultLocale) {, +// evals to "Hello World", +String helloWorld = (String) parser.parseExpression("'Hello World'").getValue(); , +// evals to 2147483647, +int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();  , +      and tesla, were populated with data listed in the section <link, +      <programlisting lang="" language="java">// evals to 1856, +int year = (Integer) parser.parseExpression("Birthdate.Year + 1900").getValue(context); , +String invention = parser.parseExpression("inventions[3]").getValue(teslaContext, , +                                                                    String.class); , +String invention = parser.parseExpression("Members[0].Inventions[6]").getValue(societyContext,, +                                                                               String.class);, +      <para>The contents of maps are obtained by specifying the literal key, +      value within the brackets. In this case, because keys for the Officers, +      map are strings, we can specify string literal.</para>, +Inventor pupin = parser.parseExpression("Officers['president']").getValue(societyContext, , +                                                                          Inventor.class);, +String city = , +    parser.parseExpression("Officers['president'].PlaceOfBirth.City").getValue(societyContext,, +                                                                               String.class);, +parser.parseExpression("Officers['advisors'][0].PlaceOfBirth.Country").setValue(societyContext,, +                                                                                "Croatia");, +boolean isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(societyContext,, +                                                                                Boolean.class);</programlisting>, +boolean trueValue = , +     parser.parseExpression("'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);, +boolean falseValue = , +     parser.parseExpression("'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);, +String testString = , +   parser.parseExpression("'test' + ' ' + 'string'").getValue(String.class);  // 'test string', +String aleks = parser.parseExpression("Name = 'Alexandar Seovic'").getValue(inventorContext, , +                                                                            String.class);, +      uses a <classname>TypeLocator</classname> to find types and the, +      <classname>StandardTypeLocator</classname> (which can be replaced) is, +      built with an understanding of the java.lang package. This means T(), +boolean trueValue = , +   parser.parseExpression("T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR"), +  .getValue(Boolean.class);, +  p.parseExpression("new org.spring.samples.spel.inventor.Inventor('Albert Einstein', , +                                                                   'German')"), +                                                                   .getValue(Inventor.class);, +p.parseExpression("Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein',, +                                                                   'German'))"), +                                                                   .getValue(societyContext);, +      <para>Variables can be referenced in the expression using the syntax, +        <para>The variable #this is always defined and refers to the current, +        evaluation object (the object against which unqualified references, +        will be resolved).</para>, +// evaluates to [11, 13, 17], +List&lt;Integer&gt; primesGreaterThanTen = , +             (List&lt;Integer&gt;) parser.parseExpression("#primes.?[#this&gt;10]").getValue(context);, +</programlisting>, +, +    for (int i = 0; i &lt; input.length(); i++) , +                         StringUtils.class.getDeclaredMethod("reverseString", , +                                                             new Class[] { String.class }));, +String helloWorldReversed = , +          parser.parseExpression("#reverseString('hello')").getValue(context, String.class);</programlisting>, +      <programlisting language="java">String falseString = ]