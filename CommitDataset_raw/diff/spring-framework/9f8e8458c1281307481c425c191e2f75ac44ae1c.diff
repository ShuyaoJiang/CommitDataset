[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java, +import java.util.stream.Collectors;, +import reactor.core.publisher.Flux;, +	private HttpStatus statusCode;, +, +	private volatile boolean committed;, +	private final List<Supplier<? extends Mono<Void>>> commitActions = new ArrayList<>(4);, +		this.cookies = new LinkedMultiValueMap<>();, +		if (this.committed) {, +			if (logger.isDebugEnabled()) {, +		else {, +			this.statusCode = statusCode;, +			return true;, +		}, +	}, +		return (this.committed ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers);, +		return (this.committed ? CollectionUtils.unmodifiableMultiValueMap(this.cookies) : this.cookies);, +		if (action != null) {, +			this.commitActions.add(action);, +		}, +		return new ChannelSendOperator<>(body,, +				writePublisher -> doCommit(() -> writeWithInternal(writePublisher)));, +		return new ChannelSendOperator<>(body,, +				writePublisher -> doCommit(() -> writeAndFlushWithInternal(writePublisher)));, +		return doCommit();, +	/**, +	 * A variant of {@link #doCommit(Supplier)} for a response without no body., +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit() {, +		return doCommit(null);, +, +	/**, +	 * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the, +	 * response status and headers/cookies, and write the response body., +	 * @param writeAction the action to write the response body or {@code null}, +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit(Supplier<? extends Mono<Void>> writeAction) {, +		if (this.committed) {, +			if (logger.isDebugEnabled()) {, +				logger.debug("Can't set the status " + statusCode.toString() +, +						" because the HTTP response has already been committed");, +			}, +			return Mono.empty();, +		}, +, +		this.committed = true;, +, +		this.commitActions.add(() -> {, +			applyStatusCode();, +			applyHeaders();, +			applyCookies();, +, +		if (writeAction != null) {, +			this.commitActions.add(writeAction);, +, +		List<? extends Mono<Void>> actions = this.commitActions.stream(), +				.map(Supplier::get).collect(Collectors.toList());, +, +		return Flux.concat(actions).next();, +	protected abstract void applyStatusCode();, +	protected abstract void applyHeaders();, +	protected abstract void applyCookies();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java, +import java.util.stream.Collectors;, +import reactor.core.publisher.Flux;, +	private HttpStatus statusCode;, +, +	private volatile boolean committed;, +	private final List<Supplier<? extends Mono<Void>>> commitActions = new ArrayList<>(4);, +		this.cookies = new LinkedMultiValueMap<>();, +		if (this.committed) {, +			if (logger.isDebugEnabled()) {, +		else {, +			this.statusCode = statusCode;, +			return true;, +		}, +	}, +		return (this.committed ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers);, +		return (this.committed ? CollectionUtils.unmodifiableMultiValueMap(this.cookies) : this.cookies);, +		if (action != null) {, +			this.commitActions.add(action);, +		}, +		return new ChannelSendOperator<>(body,, +				writePublisher -> doCommit(() -> writeWithInternal(writePublisher)));, +		return new ChannelSendOperator<>(body,, +				writePublisher -> doCommit(() -> writeAndFlushWithInternal(writePublisher)));, +		return doCommit();, +	/**, +	 * A variant of {@link #doCommit(Supplier)} for a response without no body., +	 * @return a completion publisher, +	 */, +	protected Mono<Void> doCommit() {, +		return doCommit(null);, +, +	/**, +	 * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the, +	 * response status and headers/cookies, and write the response body., +	 * @param writeAction the action to write the response body or {@code null}]