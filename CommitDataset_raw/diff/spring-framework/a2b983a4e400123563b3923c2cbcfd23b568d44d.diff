[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final List<String> propertySourceNames = new ArrayList<String>();, +				String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size()-1);, +				propertySources.addBefore(firstProcessed, propertySource);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final List<String> propertySourceNames = new ArrayList<String>();, +				String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size()-1);, +				propertySources.addBefore(firstProcessed, propertySource);, +++ b/spring-context/src/test/java/org/springframework/context/annotation/PropertySourceAnnotationTests.java, +import java.util.Collections;, +, +import org.springframework.core.env.MapPropertySource;, +	@Test, +	public void orderingDoesntReplaceExisting() throws Exception {, +		// SPR-12198: mySource should 'win' as it was registered manually, +		AnnotationConfigApplicationContext ctxWithoutName = new AnnotationConfigApplicationContext();, +		MapPropertySource mySource = new MapPropertySource("mine", Collections.singletonMap("testbean.name", "myTestBean"));, +		ctxWithoutName.getEnvironment().getPropertySources().addLast(mySource);, +		ctxWithoutName.register(ConfigWithFourResourceLocations.class);, +		ctxWithoutName.refresh();, +		assertThat(ctxWithoutName.getEnvironment().getProperty("testbean.name"), equalTo("myTestBean"));, +, +	}]