[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	public static ResolvableType forClassWithGenerics(final Class<?> sourceClass, final ResolvableType... generics) {, +		TypeVariable<?>[] variables = sourceClass.getTypeParameters();, +		Assert.isTrue(variables.length == generics.length, "Mismatched number of generics specified");, +, +		Type[] arguments = new Type[generics.length];, +		for (int i = 0; i < generics.length; i++) {, +			ResolvableType generic = generics[i];, +			Type argument = (generic != null ? generic.getType() : null);, +			arguments[i] = (argument != null ? argument : variables[i]);, +		}, +, +		ParameterizedType syntheticType = new SyntheticParameterizedType(sourceClass, arguments);, +		return forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));, +		private final TypeVariable<?>[] variables;, +		public TypeVariablesVariableResolver(TypeVariable<?>[] variables, ResolvableType[] generics) {, +			this.variables = variables;, +			for (int i = 0; i < this.variables.length; i++) {, +				if (SerializableTypeWrapper.unwrap(this.variables[i]).equals(, +	private static final class SyntheticParameterizedType implements ParameterizedType, Serializable {, +, +		private final Type rawType;, +, +		private final Type[] typeArguments;, +, +		public SyntheticParameterizedType(Type rawType, Type[] typeArguments) {, +			this.rawType = rawType;, +			this.typeArguments = typeArguments;, +		}, +, +		@Override, +		public Type[] getActualTypeArguments() {, +			return this.typeArguments;, +		}, +, +		@Override, +		public Type getRawType() {, +			return this.rawType;, +		}, +, +		@Override, +		public Type getOwnerType() {, +			return null;, +		}, +	}, +, +, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	public static ResolvableType forClassWithGenerics(final Class<?> sourceClass, final ResolvableType... generics) {, +		TypeVariable<?>[] variables = sourceClass.getTypeParameters();, +		Assert.isTrue(variables.length == generics.length, "Mismatched number of generics specified");, +, +		Type[] arguments = new Type[generics.length];, +		for (int i = 0; i < generics.length; i++) {, +			ResolvableType generic = generics[i];, +			Type argument = (generic != null ? generic.getType() : null);, +			arguments[i] = (argument != null ? argument : variables[i]);, +		}, +, +		ParameterizedType syntheticType = new SyntheticParameterizedType(sourceClass, arguments);, +		return forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));, +		private final TypeVariable<?>[] variables;, +		public TypeVariablesVariableResolver(TypeVariable<?>[] variables, ResolvableType[] generics) {, +			this.variables = variables;, +			for (int i = 0; i < this.variables.length; i++) {, +				if (SerializableTypeWrapper.unwrap(this.variables[i]).equals(, +	private static final class SyntheticParameterizedType implements ParameterizedType, Serializable {, +, +		private final Type rawType;, +, +		private final Type[] typeArguments;, +, +		public SyntheticParameterizedType(Type rawType, Type[] typeArguments) {, +			this.rawType = rawType;, +			this.typeArguments = typeArguments;, +		}, +, +		@Override, +		public Type[] getActualTypeArguments() {, +			return this.typeArguments;, +		}, +, +		@Override, +		public Type getRawType() {, +			return this.rawType;, +		}, +, +		@Override, +		public Type getOwnerType() {, +			return null;, +		}, +	}, +, +, +++ b/spring-core/src/test/java/org/springframework/core/ResolvableTypeTests.java, + * Copyright 2002-2015 the original author or authors., +import java.util.concurrent.Callable;, +	@Test, +	public void testSpr12701() throws Exception {, +		ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Callable.class, String.class);]