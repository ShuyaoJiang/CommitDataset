[+++ b/src/docs/asciidoc/web/webmvc.adoc, +Spring MVC has an extensive integration with the Servlet 3.0 asynchronous request, +processing. <<mvc-ann-async-deferredresult>> and <<mvc-ann-async-callable>>, +provide basic support for producing return values asynchronously. Controllers can produce, +<<mvc-ann-async-http-streaming,response streams>> including, +<<mvc-ann-async-sse,SSE>> and <<mvc-ann-async-output-stream,raw data>>. Controllers can, +use reactive clients and return <<mvc-ann-async-reactive-types,reactive return types>>, +to Spring MVC for response handling., +[[mvc-ann-async-deferredresult]], +=== `DeferredResult`, +, +Once the asynchronous request processing feature is, +<<mvc-ann-async-configuration,enabled>> in the Servlet container, controller methods can, +wrap any supported controller method return value with `DeferredResult`:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@GetMapping("/quotes"), +	@ResponseBody, +	public DeferredResult<String> quotes() {, +		DeferredResult<String> deferredResult = new DeferredResult<String>();, +		// Save the deferredResult somewhere.., +		return deferredResult;, +	}, +, +	// From some other thread..., +	deferredResult.setResult(data);, +----, +, +The controller can produce the return value asynchronously, from a different thread, for, +example in response to an external event (JMS message), a scheduled task, or other., +, +, +, +[[mvc-ann-async-callable]], +=== `Callable`, +, +A controller may also wrap any supported return value with `java.util.concurrent.Callable`:, +The return value will then be obtained by executing the the given task through the, +<<mvc-ann-async-configuration-spring-mvc,configured>> `TaskExecutor`., +[[mvc-ann-async-processing]], +=== Processing, +, +Here is a very concise overview of Servlet asynchronous request processing:, +`DeferredResult` processing:, +* Spring MVC calls `request.startAsync()`., +* Meanwhile the `DispatcherServlet` and all configured Filter's exit the request, +  asynchronously produced return value., +`Callable` processing:, +, +* Controller returns a `Callable`., +* Spring MVC calls `request.startAsync()` and submits the `Callable` to, +  a `TaskExecutor` for processing in a separate thread., +* Meanwhile the `DispatcherServlet` and all Filter's exit the Servlet container thread, +  but the response remains open., +* Eventually the `Callable` produces a result and Spring MVC dispatches the request back, +  to the Servlet container to complete processing., +* The `DispatcherServlet` is invoked again and processing resumes with the, +  asynchronously produced return value from the `Callable`., +, +For further background and context you can also read, +https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[the, +blog posts] that introduced asynchronous request processing support in Spring MVC 3.2., +When using a `DeferredResult` you can choose whether to call `setResult` or, +`setErrorResult` with an exception. In both cases Spring MVC dispatches the request back, +to the Servlet container to complete processing. It is then treated either as if the, +controller method returned the given value, or as if it produced the given exception., +The exception then goes through the regular exception handling mechanism, e.g. invoking, +`@ExceptionHandler` methods., +, +When using `Callable`, similar processing logic follows. The main difference being that, +the result is returned from the `Callable` or an exception is raised by it., +=== Interception, +``HandlerInterceptor``'s can also be `AsyncHandlerInterceptor` in order to receive the, +`afterConcurrentHandlingStarted` callback on the initial request that starts asynchronous, +processing instead of `postHandle` and `afterCompletion`., +``HandlerInterceptor``'s can also register a `CallableProcessingInterceptor`, +or a `DeferredResultProcessingInterceptor` in order to integrate more deeply with the, +lifecycle of an asynchronous request for example to handle a timeout event. See, +{api-spring-framework}/web/servlet/AsyncHandlerInterceptor.html[AsyncHandlerInterceptor], +`DeferredResult` provides `onTimeout(Runnable)` and `onCompletion(Runnable)` callbacks., +See the Javadoc of `DeferredResult` for more details. `Callable` can be substituted for, +`WebAsyncTask` that exposes additional methods for timeout and completion callbacks., +What if you wanted to push multiple events on a single HTTP response? The, +`ResponseBodyEmitter` return value can be used to stream multiple Objects, where each, +Object sent is serialized with an, +<<integration.adoc#rest-message-conversion,HttpMessageConverter>> and written to the, +response. For example:, +	@GetMapping("/events"), +`ResponseBodyEmitter` can also be used as the body in a `ResponseEntity` allowing you to, +customize the status and headers of the response., +`SseEmitter` is a sub-class of `ResponseBodyEmitter` that provides support for, +http://www.w3.org/TR/eventsource/[Server-Sent Events] where events sent from the server, +are formatted according to the W3C SSE specification. In order to produce an SSE, +stream from a controller simply return `SseEmitter`:, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)]