[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		if (returnValue == null) {, +			return handleNoContent(returnType, message);, +		}, +, +	/**, +	 * Invoked for a {@code null} return value, which could mean a void method, +	 * or method returning an async type parameterized by void., +	 * @param returnType return type of the handler method that produced the data, +	 * @param message the input message handled by the handler method, +	 * @return completion {@code Mono<Void>} for the handling, +	 */, +	protected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		if (returnValue == null) {, +			return handleNoContent(returnType, message);, +		}, +, +	/**, +	 * Invoked for a {@code null} return value, which could mean a void method, +	 * or method returning an async type parameterized by void., +	 * @param returnType return type of the handler method that produced the data, +	 * @param message the input message handled by the handler method, +	 * @return completion {@code Mono<Void>} for the handling, +	 */, +	protected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/InvocableHelper.java, +				.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, invocable, message))), +							.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, exHandler, message))), +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		if (returnValue == null) {, +			return handleNoContent(returnType, message);, +		}, +, +	/**, +	 * Invoked for a {@code null} return value, which could mean a void method, +	 * or method returning an async type parameterized by void., +	 * @param returnType return type of the handler method that produced the data, +	 * @param message the input message handled by the handler method, +	 * @return completion {@code Mono<Void>} for the handling, +	 */, +	protected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/InvocableHelper.java, +				.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, invocable, message))), +							.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, exHandler, message))), +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingRSocket.java, +, +, +						Mono.error(new IllegalStateException("Something went wrong: reply Mono not set"))));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		if (returnValue == null) {, +			return handleNoContent(returnType, message);, +		}, +, +	/**, +	 * Invoked for a {@code null} return value, which could mean a void method, +	 * or method returning an async type parameterized by void., +	 * @param returnType return type of the handler method that produced the data, +	 * @param message the input message handled by the handler method, +	 * @return completion {@code Mono<Void>} for the handling, +	 */, +	protected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/InvocableHelper.java, +				.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, invocable, message))), +							.switchIfEmpty(Mono.defer(() -> handleReturnValue(null, exHandler, message))), +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingRSocket.java, +, +, +						Mono.error(new IllegalStateException("Something went wrong: reply Mono not set"))));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/RSocketMessageHandler.java, +import org.springframework.messaging.Message;, +import org.springframework.messaging.MessageDeliveryException;, +import org.springframework.util.StringUtils;, +	@Override, +	protected void handleNoMatch(@Nullable String destination, Message<?> message) {, +, +		// MessagingRSocket will raise an error anyway if reply Mono is expected, +		// Here we raise a more helpful message a destination is present, +, +		// It is OK if some messages (ConnectionSetupPayload, metadataPush) are not handled, +		// We need a better way to avoid raising errors for those, +, +		if (StringUtils.hasText(destination)) {, +			throw new MessageDeliveryException("No handler for destination '" + destination + "'");, +		}, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractEncoderMethodReturnValueHandler.java, +		if (returnValue == null) {, +			return handleNoContent(returnType, message);, +		}, +, +	/**, +	 * Invoked for a {@code null} return value, which could mean a void method, +	 * or method returning an async type parameterized by void., +	 * @param returnType return type of the handler method that produced the data]