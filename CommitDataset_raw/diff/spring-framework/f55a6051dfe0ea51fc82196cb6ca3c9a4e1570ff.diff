[+++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <p>Externalized values may be injected into {@code @Configuration} classes using, + * the {@link Value @Value} annotation:, + * <p>This approach is often used in conjunction with Spring's, + * PropertySourcesPlaceholderConfigurer} that can be enabled <em>automatically</em>, + * in XML configuration via {@code <context:property-placeholder/>} or <em>explicitly</em>, + * in a {@code @Configuration} class via a dedicated {@code static} {@code @Bean} method, + * (see "a note on BeanFactoryPostProcessor-returning {@code @Bean} methods" of, + * {@link Bean @Bean}'s javadocs for details). Note, however, that explicit registration, + * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}, + * method is typically only required if you need to customize configuration such as the, + * placeholder syntax, etc. Specifically, if no bean post-processor (such as a, + * {@code PropertySourcesPlaceholderConfigurer}) has registered an <em>embedded value, + * resolver</em> for the {@code ApplicationContext}, Spring will register a default, + * <em>embedded value resolver</em> which resolves placeholders against property sources, + * registered in the {@code Environment}. See the section below on composing, + * {@code @Configuration} classes with Spring XML using {@code @ImportResource}; see, + * the {@link Value @Value} javadocs; and see the {@link Bean @Bean} javadocs for details, + * on working with {@code BeanFactoryPostProcessor} types such as, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <p>Externalized values may be injected into {@code @Configuration} classes using, + * the {@link Value @Value} annotation:, + * <p>This approach is often used in conjunction with Spring's, + * PropertySourcesPlaceholderConfigurer} that can be enabled <em>automatically</em>, + * in XML configuration via {@code <context:property-placeholder/>} or <em>explicitly</em>, + * in a {@code @Configuration} class via a dedicated {@code static} {@code @Bean} method, + * (see "a note on BeanFactoryPostProcessor-returning {@code @Bean} methods" of, + * {@link Bean @Bean}'s javadocs for details). Note, however, that explicit registration, + * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}, + * method is typically only required if you need to customize configuration such as the, + * placeholder syntax, etc. Specifically, if no bean post-processor (such as a, + * {@code PropertySourcesPlaceholderConfigurer}) has registered an <em>embedded value, + * resolver</em> for the {@code ApplicationContext}, Spring will register a default, + * <em>embedded value resolver</em> which resolves placeholders against property sources, + * registered in the {@code Environment}. See the section below on composing, + * {@code @Configuration} classes with Spring XML using {@code @ImportResource}; see, + * the {@link Value @Value} javadocs; and see the {@link Bean @Bean} javadocs for details, + * on working with {@code BeanFactoryPostProcessor} types such as, +++ b/spring-context/src/main/java/org/springframework/context/annotation/PropertySource.java, + * <p>Notice that the {@code Environment} object is, + * <h3>Resolving <code>${...}</code> placeholders in {@code <bean>} and {@code @Value} annotations</h3>, + * <p>In order to resolve ${...} placeholders in {@code <bean>} definitions or {@code @Value}, + * annotations using properties from a {@code PropertySource}, you must ensure that an, + * appropriate <em>embedded value resolver</em> is registered in the {@code BeanFactory}, + * used by the {@code ApplicationContext}. This happens automatically when using, + * {@code <context:property-placeholder>} in XML. When using {@code @Configuration} classes, + * this can be achieved by explicitly registering a {@code PropertySourcesPlaceholderConfigurer}, + * via a {@code static} {@code @Bean} method. Note, however, that explicit registration, + * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}, + * method is typically only required if you need to customize configuration such as the, + * placeholder syntax, etc. See the "Working with externalized values" section of, + * {@link Configuration @Configuration}'s javadocs and "a note on, + * BeanFactoryPostProcessor-returning {@code @Bean} methods" of {@link Bean @Bean}'s, + * javadocs for details and examples., + * <p>Any ${...} placeholders present in a {@code @PropertySource} {@linkplain #value(), + * <p>Assuming that "my.placeholder" is present in one of the property sources already, + * <p>In cases where a given property key exists in more than one {@code .properties}, + * <p>For example, given two properties files {@code a.properties} and, + * <p>The override ordering depends on the order in which these classes are registered, + * <p>In the scenario above, the properties in {@code b.properties} will override any, + * @author Sam Brannen, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * <p>Externalized values may be injected into {@code @Configuration} classes using, + * the {@link Value @Value} annotation:, + * <p>This approach is often used in conjunction with Spring's, + * PropertySourcesPlaceholderConfigurer} that can be enabled <em>automatically</em>, + * in XML configuration via {@code <context:property-placeholder/>} or <em>explicitly</em>, + * in a {@code @Configuration} class via a dedicated {@code static} {@code @Bean} method, + * (see "a note on BeanFactoryPostProcessor-returning {@code @Bean} methods" of, + * {@link Bean @Bean}'s javadocs for details). Note, however, that explicit registration, + * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}, + * method is typically only required if you need to customize configuration such as the, + * placeholder syntax, etc. Specifically, if no bean post-processor (such as a, + * {@code PropertySourcesPlaceholderConfigurer}) has registered an <em>embedded value, + * resolver</em> for the {@code ApplicationContext}, Spring will register a default, + * <em>embedded value resolver</em> which resolves placeholders against property sources, + * registered in the {@code Environment}. See the section below on composing, + * {@code @Configuration} classes with Spring XML using {@code @ImportResource}; see, + * the {@link Value @Value} javadocs; and see the {@link Bean @Bean} javadocs for details, + * on working with {@code BeanFactoryPostProcessor} types such as, +++ b/spring-context/src/main/java/org/springframework/context/annotation/PropertySource.java, + * <p>Notice that the {@code Environment} object is, + * <h3>Resolving <code>${...}</code> placeholders in {@code <bean>} and {@code @Value} annotations</h3>, + * <p>In order to resolve ${...} placeholders in {@code <bean>} definitions or {@code @Value}, + * annotations using properties from a {@code PropertySource}, you must ensure that an, + * appropriate <em>embedded value resolver</em> is registered in the {@code BeanFactory}, + * used by the {@code ApplicationContext}. This happens automatically when using, + * {@code <context:property-placeholder>} in XML. When using {@code @Configuration} classes, + * this can be achieved by explicitly registering a {@code PropertySourcesPlaceholderConfigurer}, + * via a {@code static} {@code @Bean} method. Note, however, that explicit registration, + * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}, + * method is typically only required if you need to customize configuration such as the, + * placeholder syntax, etc. See the "Working with externalized values" section of, + * {@link Configuration @Configuration}'s javadocs and "a note on, + * BeanFactoryPostProcessor-returning {@code @Bean} methods" of {@link Bean @Bean}'s, + * javadocs for details and examples., + * <p>Any ${...} placeholders present in a {@code @PropertySource} {@linkplain #value(), + * <p>Assuming that "my.placeholder" is present in one of the property sources already, + * <p>In cases where a given property key exists in more than one {@code .properties}, + * <p>For example, given two properties files {@code a.properties} and]