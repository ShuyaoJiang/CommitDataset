[+++ b/src/asciidoc/appendix.adoc, +===== The HibernateTemplate, +++ b/src/asciidoc/appendix.adoc, +===== The HibernateTemplate, +++ b/src/asciidoc/core-beans.adoc, +, +, +, +, +, +, +, +, +, +, +=== Dependency Injection, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +beans. (This initial setup is __not__ required for the standard scopes, `singleton` and, +`prototype`.), +How you accomplish this initial setup depends on your particular Servlet environment., +processed by the Spring `DispatcherServlet` or `DispatcherPortlet`, then no special, +`DispatcherServlet` (for example, when using JSF or Struts), you need to register the, +For Servlet 3.0+, this can be done programmatically via the `WebApplicationInitializer`, +Alternatively, if there are issues with your listener setup, consider using Spring's, +`DispatcherServlet`, `RequestContextListener`, and `RequestContextFilter` all do exactly, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +Most examples in this chapter use XML to specify the configuration metadata that produces, +each `BeanDefinition` within the Spring container. The previous section, +bean definitions are explicitly defined in the XML file, while the annotations only drive, +the dependency injection. This section describes an option for implicitly detecting the, +__candidate components__ by scanning the classpath. Candidate components are classes that, +match against a filter criteria and have a corresponding bean definition registered with, +the container. This removes the need to use XML to perform bean registration; instead you, +can use annotations (for example `@Component`), AspectJ type expressions, or your own, +custom filter criteria to select which classes will have bean definitions registered with, +the container., +__stereotype__ of a repository (also known as Data Access Object or DAO). Among the uses, +, +your own code. A meta-annotation is simply an annotation that can be applied to another, +annotation. For example, the `@Service` annotation mentioned above is meta-annotated with, +	@Target(ElementType.TYPE), +With the exception of the `value` attribute, composed annotations may redeclare, +attributes from meta-annotations to allow user customization. This can be particularly, +useful when you want to only expose a subset of the meta-annotation's attributes. For, +example, here is a custom `@Scope` annotation that hardcodes the scope name to `session`, +but still allows customization of the `proxyMode`., +, +, +, +, +, +, +]