[+++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +		Assert.hasLength(type, "'type' must not be empty");, +		Assert.hasLength(subtype, "'subtype' must not be empty");, +		Assert.hasLength(attribute, "'attribute' must not be empty");, +		Assert.hasLength(value, "'value' must not be empty");, +		String charset = getParameter(PARAM_CHARSET);, +		return (charset != null ? Charset.forName(unquote(charset)) : null);, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +		Assert.hasLength(type, "'type' must not be empty");, +		Assert.hasLength(subtype, "'subtype' must not be empty");, +		Assert.hasLength(attribute, "'attribute' must not be empty");, +		Assert.hasLength(value, "'value' must not be empty");, +		String charset = getParameter(PARAM_CHARSET);, +		return (charset != null ? Charset.forName(unquote(charset)) : null);, +++ b/spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java, +	 * Comparator used by {@link #sortBySpecificity(List)}., +	 */, +	public static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new SpecificityComparator<>();, +, +	/**, +, +		int index = mimeType.indexOf(';');, +		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();, +		if (fullType.length() == 0) {, +		do {, +			int nextIndex = index + 1;, +			boolean quoted = false;, +			while (nextIndex < mimeType.length()) {, +				char ch = mimeType.charAt(nextIndex);, +				if (ch == ';') {, +					if (!quoted) {, +						break;, +					}, +				}, +				else if (ch == '"') {, +					quoted = !quoted;, +				}, +				nextIndex++;, +			}, +			String parameter = mimeType.substring(index + 1, nextIndex).trim();, +			if (parameter.length() > 0) {, +				if (parameters == null) {, +					parameters = new LinkedHashMap<>(4);, +				}, +				if (eqIndex >= 0) {, +			index = nextIndex;, +		while (index < mimeType.length());, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +		Assert.hasLength(type, "'type' must not be empty");, +		Assert.hasLength(subtype, "'subtype' must not be empty");, +		Assert.hasLength(attribute, "'attribute' must not be empty");, +		Assert.hasLength(value, "'value' must not be empty");, +		String charset = getParameter(PARAM_CHARSET);, +		return (charset != null ? Charset.forName(unquote(charset)) : null);, +++ b/spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java, +	 * Comparator used by {@link #sortBySpecificity(List)}., +	 */, +	public static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new SpecificityComparator<>();, +, +	/**, +, +		int index = mimeType.indexOf(';');, +		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();, +		if (fullType.length() == 0) {, +		do {, +			int nextIndex = index + 1;, +			boolean quoted = false;, +			while (nextIndex < mimeType.length()) {, +				char ch = mimeType.charAt(nextIndex);, +				if (ch == ';') {, +					if (!quoted) {, +						break;, +					}, +				}, +				else if (ch == '"') {, +					quoted = !quoted;, +				}, +				nextIndex++;, +			}, +			String parameter = mimeType.substring(index + 1, nextIndex).trim();, +			if (parameter.length() > 0) {, +				if (parameters == null) {, +					parameters = new LinkedHashMap<>(4);, +				}, +				if (eqIndex >= 0) {, +			index = nextIndex;, +		while (index < mimeType.length());, +++ b/spring-core/src/test/java/org/springframework/util/MimeTypeTests.java, +	public void parseQuotedSeparator() {, +		String s = "application/xop+xml;charset=utf-8;type=\"application/soap+xml;action=\\\"http://x.y.z\\\"\"";, +		MimeType mimeType = MimeType.valueOf(s);, +		assertEquals("Invalid type", "application", mimeType.getType());, +		assertEquals("Invalid subtype", "xop+xml", mimeType.getSubtype());, +		assertEquals("Invalid charset", StandardCharsets.UTF_8, mimeType.getCharset());, +		assertEquals("\"application/soap+xml;action=\\\"http://x.y.z\\\"\"", mimeType.getParameter("type"));, +	}, +, +	@Test]