[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +import org.springframework.cglib.core.ClassGenerator;, +			enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));, +, +					// We know that we are optimising so we can use the FixedStaticChainInterceptors., +, +	/**, +	 * CGLIB GeneratorStrategy variant which exposes the application ClassLoader, +	 * as thread context ClassLoader for the time of class generation, +	 * (in order for ASM to pick it up when doing common superclass resolution)., +	 */, +	private static class ClassLoaderAwareUndeclaredThrowableStrategy extends UndeclaredThrowableStrategy {, +, +		private final ClassLoader classLoader;, +, +		public ClassLoaderAwareUndeclaredThrowableStrategy(ClassLoader classLoader) {, +			super(UndeclaredThrowableException.class);, +			this.classLoader = classLoader;, +		}, +, +		@Override, +		public byte[] generate(ClassGenerator cg) throws Exception {, +			if (this.classLoader == null) {, +				return super.generate(cg);, +			}, +, +			Thread currentThread = Thread.currentThread();, +			ClassLoader threadContextClassLoader;, +			try {, +				threadContextClassLoader = currentThread.getContextClassLoader();, +			}, +			catch (Throwable ex) {, +				// Cannot access thread context ClassLoader - falling back..., +				return super.generate(cg);, +			}, +, +			boolean overrideClassLoader = !this.classLoader.equals(threadContextClassLoader);, +			if (overrideClassLoader) {, +				currentThread.setContextClassLoader(this.classLoader);, +			}, +			try {, +				return super.generate(cg);, +			}, +			finally {, +				if (overrideClassLoader) {, +					// Reset original thread context ClassLoader., +					currentThread.setContextClassLoader(threadContextClassLoader);, +				}, +			}, +		}, +	}, +, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +import org.springframework.cglib.core.ClassGenerator;, +			enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));, +, +					// We know that we are optimising so we can use the FixedStaticChainInterceptors., +, +	/**, +	 * CGLIB GeneratorStrategy variant which exposes the application ClassLoader, +	 * as thread context ClassLoader for the time of class generation, +	 * (in order for ASM to pick it up when doing common superclass resolution)., +	 */, +	private static class ClassLoaderAwareUndeclaredThrowableStrategy extends UndeclaredThrowableStrategy {, +, +		private final ClassLoader classLoader;, +, +		public ClassLoaderAwareUndeclaredThrowableStrategy(ClassLoader classLoader) {, +			super(UndeclaredThrowableException.class);, +			this.classLoader = classLoader;, +		}, +, +		@Override, +		public byte[] generate(ClassGenerator cg) throws Exception {, +			if (this.classLoader == null) {, +				return super.generate(cg);, +			}, +, +			Thread currentThread = Thread.currentThread();, +			ClassLoader threadContextClassLoader;, +			try {, +				threadContextClassLoader = currentThread.getContextClassLoader();, +			}, +			catch (Throwable ex) {, +				// Cannot access thread context ClassLoader - falling back..., +				return super.generate(cg);, +			}, +, +			boolean overrideClassLoader = !this.classLoader.equals(threadContextClassLoader);, +			if (overrideClassLoader) {, +				currentThread.setContextClassLoader(this.classLoader);, +			}, +			try {, +				return super.generate(cg);, +			}, +			finally {, +				if (overrideClassLoader) {, +					// Reset original thread context ClassLoader., +					currentThread.setContextClassLoader(threadContextClassLoader);, +				}]