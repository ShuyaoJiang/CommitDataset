[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java, +import org.springframework.core.io.buffer.DataBufferUtils;, +import org.springframework.http.client.reactive.ClientHttpResponse;, + * @author Brian Clozel, +						ex -> Mono.from(unsupportedErrorHandler(inputMessage, context, ex)),, +						skipBodyAsMono(inputMessage, context));, +						ex -> unsupportedErrorHandler(inputMessage, context, ex),, +						skipBodyAsFlux(inputMessage, context));, +	private static <T> Supplier<Flux<T>> skipBodyAsFlux(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +, +		if (isExtractingForClient(message, context)) {, +			return () -> consumeAndCancel(message).thenMany(Flux.empty());, +		}, +		else {, +			return Flux::empty;, +		}, +	}, +, +	private static <T> Supplier<Mono<T>> skipBodyAsMono(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +, +		if (isExtractingForClient(message, context)) {, +			return () -> consumeAndCancel(message).then(Mono.empty());, +		}, +		else {, +			return Mono::empty;, +		}, +	}, +, +			ReactiveHttpInputMessage inputMessage, BodyExtractor.Context context,, +			UnsupportedMediaTypeException ex) {, +		Flux<T> result;, +			result = inputMessage.getBody().map(o -> {, +			result = Flux.error(ex);, +		return isExtractingForClient(inputMessage, context) ?, +				consumeAndCancel(inputMessage).thenMany(result) : result;, +	private static boolean isExtractingForClient(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +		return !context.serverResponse().isPresent(), +				&& message instanceof ClientHttpResponse;, +	}, +, +	private static Mono<Void> consumeAndCancel(ReactiveHttpInputMessage message) {, +		return message.getBody(), +				.map(buffer -> {, +					DataBufferUtils.release(buffer);, +					throw new ReadCancellationException();, +				}), +				.onErrorResume(ReadCancellationException.class, ex -> Mono.empty()), +				.then();, +	}, +, +	@SuppressWarnings("serial"), +	private static class ReadCancellationException extends RuntimeException {, +	}, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java, +import org.springframework.core.io.buffer.DataBufferUtils;, +import org.springframework.http.client.reactive.ClientHttpResponse;, + * @author Brian Clozel, +						ex -> Mono.from(unsupportedErrorHandler(inputMessage, context, ex)),, +						skipBodyAsMono(inputMessage, context));, +						ex -> unsupportedErrorHandler(inputMessage, context, ex),, +						skipBodyAsFlux(inputMessage, context));, +	private static <T> Supplier<Flux<T>> skipBodyAsFlux(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +, +		if (isExtractingForClient(message, context)) {, +			return () -> consumeAndCancel(message).thenMany(Flux.empty());, +		}, +		else {, +			return Flux::empty;, +		}, +	}, +, +	private static <T> Supplier<Mono<T>> skipBodyAsMono(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +, +		if (isExtractingForClient(message, context)) {, +			return () -> consumeAndCancel(message).then(Mono.empty());, +		}, +		else {, +			return Mono::empty;, +		}, +	}, +, +			ReactiveHttpInputMessage inputMessage, BodyExtractor.Context context,, +			UnsupportedMediaTypeException ex) {, +		Flux<T> result;, +			result = inputMessage.getBody().map(o -> {, +			result = Flux.error(ex);, +		return isExtractingForClient(inputMessage, context) ?, +				consumeAndCancel(inputMessage).thenMany(result) : result;, +	private static boolean isExtractingForClient(ReactiveHttpInputMessage message,, +			BodyExtractor.Context context) {, +		return !context.serverResponse().isPresent(), +				&& message instanceof ClientHttpResponse;, +	}, +, +	private static Mono<Void> consumeAndCancel(ReactiveHttpInputMessage message) {]