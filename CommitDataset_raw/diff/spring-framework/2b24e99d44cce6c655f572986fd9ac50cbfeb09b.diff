[+++ b/src/reference/docbook/testing.xml, +<chapter version="5.0", +         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd", +         xml:id="testing" xmlns="http://docbook.org/ns/docbook", +         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", +         xmlns:xs="http://www.w3.org/2001/XMLSchema", +         xmlns:ns2="http://www.w3.org/1998/Math/MathML", +         xmlns:ns="http://docbook.org/ns/docbook">, +    linkend="unit-testing">unit testing</link> and on the benefits of the Spring, +    Framework's support for <link linkend="integration-testing">integration, +    testing</link>. <emphasis>(A thorough treatment of testing in the enterprise, +    is beyond the scope of this reference manual.)</emphasis></para>, +    with objects simply instantiated using the <literal>new</literal> operator,, +    <emphasis>without Spring or any other container</emphasis>. You can use, +    <link linkend="mock-objects">mock objects</link> (in conjunction with other, +    valuable testing techniques) to test your code in isolation. If you follow, +    the architecture recommendations for Spring, the resulting clean layering, +    and componentization of your codebase will facilitate easier unit testing., +    For example, you can test service layer objects by stubbing or mocking DAO, +    or Repository interfaces, without needing to access persistent data while, +    running unit tests.</para>, +    your development methodology will boost your productivity. You may not need, +    this section of the testing chapter to help you write effective unit tests, +    for your IoC-based applications. For certain unit testing scenarios,, +        <interfacename>PropertySource</interfacename> abstractions introduced in, +        Spring 3.1 (see <xref linkend="new-in-3.1-environment-abstraction"/> and, +        <xref linkend="new-in-3.1-property-source-abstraction"/>)., +        contains an implementation of the JNDI SPI, which you can use to set up, +        a simple JNDI environment for test suites or stand-alone applications., +        If, for example, JDBC <classname>DataSource</classname>s get bound to, +        the same JNDI names in test code as within a Java EE container, you can, +        reuse both application code and configuration in testing scenarios, +        without modification.</para>, +        usage with Spring's Web MVC framework, which are useful for testing web, +        contexts and controllers. These mock objects are generally more, +        methods in unit and integration testing scenarios in which they need to, +        set a non-<literal>public</literal> field or invoke a, +            <interfacename>@Resource,</interfacename> which provides dependency, +            injection for <literal>private</literal> or, +        contains <classname>ModelAndViewAssert</classname>, which you can use in, +        combination with JUnit, TestNG, or any other testing framework for unit, +        tests dealing with Spring MVC <classname>ModelAndView</classname>, +          <literal>org.springframework.mock.web</literal></link> package.</para>, +      other enterprise infrastructure. This will enable you to test things such, +      as:</para>, +          <para>The correct wiring of your Spring IoC container contexts.</para>, +      module. The name of the actual JAR file might include the release version, +      and might also be in the long, +      <filename>org.springframework.test</filename> form, depending on where you, +      get it from (see the <link linkend="dependency-management">section on, +      Dependency Management</link> for an explanation). This library includes, +      the <literal>org.springframework.test</literal> package, which contains, +      valuable classes for integration testing with a Spring container. This, +      testing does not rely on an application server or other deployment, +      environment. Such tests are slower to run than unit tests but much faster, +      than the equivalent Cactus tests or remote tests that rely on deployment, +      to an application server.</para>, +      TestContext framework is agnostic of the actual testing framework in use,, +      thus allowing instrumentation of tests in various environments including, +      JUnit, TestNG, and so on.</para>, +        <para>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy (i.e.,, +        TestContext Framework</link>. Similarly, any test methods annotated with, +        <interfacename>@ExpectedException</interfacename> should be modified to, +        use the built-in support for expected exceptions in JUnit and, +        TestNG.</para>, +          linkend="testing-support-classes">Spring-specific base classes</link>, +          that assist developers in writing integration tests.</para>, +        those contexts. Support for the caching of loaded contexts is important,, +        because startup time can become an issue — not because of the overhead, +        of Spring itself, but because the objects instantiated by the Spring, +        container take time to instantiate. For example, a project with 50 to, +        100 Hibernate mapping files might take 10 to 20 seconds to load the, +        mapping files, and incurring that cost before running every test in, +        every test fixture leads to slower overall test runs that reduce, +        developer productivity.</para>, +        <emphasis>resource locations</emphasis> for XML configuration metadata —, +        often in the classpath — or an array of <emphasis>annotated, +        application context and requires reloading — for example, by modifying a, +        bean definition or the state of an application object — the TestContext, +        framework can be configured to reload the configuration and rebuild the, +        application context before executing the next test.</para>, +        <para>When the TestContext framework loads your application context, it, +        can optionally configure instances of your test classes via Dependency, +        Injection. This provides a convenient mechanism for setting up test, +        fixtures using preconfigured beans from your application context. A, +        strong benefit here is that you can reuse application contexts across, +        various testing scenarios (e.g., for configuring Spring-managed object, +        graphs, transactional proxies, <classname>DataSource</classname>s,, +        etc.), thus avoiding the need to duplicate complex test fixture setup, +        for individual test cases.</para>, +            <para>The Spring configuration: basically, is everything related to, +            the configuration of the, +            <para>The Hibernate mapping file configuration: is everything mapped, +            correctly, and are the correct lazy-loading settings in, +            <classname>HibernateTitleRepository</classname>: does the configured, +            instance of this class perform as anticipated?</para>, +        Also, many operations — such as inserting or modifying persistent data —, +        cannot be performed (or verified) outside a transaction.</para>, +        simply write code that can assume the existence of a transaction. If you, +        call transactionally proxied objects in your tests, they will behave]