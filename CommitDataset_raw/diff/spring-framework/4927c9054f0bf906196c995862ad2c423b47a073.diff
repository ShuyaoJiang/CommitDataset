[+++ b/spring-jms/src/main/java/org/springframework/jms/connection/SingleConnectionFactory.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +public class SingleConnectionFactory implements ConnectionFactory, QueueConnectionFactory,, +		TopicConnectionFactory, ExceptionListener, InitializingBean, DisposableBean {, +	/** The target Connection */, +	/** An internal aggregator allowing for per-connection ExceptionListeners */, +	private AggregatedExceptionListener aggregatedExceptionListener;, +, +	private int startedCount = 0;, +	 * @param targetConnection the single Connection, +	public SingleConnectionFactory(Connection targetConnection) {, +		Assert.notNull(targetConnection, "Target Connection must not be null");, +		this.connection = targetConnection;, +	 * Create a new SingleConnectionFactory that always returns a single Connection, +	 * that it will lazily create via the given target ConnectionFactory., +	 * registered with the single Connection created by this factory., +	 * with the single Connection created by this factory, if any., +			throw new IllegalArgumentException("Target Connection or ConnectionFactory is required");, +		return getSharedConnectionProxy(getConnection());, +	 * Obtain an initialized shared Connection., +	 * @return the Connection (never {@code null}), +	 * @throws javax.jms.JMSException if thrown by JMS API methods, +	 * @see #initConnection(), +	 */, +	protected Connection getConnection() throws JMSException {, +		synchronized (this.connectionMonitor) {, +			if (this.connection == null) {, +				initConnection();, +			}, +			return this.connection;, +		}, +	}, +, +	/**, +	 * @see #prepareConnection, +			if (this.connection != null) {, +				closeConnection(this.connection);, +			this.connection = doCreateConnection();, +			prepareConnection(this.connection);, +			if (this.startedCount > 0) {, +				this.connection.start();, +			}, +				logger.info("Established shared JMS Connection: " + this.connection);, +	 * @see #resetConnection(), +	 * @see #resetConnection(), +	 * @see #closeConnection, +			if (this.connection != null) {, +				closeConnection(this.connection);, +		if (this.aggregatedExceptionListener != null) {, +			con.setExceptionListener(this.aggregatedExceptionListener);, +		}, +		else if (getExceptionListener() != null || isReconnectOnException()) {, +				this.aggregatedExceptionListener = new AggregatedExceptionListener();, +				this.aggregatedExceptionListener.delegates.add(this);, +				if (listenerToUse != null) {, +					this.aggregatedExceptionListener.delegates.add(listenerToUse);, +				}, +				listenerToUse = this.aggregatedExceptionListener;, +			logger.debug("Closing shared JMS Connection: " + con);, +				if (this.startedCount > 0) {, +				new SharedConnectionInvocationHandler());, +		private ExceptionListener localExceptionListener;, +		private boolean locallyStarted = false;, +				Object other = args[0];, +				if (proxy == other) {, +					return true;, +				}, +				if (other == null || !Proxy.isProxyClass(other.getClass())) {, +					return false;, +				}, +				InvocationHandler otherHandler = Proxy.getInvocationHandler(other);, +				return (otherHandler instanceof SharedConnectionInvocationHandler &&, +						factory() == ((SharedConnectionInvocationHandler) otherHandler).factory());, +				// Use hashCode of containing SingleConnectionFactory., +				return System.identityHashCode(factory());, +				return "Shared JMS Connection: " + getConnection();, +				String currentClientId = getConnection().getClientID();, +				synchronized (connectionMonitor) {, +					if (aggregatedExceptionListener != null) {, +						ExceptionListener listener = (ExceptionListener) args[0];, +						if (listener != this.localExceptionListener) {, +							if (this.localExceptionListener != null) {, +								aggregatedExceptionListener.delegates.remove(this.localExceptionListener);, +							}, +							if (listener != null) {, +								aggregatedExceptionListener.delegates.add(listener);, +							}, +							this.localExceptionListener = listener;, +						}, +			}, +			else if (method.getName().equals("getExceptionListener")) {, +					if (this.localExceptionListener != null) {, +						return this.localExceptionListener;, +					}, +					else {, +						return getExceptionListener();, +			}, +			else if (method.getName().equals("start")) {, +				localStart();]