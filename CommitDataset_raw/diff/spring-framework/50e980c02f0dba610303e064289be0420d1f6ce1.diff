[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.lang.annotation.Annotation;, +import org.springframework.core.annotation.AnnotationUtils;, +			// Sanity test that we can reflectively read annotations,, +			// including Class attributes; if not -> fall back to ASM, +			for (Annotation ann : classType.getAnnotations()) {, +				AnnotationUtils.validateAnnotation(ann);, +			}, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.lang.annotation.Annotation;, +import org.springframework.core.annotation.AnnotationUtils;, +			// Sanity test that we can reflectively read annotations,, +			// including Class attributes; if not -> fall back to ASM, +			for (Annotation ann : classType.getAnnotations()) {, +				AnnotationUtils.validateAnnotation(ann);, +			}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, + * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared, + * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared, + * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}., + * <p>Methods following <em>get semantics</em> will honor the contract of Java's, + * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally, + * declared annotations (including custom composed annotations) will be favored over, + * inherited annotations. In contrast, methods following <em>find semantics</em>, + * will completely ignore the presence of {@code @Inherited} since the <em>find</em>, + * search algorithm manually traverses type and method hierarchies and thereby, + * implicitly supports annotation inheritance without a need for {@code @Inherited}., +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.lang.annotation.Annotation;, +import org.springframework.core.annotation.AnnotationUtils;, +			// Sanity test that we can reflectively read annotations,, +			// including Class attributes; if not -> fall back to ASM, +			for (Annotation ann : classType.getAnnotations()) {, +				AnnotationUtils.validateAnnotation(ann);, +			}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, + * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared, + * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared, + * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}., + * <p>Methods following <em>get semantics</em> will honor the contract of Java's, + * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally, + * declared annotations (including custom composed annotations) will be favored over, + * inherited annotations. In contrast, methods following <em>find semantics</em>, + * will completely ignore the presence of {@code @Inherited} since the <em>find</em>, + * search algorithm manually traverses type and method hierarchies and thereby, + * implicitly supports annotation inheritance without a need for {@code @Inherited}., +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +	 * @return the result of the processor (potentially {@code null}), +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +	 * Check the declared attributes of the given annotation, in particular covering, +	 * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for, +	 * {@code Class} values (instead of early {@code Class.getAnnotations() failure}., +	 * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}, +	 * won't failure either (when attempted later on)., +	 * @param annotation the annotation to validate, +	 * @throws IllegalStateException if a declared {@code Class} attribute could not be read, +	 * @since 4.3.15, +	 * @see Class#getAnnotations(), +	 * @see #getAnnotationAttributes(Annotation), +	 */, +	public static void validateAnnotation(Annotation annotation) {, +		for (Method method : getAttributeMethods(annotation.annotationType())) {, +			if (method.getReturnType() == Class.class) {, +				try {, +					method.invoke(annotation);, +				}, +				catch (Throwable ex) {, +					throw new IllegalStateException("Could not obtain annotation attribute value for " + method, ex);, +				}, +			}, +		}, +	}, +, +	/**, +				loggerToUse.debug("Failed to meta-introspect annotation " + element + ": " + ex);, +				loggerToUse.info("Failed to introspect annotations on " + element + ": " + ex);]