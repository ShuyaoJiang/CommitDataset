[+++ b/spring-web/src/main/java/org/springframework/web/util/patterns/PathPatternRegistry.java, +		Set<String> fixedFileExtensions = (fileExtensions != null) ? fileExtensions.stream(), +				.map(ext -> (ext.charAt(0) != '.') ? "." + ext : ext), +				.collect(Collectors.toSet()) : Collections.emptySet();, +		this.fileExtensions = fixedFileExtensions;, +	 * Return a (read-only) set of all patterns for matching (including generated pattern variants)., +		String fixedPattern = prependLeadingSlash(rawPattern);, +		PathPattern pattern = this.pathPatternParser.parse(fixedPattern);, +		if (StringUtils.hasLength(fixedPattern) && !pattern.isCatchAll()) {, +						newPatterns.add(this.pathPatternParser.parse(fixedPattern + extension));, +					newPatterns.add(this.pathPatternParser.parse(fixedPattern + ".*"));, +			if (this.useTrailingSlashMatch && !fixedPattern.endsWith("/")) {, +				newPatterns.add(this.pathPatternParser.parse(fixedPattern + "/"));, +	private String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {, +			return pattern;, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/web/util/patterns/PathPatternRegistry.java, +		Set<String> fixedFileExtensions = (fileExtensions != null) ? fileExtensions.stream(), +				.map(ext -> (ext.charAt(0) != '.') ? "." + ext : ext), +				.collect(Collectors.toSet()) : Collections.emptySet();, +		this.fileExtensions = fixedFileExtensions;, +	 * Return a (read-only) set of all patterns for matching (including generated pattern variants)., +		String fixedPattern = prependLeadingSlash(rawPattern);, +		PathPattern pattern = this.pathPatternParser.parse(fixedPattern);, +		if (StringUtils.hasLength(fixedPattern) && !pattern.isCatchAll()) {, +						newPatterns.add(this.pathPatternParser.parse(fixedPattern + extension));, +					newPatterns.add(this.pathPatternParser.parse(fixedPattern + ".*"));, +			if (this.useTrailingSlashMatch && !fixedPattern.endsWith("/")) {, +				newPatterns.add(this.pathPatternParser.parse(fixedPattern + "/"));, +	private String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {, +			return pattern;, +		}, +	}, +, +++ b/spring-web/src/test/java/org/springframework/web/util/patterns/PathPatternRegistryTests.java, +import static org.hamcrest.Matchers.contains;, + * , +	public void shouldFixFileExtensions() {, +		Set<String> fileExtensions = new HashSet<>();, +		fileExtensions.add("json");, +		fileExtensions.add("xml");, +		this.registry.setFileExtensions(fileExtensions);, +		assertThat(this.registry.getFileExtensions(), contains(".json", ".xml"));, +	}, +, +	@Test, +	public void shouldPrependPatternsWithSlash() {, +		this.registry.register("foo/bar");, +		assertThat(getPatternList(this.registry.getPatterns()), Matchers.containsInAnyOrder("/foo/bar"));, +	}, +, +	@Test, +		assertThat(getPatternList(patterns), Matchers.containsInAnyOrder("/foo/{bar}"));, +		assertThat(getPatternList(patterns), Matchers.containsInAnyOrder("/foo/{bar}", "/foo/{bar}/"));, +		assertThat(getPatternList(patterns), Matchers.containsInAnyOrder("/foo/{bar}", "/foo/{bar}.*"));, +		fileExtensions.add(".json");, +		fileExtensions.add(".xml");, +		assertThat(getPatternList(patterns),, +				Matchers.containsInAnyOrder("/foo/{bar}", "/foo/{bar}.xml", "/foo/{bar}.json"));, +		fileExtensions.add(".json");, +		fileExtensions.add(".xml");, +		assertThat(getPatternList(patterns), Matchers.containsInAnyOrder("/foo/{bar}",, +				"/foo/{bar}.xml", "/foo/{bar}.json", "/foo/{bar}/"));, +		assertThat(getPatternList(result.getPatterns()), Matchers.containsInAnyOrder(""));, +		assertThat(getPatternList(result.getPatterns()), Matchers.containsInAnyOrder("/foo"));, +		assertThat(getPatternList(result.getPatterns()), Matchers.containsInAnyOrder("/foo/bar", "/foo/baz"));, +		assertThat(getPatternList(matches), Matchers.contains("/f?o", "/fo?"));, +		assertThat(getPatternList(matches), Matchers.contains("/foo/bar/baz", "/foo/bar/{baz}",, +				"/foo/{*baz}"));, +	private List<String> getPatternList(Collection<PathPattern> parsedPatterns) {, +		return parsedPatterns.stream().map(pattern -> pattern.getPatternString()).collect(Collectors.toList());, +, +++ b/spring-web/src/main/java/org/springframework/web/util/patterns/PathPatternRegistry.java, +		Set<String> fixedFileExtensions = (fileExtensions != null) ? fileExtensions.stream(), +				.map(ext -> (ext.charAt(0) != '.') ? "." + ext : ext), +				.collect(Collectors.toSet()) : Collections.emptySet();, +		this.fileExtensions = fixedFileExtensions;, +	 * Return a (read-only) set of all patterns for matching (including generated pattern variants)., +		String fixedPattern = prependLeadingSlash(rawPattern);, +		PathPattern pattern = this.pathPatternParser.parse(fixedPattern);, +		if (StringUtils.hasLength(fixedPattern) && !pattern.isCatchAll()) {, +						newPatterns.add(this.pathPatternParser.parse(fixedPattern + extension));, +					newPatterns.add(this.pathPatternParser.parse(fixedPattern + ".*"));, +			if (this.useTrailingSlashMatch && !fixedPattern.endsWith("/")) {, +				newPatterns.add(this.pathPatternParser.parse(fixedPattern + "/"));, +	private String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {]