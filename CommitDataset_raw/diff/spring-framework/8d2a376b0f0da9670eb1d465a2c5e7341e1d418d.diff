[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler,, +			boolean handleConnect) {, +		this.stompHandler.setHandleConnect(handleConnect);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler,, +			boolean handleConnect) {, +		this.stompHandler.setHandleConnect(handleConnect);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +		boolean brokerRelayConfigured = getMessageBrokerConfigurer().getStompBrokerRelay() != null;, +		ServletStompEndpointRegistry registry = new ServletStompEndpointRegistry(subProtocolWebSocketHandler(),, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler(), !brokerRelayConfigured);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler,, +			boolean handleConnect) {, +		this.stompHandler.setHandleConnect(handleConnect);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +		boolean brokerRelayConfigured = getMessageBrokerConfigurer().getStompBrokerRelay() != null;, +		ServletStompEndpointRegistry registry = new ServletStompEndpointRegistry(subProtocolWebSocketHandler(),, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler(), !brokerRelayConfigured);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +			tcpConn.on().close(new Runnable() {, +				@Override, +				public void run() {, +					connectionClosed();, +				}, +			});, +				logger.warn("Message sent to relay before it was CONNECTED. Discarding message: " + message);, +			StompCommand command = StompHeaderAccessor.wrap(message).getCommand();, +, +			if (command == StompCommand.DISCONNECT) {, +				this.stompConnection.setDisconnected();, +			}, +, +					if (command != StompCommand.DISCONNECT) {, +		protected void connectionClosed() {, +			relaySessions.remove(this.sessionId);, +			if (this.stompConnection.isReady()) {, +				sendError("Lost connection to the broker");, +		 private static final long HEARTBEAT_SEND_INTERVAL = 10000;, +, +		 private static final long HEARTBEAT_RECEIVE_INTERVAL = 10000;, +, +			headers.setHeartbeat(HEARTBEAT_SEND_INTERVAL, HEARTBEAT_RECEIVE_INTERVAL);, +		protected void connectionClosed() {, +			publishBrokerUnavailableEvent();, +		}, +, +		@Override, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler,, +			boolean handleConnect) {, +		this.stompHandler.setHandleConnect(handleConnect);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +		boolean brokerRelayConfigured = getMessageBrokerConfigurer().getStompBrokerRelay() != null;, +		ServletStompEndpointRegistry registry = new ServletStompEndpointRegistry(subProtocolWebSocketHandler(),, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler(), !brokerRelayConfigured);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +			tcpConn.on().close(new Runnable() {, +				@Override, +				public void run() {, +					connectionClosed();, +				}, +			});, +				logger.warn("Message sent to relay before it was CONNECTED. Discarding message: " + message);, +			StompCommand command = StompHeaderAccessor.wrap(message).getCommand();, +, +			if (command == StompCommand.DISCONNECT) {, +				this.stompConnection.setDisconnected();, +			}, +, +					if (command != StompCommand.DISCONNECT) {, +		protected void connectionClosed() {, +			relaySessions.remove(this.sessionId);, +			if (this.stompConnection.isReady()) {, +				sendError("Lost connection to the broker");, +		 private static final long HEARTBEAT_SEND_INTERVAL = 10000;, +, +		 private static final long HEARTBEAT_RECEIVE_INTERVAL = 10000;, +, +			headers.setHeartbeat(HEARTBEAT_SEND_INTERVAL, HEARTBEAT_RECEIVE_INTERVAL);, +		protected void connectionClosed() {, +			publishBrokerUnavailableEvent();, +		}, +, +		@Override, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompProtocolHandler.java, +	private volatile boolean handleConnect = false;, +	/**, +	 * Configures the handling of CONNECT frames. When {@code true}, CONNECT, +	 * frames will be handled by this handler, and a CONNECTED response will be, +	 * sent. When {@code false}, CONNECT frames will be forwarded for, +	 * handling by another component., +	 *, +	 * @param handleConnect {@code true} if connect frames should be handled, +	 * by this handler, {@code false} otherwise., +	 */]