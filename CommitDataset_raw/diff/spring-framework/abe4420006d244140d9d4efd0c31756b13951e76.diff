[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompReactorNettyCodec.java, +public class StompReactorNettyCodec extends AbstractNioBufferReactorNettyCodec<byte[]> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompReactorNettyCodec.java, +public class StompReactorNettyCodec extends AbstractNioBufferReactorNettyCodec<byte[]> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpClient.java, +import org.springframework.lang.Nullable;, +	@Nullable, +	@Nullable, +	private LoopResources loopResources;, +	@Nullable, +	private PoolResources poolResources;, +	private final Scheduler scheduler = Schedulers.newParallel("tcp-client-scheduler");, +	 * Simple constructor with a host and a port., +	 * @param host the host to connect to, +	 * @param port the port to connect to, +	 * @param codec the code to use, +	 * @see org.springframework.messaging.simp.stomp.StompReactorNettyCodec, +		this(builder -> builder.host(host).port(port), codec);, +	 * Constructor with a {@link ClientOptions.Builder} that can be used to, +	 * customize Reactor Netty client options., +	 *, +	 * <p><strong>Note: </strong> this constructor manages the lifecycle of the, +	 * {@link TcpClient} and its underlying resources. Please do not customize, +	 * any of the following options:, +	 * {@link ClientOptions.Builder#channelGroup(ChannelGroup) ChannelGroup},, +	 * {@link ClientOptions.Builder#loopResources(LoopResources) LoopResources}, and, +	 * {@link ClientOptions.Builder#poolResources(PoolResources) PoolResources}., +	 * You may set the {@link ClientOptions.Builder#disablePool() disablePool}, +	 * option if you simply want to turn off pooling., +	 *, +	 * <p>For full control over the initialization and lifecycle of the TcpClient,, +	 * see {@link #ReactorNettyTcpClient(TcpClient, ReactorNettyCodec)}., +	 *, +	 * @param optionsConsumer consumer to customize client options, +	 * @param codec the code to use, +	 * @see org.springframework.messaging.simp.stomp.StompReactorNettyCodec, +	public ReactorNettyTcpClient(Consumer<ClientOptions.Builder<?>> optionsConsumer,, +			ReactorNettyCodec<P> codec) {, +, +		Consumer<ClientOptions.Builder<?>> builtInConsumer = builder -> {, +, +			Assert.isTrue(!builder.isLoopAvailable() && !builder.isPoolAvailable(),, +					"The provided ClientOptions.Builder contains LoopResources and/or PoolResources. " +, +							"Please, use the constructor that accepts a TcpClient instance " +, +							"for full control over initialization and lifecycle.");, +, +			builder.channelGroup(this.channelGroup);, +			builder.preferNative(false);, +, +			this.loopResources = LoopResources.create("tcp-client-loop");, +			builder.loopResources(this.loopResources);, +, +			if (!builder.isPoolDisabled()) {, +				this.poolResources = PoolResources.fixed("tcp-client-pool");, +				builder.poolResources(this.poolResources);, +			}, +		};, +	/**, +	 * Constructor with an externally created {@link TcpClient} instance whose, +	 * lifecycle is expected to be managed externally., +	 *, +	 * @param tcpClient the TcpClient instance to use, +	 * @param codec the code to use, +	 * @see org.springframework.messaging.simp.stomp.StompReactorNettyCodec, +	 */, +	public ReactorNettyTcpClient(TcpClient tcpClient, ReactorNettyCodec<P> codec) {, +		Assert.notNull(tcpClient, "TcpClient is required");, +		Assert.notNull(codec, "ReactorNettyCodec is required");, +		this.tcpClient = tcpClient;, +		this.codec = codec;, +, +		this.channelGroup = null;, +		this.loopResources = null;, +		this.poolResources = null;, +	}, +, +						.map(time -> Mono.delay(Duration.ofMillis(time), this.scheduler)), +						.orElse(Mono.empty()));, +		Mono<Void> result;, +		if (this.channelGroup != null) {, +			result = FutureMono.from(this.channelGroup.close());, +			if (this.loopResources != null) {, +				result = result.onErrorResume(ex -> Mono.empty()).then(this.loopResources.disposeLater());, +			if (this.poolResources != null) {, +				result = result.onErrorResume(ex -> Mono.empty()).then(this.poolResources.disposeLater());, +			}, +			result = result.onErrorResume(ex -> Mono.empty()).then(stopScheduler());, +		}, +		else {, +			result = stopScheduler();, +		return new MonoToListenableFutureAdapter<>(result);, +	}, +, +	private Mono<Void> stopScheduler() {, +		return Mono.fromRunnable(() -> {, +			for (int i = 0; i < 20; i++) {, +				if (this.scheduler.isDisposed()) {, +					break;, +					Thread.sleep(100);, +				catch (Throwable ex) {]