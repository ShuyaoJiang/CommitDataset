[+++ b/src/asciidoc/index.adoc, +* The https://github.com/sockjs/sockjs-client[SockJS JavaScript client] - a client library for use in browsers., +* As of 4.1 `spring-websocket` also provides a SockJS Java client., +A SockJS Java client is provided in order to connect to remote SockJS endpoints without, +communication between 2 servers over a public network, i.e. where network proxies may, +preclude the use of the WebSocket protocol. A SockJS Java client is also very useful, +for testing purposes for example to simulate a large number of concurrent users., +The SockJS Java client supports the "websocket", "xhr-streaming", and "xhr-polling", +transports. The remaining ones only make sense for use in a browser., +The `WebSocketTransport` can be configured with:, +* `StandardWebSocketClient` in a JSR-356 runtime, +* `JettyWebSocketClient` using the Jetty 9+ native WebSocket API, +* Any implementation of Spring's `WebSocketClient`, +, +An `XhrTransport` by definition supports both "xhr-streaming" and "xhr-polling" since, +from a client perspective there is no difference other than in the URL used to connect, +to the server. At present there are two implementations:, +, +* `RestTemplateXhrTransport` uses the RestTemplate for HTTP requests., +* `JettyXhrTransport` uses Jetty's HttpClient for HTTP requests., +, +The example below shows how to create a SockJS client and connect to a SockJS endpoint:, +  List<Transport> transports = new ArrayList<>(2);, +  transports.add(new WebSocketTransport(StandardWebSocketClient()));, +  transports.add(new RestTemplateXhrTransport());, +, +  sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");, +SockJS uses JSON formatted arrays for messages. By default Jackson 2 is used and needs, +to be on the classpath. Alternatively you can configure a custom implementation of, +`SockJsMessageCodec` and configure it on the SockJsClient., +To use the SockJsClient for simulating a large number of concurrent users you will, +need to configure the underlying HTTP client (for XHR transports) to allow a sufficient, +number of connections and threads. For example with Jetty:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +HttpClient jettyHttpClient = new HttpClient();, +jettyHttpClient.setMaxConnectionsPerDestination(1000);, +jettyHttpClient.setExecutor(new QueuedThreadPool(1000));, +----, +, +Consider also customizing these server-side SockJS related properties (see Javadoc for details):, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +@Configuration, +public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {, +, +    @Override, +    public void registerStompEndpoints(StompEndpointRegistry registry) {, +        registry.addEndpoint("/sockjs").withSockJS(), +            .setStreamBytesLimit(512 * 1024), +            .setHttpMessageCacheSize(1000), +            .setDisconnectDelay(30 * 1000);, +    }, +, +    // ..., +, +}, +----, +, +]