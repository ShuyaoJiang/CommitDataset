[+++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/ResolvableMethod.java, +import java.util.function.Consumer;, +import java.util.function.Supplier;, +import java.util.stream.Collectors;, +import org.aopalliance.intercept.MethodInterceptor;, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +, +import org.springframework.aop.framework.ProxyFactory;, +import org.springframework.aop.target.EmptyTargetSource;, +import org.springframework.cglib.core.SpringNamingPolicy;, +import org.springframework.cglib.proxy.Callback;, +import org.springframework.cglib.proxy.Enhancer;, +import org.springframework.cglib.proxy.Factory;, +import org.springframework.cglib.proxy.MethodProxy;, +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.objenesis.ObjenesisException;, +import org.springframework.objenesis.SpringObjenesis;, + * Convenience class to resolve a method and its parameters based on hints., + * <h1>Background</h1>, + * <p>When testing annotated methods we create test classes such as, + * "TestController" with a diverse range of method signatures representing, + * supported annotations and argument types. It becomes challenging to use, + * naming strategies to keep track of methods and arguments especially in, + * combination variables for reflection metadata., + *, + * <p>The idea with {@link ResolvableMethod} is NOT to rely on naming techniques, + * but to use hints to zero in on method parameters. Especially in combination, + * with {@link ResolvableType} such hints can be strongly typed and make tests, + * more readable by being explicit about what is being tested and more robust, + * since the provided hints have to match., + *, + * <p>Common use cases:, + *, + * <h2>1. Declared Return Type</h2>, + *, + * When testing return types it's common to have many methods with a unique, + * return type, possibly with or without an annotation., + * import static org.springframework.web.reactive.result.ResolvableMethod.on;, + * // Return type, + * on(TestController.class).resolveReturnType(Foo.class);, + *, + * // Annotation + return type, + * on(TestController.class).annotated(ResponseBody.class).resolveReturnType(Bar.class);, + *, + * // Annotation not present, + * on(TestController.class).isNotAnnotated(ResponseBody.class).resolveReturnType();, + *, + * // Annotation properties, + * on(TestController.class), + *         .annotated(RequestMapping.class, patterns("/foo"), params("p")), + *         .annotated(ResponseBody.class), + *         .resolveReturnType();, + * <h2>2. Method Arguments</h2>, + *, + * When testing method arguments it's more likely to have one or a small number, + * of methods with a wide array of argument types and parameter annotations., + *, + * <pre>, + *, + * ResolvableMethod testMethod = ResolvableMethod.on(getClass()).named("handle").build();, + *, + * testMethod.arg(Foo.class);, + * testMethod.annotated(RequestBody.class)).arg(Bar.class);, + * testMethod.annotated(RequestBody.class), required()).arg(Bar.class);, + * testMethod.notAnnotated(RequestBody.class)).arg(Bar.class);, + * </pre>, + *, + * <h3>3. Mock Handler Method Invocation</h3>, + *, + * Locate a method by invoking it through a proxy of the target handler:, + *, + * <pre>, + *, + * ResolvableMethod.on(TestController.class).mockCall(o -> o.handle(null)).method();, + * </pre>, +	private static final Log logger = LogFactory.getLog(ResolvableMethod.class);, +, +	private static final SpringObjenesis objenesis = new SpringObjenesis();, +, +, +	private final Method method;, +, +, +	private ResolvableMethod(Method method) {, +		Assert.notNull(method, "method is required");, +		this.method = method;, +	}, +, +, +	/**, +	 * Return the resolved method., +	 */, +	public Method method() {, +		return this.method;, +	}, +, +	/**, +	 * Return the declared return type of the resolved method., +	 */]