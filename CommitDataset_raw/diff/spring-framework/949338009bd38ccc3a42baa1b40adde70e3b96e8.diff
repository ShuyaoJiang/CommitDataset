[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java, +import org.springframework.beans.factory.Aware;, +import org.springframework.beans.factory.DisposableBean;, +import org.springframework.beans.factory.InitializingBean;, +import org.springframework.util.ObjectUtils;, +		if (!proxyFactory.isProxyTargetClass()) {, +			if (shouldProxyTargetClass(beanClass, beanName)) {, +				proxyFactory.setProxyTargetClass(true);, +			}, +			else {, +				evaluateProxyInterfaces(beanClass, proxyFactory);, +	 * Determine whether the given bean should be proxied with its target class rather than its interfaces., +	 * <p>Checks the {@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE "preserveTargetClass" attribute}, +		return (this.beanFactory instanceof ConfigurableListableBeanFactory &&, +				AutoProxyUtils.shouldProxyTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName));, +	}, +, +	/**, +	 * Check the interfaces on the given bean class and apply them to the ProxyFactory,, +	 * if appropriate., +	 * <p>Calls {@link #isConfigurationCallbackInterface} to filter for reasonable, +	 * proxy interfaces, falling back to a target-class proxy otherwise., +	 * @param beanClass the class of the bean, +	 * @param proxyFactory the ProxyFactory for the bean, +	 */, +	private void evaluateProxyInterfaces(Class<?> beanClass, ProxyFactory proxyFactory) {, +		Class<?>[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);, +		boolean hasReasonableProxyInterface = false;, +		for (Class<?> ifc : targetInterfaces) {, +			if (!isConfigurationCallbackInterface(ifc) && ifc.getMethods().length > 0) {, +				hasReasonableProxyInterface = true;, +				break;, +			}, +		}, +		if (hasReasonableProxyInterface) {, +			// Must allow for introductions; can't just set interfaces to the target's interfaces only., +			for (Class<?> ifc : targetInterfaces) {, +				proxyFactory.addInterface(ifc);, +			}, +		}, +		else {, +			proxyFactory.setProxyTargetClass(true);, +		}, +	}, +, +	/**, +	 * Determine whether the given interface is just a container callback and, +	 * therefore not to be considered as a reasonable proxy interface., +	 * <p>If no reasonable proxy interface is found for a given bean, it will get, +	 * proxied with its full target class, assuming that as the user's intention., +	 * @param ifc the interface to check, +	 * @return whether the given interface is just a container callback, +	 */, +	protected boolean isConfigurationCallbackInterface(Class<?> ifc) {, +		return (ifc.equals(InitializingBean.class) || ifc.equals(DisposableBean.class) ||, +				ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class));, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java, +import org.springframework.beans.factory.Aware;, +import org.springframework.beans.factory.DisposableBean;, +import org.springframework.beans.factory.InitializingBean;, +import org.springframework.util.ObjectUtils;, +		if (!proxyFactory.isProxyTargetClass()) {, +			if (shouldProxyTargetClass(beanClass, beanName)) {, +				proxyFactory.setProxyTargetClass(true);, +			}, +			else {, +				evaluateProxyInterfaces(beanClass, proxyFactory);, +	 * Determine whether the given bean should be proxied with its target class rather than its interfaces., +	 * <p>Checks the {@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE "preserveTargetClass" attribute}, +		return (this.beanFactory instanceof ConfigurableListableBeanFactory &&, +				AutoProxyUtils.shouldProxyTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName));, +	}, +, +	/**, +	 * Check the interfaces on the given bean class and apply them to the ProxyFactory,, +	 * if appropriate., +	 * <p>Calls {@link #isConfigurationCallbackInterface} to filter for reasonable, +	 * proxy interfaces, falling back to a target-class proxy otherwise., +	 * @param beanClass the class of the bean, +	 * @param proxyFactory the ProxyFactory for the bean, +	 */, +	private void evaluateProxyInterfaces(Class<?> beanClass, ProxyFactory proxyFactory) {, +		Class<?>[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);, +		boolean hasReasonableProxyInterface = false;, +		for (Class<?> ifc : targetInterfaces) {, +			if (!isConfigurationCallbackInterface(ifc) && ifc.getMethods().length > 0) {, +				hasReasonableProxyInterface = true;, +				break;, +			}, +		}, +		if (hasReasonableProxyInterface) {, +			// Must allow for introductions; can't just set interfaces to the target's interfaces only., +			for (Class<?> ifc : targetInterfaces) {, +				proxyFactory.addInterface(ifc);, +			}, +		}, +		else {, +			proxyFactory.setProxyTargetClass(true);, +		}, +	}]