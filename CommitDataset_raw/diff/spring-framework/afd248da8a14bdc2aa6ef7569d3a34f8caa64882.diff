[+++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriter.java, +		// The writer will call MultipartHttpOutputMessage#write which doesn't actually write, +		// but only stores the body Flux and returns Mono.empty()., +, +		Mono<Void> partContentReady = ((HttpMessageWriter<T>) writer.get()), +		// After partContentReady, we can access the part content from MultipartHttpOutputMessage, +		// and use it for writing to the actual request body, +, +		Flux<DataBuffer> partContent = partContentReady.thenMany(Flux.defer(outputMessage::getBody));, +, +		return Flux.concat(Mono.just(generateBoundaryLine(boundary)), partContent, Mono.just(generateNewLine()));, +, +			// We don't actually want to write (just save the body Flux), +			return Mono.empty();, +			return Mono.error(new UnsupportedOperationException());, +++ b/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriter.java, +		// The writer will call MultipartHttpOutputMessage#write which doesn't actually write, +		// but only stores the body Flux and returns Mono.empty()., +, +		Mono<Void> partContentReady = ((HttpMessageWriter<T>) writer.get()), +		// After partContentReady, we can access the part content from MultipartHttpOutputMessage, +		// and use it for writing to the actual request body, +, +		Flux<DataBuffer> partContent = partContentReady.thenMany(Flux.defer(outputMessage::getBody));, +, +		return Flux.concat(Mono.just(generateBoundaryLine(boundary)), partContent, Mono.just(generateNewLine()));, +, +			// We don't actually want to write (just save the body Flux), +			return Mono.empty();, +			return Mono.error(new UnsupportedOperationException());, +++ b/spring-web/src/test/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriterTests.java, +import java.io.IOException;, +import reactor.core.publisher.UnicastProcessor;, +	}, +	@Test // SPR-16402, +	public void singleSubscriberWithResource() throws IOException {, +		UnicastProcessor<Resource> processor = UnicastProcessor.create();, +		Resource logo = new ClassPathResource("/org/springframework/http/converter/logo.jpg");, +		Mono.just(logo).subscribe(processor);, +		MultipartBodyBuilder bodyBuilder = new MultipartBodyBuilder();, +		bodyBuilder.asyncPart("logo", processor, Resource.class);, +		Mono<MultiValueMap<String, HttpEntity<?>>> result = Mono.just(bodyBuilder.build());, +, +		MockServerHttpResponse response = new MockServerHttpResponse();, +		Map<String, Object> hints = Collections.emptyMap();, +		this.writer.write(result, null, MediaType.MULTIPART_FORM_DATA, response, hints).block();, +, +		MultiValueMap<String, Part> requestParts = parse(response, hints);, +		assertEquals(1, requestParts.size());, +, +		Part part = requestParts.getFirst("logo");, +		assertEquals("logo", part.name());, +// TODO: a Resource written as an async part doesn't have a file name in the contentDisposition, +//		assertTrue(part instanceof FilePart);, +//		assertEquals("logo.jpg", ((FilePart) part).filename());, +		assertEquals(MediaType.IMAGE_JPEG, part.headers().getContentType());, +		assertEquals(logo.getFile().length(), part.headers().getContentLength());, +	}, +, +	@Test // SPR-16402, +	public void singleSubscriberWithStrings() {, +		UnicastProcessor<String> processor = UnicastProcessor.create();, +		Flux.just("foo", "bar", "baz").subscribe(processor);, +, +		MultipartBodyBuilder bodyBuilder = new MultipartBodyBuilder();, +		bodyBuilder.asyncPart("name", processor, String.class);, +, +		Mono<MultiValueMap<String, HttpEntity<?>>> result = Mono.just(bodyBuilder.build());, +, +		MockServerHttpResponse response = new MockServerHttpResponse();, +		Map<String, Object> hints = Collections.emptyMap();, +		this.writer.write(result, null, MediaType.MULTIPART_FORM_DATA, response, hints).block();]