[+++ b/spring-jms/src/main/java/org/springframework/jms/support/SimpleJmsHeaderMapper.java, +import javax.jms.Message;, +import org.springframework.messaging.support.AbstractHeaderMapper;, + * @author Stephane Nicoll, +public class SimpleJmsHeaderMapper extends AbstractHeaderMapper<Message> implements JmsHeaderMapper {, +			Destination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);, +			if (jmsReplyTo != null) {, +					jmsMessage.setJMSReplyTo(jmsReplyTo);, +			String jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);, +			if (jmsType != null) {, +					jmsMessage.setJMSType(jmsType);, +	protected String fromHeaderName(String headerName) {, +		if (MessageHeaders.CONTENT_TYPE.equals(headerName)) {, +			return CONTENT_TYPE_PROPERTY;, +		return super.fromHeaderName(headerName);, +	protected String toHeaderName(String propertyName) {, +		if (CONTENT_TYPE_PROPERTY.equals(propertyName)) {, +			return MessageHeaders.CONTENT_TYPE;, +		return super.toHeaderName(propertyName);, +++ b/spring-jms/src/main/java/org/springframework/jms/support/SimpleJmsHeaderMapper.java, +import javax.jms.Message;, +import org.springframework.messaging.support.AbstractHeaderMapper;, + * @author Stephane Nicoll, +public class SimpleJmsHeaderMapper extends AbstractHeaderMapper<Message> implements JmsHeaderMapper {, +			Destination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);, +			if (jmsReplyTo != null) {, +					jmsMessage.setJMSReplyTo(jmsReplyTo);, +			String jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);, +			if (jmsType != null) {, +					jmsMessage.setJMSType(jmsType);, +	protected String fromHeaderName(String headerName) {, +		if (MessageHeaders.CONTENT_TYPE.equals(headerName)) {, +			return CONTENT_TYPE_PROPERTY;, +		return super.fromHeaderName(headerName);, +	protected String toHeaderName(String propertyName) {, +		if (CONTENT_TYPE_PROPERTY.equals(propertyName)) {, +			return MessageHeaders.CONTENT_TYPE;, +		return super.toHeaderName(propertyName);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/AbstractHeaderMapper.java, +/*, + * Copyright 2002-2014 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.messaging.support;, +, +import java.util.Map;, +, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +, +import org.springframework.messaging.MessageHeaders;, +import org.springframework.util.StringUtils;, +, +/**, + * A base {@link HeaderMapper} implementation, + *, + * @author Stephane Nicoll, + * @since 4.1, + */, +public abstract class AbstractHeaderMapper<T> implements HeaderMapper<T> {, +, +	protected final Log logger = LogFactory.getLog(getClass());, +, +	private String inboundPrefix = "";, +, +	private String outboundPrefix = "";, +, +	/**, +	 * Specify a prefix to be appended to the message header name for any, +	 * user-defined property that is being mapped into the MessageHeaders. The, +	 * default is an empty string (no prefix)., +	 */, +	public void setInboundPrefix(String inboundPrefix) {, +		this.inboundPrefix = (inboundPrefix != null ? inboundPrefix : "");, +	}, +, +	/**, +	 * Specify a prefix to be appended to the protocol property name for any, +	 * user-defined message header that is being mapped into the protocol-specific, +	 * Message. The default is an empty string (no prefix)., +	 */, +	public void setOutboundPrefix(String outboundPrefix) {, +		this.outboundPrefix = (outboundPrefix != null ? outboundPrefix : "");, +	}, +, +	/**, +	 * Generate the name to use to set the header defined by the specified {@code headerName} to, +	 * the protocol specific message.]