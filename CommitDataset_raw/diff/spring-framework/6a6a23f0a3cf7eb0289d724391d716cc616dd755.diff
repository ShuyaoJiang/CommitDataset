[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2013 the original author or authors., +, +import org.springframework.util.ClassUtils;, +	public void setParameterNames(String... names) {, +	public void setParameterTypes(Class<?>... types) {, +		ClassLoader cl = (this.beanFactory instanceof ConfigurableBeanFactory ?, +				((ConfigurableBeanFactory) this.beanFactory).getBeanClassLoader() :, +				ClassUtils.getDefaultClassLoader());, +					this.pointcutParameterNames[i], this.pointcutParameterTypes[i]);, +		}, +		catch (ReflectionWorldException rwe) {, +			logger.debug("PointcutExpression matching rejected target class", rwe);, +				// Actually this is still a "maybe" - treat the pointcut as dynamic if we don't know enough yet, +			}, +			catch (BCException bce) {, +				logger.debug("Fallback PointcutExpression matching rejected target class", bce);, +			if (beanHasIntroductions) {, +				return true;, +			}, +			// A match test returned maybe - if there are any subtype sensitive variables, +			// involved in the test (this, target, at_this, at_target, at_annotation) then, +			// we say this is not a match as in Spring there will never be a different, +			// runtime subtype., +			RuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);, +			return (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));, +			if (joinPointMatch.matches()) {, +		}, +	private PointcutExpression getFallbackPointcutExpression(Class<?> targetClass) {, +		return (classLoader != null ? buildPointcutExpression(classLoader) : this.pointcutExpression);, +						}, +						catch (ReflectionWorld.ReflectionWorldException ex2) {, +								catch (ReflectionWorld.ReflectionWorldException ex3) {, +									}, +									catch (ReflectionWorld.ReflectionWorldException ex4) {, +, +, +			return this.primary.alwaysMatches();, +			return this.primary.maybeMatches();, +			return this.primary.neverMatches();, +		public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {, +				return this.primary.matchesJoinPoint(thisObject, targetObject, args);, +			}, +			catch (ReflectionWorldException ex) {, +				return this.other.matchesJoinPoint(thisObject, targetObject, args);, +			this.primary.setMatchingContext(aMatchContext);, +			this.other.setMatchingContext(aMatchContext);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2013 the original author or authors., +, +import org.springframework.util.ClassUtils;, +	public void setParameterNames(String... names) {, +	public void setParameterTypes(Class<?>... types) {, +		ClassLoader cl = (this.beanFactory instanceof ConfigurableBeanFactory ?, +				((ConfigurableBeanFactory) this.beanFactory).getBeanClassLoader() :, +				ClassUtils.getDefaultClassLoader());, +					this.pointcutParameterNames[i], this.pointcutParameterTypes[i]);, +		}, +		catch (ReflectionWorldException rwe) {, +			logger.debug("PointcutExpression matching rejected target class", rwe);, +				// Actually this is still a "maybe" - treat the pointcut as dynamic if we don't know enough yet, +			}, +			catch (BCException bce) {, +				logger.debug("Fallback PointcutExpression matching rejected target class", bce);, +			if (beanHasIntroductions) {, +				return true;, +			}, +			// A match test returned maybe - if there are any subtype sensitive variables, +			// involved in the test (this, target, at_this, at_target, at_annotation) then, +			// we say this is not a match as in Spring there will never be a different, +			// runtime subtype., +			RuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);, +			return (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));, +			if (joinPointMatch.matches()) {, +		}, +	private PointcutExpression getFallbackPointcutExpression(Class<?> targetClass) {, +		return (classLoader != null ? buildPointcutExpression(classLoader) : this.pointcutExpression);, +						}, +						catch (ReflectionWorld.ReflectionWorldException ex2) {, +								catch (ReflectionWorld.ReflectionWorldException ex3) {, +									}, +									catch (ReflectionWorld.ReflectionWorldException ex4) {, +, +, +			return this.primary.alwaysMatches();, +			return this.primary.maybeMatches();, +			return this.primary.neverMatches();, +		public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {, +				return this.primary.matchesJoinPoint(thisObject, targetObject, args);, +			}, +			catch (ReflectionWorldException ex) {, +				return this.other.matchesJoinPoint(thisObject, targetObject, args);, +			this.primary.setMatchingContext(aMatchContext);, +			this.other.setMatchingContext(aMatchContext);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker.java, + * Copyright 2002-2013 the original author or authors., +import org.aspectj.weaver.ReferenceType;, +import org.aspectj.weaver.ReferenceTypeDelegate;, +import org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegate;, +	private static final Field residualTestField;]