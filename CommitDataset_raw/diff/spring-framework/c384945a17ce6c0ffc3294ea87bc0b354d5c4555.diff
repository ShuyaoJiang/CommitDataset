[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/user/DefaultUserDestinationResolver.java, + * Copyright 2002-2015 the original author or authors., + * A default implementation of {@code UserDestinationResolver} that relies, + * on a {@link org.springframework.messaging.simp.user.UserSessionRegistry} to, + * find active sessions for a user., + * <p>When a user attempts to subscribe, e.g. to "/user/queue/position-updates",, + * the "/user" prefix is removed and a unique suffix added based on the session, + * id, e.g. "/queue/position-updates-useri9oqdfzo" to ensure different users can, + * subscribe to the same logical destination without colliding., + * <p>When sending to a user, e.g. "/user/{username}/queue/position-updates", the, + * "/user/{username}" prefix is removed and a suffix based on active session id's, + * is added, e.g. "/queue/position-updates-useri9oqdfzo"., +	private final UserSessionRegistry sessionRegistry;, +	private String prefix = "/user/";, +	 * @param sessionRegistry the registry, never {@code null}, +	public DefaultUserDestinationResolver(UserSessionRegistry sessionRegistry) {, +		Assert.notNull(sessionRegistry, "'sessionRegistry' must not be null");, +		this.sessionRegistry = sessionRegistry;, +		return this.sessionRegistry;, +	/**, +	 * The prefix used to identify user destinations. Any destinations that do not, +	 * start with the given prefix are not be resolved., +	 * <p>The default prefix is "/user/"., +	 * @param prefix the prefix to use, +	 */, +	public void setUserDestinationPrefix(String prefix) {, +		Assert.hasText(prefix, "prefix must not be empty");, +		this.prefix = prefix.endsWith("/") ? prefix : prefix + "/";, +	}, +, +	/**, +	 * Return the configured prefix for user destinations., +	 */, +	public String getDestinationPrefix() {, +		return this.prefix;, +	}, +, +, +		String sourceDestination = SimpMessageHeaderAccessor.getDestination(message.getHeaders());, +		ParseResult parseResult = parse(message);, +		if (parseResult == null) {, +		String user = parseResult.getUser();, +		Set<String> targetSet = new HashSet<String>();, +		for (String sessionId : parseResult.getSessionIds()) {, +			String actualDestination = parseResult.getActualDestination();, +			String targetDestination = getTargetDestination(sourceDestination, actualDestination, sessionId, user);, +				targetSet.add(targetDestination);, +		String subscribeDestination = parseResult.getSubscribeDestination();, +		return new UserDestinationResult(sourceDestination, targetSet, subscribeDestination, user);, +	private ParseResult parse(Message<?> message) {, +		if (destination == null || !checkDestination(destination, this.prefix)) {, +			return null;, +		}, +		SimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);, +			int prefixEnd = this.prefix.length() - 1;, +			String actualDestination = destination.substring(prefixEnd);, +			String user = (principal != null ? principal.getName() : null);, +			return new ParseResult(actualDestination, destination, Collections.singleton(sessionId), user);, +			int prefixEnd = this.prefix.length();, +			int userEnd = destination.indexOf('/', prefixEnd);, +			Assert.isTrue(userEnd > 0, "Expected destination pattern \"/user/{userId}/**\"");, +			String actualDestination = destination.substring(userEnd);, +			String subscribeDestination = this.prefix.substring(0, prefixEnd - 1) + actualDestination;, +			String user = destination.substring(prefixEnd, userEnd);, +			Set<String> sessionIds;, +			else if (this.sessionRegistry.getSessionIds(user).contains(sessionId)) {, +				sessionIds = this.sessionRegistry.getSessionIds(user);, +			return new ParseResult(actualDestination, subscribeDestination, sessionIds, user);, +	 * This method determines how to translate the source "user" destination to an, +	 * actual target destination for the given active user session., +	 * @param sourceDestination the source destination from the input message., +	 * @param actualDestination a subset of the destination without any user prefix., +	 * @param sessionId the id of an active user session, never {@code null}., +	 * @param user the target user, possibly {@code null}, e.g if not authenticated., +	protected String getTargetDestination(String sourceDestination, String actualDestination,, +			String sessionId, String user) {, +		return actualDestination + "-user" + sessionId;, +		return "DefaultUserDestinationResolver[prefix=" + this.prefix + "]";, +	/**, +	 * A temporary placeholder for a parsed source "user" destination., +	 */, +	private static class ParseResult {, +		private final String actualDestination;, +		private final String user;, +, +		public ParseResult(String actualDest, String subscribeDest, Set<String> sessionIds, String user) {, +			this.actualDestination = actualDest;, +			this.subscribeDestination = subscribeDest;, +			this.user = user;, +, +		public String getActualDestination() {, +			return this.actualDestination;, +		public String getUser() {, +			return this.user;, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/user/DefaultUserDestinationResolver.java, + * Copyright 2002-2015 the original author or authors., + * A default implementation of {@code UserDestinationResolver} that relies, + * on a {@link org.springframework.messaging.simp.user.UserSessionRegistry} to, + * find active sessions for a user., + * <p>When a user attempts to subscribe, e.g. to "/user/queue/position-updates",]