[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistration.java, +import java.util.HashMap;, +import java.util.Map;, +import org.springframework.cache.Cache;, +import org.springframework.cache.concurrent.ConcurrentMapCache;, +import org.springframework.util.ClassUtils;, +import org.springframework.web.servlet.resource.CachingResourceResolver;, +import org.springframework.web.servlet.resource.CachingResourceTransformer;, +import org.springframework.web.servlet.resource.ContentVersionStrategy;, +import org.springframework.web.servlet.resource.CssLinkResourceTransformer;, +import org.springframework.web.servlet.resource.FixedVersionStrategy;, +import org.springframework.web.servlet.resource.VersionResourceResolver;, +import org.springframework.web.servlet.resource.VersionStrategy;, + * @author Brian Clozel, +	private static final String RESOURCE_CACHE_NAME = "spring-resourcehandler-cache";, +, +	private List<ResourceResolver> customResolvers = new ArrayList<ResourceResolver>();, +	private List<ResourceTransformer> customTransformers = new ArrayList<ResourceTransformer>();, +	private Map<String, VersionStrategy> versionStrategies = new HashMap<String, VersionStrategy>();, +, +	private boolean isDevMode = false;, +, +	private Cache resourceCache;, +	 * Add a {@code ResourceResolver} to the chain, allowing to resolve server-side resources from, +	 * HTTP requests., +	 *, +	 * <p>{@link ResourceResolver}s are registered, in the following order:, +	 * <ol>, +	 *     <li>a {@link org.springframework.web.servlet.resource.CachingResourceResolver}, +	 *     for caching the results of the next Resolvers; this resolver is only registered if you, +	 *     did not provide your own instance of {@link CachingResourceResolver} at the beginning of the chain</li>, +	 *     <li>all {@code ResourceResolver}s registered using this method, in the order of methods calls</li>, +	 *     <li>a {@link VersionResourceResolver} if a versioning configuration has been applied with, +	 *     {@code addVersionStrategy}, {@code addVersion}, etc.</li>, +	 *     <li>a {@link PathResourceResolver} for resolving resources on the file system</li>, +	 * </ol>, +	 *, +	 * @param resolver a {@link ResourceResolver} to add to the chain of resolvers, +	 * @return the same {@link ResourceHandlerRegistration} instance for chained method invocation, +	 * @see ResourceResolver, +	public ResourceHandlerRegistration addResolver(ResourceResolver resolver) {, +		Assert.notNull(resolver, "The provided ResourceResolver should not be null");, +		this.customResolvers.add(resolver);, +	 * Add a {@code ResourceTransformer} to the chain, allowing to transform the content, +	 * of server-side resources when serving them to HTTP clients., +	 *, +	 * <p>{@link ResourceTransformer}s are registered, in the following order:, +	 * <ol>, +	 *     <li>a {@link org.springframework.web.servlet.resource.CachingResourceTransformer}, +	 *     for caching the results of the next Transformers; this transformer is only registered if you, +	 *     did not provide your own instance of {@link CachingResourceTransformer} at the beginning of the chain</li>, +	 *     <li>a {@link CssLinkResourceTransformer} for updating links within CSS files; this transformer, +	 *     is only registered if a versioning configuration has been applied with {@code addVersionStrategy},, +	 *     {@code addVersion}, etc</li>, +	 *     <li>all {@code ResourceTransformer}s registered using this method, in the order of methods calls</li>, +	 * </ol>, +	 *, +	 * @param transformer a {@link ResourceTransformer} to add to the chain of transformers, +	 * @return the same {@link ResourceHandlerRegistration} instance for chained method invocation, +	 * @see ResourceResolver, +	public ResourceHandlerRegistration addTransformer(ResourceTransformer transformer) {, +		Assert.notNull(transformer, "The provided ResourceTransformer should not be null");, +		this.customTransformers.add(transformer);, +		return this;, +	}, +, +	/**, +	 * Apply Resource Versioning on the matching resources; this will update resources' URLs to include, +	 * a version string calculated by a {@link VersionStrategy}. This is often used for cache busting., +	 * <p>Note that a {@link CssLinkResourceTransformer} will be automatically registered to, +	 * support versioned resources in CSS files.</p>, +	 * @param strategy the versioning strategy to use, +	 * @param pathPatterns one or more resource URL path patterns, +	 * @return the same {@link ResourceHandlerRegistration} instance for chained method invocation, +	 * @see VersionResourceResolver, +	 * @see VersionStrategy, +	 * @since 4.1, +	 */, +	public ResourceHandlerRegistration addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {, +		for(String pattern : pathPatterns) {, +			this.versionStrategies.put(pattern, strategy);, +		}, +		return this;, +	}, +, +	/**, +	 * Apply Resource Versioning on the matching resources using a {@link FixedVersionStrategy}., +	 * <p>This strategy uses that fixed version string and adds it as a prefix in the resource path,, +	 * e.g. {@code fixedversion/js/main.js}.</p>, +	 * <p>There are many ways to get a version string for your application:</p>, +	 * <ul>, +	 *     <li>create a string using the current date, a source of random numbers at runtime</li>, +	 *     <li>fetch a version string from a property source or an Env variable, using SpEL or @Value</li>, +	 * </ul>, +	 * <p>Note that a {@link CssLinkResourceTransformer} will be automatically registered to, +	 * support versioned resources in CSS files.</p>, +	 * @param fixedVersion a version string, +	 * @param pathPatterns one or more resource URL path patterns, +	 * @return the same {@link ResourceHandlerRegistration} instance for chained method invocation, +	 * @see VersionResourceResolver]