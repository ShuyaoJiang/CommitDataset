[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolver.java, + * <li>Of type {@link MultipartFile} in conjunction with Spring's {@link MultipartResolver} abstraction, + * <li>Of type {@code javax.servlet.http.Part} in conjunction with Servlet 3.0 multipart requests, + * <p>When a parameter is annotated with {@code @RequestPart}, the content of the part is, + * passed through an {@link HttpMessageConverter} to resolve the method argument with the, + * 'Content-Type' of the request part in mind. This is analogous to what @{@link RequestBody}, + * does to resolve an argument based on the content of a regular request., +			List<MultipartFile> files = multipartRequest.getFiles(partName);, +			arg = files.toArray(new MultipartFile[files.size()]);, +		String partName = (annot != null ? annot.value() : "");, +			Assert.notNull(partName, "Request part name for argument type [" + parameter.getParameterType().getName() +, +					"] not specified, and parameter name information not found in class file either.");, +		return (collectionType != null && collectionType.equals(MultipartFile.class));, +		return (paramType != null && MultipartFile.class.equals(paramType));, +	}, +, +	private boolean isPartCollection(MethodParameter parameter) {, +		Class<?> collectionType = getCollectionParameterType(parameter);, +		return (collectionType != null && "javax.servlet.http.Part".equals(collectionType.getName()));, +	}, +, +	private boolean isPartArray(MethodParameter parameter) {, +		Class<?> paramType = parameter.getParameterType().getComponentType();, +		return (paramType != null && "javax.servlet.http.Part".equals(paramType.getName()));, +					if (isBindingErrorFatal(parameter)) {, +	 * @return {@code true} if the next method argument is not of type {@link Errors}, +	private boolean isBindingErrorFatal(MethodParameter parameter) {, +, +	/**, +	 * Inner class to avoid hard-coded dependency on Servlet 3.0 Part type..., +	 */, +			Collection<Part> parts = servletRequest.getParts();, +			return parts.toArray(new Part[parts.size()]);, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolver.java, + * <li>Of type {@link MultipartFile} in conjunction with Spring's {@link MultipartResolver} abstraction, + * <li>Of type {@code javax.servlet.http.Part} in conjunction with Servlet 3.0 multipart requests, + * <p>When a parameter is annotated with {@code @RequestPart}, the content of the part is, + * passed through an {@link HttpMessageConverter} to resolve the method argument with the, + * 'Content-Type' of the request part in mind. This is analogous to what @{@link RequestBody}, + * does to resolve an argument based on the content of a regular request., +			List<MultipartFile> files = multipartRequest.getFiles(partName);, +			arg = files.toArray(new MultipartFile[files.size()]);, +		String partName = (annot != null ? annot.value() : "");, +			Assert.notNull(partName, "Request part name for argument type [" + parameter.getParameterType().getName() +, +					"] not specified, and parameter name information not found in class file either.");, +		return (collectionType != null && collectionType.equals(MultipartFile.class));, +		return (paramType != null && MultipartFile.class.equals(paramType));, +	}, +, +	private boolean isPartCollection(MethodParameter parameter) {, +		Class<?> collectionType = getCollectionParameterType(parameter);, +		return (collectionType != null && "javax.servlet.http.Part".equals(collectionType.getName()));, +	}, +, +	private boolean isPartArray(MethodParameter parameter) {, +		Class<?> paramType = parameter.getParameterType().getComponentType();, +		return (paramType != null && "javax.servlet.http.Part".equals(paramType.getName()));, +					if (isBindingErrorFatal(parameter)) {, +	 * @return {@code true} if the next method argument is not of type {@link Errors}, +	private boolean isBindingErrorFatal(MethodParameter parameter) {, +, +	/**, +	 * Inner class to avoid hard-coded dependency on Servlet 3.0 Part type..., +	 */, +			Collection<Part> parts = servletRequest.getParts();, +			return parts.toArray(new Part[parts.size()]);, +++ b/src/asciidoc/index.adoc, +	@Cacheable(value="books", **key="#isbn")**, +The snippets above, show how easy it is to select a certain argument, one of its, +cache or what arguments are used. A quick example - the following method will be cached,, +only if the argument `name` has a length shorter then 32:, +Just like its sibling, `@CacheEvict` requires one to specify one (or multiple) caches, +cache) - this is not the case with `@Cacheable` which adds/update data into the cache, +such declarations however there is a workaround - using a __enclosing__ annotation, in, +automatically triggers their actions - like many things in Spring, the feature has to be, +configuration, at runtime an exception will be through since the caching infrastructure]