[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, + * <h3>Terminology</h3>, + * The terms <em>directly present</em> and <em>present</em> have the same, + * meanings as defined in the class-level Javadoc for {@link AnnotatedElement}., + *, + * <p>An annotation is <em>meta-present</em> on an element if the annotation, + * is declared as a meta-annotation on some other annotation which is, + * <em>present</em> on the element., + *, + * <p>Most {@code find*()} methods and some {@code get*()} methods in this, + * class provide support for finding annotations used as meta-annotations., + * Consult the Javadoc for each method in this class for details. For support, + * for meta-annotations with <em>attribute overrides</em> in, + * <em>composed annotations</em>, use {@link AnnotatedElementUtils} instead., +	 * {@link AnnotatedElement}, where the annotation is either <em>present</em> or, +	 * <em>meta-present</em> on the {@code AnnotatedElement}., +	 * supplied {@link Method}, where the annotation is either <em>present</em>, +	 * or <em>meta-present</em> on the method., +	 * Get the <em>repeatable</em> {@link Annotation}s of {@code annotationType}, +	 * from the supplied {@link Method}, where such annotations are either, +	 * <em>present</em> or <em>meta-present</em> on the method., +	 * <p>Handles both single annotations and annotations nested within a, +	 * <em>containing annotation</em>., +	 * <em>present</em> on the supplied method., +	 * @param method the method to look for annotations on; never {@code null}, +	 * @param containerAnnotationType the type of the container that holds the, +	 * annotations; may be {@code null} if a container is not supported, +	 * Get the <em>repeatable</em> {@link Annotation}s of {@code annotationType}, +	 * from the supplied {@link AnnotatedElement}, where such annotations are, +	 * either <em>present</em> or <em>meta-present</em> on the element., +	 * <p>Handles both single annotations and annotations nested within a, +	 * <em>containing annotation</em>., +	 * <em>present</em> on the supplied element., +	 * @param annotatedElement the element to look for annotations on; never {@code null}, +	 * @param containerAnnotationType the type of the container that holds the, +	 * annotations; may be {@code null} if a container is not supported, +	 * interfaces) if the annotation is not <em>directly present</em> on the given, +	 * method itself., +	 * superclasses if the annotation is not <em>directly present</em> on, +	 * the given class itself., +	 * Find the first {@link Class} in the inheritance hierarchy of the, +	 * specified {@code clazz} (including the specified {@code clazz} itself), +	 * on which an annotation of the specified {@code annotationType} is, +	 * <em>directly present</em>., +	 * <p>If the supplied {@code clazz} is an interface, only the interface, +	 * itself will be checked; the inheritance hierarchy for interfaces will, +	 * not be traversed., +	 * <p>The standard {@link Class} API does not provide a mechanism for, +	 * determining which class in an inheritance hierarchy actually declares, +	 * an {@link Annotation}, so we need to handle this explicitly., +	 * @param annotationType the annotation type to look for, +	 * @param clazz the class to check for the annotation on (may be {@code null}), +	 * @return the first {@link Class} in the inheritance hierarchy that, +	 * declares an annotation of the specified {@code annotationType}, or, +	 * {@code null} if not found, +	 * Find the first {@link Class} in the inheritance hierarchy of the, +	 * specified {@code clazz} (including the specified {@code clazz} itself), +	 * on which at least one of the specified {@code annotationTypes} is, +	 * <em>directly present</em>., +	 * <p>If the supplied {@code clazz} is an interface, only the interface, +	 * itself will be checked; the inheritance hierarchy for interfaces will, +	 * not be traversed., +	 * <p>The standard {@link Class} API does not provide a mechanism for, +	 * determining which class in an inheritance hierarchy actually declares, +	 * one of several candidate {@linkplain Annotation annotations}, so we, +	 * need to handle this explicitly., +	 * @param annotationTypes the annotation types to look for, +	 * @param clazz the class to check for the annotations on, or {@code null}, +	 * @return the first {@link Class} in the inheritance hierarchy that, +	 * declares an annotation of at least one of the specified, +	 * Determine whether an annotation of the specified {@code annotationType}, +	 * is declared locally (i.e., <em>directly present</em>) on the supplied, +	 * {@code clazz}., +	 * <p>The supplied {@link Class} may represent any type., +	 * <p>Note: This method does <strong>not</strong> determine if the annotation, +	 * is {@linkplain java.lang.annotation.Inherited inherited}. For greater, +	 * clarity regarding inherited annotations, consider using, +	 * @param annotationType the annotation type to look for, +	 * @param clazz the class to check for the annotation on, +	 * is <em>directly present</em>, +					return true;, +		return false;, +	 * Determine whether an annotation of the specified {@code annotationType}, +	 * is <em>present</em> on the supplied {@code clazz} and is, +	 * {@linkplain java.lang.annotation.Inherited inherited} (i.e., not, +	 * <em>directly present</em>)., +	 * <p>If the supplied {@code clazz} is an interface, only the interface, +	 * itself will be checked. In accordance with standard meta-annotation, +	 * semantics in Java, the inheritance hierarchy for interfaces will not, +	 * be traversed. See the {@linkplain java.lang.annotation.Inherited Javadoc}, +	 * for the {@code @Inherited} meta-annotation for further details regarding, +	 * annotation inheritance., +	 * @param annotationType the annotation type to look for, +	 * @param clazz the class to check for the annotation on, +	 * @return {@code true} if an annotation of the specified {@code annotationType}, +	 * is <em>present</em> and <em>inherited</em>]