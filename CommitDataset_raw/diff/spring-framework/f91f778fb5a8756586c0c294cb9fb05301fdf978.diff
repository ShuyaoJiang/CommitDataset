[+++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/CacheEvict.java, +	/**, +	 * Whether the eviction should occur after the method is successfully invoked (default), +	 * or before. The latter causes the eviction to occur irrespective of the method outcome (whether, +	 * it threw an exception or not) while the former does not., +	 */, +	boolean afterInvocation() default true;, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/CacheEvict.java, +	/**, +	 * Whether the eviction should occur after the method is successfully invoked (default), +	 * or before. The latter causes the eviction to occur irrespective of the method outcome (whether, +	 * it threw an exception or not) while the former does not., +	 */, +	boolean afterInvocation() default true;, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +		ceo.setAfterInvocation(caching.afterInvocation());, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/CacheEvict.java, +	/**, +	 * Whether the eviction should occur after the method is successfully invoked (default), +	 * or before. The latter causes the eviction to occur irrespective of the method outcome (whether, +	 * it threw an exception or not) while the former does not., +	 */, +	boolean afterInvocation() default true;, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +		ceo.setAfterInvocation(caching.afterInvocation());, +++ b/org.springframework.context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java, +		<T extends CacheOperation> T merge(Element element, ReaderContext readerCtx, T op) {, +			CacheEvictOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CacheEvictOperation());, +, +			String wide = opElement.getAttribute("all-entries");, +			if (StringUtils.hasText(wide)) {, +				op.setCacheWide(Boolean.valueOf(wide.trim()));, +			}, +, +			String after = opElement.getAttribute("after-invocation");, +			if (StringUtils.hasText(after)) {, +				op.setAfterInvocation(Boolean.valueOf(after.trim()));, +			}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/CacheEvict.java, +	/**, +	 * Whether the eviction should occur after the method is successfully invoked (default), +	 * or before. The latter causes the eviction to occur irrespective of the method outcome (whether, +	 * it threw an exception or not) while the former does not., +	 */, +	boolean afterInvocation() default true;, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +		ceo.setAfterInvocation(caching.afterInvocation());, +++ b/org.springframework.context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java, +		<T extends CacheOperation> T merge(Element element, ReaderContext readerCtx, T op) {, +			CacheEvictOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CacheEvictOperation());, +, +			String wide = opElement.getAttribute("all-entries");, +			if (StringUtils.hasText(wide)) {, +				op.setCacheWide(Boolean.valueOf(wide.trim()));, +			}, +, +			String after = opElement.getAttribute("after-invocation");, +			if (StringUtils.hasText(after)) {, +				op.setAfterInvocation(Boolean.valueOf(after.trim()));, +			}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +			Map<String, Collection<CacheOperationContext>> ops = createOperationContext(cacheOp, method, args, target, targetClass);, +			inspectBeforeCacheEvicts(ops.get(EVICT));, +			inspectAfterCacheEvicts(ops.get(EVICT));, +, +	private void inspectBeforeCacheEvicts(Collection<CacheOperationContext> evictions) {, +		inspectAfterCacheEvicts(evictions, false);, +	}, +, +	private void inspectAfterCacheEvicts(Collection<CacheOperationContext> evictions) {, +		inspectAfterCacheEvicts(evictions, true);, +	}, +, +	private void inspectAfterCacheEvicts(Collection<CacheOperationContext> evictions, boolean afterInvocation) {, +				if (afterInvocation == evictOp.isAfterInvocation()) {, +					if (context.isConditionPassing()) {, +					} else {, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/CacheEvict.java, +	/**, +	 * Whether the eviction should occur after the method is successfully invoked (default), +	 * or before. The latter causes the eviction to occur irrespective of the method outcome (whether, +	 * it threw an exception or not) while the former does not., +	 */, +	boolean afterInvocation() default true;, +++ b/org.springframework.context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java, +		ceo.setAfterInvocation(caching.afterInvocation());, +++ b/org.springframework.context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java, +		<T extends CacheOperation> T merge(Element element, ReaderContext readerCtx, T op) {, +			CacheEvictOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CacheEvictOperation());, +, +			String wide = opElement.getAttribute("all-entries");, +			if (StringUtils.hasText(wide)) {, +				op.setCacheWide(Boolean.valueOf(wide.trim()));, +			}, +, +			String after = opElement.getAttribute("after-invocation");, +			if (StringUtils.hasText(after)) {, +				op.setAfterInvocation(Boolean.valueOf(after.trim()));, +			}]