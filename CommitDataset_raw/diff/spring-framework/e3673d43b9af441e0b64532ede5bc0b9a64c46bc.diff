[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpRequest.java, +	private final URI uri;, +, +	private final HttpHeaders headers;, +	/**, +	 * Constructor with the URI and headers for the request., +	 * @param uri the URI for the request, +	 * @param headers the headers for the request, +	 */, +	public AbstractServerHttpRequest(URI uri, HttpHeaders headers) {, +		this.uri = uri;, +		this.headers = HttpHeaders.readOnlyHttpHeaders(headers);, +	}, +, +, +	public HttpHeaders getHeaders() {, +		return this.headers;, +	}, +, +	@Override, +	/**, +	 * A method for parsing of the query into name-value pairs. The return, +	 * value is turned into an immutable map and cached., +	 *, +	 * <p>Note that this method is invoked lazily on first access to, +	 * {@link #getQueryParams()}. The invocation is not synchronized but the, +	 * parsing is thread-safe nevertheless., +	 */, +	 * Obtain the cookies from the underlying "native" request and adapt those to, +	 * an {@link HttpCookie} map. The return value is turned into an immutable, +	 * map and cached., +	 * <p>Note that this method is invoked lazily on access to, +	 * {@link #getCookies()}. Sub-classes should synchronize cookie, +	 * initialization if the underlying "native" request does not provide, +	 * thread-safe access to cookie data., +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpRequest.java, +	private final URI uri;, +, +	private final HttpHeaders headers;, +	/**, +	 * Constructor with the URI and headers for the request., +	 * @param uri the URI for the request, +	 * @param headers the headers for the request, +	 */, +	public AbstractServerHttpRequest(URI uri, HttpHeaders headers) {, +		this.uri = uri;, +		this.headers = HttpHeaders.readOnlyHttpHeaders(headers);, +	}, +, +, +	public HttpHeaders getHeaders() {, +		return this.headers;, +	}, +, +	@Override, +	/**, +	 * A method for parsing of the query into name-value pairs. The return, +	 * value is turned into an immutable map and cached., +	 *, +	 * <p>Note that this method is invoked lazily on first access to, +	 * {@link #getQueryParams()}. The invocation is not synchronized but the, +	 * parsing is thread-safe nevertheless., +	 */, +	 * Obtain the cookies from the underlying "native" request and adapt those to, +	 * an {@link HttpCookie} map. The return value is turned into an immutable, +	 * map and cached., +	 * <p>Note that this method is invoked lazily on access to, +	 * {@link #getCookies()}. Sub-classes should synchronize cookie, +	 * initialization if the underlying "native" request does not provide, +	 * thread-safe access to cookie data., +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorServerHttpRequest.java, + * @author Rossen Stoyanchev, +	public ReactorServerHttpRequest(HttpChannel channel, NettyDataBufferFactory bufferFactory) {, +		super(initUri(channel), initHeaders(channel));, +		this.channel = channel;, +	private static URI initUri(HttpChannel channel) {, +		Assert.notNull("'channel' must not be null");, +		try {, +			URI uri = new URI(channel.uri());, +			InetSocketAddress remoteAddress = channel.remoteAddress();, +			return new URI(, +					uri.getScheme(),, +					uri.getUserInfo(),, +					(remoteAddress != null ? remoteAddress.getHostString() : null),, +					(remoteAddress != null ? remoteAddress.getPort() : -1),, +					uri.getPath(),, +					uri.getQuery(),, +					uri.getFragment());, +		}, +		catch (URISyntaxException ex) {, +			throw new IllegalStateException("Could not get URI: " + ex.getMessage(), ex);, +		}, +	}, +, +	private static HttpHeaders initHeaders(HttpChannel channel) {, +		HttpHeaders headers = new HttpHeaders();, +		for (String name : channel.headers().names()) {, +			headers.put(name, channel.headers().getAll(name));, +		}, +		return headers;]