[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, +import static org.springframework.messaging.support.MessageHeaderAccessor.getAccessor;, +, +import java.util.concurrent.CopyOnWriteArraySet;, +import org.springframework.expression.AccessException;, +import org.springframework.expression.EvaluationContext;, +import org.springframework.expression.Expression;, +import org.springframework.expression.ExpressionParser;, +import org.springframework.expression.PropertyAccessor;, +import org.springframework.expression.TypedValue;, +import org.springframework.expression.spel.SpelEvaluationException;, +import org.springframework.expression.spel.standard.SpelExpressionParser;, +import org.springframework.expression.spel.support.StandardEvaluationContext;, +import org.springframework.messaging.MessageHeaders;, +import org.springframework.messaging.simp.SimpMessageHeaderAccessor;, + * Implementation of {@link SubscriptionRegistry} that stores subscriptions, + * in memory and uses a {@link org.springframework.util.PathMatcher PathMatcher}, + * for matching destinations., + *, + * <p>As of 4.2 this class supports a {@link #setSelectorHeaderName selector}, + * header on subscription messages with Spring EL expressions evaluated against, + * the headers to filter out messages in addition to destination matching., +	private String selectorHeaderName = "selector";, +, +	private ExpressionParser expressionParser = new SpelExpressionParser();, +, +	/**, +	 * Configure the name of a selector header that a subscription message can, +	 * have in order to filter messages based on their headers. The value of the, +	 * header can use Spring EL expressions against message headers., +	 * <p>For example the following expression expects a header called "foo" to, +	 * have the value "bar":, +	 * <pre>, +	 * headers.foo == 'bar', +	 * </pre>, +	 * <p>By default this is set to "selector"., +	 * @since 4.2, +	 */, +	public void setSelectorHeaderName(String selectorHeaderName) {, +		Assert.notNull(selectorHeaderName);, +		this.selectorHeaderName = selectorHeaderName;, +	}, +, +	/**, +	 * Return the name for the selector header., +	 */, +	public String getSelectorHeaderName() {, +		return this.selectorHeaderName;, +	}, +, +	protected void addSubscriptionInternal(String sessionId, String subsId, String destination,, +			Message<?> message) {, +, +		Expression expression = null;, +		MessageHeaders headers = message.getHeaders();, +		String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers);, +		if (selector != null) {, +			try {, +				expression = this.expressionParser.parseExpression(selector);, +				if (logger.isTraceEnabled()) {, +					logger.trace("Subscription selector: [" + selector + "]");, +				}, +			}, +			catch (Throwable ex) {, +				if (logger.isDebugEnabled()) {, +					logger.debug("Failed to parse selector: " + selector, ex);, +				}, +			}, +		}, +		this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);, +	protected MultiValueMap<String, String> findSubscriptionsInternal(String destination,, +			Message<?> message) {, +, +			return filterSubscriptions(result, message);, +					for (Subscription subscription : info.getSubscriptions(destinationPattern)) {, +						result.add(info.sessionId, subscription.getId());, +		return filterSubscriptions(result, message);, +	}, +, +	private MultiValueMap<String, String> filterSubscriptions(MultiValueMap<String, String> allMatches,, +			Message<?> message) {, +, +		EvaluationContext context = null;, +		MultiValueMap<String, String> result = new LinkedMultiValueMap<String, String>(allMatches.size());, +		for (String sessionId : allMatches.keySet()) {, +			for (String subId : allMatches.get(sessionId)) {, +				SessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);, +				Subscription sub = info.getSubscription(subId);, +				Expression expression = sub.getSelectorExpression();, +				if (expression == null) {, +					result.add(sessionId, subId);, +					continue;, +				}, +				if (context == null) {, +					context = new StandardEvaluationContext(message);, +					context.getPropertyAccessors().add(new SimpMessageHeaderPropertyAccessor());, +				}, +				try {, +					if (expression.getValue(context, boolean.class)) {, +						result.add(sessionId, subId);]