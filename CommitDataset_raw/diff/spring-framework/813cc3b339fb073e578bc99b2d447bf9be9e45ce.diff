[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +		else if (this.indexedType == IndexedType.list) {, +			return this.children[0].isCompilable();, +		} , +		else if (this.indexedType == IndexedType.map) {, +			if (this.children[0] instanceof PropertyOrFieldReference) {, +				// Only the name will be used, so that is OK, +			else {, +				return this.children[0].isCompilable();, +			}, +		}, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +			codeflow.enterCompilationScope();, +			codeflow.exitCompilationScope();, +			// Special case when the key is an unquoted string literal that will be parsed as, +			// a property/field reference, +			if ((this.children[0] instanceof PropertyOrFieldReference)) {, +				PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];, +				String mapKeyName = reference.getName();, +				mv.visitLdcInsn(mapKeyName);, +			}, +			else {, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +			}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +		else if (this.indexedType == IndexedType.list) {, +			return this.children[0].isCompilable();, +		} , +		else if (this.indexedType == IndexedType.map) {, +			if (this.children[0] instanceof PropertyOrFieldReference) {, +				// Only the name will be used, so that is OK, +			else {, +				return this.children[0].isCompilable();, +			}, +		}, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +			codeflow.enterCompilationScope();, +			codeflow.exitCompilationScope();, +			// Special case when the key is an unquoted string literal that will be parsed as, +			// a property/field reference, +			if ((this.children[0] instanceof PropertyOrFieldReference)) {, +				PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];, +				String mapKeyName = reference.getName();, +				mv.visitLdcInsn(mapKeyName);, +			}, +			else {, +				codeflow.enterCompilationScope();, +				codeflow.exitCompilationScope();, +			}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java, +import org.springframework.expression.spel.standard.SpelExpressionParser;, +	@Test, +	public void indexerMapAccessor_12045() throws Exception {, +		SpelParserConfiguration spc = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,this.getClass().getClassLoader());, +		SpelExpressionParser sep = new SpelExpressionParser(spc);, +		expression=sep.parseExpression("headers[command]");, +		MyMessage root = new MyMessage();, +		assertEquals("wibble",expression.getValue(root));, +		// This next call was failing because the isCompilable check in Indexer did not check on the key being compilable, +		// (and also generateCode in the Indexer was missing the optimization that it didn't need necessarily need to call, +		// generateCode for that accessor), +		assertEquals("wibble",expression.getValue(root));, +		assertCanCompile(expression);, +, +		// What about a map key that is an expression - ensure the getKey() is evaluated in the right scope, +		expression=sep.parseExpression("headers[getKey()]");, +		assertEquals("wobble",expression.getValue(root));, +		assertEquals("wobble",expression.getValue(root));, +		, +		expression=sep.parseExpression("list[getKey2()]");, +		assertEquals("wobble",expression.getValue(root));]