[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, + * Copyright 2002-2014 the original author or authors., +	 * Return a {@link ResolvableType} for the specified {@link Field} with a given, +	 * implementation., +	 * <p>Use this variant when the class that declares the field includes generic, +	 * parameter variables that are satisfied by the implementation type., +	 * @param field the source field, +	 * @param implementationType the implementation type, +	 * @return a {@link ResolvableType} for the specified field, +	 * @see #forField(Field), +	 */, +	public static ResolvableType forField(Field field, ResolvableType implementationType) {, +		Assert.notNull(field, "Field must not be null");, +		implementationType = (implementationType == null ? NONE : implementationType);, +		ResolvableType owner = implementationType.as(field.getDeclaringClass());, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());, +	}, +, +	/**, +		return forMethodParameter(methodParameter, (Type) null);, +	}, +, +	/**, +	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a, +	 * given implementation type. Use this variant when the class that declares the method, +	 * includes generic parameter variables that are satisfied by the implementation type., +	 * @param methodParameter the source method parameter (must not be {@code null}), +	 * @param implementationType the implementation type, +	 * @return a {@link ResolvableType} for the specified method parameter, +	 * @see #forMethodParameter(MethodParameter), +	 */, +	public static ResolvableType forMethodParameter(MethodParameter methodParameter, ResolvableType implementationType) {, +		Assert.notNull(methodParameter, "MethodParameter must not be null");, +		implementationType = (implementationType == null ? forType(methodParameter.getContainingClass()) : implementationType);, +		ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());, +		return forType(null, new MethodParameterTypeProvider(methodParameter),, +				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),, +				methodParameter.typeIndexesPerLevel);, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, + * Copyright 2002-2014 the original author or authors., +	 * Return a {@link ResolvableType} for the specified {@link Field} with a given, +	 * implementation., +	 * <p>Use this variant when the class that declares the field includes generic, +	 * parameter variables that are satisfied by the implementation type., +	 * @param field the source field, +	 * @param implementationType the implementation type, +	 * @return a {@link ResolvableType} for the specified field, +	 * @see #forField(Field), +	 */, +	public static ResolvableType forField(Field field, ResolvableType implementationType) {, +		Assert.notNull(field, "Field must not be null");, +		implementationType = (implementationType == null ? NONE : implementationType);, +		ResolvableType owner = implementationType.as(field.getDeclaringClass());, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());, +	}, +, +	/**, +		return forMethodParameter(methodParameter, (Type) null);, +	}, +, +	/**, +	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a, +	 * given implementation type. Use this variant when the class that declares the method, +	 * includes generic parameter variables that are satisfied by the implementation type., +	 * @param methodParameter the source method parameter (must not be {@code null}), +	 * @param implementationType the implementation type, +	 * @return a {@link ResolvableType} for the specified method parameter, +	 * @see #forMethodParameter(MethodParameter), +	 */, +	public static ResolvableType forMethodParameter(MethodParameter methodParameter, ResolvableType implementationType) {, +		Assert.notNull(methodParameter, "MethodParameter must not be null");, +		implementationType = (implementationType == null ? forType(methodParameter.getContainingClass()) : implementationType);, +		ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());, +		return forType(null, new MethodParameterTypeProvider(methodParameter),, +				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),, +				methodParameter.typeIndexesPerLevel);, +++ b/spring-core/src/test/java/org/springframework/core/ResolvableTypeTests.java, + * Copyright 2002-2014 the original author or authors., +	public void resolveTypeVariableFromFieldTypeWithImplementsType() throws Exception {, +		ResolvableType implementationType = ResolvableType.forClassWithGenerics(, +				Fields.class, Integer.class);, +		ResolvableType type = ResolvableType.forField(, +				Fields.class.getField("parameterizedType"), implementationType);, +		assertThat(type.resolve(), equalTo((Class) List.class));, +		assertThat(type.getGeneric().resolve(), equalTo((Class) Integer.class));, +	}, +, +	@Test, +	public void resolveTypeVariableFromMethodParameterTypeWithImplementsType() throws Exception {, +		Method method = Methods.class.getMethod("typedParameter", Object.class);, +		MethodParameter methodParameter = MethodParameter.forMethodOrConstructor(method, 0);, +		ResolvableType implementationType = ResolvableType.forClassWithGenerics(Methods.class, Integer.class);, +		ResolvableType type = ResolvableType.forMethodParameter(methodParameter, implementationType);, +		assertThat(type.resolve(), equalTo((Class) Integer.class));, +		assertThat(type.getType().toString(), equalTo("T"));, +	}, +, +	@Test]