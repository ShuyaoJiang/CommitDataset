[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ExpressionState.java, +import org.springframework.util.Assert;, +	private final TypedValue rootObject;, +, +	private final SpelParserConfiguration configuration;, +, +		this(context, context.getRootObject(), new SpelParserConfiguration(false, false));, +		this(context, context.getRootObject(), configuration);, +		this(context, rootObject, new SpelParserConfiguration(false, false));, +		Assert.notNull(context, "EvaluationContext must not be null");, +		Assert.notNull(configuration, "SpelParserConfiguration must not be null");, +		this.configuration = configuration;, +		return this.relatedContext.getTypeConverter().convertValue(val, TypeDescriptor.forObject(val), targetTypeDescriptor);, +	 * A new scope is entered when a function is invoked., +	 * A new scope is entered when a function is called and it is used to hold the, +	 * parameters to the function call. If the names of the parameters clash with, +	 * those in a higher level scope, those in the higher level scope will not be, +	 * accessible whilst the function is executing. When the function returns,, +	 * the scope is exited., +		public VariableScope() {, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ExpressionState.java, +import org.springframework.util.Assert;, +	private final TypedValue rootObject;, +, +	private final SpelParserConfiguration configuration;, +, +		this(context, context.getRootObject(), new SpelParserConfiguration(false, false));, +		this(context, context.getRootObject(), configuration);, +		this(context, rootObject, new SpelParserConfiguration(false, false));, +		Assert.notNull(context, "EvaluationContext must not be null");, +		Assert.notNull(configuration, "SpelParserConfiguration must not be null");, +		this.configuration = configuration;, +		return this.relatedContext.getTypeConverter().convertValue(val, TypeDescriptor.forObject(val), targetTypeDescriptor);, +	 * A new scope is entered when a function is invoked., +	 * A new scope is entered when a function is called and it is used to hold the, +	 * parameters to the function call. If the names of the parameters clash with, +	 * those in a higher level scope, those in the higher level scope will not be, +	 * accessible whilst the function is executing. When the function returns,, +	 * the scope is exited., +		public VariableScope() {, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java, +	public SpelParserConfiguration(boolean autoGrowNullReferences, boolean autoGrowCollections, int maximumAutoGrowSize) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ExpressionState.java, +import org.springframework.util.Assert;, +	private final TypedValue rootObject;, +, +	private final SpelParserConfiguration configuration;, +, +		this(context, context.getRootObject(), new SpelParserConfiguration(false, false));, +		this(context, context.getRootObject(), configuration);, +		this(context, rootObject, new SpelParserConfiguration(false, false));, +		Assert.notNull(context, "EvaluationContext must not be null");, +		Assert.notNull(configuration, "SpelParserConfiguration must not be null");, +		this.configuration = configuration;, +		return this.relatedContext.getTypeConverter().convertValue(val, TypeDescriptor.forObject(val), targetTypeDescriptor);, +	 * A new scope is entered when a function is invoked., +	 * A new scope is entered when a function is called and it is used to hold the, +	 * parameters to the function call. If the names of the parameters clash with, +	 * those in a higher level scope, those in the higher level scope will not be, +	 * accessible whilst the function is executing. When the function returns,, +	 * the scope is exited., +		public VariableScope() {, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java, +	public SpelParserConfiguration(boolean autoGrowNullReferences, boolean autoGrowCollections, int maximumAutoGrowSize) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +		return new AccessorLValue(this, state.getActiveContextObject(), state.getEvaluationContext(),, +				state.getConfiguration().isAutoGrowNullReferences());, +		return getValueInternal(state.getActiveContextObject(), state.getEvaluationContext(),, +				state.getConfiguration().isAutoGrowNullReferences());, +	private TypedValue getValueInternal(TypedValue contextObject, EvaluationContext eContext,, +			boolean isAutoGrowNullReferences) throws EvaluationException {, +, +	private static class AccessorLValue implements ValueRef {, +, +		private final PropertyOrFieldReference ref;, +, +		private final TypedValue contextObject;, +, +		private final EvaluationContext eContext;, +, +		private final boolean autoGrowNullReferences;, +, +		public AccessorLValue(PropertyOrFieldReference propertyOrFieldReference, TypedValue activeContextObject,, +				EvaluationContext evaluationContext, boolean autoGrowNullReferences) {, +			this.ref = propertyOrFieldReference;, +			this.contextObject = activeContextObject;, +			this.eContext = evaluationContext;, +			this.autoGrowNullReferences = autoGrowNullReferences;, +		}, +, +		@Override, +		public TypedValue getValue() {, +			return this.ref.getValueInternal(this.contextObject, this.eContext, this.autoGrowNullReferences);, +		}, +, +		@Override, +		public void setValue(Object newValue) {]