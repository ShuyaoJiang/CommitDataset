[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/DefaultStompSession.java, + * Copyright 2002-2018 the original author or authors., +		StompHeaders headers = new StompHeaders();, +		headers.setDestination(destination);, +		return send(headers, payload);, +	public Receiptable send(StompHeaders headers, Object payload) {, +		Assert.hasText(headers.getDestination(), "Destination header is required");, +		String receiptId = checkOrAddReceipt(headers);, +		accessor.addNativeHeaders(headers);, +	private String checkOrAddReceipt(StompHeaders headers) {, +		String receiptId = headers.getReceipt();, +			headers.setReceipt(receiptId);, +		StompHeaders headers = new StompHeaders();, +		headers.setDestination(destination);, +		return subscribe(headers, handler);, +	public Subscription subscribe(StompHeaders headers, StompFrameHandler handler) {, +		Assert.hasText(headers.getDestination(), "Destination header is required");, +		String subscriptionId = headers.getId();, +			headers.setId(subscriptionId);, +		checkOrAddReceipt(headers);, +		Subscription subscription = new DefaultSubscription(headers, handler);, +		accessor.addNativeHeaders(headers);, +		StompHeaders headers = new StompHeaders();, +			headers.setMessageId(messageId);, +			headers.setId(messageId);, +		return acknowledge(headers, consumed);, +	private void unsubscribe(String id, @Nullable StompHeaders headers) {, +		if (headers != null) {, +			accessor.addNativeHeaders(headers);, +		StompHeaders headers = StompHeaders.readOnlyStompHeaders(nativeHeaders);, +				DefaultSubscription subscription = this.subscriptions.get(headers.getSubscription());, +					invokeHandler(subscription.getHandler(), message, headers);, +					String receiptId = headers.getReceiptId();, +					initHeartbeatTasks(headers);, +					this.version = headers.getFirst("version");, +					this.sessionHandler.afterConnected(this, headers);, +					invokeHandler(this.sessionHandler, message, headers);, +			this.sessionHandler.handleException(this, command, headers, message.getPayload(), ex);, +	private void invokeHandler(StompFrameHandler handler, Message<byte[]> message, StompHeaders headers) {, +			handler.handleFrame(headers, null);, +		Type payloadType = handler.getPayloadType(headers);, +		handler.handleFrame(headers, object);, +		public void unsubscribe(@Nullable StompHeaders headers) {, +				DefaultStompSession.this.unsubscribe(id, headers);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/DefaultStompSession.java, + * Copyright 2002-2018 the original author or authors., +		StompHeaders headers = new StompHeaders();, +		headers.setDestination(destination);, +		return send(headers, payload);, +	public Receiptable send(StompHeaders headers, Object payload) {, +		Assert.hasText(headers.getDestination(), "Destination header is required");, +		String receiptId = checkOrAddReceipt(headers);, +		accessor.addNativeHeaders(headers);, +	private String checkOrAddReceipt(StompHeaders headers) {, +		String receiptId = headers.getReceipt();, +			headers.setReceipt(receiptId);, +		StompHeaders headers = new StompHeaders();, +		headers.setDestination(destination);, +		return subscribe(headers, handler);, +	public Subscription subscribe(StompHeaders headers, StompFrameHandler handler) {, +		Assert.hasText(headers.getDestination(), "Destination header is required");, +		String subscriptionId = headers.getId();, +			headers.setId(subscriptionId);, +		checkOrAddReceipt(headers);, +		Subscription subscription = new DefaultSubscription(headers, handler);, +		accessor.addNativeHeaders(headers);, +		StompHeaders headers = new StompHeaders();, +			headers.setMessageId(messageId);, +			headers.setId(messageId);, +		return acknowledge(headers, consumed);, +	private void unsubscribe(String id, @Nullable StompHeaders headers) {, +		if (headers != null) {, +			accessor.addNativeHeaders(headers);, +		StompHeaders headers = StompHeaders.readOnlyStompHeaders(nativeHeaders);, +				DefaultSubscription subscription = this.subscriptions.get(headers.getSubscription());, +					invokeHandler(subscription.getHandler(), message, headers);, +					String receiptId = headers.getReceiptId();, +					initHeartbeatTasks(headers);, +					this.version = headers.getFirst("version");, +					this.sessionHandler.afterConnected(this, headers);, +					invokeHandler(this.sessionHandler, message, headers);, +			this.sessionHandler.handleException(this, command, headers, message.getPayload(), ex);, +	private void invokeHandler(StompFrameHandler handler, Message<byte[]> message, StompHeaders headers) {, +			handler.handleFrame(headers, null);, +		Type payloadType = handler.getPayloadType(headers);, +		handler.handleFrame(headers, object);, +		public void unsubscribe(@Nullable StompHeaders headers) {, +				DefaultStompSession.this.unsubscribe(id, headers);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompSession.java, + * Copyright 2002-2018 the original author or authors., +	 * {@code send} and {@code subscribe} operations on this session, which, +	 * causes the server to return a RECEIPT. An application can then use, +	 * the {@link StompSession.Receiptable Receiptable} returned from the, +	 * operation to track the receipt., +	 * An overloaded version of {@link #send(String, Object)} with full, +	 * {@link StompHeaders} instead of just a destination. The headers must, +	 * "content-type" or custom headers for the broker to propagate to, +	 * subscribers, or broker-specific, non-standard headers.., +	 * with full {@link StompHeaders} instead of just a destination., +	 * An overloaded version of {@link #acknowledge(String, boolean)} with]