[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +import java.util.Comparator;, +import java.util.LinkedHashMap;, +import org.springframework.util.StringUtils;, +	private final Map<PathPattern, Object> handlerMap = new LinkedHashMap<>();, +	 * Return a read-only view of registered path patterns and handlers which may, +	 * may be an actual handler instance or the bean name of lazily initialized, +	 * handler., +		return Collections.unmodifiableMap(this.handlerMap);, +	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange), +			throws Exception {, +		return this.handlerMap.entrySet().stream(), +				.filter(entry -> entry.getKey().matches(lookupPath)), +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +				.map(entry -> {, +					PathPattern pattern = entry.getKey();, +					if (logger.isDebugEnabled()) {, +						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern);, +					}, +					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);, +					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange);, +				}), +				.orElse(null);, +			ServerWebExchange exchange) {, +	protected void validateHandler(Object handler, ServerWebExchange exchange) {, +	protected void registerHandler(String[] urlPaths, String beanName), +			throws BeansException, IllegalStateException {, +, +	protected void registerHandler(String urlPath, Object handler), +			throws BeansException, IllegalStateException {, +, +		// Parse path pattern, +		urlPath = prependLeadingSlash(urlPath);, +		PathPattern pattern = getPathPatternParser().parse(urlPath);, +		if (this.handlerMap.containsKey(pattern)) {, +			Object existingHandler = this.handlerMap.get(pattern);, +			if (existingHandler != null) {, +				if (existingHandler != resolvedHandler) {, +					throw new IllegalStateException(, +							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +, +							"there is already " + getHandlerDescription(existingHandler) + " mapped.");, +				}, +			}, +		}, +		// Register resolved handler, +		this.handlerMap.put(pattern, resolvedHandler);, +	private static String prependLeadingSlash(String pattern) {, +		if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {, +			return "/" + pattern;, +		}, +		else {, +			return pattern;, +		}, +	}, +, +		return "handler " + (handler instanceof String ?, +				"'" + handler + "'" : "of type [" + handler.getClass() + "]");, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java, +import java.util.Comparator;, +import java.util.LinkedHashMap;, +import org.springframework.util.StringUtils;, +	private final Map<PathPattern, Object> handlerMap = new LinkedHashMap<>();, +	 * Return a read-only view of registered path patterns and handlers which may, +	 * may be an actual handler instance or the bean name of lazily initialized, +	 * handler., +		return Collections.unmodifiableMap(this.handlerMap);, +	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange), +			throws Exception {, +		return this.handlerMap.entrySet().stream(), +				.filter(entry -> entry.getKey().matches(lookupPath)), +				.sorted(Comparator.comparing(Map.Entry::getKey)), +				.findFirst(), +				.map(entry -> {, +					PathPattern pattern = entry.getKey();, +					if (logger.isDebugEnabled()) {, +						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern);, +					}, +					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);, +					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange);, +				}), +				.orElse(null);, +			ServerWebExchange exchange) {, +	protected void validateHandler(Object handler, ServerWebExchange exchange) {, +	protected void registerHandler(String[] urlPaths, String beanName), +			throws BeansException, IllegalStateException {, +, +	protected void registerHandler(String urlPath, Object handler), +			throws BeansException, IllegalStateException {, +, +		// Parse path pattern, +		urlPath = prependLeadingSlash(urlPath);, +		PathPattern pattern = getPathPatternParser().parse(urlPath);, +		if (this.handlerMap.containsKey(pattern)) {, +			Object existingHandler = this.handlerMap.get(pattern);, +			if (existingHandler != null) {, +				if (existingHandler != resolvedHandler) {, +					throw new IllegalStateException(, +							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +, +							"there is already " + getHandlerDescription(existingHandler) + " mapped.");]