[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java, + * Copyright 2002-2012 the original author or authors., +import org.springframework.util.ClassUtils;, +				String propertyName = pd.getName();, +				Method readMethod = pd.getReadMethod();, +				Method mostSpecificReadMethod = ClassUtils.getMostSpecificMethod(readMethod, method.getDeclaringClass());, +					if (method.equals(mostSpecificReadMethod), +							&& existingPD.getName().equals(propertyName)) {, +							this.addOrUpdatePropertyDescriptor(pd, propertyName, method, pd.getWriteMethod());, +				if (method.equals(mostSpecificReadMethod), +						this.addOrUpdatePropertyDescriptor(pd, propertyName, readMethod, pd.getWriteMethod(), ((IndexedPropertyDescriptor)pd).getIndexedReadMethod(), ((IndexedPropertyDescriptor)pd).getIndexedWriteMethod());, +						this.addOrUpdatePropertyDescriptor(pd, propertyName, readMethod, pd.getWriteMethod());, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java, + * Copyright 2002-2012 the original author or authors., +import org.springframework.util.ClassUtils;, +				String propertyName = pd.getName();, +				Method readMethod = pd.getReadMethod();, +				Method mostSpecificReadMethod = ClassUtils.getMostSpecificMethod(readMethod, method.getDeclaringClass());, +					if (method.equals(mostSpecificReadMethod), +							&& existingPD.getName().equals(propertyName)) {, +							this.addOrUpdatePropertyDescriptor(pd, propertyName, method, pd.getWriteMethod());, +				if (method.equals(mostSpecificReadMethod), +						this.addOrUpdatePropertyDescriptor(pd, propertyName, readMethod, pd.getWriteMethod(), ((IndexedPropertyDescriptor)pd).getIndexedReadMethod(), ((IndexedPropertyDescriptor)pd).getIndexedWriteMethod());, +						this.addOrUpdatePropertyDescriptor(pd, propertyName, readMethod, pd.getWriteMethod());, +++ b/org.springframework.beans/src/test/java/org/springframework/beans/ExtendedBeanInfoTests.java, +import static org.junit.Assert.assertTrue;, +import java.lang.reflect.Method;, +import org.springframework.util.ClassUtils;, +, +, +, +	/**, +	 * java.beans.Introspector returns the "wrong" declaring class for overridden read, +	 * methods, which in turn violates expectations in {@link ExtendedBeanInfo} regarding, +	 * method equality. Spring's {@link ClassUtils#getMostSpecificMethod(Method, Class)}, +	 * helps out here, and is now put into use in ExtendedBeanInfo as well, +	 */, +	@Test, +	public void demonstrateCauseSpr8949() throws IntrospectionException {, +		BeanInfo info = Introspector.getBeanInfo(B.class);, +, +		for (PropertyDescriptor pd : info.getPropertyDescriptors()) {, +			if ("targetMethod".equals(pd.getName())) {, +				Method readMethod = pd.getReadMethod();, +				assertTrue(readMethod.getDeclaringClass().equals(A.class)); // we expected B!, +, +				Method msReadMethod = ClassUtils.getMostSpecificMethod(readMethod, B.class);, +				assertTrue(msReadMethod.getDeclaringClass().equals(B.class)); // and now we get it., +			}, +		}, +	}, +, +	@Test, +	public void cornerSpr8949() throws IntrospectionException {, +		BeanInfo bi = Introspector.getBeanInfo(B.class);, +		ExtendedBeanInfo ebi = new ExtendedBeanInfo(bi);, +, +		assertThat(hasReadMethodForProperty(bi, "targetMethod"), is(true));, +		assertThat(hasWriteMethodForProperty(bi, "targetMethod"), is(false));, +, +		assertThat(hasReadMethodForProperty(ebi, "targetMethod"), is(true));, +		assertThat(hasWriteMethodForProperty(ebi, "targetMethod"), is(false));, +	}, +, +	static class A {, +		public boolean isTargetMethod() {, +			return false;, +		}, +	}, +, +	static class B extends A {, +		@Override, +		public boolean isTargetMethod() {, +			return false;, +		}, +	}]