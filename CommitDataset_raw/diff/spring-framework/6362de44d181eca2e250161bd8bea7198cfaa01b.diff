[+++ b/spring-framework-reference/src/testing.xml, +    <emphasis>(A thorough treatment of testing in the enterprise is beyond the, +    scope of this chapter.)</emphasis></para>, +      The name of the actual JAR file might include the release, +        test. Thus the setup cost is incurred only once (per test suite),, +        application object &mdash; the TestContext framework can be configured, +        to reload the configurations and rebuild the application, +        <classname>HibernateTitleRepository</classname>, that performs data access, +            <classname>HibernateTitleRepository</classname> bean correct and, +            <para>The logic of the <classname>HibernateTitleRepository</classname>:, +          is used in conjunction with, +          via the <interfacename>@Transactional</interfacename>, +          via the <interfacename>@Transactional</interfacename>, +      For JUnit 4.5+, the framework also provides a custom JUnit, +        and whether to load a context from a default location. For, +        explicitly configure the <literal>locations</literal> attribute of, +        has been configured, which is the default). A plain path, for, +        example <literal>"context.xml"</literal>, will be treated as a, +        classpath resource from the same package in which the test class, +        is defined. A path starting with a slash is treated as a fully qualified, +        classpath location, for example <literal>"/org/example/config.xml"</literal>., +        A path which represents a URL (i.e., a path prefixed with, +        <literal>classpath:</literal>, <literal>file:</literal>,, +        <literal>http:</literal>, etc.) will be used <emphasis>as is</emphasis>., +        Alternatively, you can implement and configure your own custom, +<emphasis role="bold">@ContextConfiguration(locations={"/applicationContext.xml", "/applicationContext-test.xml"})</emphasis>, +        shorthand format demonstrated in the following example.</para>, +, +        <para>, +        following example, the <interfacename>ApplicationContext</interfacename> for, +        class shadow and effectively replace any resource locations defined, +        test. Thus the setup cost is incurred only once (per test suite),, +        that a test corrupts the application context and requires reloading &mdash;, +        for example, by modifying a bean definition or the state of an, +        application object &mdash; you can annotate your test class or test, +        method with <interfacename>@DirtiesContext</interfacename> (assuming, +        configured, which is the default). This instructs Spring to reload, +        which is configured by default &mdash; the dependencies of your, +        test instances are <emphasis>injected</emphasis> from beans in the, +        application context that you configured with, +        <interfacename>@ContextConfiguration</interfacename>. You may use setter, +        <methodname>applicationContext.getBean("titleRepository")</methodname>. A, +        <para>Consider the scenario of testing a, +        <classname>HibernateTitleRepository</classname> class, as outlined in the <link, +        linkend="testing-fixture-di">Goals</link> section. The next four, +        code listings demonstrate the use of <interfacename>@Autowired</interfacename>, +        and <interfacename>@Resource</interfacename> on fields and, +        setter methods. The application context configuration is presented, +        after all sample code listings.</para>, +        <para>The first code listing shows a JUnit 4-based implementation, +        of the test class that uses <interfacename>@Autowired</interfacename>, +        for field injection.</para>, +, +<emphasis role="bold">@ContextConfiguration("repository-config.xml")</emphasis>, +public class HibernateTitleRepositoryTests {, +    private HibernateTitleRepository titleRepository;, +    @Test, +    public void loadTitle() {, +        Title title = titleRepository.loadTitle(new Long(10));, +        <interfacename>@Autowired</interfacename> for setter injection as, +        seen below.</para>, +<emphasis role="bold">@ContextConfiguration("repository-config.xml")</emphasis>, +public class HibernateTitleRepositoryTests {, +    private HibernateTitleRepository titleRepository;, +    public void setTitleRepository(HibernateTitleRepository titleRepository) {, +        this.titleRepository = titleRepository;, +    @Test, +    public void loadTitle() {, +        Title title = titleRepository.loadTitle(new Long(10));, +        <para>The following is an example of using <interfacename>@Resource</interfacename>, +<emphasis role="bold">@ContextConfiguration("repository-config.xml")</emphasis>, +public class HibernateTitleRepositoryTests {, +    private HibernateTitleRepository titleRepository;, +    @Test, +    public void loadTitle() {, +        Title title = titleRepository.loadTitle(new Long(10));, +        <para>Here is an example of using <interfacename>@Resource</interfacename>, +<emphasis role="bold">@ContextConfiguration("repository-config.xml")</emphasis>, +public class HibernateTitleRepositoryTests {, +    private HibernateTitleRepository titleRepository;, +    public void setTitleRepository(HibernateTitleRepository titleRepository) {, +        this.titleRepository = titleRepository;, +    @Test, +    public void loadTitle() {, +        Title title = titleRepository.loadTitle(new Long(10));, +        annotation (that is, <literal>repository-config.xml</literal>), which looks like, +    <lineannotation>&lt;!-- this bean will be injected into the <classname>HibernateTitleRepositoryTests</classname> class --&gt;</lineannotation>, +    &lt;bean id="<emphasis role="bold">titleRepository</emphasis>" class="<emphasis, +            role="bold">com.foo.repository.hibernate.HibernateTitleRepository</emphasis>"&gt;, +        <lineannotation>&lt;!-- configuration elided for brevity --&gt;</lineannotation>, +          can override the setter method and use the, +          specific target bean as follows, but make sure to delegate to the , +          overridden method in the superclass as well.</para>, +          assuming that "myDataSource" is the bean id).</para>, +          overridden setter methods. This allows you to specify the name of, +          the target bean explicitly, but without type matching semantics., +          In contrast to the solution above that combined , +          <interfacename>@Autowired</interfacename> and, +          <interfacename>@Qualifier</interfacename>, using , +          <interfacename>@Resource</interfacename> results in the ]