[+++ b/spring-framework-reference/src/dao.xml, +    easy to work with data access technologies like JDBC, Hibernate, JPA or, +    JDO in a consistent way. This allows one to switch between the, +    aforementioned persistence technologies fairly easily and it also allows, +    one to code without worrying about catching exceptions that are specific, +    to each technology.</para>, +++ b/spring-framework-reference/src/dao.xml, +    easy to work with data access technologies like JDBC, Hibernate, JPA or, +    JDO in a consistent way. This allows one to switch between the, +    aforementioned persistence technologies fairly easily and it also allows, +    one to code without worrying about catching exceptions that are specific, +    to each technology.</para>, +++ b/spring-framework-reference/src/jdbc.xml, +          under the covers. In Spring 3.0 it has been updated with Java 5, +          support like generics and vararg support. </para>, +          parameters for an SQL statement. It has also been updated with Java, +          5 support like generics and vararg support for Spring 3.0.</para>, +          convenience by taking better advantage of Java 5 varargs for, +          ceratain methods where this wasn't possible in the JdbcTemplate due, +          to backwars compatibility reasons.</para>, +          SimpleJdbcTemplate. Requires a database that provides adequate, +          metadata.</para>, +          multiple times with various parameter values passed in. It has also, +          been updated with Java 5 support like generics and vararg support, +          for Spring 3.0.</para>, +          <programlisting language="java"><![CDATA[int rowCount = this.jdbcTemplate.queryForInt("select count(*) from t_actor");]]></programlisting>, +          <programlisting language="java"><![CDATA[int countOfActorsNamedJoe = this.jdbcTemplate.queryForInt(, +        "select count(*) from t_actor where first_name = ?", "Joe");]]></programlisting>, +          <programlisting language="java"><![CDATA[String surname = this.jdbcTemplate.queryForObject(, +        new Object[]{1212L}, String.class);]]></programlisting>, +          <programlisting language="java"><![CDATA[Actor actor = this.jdbcTemplate.queryForObject(, +        new Object[]{1212L},, +        new RowMapper<Actor>() {, +            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {, +        });, +]]></programlisting>, +          <programlisting language="java"><![CDATA[List<Actor> actors = this.jdbcTemplate.query(, +        new RowMapper<Actor>() {, +            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {, +        });, +]]></programlisting>, +          <programlisting language="java"><![CDATA[public List<Actor> findAllActors() {, +private static final class ActorMapper implements RowMapper<Actor> {, +    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {, +}]]></programlisting>, +          <programlisting language="java"><![CDATA[this.jdbcTemplate.update(, +        new Object[] {"Leonor", "Watling"});]]></programlisting>, +          <programlisting language="java"><![CDATA[this.jdbcTemplate.update(, +        new Object[] {"Banjo", new Long(5276)});]]></programlisting>, +          <programlisting language="java"><![CDATA[this.jdbcTemplate.update(, +        new Object[] {new Long.valueOf(actorId)});]]></programlisting>, +          <programlisting language="java"><![CDATA[this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");]]></programlisting>, +          <programlisting language="java"><![CDATA[this.jdbcTemplate.update(, +        new Object[]{Long.valueOf(unionId)});]]></programlisting>, +      <programlisting language="java"><![CDATA[DriverManagerDataSource dataSource = new DriverManagerDataSource();, +dataSource.setPassword("");]]></programlisting>, +      <programlisting language="java"><![CDATA[public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {, +}]]></programlisting>, +      <programlisting language="java"><![CDATA[import javax.sql.DataSource;, +}]]></programlisting>, +      <programlisting language="java"><![CDATA[import javax.sql.DataSource;, +}]]></programlisting>, +      <programlisting language="java"><![CDATA[, +}]]></programlisting>, +      <programlisting><![CDATA[[{name=Bob, id=1}, {name=Mary, id=2}]]]></programlisting>, +      <programlisting language="java"><![CDATA[import javax.sql.DataSource;, +}]]></programlisting>, +      interface that configures a plain old JDBC Driver via bean properties,, +      and returns a new <interfacename>Connection</interfacename> every, +      time.</para>, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +}]]></programlisting>If you are processing stream of updates or reading from a, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +    public int[] batchUpdate(final List<Actor> actors) {, +}]]></programlisting>For an SQL statement using the classic "?" place holders, +      you pass in a List containing an object array with the update values., +      This object array must have one entry for each placeholder in the SQL, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +    public int[] batchUpdate(final List<Actor> actors) {, +        List<Object[]> batch = new ArrayList<Object[]>();, +}]]></programlisting>All batch update methods return an int array containing, +      the number of affected rows for each batch entry. This count is reported, +      by the JDBC driver and it's not always available in which case the JDBC, +      <programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +        Map<String, Object> parameters = new HashMap<String, Object>(3);, +}]]></programlisting>, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +        Map<String, Object> parameters = new HashMap<String, Object>(2);, +}]]></programlisting>Here we can see the main difference when executing the, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +        Map<String, Object> parameters = new HashMap<String, Object>(2);, +}]]></programlisting>The execution of the insert is the same as if we had, +      relied on the metadata for determining what columns to use.</para>, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +}]]></programlisting>Another option is the, +      <para><programlisting language="java"><![CDATA[public class JdbcActorDao implements ActorDao {, +}]]></programlisting>As you can see, the configuration is the same, it;s just, +      the executing code that has to change to use these alternative input, +      <para><programlisting><![CDATA[CREATE PROCEDURE read_actor ( , +END;]]></programlisting>As you can see there are four parameters. One is an in]