[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * Get <strong>all</strong> annotations of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @return the set of all merged, synthesized {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #getMergedAnnotation(AnnotatedElement, Class), +	 * @see #getAllAnnotationAttributes(AnnotatedElement, String), +	 * @see #findAllMergedAnnotations(AnnotatedElement, Class), +	 */, +	public static <A extends Annotation> Set<A> getAllMergedAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +, +		Assert.notNull(element, "AnnotatedElement must not be null");, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		MergedAnnotationAttributesProcessor processor =, +				new MergedAnnotationAttributesProcessor(annotationType, null, false, false, true);, +		searchWithGetSemantics(element, annotationType, null, processor);, +		return postProcessAndSynthesizeAggregatedResults(element, annotationType, processor.getAggregatedResults());, +	}, +, +	/**, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * @see #getAllMergedAnnotations(AnnotatedElement, Class), +		return postProcessAndSynthesizeAggregatedResults(element, annotationType, processor.getAggregatedResults());, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * hierarchy and synthesize the results back into an annotation of the specified, +		return postProcessAndSynthesizeAggregatedResults(element, annotationType, processor.getAggregatedResults());, +			// Note: we only check for (metaDepth > 0) due to the nuances of getMetaAnnotationTypes()., +					((annotation.annotationType() == annotationType, +							|| annotation.annotationType().getName().equals(annotationName)) || metaDepth > 0)) {, +					if (processor.aggregates() && metaDepth == 0) {, +						processor.getAggregatedResults().add(result);, +					}, +					else {, +		}, +					if (processor.aggregates() && metaDepth == 0) {, +						processor.getAggregatedResults().add(result);, +					}, +					else {, +		}, +	/**, +	 * @since 4.3, +	 */, +	private static <A extends Annotation> Set<A> postProcessAndSynthesizeAggregatedResults(AnnotatedElement element,, +			Class<A> annotationType, List<AnnotationAttributes> aggregatedResults) {, +, +		Set<A> annotations = new LinkedHashSet<A>();, +		for (AnnotationAttributes attributes : aggregatedResults) {, +			AnnotationUtils.postProcessAnnotationAttributes(element, attributes, false, false);, +			annotations.add(AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element));, +		}, +		return annotations;, +	}, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	 * Get <strong>all</strong> annotations of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the results back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>get semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @return the set of all merged, synthesized {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #getMergedAnnotation(AnnotatedElement, Class), +	 * @see #getAllAnnotationAttributes(AnnotatedElement, String), +	 * @see #findAllMergedAnnotations(AnnotatedElement, Class), +	 */, +	public static <A extends Annotation> Set<A> getAllMergedAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +, +		Assert.notNull(element, "AnnotatedElement must not be null");, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		MergedAnnotationAttributesProcessor processor =, +				new MergedAnnotationAttributesProcessor(annotationType, null, false, false, true);, +		searchWithGetSemantics(element, annotationType, null, processor);, +		return postProcessAndSynthesizeAggregatedResults(element, annotationType, processor.getAggregatedResults());, +	}, +, +	/**, +	 * hierarchy and synthesize the results back into an annotation of the specified]