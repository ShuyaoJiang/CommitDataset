[+++ b/src/asciidoc/images/message-flow-broker-relay.png, +++ b/src/asciidoc/images/message-flow-broker-relay.png, +++ b/src/asciidoc/images/message-flow-simple-broker.png, +++ b/src/asciidoc/images/message-flow-broker-relay.png, +++ b/src/asciidoc/images/message-flow-simple-broker.png, +++ b/src/asciidoc/web-websocket.adoc, +The WebSocket protocol defines two types of messages, text and binary, but their, +content is undefined. It's expected that the client and server may agree on using, +a sub-protocol (i.e. a higher-level protocol) to define message semantics., +While the use of a sub-protocol with WebSocket is completely optional either way, +client and server will need to agree on some kind of protocol to help interpret, +messages., +such as Ruby, Python, and Perl to connect to enterprise message brokers. It is, +designed to address a subset of commonly used messaging patterns. STOMP can be, +used over any reliable 2-way streaming network protocol such as TCP and WebSocket., +Although STOMP is a text-oriented protocol, the payload of messages can be, +either text or binary., +STOMP is a frame based protocol whose frames are modeled on HTTP. The structure, +of a STOMP frame:, +Clients can use the +SEND+ or +SUBSCRIBE+ commands to send or subscribe for, +messages along with a +"destination"+ header that describes what the, +message is about and who should receive it. This enables a simple, +publish-subscribe mechanism that can be used to send messages through the broker, +to other connected clients or to send messages to the server to request that, +some work be performed., +When using Spring's STOMP support, the Spring WebSocket application acts, +as the STOMP broker to clients. Messages are routed to `@Controller` message-handling, +methods or to a simple, in-memory broker that keeps track of subscriptions and, +broadcasts messages to subscribed users. You can also configure Spring to work, +with a dedicated STOMP broker (e.g. RabbitMQ, ActiveMQ, etc) for the actual, +broadcasting of messages. In that case Spring maintains, +TCP connections to the broker, relays messages to it, and also passes messages, +from it down to connected WebSocket clients. Thus Spring web applications can, +rely on unified HTTP-based security, common validation, and a familiar programming, +model message-handling work., +, +Here is an example of a client subscribing to receive stock quotes which, +the server may emit periodically e.g. via a scheduled task sending messages, +through a `SimpMessagingTemplate` to the broker:, +, +----, +SUBSCRIBE, +id:sub-1, +destination:/topic/price.stock.*, +, +^@, +----, +, +Here is an example of a client sending a trade request, which the server, +may handle through an `@MessageMapping` method and later on, after the execution,, +broadcast a trade confirmation message and details down to the client:, +http://stomp.github.io/stomp-specification-1.2.html[specification] in full., +The benefits of using STOMP as a WebSocket sub-protocol:, +* No need to invent a custom message format, +* Use existing https://github.com/jmesnil/stomp-websocket[stomp.js] client in the browser, +* Ability to route messages to based on destination, +* Option to use full-fledged message broker such as RabbitMQ, ActiveMQ, etc. for broadcasting, +the +spring-messaging+ and +spring-websocket+ modules., +Here is an example of exposing a STOMP WebSocket/SockJS endpoint at the URL path, +`/portfolio` where messages whose destination starts with "/app" are routed to, +message-handling methods (i.e. application work) and messages whose destinations, +start with "/topic" or "/queue" will be routed to the message broker (i.e., +broadcasting to other connected clients):, +		@Override, +        public void configureMessageBroker(MessageBrokerRegistry config) {, +            config.setApplicationDestinationPrefixes("/app");, +            config.enableSimpleBroker("/topic", "/queue");, +        }, +and in XML:, +			<websocket:simple-broker prefix="/topic, /queue"/>, +[NOTE], +====, +The "/app" prefix is arbitrary. You can pick any prefix. It's simply meant to differentiate, +messages to be routed to message-handling methods to do application work vs messages, +to be routed to the broker to broadcast to subscribed clients., +, +The "/topic" and "/queue" prefixes depend on the broker in use. In the case of the simple,, +in-memory broker the prefixes do not have any special meaning; it's merely a convention, +that indicates how the destination is used (pub-sub targetting many subscribers or, +point-to-point messages typically targeting an individual recipient)., +In the case of using a dedicated broker, most brokers use "/topic" as, +a prefix for destinations with pub-sub semantics and "/queue" for destinations, +with point-to-point semantics. Check the STOMP page of the broker to see the destination, +semantics it supports., +====, +, +, +to connected clients. This section provides a big picture overview of how messages flow, +within the application., +The `spring-messaging` module provides the foundation for asynchronous message processing., +It contains a number of abstractions that originated in the, +The `@EnableWebSocketMessageBroker` Java config and the `<websocket:message-broker>` XML config, +both assemble a concrete message flow. Below is a diagram of the part of the setup when using, +the simple, in-memory broker:, +image::images/message-flow-simple-broker.png[width=640], +, +The above setup that includes 3 message channels:, +, +* `"clientInboundChannel"` for messages from WebSocket clients., +* `"clientOutboundChannel"` for messages to WebSocket clients.]