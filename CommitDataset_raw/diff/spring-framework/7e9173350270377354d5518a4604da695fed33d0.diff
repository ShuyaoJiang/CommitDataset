[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +	private static final ResponseEntity<Object> notFound = new ResponseEntity<>(HttpStatus.NOT_FOUND);, +, +			returnValueMono = Mono.from(adapter.toPublisher(result.getReturnValue())), +					.defaultIfEmpty(notFound);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +	private static final ResponseEntity<Object> notFound = new ResponseEntity<>(HttpStatus.NOT_FOUND);, +, +			returnValueMono = Mono.from(adapter.toPublisher(result.getReturnValue())), +					.defaultIfEmpty(notFound);, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandlerTests.java, +	@Test // SPR-13281, +	public void handleEmptyMonoShouldResultInNotFoundStatus() {, +		MockServerWebExchange exchange = MockServerWebExchange.from(get("/path"));, +		exchange.getAttributes().put(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, Collections.singleton(APPLICATION_JSON));, +, +		MethodParameter type = on(TestController.class).resolveReturnType(Mono.class, ResponseEntity.class);, +		HandlerResult result = new HandlerResult(new TestController(), Mono.empty(), type);, +, +		this.resultHandler.handleResult(exchange, result).block(Duration.ofSeconds(5));, +, +		assertEquals(HttpStatus.NOT_FOUND, exchange.getResponse().getStatusCode());, +		assertResponseBodyIsEmpty(exchange);, +	}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +	private static final ResponseEntity<Object> notFound = new ResponseEntity<>(HttpStatus.NOT_FOUND);, +, +			returnValueMono = Mono.from(adapter.toPublisher(result.getReturnValue())), +					.defaultIfEmpty(notFound);, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandlerTests.java, +	@Test // SPR-13281, +	public void handleEmptyMonoShouldResultInNotFoundStatus() {, +		MockServerWebExchange exchange = MockServerWebExchange.from(get("/path"));, +		exchange.getAttributes().put(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, Collections.singleton(APPLICATION_JSON));, +, +		MethodParameter type = on(TestController.class).resolveReturnType(Mono.class, ResponseEntity.class);, +		HandlerResult result = new HandlerResult(new TestController(), Mono.empty(), type);, +, +		this.resultHandler.handleResult(exchange, result).block(Duration.ofSeconds(5));, +, +		assertEquals(HttpStatus.NOT_FOUND, exchange.getResponse().getStatusCode());, +		assertResponseBodyIsEmpty(exchange);, +	}, +, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor.java, +import java.util.Optional;, +import org.springframework.http.HttpStatus;, +		Class<?> parameterType = returnType.nestedIfOptional().getNestedParameterType();, +		return (HttpEntity.class.isAssignableFrom(parameterType) &&, +				!RequestEntity.class.isAssignableFrom(parameterType));, +		Assert.isAssignable(HttpEntity.class, parameter.getNestedParameterType());, +	@SuppressWarnings("unchecked"), +		if (returnType.getParameterType() == Optional.class) {, +			Optional<HttpEntity<?>> optionalEntity = (Optional<HttpEntity<?>>) returnValue;, +			returnValue = optionalEntity.orElseGet(() -> new ResponseEntity<>(HttpStatus.NOT_FOUND));, +			returnType = returnType.nestedIfOptional();, +		}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java, +	private static final ResponseEntity<Object> notFound = new ResponseEntity<>(HttpStatus.NOT_FOUND);, +, +			returnValueMono = Mono.from(adapter.toPublisher(result.getReturnValue())), +					.defaultIfEmpty(notFound);, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandlerTests.java, +	@Test // SPR-13281, +	public void handleEmptyMonoShouldResultInNotFoundStatus() {, +		MockServerWebExchange exchange = MockServerWebExchange.from(get("/path"));, +		exchange.getAttributes().put(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, Collections.singleton(APPLICATION_JSON));, +, +		MethodParameter type = on(TestController.class).resolveReturnType(Mono.class, ResponseEntity.class);, +		HandlerResult result = new HandlerResult(new TestController(), Mono.empty(), type);, +, +		this.resultHandler.handleResult(exchange, result).block(Duration.ofSeconds(5));, +, +		assertEquals(HttpStatus.NOT_FOUND, exchange.getResponse().getStatusCode());, +		assertResponseBodyIsEmpty(exchange);, +	}, +, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor.java, +import java.util.Optional;, +import org.springframework.http.HttpStatus;, +		Class<?> parameterType = returnType.nestedIfOptional().getNestedParameterType();, +		return (HttpEntity.class.isAssignableFrom(parameterType) &&, +				!RequestEntity.class.isAssignableFrom(parameterType));, +		Assert.isAssignable(HttpEntity.class, parameter.getNestedParameterType());, +	@SuppressWarnings("unchecked"), +		if (returnType.getParameterType() == Optional.class) {, +			Optional<HttpEntity<?>> optionalEntity = (Optional<HttpEntity<?>>) returnValue;, +			returnValue = optionalEntity.orElseGet(() -> new ResponseEntity<>(HttpStatus.NOT_FOUND));, +			returnType = returnType.nestedIfOptional();, +		}, +, +++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessorMockTests.java, +import java.util.Optional;, +import org.springframework.web.method.ResolvableMethod;, +import static java.time.Instant.ofEpochMilli;, +import static java.time.format.DateTimeFormatter.RFC_1123_DATE_TIME;, +import static org.springframework.http.MediaType.APPLICATION_OCTET_STREAM;, +import static org.springframework.http.MediaType.TEXT_PLAIN;]