[+++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +import java.util.Arrays;, +import java.util.stream.Collectors;, +import org.springframework.http.HttpMethod;, +import static org.springframework.test.util.AssertionErrors.assertEquals;, +import static org.springframework.test.util.AssertionErrors.assertTrue;, +import static org.springframework.test.util.AssertionErrors.fail;, +			return createResponseSpec(this.headerSpec.exchange());, +			return createResponseSpec(this.headerSpec.exchange(inserter));, +			return createResponseSpec(this.headerSpec.exchange(publisher, elementClass));, +		protected DefaultResponseSpec createResponseSpec(Mono<ClientResponse> responseMono) {, +			ClientResponse response = responseMono.block(getTimeout());, +			WiretapConnector.Info info = connectorListener.retrieveRequest(this.requestId);, +			HttpMethod method = info.getMethod();, +			URI url = info.getUrl();, +			HttpHeaders headers = info.getRequestHeaders();, +			ExchangeResult<Flux<DataBuffer>> result = ExchangeResult.fromResponse(method, url, headers, response);, +			return new DefaultResponseSpec(result, response);, +		}, +	}, +	private abstract class ResponseSpecSupport {, +, +		private final ExchangeResult<Flux<DataBuffer>> exchangeResult;, +, +		private final ClientResponse response;, +		public ResponseSpecSupport(ExchangeResult<Flux<DataBuffer>> result, ClientResponse response) {, +			this.exchangeResult = result;, +			this.response = response;, +		}, +, +		public ResponseSpecSupport(ResponseSpecSupport responseSpec) {, +			this.exchangeResult = responseSpec.getExchangeResult();, +			this.response = responseSpec.getResponse();, +		}, +, +, +		protected ExchangeResult<Flux<DataBuffer>> getExchangeResult() {, +			return this.exchangeResult;, +		}, +, +		protected ClientResponse getResponse() {, +			return this.response;, +		}, +, +		protected HttpHeaders getResponseHeaders() {, +			return getExchangeResult().getResponseHeaders();, +		}, +, +		protected <T> ExchangeResult<T> createResultWithDecodedBody(T body) {, +			return ExchangeResult.withDecodedBody(this.exchangeResult, body);, +		}, +, +	}, +, +	private class DefaultResponseSpec extends ResponseSpecSupport implements ResponseSpec {, +, +, +		public DefaultResponseSpec(ExchangeResult<Flux<DataBuffer>> result, ClientResponse response) {, +			super(result, response);, +		public StatusAssertions expectStatus() {, +			return new StatusAssertions(getResponse().statusCode(), this);, +		public HeaderAssertions expectHeader() {, +			return new HeaderAssertions(getResponseHeaders(), this);, +		public BodySpec expectBody() {, +			return new DefaultBodySpec(this);, +		public ElementBodySpec expectBody(Class<?> elementType) {, +			return expectBody(ResolvableType.forClass(elementType));, +		public ElementBodySpec expectBody(ResolvableType elementType) {, +			return new DefaultElementBodySpec(this, elementType);, +		public ResponseSpec consumeWith(Consumer<ExchangeResult<Flux<DataBuffer>>> consumer) {, +			consumer.accept(getExchangeResult());, +			return this;, +		public ExchangeResult<Flux<DataBuffer>> returnResult() {, +			return getExchangeResult();, +		}, +	private class DefaultBodySpec extends ResponseSpecSupport implements BodySpec {, +, +, +		public DefaultBodySpec(ResponseSpecSupport responseSpec) {, +			super(responseSpec);, +		}, +, +, +		@Override, +		public ExchangeResult<Void> isEmpty() {, +			DataBuffer buffer = getResponse().body(toDataBuffers()).blockFirst(getTimeout());, +			assertTrue("Expected empty body", buffer == null);, +			return createResultWithDecodedBody(null);, +		}, +, +		@Override, +		public MapBodySpec map(Class<?> keyType, Class<?> valueType) {, +			return map(ResolvableType.forClass(keyType), ResolvableType.forClass(valueType));, +		}, +, +		@Override, +		public MapBodySpec map(ResolvableType keyType, ResolvableType valueType) {, +			return new DefaultMapBodySpec(this, keyType, valueType);, +		}, +	}]