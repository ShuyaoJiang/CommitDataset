[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/DefaultRequestPath.java, +/*, + * Copyright 2002-2017 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package org.springframework.http.server.reactive;, +, +import java.net.URI;, +import java.nio.charset.Charset;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +import org.springframework.util.Assert;, +import org.springframework.util.CollectionUtils;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +import org.springframework.util.StringUtils;, +, +/**, + *, + * @author Rossen Stoyanchev, + * @since 5.0, + */, +class DefaultRequestPath implements RequestPath {, +, +	private static final MultiValueMap<String, String> EMPTY_MAP = new LinkedMultiValueMap<>(0);, +, +	private static final PathSegment EMPTY_PATH_SEGMENT = new DefaultPathSegment("", "", "", EMPTY_MAP);, +, +	private static final PathSegmentContainer EMPTY_PATH =, +			new DefaultPathSegmentContainer("", Collections.emptyList());, +, +	private static final PathSegmentContainer ROOT_PATH =, +			new DefaultPathSegmentContainer("/", Collections.singletonList(EMPTY_PATH_SEGMENT));, +, +, +	private final PathSegmentContainer fullPath;, +, +	private final PathSegmentContainer contextPath;, +, +	private final PathSegmentContainer pathWithinApplication;, +, +, +	DefaultRequestPath(URI uri, String contextPath, Charset charset) {, +		this.fullPath = parsePath(uri.getRawPath(), charset);, +		this.contextPath = initContextPath(this.fullPath, contextPath);, +		this.pathWithinApplication = initPathWithinApplication(this.fullPath, this.contextPath);, +	}, +, +, +	private static PathSegmentContainer parsePath(String path, Charset charset) {, +		path = StringUtils.hasText(path) ? path : "";, +		if ("".equals(path)) {, +			return EMPTY_PATH;, +		}, +		if ("/".equals(path)) {, +			return ROOT_PATH;, +		}, +		List<PathSegment> result = new ArrayList<>();, +		int begin = 1;, +		while (true) {, +			int end = path.indexOf('/', begin);, +			String segment = (end != -1 ? path.substring(begin, end) : path.substring(begin));, +			result.add(parsePathSegment(segment, charset));, +			if (end == -1) {, +				break;, +			}, +			begin = end + 1;, +			if (begin == path.length()) {, +				// trailing slash, +				result.add(EMPTY_PATH_SEGMENT);, +				break;, +			}, +		}, +		return new DefaultPathSegmentContainer(path, result);, +	}, +, +	private static PathSegment parsePathSegment(String input, Charset charset) {, +		if ("".equals(input)) {, +			return EMPTY_PATH_SEGMENT;, +		}, +		int index = input.indexOf(';');, +		if (index == -1) {, +			return new DefaultPathSegment(input, StringUtils.uriDecode(input, charset), "", EMPTY_MAP);, +		}, +		String value = input.substring(0, index);, +		String valueDecoded = StringUtils.uriDecode(value, charset);, +		String semicolonContent = input.substring(index);]