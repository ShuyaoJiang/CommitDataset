[+++ b/org.springframework.core/src/main/java/org/springframework/core/env/MutablePropertySources.java, + * Copyright 2002-2011 the original author or authors., +import java.util.Iterator;, +/**, + * Default implementation of the {@link PropertySources} interface., + * Allows manipulation of contained property sources and provides constructor, + * to copying an existing {@code PropertySources} instance., + *, + * <p>Where <em>precedence</em> is mentioned in methods such as {@link #addFirst}, + * and {@link #addLast}, this is with regard to the order in which property sources, + * will be searched when resolving a given property with a {@link PropertyResolver}., + *, + * @author Chris Beams, + * @since 3.1, + * @see PropertySourcesPropertyResolver, + */, +	private final LinkedList<PropertySource<?>> propertySourceList = new LinkedList<PropertySource<?>>();, +, +	/**, +	 * Create a new {@link MutablePropertySources} object., +	 */, +	/**, +	 * Create a new {@code MutablePropertySources} from the given propertySources, +	 * object, preserving the original order of contained {@code PropertySource} objects., +	 */, +		for (PropertySource<?> propertySource : propertySources) {, +	public boolean contains(String name) {, +		return this.propertySourceList.contains(PropertySource.named(name));, +	}, +, +	public PropertySource<?> get(String name) {, +		return this.propertySourceList.get(this.propertySourceList.indexOf(PropertySource.named(name)));, +	}, +, +	public Iterator<PropertySource<?>> iterator() {, +		return this.propertySourceList.iterator();, +	}, +, +	/**, +	 * Add the given property source object with highest precedence., +	 */, +	/**, +	 * Add the given property source object with lowest precedence., +	 */, +	/**, +	 * Add the given property source object with precedence immediately greater, +	 * than the named relative property source., +	 */, +	/**, +	 * Add the given property source object with precedence immediately less than, +	 * than the named relative property source., +	 */, +	/**, +	 * Return the precedence of the given property source, {@code -1} if not found., +	 */, +	public int precedenceOf(PropertySource<?> propertySource) {, +		return this.propertySourceList.indexOf(propertySource);, +	}, +, +	/**, +	 * Remove and return the property source with the given name, {@code null} if not found., +	 * @param name the name of the property source to find and remove, +	 */, +	public PropertySource<?> remove(String name) {, +		int index = this.propertySourceList.indexOf(PropertySource.named(name));, +		if (index >= 0) {, +			return this.propertySourceList.remove(index);, +		}, +		return null;, +	}, +, +	/**, +	 * Replace the property source with the given name with the given property source object., +	 * @param name the name of the property source to find and replace, +	 * @param propertySource the replacement property source, +	 * @throws IllegalArgumentException if no property source with the given name is present, +	 * @see #contains, +	 */, +	public void replace(String name, PropertySource<?> propertySource) {, +		int index = assertPresentAndGetIndex(name);, +		this.propertySourceList.set(index, propertySource);, +	}, +, +	/**, +	 * Return the number of {@link PropertySource} objects contained., +	 */, +	public int size() {, +		return this.propertySourceList.size();, +	}, +, +	/**, +	 * Ensure that the given property source is not being added relative to itself., +	 */, +	/**, +	 * Log the removal of the given propertySource if it is present., +	 */, +			// TODO SPR-7508: add logging, +	/**, +	 * Add the given property source at a particular index in the list., +	 */]