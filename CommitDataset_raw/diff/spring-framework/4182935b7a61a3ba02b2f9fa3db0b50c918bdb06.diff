[+++ b/spring-core/src/main/java/org/springframework/core/codec/StringDecoder.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.util.Assert;, +	private final ConcurrentMap<Charset, List<byte[]>> delimitersCache = new ConcurrentHashMap<>();, +, +	private StringDecoder(List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {, +		Assert.notEmpty(delimiters, "'delimiters' must not be empty");, +		this.delimiters = new ArrayList<>(delimiters);, +		List<byte[]> delimiterBytes = getDelimiterBytes(mimeType);, +	private List<byte[]> getDelimiterBytes(@Nullable MimeType mimeType) {, +		return this.delimitersCache.computeIfAbsent(getCharset(mimeType),, +				charset -> this.delimiters.stream(), +						.map(s -> s.getBytes(charset)), +						.collect(Collectors.toList()));, +	}, +, +		return textPlainOnly(DEFAULT_DELIMITERS, true);, +	 * @param delimiters delimiter strings to use to split the input stream, +	public static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {, +		return allMimeTypes(DEFAULT_DELIMITERS, true);, +	 * @param delimiters delimiter strings to use to split the input stream, +	public static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {, +++ b/spring-core/src/main/java/org/springframework/core/codec/StringDecoder.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import org.springframework.util.Assert;, +	private final ConcurrentMap<Charset, List<byte[]>> delimitersCache = new ConcurrentHashMap<>();, +, +	private StringDecoder(List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {, +		Assert.notEmpty(delimiters, "'delimiters' must not be empty");, +		this.delimiters = new ArrayList<>(delimiters);, +		List<byte[]> delimiterBytes = getDelimiterBytes(mimeType);, +	private List<byte[]> getDelimiterBytes(@Nullable MimeType mimeType) {, +		return this.delimitersCache.computeIfAbsent(getCharset(mimeType),, +				charset -> this.delimiters.stream(), +						.map(s -> s.getBytes(charset)), +						.collect(Collectors.toList()));, +	}, +, +		return textPlainOnly(DEFAULT_DELIMITERS, true);, +	 * @param delimiters delimiter strings to use to split the input stream, +	public static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {, +		return allMimeTypes(DEFAULT_DELIMITERS, true);, +	 * @param delimiters delimiter strings to use to split the input stream, +	public static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {, +++ b/spring-core/src/test/java/org/springframework/core/codec/StringDecoderTests.java, +import java.nio.charset.Charset;, +import org.springframework.util.MimeType;, +import static java.nio.charset.StandardCharsets.UTF_16BE;, +import static java.nio.charset.StandardCharsets.UTF_8;, +		String u = "ü";, +		String e = "é";, +		String o = "ø";, +		String s = String.format("%s\n%s\n%s", u, e, o);, +		Flux<DataBuffer> source = toDataBuffers(s, 1, UTF_8);, +				.expectNext(u, e, o), +	@Test, +	public void decodeMultibyteCharacterUtf16() {, +		String u = "ü";, +		String e = "é";, +		String o = "ø";, +		String s = String.format("%s\n%s\n%s", u, e, o);, +		Flux<DataBuffer> source = toDataBuffers(s, 2, UTF_16BE);, +, +		MimeType mimeType = MimeTypeUtils.parseMimeType("text/plain;charset=utf-16be");, +		Flux<String> output = this.decoder.decode(source, ResolvableType.forClass(String.class),, +				mimeType, Collections.emptyMap());, +		StepVerifier.create(output), +				.expectNext(u, e, o), +				.verifyComplete();, +	}, +, +	private Flux<DataBuffer> toDataBuffers(String s, int length, Charset charset) {, +		byte[] bytes = s.getBytes(charset);, +		for (int i = 0; i < bytes.length; i += length) {, +			DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(length);, +			dataBuffer.write(bytes, i, length);, +			dataBuffers.add(dataBuffer);]