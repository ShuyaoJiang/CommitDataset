[+++ b/spring-context/src/test/groovy/org/springframework/context/groovy/GroovyBeanDefinitionReaderTests.groovy, +, +, +, +, +, +, +, +, +, +, +, +class ScopeTest {, +}, +, +, +, +, +++ b/spring-context/src/test/groovy/org/springframework/context/groovy/GroovyBeanDefinitionReaderTests.groovy, +, +, +, +, +, +, +, +, +, +, +, +class ScopeTest {, +}, +, +, +, +, +++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, + * Copyright 2002-2013 the original author or authors., +public class ConcurrentReferenceHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {, +	/**, +	 * The reference type: SOFT or WEAK., +	 */, +		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);, +		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);, +		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);, +	 * @param concurrencyLevel the expected number of threads that will concurrently, +	 * write to the map, +		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE);, +	 * @param loadFactor the load factor. When the average number of references per, +	 * table exceeds this value, resize will be attempted., +	 * @param concurrencyLevel the expected number of threads that will concurrently, +	 * write to the map, +	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {, +	 * @param loadFactor the load factor. When the average number of references per, +	 * table exceeds this value, resize will be attempted., +	 * @param concurrencyLevel the expected number of threads that will concurrently, +	 * write to the map, +	@SuppressWarnings("unchecked"), +	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,, +			ReferenceType referenceType) {, +, +		this.segments = (Segment[]) Array.newInstance(Segment.class, size);, +		return (entry != null ? entry.getValue() : null);, +		WEAK, +			}, +			finally {, +		private Reference<K, V> findInChain(Reference<K, V> reference, Object key, int hash) {, +, +				Reference<K, V> reference = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);, +				return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());, +		public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {, +	private static final class SoftEntryReference<K, V> extends SoftReference<Entry<K, V>> implements Reference<K, V> {, +		public SoftEntryReference(Entry<K, V> entry, int hash, Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {, +	private static final class WeakEntryReference<K, V> extends WeakReference<Entry<K, V>> implements Reference<K, V> {, +		public WeakEntryReference(Entry<K, V> entry, int hash, Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {, +, +++ b/spring-context/src/test/groovy/org/springframework/context/groovy/GroovyBeanDefinitionReaderTests.groovy, +, +, +, +, +, +, +, +, +, +, +, +class ScopeTest {, +}, +, +, +, +, +++ b/spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java, + * Copyright 2002-2013 the original author or authors., +public class ConcurrentReferenceHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {, +	/**, +	 * The reference type: SOFT or WEAK., +	 */]