[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ComponentScan.java, +		 * The class or classes to use as the filter. In the case of, +		 * {@link FilterType#ANNOTATION}, the class will be the annotation itself. In the, +		 * case of {@link FilterType#ASSIGNABLE_TYPE}, the class will be the type that, +		 * detected components should be assignable to. And in the case of, +		 * {@link FilterType#CUSTOM}, the class will be an implementation of, +		 * {@link TypeFilter}., +		 * <p>When multiple classes are specified, OR logic is applied, e.g. "include, +		 * types annotated with {@code @Foo} OR {@code @Bar}"., +		 * <p>Specifying zero classes is permitted but will have no effect on component, +		 * scanning., +		Class<?>[] value(); //doco, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ComponentScan.java, +		 * The class or classes to use as the filter. In the case of, +		 * {@link FilterType#ANNOTATION}, the class will be the annotation itself. In the, +		 * case of {@link FilterType#ASSIGNABLE_TYPE}, the class will be the type that, +		 * detected components should be assignable to. And in the case of, +		 * {@link FilterType#CUSTOM}, the class will be an implementation of, +		 * {@link TypeFilter}., +		 * <p>When multiple classes are specified, OR logic is applied, e.g. "include, +		 * types annotated with {@code @Foo} OR {@code @Bar}"., +		 * <p>Specifying zero classes is permitted but will have no effect on component, +		 * scanning., +		Class<?>[] value(); //doco, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ComponentScanAnnotationParser.java, +		for (Filter filterAnno : (Filter[])componentScanAttributes.get("includeFilters")) {, +			for (TypeFilter typeFilter : typeFiltersFor(filterAnno)) {, +				scanner.addIncludeFilter(typeFilter);, +		}, +		for (Filter filterAnno : (Filter[])componentScanAttributes.get("excludeFilters")) {, +			for (TypeFilter typeFilter : typeFiltersFor(filterAnno)) {, +				scanner.addExcludeFilter(typeFilter);, +			}, +	private List<TypeFilter> typeFiltersFor(Filter filterAnno) {, +		List<TypeFilter> typeFilters = new ArrayList<TypeFilter>();, +		for (Class<?> filterClass : (Class<?>[])filterAnno.value()) {, +			switch (filterAnno.type()) {, +					Assert.isAssignable(Annotation.class, filterClass,, +							"An error occured when processing a @ComponentScan " +, +							"ANNOTATION type filter: ");, +					Class<Annotation> annoClass = (Class<Annotation>)filterClass;, +					typeFilters.add(new AnnotationTypeFilter(annoClass));, +					break;, +					typeFilters.add(new AssignableTypeFilter(filterClass));, +					break;, +					Assert.isAssignable(TypeFilter.class, filterClass,, +							"An error occured when processing a @ComponentScan " +, +							"CUSTOM type filter: ");, +					typeFilters.add(BeanUtils.instantiateClass(filterClass, TypeFilter.class));, +					break;, +					throw new IllegalArgumentException("unknown filter type " + filterAnno.type());, +		return typeFilters;, +	}, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ComponentScan.java, +		 * The class or classes to use as the filter. In the case of, +		 * {@link FilterType#ANNOTATION}, the class will be the annotation itself. In the, +		 * case of {@link FilterType#ASSIGNABLE_TYPE}, the class will be the type that, +		 * detected components should be assignable to. And in the case of, +		 * {@link FilterType#CUSTOM}, the class will be an implementation of, +		 * {@link TypeFilter}., +		 * <p>When multiple classes are specified, OR logic is applied, e.g. "include, +		 * types annotated with {@code @Foo} OR {@code @Bar}"., +		 * <p>Specifying zero classes is permitted but will have no effect on component, +		 * scanning., +		Class<?>[] value(); //doco, +++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/ComponentScanAnnotationParser.java, +		for (Filter filterAnno : (Filter[])componentScanAttributes.get("includeFilters")) {, +			for (TypeFilter typeFilter : typeFiltersFor(filterAnno)) {, +				scanner.addIncludeFilter(typeFilter);, +		}, +		for (Filter filterAnno : (Filter[])componentScanAttributes.get("excludeFilters")) {, +			for (TypeFilter typeFilter : typeFiltersFor(filterAnno)) {, +				scanner.addExcludeFilter(typeFilter);, +			}, +	private List<TypeFilter> typeFiltersFor(Filter filterAnno) {, +		List<TypeFilter> typeFilters = new ArrayList<TypeFilter>();, +		for (Class<?> filterClass : (Class<?>[])filterAnno.value()) {, +			switch (filterAnno.type()) {, +					Assert.isAssignable(Annotation.class, filterClass,, +							"An error occured when processing a @ComponentScan " +, +							"ANNOTATION type filter: ");, +					Class<Annotation> annoClass = (Class<Annotation>)filterClass;, +					typeFilters.add(new AnnotationTypeFilter(annoClass));, +					break;, +					typeFilters.add(new AssignableTypeFilter(filterClass));, +					break;, +					Assert.isAssignable(TypeFilter.class, filterClass,, +							"An error occured when processing a @ComponentScan " +, +							"CUSTOM type filter: ");, +					typeFilters.add(BeanUtils.instantiateClass(filterClass, TypeFilter.class));, +					break;, +					throw new IllegalArgumentException("unknown filter type " + filterAnno.type());, +		return typeFilters;, +	}, +++ b/org.springframework.context/src/test/java/org/springframework/context/annotation/ComponentScanAnnotationIntegrationTests.java, +import example.scannable.CustomComponent;, +import example.scannable.CustomStereotype;, +import example.scannable.DefaultNamedComponent;, +import example.scannable.MessageBean;, +	public void withMultipleAnnotationIncludeFilters1() throws IOException, ClassNotFoundException {]