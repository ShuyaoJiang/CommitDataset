[+++ b/src/docs/asciidoc/web/webflux-functional.adoc, +Spring WebFlux includes WebFlux.fn, a lightweight functional programming model in which functions, +In WebFlux.fn, an HTTP request is handled with a `HandlerFunction`: a function that takes, +`ServerRequest` and returns a delayed `ServerResponse` (i.e. `Mono<ServerResponse>`)., +Both the request as the response object have immutable contracts that offer JDK 8-friendly, +access to the HTTP request and response., +`HandlerFunction` is the equivalent of the body of a `@RequestMapping` method in the, +annotation-based programming model., +Incoming requests are routed to a handler function with a `RouterFunction`: a function that, +takes `ServerRequest` and returns a delayed `HandlerFunction` (i.e. `Mono<HandlerFunction>`)., +When the router function matches, a handler function is returned; otherwise an empty Mono., +`RouterFunction` is the equivalent of a `@RequestMapping` annotation, but with the major, +difference that router functions provide not just data, but also behavior., +`RouterFunctions.route()` provides a router builder that facilitates the creation of routers,, +RouterFunction<ServerResponse> route = route(), +	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson), +	.GET("/person", accept(APPLICATION_JSON), handler::listPeople), +	.POST("/person", handler::createPerson), +	.build();, +access to the HTTP request and response., +Both request and response provide http://www.reactive-streams.org[Reactive Streams] back pressure, +against the body streams., +The request body is represented with a Reactor `Flux` or `Mono`., +The response body is represented with any Reactive Streams `Publisher`, including `Flux` and `Mono`., +For more on that, see <<web-reactive.adoc#webflux-reactive-libraries,Reactive Libraries>>., +That is convenient, but in an application we need multiple functions, and multiple inline, +lambda's can get messy., +Therefore, it is useful to group related handler functions together into a handler class, which, +has a similar role as  `@Controller` in an annotation-based application., +For example, the following class exposes a reactive `Person` repository:, +Router functions are used to route the requests to the corresponding `HandlerFunction`., +Typically, you do not write router functions yourself, but rather use a method on the, +`RouterFunctions` utility class to create one., +`RouterFunctions.route()` (no parameters) provides you with a fluent builder for creating a router, +function, whereas `RouterFunctions.route(RequestPredicate, HandlerFunction)` offers a direct way, +to create a router., +Generally, it is recommended to use the `route()` builder, as it provides, +convenient short-cuts for typical mapping scenarios without requiring hard-to-discover, +static imports., +For instance, the router function builder offers the method `GET(String, HandlerFunction)` to create a mapping for GET requests; and `POST(String, HandlerFunction)` for POSTs., +, +Besides HTTP method-based mapping, the route builder offers a way to introduce additional, +predicates when mapping to requests., +For each HTTP method there is an overloaded variant that takes a `RequestPredicate` as a, +parameter, though which additional constraints can be expressed., +and so on., +The following example uses a request predicate to create a constraint based on the `Accept`, +header:, +RouterFunction<ServerResponse> route = RouterFunctions.route(), +	.GET("/hello-world", accept(MediaType.TEXT_PLAIN),, +Many of the predicates from `RequestPredicates` are composed., +For example, `RequestPredicates.GET(String)` is composed from `RequestPredicates.method(HttpMethod)`, +The example shown above also uses two request predicates, as the builder uses, +`RequestPredicates.GET` internally, and composes that with the `accept` predicate., +Router functions are evaluated in order: if the first route does not match, the, +second is evaluated, and so on., +Therefore, it makes sense to declare more specific routes before general ones., +Note that this behavior is different from the annotation-based programming model, where the, +"most specific" controller method is picked automatically., +When using the router function builder, all defined routes are composed into one, +`RouterFunction` that is returned from `build()`., +There are also other ways to compose multiple router functions together:, +, +* `add(RouterFunction)` on the `RouterFunctions.route()` builder, +The following example shows the composition of four routes:, +, +RouterFunction<ServerResponse> otherRoute = ..., +, +RouterFunction<ServerResponse> route = route(), +	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) // <1>, +	.GET("/person", accept(APPLICATION_JSON), handler::listPeople) // <2>, +	.POST("/person", handler::createPerson) // <3>, +	.add(otherRoute) // <4>, +	.build();, +<1> `GET /person/{id}` with an `Accept` header that matches JSON is routed to, +`PersonHandler.getPerson`, +<2> `GET /person` with an `Accept` header that matches JSON is routed to, +`PersonHandler.listPeople`, +<3> `POST /person` with no additional predicates is mapped to, +`PersonHandler.createPerson`, and, +<4> `otherRoute` is a router function that is created elsewhere, and added to the route built., +, +=== Nested Routes, +, +It is common for a group of router functions to have a shared predicate, for instance a shared, +path., +In the example above, the shared predicate would be a path predicate that matches `/person`,, +used by three of the routes., +When using annotations, you would remove this duplication by using a type-level `@RequestMapping`, + annotation that maps to `/person`., +In WebFlux.fn, path predicates can be shared through the `path` method on the router function builder., +For instance, the last few lines of the example above can be improved in the following way by using nested routes:, +, +====, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +RouterFunction<ServerResponse> route = route(), +	.path("/person", builder -> builder, +		.GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)]