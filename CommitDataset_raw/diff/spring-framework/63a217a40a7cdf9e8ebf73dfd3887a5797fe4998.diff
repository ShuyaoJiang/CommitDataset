[+++ b/org.springframework.context/src/main/java/org/springframework/cache/config/AnnotationDrivenCacheBeanDefinitionParser.java, +		def.getPropertyValues().add("cacheManager",, +				new RuntimeBeanReference(CacheNamespaceHandler.extractCacheManager(element)));, +				interceptorDef.getPropertyValues().add("cacheOperationSources", new RuntimeBeanReference(sourceName));, +++ b/org.springframework.context/src/main/java/org/springframework/cache/config/AnnotationDrivenCacheBeanDefinitionParser.java, +		def.getPropertyValues().add("cacheManager",, +				new RuntimeBeanReference(CacheNamespaceHandler.extractCacheManager(element)));, +				interceptorDef.getPropertyValues().add("cacheOperationSources", new RuntimeBeanReference(sourceName));, +++ b/org.springframework.context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java, +/*, + * Copyright 2011 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.cache.config;, +, +import java.util.List;, +, +import org.springframework.beans.factory.config.TypedStringValue;, +import org.springframework.beans.factory.parsing.ReaderContext;, +import org.springframework.beans.factory.support.BeanDefinitionBuilder;, +import org.springframework.beans.factory.support.ManagedList;, +import org.springframework.beans.factory.support.ManagedMap;, +import org.springframework.beans.factory.support.RootBeanDefinition;, +import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;, +import org.springframework.beans.factory.xml.ParserContext;, +import org.springframework.cache.annotation.AnnotationCacheOperationSource;, +import org.springframework.cache.interceptor.CacheEvictOperation;, +import org.springframework.cache.interceptor.CacheInterceptor;, +import org.springframework.cache.interceptor.CacheOperation;, +import org.springframework.cache.interceptor.CacheUpdateOperation;, +import org.springframework.cache.interceptor.NameMatchCacheOperationSource;, +import org.springframework.util.StringUtils;, +import org.springframework.util.xml.DomUtils;, +import org.w3c.dom.Element;, +, +/**, + * {@link org.springframework.beans.factory.xml.BeanDefinitionParser, + * BeanDefinitionParser} for the {@code <tx:advice/>} tag., + * , + * @author Costin Leau, + *, + */, +class CacheAdviceParser extends AbstractSingleBeanDefinitionParser {, +, +	/**, +	 * Simple, reusable class used for overriding defaults., +	 * , +	 * @author Costin Leau, +	 */, +	private static class Props {, +, +		private String key, condition;, +		private String[] caches = null;, +, +		Props(Element root) {, +			String defaultCache = root.getAttribute("cache");, +			key = root.getAttribute("key");, +			condition = root.getAttribute("condition");, +, +			if (StringUtils.hasText(defaultCache)) {, +				caches = StringUtils.commaDelimitedListToStringArray(defaultCache.trim());, +			}, +		}, +, +		CacheOperation merge(Element element, ReaderContext readerCtx, CacheOperation op) {, +			String cache = element.getAttribute("cache");, +			String k = element.getAttribute("key");, +			String c = element.getAttribute("condition");, +, +			String[] localCaches = caches;, +			String localKey = key, localCondition = condition;, +, +			// sanity check, +			if (StringUtils.hasText(cache)) {, +				localCaches = StringUtils.commaDelimitedListToStringArray(cache.trim());, +			} else {, +				if (caches == null) {, +					readerCtx.error("No cache specified specified for " + element.getNodeName(), element);, +				}, +			}, +, +			if (StringUtils.hasText(k)) {, +				localKey = k.trim();, +			}, +, +			if (StringUtils.hasText(c)) {, +				localCondition = c.trim();, +			}]