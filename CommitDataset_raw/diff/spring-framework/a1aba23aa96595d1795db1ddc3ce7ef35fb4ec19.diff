[+++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, + * @author Sam Brannen, +	 * <p>Use this constructor when a source or target conversion point is a, +	 * constructor parameter, method parameter, or method return value., +	 * <p>Use this constructor when a source or target conversion point is a field., +	 * <p>Use this constructor when a source or target conversion point is a, +	 * property on a Java class., +	 * <p>Use this to instruct the conversion system to convert an object to a, +	 * specific target type, when no type location such as a method parameter or, +	 * field is available to provide additional conversion context., +	 * <p>Generally prefer use of {@link #forObject(Object)} for constructing type, +	 * descriptors from source objects, as it handles the {@code null} object case., +	 * Create a new type descriptor from a {@link java.util.Collection} type., +	 * <p>Useful for converting to typed Collections., +	 * <p>For example, a {@code List<String>} could be converted to a, +	 * {@code List<EmailAddress>} by converting to a targetType built with this method., +	 * The method call to construct such a {@code TypeDescriptor} would look something, +	 * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}, +	 * @param elementTypeDescriptor a descriptor for the collection's element type,, +	 * used to convert collection elements, +	 * Create a new type descriptor from a {@link java.util.Map} type., +	 * <p>Useful for converting to typed Maps., +	 * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt; by converting to a targetType built with this method:, +	 * Create a new type descriptor as an array of the specified type., +	 * <p>For example to create a {@code Map<String,String>[]} use, +	 * @since 3.2.1, +	 * <p>For example, if the methodParameter is a {@code List<String>} and the, +	 * nesting level is 1, the nested type descriptor will be String.class., +	 * <p>If the methodParameter is a {@code List<List<String>>} and the nesting, +	 * level is 2, the nested type descriptor will also be a String.class., +	 * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting, +	 * level is 1, the nested type descriptor will be String, derived from the map value., +	 * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the, +	 * nesting level is 2, the nested type descriptor will be String, derived from the map value., +	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared., +	 * For example, if the method parameter is a {@code List<?>}, the nested type, +	 * descriptor returned will be {@code null}., +	 * @param nestingLevel the nesting level of the collection/array element or, +	 * map key/value declaration within the method parameter, +	 * @return the nested type descriptor at the specified nesting level, or null, +	 * if it could not be obtained, +	 * @throws IllegalArgumentException if the nesting level of the input, +	 * {@link MethodParameter} argument is not 1, +	 * @throws IllegalArgumentException if the types up to the specified nesting, +	 * level are not of collection, array, or map types, +	 * <p>For example, if the field is a {@code List<String>} and the nesting, +	 * level is 1, the nested type descriptor will be {@code String.class}., +	 * <p>If the field is a {@code List<List<String>>} and the nesting level is, +	 * 2, the nested type descriptor will also be a {@code String.class}., +	 * <p>If the field is a {@code Map<Integer, String>} and the nesting level, +	 * is 1, the nested type descriptor will be String, derived from the map value., +	 * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting, +	 * level is 2, the nested type descriptor will be String, derived from the map value., +	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared., +	 * For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}., +	 * @param nestingLevel the nesting level of the collection/array element or, +	 * map key/value declaration within the field, +	 * @return the nested type descriptor at the specified nesting level, or null, +	 * if it could not be obtained, +	 * @throws IllegalArgumentException if the types up to the specified nesting, +	 * level are not of collection, array, or map types, +	 * <p>For example, if the property is a {@code List<String>} and the nesting, +	 * level is 1, the nested type descriptor will be {@code String.class}., +	 * <p>If the property is a {@code List<List<String>>} and the nesting level, +	 * is 2, the nested type descriptor will also be a {@code String.class}., +	 * <p>If the property is a {@code Map<Integer, String>} and the nesting level, +	 * is 1, the nested type descriptor will be String, derived from the map value., +	 * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting, +	 * level is 2, the nested type descriptor will be String, derived from the map value., +	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared., +	 * For example, if the property is a {@code List<?>}, the nested type descriptor, +	 * returned will be {@code null}., +	 * @param nestingLevel the nesting level of the collection/array element or, +	 * map key/value declaration within the property, +	 * @return the nested type descriptor at the specified nesting level, or, +	 * {@code null} if it could not be obtained, +	 * @throws IllegalArgumentException if the types up to the specified nesting, +	 * level are not of collection, array, or map types, +	 * <p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type., +	 * <p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class., +	 * <p>Returns primitive types as-is., +	 * <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged., +	 * <p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable., +	 * <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element., +	 * <p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned., +	 * <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key., +	 * <p>If this describes a java.util.Map&lt;?, ?&gt; and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * <p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned., +	 * <p>If the Map's value type is not parameterized, returns null indicating the value type is not declared., +	 * <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value., +	 * <p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned.]