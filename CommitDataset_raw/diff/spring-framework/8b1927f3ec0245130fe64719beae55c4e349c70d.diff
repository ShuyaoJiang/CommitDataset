[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = AutowireUtils.resolveReturnTypeForFactoryMethod(, +						factoryMethod, args, getBeanClassLoader());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = AutowireUtils.resolveReturnTypeForFactoryMethod(, +						factoryMethod, args, getBeanClassLoader());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AutowireUtils.java, + * Copyright 2002-2013 the original author or authors., +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.lang.reflect.TypeVariable;, +import org.springframework.util.Assert;, + * @author Sam Brannen, +			Class<?> targetClass = setter.getDeclaringClass();, +			for (Class<?> ifc : interfaces) {, +	public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {, +	/**, +	 * Determine the target type for the generic return type of the given, +	 * <em>generic factory method</em>, where formal type variables are declared, +	 * on the given method itself., +	 * <p>For example, given a factory method with the following signature,, +	 * if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected, +	 * method for {@code creatProxy()} and an {@code Object[]} array containing, +	 * {@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will, +	 * infer that the target return type is {@code MyService}., +	 * <pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>, +	 * <h4>Possible Return Values</h4>, +	 * <ul>, +	 * <li>the target return type, if it can be inferred</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if, +	 * the given {@code method} does not declare any {@linkplain, +	 * Method#getTypeParameters() formal type variables}</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if the, +	 * target return type cannot be inferred (e.g., due to type erasure)</li>, +	 * <li>{@code null}, if the length of the given arguments array is shorter, +	 * than the length of the {@linkplain, +	 * Method#getGenericParameterTypes() formal argument list} for the given, +	 * method</li>, +	 * </ul>, +	 * @param method the method to introspect (never {@code null}), +	 * @param args the arguments that will be supplied to the method when it is, +	 * invoked (never {@code null}), +	 * @param classLoader the ClassLoader to resolve class names against, if necessary, +	 * (never {@code null}), +	 * @return the resolved target return type, the standard return type, or {@code null}, +	 */, +	public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {, +		Assert.notNull(method, "Method must not be null");, +		Assert.notNull(args, "Argument array must not be null");, +, +		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters();, +		Type genericReturnType = method.getGenericReturnType();, +		Type[] methodArgumentTypes = method.getGenericParameterTypes();, +, +		// No declared type variables to inspect, so just return the standard return type., +		if (declaredTypeVariables.length == 0) {, +			return method.getReturnType();, +		}, +, +		// The supplied argument list is too short for the method's signature, so, +		// return null, since such a method invocation would fail., +		if (args.length < methodArgumentTypes.length) {, +			return null;, +		}, +, +		// Ensure that the type variable (e.g., T) is declared directly on the method, +		// itself (e.g., via <T>), not on the enclosing class or interface., +		boolean locallyDeclaredTypeVariableMatchesReturnType = false;, +		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {, +			if (currentTypeVariable.equals(genericReturnType)) {, +				locallyDeclaredTypeVariableMatchesReturnType = true;, +				break;, +			}, +		}, +, +		if (locallyDeclaredTypeVariableMatchesReturnType) {, +			for (int i = 0; i < methodArgumentTypes.length; i++) {, +				Type currentMethodArgumentType = methodArgumentTypes[i];, +				if (currentMethodArgumentType.equals(genericReturnType)) {, +					return args[i].getClass();, +				}, +				if (currentMethodArgumentType instanceof ParameterizedType) {, +					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType;, +					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();, +					for (Type typeArg : actualTypeArguments) {, +						if (typeArg.equals(genericReturnType)) {, +							Object arg = args[i];, +							if (arg instanceof Class) {, +								return (Class<?>) arg;, +							}, +							else if (arg instanceof String) {, +								try {, +									return classLoader.loadClass((String) arg);, +								}, +								catch (ClassNotFoundException ex) {, +									throw new IllegalStateException(, +											"Could not resolve specified class name argument [" + arg + "]", ex);, +								}, +							}, +							else {]