[+++ b/spring-test/src/main/java/org/springframework/test/context/MetaAnnotationUtils.java, + * Copyright 2002-2014 the original author or authors., +import java.util.HashSet;, +import java.util.Set;, + * the standard support already available in {@link AnnotationUtils}., + * <p>Whereas {@code AnnotationUtils} provides utilities for <em>getting</em> or, + * <em>finding</em> an annotation, {@code MetaAnnotationUtils} goes a step further, + * by providing support for determining the <em>root class</em> on which an, + * required by the <em>Spring TestContext Framework</em> in order to be able to, + * support class hierarchy traversals for annotations such as, + * {@link ActiveProfiles @ActiveProfiles} which offer support for merging and, + * overriding various <em>inherited</em> annotation attributes (e.g., {@link, + * ContextConfiguration#inheritLocations})., +	 * on the supplied {@link Class}, traversing its annotations and superclasses, +	 *   <li>Search for the annotation on the given class and return a corresponding, +	 *   {@code AnnotationDescriptor} if found., +	 *   <li>Recursively search through all annotations that the given class declares., +	 *   <li>Recursively search through the superclass hierarchy of the given class., +	 * <p>In this context, the term <em>recursively</em> means that the search, +	 * process continues by returning to step #1 with the current annotation or, +	 * superclass as the class to look for annotations on., +	 *, +	 * @param annotationType the type of annotation to look for, +		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType);, +	}, +, +	/**, +	 * Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},, +	 * avoiding endless recursion by tracking which annotations have already been, +	 * <em>visited</em>., +	 *, +	 * @param clazz the class to look for annotations on, +	 * @param visited the set of annotations that have already been visited, +	 * @param annotationType the type of annotation to look for, +	 * @return the corresponding annotation descriptor if the annotation was found;, +	 * otherwise {@code null}, +	 */, +	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,, +			Set<Annotation> visited, Class<T> annotationType) {, +		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {, +			if (visited.add(composedAnnotation)) {, +				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),, +					visited, annotationType);, +				if (descriptor != null) {, +					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,, +						descriptor.getAnnotation());, +		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType);, +	 * specified {@code annotationTypes}., +	 *   <li>Recursively search through all annotations that the given class declares., +	 *   <li>Recursively search through the superclass hierarchy of the given class., +	 * <p>In this context, the term <em>recursively</em> means that the search, +	 * process continues by returning to step #1 with the current annotation or, +	 * superclass as the class to look for annotations on., +	 *, +	 * @param annotationTypes the types of annotations to look for, +		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes);, +	}, +, +	/**, +	 * Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},, +	 * avoiding endless recursion by tracking which annotations have already been, +	 * <em>visited</em>., +	 *, +	 * @param clazz the class to look for annotations on, +	 * @param visited the set of annotations that have already been visited, +	 * @param annotationTypes the types of annotations to look for, +	 * @return the corresponding annotation descriptor if one of the annotations, +	 * was found; otherwise {@code null}, +	 */, +	@SuppressWarnings("unchecked"), +	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,, +			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {, +		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {, +			if (visited.add(composedAnnotation)) {, +				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(, +					composedAnnotation.annotationType(), visited, annotationTypes);, +				if (descriptor != null) {, +					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,, +						descriptor.getAnnotation());, +		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes);, +			this(rootDeclaringClass, rootDeclaringClass, null, annotation);, +		public AnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass,, +				Annotation composedAnnotation, T annotation) {, +			this.declaringClass = declaringClass;, +		public UntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Annotation annotation) {, +			this(rootDeclaringClass, rootDeclaringClass, null, annotation);, +		public UntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass,, +				Annotation composedAnnotation, Annotation annotation) {, +			super(rootDeclaringClass, declaringClass, composedAnnotation, annotation);, +++ b/spring-test/src/main/java/org/springframework/test/context/MetaAnnotationUtils.java, + * Copyright 2002-2014 the original author or authors., +import java.util.HashSet;, +import java.util.Set;, + * the standard support already available in {@link AnnotationUtils}., + * <p>Whereas {@code AnnotationUtils} provides utilities for <em>getting</em> or, + * <em>finding</em> an annotation, {@code MetaAnnotationUtils} goes a step further, + * by providing support for determining the <em>root class</em> on which an, + * required by the <em>Spring TestContext Framework</em> in order to be able to, + * support class hierarchy traversals for annotations such as, + * {@link ActiveProfiles @ActiveProfiles} which offer support for merging and]