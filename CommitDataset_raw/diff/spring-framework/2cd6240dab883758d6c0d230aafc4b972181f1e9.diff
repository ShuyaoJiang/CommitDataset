[+++ b/spring-web/src/main/java/org/springframework/web/server/adapter/WebHttpHandlerBuilder.java, + * Copyright 2002-2017 the original author or authors., +	private final WebHandler webHandler;, +	private WebHttpHandlerBuilder(WebHandler webHandler) {, +		Assert.notNull(webHandler, "WebHandler must not be null");, +		this.webHandler = webHandler;, +	 * Static factory method to create a new builder instance., +	 * Static factory method to create a new builder instance by detecting beans, +	 * in an {@link ApplicationContext}. The following are detected:, +		// Autowire lists for @Bean + @Order, +		SortedBeanContainer container = new SortedBeanContainer();, +		context.getAutowireCapableBeanFactory().autowireBean(container);, +		builder.filters(container.getFilters());, +		builder.exceptionHandlers(container.getExceptionHandlers());, +	public WebHttpHandlerBuilder filters(List<? extends WebFilter> filters) {, +	 * @param handlers the exception handlers, +	public WebHttpHandlerBuilder exceptionHandlers(List<WebExceptionHandler> handlers) {, +		if (!ObjectUtils.isEmpty(handlers)) {, +			this.exceptionHandlers.addAll(handlers);, +	 * @param manager the session manager, +	public WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {, +		this.sessionManager = manager;, +, +, +		WebHandler decorated;, +, +		decorated = new FilteringWebHandler(this.webHandler, this.filters);, +		decorated = new ExceptionHandlingWebHandler(decorated,  this.exceptionHandlers);, +, +		HttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);, +			adapted.setSessionManager(this.sessionManager);, +, +		return adapted;, +	private static class SortedBeanContainer {, +		private List<WebExceptionHandler> exceptionHandlers;, +, +, +++ b/spring-web/src/main/java/org/springframework/web/server/adapter/WebHttpHandlerBuilder.java, + * Copyright 2002-2017 the original author or authors., +	private final WebHandler webHandler;, +	private WebHttpHandlerBuilder(WebHandler webHandler) {, +		Assert.notNull(webHandler, "WebHandler must not be null");, +		this.webHandler = webHandler;, +	 * Static factory method to create a new builder instance., +	 * Static factory method to create a new builder instance by detecting beans, +	 * in an {@link ApplicationContext}. The following are detected:, +		// Autowire lists for @Bean + @Order, +		SortedBeanContainer container = new SortedBeanContainer();, +		context.getAutowireCapableBeanFactory().autowireBean(container);, +		builder.filters(container.getFilters());, +		builder.exceptionHandlers(container.getExceptionHandlers());, +	public WebHttpHandlerBuilder filters(List<? extends WebFilter> filters) {, +	 * @param handlers the exception handlers, +	public WebHttpHandlerBuilder exceptionHandlers(List<WebExceptionHandler> handlers) {, +		if (!ObjectUtils.isEmpty(handlers)) {, +			this.exceptionHandlers.addAll(handlers);, +	 * @param manager the session manager, +	public WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {, +		this.sessionManager = manager;, +, +, +		WebHandler decorated;, +, +		decorated = new FilteringWebHandler(this.webHandler, this.filters);, +		decorated = new ExceptionHandlingWebHandler(decorated,  this.exceptionHandlers);, +, +		HttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);, +			adapted.setSessionManager(this.sessionManager);, +, +		return adapted;, +	private static class SortedBeanContainer {, +		private List<WebExceptionHandler> exceptionHandlers;, +, +, +++ b/spring-web/src/main/java/org/springframework/web/server/handler/ExceptionHandlingWebHandler.java, + * Copyright 2002-2017 the original author or authors., +import java.util.ArrayList;, + * WebHandler decorator that invokes one or more {@link WebExceptionHandler}s, + * after the delegate {@link WebHandler}., +	 * Dedicated log category for disconnected client exceptions., +	 * <p>Servlet containers do not expose a notification when a client disconnects,, +	 * e.g. <a href="https://java.net/jira/browse/SERVLET_SPEC-44">SERVLET_SPEC-44</a>., +	 * <p>To avoid filling logs with unnecessary stack traces, we make an, +	 * effort to identify such network failures on a per-server basis, and then, +	 * log under a separate log category a simple one-line message at DEBUG level, +	 * or a full stack trace only at TRACE level., +	private static final Set<String> DISCONNECTED_CLIENT_EXCEPTIONS =, +			new HashSet<>(Arrays.asList("ClientAbortException", "EOFException", "EofException"));, +, +	public ExceptionHandlingWebHandler(WebHandler delegate, List<WebExceptionHandler> handlers) {, +		this.exceptionHandlers = initHandlers(handlers);, +	}, +, +	private List<WebExceptionHandler> initHandlers(List<WebExceptionHandler> handlers) {, +		List<WebExceptionHandler> result = new ArrayList<>(handlers);, +		result.add(new UnresolvedExceptionHandler());, +		return Collections.unmodifiableList(result);, +, +		Mono<Void> completion;, +			completion = super.handle(exchange);]