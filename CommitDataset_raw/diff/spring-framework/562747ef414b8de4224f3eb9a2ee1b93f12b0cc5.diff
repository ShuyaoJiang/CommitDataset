[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/resource/DefaultServletHttpRequestHandler.java, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/resource/DefaultServletHttpRequestHandler.java, +++ b/spring-framework-reference/src/beans-dependencies.xml, +          must be compiled with the debug flag enabled so that Spring can, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/resource/DefaultServletHttpRequestHandler.java, +++ b/spring-framework-reference/src/beans-dependencies.xml, +          must be compiled with the debug flag enabled so that Spring can, +++ b/spring-framework-reference/src/mvc.xml, +      <tip>, +        <title>Working with interface-based @Controller classes</title>, +        <para>A common pitfall when working with annotated controller classes, +        happens when applying functionality that requires creating a proxy, +        proxy for the controller object (e.g., +        <interfacename>@Transactional</interfacename> methods). Usually you, +        will introduce an interface for the controller in order to use JDK, +        dynamic proxies. To make this work you must move the, +        <interfacename>@RequestMapping</interfacename> annotations to the, +        interface as as the mapping mechanism can only "see" the interface, +        exposed by the proxy. As an alternative, you may choose to activate, +        <code>proxy-target-class="true"</code> in the configuration for the, +        functionality applied to the controller (in our transaction scenario, +        in <code>&lt;tx:annotation-driven /&gt;</code>). Doing so indicates, +        that CGLIB-based subclass proxies should be used instead of, +        interface-based JDK proxies. For more information on various proxying, +        mechanisms see <xref linkend="aop-proxying"/>.</para>, +      </tip>, +]