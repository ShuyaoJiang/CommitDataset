[+++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		TypeDescriptor desc = getPropertyTypeDescriptor(tokens.canonicalName);, +		Class<?> type = desc.getType();, +		Object defaultValue = newValue(type, desc, tokens.canonicalName);, +	private Object newValue(Class<?> type, TypeDescriptor desc, String name) {, +				TypeDescriptor elementDesc = (desc != null ? desc.getElementTypeDescriptor() : null);, +				return CollectionFactory.createCollection(type, (elementDesc != null ? elementDesc.getType() : null), 16);, +				TypeDescriptor keyDesc = (desc != null ? desc.getMapKeyTypeDescriptor() : null);, +				return CollectionFactory.createMap(type, (keyDesc != null ? keyDesc.getType() : null), 16);, +			// TODO: Root cause exception context is lost here; just exception message preserved., +			// Should we throw another exception type that preserves context instead?, +				Array.set(newArray, i, newValue(componentType, null, name));, +					collection.add(newValue(elementType, null, name));, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		TypeDescriptor desc = getPropertyTypeDescriptor(tokens.canonicalName);, +		Class<?> type = desc.getType();, +		Object defaultValue = newValue(type, desc, tokens.canonicalName);, +	private Object newValue(Class<?> type, TypeDescriptor desc, String name) {, +				TypeDescriptor elementDesc = (desc != null ? desc.getElementTypeDescriptor() : null);, +				return CollectionFactory.createCollection(type, (elementDesc != null ? elementDesc.getType() : null), 16);, +				TypeDescriptor keyDesc = (desc != null ? desc.getMapKeyTypeDescriptor() : null);, +				return CollectionFactory.createMap(type, (keyDesc != null ? keyDesc.getType() : null), 16);, +			// TODO: Root cause exception context is lost here; just exception message preserved., +			// Should we throw another exception type that preserves context instead?, +				Array.set(newArray, i, newValue(componentType, null, name));, +					collection.add(newValue(elementType, null, name));, +++ b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperEnumTests.java, + * Copyright 2002-2014 the original author or authors., +import java.util.LinkedHashMap;, +import java.util.Map;, +, +import org.springframework.core.convert.support.DefaultConversionService;, +	@Test, +	public void testStandardEnumSetWithMultipleValues() {, +		GenericBean<?> gb = new GenericBean<Object>();, +		BeanWrapper bw = new BeanWrapperImpl(gb);, +		bw.setConversionService(new DefaultConversionService());, +		assertNull(gb.getStandardEnumSet());, +		bw.setPropertyValue("standardEnumSet", new String[] {"VALUE_1", "VALUE_2"});, +		assertEquals(2, gb.getStandardEnumSet().size());, +		assertTrue(gb.getStandardEnumSet().contains(CustomEnum.VALUE_1));, +		assertTrue(gb.getStandardEnumSet().contains(CustomEnum.VALUE_2));, +	}, +, +	@Test, +	public void testStandardEnumSetWithAutoGrowing() {, +		GenericBean<?> gb = new GenericBean<Object>();, +		BeanWrapper bw = new BeanWrapperImpl(gb);, +		bw.setAutoGrowNestedPaths(true);, +		assertNull(gb.getStandardEnumSet());, +		bw.getPropertyValue("standardEnumSet.class");, +		assertEquals(0, gb.getStandardEnumSet().size());, +	}, +, +	@Test, +	public void testStandardEnumMapWithMultipleValues() {, +		GenericBean<?> gb = new GenericBean<Object>();, +		BeanWrapper bw = new BeanWrapperImpl(gb);, +		bw.setConversionService(new DefaultConversionService());, +		assertNull(gb.getStandardEnumMap());, +		Map<String, Integer> map = new LinkedHashMap<String, Integer>();, +		map.put("VALUE_1", 1);, +		map.put("VALUE_2", 2);, +		bw.setPropertyValue("standardEnumMap", map);, +		assertEquals(2, gb.getStandardEnumMap().size());, +		assertEquals(new Integer(1), gb.getStandardEnumMap().get(CustomEnum.VALUE_1));, +		assertEquals(new Integer(2), gb.getStandardEnumMap().get(CustomEnum.VALUE_2));, +	}, +, +	@Test, +	public void testStandardEnumMapWithAutoGrowing() {, +		GenericBean<?> gb = new GenericBean<Object>();, +		BeanWrapper bw = new BeanWrapperImpl(gb);, +		bw.setAutoGrowNestedPaths(true);, +		assertNull(gb.getStandardEnumMap());, +		bw.setPropertyValue("standardEnumMap[VALUE_1]", 1);, +		assertEquals(1, gb.getStandardEnumMap().size());, +		assertEquals(new Integer(1), gb.getStandardEnumMap().get(CustomEnum.VALUE_1));, +	}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		TypeDescriptor desc = getPropertyTypeDescriptor(tokens.canonicalName);, +		Class<?> type = desc.getType();, +		Object defaultValue = newValue(type, desc, tokens.canonicalName);, +	private Object newValue(Class<?> type, TypeDescriptor desc, String name) {, +				TypeDescriptor elementDesc = (desc != null ? desc.getElementTypeDescriptor() : null);, +				return CollectionFactory.createCollection(type, (elementDesc != null ? elementDesc.getType() : null), 16);, +				TypeDescriptor keyDesc = (desc != null ? desc.getMapKeyTypeDescriptor() : null);, +				return CollectionFactory.createMap(type, (keyDesc != null ? keyDesc.getType() : null), 16);, +			// TODO: Root cause exception context is lost here; just exception message preserved., +			// Should we throw another exception type that preserves context instead?, +				Array.set(newArray, i, newValue(componentType, null, name));, +					collection.add(newValue(elementType, null, name));, +++ b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperEnumTests.java, + * Copyright 2002-2014 the original author or authors., +import java.util.LinkedHashMap;, +import java.util.Map;, +, +import org.springframework.core.convert.support.DefaultConversionService;, +	@Test]