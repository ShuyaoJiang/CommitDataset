[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +			// The config class is annotated with @ComponentScan -> perform the scan immediately, +			// Check the set of scanned definitions for any further config classes and parse recursively if necessary, +		// No superclass -> processing is complete, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +			// The config class is annotated with @ComponentScan -> perform the scan immediately, +			// Check the set of scanned definitions for any further config classes and parse recursively if necessary, +		// No superclass -> processing is complete, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +		return get(ID, UUID.class);, +		return get(TIMESTAMP, Long.class);, +		return get(REPLY_CHANNEL);, +		return get(ERROR_CHANNEL);, +	// Delegating Map implementation, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +			// The config class is annotated with @ComponentScan -> perform the scan immediately, +			// Check the set of scanned definitions for any further config classes and parse recursively if necessary, +		// No superclass -> processing is complete, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +		return get(ID, UUID.class);, +		return get(TIMESTAMP, Long.class);, +		return get(REPLY_CHANNEL);, +		return get(ERROR_CHANNEL);, +	// Delegating Map implementation, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/GenericMessage.java, +		Assert.notNull(payload, "Payload must not be null");, +		Assert.notNull(headers, "MessageHeaders must not be null");, +	public boolean equals(Object other) {, +		if (this == other) {, +		if (!(other instanceof GenericMessage)) {, +		GenericMessage<?> otherMessage = (GenericMessage<?>) other;, +		return (this.payload.equals(otherMessage.payload) && this.headers.equals(otherMessage.headers));, +	}, +		return (this.payload.hashCode() * 23 + this.headers.hashCode());, +		sb.append(" [payload=");, +			sb.append("byte[").append(((byte[]) this.payload).length).append("]");, +			sb.append(this.payload);, +		sb.append(", headers=").append(this.headers).append("]");, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {, +			// The config class is annotated with @ComponentScan -> perform the scan immediately, +			// Check the set of scanned definitions for any further config classes and parse recursively if necessary, +		// No superclass -> processing is complete, +++ b/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java, +		return get(ID, UUID.class);, +		return get(TIMESTAMP, Long.class);, +		return get(REPLY_CHANNEL);, +		return get(ERROR_CHANNEL);, +	// Delegating Map implementation, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/GenericMessage.java, +		Assert.notNull(payload, "Payload must not be null");, +		Assert.notNull(headers, "MessageHeaders must not be null");, +	public boolean equals(Object other) {, +		if (this == other) {, +		if (!(other instanceof GenericMessage)) {, +		GenericMessage<?> otherMessage = (GenericMessage<?>) other;, +		return (this.payload.equals(otherMessage.payload) && this.headers.equals(otherMessage.headers));, +	}, +		return (this.payload.hashCode() * 23 + this.headers.hashCode());, +		sb.append(" [payload=");, +			sb.append("byte[").append(((byte[]) this.payload).length).append("]");, +			sb.append(this.payload);, +		sb.append(", headers=").append(this.headers).append("]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/MessageHeaderAccessor.java]