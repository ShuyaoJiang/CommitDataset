[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestPartMethodArgumentResolver.java, +		Flux<Part> parts = exchange.getMultipartData(), +					List<Part> list = map.get(name);, +					if (CollectionUtils.isEmpty(list)) {, +					return Flux.fromIterable(list);, +		if (Part.class.isAssignableFrom(parameter.getParameterType())) {, +			return parts.next().cast(Object.class);, +		}, +		if (List.class.isAssignableFrom(parameter.getParameterType())) {, +			MethodParameter elementType = parameter.nested();, +				return parts.collectList().cast(Object.class);, +				return decodePartValues(parts, elementType, bindingContext, exchange, isRequired), +						.collectList().cast(Object.class);, +		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType());, +		if (adapter != null) {, +			// Mono<Part> or Flux<Part>, +			MethodParameter elementType = parameter.nested();, +			if (Part.class.isAssignableFrom(elementType.getNestedParameterType())) {, +				parts = adapter.isMultiValue() ? parts : parts.take(1);, +				return Mono.just(adapter.fromPublisher(parts));, +			}, +			// We have to decode the content for each part, one at a time, +			if (adapter.isMultiValue()) {, +				return Mono.just(decodePartValues(parts, elementType, bindingContext, exchange, isRequired));, +			}, +		}, +, +		// <T> or Mono<T>, +		return decodePartValues(parts, parameter, bindingContext, exchange, isRequired), +				.next().cast(Object.class);, +	private Flux<?> decodePartValues(Flux<Part> parts, MethodParameter elementType, BindingContext bindingContext,, +			ServerWebExchange exchange, boolean isRequired) {, +, +		return parts.flatMap(part -> {, +			ServerHttpRequest partRequest = new PartServerHttpRequest(exchange.getRequest(), part);, +			ServerWebExchange partExchange = exchange.mutate().request(partRequest).build();, +			return readBody(elementType, isRequired, bindingContext, partExchange);, +		});, +	}, +, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestPartMethodArgumentResolver.java, +		Flux<Part> parts = exchange.getMultipartData(), +					List<Part> list = map.get(name);, +					if (CollectionUtils.isEmpty(list)) {, +					return Flux.fromIterable(list);, +		if (Part.class.isAssignableFrom(parameter.getParameterType())) {, +			return parts.next().cast(Object.class);, +		}, +		if (List.class.isAssignableFrom(parameter.getParameterType())) {, +			MethodParameter elementType = parameter.nested();, +				return parts.collectList().cast(Object.class);, +				return decodePartValues(parts, elementType, bindingContext, exchange, isRequired), +						.collectList().cast(Object.class);, +		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType());, +		if (adapter != null) {, +			// Mono<Part> or Flux<Part>, +			MethodParameter elementType = parameter.nested();, +			if (Part.class.isAssignableFrom(elementType.getNestedParameterType())) {, +				parts = adapter.isMultiValue() ? parts : parts.take(1);, +				return Mono.just(adapter.fromPublisher(parts));, +			}, +			// We have to decode the content for each part, one at a time, +			if (adapter.isMultiValue()) {, +				return Mono.just(decodePartValues(parts, elementType, bindingContext, exchange, isRequired));, +			}, +		}, +, +		// <T> or Mono<T>, +		return decodePartValues(parts, parameter, bindingContext, exchange, isRequired), +				.next().cast(Object.class);, +	private Flux<?> decodePartValues(Flux<Part> parts, MethodParameter elementType, BindingContext bindingContext,, +			ServerWebExchange exchange, boolean isRequired) {, +, +		return parts.flatMap(part -> {, +			ServerHttpRequest partRequest = new PartServerHttpRequest(exchange.getRequest(), part);, +			ServerWebExchange partExchange = exchange.mutate().request(partRequest).build();, +			return readBody(elementType, isRequired, bindingContext, partExchange);, +		});, +	}, +, +, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/RequestPartMethodArgumentResolverTests.java, +/*, + * Copyright 2002-2018 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.web.reactive.result.method.annotation;]