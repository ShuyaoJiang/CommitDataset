[+++ b/spring-core/src/main/java/org/springframework/core/convert/converter/ConditionalGenericConverter.java, + * Copyright 2002-2014 the original author or authors., + * A {@link GenericConverter} that may conditionally execute based on attributes, + * of the {@code source} and {@code target} {@link TypeDescriptor}., + * See {@link ConditionalConverter} for details., +public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {, +++ b/spring-core/src/main/java/org/springframework/core/convert/converter/ConditionalGenericConverter.java, + * Copyright 2002-2014 the original author or authors., + * A {@link GenericConverter} that may conditionally execute based on attributes, + * of the {@code source} and {@code target} {@link TypeDescriptor}., + * See {@link ConditionalConverter} for details., +public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java, +			// Check raw type first..., +			if (!this.typeInfo.getTargetType().equals(targetType.getObjectType())) {, +			// Full check for complex generic type match required?, +			ResolvableType rt = targetType.getResolvableType();, +			if (!(rt.getType() instanceof Class) && !rt.isAssignableFrom(this.targetType) &&, +					!this.targetType.hasUnresolvableGenerics()) {, +				return false;, +			return !(this.converter instanceof ConditionalConverter) ||, +					((ConditionalConverter) this.converter).matches(sourceType, targetType);, +++ b/spring-core/src/main/java/org/springframework/core/convert/converter/ConditionalGenericConverter.java, + * Copyright 2002-2014 the original author or authors., + * A {@link GenericConverter} that may conditionally execute based on attributes, + * of the {@code source} and {@code target} {@link TypeDescriptor}., + * See {@link ConditionalConverter} for details., +public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java, +			// Check raw type first..., +			if (!this.typeInfo.getTargetType().equals(targetType.getObjectType())) {, +			// Full check for complex generic type match required?, +			ResolvableType rt = targetType.getResolvableType();, +			if (!(rt.getType() instanceof Class) && !rt.isAssignableFrom(this.targetType) &&, +					!this.targetType.hasUnresolvableGenerics()) {, +				return false;, +			return !(this.converter instanceof ConditionalConverter) ||, +					((ConditionalConverter) this.converter).matches(sourceType, targetType);, +++ b/spring-core/src/test/java/org/springframework/core/convert/support/GenericConversionServiceTests.java, +		conversionService.addConverter(new MyStringToRawCollectionConverter());, +		conversionService.addConverter(new MyStringToGenericCollectionConverter());, +, +, +, +		try {, +			conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("integerCollection")));, +			fail("Should have thrown ConverterNotFoundException");, +		}, +		catch (ConverterNotFoundException ex) {, +			// expected, +		}, +	}, +, +	@Test, +	public void genericCollectionAsSource() throws Exception {, +		conversionService.addConverter(new MyStringToGenericCollectionConverter());, +, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("stringCollection"))));, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("genericCollection"))));, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("rawCollection"))));, +, +		// The following is unpleasant but a consequence of the generic collection converter above..., +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("integerCollection"))));, +	}, +, +	@Test, +	public void rawCollectionAsSource() throws Exception {, +		conversionService.addConverter(new MyStringToRawCollectionConverter());, +, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("stringCollection"))));, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("genericCollection"))));, +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("rawCollection"))));, +, +		// The following is unpleasant but a consequence of the raw collection converter above..., +		assertEquals(Collections.singleton("testX"),, +				conversionService.convert("test", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField("integerCollection"))));, +, +, +	private static class MyConditionalGenericConverter implements GenericConverter, ConditionalConverter {, +, +	private static class MyConditionalConverterFactory implements ConverterFactory<String, Color>, ConditionalConverter {, +, +, +	public static class MyStringToRawCollectionConverter implements Converter<String, Collection> {, +, +		@Override, +		public Collection convert(String source) {, +			return Collections.singleton(source + "X");, +		}, +	}, +, +	public static class MyStringToGenericCollectionConverter implements Converter<String, Collection<?>> {, +]