[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +			Class<?> beanType = predictBeanType(beanName, mbd, typesToMatch);, +			if (beanType == null) {, +			if (FactoryBean.class.isAssignableFrom(beanType)) {, +					beanType = getTypeForFactoryBean(beanName, mbd);, +					if (beanType == null) {, +						return false;, +			else if (BeanFactoryUtils.isFactoryDereference(name)) {, +				// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean, +				// type but we nevertheless are being asked to dereference a FactoryBean..., +				// Let's check the original bean class and proceed with it if it is a FactoryBean., +				beanType = predictBeanType(beanName, mbd, FactoryBean.class);, +				if (beanType == null || !FactoryBean.class.isAssignableFrom(beanType)) {, +					return false;, +				}, +			}, +, +			return typeToMatch.isAssignableFrom(beanType);, +		Class<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);, +		return (beanType != null && FactoryBean.class.isAssignableFrom(beanType));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +			Class<?> beanType = predictBeanType(beanName, mbd, typesToMatch);, +			if (beanType == null) {, +			if (FactoryBean.class.isAssignableFrom(beanType)) {, +					beanType = getTypeForFactoryBean(beanName, mbd);, +					if (beanType == null) {, +						return false;, +			else if (BeanFactoryUtils.isFactoryDereference(name)) {, +				// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean, +				// type but we nevertheless are being asked to dereference a FactoryBean..., +				// Let's check the original bean class and proceed with it if it is a FactoryBean., +				beanType = predictBeanType(beanName, mbd, FactoryBean.class);, +				if (beanType == null || !FactoryBean.class.isAssignableFrom(beanType)) {, +					return false;, +				}, +			}, +, +			return typeToMatch.isAssignableFrom(beanType);, +		Class<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);, +		return (beanType != null && FactoryBean.class.isAssignableFrom(beanType));, +++ b/spring-beans/src/test/java/org/springframework/beans/factory/support/Spr8954Tests.java, +import java.util.Arrays;, +import org.junit.Before;, +import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;, +, +import static org.hamcrest.CoreMatchers.*;, +import static org.junit.Assert.*;, + * {@link AbstractBeanFactory#isFactoryBean(String, RootBeanDefinition)} now ensures that, + * not only the predicted bean type is considered, but also the original bean definition's, + * beanClass., +	private DefaultListableBeanFactory bf;, +, +	@Before, +	public void setUp() {, +		bf = new DefaultListableBeanFactory();, +	}, +	@Test, +	public void repro() {, +		assertThat(fbBeans.size(), is(1));, +		assertThat(fbBeans.keySet(), hasItem("&foo"));, +		assertThat(aiBeans.size(), is(1));, +		assertThat(aiBeans.keySet(), hasItem("&foo"));, +		assertThat(aiBeans.size(), is(1));, +		assertThat(aiBeans.keySet(), hasItem("&foo"));, +	}, +, +	/**, +	 * SPR-10517, +	 */, +	@Test, +	public void findsFactoryBeanNameByTypeWithoutInstantiation() {, +		String[] names = bf.getBeanNamesForType(AnInterface.class, false, false);, +		assertThat(Arrays.asList(names), hasItem("&foo"));, +, +		Map<String, AnInterface> beans = bf.getBeansOfType(AnInterface.class, false, false);, +		assertThat(beans.size(), is(1));, +		assertThat(beans.keySet(), hasItem("&foo"));, +			return FactoryBean.class.isAssignableFrom(beanClass) ? PredictedType.class : null;]