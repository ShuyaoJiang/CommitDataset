[+++ /dev/null, +++ /dev/null, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java, + * Copyright 2004-2008 the original author or authors., + * TODO auto-conversion of generic collection elements, +	 * An indexed map of SuperConverters. Each Map.Entry key is a source class (S) that can be converted from. Each, +	 * Map.Entry value is a Map that defines the targetClass-to-SuperConverter mappings for that source., +	 * A map of custom converters. Custom converters are assigned a unique identifier that can be used to lookup the, +	 * converter. This allows multiple converters for the same source->target class to be registered., +	 */, +	private final Map customConverters = new HashMap();, +, +	/**, +		List typeInfo = getRequiredTypeInfo(converter);, +		List typeInfo = getRequiredTypeInfo(converter);, +	 * Register the converter as a custom converter with this conversion service., +	 * @param id the id to assign the converter, +	 * @param converter the converter to use a custom converter, +	 */, +	public void addConverter(String id, Converter converter) {, +		customConverters.put(id, converter);, +	}, +, +	/**, +	 * Adapts a {@link SuperTwoWayConverter} that converts between BS and BT class hierarchies to a {@link Converter}, +	 * that converts between the specific BS/BT sub types S and T., +	 * , +	 * TODO - I think this is going to force indexing on a getSourceClass/getTargetclass prop instead generic args, +	 * , +	 * @param sourceClass the source class S to convert from, which must be equal or extend BS, +	 * @param targetClass the target type T to convert to, which must equal or extend BT, +	 * @param converter the super two way converter, +	 * @return a converter that converts from S to T by delegating to the super converter, +	 */, +	public static <S, T> Converter<S, T> converterFor(Class<S> sourceClass, Class<T> targetClass,, +			SuperTwoWayConverter converter) {, +		return new SuperTwoWayConverterConverter<S, T>(converter, sourceClass, targetClass);, +	}, +, +	/**, +	// implementing ConversionService, +, +		return getConversionExecutor(source.getClass(), targetClass).execute(source);, +		return getConversionExecutor(converterId, source.getClass(), targetClass).execute(source);, +	public ConversionExecutor getConversionExecutor(String id, Class sourceClass, Class targetClass), +		Assert.hasText(id, "The id of the custom converter is required");, +		Assert.notNull(sourceClass, "The source class to convert from is required");, +		Assert.notNull(targetClass, "The target class to convert to is required");, +		Converter converter = (Converter) customConverters.get(id);, +		if (converter == null) {, +			if (parent != null) {, +				return parent.getConversionExecutor(id, sourceClass, targetClass);, +			} else {, +				throw new ConversionExecutorNotFoundException(sourceClass, targetClass,, +						"No custom Converter found with id '" + id + "' for converting from sourceClass [", +								+ sourceClass.getName() + "] to targetClass [" + targetClass.getName() + "]");, +			}, +		}, +		sourceClass = convertToWrapperClassIfNecessary(sourceClass);, +		targetClass = convertToWrapperClassIfNecessary(targetClass);, +		// TODO Not optimal getting this each time, +		List typeInfo = getRequiredTypeInfo(converter);, +		Class converterSourceClass = (Class) typeInfo.get(0);, +		Class converterTargetClass = (Class) typeInfo.get(1);, +		if (sourceClass.isArray()) {, +			Class sourceComponentType = sourceClass.getComponentType();, +			if (targetClass.isArray()) {, +				Class targetComponentType = targetClass.getComponentType();, +				if (converterSourceClass.isAssignableFrom(sourceComponentType)) {, +					if (!converterTargetClass.equals(targetComponentType)) {, +						throw new ConversionExecutorNotFoundException(sourceClass, targetClass,, +								"Custom Converter with id '" + id, +										+ "' cannot convert from an array storing elements of type [", +										+ sourceComponentType.getName() + "] to an array of storing elements of type [", +										+ targetComponentType.getName() + "]");, +					}, +					ConversionExecutor elementConverter = new StaticConversionExecutor(sourceComponentType,, +							targetComponentType, converter);, +					return new StaticSuperConversionExecutor(sourceClass, targetClass, new ArrayToArray(, +							elementConverter));, +				} else if (converterTargetClass.isAssignableFrom(sourceComponentType)) {, +					if (!converterSourceClass.equals(targetComponentType)) {, +						throw new ConversionExecutorNotFoundException(sourceClass, targetClass,, +								"Custom Converter with id '" + id, +										+ "' cannot convert from an array storing elements of type [", +										+ sourceComponentType.getName() + "] to an array of storing elements of type [", +										+ targetComponentType.getName() + "]");, +					}, +					ConversionExecutor elementConverter = new StaticConversionExecutor(sourceComponentType,, +							targetComponentType, new ReverseConverter(converter));, +					return new StaticSuperConversionExecutor(sourceClass, targetClass, new ArrayToArray(, +							elementConverter));, +				} else {, +					throw new ConversionExecutorNotFoundException(sourceClass, targetClass,, +							"Custom Converter with id '" + id, +									+ "' cannot convert from an array storing elements of type [", +									+ sourceComponentType.getName() + "] to an array storing elements of type [", +									+ targetComponentType.getName() + "]");, +				}, +			} else if (Collection.class.isAssignableFrom(targetClass)) {]