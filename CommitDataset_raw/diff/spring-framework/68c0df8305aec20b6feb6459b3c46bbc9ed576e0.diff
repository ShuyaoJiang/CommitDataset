[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.util.concurrent.atomic.AtomicReference;, + * A {@link MessageHandler} that handles messages by forwarding them to a STOMP broker and, + * reversely sends any returned messages from the broker to the provided, + * {@link MessageChannel}., + *, +, +, +, +			if (logger.isDebugEnabled()) {, +				logger.debug("Initializing \"system\" TCP connection");, +			}, +			SystemRelaySession session = new SystemRelaySession();, +			this.relaySessions.put(session.getId(), session);, +			session.connect();, +, +			sessionId = (sessionId == null) ? SystemRelaySession.ID : sessionId;, +					headers.setHeartbeat(0, 0);, +					session.connect(message);, +	private void publishBrokerAvailableEvent() {, +	private void publishBrokerUnavailableEvent() {, +		private volatile StompConnection stompConnection = new StompConnection();, +		public String getId() {, +			return this.sessionId;, +		}, +		public void connect(final Message<?> connectMessage) {, +			Assert.notNull(connectMessage, "connectMessage is required");, +, +			Composable<TcpConnection<String, String>> connectionComposable = openTcpConnection();, +				public void accept(TcpConnection<String, String> connection) {, +					handleTcpConnection(connection, connectMessage);, +					handleTcpClientFailure("Failed to connect to message broker", ex);, +		protected Composable<TcpConnection<String, String>> openTcpConnection() {, +		protected void handleTcpConnection(TcpConnection<String, String> tcpConn, final Message<?> connectMessage) {, +			this.stompConnection.setTcpConnection(tcpConn);, +			tcpConn.in().consume(new Consumer<String>() {, +				@Override, +				public void accept(String message) {, +					readStompFrame(message);, +				}, +			});, +			forwardInternal(tcpConn, connectMessage);, +		}, +, +					this.stompConnection.setReady();, +					publishBrokerAvailableEvent();, +		private void handleTcpClientFailure(String message, Throwable ex) {, +			if (logger.isErrorEnabled()) {, +				logger.error(message + ", sessionId=" + this.sessionId, ex);, +			}, +			this.stompConnection.setDisconnected();, +			sendError(message);, +			publishBrokerUnavailableEvent();, +		private void sendError(String errorText) {, +			headers.setSessionId(this.sessionId);, +		protected void sendMessageToClient(Message<?> message) {, +			messageChannel.send(message);, +			if (!this.stompConnection.isReady()) {, +					if (!this.stompConnection.isReady()) {, +			TcpConnection<String, String> tcpConnection = this.stompConnection.getReadyConnection();, +			if (tcpConnection == null) {, +			return forwardInternal(tcpConnection, message);, +		}, +, +		private boolean forwardInternal(TcpConnection<String, String> tcpConnection, final Message<?> message) {, +			tcpConnection.send(payload, new Consumer<Boolean>() {, +					handleTcpClientFailure("Timed out waiting for message to be forwarded to the broker", null);, +						handleTcpClientFailure("Failed to forward message to the broker", null);, +			catch (InterruptedException ex) {, +				handleTcpClientFailure("Interrupted while forwarding message to the broker", ex);, +, +	private static class StompConnection {, +, +		private volatile TcpConnection<String, String> connection;, +, +		private AtomicReference<TcpConnection<String, String>> readyConnection =, +				new AtomicReference<TcpConnection<String, String>>();, +, +, +		public void setTcpConnection(TcpConnection<String, String> connection) {, +			Assert.notNull(connection, "connection must not be null");, +			this.connection = connection;, +		}, +, +		public TcpConnection<String, String> getReadyConnection() {, +			return this.readyConnection.get();, +		}, +, +		public void setReady() {, +			this.readyConnection.set(this.connection);, +		}, +, +		public boolean isReady() {, +			return (this.readyConnection.get() != null);, +		}, +, +		public void setDisconnected() {, +			this.readyConnection.set(null);, +			this.connection = null;, +		}]