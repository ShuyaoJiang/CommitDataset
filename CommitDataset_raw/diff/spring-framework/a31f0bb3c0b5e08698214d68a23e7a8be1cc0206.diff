[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/OperatorInstanceof.java, + * Copyright 2002-2016 the original author or authors., +		SpelNodeImpl rightOperand = getRightOperand();, +		TypedValue right = rightOperand.getValueInternal(state);, +		if (rightOperand instanceof TypeReference) {, +			// Can only generate bytecode where the right operand is a direct type reference, , +			// not if it is indirect (for example when right operand is a variable reference), +		}, +		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor());, +		if (this.type.isPrimitive()) {, +			// always false - but left operand code always driven, +			// in case it had side effects, +			mv.visitInsn(POP);, +			mv.visitInsn(ICONST_0); // value of false, +		} , +		else {, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/OperatorInstanceof.java, + * Copyright 2002-2016 the original author or authors., +		SpelNodeImpl rightOperand = getRightOperand();, +		TypedValue right = rightOperand.getValueInternal(state);, +		if (rightOperand instanceof TypeReference) {, +			// Can only generate bytecode where the right operand is a direct type reference, , +			// not if it is indirect (for example when right operand is a variable reference), +		}, +		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor());, +		if (this.type.isPrimitive()) {, +			// always false - but left operand code always driven, +			// in case it had side effects, +			mv.visitInsn(POP);, +			mv.visitInsn(ICONST_0); // value of false, +		} , +		else {, +		}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java, + * Copyright 2002-2016 the original author or authors., +	public void operatorInstanceOf_SPR14250() throws Exception {, +		// primitive left operand - should get boxed, return true, +		expression = parse("3 instanceof T(Integer)");, +		assertEquals(true,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(true,expression.getValue());, +, +		// primitive left operand - should get boxed, return false, +		expression = parse("3 instanceof T(String)");, +		assertEquals(false,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(false,expression.getValue());, +		, +		// double slot left operand - should get boxed, return false, +		expression = parse("3.0d instanceof T(Integer)");, +		assertEquals(false,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(false,expression.getValue());, +, +		// double slot left operand - should get boxed, return true, +		expression = parse("3.0d instanceof T(Double)");, +		assertEquals(true,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(true,expression.getValue());, +		, +		// Only when the right hand operand is a direct type reference, +		// will it be compilable., +		StandardEvaluationContext ctx = new StandardEvaluationContext();, +		ctx.setVariable("foo", String.class);, +		expression = parse("3 instanceof #foo");, +		assertEquals(false,expression.getValue(ctx));, +		assertCantCompile(expression);, +, +		// use of primitive as type for instanceof check - compilable, +		// but always false, +		expression = parse("3 instanceof T(int)");, +		assertEquals(false,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(false,expression.getValue());, +		, +		expression = parse("3 instanceof T(long)");, +		assertEquals(false,expression.getValue());, +		assertCanCompile(expression);, +		assertEquals(false,expression.getValue());, +	}, +	, +	@Test]