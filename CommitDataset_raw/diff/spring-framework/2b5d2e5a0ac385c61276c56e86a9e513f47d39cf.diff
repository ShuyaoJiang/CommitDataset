[+++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, +	 * Resolve the {@link ContextLoader} {@link Class class} to use for the, +	 * supplied {@link Class testClass} and then instantiate and return that, +	 * {@code ContextLoader}., +	 * <p>If the supplied <code>defaultContextLoaderClassName</code> is, +	 * <code>null</code> or <em>empty</em>, the <em>standard</em>, +	 * default context loader class name {@value #DEFAULT_CONTEXT_LOADER_CLASS_NAME}, +	 * will be used. For details on the class resolution process, see, +	 * {@link #resolveContextLoaderClass()}., +	 * @param testClass the test class for which the {@code ContextLoader}, +	 * should be resolved (must not be <code>null</code>), +	 * @param defaultContextLoaderClassName the name of the default, +	 * {@code ContextLoader} class to use (may be <code>null</code>), +	 * @return the resolved {@code ContextLoader} for the supplied, +	 * <code>testClass</code> (never <code>null</code>), +	 * @see #resolveContextLoaderClass(), +	 */, +	static ContextLoader resolveContextLoader(Class<?> testClass, String defaultContextLoaderClassName) {, +		Assert.notNull(testClass, "Test class must not be null");, +, +		if (!StringUtils.hasText(defaultContextLoaderClassName)) {, +			defaultContextLoaderClassName = DEFAULT_CONTEXT_LOADER_CLASS_NAME;, +		}, +, +		Class<? extends ContextLoader> contextLoaderClass = resolveContextLoaderClass(testClass,, +			defaultContextLoaderClassName);, +, +		return (ContextLoader) BeanUtils.instantiateClass(contextLoaderClass);, +	}, +, +	/**, +	 * Resolve the {@link ContextLoader} {@link Class} to use for the supplied, +	 * {@link Class testClass}., +	 * <ol>, +	 * <li>If the {@link ContextConfiguration#loader() loader} attribute of, +	 * {@link ContextConfiguration &#064;ContextConfiguration} is configured, +	 * with an explicit class, that class will be returned.</li>, +	 * <li>If a <code>loader</code> class is not specified, the class hierarchy, +	 * will be traversed to find a parent class annotated with, +	 * {@code @ContextConfiguration}; go to step #1.</li>, +	 * <li>If no explicit <code>loader</code> class is found after traversing, +	 * the class hierarchy, an attempt will be made to load and return the class, +	 * with the supplied <code>defaultContextLoaderClassName</code>.</li>, +	 * </ol>, +	 * @param testClass the class for which to resolve the {@code ContextLoader}, +	 * class; must not be <code>null</code>, +	 * @param defaultContextLoaderClassName the name of the default, +	 * {@code ContextLoader} class to use; must not be <code>null</code> or empty, +	 * @return the {@code ContextLoader} class to use for the supplied test class, +	 * @throws IllegalArgumentException if {@code @ContextConfiguration} is not, +	 * <em>present</em> on the supplied test class , +	 * @throws IllegalStateException if the default {@code ContextLoader} class, +	 * could not be loaded , +	 */, +	@SuppressWarnings("unchecked"), +	static Class<? extends ContextLoader> resolveContextLoaderClass(Class<?> testClass,, +			String defaultContextLoaderClassName) {, +		Assert.notNull(testClass, "Class must not be null");, +		Assert.hasText(defaultContextLoaderClassName, "Default ContextLoader class name must not be null or empty");, +, +		Class<ContextConfiguration> annotationType = ContextConfiguration.class;, +		Class<?> declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType, testClass);, +		Assert.notNull(declaringClass, String.format(, +			"Could not find an 'annotation declaring class' for annotation type [%s] and test class [%s]",, +			annotationType, testClass));, +, +		while (declaringClass != null) {, +			ContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);, +, +			if (logger.isTraceEnabled()) {, +				logger.trace(String.format(, +					"Processing ContextLoader for @ContextConfiguration [%s] and declaring class [%s]",, +					contextConfiguration, declaringClass));, +			}, +, +			Class<? extends ContextLoader> contextLoaderClass = contextConfiguration.loader();, +			if (!ContextLoader.class.equals(contextLoaderClass)) {, +				if (logger.isDebugEnabled()) {, +					logger.debug(String.format(, +						"Found explicit ContextLoader class [%s] for @ContextConfiguration [%s] and declaring class [%s]",, +						contextLoaderClass, contextConfiguration, declaringClass));, +				}, +				return contextLoaderClass;, +			}, +, +			declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType,, +				declaringClass.getSuperclass());, +		}, +, +		try {, +			if (logger.isTraceEnabled()) {, +				logger.trace(String.format("Using default ContextLoader class [%s] for test class [%s]",, +					defaultContextLoaderClassName, testClass));, +			}, +			return (Class<? extends ContextLoader>) ContextLoaderUtils.class.getClassLoader().loadClass(, +				defaultContextLoaderClassName);, +		}, +		catch (ClassNotFoundException ex) {, +			throw new IllegalStateException("Could not load default ContextLoader class [", +					+ defaultContextLoaderClassName + "]. Specify @ContextConfiguration's 'loader' "]