[+++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +	 * Set a custom ModelAndViewResolvers to use for special method return types., +	 * Such a custom ModelAndViewResolver will kick in first, having a chance to, +	 * resolve an return value before the standard ModelAndView handling kicks in., +	 * Set one or more custom ModelAndViewResolvers to use for special method return types., +	 * Any such custom ModelAndViewResolver will kick in first, having a chance to, +	 * resolve an return value before the standard ModelAndView handling kicks in., +			RequestMapping requestMapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);, +++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +	 * Set a custom ModelAndViewResolvers to use for special method return types., +	 * Such a custom ModelAndViewResolver will kick in first, having a chance to, +	 * resolve an return value before the standard ModelAndView handling kicks in., +	 * Set one or more custom ModelAndViewResolvers to use for special method return types., +	 * Any such custom ModelAndViewResolver will kick in first, having a chance to, +	 * resolve an return value before the standard ModelAndView handling kicks in., +			RequestMapping requestMapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);, +++ b/org.springframework.web.portlet/src/main/java/org/springframework/web/portlet/mvc/annotation/DefaultAnnotationHandlerMapping.java, + * Copyright 2002-2011 the original author or authors., +import javax.portlet.ActionRequest;, +import javax.portlet.WindowState;, +import org.springframework.web.portlet.bind.annotation.ActionMapping;, +import org.springframework.web.portlet.bind.annotation.RenderMapping;, + * <p>Registered by default in {@link org.springframework.web.portlet.DispatcherPortlet}., + * <b>NOTE:</b> If you define custom HandlerMapping beans in your DispatcherPortlet context,, + * you need to add a DefaultAnnotationHandlerMapping bean explicitly, since custom, + * HandlerMapping beans replace the default mapping strategies. Defining a, + * DefaultAnnotationHandlerMapping also allows for registering custom interceptors:, +					AbstractParameterMappingPredicate predicate = new TypeLevelMappingPredicate(, +					PortletRequestMappingPredicate predicate = null;, +						params = StringUtils.mergeStringArrays(typeMapping.params(), params);, +					ActionMapping actionMapping = AnnotationUtils.findAnnotation(method, ActionMapping.class);, +					RenderMapping renderMapping = AnnotationUtils.findAnnotation(method, RenderMapping.class);, +					ResourceMapping resourceMapping = AnnotationUtils.findAnnotation(method, ResourceMapping.class);, +					EventMapping eventMapping = AnnotationUtils.findAnnotation(method, EventMapping.class);, +					RequestMapping requestMapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);, +					if (actionMapping != null) {, +						params = StringUtils.mergeStringArrays(params, actionMapping.params());, +						predicate = new ActionMappingPredicate(actionMapping.value(), params);, +					else if (renderMapping != null) {, +						params = StringUtils.mergeStringArrays(params, renderMapping.params());, +						predicate = new RenderMappingPredicate(renderMapping.value(), params);, +					else if (resourceMapping != null) {, +						predicate = new ResourceMappingPredicate(resourceMapping.value());, +					}, +					else if (eventMapping != null) {, +						predicate = new EventMappingPredicate(eventMapping.value());, +					}, +					if (requestMapping != null) {, +						modeKeys = requestMapping.value();, +						params = StringUtils.mergeStringArrays(params, requestMapping.params());, +						if (predicate == null) {, +							predicate = new MethodLevelMappingPredicate(params);, +					if (predicate != null) {, +						if (modeKeys.length == 0) {, +							if (typeMapping != null) {, +								modeKeys = typeMapping.value();, +							}, +							if (modeKeys.length == 0) {, +								throw new IllegalStateException(, +										"No portlet mode mappings specified - neither at type nor at method level");, +							}, +	 * checking request method and parameter conditions., +	 * @param request current portlet request, +	private interface SpecialRequestTypePredicate {, +	}, +, +	private static abstract class AbstractParameterMappingPredicate implements PortletRequestMappingPredicate {, +, +		protected final String[] params;, +, +		public AbstractParameterMappingPredicate(String[] params) {, +			this.params = params;, +		}, +, +		public boolean match(PortletRequest request) {, +			return PortletAnnotationMappingUtils.checkParameters(this.params, request);, +		}, +	}, +, +, +	private static class TypeLevelMappingPredicate extends AbstractParameterMappingPredicate {, +		public TypeLevelMappingPredicate(String[] params, String[] headers, RequestMethod[] methods) {, +			super(params);, +			if (other instanceof AbstractParameterMappingPredicate) {, +				return new Integer(((AbstractParameterMappingPredicate) other).params.length).compareTo(this.params.length);, +			return (other instanceof SpecialRequestTypePredicate ? -1 : 0);, +		}, +	}, +, +, +	private static class MethodLevelMappingPredicate extends AbstractParameterMappingPredicate {, +, +		public MethodLevelMappingPredicate(String[] params) {, +			super(params);, +		}, +, +		public void validate(PortletRequest request) throws PortletException {, +		}, +, +		public int compareTo(Object other) {]