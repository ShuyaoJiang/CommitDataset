[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2019 the original author or authors., +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2019 the original author or authors., +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +		Class<?> commonType = null;, +		Method uniqueCandidate = mbd.factoryMethodToIntrospect;, +, +		if (uniqueCandidate == null) {, +			Method[] candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,, +					clazz -> ReflectionUtils.getUniqueDeclaredMethods(clazz, ReflectionUtils.USER_DECLARED_METHODS));, +		}, +, +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2019 the original author or authors., +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +		Class<?> commonType = null;, +		Method uniqueCandidate = mbd.factoryMethodToIntrospect;, +, +		if (uniqueCandidate == null) {, +			Method[] candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,, +					clazz -> ReflectionUtils.getUniqueDeclaredMethods(clazz, ReflectionUtils.USER_DECLARED_METHODS));, +		}, +, +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, + * Copyright 2002-2019 the original author or authors., +import java.util.Collections;, +			List<Method> candidateList = null;, +			if (mbd.isFactoryMethodUnique) {, +				if (factoryMethodToUse == null) {, +					factoryMethodToUse = mbd.getResolvedFactoryMethod();, +				}, +				if (factoryMethodToUse != null) {, +					candidateList = Collections.singletonList(factoryMethodToUse);, +				}, +			}, +			if (candidateList == null) {, +				candidateList = new ArrayList<>();, +			}, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2019 the original author or authors., +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +		Class<?> commonType = null;, +		Method uniqueCandidate = mbd.factoryMethodToIntrospect;, +, +		if (uniqueCandidate == null) {, +			Method[] candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,, +					clazz -> ReflectionUtils.getUniqueDeclaredMethods(clazz, ReflectionUtils.USER_DECLARED_METHODS));, +		}, +, +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, + * Copyright 2002-2019 the original author or authors., +import java.util.Collections;, +			List<Method> candidateList = null;, +			if (mbd.isFactoryMethodUnique) {, +				if (factoryMethodToUse == null) {, +					factoryMethodToUse = mbd.getResolvedFactoryMethod();, +				}, +				if (factoryMethodToUse != null) {, +					candidateList = Collections.singletonList(factoryMethodToUse);, +				}, +			}, +			if (candidateList == null) {, +				candidateList = new ArrayList<>();, +			}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java, + * Copyright 2002-2019 the original author or authors., +		this.factoryMethodToIntrospect = original.factoryMethodToIntrospect;, +	 * Specify a factory method name that refers to an overloaded method., +	 * @since 5.2, +	 */, +	public void setNonUniqueFactoryMethodName(String name) {, +		Assert.hasText(name, "Factory method name must not be empty");, +		setFactoryMethodName(name);, +		this.isFactoryMethodUnique = false;, +	}, +, +	/**, +	 * Set a resolved Java Method for the factory method on this bean definition., +	 * @param method the resolved factory method, or {@code null} to reset it, +	 * @since 5.2, +	 */, +	public void setResolvedFactoryMethod(@Nullable Method method) {, +		this.factoryMethodToIntrospect = method;, +	}, +, +	/**, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2019 the original author or authors., +		}, ReflectionUtils.USER_DECLARED_METHODS);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +		Class<?> commonType = null;, +		Method uniqueCandidate = mbd.factoryMethodToIntrospect;]