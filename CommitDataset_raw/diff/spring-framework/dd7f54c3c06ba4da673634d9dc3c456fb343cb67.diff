[+++ b/spring-core/src/main/java/org/springframework/core/convert/support/PropertiesToStringConverter.java, + * Copyright 2002-2014 the original author or authors., +			ByteArrayOutputStream os = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/PropertiesToStringConverter.java, + * Copyright 2002-2014 the original author or authors., +			ByteArrayOutputStream os = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/serializer/support/SerializingConverter.java, + * Copyright 2002-2014 the original author or authors., +		ByteArrayOutputStream byteStream = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/PropertiesToStringConverter.java, + * Copyright 2002-2014 the original author or authors., +			ByteArrayOutputStream os = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/serializer/support/SerializingConverter.java, + * Copyright 2002-2014 the original author or authors., +		ByteArrayOutputStream byteStream = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/style/ToStringCreator.java, + * Copyright 2002-2014 the original author or authors., +	private final StringBuilder buffer = new StringBuilder(256);, +	private final ToStringStyler styler;, +	private final Object object;, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/PropertiesToStringConverter.java, + * Copyright 2002-2014 the original author or authors., +			ByteArrayOutputStream os = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/serializer/support/SerializingConverter.java, + * Copyright 2002-2014 the original author or authors., +		ByteArrayOutputStream byteStream = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/style/ToStringCreator.java, + * Copyright 2002-2014 the original author or authors., +	private final StringBuilder buffer = new StringBuilder(256);, +	private final ToStringStyler styler;, +	private final Object object;, +++ b/spring-core/src/main/java/org/springframework/util/ResizableByteArrayOutputStream.java, +, +import java.io.ByteArrayOutputStream;, + * An extension of {@link java.io.ByteArrayOutputStream} that:, + * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}, + * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods, + * to get more control over the the size of the internal buffer</li>, + * <li>has a higher initial capacity (256) by default</li>, + * @author Juergen Hoeller, +public class ResizableByteArrayOutputStream extends ByteArrayOutputStream {, +	private static final int DEFAULT_INITIAL_CAPACITY = 256;, +	 * Create a new <code>ResizableByteArrayOutputStream</code>, +	 * with the default initial capacity of 128 bytes., +		super(DEFAULT_INITIAL_CAPACITY);, +	 * Create a new <code>ResizableByteArrayOutputStream</code>, +	 * with the specified initial capacity., +	 * @param initialCapacity the initial buffer size in bytes, +	public ResizableByteArrayOutputStream(int initialCapacity) {, +		super(initialCapacity);, +	 * Resize the internal buffer size to a specified capacity., +	 * @param targetCapacity the desired size of the buffer, +	 * @throws IllegalArgumentException if the given capacity is smaller than, +	 * the actual size of the content stored in the buffer already, +	public synchronized void resize(int targetCapacity) {, +		Assert.isTrue(targetCapacity >= this.count, "New capacity must not be smaller than current size");, +		byte[] resizedBuffer = new byte[targetCapacity];, +		System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);, +		this.buf = resizedBuffer;, +	 * Grow the internal buffer size., +	 * @param additionalCapacity the number of bytes to add to the current buffer size, +	public synchronized void grow(int additionalCapacity) {, +		Assert.isTrue(additionalCapacity >= 0, "Additional capacity must be 0 or higher");, +		if (this.count + additionalCapacity > this.buf.length) {, +			int newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);, +			resize(newCapacity);, +		}, +	 * Return the current size of this stream's internal buffer., +	public synchronized int capacity() {, +		return this.buf.length;, +++ b/spring-core/src/main/java/org/springframework/core/convert/support/PropertiesToStringConverter.java, + * Copyright 2002-2014 the original author or authors., +			ByteArrayOutputStream os = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/serializer/support/SerializingConverter.java, + * Copyright 2002-2014 the original author or authors., +		ByteArrayOutputStream byteStream = new ByteArrayOutputStream(256);, +++ b/spring-core/src/main/java/org/springframework/core/style/ToStringCreator.java, + * Copyright 2002-2014 the original author or authors., +	private final StringBuilder buffer = new StringBuilder(256);, +	private final ToStringStyler styler;, +	private final Object object;, +++ b/spring-core/src/main/java/org/springframework/util/ResizableByteArrayOutputStream.java, +, +import java.io.ByteArrayOutputStream;, + * An extension of {@link java.io.ByteArrayOutputStream} that:, + * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}, + * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods, + * to get more control over the the size of the internal buffer</li>, + * <li>has a higher initial capacity (256) by default</li>, + * @author Juergen Hoeller, +public class ResizableByteArrayOutputStream extends ByteArrayOutputStream {, +	private static final int DEFAULT_INITIAL_CAPACITY = 256;, +	 * Create a new <code>ResizableByteArrayOutputStream</code>, +	 * with the default initial capacity of 128 bytes., +		super(DEFAULT_INITIAL_CAPACITY);, +	 * Create a new <code>ResizableByteArrayOutputStream</code>, +	 * with the specified initial capacity., +	 * @param initialCapacity the initial buffer size in bytes, +	public ResizableByteArrayOutputStream(int initialCapacity) {, +		super(initialCapacity);]