[+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodesFactory.java, +import org.springframework.util.ConcurrentReferenceHashMap;, +	private final Map<DataSource, SQLErrorCodes> dataSourceCache = new ConcurrentReferenceHashMap<>(16);, +	 * @param databaseName the database name (must not be {@code null}), +	public SQLErrorCodes getErrorCodes(String databaseName) {, +		Assert.notNull(databaseName, "Database product name must not be null");, +		SQLErrorCodes sec = this.errorCodesMap.get(databaseName);, +				if (PatternMatchUtils.simpleMatch(candidate.getDatabaseProductNames(), databaseName)) {, +			checkCustomTranslatorRegistry(databaseName, sec);, +				logger.debug("SQL error codes for '" + databaseName + "' found");, +			logger.debug("SQL error codes for '" + databaseName + "' not found");, +			logger.debug("Looking up default SQLErrorCodes for DataSource [" + identify(dataSource) + "]");, +		// Try efficient lock-free access for existing cache entry, +		if (sec == null) {, +			synchronized (this.dataSourceCache) {, +				// Double-check within full dataSourceCache lock, +				sec = this.dataSourceCache.get(dataSource);, +				if (sec == null) {, +						String name = (String) JdbcUtils.extractDatabaseMetaData(dataSource, "getDatabaseProductName");, +						if (name != null) {, +							return registerDatabase(dataSource, name);, +						logger.warn("Error while extracting database name - falling back to empty error codes", ex);, +						// Fallback is to return an empty SQLErrorCodes instance., +						return new SQLErrorCodes();, +					}, +				}, +		if (logger.isDebugEnabled()) {, +			logger.debug("SQLErrorCodes found in cache for DataSource [" + identify(dataSource) + "]");, +		}, +, +		return sec;, +	 * @param databaseName the corresponding database name as stated in the error codes, +	 * @return the corresponding {@code SQLErrorCodes} object (never {@code null}), +	 * @see #unregisterDatabase(DataSource), +	public SQLErrorCodes registerDatabase(DataSource dataSource, String databaseName) {, +		SQLErrorCodes sec = getErrorCodes(databaseName);, +		if (logger.isDebugEnabled()) {, +			logger.debug("Caching SQL error codes for DataSource [" + identify(dataSource) +, +					"]: database product name is '" + databaseName + "'");, +		}, +, +	/**, +	 * Clear the cache for the specified {@link DataSource}, if registered., +	 * @param dataSource the {@code DataSource} identifying the database, +	 * @return the corresponding {@code SQLErrorCodes} object,, +	 * or {@code null} if not registered, +	 * @since 4.3.5, +	 * @see #registerDatabase(DataSource, String), +	 */, +	public SQLErrorCodes unregisterDatabase(DataSource dataSource) {, +		return this.dataSourceCache.remove(dataSource);, +	}, +, +	/**, +	 * Build an identification String for the given {@link DataSource},, +	 * primarily for logging purposes., +	 * @param dataSource the {@code DataSource} to introspect, +	 * @return the identification String, +	 */, +	private String identify(DataSource dataSource) {, +		return dataSource.getClass().getName() + '@' + Integer.toHexString(dataSource.hashCode());, +	private void checkCustomTranslatorRegistry(String databaseName, SQLErrorCodes errorCodes) {, +				CustomSQLExceptionTranslatorRegistry.getInstance().findTranslatorForDatabase(databaseName);, +			if (errorCodes.getCustomSqlExceptionTranslator() != null && logger.isWarnEnabled()) {, +						errorCodes.getCustomSqlExceptionTranslator().getClass().getSimpleName() +, +						"' found in the CustomSQLExceptionTranslatorRegistry for database '" + databaseName + "'");, +			else if (logger.isInfoEnabled()) {, +						"' found in the CustomSQLExceptionTranslatorRegistry for database '" + databaseName + "'");, +			errorCodes.setCustomSqlExceptionTranslator(customTranslator);]