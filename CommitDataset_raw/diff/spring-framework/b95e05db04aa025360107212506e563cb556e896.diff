[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.core.BridgeMethodResolver;, +	public boolean matches(Method method, @Nullable Class<?> targetClass, boolean hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +			if (hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +				RuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));, +	private ShadowMatch getTargetShadowMatch(Method method, @Nullable Class<?> targetClass) {, +		Method targetMethod = method;, +		if (targetClass != null) {, +			targetMethod = ClassUtils.getMostSpecificMethod(method, ClassUtils.getUserClass(targetClass));, +			if (targetMethod.getDeclaringClass().isInterface()) {, +				Set<Class<?>> ifcs = ClassUtils.getAllInterfacesForClassAsSet(targetClass);, +				if (ifcs.size() > 1) {, +					Class<?> compositeInterface = ClassUtils.createCompositeInterface(, +							ClassUtils.toClassArray(ifcs), targetClass.getClassLoader());, +					targetMethod = ClassUtils.getMostSpecificMethod(targetMethod, compositeInterface);, +				}, +			}, +		}, +		targetMethod = BridgeMethodResolver.findBridgedMethod(targetMethod);, +		return getShadowMatch(targetMethod, method);, +	}, +, +					Method methodToMatch = targetMethod;, +							catch (ReflectionWorldException ex) {, +								catch (ReflectionWorldException ex2) {, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.core.BridgeMethodResolver;, +	public boolean matches(Method method, @Nullable Class<?> targetClass, boolean hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +			if (hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +				RuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));, +	private ShadowMatch getTargetShadowMatch(Method method, @Nullable Class<?> targetClass) {, +		Method targetMethod = method;, +		if (targetClass != null) {, +			targetMethod = ClassUtils.getMostSpecificMethod(method, ClassUtils.getUserClass(targetClass));, +			if (targetMethod.getDeclaringClass().isInterface()) {, +				Set<Class<?>> ifcs = ClassUtils.getAllInterfacesForClassAsSet(targetClass);, +				if (ifcs.size() > 1) {, +					Class<?> compositeInterface = ClassUtils.createCompositeInterface(, +							ClassUtils.toClassArray(ifcs), targetClass.getClassLoader());, +					targetMethod = ClassUtils.getMostSpecificMethod(targetMethod, compositeInterface);, +				}, +			}, +		}, +		targetMethod = BridgeMethodResolver.findBridgedMethod(targetMethod);, +		return getShadowMatch(targetMethod, method);, +	}, +, +					Method methodToMatch = targetMethod;, +							catch (ReflectionWorldException ex) {, +								catch (ReflectionWorldException ex2) {, +++ b/spring-aop/src/main/java/org/springframework/aop/support/MethodMatchers.java, + * Copyright 2002-2018 the original author or authors., +		return (mm instanceof IntroductionAwareMethodMatcher ?, +				((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions) :, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2018 the original author or authors., +import org.springframework.core.BridgeMethodResolver;, +	public boolean matches(Method method, @Nullable Class<?> targetClass, boolean hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +			if (hasIntroductions) {, +		ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);, +				RuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));, +	private ShadowMatch getTargetShadowMatch(Method method, @Nullable Class<?> targetClass) {, +		Method targetMethod = method;, +		if (targetClass != null) {, +			targetMethod = ClassUtils.getMostSpecificMethod(method, ClassUtils.getUserClass(targetClass));, +			if (targetMethod.getDeclaringClass().isInterface()) {, +				Set<Class<?>> ifcs = ClassUtils.getAllInterfacesForClassAsSet(targetClass);, +				if (ifcs.size() > 1) {, +					Class<?> compositeInterface = ClassUtils.createCompositeInterface(, +							ClassUtils.toClassArray(ifcs), targetClass.getClassLoader());, +					targetMethod = ClassUtils.getMostSpecificMethod(targetMethod, compositeInterface);, +				}, +			}, +		}, +		targetMethod = BridgeMethodResolver.findBridgedMethod(targetMethod);, +		return getShadowMatch(targetMethod, method);, +	}, +, +					Method methodToMatch = targetMethod;, +							catch (ReflectionWorldException ex) {, +								catch (ReflectionWorldException ex2) {, +++ b/spring-aop/src/main/java/org/springframework/aop/support/MethodMatchers.java, + * Copyright 2002-2018 the original author or authors., +		return (mm instanceof IntroductionAwareMethodMatcher ?, +				((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions) :, +++ b/spring-beans/src/test/java/org/springframework/tests/sample/beans/AgeHolder.java, +/*, + * Copyright 2002-2018 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *]