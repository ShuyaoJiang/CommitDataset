[+++ b/src/docs/asciidoc/web/webflux.adoc, +=== @Controller, +`@RestController` is a composed annotation that is itself annotated with, +`@Controller` and `@ResponseBody` indicating a controller whose every method inherits the type-level, +++ b/src/docs/asciidoc/web/webflux.adoc, +=== @Controller, +`@RestController` is a composed annotation that is itself annotated with, +`@Controller` and `@ResponseBody` indicating a controller whose every method inherits the type-level, +++ b/src/docs/asciidoc/web/webmvc.adoc, +(see <<mvc-container-config>>):, +| Map a request to a handler along with a list of ``HandlerInterceptor``'s for, +[[mvc-container-config]], +=== Servlet Config API, +, +In a Servlet 3.0+ environment, you have the option of configuring the Servlet container, +programmatically as an alternative or in combination with a `web.xml` file. Below is an, +example of registering a `DispatcherServlet`:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	import org.springframework.web.WebApplicationInitializer;, +, +	public class MyWebApplicationInitializer implements WebApplicationInitializer {, +, +		@Override, +		public void onStartup(ServletContext container) {, +			XmlWebApplicationContext appContext = new XmlWebApplicationContext();, +			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");, +, +			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));, +			registration.setLoadOnStartup(1);, +			registration.addMapping("/");, +		}, +, +	}, +----, +, +`WebApplicationInitializer` is an interface provided by Spring MVC that ensures your, +implementation is detected and automatically used to initialize any Servlet 3 container., +An abstract base class implementation of `WebApplicationInitializer` named, +`AbstractDispatcherServletInitializer` makes it even easier to register the, +`DispatcherServlet` by simply overriding methods to specify the servlet mapping and the, +location of the `DispatcherServlet` configuration., +, +This is recommended for applications that use Java-based Spring configuration:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {, +, +		@Override, +		protected Class<?>[] getRootConfigClasses() {, +			return null;, +		}, +, +		@Override, +		protected Class<?>[] getServletConfigClasses() {, +			return new Class[] { MyWebConfig.class };, +		}, +, +		@Override, +		protected String[] getServletMappings() {, +			return new String[] { "/" };, +		}, +, +	}, +----, +, +If using XML-based Spring configuration, you should extend directly from, +`AbstractDispatcherServletInitializer`:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {, +, +		@Override, +		protected WebApplicationContext createRootApplicationContext() {, +			return null;, +		}, +, +		@Override, +		protected WebApplicationContext createServletApplicationContext() {, +			XmlWebApplicationContext cxt = new XmlWebApplicationContext();, +			cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");, +			return cxt;, +		}, +, +		@Override, +		protected String[] getServletMappings() {, +			return new String[] { "/" };, +		}, +, +	}, +----, +, +`AbstractDispatcherServletInitializer` also provides a convenient way to add `Filter`, +instances and have them automatically mapped to the `DispatcherServlet`:]