[+++ b/spring-framework-reference/src/beans.xml, +    <title>Classpath scanning, managed components and writing configurations, +    using Java</title>, +    <note>, +      <para>Starting with Spring 3.0 many of the features provided by the, +      <ulink url="http://www.springsource.org/javaconfig">Spring JavaConfig, +      project</ulink> have been added to the core Spring Framework. This, +      allows you to define beans using Java rather than using the traditional, +      XML files. Take a look at the, +      <interfacename>@Configuration</interfacename>,, +      <interfacename>@Bean</interfacename>,, +      <interfacename>@Value</interfacename> annotations for how to use these, +      new features.</para>, +    </note>, +, +    <section id="beans-javaconfig-configuration-annotation">, +      <title>Using the <interfacename>@Configuration</interfacename>, +      annotation</title>, +, +      <para>The central artifact in Spring's new Java-configuration support is, +      the <interfacename>@Configuration</interfacename>-annotated class. These, +      classes consist principally of, +      <interfacename>@Bean</interfacename>-annotated methods that define, +      instantiation, configuration, and initialization logic for objects that, +      will be managed by the Spring IoC container.</para>, +, +      <para>Annotating a class with the, +      <interfacename>@Configuration</interfacename> indicates that the class, +      may be used by the Spring IoC container as a source of bean definitions., +      The simplest possible <interfacename>@Configuration</interfacename>, +      class would read as follows: <programlisting language="java"><![CDATA[@Configuration, +public class AppConfig {, +, +}            ]]></programlisting></para>, +, +      <para>An application may make use of one, +      <interfacename>@Configuration</interfacename>-annotated class, or many., +      <interfacename>@Configuration</interfacename> is meta-annotated as a, +      <interfacename>@Component</interfacename>, therefore, +      Configuration-classes are candidates for component-scanning and may also, +      take advantage of <interfacename>@Autowired</interfacename> annotations, +      at the field and method level but not at the constructor level., +      Configuration-classes must also have a default constructor. Externalized, +      values may be wired into Configuration-classes using the, +      <interfacename>@Value</interfacename> annotation.</para>, +    </section>, +, +    <section id="beans-javaconfig-bean-annotation">, +      <title>Using the <interfacename>@Bean</interfacename> annotation</title>, +, +      <para><interfacename>@Bean</interfacename> is a method-level annotation, +      and a direct analog of the XML <code>&lt;bean/&gt;</code> element. The, +      annotation supports some of the attributes offered by, +      <code>&lt;bean/&gt;</code>, such as: <code><link, +      linkend="beans-factory-lifecycle-initializingbean">init-method</link></code>,, +      <code><link, +      linkend="beans-factory-lifecycle-disposablebean">destroy-method</link></code>,, +      <code><link linkend="beans-factory-autowire">autowiring</link></code>, +      and <code><link, +      linkend="beans-factory-scopes">name</link></code>.</para>, +, +      <para>You can use the @Bean annotation in a Configuraton-class or in a, +      Component-class.</para>, +, +      <section id="beans-javaconfig-declaring-a-bean">, +        <title>Declaring a bean</title>, +, +        <para>To declare a bean, simply annotate a method with the, +        <interfacename>@Bean</interfacename> annotation. Such a method will be, +        used to register a bean definition within a <code>BeanFactory</code>, +        of the type specified as the methods return value. By default, the, +        bean name will be the same as the method name (see <link, +        linkend="bean-naming"> bean naming</link> for details on how to, +        customize this behavior). The following is a simple example of a, +        <interfacename>@Bean</interfacename> method declaration:, +        <programlisting language="java"><![CDATA[@Configuration, +public class AppConfig {, +, +    @Bean, +    public TransferService transferService() {, +        return new TransferServiceImpl();, +    }, +, +}                ]]></programlisting></para>, +, +        <para>For comparison sake, the configuration above is exactly, +        equivalent to the following Spring XML: <programlisting, +        language="xml"><![CDATA[<beans>, +    <bean name="transferService" class="com.acme.TransferServiceImpl"/>, +</beans>                ]]></programlisting></para>, +, +        <para>Both will result in a bean named <code>transferService</code>, +        being available in the <code>BeanFactory</code> or, +        <code>ApplicationContext</code>, bound to an object instance of type, +        <code>TransferServiceImpl</code>: <programlisting><![CDATA[, +transferService -> com.acme.TransferServiceImpl, +                ]]></programlisting></para>, +      </section>, +, +      <section id="beans-javaconfig-injecting-dependencies">]