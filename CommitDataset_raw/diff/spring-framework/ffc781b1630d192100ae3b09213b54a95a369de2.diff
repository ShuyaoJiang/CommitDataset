[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +import java.nio.Buffer;, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) this.byteBuffer).position(this.readPosition);, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) this.byteBuffer).position(this.writePosition);, +		// Explicit access via Buffer base type for compatibility, +		// with covariant return type on JDK 9's ByteBuffer..., +		Buffer buffer = this.byteBuffer;, +			buffer.position(index);, +			// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +			((Buffer) slice).limit(length);, +			buffer.position(oldPosition);, +		// Explicit access via Buffer base type for compatibility, +		// with covariant return type on JDK 9's ByteBuffer..., +		Buffer buffer = duplicate;, +		buffer.position(this.readPosition);, +		buffer.limit(this.writePosition);, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) oldBuffer).position(this.readPosition);, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +import java.nio.Buffer;, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) this.byteBuffer).position(this.readPosition);, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) this.byteBuffer).position(this.writePosition);, +		// Explicit access via Buffer base type for compatibility, +		// with covariant return type on JDK 9's ByteBuffer..., +		Buffer buffer = this.byteBuffer;, +			buffer.position(index);, +			// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +			((Buffer) slice).limit(length);, +			buffer.position(oldPosition);, +		// Explicit access via Buffer base type for compatibility, +		// with covariant return type on JDK 9's ByteBuffer..., +		Buffer buffer = duplicate;, +		buffer.position(this.readPosition);, +		buffer.limit(this.writePosition);, +		// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +		((Buffer) oldBuffer).position(this.readPosition);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java, +import java.nio.Buffer;, +	 * @param byteBuffer the buffer to decode the STOMP frame from, +	public List<Message<byte[]>> decode(ByteBuffer byteBuffer) {, +		return decode(byteBuffer, null);, +	 * @param byteBuffer the buffer to decode the STOMP frame from, +	public List<Message<byte[]>> decode(ByteBuffer byteBuffer, MultiValueMap<String, String> partialMessageHeaders) {, +		while (byteBuffer.hasRemaining()) {, +			Message<byte[]> message = decodeMessage(byteBuffer, partialMessageHeaders);, +	private Message<byte[]> decodeMessage(ByteBuffer byteBuffer, MultiValueMap<String, String> headers) {, +		skipLeadingEol(byteBuffer);, +, +		// Explicit mark/reset access via Buffer base type for compatibility, +		// with covariant return type on JDK 9's ByteBuffer..., +		Buffer buffer = byteBuffer;, +		String command = readCommand(byteBuffer);, +			if (byteBuffer.remaining() > 0) {, +				readHeaders(byteBuffer, headerAccessor);, +				payload = readPayload(byteBuffer, headerAccessor);, +	protected void skipLeadingEol(ByteBuffer byteBuffer) {, +			if (!tryConsumeEndOfLine(byteBuffer)) {, +	private String readCommand(ByteBuffer byteBuffer) {, +		while (byteBuffer.remaining() > 0 && !tryConsumeEndOfLine(byteBuffer)) {, +			command.write(byteBuffer.get());, +	private void readHeaders(ByteBuffer byteBuffer, StompHeaderAccessor headerAccessor) {, +			while (byteBuffer.hasRemaining()) {, +				if (tryConsumeEndOfLine(byteBuffer)) {, +				headerStream.write(byteBuffer.get());, +					if (byteBuffer.remaining() > 0) {, +						if (byteBuffer.remaining() > 0) {, +	private byte[] readPayload(ByteBuffer byteBuffer, StompHeaderAccessor headerAccessor) {, +			if (byteBuffer.remaining() > contentLength) {, +				byteBuffer.get(payload);, +				if (byteBuffer.get() != 0) {, +			while (byteBuffer.remaining() > 0) {, +				byte b = byteBuffer.get();, +	private boolean tryConsumeEndOfLine(ByteBuffer byteBuffer) {, +		if (byteBuffer.remaining() > 0) {, +			byte b = byteBuffer.get();, +				if (byteBuffer.remaining() > 0 && byteBuffer.get() == '\n') {, +			// Explicit cast for compatibility with covariant return type on JDK 9's ByteBuffer, +			((Buffer) byteBuffer).position(byteBuffer.position() - 1);]