[+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HandlerMethodAnnotationDetectionTests.java, +			{ ParameterizedSubclassOverridesDefaultMappings.class, true }, // CGLib proxy, +			{ ParameterizedSubclassOverridesDefaultMappings.class, false },, +, +			// TODO [SPR-9517] Enable ParameterizedSubclassDoesNotOverrideConcreteImplementationsFromGenericAbstractSuperclass test cases, +			// { ParameterizedSubclassDoesNotOverrideConcreteImplementationsFromGenericAbstractSuperclass.class, true }, // CGLib proxy, +			// { ParameterizedSubclassDoesNotOverrideConcreteImplementationsFromGenericAbstractSuperclass.class, false },, +, +		assertEquals("model attr1:", dateFormat.parse(dateA), mav.getModel().get("attr1"));, +		assertEquals("model attr2:", dateFormat.parse(dateB), mav.getModel().get("attr2"));, +	static abstract class MappingGenericAbstractClass<A, B, C> {, +	static class ParameterizedAbstractClassController extends MappingGenericAbstractClass<String, Date, Date> {, +	@Controller, +	static abstract class MappedGenericAbstractClassWithConcreteImplementations<A, B, C> {, +, +		@InitBinder, +		public abstract void initBinder(WebDataBinder dataBinder, A thePattern);, +, +		@ModelAttribute, +		public abstract void initModel(B date, Model model);, +, +		@RequestMapping(value = "/path1/path2", method = RequestMethod.POST), +		@ModelAttribute("attr2"), +		public Date handle(C date, Model model) throws Exception {, +			return (Date) date;, +		}, +, +		@ExceptionHandler(Exception.class), +		@ResponseBody, +		public abstract String handleException(Exception exception);, +	}, +, +	static class ParameterizedSubclassDoesNotOverrideConcreteImplementationsFromGenericAbstractSuperclass extends, +			MappedGenericAbstractClassWithConcreteImplementations<String, Date, Date> {, +, +		@Override, +		public void initBinder(WebDataBinder dataBinder, @RequestParam("datePattern") String thePattern) {, +			CustomDateEditor dateEditor = new CustomDateEditor(new SimpleDateFormat(thePattern), false);, +			dataBinder.registerCustomEditor(Date.class, dateEditor);, +		}, +, +		@Override, +		public void initModel(@RequestHeader("header1") Date date, Model model) {, +			model.addAttribute("attr1", date);, +		}, +, +		// does not override handle(), +, +		@Override, +		public String handleException(Exception exception) {, +			return exception.getMessage();, +		}, +	}, +, +	@Controller, +	static abstract class GenericAbstractClassDeclaresDefaultMappings<A, B, C> {, +, +		@InitBinder, +		public abstract void initBinder(WebDataBinder dataBinder, A thePattern);, +, +		@ModelAttribute, +		public abstract void initModel(B date, Model model);, +, +		// /foo/bar should be overridden in concrete subclass, +		@RequestMapping(value = "/foo/bar", method = RequestMethod.POST), +		// attrFoo should be overridden in concrete subclass, +		@ModelAttribute("attrFoo"), +		public abstract Date handle(C date, Model model) throws Exception;, +, +		@ExceptionHandler(Exception.class), +		@ResponseBody, +		public abstract String handleException(Exception exception);, +	}, +, +	static class ParameterizedSubclassOverridesDefaultMappings extends GenericAbstractClassDeclaresDefaultMappings<String, Date, Date> {, +, +		@Override, +		public void initBinder(WebDataBinder dataBinder, @RequestParam("datePattern") String thePattern) {, +			CustomDateEditor dateEditor = new CustomDateEditor(new SimpleDateFormat(thePattern), false);, +			dataBinder.registerCustomEditor(Date.class, dateEditor);, +		}, +, +		@Override, +		public void initModel(@RequestHeader("header1") Date date, Model model) {, +			model.addAttribute("attr1", date);, +		}, +, +		@Override, +		@RequestMapping(value = "/path1/path2", method = RequestMethod.POST), +		// NOTE: @ModelAttribute will NOT be found on the abstract superclass if, +		// @RequestMapping is declared locally. Thus, we have to redeclare, +		// @ModelAttribute locally as well., +		@ModelAttribute("attr2"), +		public Date handle(@RequestHeader("header2") Date date, Model model) throws Exception {, +			return date;, +		}, +, +		@Override, +		public String handleException(Exception exception) {, +			return exception.getMessage();]