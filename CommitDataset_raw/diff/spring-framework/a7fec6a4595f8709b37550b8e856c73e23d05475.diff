[+++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/DefaultJCacheOperationSource.java, +import java.util.Collection;, +, +import org.springframework.cache.Cache;, +import org.springframework.cache.interceptor.CacheOperationInvocationContext;, +			this.exceptionCacheResolver = new LazyCacheResolver();, +, +	/**, +	 * Only resolve the default exception cache resolver when an exception needs to be handled., +	 * <p>, +	 * A non-JSR-107 setup requires either a {@link CacheManager} or a {@link CacheResolver}. If only, +	 * the latter is specified, it is not possible to extract a default exception {@code CacheResolver}, +	 * from a custom {@code CacheResolver} implementation so we have to fallback on the {@code CacheManager}., +	 * <p>, +	 * This gives this weird situation of a perfectly valid configuration that breaks all the sudden, +	 * because the JCache support is enabled. To avoid this we resolve the default exception {@code CacheResolver}, +	 * as late as possible to avoid such hard requirement in other cases., +	 */, +	class LazyCacheResolver implements CacheResolver {, +, +		private CacheResolver cacheResolver;, +, +		@Override, +		public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {, +			if (this.cacheResolver == null) {, +				this.cacheResolver = new SimpleExceptionCacheResolver(getDefaultCacheManager());, +			}, +			return this.cacheResolver.resolveCaches(context);, +		}, +	}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/DefaultJCacheOperationSource.java, +import java.util.Collection;, +, +import org.springframework.cache.Cache;, +import org.springframework.cache.interceptor.CacheOperationInvocationContext;, +			this.exceptionCacheResolver = new LazyCacheResolver();, +, +	/**, +	 * Only resolve the default exception cache resolver when an exception needs to be handled., +	 * <p>, +	 * A non-JSR-107 setup requires either a {@link CacheManager} or a {@link CacheResolver}. If only, +	 * the latter is specified, it is not possible to extract a default exception {@code CacheResolver}, +	 * from a custom {@code CacheResolver} implementation so we have to fallback on the {@code CacheManager}., +	 * <p>, +	 * This gives this weird situation of a perfectly valid configuration that breaks all the sudden, +	 * because the JCache support is enabled. To avoid this we resolve the default exception {@code CacheResolver}, +	 * as late as possible to avoid such hard requirement in other cases., +	 */, +	class LazyCacheResolver implements CacheResolver {, +, +		private CacheResolver cacheResolver;, +, +		@Override, +		public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {, +			if (this.cacheResolver == null) {, +				this.cacheResolver = new SimpleExceptionCacheResolver(getDefaultCacheManager());, +			}, +			return this.cacheResolver.resolveCaches(context);, +		}, +	}, +, +++ b/spring-context-support/src/test/java/org/springframework/cache/jcache/config/JCacheJavaConfigTests.java, +	public void exceptionCacheResolverLazilyRequired() {]