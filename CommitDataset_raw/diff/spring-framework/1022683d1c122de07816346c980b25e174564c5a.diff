[+++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/MonoToCompletableFutureConverter.java, +	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(2);, +			return Mono.fromFuture((CompletableFuture<?>) source);, +			return Mono.from((Publisher<?>) source).toFuture();, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/MonoToCompletableFutureConverter.java, +	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(2);, +			return Mono.fromFuture((CompletableFuture<?>) source);, +			return Mono.from((Publisher<?>) source).toFuture();, +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/ReactorToRxJava1Converter.java, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(6);, +			return RxJava1ObservableConverter.toPublisher((Observable<?>) source);, +			return RxJava1ObservableConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1SingleConverter.toPublisher((Single<?>) source);, +			return RxJava1SingleConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1CompletableConverter.fromPublisher((Publisher<?>) source);, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/MonoToCompletableFutureConverter.java, +	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(2);, +			return Mono.fromFuture((CompletableFuture<?>) source);, +			return Mono.from((Publisher<?>) source).toFuture();, +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/ReactorToRxJava1Converter.java, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(6);, +			return RxJava1ObservableConverter.toPublisher((Observable<?>) source);, +			return RxJava1ObservableConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1SingleConverter.toPublisher((Single<?>) source);, +			return RxJava1SingleConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1CompletableConverter.fromPublisher((Publisher<?>) source);, +++ b/spring-web-reactive/src/main/java/org/springframework/http/codec/SseEventEncoder.java, +import org.springframework.core.codec.AbstractEncoder;, +					dataBuffer = applyEncoder(data, mediaType, bufferFactory);, +	@SuppressWarnings("unchecked"), +	private <T> Flux<DataBuffer> applyEncoder(Object data, MediaType mediaType, DataBufferFactory bufferFactory) {, +		ResolvableType elementType = ResolvableType.forClass(data.getClass());, +		Optional<Encoder<?>> encoder = dataEncoders, +			.stream(), +			.filter(e -> e.canEncode(elementType, mediaType)), +			.findFirst();, +		if (!encoder.isPresent()) {, +			return Flux.error(new CodecException("No suitable encoder found!"));, +		}, +		return ((Encoder<T>) encoder.get()), +				.encode(Mono.just((T) data), bufferFactory, elementType, mediaType), +				.concatWith(encodeString("\n", bufferFactory));, +	}, +, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/MonoToCompletableFutureConverter.java, +	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(2);, +			return Mono.fromFuture((CompletableFuture<?>) source);, +			return Mono.from((Publisher<?>) source).toFuture();, +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/ReactorToRxJava1Converter.java, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(6);, +			return RxJava1ObservableConverter.toPublisher((Observable<?>) source);, +			return RxJava1ObservableConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1SingleConverter.toPublisher((Single<?>) source);, +			return RxJava1SingleConverter.fromPublisher((Publisher<?>) source);, +			return RxJava1CompletableConverter.fromPublisher((Publisher<?>) source);, +++ b/spring-web-reactive/src/main/java/org/springframework/http/codec/SseEventEncoder.java, +import org.springframework.core.codec.AbstractEncoder;, +					dataBuffer = applyEncoder(data, mediaType, bufferFactory);, +	@SuppressWarnings("unchecked"), +	private <T> Flux<DataBuffer> applyEncoder(Object data, MediaType mediaType, DataBufferFactory bufferFactory) {, +		ResolvableType elementType = ResolvableType.forClass(data.getClass());, +		Optional<Encoder<?>> encoder = dataEncoders, +			.stream(), +			.filter(e -> e.canEncode(elementType, mediaType)), +			.findFirst();, +		if (!encoder.isPresent()) {, +			return Flux.error(new CodecException("No suitable encoder found!"));, +		}, +		return ((Encoder<T>) encoder.get()), +				.encode(Mono.just((T) data), bufferFactory, elementType, mediaType), +				.concatWith(encodeString("\n", bufferFactory));, +	}, +, +++ b/spring-web-reactive/src/main/java/org/springframework/http/codec/xml/XmlEventDecoder.java, +	@SuppressWarnings("unchecked"), +							XMLEventReader eventReader = inputFactory.createXMLEventReader(is);, +							return Flux.fromIterable((Iterable<XMLEvent>) () -> eventReader);, +++ b/spring-web-reactive/src/main/java/org/springframework/core/codec/CodecException.java, +@SuppressWarnings("serial"), +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/MonoToCompletableFutureConverter.java, +	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(2);, +			return Mono.fromFuture((CompletableFuture<?>) source);, +			return Mono.from((Publisher<?>) source).toFuture();, +++ b/spring-web-reactive/src/main/java/org/springframework/core/convert/support/ReactorToRxJava1Converter.java, +		Set<GenericConverter.ConvertiblePair> pairs = new LinkedHashSet<>(6);]