[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactoryUtils.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.reflect.Method;, +, +import org.springframework.beans.factory.annotation.Qualifier;, +import org.springframework.beans.factory.config.BeanDefinition;, +import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;, +import org.springframework.beans.factory.support.AbstractBeanDefinition;, +import org.springframework.beans.factory.support.AutowireCandidateQualifier;, +import org.springframework.beans.factory.support.RootBeanDefinition;, +import org.springframework.util.ObjectUtils;, + * @author Chris Beams, +	/**, +	 * Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a, +	 * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given, +	 * qualifier, or having a bean name matching the given qualifier., +	 * @param bf the BeanFactory to get the target bean from, +	 * @param beanType the type of bean to retrieve, +	 * @param qualifier the qualifier for selecting between multiple bean matches, +	 * @return the matching bean of type {@code T} (never {@code null}), +	 * @throws IllegalStateException if no matching bean of type {@code T} found, +	 * @since 3.2, +	 */, +	public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {, +		if (beanFactory instanceof ConfigurableListableBeanFactory) {, +			// Full qualifier matching supported., +			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier);, +		}, +		else if (beanFactory.containsBean(qualifier)) {, +			// Fallback: target bean at least found by bean name., +			return beanFactory.getBean(qualifier, beanType);, +		}, +		else {, +			throw new IllegalStateException("No matching " + beanType.getSimpleName() +, +					" bean found for bean name '" + qualifier +, +					"'! (Note: Qualifier matching not supported because given " +, +					"BeanFactory does not implement ConfigurableListableBeanFactory.)");, +		}, +	}, +, +	/**, +	 * Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a, +	 * qualifier (e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given, +	 * qualifier, +	 * @param bf the BeanFactory to get the target bean from, +	 * @param beanType the type of bean to retrieve, +	 * @param qualifier the qualifier for selecting between multiple bean matches, +	 * @return the matching bean of type {@code T} (never {@code null}), +	 * @throws IllegalStateException if no matching bean of type {@code T} found, +	 */, +	private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {, +		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType);, +		T matchingBean = null;, +		for (String beanName : candidateBeans.keySet()) {, +			if (isQualifierMatch(qualifier, beanName, bf)) {, +				if (matchingBean != null) {, +					throw new IllegalStateException("No unique " + beanType.getSimpleName() +, +							" bean found for qualifier '" + qualifier + "'");, +				}, +				matchingBean = candidateBeans.get(beanName);, +			}, +		}, +		if (matchingBean != null) {, +			return matchingBean;, +		}, +		else {, +			throw new IllegalStateException("No matching " + beanType.getSimpleName() +, +					" bean found for qualifier '" + qualifier + "' - neither qualifier " +, +					"match nor bean name match!");, +		}, +	}, +, +	/**, +	 * Check whether the named bean declares a qualifier of the given name., +	 * @param qualifier the qualifier to match, +	 * @param beanName the name of the candidate bean, +	 * @param bf the {@code BeanFactory} from which to retrieve the named bean, +	 * @return {@code true} if either the bean definition (in the XML case), +	 * or the bean's factory method (in the {@code @Bean} case) defines a matching, +	 * qualifier value (through {@code <qualifier>} or {@code @Qualifier}), +	 */, +	private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {, +		if (bf.containsBean(beanName)) {, +			try {, +				BeanDefinition bd = bf.getMergedBeanDefinition(beanName);, +				if (bd instanceof AbstractBeanDefinition) {, +					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd;, +					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName());, +					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||, +							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {, +						return true;, +					}, +				}, +				if (bd instanceof RootBeanDefinition) {, +					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod();, +					if (factoryMethod != null) {, +						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class);, +						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {, +							return true;, +						}]