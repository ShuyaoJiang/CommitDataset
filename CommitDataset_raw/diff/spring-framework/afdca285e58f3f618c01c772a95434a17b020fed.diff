[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	 * Invoked when reading is paused due to a lack of demand., +	 * <p><strong>Note:</strong> This method is guaranteed not to compete with, +	 * {@link #checkOnDataAvailable()} so it can be used to safely suspend, +	 * reading, if the underlying API supports it, i.e. without competing with, +	 * an implicit call to resume via {@code checkOnDataAvailable()}., +	 * @since 5.0.2, +	protected abstract void readingPaused();, +					if (publisher.changeState(NO_DEMAND, this)) {, +						else {, +							publisher.readingPaused();, +							if (publisher.changeState(READING, NO_DEMAND)) {, +								// Demand may have arrived since readAndPublish returned, +								long r = publisher.demand;, +								if (r > 0  && publisher.changeState(NO_DEMAND, this)) {, +									publisher.checkOnDataAvailable();, +								}, +							}, +				// Else, either competing onDataAvailable (request vs container), or concurrent completion, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	 * Invoked when reading is paused due to a lack of demand., +	 * <p><strong>Note:</strong> This method is guaranteed not to compete with, +	 * {@link #checkOnDataAvailable()} so it can be used to safely suspend, +	 * reading, if the underlying API supports it, i.e. without competing with, +	 * an implicit call to resume via {@code checkOnDataAvailable()}., +	 * @since 5.0.2, +	protected abstract void readingPaused();, +					if (publisher.changeState(NO_DEMAND, this)) {, +						else {, +							publisher.readingPaused();, +							if (publisher.changeState(READING, NO_DEMAND)) {, +								// Demand may have arrived since readAndPublish returned, +								long r = publisher.demand;, +								if (r > 0  && publisher.changeState(NO_DEMAND, this)) {, +									publisher.checkOnDataAvailable();, +								}, +							}, +				// Else, either competing onDataAvailable (request vs container), or concurrent completion, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpRequest.java, +		protected void readingPaused() {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	 * Invoked when reading is paused due to a lack of demand., +	 * <p><strong>Note:</strong> This method is guaranteed not to compete with, +	 * {@link #checkOnDataAvailable()} so it can be used to safely suspend, +	 * reading, if the underlying API supports it, i.e. without competing with, +	 * an implicit call to resume via {@code checkOnDataAvailable()}., +	 * @since 5.0.2, +	protected abstract void readingPaused();, +					if (publisher.changeState(NO_DEMAND, this)) {, +						else {, +							publisher.readingPaused();, +							if (publisher.changeState(READING, NO_DEMAND)) {, +								// Demand may have arrived since readAndPublish returned, +								long r = publisher.demand;, +								if (r > 0  && publisher.changeState(NO_DEMAND, this)) {, +									publisher.checkOnDataAvailable();, +								}, +							}, +				// Else, either competing onDataAvailable (request vs container), or concurrent completion, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpRequest.java, +		protected void readingPaused() {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/UndertowServerHttpRequest.java, +			this.channel.resumeReads();, +			// We are allowed to try, it will return null if data is not available, +		protected void readingPaused() {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	 * Invoked when reading is paused due to a lack of demand., +	 * <p><strong>Note:</strong> This method is guaranteed not to compete with, +	 * {@link #checkOnDataAvailable()} so it can be used to safely suspend, +	 * reading, if the underlying API supports it, i.e. without competing with, +	 * an implicit call to resume via {@code checkOnDataAvailable()}., +	 * @since 5.0.2, +	protected abstract void readingPaused();, +					if (publisher.changeState(NO_DEMAND, this)) {, +						else {, +							publisher.readingPaused();, +							if (publisher.changeState(READING, NO_DEMAND)) {, +								// Demand may have arrived since readAndPublish returned, +								long r = publisher.demand;, +								if (r > 0  && publisher.changeState(NO_DEMAND, this)) {, +									publisher.checkOnDataAvailable();, +								}, +							}, +				// Else, either competing onDataAvailable (request vs container), or concurrent completion, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpRequest.java, +		protected void readingPaused() {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/UndertowServerHttpRequest.java, +			this.channel.resumeReads();, +			// We are allowed to try, it will return null if data is not available, +		protected void readingPaused() {, +++ b/spring-web/src/test/java/org/springframework/http/server/reactive/ListenerReadPublisherTests.java, +		protected void readingPaused() {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	 * Invoked when reading is paused due to a lack of demand., +	 * <p><strong>Note:</strong> This method is guaranteed not to compete with, +	 * {@link #checkOnDataAvailable()} so it can be used to safely suspend, +	 * reading, if the underlying API supports it, i.e. without competing with, +	 * an implicit call to resume via {@code checkOnDataAvailable()}., +	 * @since 5.0.2, +	protected abstract void readingPaused();]