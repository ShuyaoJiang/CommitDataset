[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +import java.util.List;, +import org.springframework.asm.ClassWriter;, +import org.springframework.expression.spel.ast.SpelNodeImpl;, + * Manages the class being generated by the compilation process. It records, + * intermediate compilation state as the bytecode is generated. It also includes, + * various bytecode generation helper functions., +	/**, +	 * The current class being generated, +	 */, +	private ClassWriter cw;, +	/**, +	 * As SpEL ast nodes are called to generate code for the main evaluation method, +	 * they can register to add a field to this class. Any registered FieldAdders, +	 * will be called after the main evaluation function has finished being generated., +	 */, +	private List<FieldAdder> fieldAdders = null;, +	, +	/**, +	 * As SpEL ast nodes are called to generate code for the main evaluation method, +	 * they can register to add code to a static initializer in the class. Any, +	 * registered ClinitAdders will be called after the main evaluation function, +	 * has finished being generated., +	 */, +	private List<ClinitAdder> clinitAdders = null;, +	, +	/**, +	 * Name of the class being generated. Typically used when generating code, +	 * that accesses freshly generated fields on the generated type., +	 */, +	private String clazzName;, +	, +	/**, +	 * When code generation requires holding a value in a class level field, this, +	 * is used to track the next available field id (used as a name suffix)., +	 */, +	private int nextFieldId = 1;, +	, +	/**, +	 * When code generation requires an intermediate variable within a method,, +	 * this method records the next available variable (variable 0 is 'this')., +	 */, +	private int nextFreeVariableId = 1;, +, +	public CodeFlow(String clazzName, ClassWriter cw) {, +		this.cw = cw;, +		this.clazzName = clazzName;, +	/**, +	 * Called after the main expression evaluation method has been generated, this, +	 * method will callback any registered FieldAdders or ClinitAdders to add any, +	 * extra information to the class representing the compiled expression., +	 */, +	public void finish() {, +		if (fieldAdders != null) {, +			for (FieldAdder fieldAdder: fieldAdders) {, +				fieldAdder.generateField(cw,this);, +			}, +		}, +		if (clinitAdders != null) {, +			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null);, +			mv.visitCode();, +			nextFreeVariableId = 0; // To 0 because there is no 'this' in a clinit, +			for (ClinitAdder clinitAdder: clinitAdders) {, +				clinitAdder.generateCode(mv, this);, +			}, +			mv.visitInsn(RETURN);, +			mv.visitMaxs(0,0); // not supplied due to COMPUTE_MAXS, +			mv.visitEnd();, +		}, +	}, +, +	/**, +	 * Register a FieldAdder which will add a new field to the generated, +	 * class to support the code produced by an ast nodes primary, +	 * generateCode() method., +	 */, +	public void registerNewField(FieldAdder fieldAdder) {, +		if (fieldAdders == null) {, +			fieldAdders = new ArrayList<FieldAdder>();, +		}, +		fieldAdders.add(fieldAdder);, +	}, +, +	/**, +	 * Register a ClinitAdder which will add code to the static , +	 * initializer in the generated class to support the code, +	 * produced by an ast nodes primary generateCode() method., +	 */, +	public void registerNewClinit(ClinitAdder clinitAdder) {, +		if (clinitAdders == null) {, +			clinitAdders = new ArrayList<ClinitAdder>();, +		}, +		clinitAdders.add(clinitAdder);, +	}, +, +	public int nextFieldId() {, +		return nextFieldId++;, +	}, +, +	public int nextFreeVariableId() {]