[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/RequestBodyArgumentResolver.java, +		else if (type.getRawClass() == Flux.class) {, +			return Mono.just(elementFlux);, +		}, +		else if (type.getRawClass() == Mono.class) {, +			return Mono.just(Mono.from(elementFlux));, +		}, +		// TODO Currently manage only "Foo" parameter, not "List<Foo>" parameters, Stéphane is going to add toIterable/toIterator to Flux to support that use case, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/RequestBodyArgumentResolver.java, +		else if (type.getRawClass() == Flux.class) {, +			return Mono.just(elementFlux);, +		}, +		else if (type.getRawClass() == Mono.class) {, +			return Mono.just(Mono.from(elementFlux));, +		}, +		// TODO Currently manage only "Foo" parameter, not "List<Foo>" parameters, Stéphane is going to add toIterable/toIterator to Flux to support that use case, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/method/annotation/RequestMappingIntegrationTests.java, +import reactor.Flux;, +	public void rawFluxResponse() throws Exception {, +, +		RestTemplate restTemplate = new RestTemplate();, +, +		URI url = new URI("http://localhost:" + port + "/raw-flux");, +		RequestEntity<Void> request = RequestEntity.get(url).build();, +		ResponseEntity<String> response = restTemplate.exchange(request, String.class);, +, +		assertEquals("Hello!", response.getBody());, +	}, +, +	@Test, +	public void rawObservableResponse() throws Exception {, +	public void serializeAsMono() throws Exception {, +		serializeAsPojo("http://localhost:" + port + "/mono");, +	}, +, +	@Test, +	public void serializeAsFlux() throws Exception {, +		serializeAsCollection("http://localhost:" + port + "/flux");, +	}, +, +	@Test, +	public void fluxCapitalize() throws Exception {, +		capitalizeCollection("http://localhost:" + port + "/flux-capitalize");, +	}, +, +	@Test, +	public void monoCapitalize() throws Exception {, +		capitalizePojo("http://localhost:" + port + "/mono-capitalize");, +	}, +, +	@Test, +	public void fluxCreate() throws Exception {, +		create("http://localhost:" + this.port + "/flux-create");, +	}, +, +	@Test, +		@RequestMapping("/raw-flux"), +		@ResponseBody, +		public Flux<ByteBuffer> rawFluxResponseBody() {, +			return Flux.just(Buffer.wrap("Hello!").byteBuffer());, +		}, +, +		@RequestMapping("/mono"), +		@ResponseBody, +		public Mono<Person> monoResponseBody() {, +			return Mono.just(new Person("Robert"));, +		}, +, +		@RequestMapping("/flux"), +		@ResponseBody, +		public Flux<Person> fluxResponseBody() {, +			return Flux.just(new Person("Robert"), new Person("Marie"));, +		}, +, +		@RequestMapping("/flux-capitalize"), +		@ResponseBody, +		public Flux<Person> fluxCapitalize(@RequestBody Flux<Person> persons) {, +			return persons.map(person -> {, +				person.setName(person.getName().toUpperCase());, +				return person;, +			});, +		}, +, +		@RequestMapping("/mono-capitalize"), +		@ResponseBody, +		public Mono<Person> monoCapitalize(@RequestBody Mono<Person> personFuture) {, +			return personFuture.map(person -> {, +				person.setName(person.getName().toUpperCase());, +				return person;, +			});, +		}, +, +			return Flux.from(personStream).doOnNext(persons::add).after();, +		}, +, +		@RequestMapping("/flux-create"), +		public Mono<Void> fluxCreate(@RequestBody Flux<Person> personStream) {, +			return personStream.doOnNext(persons::add).after();, +			return personStream.toList().doOnSuccess(persons::addAll).after();, +			return Mono.just("Recovered from error: " + ex.getMessage());]