[+++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * &#064;Profile("development"), + * Alternatively, you may also declare profile conditions at the {@code @Bean} method level,, + * e.g. for alternative bean variants within the same configuration class:, + *, + * <pre class="code">, + * &#064;Configuration, + * public class ProfileDatabaseConfig {, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("development"), + *     public DataSource embeddedDatabase() { ... }, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("production"), + *     public DataSource productionDatabase() { ... }, + * }</pre>, + *, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * &#064;Profile("development"), + * Alternatively, you may also declare profile conditions at the {@code @Bean} method level,, + * e.g. for alternative bean variants within the same configuration class:, + *, + * <pre class="code">, + * &#064;Configuration, + * public class ProfileDatabaseConfig {, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("development"), + *     public DataSource embeddedDatabase() { ... }, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("production"), + *     public DataSource productionDatabase() { ... }, + * }</pre>, + *, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Profile.java, + * apply: In the case of overloaded {@code @Bean} methods of the same Java method name, + * (analogous to constructor overloading), an {@code @Profile} condition needs to be, + * consistently declared on all overloaded methods. If the conditions are inconsistent,, + * only the condition on the first declaration among the overloaded methods will matter., + * {@code @Profile} can therefore not be used to select an overloaded method with a, + * particular argument signature over another; resolution between all factory methods, + * for the same bean follows Spring's constructor resolution algorithm at creation time., + * <b>Use distinct Java method names pointing to the same {@link @Bean#name bean name}, + * if you'd like to define alternative beans with different profile conditions</b>;, + * see {@code ProfileDatabaseConfig} in {@link Configuration @Configuration}'s javadoc., +++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java, + * &#064;Profile("development"), + * Alternatively, you may also declare profile conditions at the {@code @Bean} method level,, + * e.g. for alternative bean variants within the same configuration class:, + *, + * <pre class="code">, + * &#064;Configuration, + * public class ProfileDatabaseConfig {, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("development"), + *     public DataSource embeddedDatabase() { ... }, + *, + *     &#064;Bean("dataSource"), + *     &#064;Profile("production"), + *     public DataSource productionDatabase() { ... }, + * }</pre>, + *, +++ b/spring-context/src/main/java/org/springframework/context/annotation/Profile.java, + * apply: In the case of overloaded {@code @Bean} methods of the same Java method name, + * (analogous to constructor overloading), an {@code @Profile} condition needs to be, + * consistently declared on all overloaded methods. If the conditions are inconsistent,, + * only the condition on the first declaration among the overloaded methods will matter., + * {@code @Profile} can therefore not be used to select an overloaded method with a, + * particular argument signature over another; resolution between all factory methods, + * for the same bean follows Spring's constructor resolution algorithm at creation time., + * <b>Use distinct Java method names pointing to the same {@link @Bean#name bean name}, + * if you'd like to define alternative beans with different profile conditions</b>;, + * see {@code ProfileDatabaseConfig} in {@link Configuration @Configuration}'s javadoc., +++ b/src/docs/asciidoc/core/core-beans.adoc, +	**@Profile("development")**, +of a configuration class, e.g. for alternative variants of a particular bean:, +		@Bean("dataSource"), +		**@Profile("development")**, +		public DataSource standaloneDataSource() {, +		@Bean("dataSource"), +		public DataSource jndiDataSource() throws Exception {, +overloaded `@Bean` methods of the same Java method name (analogous to constructor, +overloading), an `@Profile` condition needs to be consistently declared on all, +overloaded methods. If the conditions are inconsistent, only the condition on the, +first declaration among the overloaded methods will matter. `@Profile` can therefore, +not be used to select an overloaded method with a particular argument signature over, +another; resolution between all factory methods for the same bean follows Spring's, +constructor resolution algorithm at creation time., +, +If you would like to define alternative beans with different profile conditions,, +use distinct Java method names pointing to the same bean name via the `@Bean` name, +attribute, as indicated in the example above. If the argument signatures are all, +the same (e.g. all of the variants have no-arg factory methods), this is the only, +way to represent such an arrangement in a valid Java class in the first place, +(since there can only be one method of a particular name and argument signature)., +	<beans profile="development", +		<beans profile="development">]