[+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	 * Resolve the given generic type against the given context class,, +	 * substituting type variables as far as possible., +	 * @param genericType the (potentially) generic type, +	 * @param contextClass a context class for the target type, for example a class, +	 * in which the target type appears in a method signature (can be {@code null}), +	 * @return the resolved type (possibly the given generic type as-is), +	 * @since 5.0, +	public static Type resolveType(Type genericType, Class<?> contextClass) {, +		if (contextClass != null) {, +			if (genericType instanceof TypeVariable) {, +				ResolvableType resolvedTypeVariable = resolveVariable(, +						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass));, +				if (resolvedTypeVariable != ResolvableType.NONE) {, +					return resolvedTypeVariable.resolve();, +				}, +			}, +			else if (genericType instanceof ParameterizedType) {, +				ResolvableType resolvedType = ResolvableType.forType(genericType);, +				if (resolvedType.hasUnresolvableGenerics()) {, +					ParameterizedType parameterizedType = (ParameterizedType) genericType;, +					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length];, +					Type[] typeArguments = parameterizedType.getActualTypeArguments();, +					for (int i = 0; i < typeArguments.length; i++) {, +						Type typeArgument = typeArguments[i];, +						if (typeArgument instanceof TypeVariable) {, +							ResolvableType resolvedTypeArgument = resolveVariable(, +									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass));, +							if (resolvedTypeArgument != ResolvableType.NONE) {, +								generics[i] = resolvedTypeArgument.resolve();, +							}, +							else {, +								generics[i] = ResolvableType.forType(typeArgument).resolve();, +							}, +						}, +						else {, +							generics[i] = ResolvableType.forType(typeArgument).resolve();, +						}, +					}, +					return ResolvableType.forClassWithGenerics(resolvedType.getRawClass(), generics).getType();, +				}, +			}, +		}, +		return genericType;, +	private static ResolvableType resolveVariable(TypeVariable<?> typeVariable, ResolvableType contextType) {, +		ResolvableType resolvedType;, +		if (contextType.hasGenerics()) {, +			resolvedType = ResolvableType.forType(typeVariable, contextType);, +			if (resolvedType.resolve() != null) {, +				return resolvedType;, +		ResolvableType superType = contextType.getSuperType();, +		if (superType != ResolvableType.NONE) {, +			resolvedType = resolveVariable(typeVariable, superType);, +			if (resolvedType.resolve() != null) {, +				return resolvedType;, +		for (ResolvableType ifc : contextType.getInterfaces()) {, +			resolvedType = resolveVariable(typeVariable, ifc);, +			if (resolvedType.resolve() != null) {, +				return resolvedType;, +		return ResolvableType.NONE;, +	}, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	 * Resolve the given generic type against the given context class,, +	 * substituting type variables as far as possible., +	 * @param genericType the (potentially) generic type, +	 * @param contextClass a context class for the target type, for example a class, +	 * in which the target type appears in a method signature (can be {@code null}), +	 * @return the resolved type (possibly the given generic type as-is), +	 * @since 5.0, +	public static Type resolveType(Type genericType, Class<?> contextClass) {, +		if (contextClass != null) {, +			if (genericType instanceof TypeVariable) {, +				ResolvableType resolvedTypeVariable = resolveVariable(, +						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass));, +				if (resolvedTypeVariable != ResolvableType.NONE) {, +					return resolvedTypeVariable.resolve();, +				}, +			}, +			else if (genericType instanceof ParameterizedType) {, +				ResolvableType resolvedType = ResolvableType.forType(genericType);, +				if (resolvedType.hasUnresolvableGenerics()) {, +					ParameterizedType parameterizedType = (ParameterizedType) genericType;, +					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length];, +					Type[] typeArguments = parameterizedType.getActualTypeArguments();, +					for (int i = 0; i < typeArguments.length; i++) {, +						Type typeArgument = typeArguments[i];, +						if (typeArgument instanceof TypeVariable) {, +							ResolvableType resolvedTypeArgument = resolveVariable(, +									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass));, +							if (resolvedTypeArgument != ResolvableType.NONE) {, +								generics[i] = resolvedTypeArgument.resolve();, +							}, +							else {, +								generics[i] = ResolvableType.forType(typeArgument).resolve();, +							}, +						}, +						else {, +							generics[i] = ResolvableType.forType(typeArgument).resolve();, +						}, +					}]