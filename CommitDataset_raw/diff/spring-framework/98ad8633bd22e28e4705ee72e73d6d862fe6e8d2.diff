[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java, +	/** Whether we should attempt to resolve views again if unresolved once */, +	private boolean cacheUnresolved = false;, +, +	/**, +	 * Whether a view name once resolved to {@code null} should be cached and , +	 * automatically resolved to {@code null} subsequently., +	 * <p>Default is "false": unresolved view names are not cached., +	 * <p>Of specific interest is the ability for some AbstractUrlBasedView , +	 * implementations (Freemarker, Velocity, Tiles) to check if an underlying , +	 * resource exists via {@link AbstractUrlBasedView#checkResource(Locale)}., +	 * With this flag set to "false", an underlying resource that re-appears , +	 * is noticed and used. With the flag set to "true", one check is made only., +	 */, +	public void setCacheUnresolved(boolean cacheUnresolved) {, +		this.cacheUnresolved = cacheUnresolved;, +	}, +, +	/**, +	 * Return if caching of unresolved views is enabled., +	 */, +	public boolean isCacheUnresolved() {, +		return cacheUnresolved;, +	}, +				boolean isCached = this.cacheUnresolved && this.viewCache.containsKey(cacheKey);, +				if (view == null && !isCached) {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java, +	/** Whether we should attempt to resolve views again if unresolved once */, +	private boolean cacheUnresolved = false;, +, +	/**, +	 * Whether a view name once resolved to {@code null} should be cached and , +	 * automatically resolved to {@code null} subsequently., +	 * <p>Default is "false": unresolved view names are not cached., +	 * <p>Of specific interest is the ability for some AbstractUrlBasedView , +	 * implementations (Freemarker, Velocity, Tiles) to check if an underlying , +	 * resource exists via {@link AbstractUrlBasedView#checkResource(Locale)}., +	 * With this flag set to "false", an underlying resource that re-appears , +	 * is noticed and used. With the flag set to "true", one check is made only., +	 */, +	public void setCacheUnresolved(boolean cacheUnresolved) {, +		this.cacheUnresolved = cacheUnresolved;, +	}, +, +	/**, +	 * Return if caching of unresolved views is enabled., +	 */, +	public boolean isCacheUnresolved() {, +		return cacheUnresolved;, +	}, +				boolean isCached = this.cacheUnresolved && this.viewCache.containsKey(cacheKey);, +				if (view == null && !isCached) {, +++ b/org.springframework.web.servlet/src/test/java/org/springframework/web/servlet/view/ViewResolverTests.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertSame;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +, +import java.util.concurrent.atomic.AtomicInteger;, +, +	@Test, +	public void testCacheUnresolved() throws Exception {, +		final AtomicInteger count = new AtomicInteger();, +		AbstractCachingViewResolver viewResolver = new AbstractCachingViewResolver() {, +			@Override, +			protected View loadView(String viewName, Locale locale) throws Exception {, +				count.incrementAndGet();, +				return null;, +			}, +		};, +, +		viewResolver.setCacheUnresolved(false);, +, +		viewResolver.resolveViewName("view", Locale.getDefault());, +		viewResolver.resolveViewName("view", Locale.getDefault());, +		, +		assertEquals(2, count.intValue());, +, +		viewResolver.setCacheUnresolved(true);, +		, +		viewResolver.resolveViewName("view", Locale.getDefault());, +		viewResolver.resolveViewName("view", Locale.getDefault());, +		, +		assertEquals(2, count.intValue());, +	}]