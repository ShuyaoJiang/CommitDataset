[+++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, + * Represents a MIME Type, as originally defined in RFC 2046 and subsequently, + * used in other Internet protocols including HTTP., + * in HTTP content negotiation. Those can be found in the subclass, + * Also has functionality to parse MIME Type values from a {@code String} using, +	 * @param other the other MimeType, +	 * @param other the other MimeType, +	 * @param parameters the parameters (may be {@code null}), +	 * @param parameters the parameters (may be {@code null}), +	 * Indicates whether this MIME Type is concrete, i.e. whether neither the type, +	 * @return whether this MIME Type is concrete, +	 * Indicate whether this MIME Type includes the given MIME Type., +	 * and {@code application/*+xml} includes {@code application/soap+xml}, etc., +	 * This method is <b>not</b> symmetric., +	 * @param other the reference MIME Type with which to compare, +	 * @return {@code true} if this MIME Type includes the given MIME Type;, +	 * Indicate whether this MIME Type is compatible with the given MIME Type., +	 * @param other the reference MIME Type with which to compare, +	 * @return {@code true} if this MIME Type is compatible with the given MIME Type;, +	 * Compares this MIME Type to another alphabetically., +	 * @param other the MIME Type to compare to, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, + * Represents a MIME Type, as originally defined in RFC 2046 and subsequently, + * used in other Internet protocols including HTTP., + * in HTTP content negotiation. Those can be found in the subclass, + * Also has functionality to parse MIME Type values from a {@code String} using, +	 * @param other the other MimeType, +	 * @param other the other MimeType, +	 * @param parameters the parameters (may be {@code null}), +	 * @param parameters the parameters (may be {@code null}), +	 * Indicates whether this MIME Type is concrete, i.e. whether neither the type, +	 * @return whether this MIME Type is concrete, +	 * Indicate whether this MIME Type includes the given MIME Type., +	 * and {@code application/*+xml} includes {@code application/soap+xml}, etc., +	 * This method is <b>not</b> symmetric., +	 * @param other the reference MIME Type with which to compare, +	 * @return {@code true} if this MIME Type includes the given MIME Type;, +	 * Indicate whether this MIME Type is compatible with the given MIME Type., +	 * @param other the reference MIME Type with which to compare, +	 * @return {@code true} if this MIME Type is compatible with the given MIME Type;, +	 * Compares this MIME Type to another alphabetically., +	 * @param other the MIME Type to compare to, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java, +		Expression e = parser.parseExpression("list[0]");, +, +		Object o = e.getValue(new StandardEvaluationContext(testClass));, +, +, +	public void testCreateMapsOnAttemptToIndexNull01() {, +, +		Object o = parser.parseExpression("map['a']").getValue(ctx);, +	public void testCreateObjectsOnAttemptToReferenceNull() {, +, +		Object o = parser.parseExpression("wibble.bar").getValue(ctx);, +		catch (SpelParseException ex) {, +			assertEquals(SpelMessage.OOD, ex.getMessageCode());, +			assertEquals(16, ex.getPosition());, +	public void testConstructorInvocation06() {, +		SpelExpression e = (SpelExpression) parser.parseExpression("new String('wibble')");, +		String newString = e.getValue(String.class);, +		newString = e.getValue(String.class);, +		assertFalse(e.isWritable(new StandardEvaluationContext()));, +		assertEquals("new String('wibble')", e.toStringAST());, +	public void testTernaryOperator04() {, +		Expression e = parser.parseExpression("1>2?3:4");, +		assertFalse(e.isWritable(eContext));, +	public void testTypeReferencesAndQualifiedIdentifierCaching() {, +		SpelExpression e = (SpelExpression) parser.parseExpression("T(java.lang.String)");, +		assertFalse(e.isWritable(new StandardEvaluationContext()));, +		assertEquals("T(java.lang.String)", e.toStringAST());, +		assertEquals(String.class, e.getValue(Class.class));, +		assertEquals("T(java.lang.String)", e.toStringAST());, +		assertEquals(String.class, e.getValue(Class.class));, +	public void operatorVariants() {, +		SpelExpression e = (SpelExpression)parser.parseExpression("#a < #b");, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertFalse(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +		assertTrue(e.getValue(ctx, Boolean.class));, +	public void testAdvancedNumerics() {, +	public void testComparison() {, +		boolean trueValue = parser.parseExpression("T(java.util.Date) == Birthdate.Class").getValue(, +				context, Boolean.class);, +	public void testResolvingList() {, +	public void testResolvingString() {, +	public void initializingCollectionElementsOnWrite() {, +		Expression e = parser.parseExpression("name");, +		e.setValue(context, "Oleg");, +		e = parser.parseExpression("address.street");, +		e.setValue(context, "123 High St");, +		e = parser.parseExpression("address.crossStreets[0]");, +		e.setValue(context, "Blah");, +		e = parser.parseExpression("address.crossStreets[3]");, +		e.setValue(context, "Wibble");, +		Expression e = parser.parseExpression("null");, +		assertNull(e.getValue());]