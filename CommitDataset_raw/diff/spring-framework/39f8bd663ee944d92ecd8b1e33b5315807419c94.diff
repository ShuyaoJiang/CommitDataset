[+++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||, +				main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||, +				main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageReader.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +		return (MULTIVALUE_TYPE.isAssignableFrom(elementType) &&, +				(mediaType == null || MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)));, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||, +				main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageReader.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +		return (MULTIVALUE_TYPE.isAssignableFrom(elementType) &&, +				(mediaType == null || MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)));, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageWriter.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||, +				main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageReader.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +		return (MULTIVALUE_TYPE.isAssignableFrom(elementType) &&, +				(mediaType == null || MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)));, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageWriter.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +++ b/spring-web/src/main/java/org/springframework/http/codec/HttpMessageDecoder.java, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||, +				main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageReader.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +		return (MULTIVALUE_TYPE.isAssignableFrom(elementType) &&, +				(mediaType == null || MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)));, +++ b/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageWriter.java, + * Copyright 2002-2017 the original author or authors., +		Assert.notNull(charset, "Charset must not be null");, +++ b/spring-web/src/main/java/org/springframework/http/codec/HttpMessageDecoder.java, +++ b/spring-web/src/main/java/org/springframework/http/codec/HttpMessageEncoder.java, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +			MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {, +		Flux<DataBuffer> body = this.encoder.encode(, +				inputStream, message.bufferFactory(), elementType, contentType, hints);, +		return (isStreamingMediaType(contentType) ?, +				message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));, +		return (main == null || !main.isConcrete() ||]