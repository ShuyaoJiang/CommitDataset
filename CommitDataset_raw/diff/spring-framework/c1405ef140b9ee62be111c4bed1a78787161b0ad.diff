[+++ b/spring-expression/src/test/java/org/springframework/expression/spel/support/ReflectionHelperTests.java, + * Tests for reflection helper code., +		assertEquals("java.lang.String[]", FormatHelper.formatClassNameForMessage(String[].class));, +		assertEquals("java.lang.String[][]", FormatHelper.formatClassNameForMessage(String[][].class));, +		assertEquals("int[]", FormatHelper.formatClassNameForMessage(int[].class));, +		assertEquals("int[][]", FormatHelper.formatClassNameForMessage(int[][].class));, +		checkMatch2(new Class<?>[] {String[].class}, new Class<?>[] {String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Integer.class, String[].class}, new Class<?>[] {Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {String.class, Integer.class, String[].class}, new Class<?>[] {String.class,Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Sub.class, String[].class}, new Class<?>[] {Super.class,String[].class}, tc, ArgumentsMatchKind.CLOSE);, +		checkMatch2(new Class<?>[] {Integer.class, String[].class}, new Class<?>[] {String.class, String[].class}, tc, ArgumentsMatchKind.REQUIRES_CONVERSION);, +		checkMatch2(new Class<?>[] {String.class}, new Class<?>[] {String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Integer.class, String.class}, new Class<?>[] {Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {String.class}, new Class<?>[] {Integer[].class}, tc, ArgumentsMatchKind.REQUIRES_CONVERSION);, +		checkMatch2(new Class<?>[] {Sub.class}, new Class<?>[] {Super[].class}, tc, ArgumentsMatchKind.CLOSE);, +		checkMatch2(new Class<?>[] {Super.class}, new Class<?>[] {Sub[].class}, tc, null);, +				new Class<?>[] {String[].class}, "a", "b", "c");, +	public void testReflectivePropertyAccessor() throws Exception {, +		ReflectivePropertyAccessor rpa = new ReflectivePropertyAccessor();, +		assertTrue(rpa.canRead(ctx, t, "property"));, +		assertEquals("hello",rpa.read(ctx, t, "property").getValue());, +		assertEquals("hello",rpa.read(ctx, t, "property").getValue()); // cached accessor used, +		assertTrue(rpa.canRead(ctx, t, "field"));, +		assertEquals(3,rpa.read(ctx, t, "field").getValue());, +		assertEquals(3,rpa.read(ctx, t, "field").getValue()); // cached accessor used, +		assertTrue(rpa.canWrite(ctx, t, "property"));, +		rpa.write(ctx, t, "property", "goodbye");, +		rpa.write(ctx, t, "property", "goodbye"); // cached accessor used, +		assertTrue(rpa.canWrite(ctx, t, "field"));, +		rpa.write(ctx, t, "field", 12);, +		rpa.write(ctx, t, "field", 12);, +		rpa.write(ctx, t, "field2", 3);, +		rpa.write(ctx, t, "property2", "doodoo");, +		assertEquals(3,rpa.read(ctx, t, "field2").getValue());, +		assertEquals(0,rpa.read(ctx, t, "field3").getValue());, +		assertEquals("doodoo",rpa.read(ctx, t, "property3").getValue());, +		assertEquals(0,rpa .read(ctx, t, "field3").getValue());, +		assertEquals(false,rpa.read(ctx, t, "property4").getValue());, +		assertTrue(rpa.canRead(ctx, t, "property4"));, +		assertEquals("iD",rpa.read(ctx, t, "iD").getValue());, +		assertTrue(rpa.canRead(ctx, t, "iD"));, +		assertEquals("id",rpa.read(ctx, t, "id").getValue());, +		assertTrue(rpa.canRead(ctx, t, "id"));, +		assertEquals("ID",rpa.read(ctx, t, "ID").getValue());, +		assertTrue(rpa.canRead(ctx, t, "ID"));, +		assertEquals("id",rpa.read(ctx, t, "Id").getValue());, +		assertTrue(rpa.canRead(ctx, t, "Id"));, +		assertEquals("xyZ",rpa.read(ctx, t, "xyZ").getValue());, +		assertTrue(rpa.canRead(ctx, t, "xyZ"));, +		assertEquals("xY",rpa.read(ctx, t, "xY").getValue());, +		assertTrue(rpa.canRead(ctx, t, "xY"));, +		rpa.write(ctx, t, "pEBS", "Test String");, +		assertEquals("Test String",rpa.read(ctx, t, "pEBS").getValue());, +	public void testOptimalReflectivePropertyAccessor() throws Exception {, +		ReflectivePropertyAccessor rpa = new ReflectivePropertyAccessor();, +		assertTrue(rpa.canRead(ctx, t, "property"));, +		assertEquals("hello", rpa.read(ctx, t, "property").getValue());, +		assertEquals("hello", rpa.read(ctx, t, "property").getValue()); // cached accessor used, +		PropertyAccessor optA = rpa.createOptimalAccessor(ctx, t, "property");, +		optA = rpa.createOptimalAccessor(ctx, t, "field");, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/support/ReflectionHelperTests.java, + * Tests for reflection helper code., +		assertEquals("java.lang.String[]", FormatHelper.formatClassNameForMessage(String[].class));, +		assertEquals("java.lang.String[][]", FormatHelper.formatClassNameForMessage(String[][].class));, +		assertEquals("int[]", FormatHelper.formatClassNameForMessage(int[].class));, +		assertEquals("int[][]", FormatHelper.formatClassNameForMessage(int[][].class));, +		checkMatch2(new Class<?>[] {String[].class}, new Class<?>[] {String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Integer.class, String[].class}, new Class<?>[] {Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {String.class, Integer.class, String[].class}, new Class<?>[] {String.class,Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Sub.class, String[].class}, new Class<?>[] {Super.class,String[].class}, tc, ArgumentsMatchKind.CLOSE);, +		checkMatch2(new Class<?>[] {Integer.class, String[].class}, new Class<?>[] {String.class, String[].class}, tc, ArgumentsMatchKind.REQUIRES_CONVERSION);, +		checkMatch2(new Class<?>[] {String.class}, new Class<?>[] {String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {Integer.class, String.class}, new Class<?>[] {Integer.class, String[].class}, tc, ArgumentsMatchKind.EXACT);, +		checkMatch2(new Class<?>[] {String.class}, new Class<?>[] {Integer[].class}, tc, ArgumentsMatchKind.REQUIRES_CONVERSION);, +		checkMatch2(new Class<?>[] {Sub.class}, new Class<?>[] {Super[].class}, tc, ArgumentsMatchKind.CLOSE);, +		checkMatch2(new Class<?>[] {Super.class}, new Class<?>[] {Sub[].class}, tc, null);, +				new Class<?>[] {String[].class}, "a", "b", "c");, +	public void testReflectivePropertyAccessor() throws Exception {, +		ReflectivePropertyAccessor rpa = new ReflectivePropertyAccessor();, +		assertTrue(rpa.canRead(ctx, t, "property"));, +		assertEquals("hello",rpa.read(ctx, t, "property").getValue());, +		assertEquals("hello",rpa.read(ctx, t, "property").getValue()); // cached accessor used, +		assertTrue(rpa.canRead(ctx, t, "field"));, +		assertEquals(3,rpa.read(ctx, t, "field").getValue());, +		assertEquals(3,rpa.read(ctx, t, "field").getValue()); // cached accessor used, +		assertTrue(rpa.canWrite(ctx, t, "property"));, +		rpa.write(ctx, t, "property", "goodbye");, +		rpa.write(ctx, t, "property", "goodbye"); // cached accessor used, +		assertTrue(rpa.canWrite(ctx, t, "field"));, +		rpa.write(ctx, t, "field", 12);, +		rpa.write(ctx, t, "field", 12);, +		rpa.write(ctx, t, "field2", 3);, +		rpa.write(ctx, t, "property2", "doodoo");, +		assertEquals(3,rpa.read(ctx, t, "field2").getValue());, +		assertEquals(0,rpa.read(ctx, t, "field3").getValue());, +		assertEquals("doodoo",rpa.read(ctx, t, "property3").getValue());, +		assertEquals(0,rpa .read(ctx, t, "field3").getValue());, +		assertEquals(false,rpa.read(ctx, t, "property4").getValue());, +		assertTrue(rpa.canRead(ctx, t, "property4"));, +		assertEquals("iD",rpa.read(ctx, t, "iD").getValue());]