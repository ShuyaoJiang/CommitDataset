[+++ b/spring-messaging/src/test/java/org/springframework/messaging/handler/invocation/AbstractMethodMessageHandlerTests.java, +/*, + * Copyright 2002-2014 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.messaging.handler.invocation;, +, +import org.hamcrest.Matchers;, +import org.junit.Before;, +import org.junit.Test;, +, +import org.springframework.beans.DirectFieldAccessor;, +import org.springframework.context.support.StaticApplicationContext;, +import org.springframework.messaging.Message;, +import org.springframework.messaging.handler.DestinationPatternsMessageCondition;, +import org.springframework.messaging.handler.HandlerMethod;, +import org.springframework.messaging.handler.HandlerMethodSelector;, +import org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolver;, +import org.springframework.messaging.support.MessageBuilder;, +import org.springframework.messaging.support.MessageHeaderAccessor;, +import org.springframework.util.AntPathMatcher;, +import org.springframework.util.PathMatcher;, +import org.springframework.util.ReflectionUtils.MethodFilter;, +, +import java.lang.reflect.Method;, +import java.util.*;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertThat;, +, +/**, + * Test fixture for {@link org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler}., + * @author Brian Clozel, + */, +public class AbstractMethodMessageHandlerTests {, +, +	private static final String DESTINATION_HEADER = "testDestination";, +, +	private MyMethodMessageHandler messageHandler;, +, +	private TestController testController;, +, +	@Before, +	public void setup() {, +		List<String> destinationPrefixes = new ArrayList<String>();, +		destinationPrefixes.add("/test/");, +, +		this.messageHandler = new MyMethodMessageHandler();, +		this.messageHandler.setApplicationContext(new StaticApplicationContext());, +		this.messageHandler.setDestinationPrefixes(destinationPrefixes);, +		this.messageHandler.afterPropertiesSet();, +		this.testController = new TestController();, +		this.messageHandler.registerHandler(this.testController);, +	}, +, +	@Test(expected=IllegalStateException.class), +	public void duplicateMapping() {, +		this.messageHandler.registerHandler(new DuplicateMappingsController());, +	}, +, +	@Test, +	public void registeredMappings() {, +, +		DirectFieldAccessor fieldAccessor = new DirectFieldAccessor(this.messageHandler);, +		Map<String, HandlerMethod> handlerMethods = (Map<String, HandlerMethod>), +				fieldAccessor.getPropertyValue("handlerMethods");, +, +		assertNotNull(handlerMethods);, +		assertThat(handlerMethods.keySet(), Matchers.hasSize(3));, +	}, +, +	@Test, +	public void antPatchMatchWildcard() throws Exception {, +, +		Method method = this.testController.getClass().getMethod("handlerPathMatchWildcard");, +		this.messageHandler.registerHandlerMethod(this.testController, method, "/handlerPathMatch**");, +, +		MessageHeaderAccessor headers = new MessageHeaderAccessor();, +		headers.setHeader(DESTINATION_HEADER, "/test/handlerPathMatchFoo");, +		Message<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		this.messageHandler.handleMessage(message);, +, +		assertEquals("pathMatchWildcard", this.testController.method);, +	}, +, +	@Test, +	public void bestMatchWildcard() throws Exception {]