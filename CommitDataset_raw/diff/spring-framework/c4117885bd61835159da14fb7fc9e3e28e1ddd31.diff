[+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private static final char[] WILDCARD_CHARS = { '*', '?', '{' };, +, +	private final Map<String, String[]> tokenizedPatternCache = new ConcurrentHashMap<String, String[]>(256);, +		String[] pattDirs = tokenizePattern(pattern);, +		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {, +, +	private boolean isPotentialMatch(String path, String[] pattDirs) {, +		char[] pathChars = path.toCharArray();, +		int pos = 0;, +		for (String pattDir : pattDirs) {, +			int count = countStartsWith(pathChars, pos, this.pathSeparator, false);, +			pos += (count == this.pathSeparator.length() ? count : 0);, +			count = countStartsWith(pathChars, pos, pattDir, true);, +			if (count < pattDir.length()) {, +				if (count > 0) {, +					return true;, +				}, +				return (pattDir.length() > 0) && isWildcardChar(pattDir.charAt(0));, +			}, +			pos += count;, +		}, +		return true;, +	}, +, +	private int countStartsWith(char[] chars, int pos, String prefix, boolean stopOnWildcard) {, +		int count = 0;, +		for (char c : prefix.toCharArray()) {, +			if (stopOnWildcard && isWildcardChar(c)) {, +				return count;, +			}, +			if (pos + count >= chars.length) {, +				return 0;, +			}, +			if (chars[pos + count] == c) {, +				count++;, +			}, +		}, +		return count;, +	}, +, +	private boolean isWildcardChar(char c) {, +		for (char candidate : WILDCARD_CHARS) {, +			if (c == candidate) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	protected String[] tokenizePattern(String pattern) {, +		String[] tokenized = null;, +			tokenized = tokenizePath(pattern);, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, +	private static final char[] WILDCARD_CHARS = { '*', '?', '{' };, +, +	private final Map<String, String[]> tokenizedPatternCache = new ConcurrentHashMap<String, String[]>(256);, +		String[] pattDirs = tokenizePattern(pattern);, +		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {, +, +	private boolean isPotentialMatch(String path, String[] pattDirs) {, +		char[] pathChars = path.toCharArray();, +		int pos = 0;, +		for (String pattDir : pattDirs) {, +			int count = countStartsWith(pathChars, pos, this.pathSeparator, false);, +			pos += (count == this.pathSeparator.length() ? count : 0);, +			count = countStartsWith(pathChars, pos, pattDir, true);, +			if (count < pattDir.length()) {, +				if (count > 0) {, +					return true;, +				}, +				return (pattDir.length() > 0) && isWildcardChar(pattDir.charAt(0));, +			}, +			pos += count;, +		}, +		return true;, +	}, +, +	private int countStartsWith(char[] chars, int pos, String prefix, boolean stopOnWildcard) {, +		int count = 0;, +		for (char c : prefix.toCharArray()) {, +			if (stopOnWildcard && isWildcardChar(c)) {, +				return count;, +			}, +			if (pos + count >= chars.length) {, +				return 0;, +			}, +			if (chars[pos + count] == c) {, +				count++;, +			}, +		}, +		return count;, +	}, +, +	private boolean isWildcardChar(char c) {, +		for (char candidate : WILDCARD_CHARS) {, +			if (c == candidate) {, +				return true;, +			}, +		}]