[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2010 the original author or authors., + * <p>Functions are very simplistic, the arguments are not part of the definition (right now),, + * so the names must be unique., +		}, +		catch (SpelEvaluationException se) {, +	private TypedValue executeFunctionJLRMethod(ExpressionState state, Method method) throws EvaluationException {, +		if (!method.isVarArgs() && method.getParameterTypes().length != functionArgs.length) {, +			throw new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,, +					functionArgs.length, method.getParameterTypes().length);, +		if (!Modifier.isStatic(method.getModifiers())) {, +			throw new SpelEvaluationException(getStartPosition(), SpelMessage.FUNCTION_MUST_BE_STATIC, method, +					+ "." + method.getName(), name);, +			ReflectionHelper.convertAllArguments(converter, functionArgs, method);, +		if (method.isVarArgs()) {, +			functionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(method.getParameterTypes(), functionArgs);, +			ReflectionUtils.makeAccessible(method);, +			Object result = method.invoke(method.getClass(), functionArgs);, +			return new TypedValue(result, new TypeDescriptor(new MethodParameter(method,-1)));, +		}, +		catch (Exception ex) {, +			throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,, +					this.name, ex.getMessage());, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2010 the original author or authors., + * <p>Functions are very simplistic, the arguments are not part of the definition (right now),, + * so the names must be unique., +		}, +		catch (SpelEvaluationException se) {, +	private TypedValue executeFunctionJLRMethod(ExpressionState state, Method method) throws EvaluationException {, +		if (!method.isVarArgs() && method.getParameterTypes().length != functionArgs.length) {, +			throw new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,, +					functionArgs.length, method.getParameterTypes().length);, +		if (!Modifier.isStatic(method.getModifiers())) {, +			throw new SpelEvaluationException(getStartPosition(), SpelMessage.FUNCTION_MUST_BE_STATIC, method, +					+ "." + method.getName(), name);, +			ReflectionHelper.convertAllArguments(converter, functionArgs, method);, +		if (method.isVarArgs()) {, +			functionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(method.getParameterTypes(), functionArgs);, +			ReflectionUtils.makeAccessible(method);, +			Object result = method.invoke(method.getClass(), functionArgs);, +			return new TypedValue(result, new TypeDescriptor(new MethodParameter(method,-1)));, +		}, +		catch (Exception ex) {, +			throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,, +					this.name, ex.getMessage());, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +import java.lang.reflect.Method;, +import org.springframework.core.MethodParameter;, + * Utility methods used by the reflection resolver code to discover the appropriate, +	 * Compare argument arrays and return information about whether they match. A supplied type converter, +	 * and conversionAllowed flag allow for matches to take into account that a type may be transformed, +	 * into a different type by the converter., +	static ArgumentsMatchInfo compareArguments(, +	static ArgumentsMatchInfo compareArgumentsVarargs(, +		Assert.isTrue(expectedArgTypes != null && expectedArgTypes.length > 0,, +				"Expected arguments must at least include one array (the vargargs parameter)");, +		Assert.isTrue(expectedArgTypes[expectedArgTypes.length - 1].isArray(),, +				"Final expected argument should be array type (the varargs parameter)");, +	 * Takes an input set of argument values and, following the positions specified in the int array,, +	 * it converts them to the types specified as the required parameter types. The arguments are, +	 * converted 'in-place' in the input array., +	 * @param methodOrCtor the target Method or Constructor, +	 * @param argumentsRequiringConversion details which of the input arguments need conversion, +	 * @param varargsPosition the known position of the varargs argument, if any, +	static void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,, +			int[] argumentsRequiringConversion, Integer varargsPosition) throws EvaluationException {, +		for (int argPosition : argumentsRequiringConversion) {, +			TypeDescriptor targetType;, +			if (varargsPosition != null && argPosition >= varargsPosition) {, +				MethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition);, +				targetType = new TypeDescriptor(methodParam, methodParam.getParameterType().getComponentType());, +				targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, argPosition));, +			arguments[argPosition] = converter.convertValue(, +					arguments[argPosition], TypeDescriptor.forObject(arguments[argPosition]), targetType);, +	 * @param method the target Method, +	public static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {, +		Integer varargsPosition = null;, +		if (method.isVarArgs()) {, +			Class[] paramTypes = method.getParameterTypes();, +			varargsPosition = paramTypes.length - 1;, +		for (int argPosition = 0; argPosition < arguments.length; argPosition++) {, +			TypeDescriptor targetType;, +			if (varargsPosition != null && argPosition >= varargsPosition) {, +				MethodParameter methodParam = new MethodParameter(method, varargsPosition);, +				targetType = new TypeDescriptor(methodParam, methodParam.getParameterType().getComponentType());, +				targetType = new TypeDescriptor(new MethodParameter(method, argPosition));, +				Object argument = arguments[argPosition];, +				if (argument != null && !targetType.getObjectType().isInstance(argument)) {, +						throw new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType);, +					arguments[argPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);, +					throw new SpelEvaluationException(ex, SpelMessage.TYPE_CONVERSION_ERROR,arguments[argPosition].getClass().getName(), targetType);, +		if (parameterCount != args.length ||, +				requiredParameterTypes[parameterCount - 1] !=, +						(args[argumentCount - 1] == null ? null : args[argumentCount - 1].getClass())) {, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, + * Copyright 2002-2010 the original author or authors., + * <p>Functions are very simplistic, the arguments are not part of the definition (right now),, + * so the names must be unique., +		}]