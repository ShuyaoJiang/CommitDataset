[+++ b/spring-web/src/main/java/org/springframework/http/converter/AbstractGenericHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +			streamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {, +				public OutputStream getBody() {, +			}));, +++ b/spring-web/src/main/java/org/springframework/http/converter/AbstractGenericHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +			streamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {, +				public OutputStream getBody() {, +			}));, +++ b/spring-web/src/main/java/org/springframework/http/converter/json/GsonHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.ParameterizedType;, + * <p>Tested against Gson 2.8; compatible with Gson 2.0 and higher., +		// In Gson, toJson with a type argument will exclusively use that given type,, +		// ignoring the actual type of the object... which might be more specific,, +		// e.g. a subclass of the specified type which includes additional fields., +		// As a consequence, we're only passing in parameterized type declarations, +		// which might contain extra generics that the object instance doesn't retain., +		if (type instanceof ParameterizedType) {, +++ b/spring-web/src/main/java/org/springframework/http/converter/AbstractGenericHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +			streamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {, +				public OutputStream getBody() {, +			}));, +++ b/spring-web/src/main/java/org/springframework/http/converter/json/GsonHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.ParameterizedType;, + * <p>Tested against Gson 2.8; compatible with Gson 2.0 and higher., +		// In Gson, toJson with a type argument will exclusively use that given type,, +		// ignoring the actual type of the object... which might be more specific,, +		// e.g. a subclass of the specified type which includes additional fields., +		// As a consequence, we're only passing in parameterized type declarations, +		// which might contain extra generics that the object instance doesn't retain., +		if (type instanceof ParameterizedType) {, +++ b/spring-web/src/main/java/org/springframework/http/converter/json/JsonbHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.ParameterizedType;, +		if (type instanceof ParameterizedType) {, +++ b/spring-web/src/main/java/org/springframework/http/converter/AbstractGenericHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +			streamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {, +				public OutputStream getBody() {, +			}));, +++ b/spring-web/src/main/java/org/springframework/http/converter/json/GsonHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.ParameterizedType;, + * <p>Tested against Gson 2.8; compatible with Gson 2.0 and higher., +		// In Gson, toJson with a type argument will exclusively use that given type,, +		// ignoring the actual type of the object... which might be more specific,, +		// e.g. a subclass of the specified type which includes additional fields., +		// As a consequence, we're only passing in parameterized type declarations, +		// which might contain extra generics that the object instance doesn't retain., +		if (type instanceof ParameterizedType) {, +++ b/spring-web/src/main/java/org/springframework/http/converter/json/JsonbHttpMessageConverter.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.ParameterizedType;, +		if (type instanceof ParameterizedType) {, +++ b/spring-web/src/test/java/org/springframework/http/converter/json/GsonHttpMessageConverterTests.java, + * Copyright 2002-2018 the original author or authors., +import org.skyscreamer.jsonassert.JSONAssert;, + * @author Juergen Hoeller, +	public void writeWithBaseType() throws IOException {, +		MockHttpOutputMessage outputMessage = new MockHttpOutputMessage();, +		MyBean body = new MyBean();, +		body.setString("Foo");, +		body.setNumber(42);, +		body.setFraction(42F);, +		body.setArray(new String[] {"Foo", "Bar"});, +		body.setBool(true);, +		body.setBytes(new byte[] {0x1, 0x2});, +		this.converter.write(body, MyBase.class, null, outputMessage);, +		Charset utf8 = StandardCharsets.UTF_8;, +		String result = outputMessage.getBodyAsString(utf8);, +		assertTrue(result.contains("\"string\":\"Foo\""));, +		assertTrue(result.contains("\"number\":42"));, +		assertTrue(result.contains("fraction\":42.0"));, +		assertTrue(result.contains("\"array\":[\"Foo\",\"Bar\"]"));, +		assertTrue(result.contains("\"bool\":true"));, +		assertTrue(result.contains("\"bytes\":[1,2]"));, +		assertEquals("Invalid content-type", new MediaType("application", "json", utf8),, +				outputMessage.getHeaders().getContentType());, +	}, +, +	@Test, +	public void readAndWriteGenerics() throws Exception {, +, +		MockHttpOutputMessage outputMessage = new MockHttpOutputMessage();, +		converter.write(results, genericType, new MediaType("application", "json"), outputMessage);, +		JSONAssert.assertEquals(body, outputMessage.getBodyAsString(StandardCharsets.UTF_8), true);, +	public void readAndWriteParameterizedType() throws Exception {, +, +		MockHttpOutputMessage outputMessage = new MockHttpOutputMessage();, +		converter.write(results, beansList.getType(), new MediaType("application", "json"), outputMessage);, +		JSONAssert.assertEquals(body, outputMessage.getBodyAsString(StandardCharsets.UTF_8), true);, +	@SuppressWarnings("unchecked"), +	public void writeParameterizedBaseType() throws Exception {, +		ParameterizedTypeReference<List<MyBean>> beansList = new ParameterizedTypeReference<List<MyBean>>() {};, +		ParameterizedTypeReference<List<MyBase>> baseList = new ParameterizedTypeReference<List<MyBase>>() {};, +]