[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/config/HandlersBeanDefinitionParser.java, + * Parses the configuration for the {@code <websocket:handlers/>} namespace, + * element. Registers a Spring MVC {@code SimpleUrlHandlerMapping} to map HTTP, + * WebSocket handshake (or SockJS) requests to, + * {@link org.springframework.web.socket.WebSocketHandler WebSocketHandler}s., + * @author Rossen Stoyanchev, +	public BeanDefinition parse(Element element, ParserContext context) {, +		Object source = context.extractSource(element);, +		context.pushContainingComponent(compDefinition);, +		String handlerMappingName = context.getReaderContext().registerWithGeneratedName(handlerMappingDef);, +		RuntimeBeanReference sockJsService = WebSocketNamespaceUtils.registerSockJsService(, +				element, SOCK_JS_SCHEDULER_NAME, context, source);, +, +		HandlerMappingStrategy strategy;, +		if (sockJsService != null) {, +			strategy = new SockJsHandlerMappingStrategy(sockJsService);, +		}, +		else {, +			RuntimeBeanReference handshakeHandler = WebSocketNamespaceUtils.registerHandshakeHandler(element, context, source);, +			ManagedList<?> interceptors = WebSocketNamespaceUtils.parseBeanSubElements(interceptorsElement, context);, +			strategy = new WebSocketHandlerMappingStrategy(handshakeHandler, interceptors);, +		}, +		for(Element mappingElement : DomUtils.getChildElementsByTagName(element, "mapping")) {, +			strategy.addMapping(mappingElement, urlMap, context);, +		context.registerComponent(new BeanComponentDefinition(handlerMappingDef, handlerMappingName));, +		context.popAndRegisterContainingComponent();, +		void addMapping(Element mappingElement, ManagedMap<String, Object> map, ParserContext context);, +, +	private static class WebSocketHandlerMappingStrategy implements HandlerMappingStrategy {, +		private final RuntimeBeanReference handshakeHandlerReference;, +, +		private final ManagedList<?> interceptorsList;, +, +, +		private WebSocketHandlerMappingStrategy(RuntimeBeanReference handshakeHandler, ManagedList<?> interceptors) {, +			this.handshakeHandlerReference = handshakeHandler;, +			this.interceptorsList = interceptors;, +		public void addMapping(Element element, ManagedMap<String, Object> urlMap, ParserContext context) {, +			String pathAttribute = element.getAttribute("path");, +			List<String> mappings = Arrays.asList(StringUtils.tokenizeToStringArray(pathAttribute, ","));, +			RuntimeBeanReference handlerReference = new RuntimeBeanReference(element.getAttribute("handler"));, +			cavs.addIndexedArgumentValue(0, handlerReference);, +			requestHandlerDef.setSource(context.extractSource(element));, +			String requestHandlerName = context.getReaderContext().registerWithGeneratedName(requestHandlerDef);, +	private static class SockJsHandlerMappingStrategy implements HandlerMappingStrategy {, +		private final RuntimeBeanReference sockJsService;, +, +		private SockJsHandlerMappingStrategy(RuntimeBeanReference sockJsService) {, +			this.sockJsService = sockJsService;, +		public void addMapping(Element element, ManagedMap<String, Object> urlMap, ParserContext context) {, +			String pathAttribute = element.getAttribute("path");, +			List<String> mappings = Arrays.asList(StringUtils.tokenizeToStringArray(pathAttribute, ","));, +			RuntimeBeanReference handlerReference = new RuntimeBeanReference(element.getAttribute("handler"));, +			cavs.addIndexedArgumentValue(0, this.sockJsService, "SockJsService");, +			cavs.addIndexedArgumentValue(1, handlerReference, "WebSocketHandler");, +			requestHandlerDef.setSource(context.extractSource(element));, +			String requestHandlerName = context.getReaderContext().registerWithGeneratedName(requestHandlerDef);, +			for (String mapping : mappings) {, +				String pathPattern = (mapping.endsWith("/") ? mapping + "**" : mapping + "/**");, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/config/HandlersBeanDefinitionParser.java, + * Parses the configuration for the {@code <websocket:handlers/>} namespace, + * element. Registers a Spring MVC {@code SimpleUrlHandlerMapping} to map HTTP, + * WebSocket handshake (or SockJS) requests to, + * {@link org.springframework.web.socket.WebSocketHandler WebSocketHandler}s., + * @author Rossen Stoyanchev, +	public BeanDefinition parse(Element element, ParserContext context) {, +		Object source = context.extractSource(element);, +		context.pushContainingComponent(compDefinition);, +		String handlerMappingName = context.getReaderContext().registerWithGeneratedName(handlerMappingDef);, +		RuntimeBeanReference sockJsService = WebSocketNamespaceUtils.registerSockJsService(, +				element, SOCK_JS_SCHEDULER_NAME, context, source);, +, +		HandlerMappingStrategy strategy;, +		if (sockJsService != null) {, +			strategy = new SockJsHandlerMappingStrategy(sockJsService);, +		}, +		else {, +			RuntimeBeanReference handshakeHandler = WebSocketNamespaceUtils.registerHandshakeHandler(element, context, source);, +			ManagedList<?> interceptors = WebSocketNamespaceUtils.parseBeanSubElements(interceptorsElement, context);, +			strategy = new WebSocketHandlerMappingStrategy(handshakeHandler, interceptors);, +		}, +		for(Element mappingElement : DomUtils.getChildElementsByTagName(element, "mapping")) {, +			strategy.addMapping(mappingElement, urlMap, context);, +		context.registerComponent(new BeanComponentDefinition(handlerMappingDef, handlerMappingName));, +		context.popAndRegisterContainingComponent();, +		void addMapping(Element mappingElement, ManagedMap<String, Object> map, ParserContext context);, +, +	private static class WebSocketHandlerMappingStrategy implements HandlerMappingStrategy {, +		private final RuntimeBeanReference handshakeHandlerReference;, +, +		private final ManagedList<?> interceptorsList;, +, +, +		private WebSocketHandlerMappingStrategy(RuntimeBeanReference handshakeHandler, ManagedList<?> interceptors) {, +			this.handshakeHandlerReference = handshakeHandler;, +			this.interceptorsList = interceptors;, +		public void addMapping(Element element, ManagedMap<String, Object> urlMap, ParserContext context) {, +			String pathAttribute = element.getAttribute("path");, +			List<String> mappings = Arrays.asList(StringUtils.tokenizeToStringArray(pathAttribute, ","));, +			RuntimeBeanReference handlerReference = new RuntimeBeanReference(element.getAttribute("handler"));]