[+++ b/org.springframework.web/src/main/java/org/springframework/web/util/UriComponents.java, + * getters for all components. Effectively similar to {@link URI}, but with more powerful encoding options and support, + * for URI template variables., +	/**, +	 * Package-friendly constructor that creates a new {@code UriComponents} instance from the given parameters. All, +	 * parameters are optional, and can be {@code null}., +	 *, +	 * @param scheme the scheme, +	 * @param userInfo the user info, +	 * @param host the host, +	 * @param port the port, +	 * @param path the path component, +	 * @param queryParams the query parameters, +	 * @param fragment the fragment, +	 * @param encoded whether the components are encoded, +	 * @param verify whether the components need to be verified to determine whether they contain illegal characters, +	 */, +				  boolean encoded,, +				  boolean verify) {, +		this.queryParams = CollectionUtils.unmodifiableMultiValueMap(, +				queryParams != null ? queryParams : new LinkedMultiValueMap<String, String>(0));, +		if (verify) {, +			verify();, +		}, +				encodedQueryParams, encodedFragment, true, false);, +	// verifying, +, +	/**, +	 * Verifies all URI components to determine whether they contain any illegal characters, throwing an, +	 * {@code IllegalArgumentException} if so., +	 *, +	 * @throws IllegalArgumentException if any of the components contain illegal characters, +	 */, +	private void verify() {, +		if (!encoded) {, +			return;, +		}, +		verifyUriComponent(scheme, Type.SCHEME);, +		verifyUriComponent(userInfo, Type.USER_INFO);, +		verifyUriComponent(host, Type.HOST);, +		path.verify();, +		for (Map.Entry<String, List<String>> entry : queryParams.entrySet()) {, +			verifyUriComponent(entry.getKey(), Type.QUERY_PARAM);, +			for (String value : entry.getValue()) {, +				verifyUriComponent(value, Type.QUERY_PARAM);, +			}, +		}, +		verifyUriComponent(fragment, Type.FRAGMENT);, +	}, +, +, +	private static void verifyUriComponent(String source, Type type) {, +		if (source == null) {, +			return;, +		}, +, +		int length = source.length();, +, +		for (int i=0; i < length; i++) {, +			char ch = source.charAt(i);, +			if (ch == '%') {, +				if ((i + 2) < length) {, +					char hex1 = source.charAt(i + 1);, +					char hex2 = source.charAt(i + 2);, +					int u = Character.digit(hex1, 16);, +					int l = Character.digit(hex2, 16);, +					if (u == -1 || l == -1) {, +						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"");, +					}, +					i += 2;, +				}, +				else {, +					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"");, +				}, +			}, +			else if (!type.isAllowed(ch)) {, +				throw new IllegalArgumentException(, +						"Invalid character '" + ch + "' for " + type.name() + " in \"" + source + "\"");, +			}, +		}, +	}, +, +				expandedQueryParams, expandedFragment, false, false);, +     * Contains methods to indicate whether a given character is valid in a specific URI component., +		void verify();, +, +		public void verify() {, +			verifyUriComponent(path, Type.PATH);, +		}, +, +		public void verify() {, +			for (String pathSegment : getPathSegments()) {, +				verifyUriComponent(pathSegment, Type.PATH_SEGMENT);, +			}, +		}, +, +		public void verify() {, +			for (PathComponent pathComponent : pathComponents) {, +				pathComponent.verify();, +			}]