[+++ b/spring-framework-reference/src/expressions.xml, +    expression language implementations to be integreated should the need, +    independently. In order to be self contained, many of the examples in this, +    chatper use SpEL as if it was an independent expression language. This, +    requires creating a few boostrapping infrastructure classes such as the, +    parser. Most Spring users will not need to deal with this infrastructure, +    and will instead only author expression strings for evaluation. An example, +    of this typical use is the integration of SpEL into creating XML or, +    annotated based bean definitions as shown in the section <link, +    <para>This chapter covers the features of the expression language, its, +    API, and its language sytnax. In several places an Inventor and Inventor's, +    Society class are used as the target objects for expression evaluation., +    These class declarations and the data used to populate them are listed at, +    the end of the chapter. </para>, +    <para>This section introduces the simple use of SpEL interfaces and its, +    <para><programlisting language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +    <para>The SpEL classes and interfaces you are most likely to use are, +    located in the packages <package>org.springframework.expression</package>, +    and its subpackages <package>spel.antlr</package> and, +    <package>spel.support</package>.</para>, +, +    an expression string. In this example the expression string is a string, +    literal denoted by the surrounding single quotes. The interface, +    <para>As an example of method invocation, we call the 'concat' method on, +    <programlisting lang="" language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +    <programlisting language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +    prop1.prop2.prop3 and the setting of property values</para>, +    <programlisting language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +    <para>The String's constructor can be called instead of using a string, +    <programlisting language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +    <para><programlisting language="java">// Create and set a calendar , +GregorianCalendar c = new GregorianCalendar();, +Expression exp = parser.parseExpression("<emphasis role="bold">name</emphasis>");, +    Tesla". The class StandardEvaluationContext is where you can specify which, +    object the "Name" property will be evaluated against. You can reuse the, +    same expression over and over again and set a new root object on the, +    evaluation context. Expressions are evaluated using reflection. </para>, +        is to provide only the SpEL expression string as part of a, +        configuration file, for example for Spring bean or Spring Web Flow, +        definitions. In this case, the parser, evaluation context, root object, +        and any predefined variables will be set up for you implicitly.</para>, +      </note>As a final introductory example, the use of a boolean operator is, +    shown using the Inventor object in the previous example</para>, +, +    <programlisting language="java">Expression exp = parser.parseExpression("name == 'Nikola Tesla'");, +boolean isEqual = exp.getValue(context, Boolean.class);  // evaluates to true</programlisting>, +      ,fields, and to help perform type conversion. The out-of-the-box, +      reflection to manipulate the object, caching, +      j<package>ava.lang.reflect</package>'s <classname>Method</classname>,, +      <classname>Field</classname>, and <classname>Constructor</classname>, +      instances for increased performance.</para>, +      and functions that will be used in the expression using the methods, +      <methodname>setVariable</methodname> and, +      <methodname>registerFunction</methodname>. The use of variables and, +      functions are described in the language reference sections <link, +      linkend="expressions-ref-variables">Variables</link> and <link lang="", +      linkend="expressions-ref-functions">Functions</link>.</para>, +      <programlisting language="xml">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;, +      <programlisting language="xml">&lt;bean id="taxCalculator" class="org.spring.samples.TaxCalculator"&gt;, +      <para><programlisting language="xml">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;, +      <para>The <literal>@Value</literal> annotation can be placed on fields,, +      methods and method/constructor parameters to specify a default, +      value.</para>, +      <programlisting language="java">public static class FieldValueTestBean, +      <programlisting language="java">public static class PropertyValueTestBean, +      <programlisting language="java">public class SimpleMovieLister {, +      <para><programlisting language="java">public class MovieRecommender {, +    <section id="expressions-ref-literal">, +      <para>The types of literal expressions supported are strings, dates,, +      numeric values (int, real, and hex), boolean and null. String are, +      delimited by single quotes. To put a single quote itself in a string use, +      the backslash character. The following listing shows simple usage of, +      literals. Typically they would not be used in isolation like this, but, +      as part of a more complex expression, for example using a literal on one, +      side of a logical comparison operator. </para>, +, +      <programlisting language="java">ExpressionParser parser = new SpelAntlrExpressionParser();, +, +String helloWorld = (String) parser.parseExpression("'Hello World'").getValue(); // evals to "Hello World", +, +double avogadrosNumber  = (Double) parser.parseExpression("6.0221415E+23").getValue();  , +, +int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();  // evals to 2147483647, +, +boolean trueValue = (Boolean) parser.parseExpression("true").getValue();, +, +Object nullValue = parser.parseExpression("null").getValue();, +</programlisting>, +, +      <para>Numbers support the use of the negative sign, exponential, +      notation, and decimal points. By default real numbers are parsed using, +      Double.parseDouble().</para>, +      <para>Navigating through properties is easy, just use a period to, +      indicate a nested property value. The instances of Inventor class, pupin, +      and tesla, were populated with data listed in section Section <link, +      linkend="expressions-examples-classes">Classes used in the, +      examples</link>. To navigate "down" and get Tesla's year of birth and, +      Pupin's city of birth the following expressions are used </para>, +, +      <programlisting lang="" language="java">int year = (Integer) parser.parseExpression("Birthdate.Year + 1900").getValue(context); // 1856]