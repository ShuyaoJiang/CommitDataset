[+++ b/spring-framework-reference/src/transaction.xml, +  <title>Transaction Management</title>, +    <title>Introduction to Spring Framework transaction management</title>, +    <para>Comprehensive transaction support is among the most compelling, +    reasons to use Spring Framework. Spring Framework provides a consistent, +    abstraction for transaction management that delivers the following, +    benefits:</para>, +        <para>Consistent programming model across different transaction APIs, +        such as Java Transaction API (JTA), JDBC, Hibernate, Java Persistence, +        API (JPA), and Java Data Objects (JDO).</para>, +        <para>Support for <link linkend="transaction-declarative">declarative, +        <para>Simpler API for <link, +        management than complex transaction APIs such as JTA.</para>, +        <para>Excellent integration with Spring's data access, +    <para>The following sections describe Spring Framework's transaction, +    value-adds and technologies. (The chapter also includes discussions of, +    best practices, application server integration, and solutions to common, +    problems.)</para>, +        <para><link linkend="transaction-motivation">Advantages of Spring, +        Framework's transaction support model</link> describes, +        <emphasis>why</emphasis> you would use Spring Framework's transaction, +        abstraction instead of EJB Container-Managed Transactions (CMT) or, +        choosing to drive transactions through a proprietary API such as, +        Hibernate.</para>, +, +        <!--The section (formerly called Motivation) does not mention Hibernate. It talks about local and global.-->, +        <para><link linkend="transaction-strategies">Understanding the Spring, +        Framework transaction abstraction</link> outlines the core classes and, +        describes how to configure and obtain, +        <interfacename>DataSource</interfacename> instances from a variety of, +        sources.</para>, +        <para><link linkend="tx-resource-synchronization">Synchronizing, +        resources with transactions </link>describes how the application code, +        ensures that resources are created, reused, and cleaned up, +        properly.<!--Added above link and bullet item.--></para>, +        <para><link linkend="transaction-declarative">Declarative transaction, +        management</link> describes support for declarative transaction, +, +      <listitem>, +        <para><link linkend="transaction-programmatic">Programmatic, +        transaction management</link> covers support for programmatic (that, +        is, explicitly coded) transaction management.</para>, +      </listitem>, +    <title>Advantages of Spring Framework's transaction support model<!--Renamed section to make it more to the point.--></title>, +    <para>Traditionally, Java EE developers have had two choices for, +    transaction management: <emphasis>global</emphasis> or, +    <emphasis>local</emphasis> transactions, both of which have profound, +    limitations. Global and local transaction management is reviewed in the, +    next two sections, followed by a discussion of how Spring Framework's, +    transaction management support addresses the limitations of the global and, +    local transaction models.</para>, +    <!--Gave global, local, and spring models their own sections. These need to be called out at a higher level, esp. Spring advantage!-->, +    <section>, +      <title>Global transactions</title>, +      <para>Global transactions enable you to work with multiple transactional, +      resources, typically relational databases and message queues. The, +      application server manages global transactions through the JTA, which is, +      a cumbersome API to use (partly due to its exception model)., +      Furthermore, a JTA <interfacename>UserTransaction</interfacename>, +      normally needs to be sourced from JNDI, meaning that you, +      <emphasis>also</emphasis> need to use JNDI in order to use JTA., +      Obviously the use of global transactions would limit any potetntial, +      reuse of application code, as JTA is normally only available in an, +      application server environment.</para>, +      JNDI lookups, although of course the use of EJB itself necessitates the, +      use of JNDI. It removes most but not all of the need to write Java code, +      to control transactions. The significant downside is that CMT is tied to, +      JTA and an application server environment. Also, it is only available if, +      one chooses to implement business logic in EJBs, or at least behind a, +      transactional EJB facade. The negatives of EJB in general are so great, +      that this is not an attractive proposition, especially in the face of, +      compelling alternatives for declarative transaction management.</para>, +    </section>, +    <section>, +      <title>Local transactions</title>, +      <para>Local transactions are resource-specific, such as a transaction, +      associated with a JDBC connection. Local transactions may be easier to, +      use, but have significant disadvantages: they cannot work across, +      multiple transactional resources. For example, code that manages, +      transactions using a JDBC connection cannot run within a global JTA, +      transaction. Because the application server is not involved in, +      transaction management, it cannot help ensure correctness across, +      multiple resources. (It is worth noting that most applications use a, +      single transaction resource.) Another downside is that local, +      transactions are invasive to the programming model.</para>, +    </section>, +    <section>, +      <title>Spring Framework's consistent programming model</title>, +, +      <para>Spring resolves the disadvantages of global and local, +      transactions. It enables application developers to use a, +      <emphasis>consistent</emphasis> programming model <emphasis>in any, +      environment</emphasis>. You write your code once, and it can benefit, +      from different transaction management strategies in different, +      environments. Spring Framework provides both declarative and, +      programmatic transaction management. Most users prefer declarative, +      transaction management, which is recommended in most cases.</para>, +, +      <!--Do you need to specify that Spring allows you to work with *multiple* transactional resourcess (as global transactions do)?-->, +      underlying transaction infrastructure. <!--Re preceding statement, does this mean that next section re transaction abstraction applies only to programmatic tx management?If so--><!--shouldn't the next section be subsection of *Programmatic transaction management* section? However, there is a sentence in the next--><!--section that reads *regardless of whether you opt for declarative or prog. tx man. defining correct PlatformTransactionManager impl. is--><!--absolutely essential.* This is followed by discussion of that impl. So I'm not sure what goes where.]