[+++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/cache.xml, +			Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below)., +		<para>For cases where the cache needs to be updated without interfering with the method execution, one can use the <literal>@CachePut</literal> annotation. That is, the method will always, +		<para>Note that using <literal>@CachePut</literal> and <literal>@Cacheable</literal> annotations on the same method is generally discouraged because they have different behaviours. While the latter, +		mentioned <link linkend="cache-annotation-enable">above</link>, the annotation-driven behaviour needs to be enabled.</para>, +		methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create, +		<para>The <literal>CompositeCacheManager</literal> above chains multiple <literal>CacheManager</literal>s and additionally, through the <literal>addNoOpManager</literal> flag, adds a, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/cache.xml, +			Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below)., +		<para>For cases where the cache needs to be updated without interfering with the method execution, one can use the <literal>@CachePut</literal> annotation. That is, the method will always, +		<para>Note that using <literal>@CachePut</literal> and <literal>@Cacheable</literal> annotations on the same method is generally discouraged because they have different behaviours. While the latter, +		mentioned <link linkend="cache-annotation-enable">above</link>, the annotation-driven behaviour needs to be enabled.</para>, +		methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create, +		<para>The <literal>CompositeCacheManager</literal> above chains multiple <literal>CacheManager</literal>s and additionally, through the <literal>addNoOpManager</literal> flag, adds a, +++ b/src/reference/docbook/classic-aop-spring.xml, +      instances of the target to grow the pool as necessary. See the Javadoc, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/cache.xml, +			Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below)., +		<para>For cases where the cache needs to be updated without interfering with the method execution, one can use the <literal>@CachePut</literal> annotation. That is, the method will always, +		<para>Note that using <literal>@CachePut</literal> and <literal>@Cacheable</literal> annotations on the same method is generally discouraged because they have different behaviours. While the latter, +		mentioned <link linkend="cache-annotation-enable">above</link>, the annotation-driven behaviour needs to be enabled.</para>, +		methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create, +		<para>The <literal>CompositeCacheManager</literal> above chains multiple <literal>CacheManager</literal>s and additionally, through the <literal>addNoOpManager</literal> flag, adds a, +++ b/src/reference/docbook/classic-aop-spring.xml, +      instances of the target to grow the pool as necessary. See the Javadoc, +++ b/src/reference/docbook/expressions.xml, +String expression =  "isMember('Nikola Tesla') or isMember('Albert Einstein')";, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/cache.xml, +			Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below)., +		<para>For cases where the cache needs to be updated without interfering with the method execution, one can use the <literal>@CachePut</literal> annotation. That is, the method will always, +		<para>Note that using <literal>@CachePut</literal> and <literal>@Cacheable</literal> annotations on the same method is generally discouraged because they have different behaviours. While the latter, +		mentioned <link linkend="cache-annotation-enable">above</link>, the annotation-driven behaviour needs to be enabled.</para>, +		methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create, +		<para>The <literal>CompositeCacheManager</literal> above chains multiple <literal>CacheManager</literal>s and additionally, through the <literal>addNoOpManager</literal> flag, adds a, +++ b/src/reference/docbook/classic-aop-spring.xml, +      instances of the target to grow the pool as necessary. See the Javadoc, +++ b/src/reference/docbook/expressions.xml, +String expression =  "isMember('Nikola Tesla') or isMember('Albert Einstein')";, +++ b/src/reference/docbook/jdbc.xml, +    <lineannotation>// notice the wrapping up of the arguments in an array</lineannotation>, +      <interfacename>DatabaseMetaData</interfacename>. The codes for the actual, +      <programlisting language="java"><lineannotation>private JdbcTemplate jdbcTemplate;, +    // use the <classname>prepared JdbcTemplate</classname> for this <classname>update</classname></lineannotation>, +      total number of update objects provided. The update count for each update, +      statement is the one reported by the JDBC driver. If the count is not, +          indicate the SQL type of the corresponding parameter using constant, +      database and there are some DROP statements in the scripts which would, +++ b/src/reference/docbook/aop.xml, +        cannot be overridden.</para>, +++ b/src/reference/docbook/beans-classpath-scanning.xml, +      stereotype annotations and they will be automatically detected during, +++ b/src/reference/docbook/beans.xml, +          provides a convenient mechanism for reading an InputStream from, +++ b/src/reference/docbook/cache.xml, +			Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below)., +		<para>For cases where the cache needs to be updated without interfering with the method execution, one can use the <literal>@CachePut</literal> annotation. That is, the method will always, +		<para>Note that using <literal>@CachePut</literal> and <literal>@Cacheable</literal> annotations on the same method is generally discouraged because they have different behaviours. While the latter, +		mentioned <link linkend="cache-annotation-enable">above</link>, the annotation-driven behaviour needs to be enabled.</para>, +		methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create, +		<para>The <literal>CompositeCacheManager</literal> above chains multiple <literal>CacheManager</literal>s and additionally, through the <literal>addNoOpManager</literal> flag, adds a, +++ b/src/reference/docbook/classic-aop-spring.xml, +      instances of the target to grow the pool as necessary. See the Javadoc, +++ b/src/reference/docbook/expressions.xml, +String expression =  "isMember('Nikola Tesla') or isMember('Albert Einstein')";]