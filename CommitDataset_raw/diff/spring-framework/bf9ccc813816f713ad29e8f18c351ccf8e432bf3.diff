[+++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/CacheResultInterceptor.java, +import org.springframework.util.ExceptionTypeFilter;, +		catch (CacheOperationInvoker.ThrowableWrapper ex) {, +			Throwable original = ex.getOriginal();, +			throw ex;, +	protected void cacheException(Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {, +		if (filter.match(ex.getClass())) {, +			exceptionCache.put(cacheKey, ex);, +			return extractFrom(context.getOperation().getExceptionCacheResolver().resolveCaches(context));, +	private static CacheOperationInvoker.ThrowableWrapper rewriteCallStack(, +			Throwable exception, String className, String methodName) {, +, +		catch (Exception ex) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/CacheResultInterceptor.java, +import org.springframework.util.ExceptionTypeFilter;, +		catch (CacheOperationInvoker.ThrowableWrapper ex) {, +			Throwable original = ex.getOriginal();, +			throw ex;, +	protected void cacheException(Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {, +		if (filter.match(ex.getClass())) {, +			exceptionCache.put(cacheKey, ex);, +			return extractFrom(context.getOperation().getExceptionCacheResolver().resolveCaches(context));, +	private static CacheOperationInvoker.ThrowableWrapper rewriteCallStack(, +			Throwable exception, String className, String methodName) {, +, +		catch (Exception ex) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/model/BaseCacheOperation.java, +import org.springframework.util.ExceptionTypeFilter;, +, +import static java.util.Arrays.*;, +, +, +, +		return this.methodDetails.getMethod();, +		return this.methodDetails.getAnnotations();, +		return this.methodDetails.getCacheAnnotation();, +		return this.methodDetails.getCacheName();, +		return this.cacheResolver;, +		if (this.allParameterDetails.size() != values.length) {, +			throw new IllegalStateException("Values mismatch, operation has " +, +					this.allParameterDetails.size() + " parameter(s) but got " + values.length + " value(s)");, +		for (int i = 0; i < this.allParameterDetails.size(); i++) {, +			result.add(this.allParameterDetails.get(i).toCacheInvocationParameter(values[i]));, +	protected ExceptionTypeFilter createExceptionTypeFilter(, +			Class<? extends Throwable>[] includes, Class<? extends Throwable>[] excludes) {, +, +	private static List<CacheParameterDetail> initializeAllParameterDetails(Method method) {, +		List<CacheParameterDetail> result = new ArrayList<CacheParameterDetail>();, +		for (int i = 0; i < method.getParameterTypes().length; i++) {, +			CacheParameterDetail detail = new CacheParameterDetail(method, i);, +			result.add(detail);, +		}, +		return result;, +	}, +, +, +		public CacheParameterDetail(Method m, int parameterPosition) {, +			return this.parameterPosition;, +			return this.isKey;, +			return this.isValue;, +, +		public CacheInvocationParameterImpl(CacheParameterDetail detail, Object value) {, +			return this.detail.rawType;, +			return this.value;, +			return this.detail.annotations;, +			return this.detail.parameterPosition;, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/CacheResultInterceptor.java, +import org.springframework.util.ExceptionTypeFilter;, +		catch (CacheOperationInvoker.ThrowableWrapper ex) {, +			Throwable original = ex.getOriginal();, +			throw ex;, +	protected void cacheException(Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {, +		if (filter.match(ex.getClass())) {, +			exceptionCache.put(cacheKey, ex);, +			return extractFrom(context.getOperation().getExceptionCacheResolver().resolveCaches(context));, +	private static CacheOperationInvoker.ThrowableWrapper rewriteCallStack(, +			Throwable exception, String className, String methodName) {, +, +		catch (Exception ex) {, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/model/BaseCacheOperation.java, +import org.springframework.util.ExceptionTypeFilter;, +, +import static java.util.Arrays.*;, +, +, +, +		return this.methodDetails.getMethod();, +		return this.methodDetails.getAnnotations();, +		return this.methodDetails.getCacheAnnotation();, +		return this.methodDetails.getCacheName();, +		return this.cacheResolver;, +		if (this.allParameterDetails.size() != values.length) {, +			throw new IllegalStateException("Values mismatch, operation has " +, +					this.allParameterDetails.size() + " parameter(s) but got " + values.length + " value(s)");, +		for (int i = 0; i < this.allParameterDetails.size(); i++) {, +			result.add(this.allParameterDetails.get(i).toCacheInvocationParameter(values[i]));, +	protected ExceptionTypeFilter createExceptionTypeFilter(, +			Class<? extends Throwable>[] includes, Class<? extends Throwable>[] excludes) {, +, +	private static List<CacheParameterDetail> initializeAllParameterDetails(Method method) {]