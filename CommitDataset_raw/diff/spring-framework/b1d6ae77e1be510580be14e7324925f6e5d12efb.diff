[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2015 the original author or authors., +import org.springframework.util.ClassUtils;, + * A {@link HandlerMethodArgumentResolver} for {@link Message} parameters., + * Validates that the generic type of the payload matches with the message value., +						"The actual message type [" + ClassUtils.getQualifiedName(message.getClass()) + "] " +, +						"does not match the expected type [" + ClassUtils.getQualifiedName(paramType) + "]");, +		if (payload != null && expectedPayloadType != null && !expectedPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(expectedPayloadType) +, +					"] does not match the actual payload type [" + ClassUtils.getQualifiedName(payload.getClass()) + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2015 the original author or authors., +import org.springframework.util.ClassUtils;, + * A {@link HandlerMethodArgumentResolver} for {@link Message} parameters., + * Validates that the generic type of the payload matches with the message value., +						"The actual message type [" + ClassUtils.getQualifiedName(message.getClass()) + "] " +, +						"does not match the expected type [" + ClassUtils.getQualifiedName(paramType) + "]");, +		if (payload != null && expectedPayloadType != null && !expectedPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(expectedPayloadType) +, +					"] does not match the actual payload type [" + ClassUtils.getQualifiedName(payload.getClass()) + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SendToMethodReturnValueHandler.java, +import org.springframework.util.StringUtils;, + * sent through the provided {@link MessageChannel}. The message is then enriched with the, + * session id of the input message as well as the destination from the annotation(s)., + * If multiple destinations are specified, a copy of the message is sent to each destination., +		if (returnType.getMethodAnnotation(SendTo.class) != null ||, +				returnType.getMethodAnnotation(SendToUser.class) != null) {, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(null, returnType));, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(sessionId, returnType));, +		if (!StringUtils.hasText(destination)) {, +			throw new IllegalStateException("No lookup destination header in " + message);, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2015 the original author or authors., +import org.springframework.util.ClassUtils;, + * A {@link HandlerMethodArgumentResolver} for {@link Message} parameters., + * Validates that the generic type of the payload matches with the message value., +						"The actual message type [" + ClassUtils.getQualifiedName(message.getClass()) + "] " +, +						"does not match the expected type [" + ClassUtils.getQualifiedName(paramType) + "]");, +		if (payload != null && expectedPayloadType != null && !expectedPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(expectedPayloadType) +, +					"] does not match the actual payload type [" + ClassUtils.getQualifiedName(payload.getClass()) + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SendToMethodReturnValueHandler.java, +import org.springframework.util.StringUtils;, + * sent through the provided {@link MessageChannel}. The message is then enriched with the, + * session id of the input message as well as the destination from the annotation(s)., + * If multiple destinations are specified, a copy of the message is sent to each destination., +		if (returnType.getMethodAnnotation(SendTo.class) != null ||, +				returnType.getMethodAnnotation(SendToUser.class) != null) {, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(null, returnType));, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(sessionId, returnType));, +		if (!StringUtils.hasText(destination)) {, +			throw new IllegalStateException("No lookup destination header in " + message);, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SubscriptionMethodReturnValueHandler.java, +		if (subscriptionId == null) {, +			throw new IllegalStateException(, +					"No subscriptionId in " + message + " returned by: " + returnType.getMethod());, +		}, +		this.messagingTemplate.convertAndSend(, +				destination, returnValue, createHeaders(sessionId, subscriptionId, returnType));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolver.java, + * Copyright 2002-2015 the original author or authors., +import org.springframework.util.ClassUtils;, + * A {@link HandlerMethodArgumentResolver} for {@link Message} parameters., + * Validates that the generic type of the payload matches with the message value., +						"The actual message type [" + ClassUtils.getQualifiedName(message.getClass()) + "] " +, +						"does not match the expected type [" + ClassUtils.getQualifiedName(paramType) + "]");, +		if (payload != null && expectedPayloadType != null && !expectedPayloadType.isInstance(payload)) {, +					"The expected Message<?> payload type [" + ClassUtils.getQualifiedName(expectedPayloadType) +, +					"] does not match the actual payload type [" + ClassUtils.getQualifiedName(payload.getClass()) + "]");, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SendToMethodReturnValueHandler.java, +import org.springframework.util.StringUtils;, + * sent through the provided {@link MessageChannel}. The message is then enriched with the, + * session id of the input message as well as the destination from the annotation(s)., + * If multiple destinations are specified, a copy of the message is sent to each destination., +		if (returnType.getMethodAnnotation(SendTo.class) != null ||, +				returnType.getMethodAnnotation(SendToUser.class) != null) {, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(null, returnType));, +					this.messagingTemplate.convertAndSendToUser(, +							user, destination, returnValue, createHeaders(sessionId, returnType));, +		if (!StringUtils.hasText(destination)) {, +			throw new IllegalStateException("No lookup destination header in " + message);, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SubscriptionMethodReturnValueHandler.java, +		if (subscriptionId == null) {, +			throw new IllegalStateException(, +					"No subscriptionId in " + message + " returned by: " + returnType.getMethod());, +		}, +		this.messagingTemplate.convertAndSend(, +				destination, returnValue, createHeaders(sessionId, subscriptionId, returnType));, +++ b/spring-messaging/src/test/java/org/springframework/messaging/handler/annotation/support/MessageMethodArgumentResolverTests.java]