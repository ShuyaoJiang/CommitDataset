[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.java, +import java.util.stream.Collectors;, +import org.springframework.util.ClassUtils;, +	private static final Object NO_VALUE = new Object();, +, +	private static final Mono<Object> NO_VALUE_MONO = Mono.just(NO_VALUE);, +, +, +	@SuppressWarnings("unchecked"), +		Mono<Object> returnValueMono;, +		ResolvableType parameterType = result.getReturnType();, +		ReactiveAdapter adapter = getAdapterRegistry().getAdapterFrom(parameterType.getRawClass(), optional);, +, +				returnValueMono = converted.map(o -> o);, +				returnValueMono = Mono.empty();, +					ResolvableType.forClass(Void.class) : parameterType.getGeneric(0);, +			returnValueMono = Mono.justOrEmpty(result.getReturnValue());, +			elementType = parameterType;, +		return returnValueMono, +				.otherwiseIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO), +				.then(returnValue -> {, +, +					Mono<List<View>> viewsMono;, +					Model model = result.getModel();, +					Locale locale = Locale.getDefault(); // TODO, +, +					Class<?> clazz = elementType.getRawClass();, +					if (clazz == null) {, +						clazz = returnValue.getClass();, +					}, +, +					if (returnValue == NO_VALUE || Void.class.equals(clazz) || void.class.equals(clazz)) {, +						viewsMono = resolveViews(getDefaultViewName(result, exchange), locale);, +					}, +					else if (Model.class.isAssignableFrom(clazz)) {, +						model.addAllAttributes(((Model) returnValue).asMap());, +						viewsMono = resolveViews(getDefaultViewName(result, exchange), locale);, +					}, +					else if (Map.class.isAssignableFrom(clazz)) {, +						model.addAllAttributes((Map<String, ?>) returnValue);, +						viewsMono = resolveViews(getDefaultViewName(result, exchange), locale);, +					}, +					else if (View.class.isAssignableFrom(clazz)) {, +						viewsMono = Mono.just(Collections.singletonList((View) returnValue));, +					}, +					else if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAttributeAnnotation(result)) {, +						viewsMono = resolveViews(returnValue.toString(), locale);, +						String name = getNameForReturnValue(clazz, result.getReturnTypeSource());, +						model.addAttribute(name, returnValue);, +						viewsMono = resolveViews(getDefaultViewName(result, exchange), locale);, +, +					return resolveAsyncAttributes(model.asMap()), +							.then(viewsMono), +							.then(views -> render(views, model.asMap(), exchange));, +	 * Select a default view name when a controller leaves the view unspecified., +	 * The default implementation strips the leading and trailing slash from the, +	 * as well as any extension and uses that as the view name., +	private Mono<List<View>> resolveViews(String viewName, Locale locale) {, +		return Flux.fromIterable(getViewResolvers()), +				.concatMap(resolver -> resolver.resolveViewName(viewName, locale)), +				.collectList(), +				.map(views -> {, +					if (views.isEmpty()) {, +						throw new IllegalStateException(, +								"Could not resolve view with name '" + viewName + "'.");, +					views.addAll(getDefaultViews());, +					return views;, +				});, +	 * Return the name of a model attribute return value based on the method, +	 * {@code @ModelAttribute} annotation, if present, or derived from the type, +	 * of the return value otherwise., +	private String getNameForReturnValue(Class<?> returnValueType, MethodParameter returnType) {, +		// TODO: Conventions does not deal with async wrappers, +		return ClassUtils.getShortNameAsProperty(returnValueType);, +	}, +, +	private Mono<Void> resolveAsyncAttributes(Map<String, Object> model) {, +, +		List<String> names = new ArrayList<>();, +		List<Mono<Object>> valueMonos = new ArrayList<>();, +, +		for (Map.Entry<String, ?> entry : model.entrySet()) {, +			ReactiveAdapter adapter = getAdapterRegistry().getAdapterFrom(null, entry.getValue());, +			if (adapter != null) {, +				names.add(entry.getKey());, +				valueMonos.add(adapter.toMono(entry.getValue()).defaultIfEmpty(NO_VALUE));, +			}, +		}, +, +		if (names.isEmpty()) {, +			return Mono.empty();, +		}, +, +		return Mono.when(valueMonos,, +				values -> {, +					for (int i=0; i < values.length; i++) {, +						if (values[i] != NO_VALUE) {, +							model.put(names.get(i), values[i]);, +						}, +							model.remove(names.get(i));]