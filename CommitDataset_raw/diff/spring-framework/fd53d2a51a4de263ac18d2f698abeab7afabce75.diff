[+++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +				Object target = this.advised.getTargetSource().getTarget();, +				Class<?> targetClass = this.advised.getTargetClass();, +				if (targetClass == null) {, +					targetClass = target.getClass();, +				}, +				fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(chain, target, targetClass);, +	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {, +		public StaticUnadvisedInterceptor(Object target) {, +		public StaticUnadvisedExposedInterceptor(Object target) {, +		public FixedChainStaticTargetInterceptor(List<Object> adviceChain, Object target, Class<?> targetClass) {, +				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool..., +				Class<?> targetClass = target.getClass();, +		public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments,, +				Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {, +++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +				Object target = this.advised.getTargetSource().getTarget();, +				Class<?> targetClass = this.advised.getTargetClass();, +				if (targetClass == null) {, +					targetClass = target.getClass();, +				}, +				fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(chain, target, targetClass);, +	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {, +		public StaticUnadvisedInterceptor(Object target) {, +		public StaticUnadvisedExposedInterceptor(Object target) {, +		public FixedChainStaticTargetInterceptor(List<Object> adviceChain, Object target, Class<?> targetClass) {, +				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool..., +				Class<?> targetClass = target.getClass();, +		public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments,, +				Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.java, +			// Get as late as possible to minimize the time we "own" the target,, +			Class<?> targetClass = target.getClass();, +++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +				Object target = this.advised.getTargetSource().getTarget();, +				Class<?> targetClass = this.advised.getTargetClass();, +				if (targetClass == null) {, +					targetClass = target.getClass();, +				}, +				fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(chain, target, targetClass);, +	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {, +		public StaticUnadvisedInterceptor(Object target) {, +		public StaticUnadvisedExposedInterceptor(Object target) {, +		public FixedChainStaticTargetInterceptor(List<Object> adviceChain, Object target, Class<?> targetClass) {, +				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool..., +				Class<?> targetClass = target.getClass();, +		public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments,, +				Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.java, +			// Get as late as possible to minimize the time we "own" the target,, +			Class<?> targetClass = target.getClass();, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/ReflectiveMethodInvocation.java, +			Object proxy, Object target, Method method, Object[] arguments,, +			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {, +++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +				Object target = this.advised.getTargetSource().getTarget();, +				Class<?> targetClass = this.advised.getTargetClass();, +				if (targetClass == null) {, +					targetClass = target.getClass();, +				}, +				fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(chain, target, targetClass);, +	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {, +		public StaticUnadvisedInterceptor(Object target) {, +		public StaticUnadvisedExposedInterceptor(Object target) {, +		public FixedChainStaticTargetInterceptor(List<Object> adviceChain, Object target, Class<?> targetClass) {, +				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool..., +				Class<?> targetClass = target.getClass();, +		public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments,, +				Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.java, +			// Get as late as possible to minimize the time we "own" the target,, +			Class<?> targetClass = target.getClass();, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/ReflectiveMethodInvocation.java, +			Object proxy, Object target, Method method, Object[] arguments,, +			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {, +++ b/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java, +	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args), +++ b/spring-aop/src/main/java/org/springframework/aop/TargetSource.java, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +				Object target = this.advised.getTargetSource().getTarget();, +				Class<?> targetClass = this.advised.getTargetClass();, +				if (targetClass == null) {, +					targetClass = target.getClass();, +				}, +				fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(chain, target, targetClass);, +	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {, +		public StaticUnadvisedInterceptor(Object target) {, +		public StaticUnadvisedExposedInterceptor(Object target) {, +		public FixedChainStaticTargetInterceptor(List<Object> adviceChain, Object target, Class<?> targetClass) {, +				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool..., +				Class<?> targetClass = target.getClass();, +		public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments,, +				Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.java, +			// Get as late as possible to minimize the time we "own" the target,]