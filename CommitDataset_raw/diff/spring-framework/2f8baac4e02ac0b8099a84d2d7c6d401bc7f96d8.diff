[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestBodyArgumentResolver.java, +import java.lang.annotation.Annotation;, +import org.springframework.core.Conventions;, +import org.springframework.core.annotation.AnnotationUtils;, +import org.springframework.util.ObjectUtils;, +import org.springframework.validation.BeanPropertyBindingResult;, +import org.springframework.validation.Errors;, +import org.springframework.validation.SmartValidator;, +import org.springframework.validation.Validator;, +import org.springframework.validation.annotation.Validated;, +import org.springframework.web.server.ServerWebInputException;, +	private final Validator validator;, +, +		this(converters, service, null);, +	}, +, +	/**, +	 * Constructor with message converters and a ConversionService., +	 * @param converters converters for reading the request body with, +	 * @param service for converting to other reactive types from Flux and Mono, +	 * @param validator validator to validate decoded objects with, +	 */, +	public RequestBodyArgumentResolver(List<HttpMessageConverter<?>> converters,, +			ConversionService service, Validator validator) {, +, +		this.validator = validator;, +, +				if (this.validator != null) {, +					elementFlux= applyValidationIfApplicable(elementFlux, parameter);, +				}, +, +	protected Flux<?> applyValidationIfApplicable(Flux<?> elementFlux, MethodParameter methodParam) {, +		Annotation[] annotations = methodParam.getParameterAnnotations();, +		for (Annotation ann : annotations) {, +			Validated validAnnot = AnnotationUtils.getAnnotation(ann, Validated.class);, +			if (validAnnot != null || ann.annotationType().getSimpleName().startsWith("Valid")) {, +				Object hints = (validAnnot != null ? validAnnot.value() : AnnotationUtils.getValue(ann));, +				Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});, +				return elementFlux.map(element -> {, +					validate(element, validationHints, methodParam);, +					return element;, +				});, +			}, +		}, +		return elementFlux;, +	}, +, +	/**, +	 * TODO: replace with use of DataBinder, +	 */, +	private void validate(Object target, Object[] validationHints, MethodParameter methodParam) {, +		String name = Conventions.getVariableNameForParameter(methodParam);, +		Errors errors = new BeanPropertyBindingResult(target, name);, +		if (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator) {, +			((SmartValidator) this.validator).validate(target, errors, validationHints);, +		}, +		else if (this.validator != null) {, +			this.validator.validate(target, errors);, +		}, +		if (errors.hasErrors()) {, +			throw new ServerWebInputException("Validation failed", methodParam);, +		}, +	}, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestBodyArgumentResolver.java, +import java.lang.annotation.Annotation;, +import org.springframework.core.Conventions;, +import org.springframework.core.annotation.AnnotationUtils;, +import org.springframework.util.ObjectUtils;, +import org.springframework.validation.BeanPropertyBindingResult;, +import org.springframework.validation.Errors;, +import org.springframework.validation.SmartValidator;, +import org.springframework.validation.Validator;, +import org.springframework.validation.annotation.Validated;, +import org.springframework.web.server.ServerWebInputException;, +	private final Validator validator;, +, +		this(converters, service, null);, +	}, +, +	/**, +	 * Constructor with message converters and a ConversionService., +	 * @param converters converters for reading the request body with, +	 * @param service for converting to other reactive types from Flux and Mono, +	 * @param validator validator to validate decoded objects with, +	 */, +	public RequestBodyArgumentResolver(List<HttpMessageConverter<?>> converters,, +			ConversionService service, Validator validator) {, +, +		this.validator = validator;, +, +				if (this.validator != null) {, +					elementFlux= applyValidationIfApplicable(elementFlux, parameter);, +				}, +, +	protected Flux<?> applyValidationIfApplicable(Flux<?> elementFlux, MethodParameter methodParam) {, +		Annotation[] annotations = methodParam.getParameterAnnotations();, +		for (Annotation ann : annotations) {, +			Validated validAnnot = AnnotationUtils.getAnnotation(ann, Validated.class);, +			if (validAnnot != null || ann.annotationType().getSimpleName().startsWith("Valid")) {]