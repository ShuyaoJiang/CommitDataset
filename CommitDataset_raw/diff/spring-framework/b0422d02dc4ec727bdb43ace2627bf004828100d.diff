[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/AppCacheManifestTransformer.java, +import java.nio.CharBuffer;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import org.springframework.core.io.buffer.DataBufferUtils;, +import org.springframework.util.StreamUtils;, + * A {@link ResourceTransformer} HTML5 AppCache manifests., + * <p>All files with an ".appcache" file extension (or the extension given, + * to the constructor) will be transformed by this class. The hash is computed, + * using the content of the appcache manifest so that changes in the manifest, + * should invalidate the browser cache. This should also work with changes in, + * referenced resources whose links are also versioned., +				.flatMap(outputResource -> {, +					String name = outputResource.getFilename();, +						return Mono.just(outputResource);, +					DataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();, +					return DataBufferUtils.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE), +							.reduce(DataBuffer::write), +							.flatMap(dataBuffer -> {, +								CharBuffer charBuffer = DEFAULT_CHARSET.decode(dataBuffer.asByteBuffer());, +								DataBufferUtils.release(dataBuffer);, +								String content = charBuffer.toString();, +								return transform(content, outputResource, chain, exchange);, +							});, +				});, +	}, +, +	private Mono<? extends Resource> transform(String content, Resource resource,, +			ResourceTransformerChain chain, ServerWebExchange exchange) {, +, +		return Flux.generate(new LineInfoGenerator(content)), +				.reduce(new ByteArrayOutputStream(), (out, line) -> {, +					writeToByteArrayOutputStream(out, line + "\n");, +					return out;, +				}), +				.map(out -> {, +					String hash = DigestUtils.md5DigestAsHex(out.toByteArray());, +					writeToByteArrayOutputStream(out, "\n" + "# Hash: " + hash);, +					if (logger.isTraceEnabled()) {, +						logger.trace("AppCache file: [" + resource.getFilename()+ "] hash: [" + hash + "]");, +					}, +					return new TransformedResource(resource, out.toByteArray());, +	private static void writeToByteArrayOutputStream(ByteArrayOutputStream out, String toWrite) {, +			byte[] bytes = toWrite.getBytes(DEFAULT_CHARSET);, +			out.write(bytes);, +	private Mono<String> processLine(LineInfo info, ServerWebExchange exchange,, +			return Mono.just(info.getLine());, +		return resolveUrlPath(link, exchange, resource, chain), +	private static class LineInfoGenerator implements Consumer<SynchronousSink<LineInfo>> {, +, +		LineInfoGenerator(String content) {, +, +, +		LineInfo(String line, @Nullable LineInfo previousLine) {, +, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/AppCacheManifestTransformer.java, +import java.nio.CharBuffer;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import org.springframework.core.io.buffer.DataBufferUtils;, +import org.springframework.util.StreamUtils;, + * A {@link ResourceTransformer} HTML5 AppCache manifests., + * <p>All files with an ".appcache" file extension (or the extension given, + * to the constructor) will be transformed by this class. The hash is computed, + * using the content of the appcache manifest so that changes in the manifest, + * should invalidate the browser cache. This should also work with changes in, + * referenced resources whose links are also versioned., +				.flatMap(outputResource -> {, +					String name = outputResource.getFilename();, +						return Mono.just(outputResource);, +					DataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();, +					return DataBufferUtils.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE), +							.reduce(DataBuffer::write), +							.flatMap(dataBuffer -> {, +								CharBuffer charBuffer = DEFAULT_CHARSET.decode(dataBuffer.asByteBuffer());, +								DataBufferUtils.release(dataBuffer);, +								String content = charBuffer.toString();, +								return transform(content, outputResource, chain, exchange);, +							});, +				});, +	}, +, +	private Mono<? extends Resource> transform(String content, Resource resource,, +			ResourceTransformerChain chain, ServerWebExchange exchange) {, +, +		return Flux.generate(new LineInfoGenerator(content)), +				.reduce(new ByteArrayOutputStream(), (out, line) -> {, +					writeToByteArrayOutputStream(out, line + "\n");, +					return out;, +				}), +				.map(out -> {, +					String hash = DigestUtils.md5DigestAsHex(out.toByteArray());, +					writeToByteArrayOutputStream(out, "\n" + "# Hash: " + hash);, +					if (logger.isTraceEnabled()) {, +						logger.trace("AppCache file: [" + resource.getFilename()+ "] hash: [" + hash + "]");, +					}, +					return new TransformedResource(resource, out.toByteArray());, +	private static void writeToByteArrayOutputStream(ByteArrayOutputStream out, String toWrite) {, +			byte[] bytes = toWrite.getBytes(DEFAULT_CHARSET);]