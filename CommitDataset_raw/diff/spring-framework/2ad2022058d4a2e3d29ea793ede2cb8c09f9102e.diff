[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +	public <T> T convertIfNecessary(Object value, Class<T> requiredType, MethodParameter methodParam), +			throws TypeMismatchException {, +	private Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<?> requiredType,, +			TypeDescriptor td) throws TypeMismatchException {, +		try {, +			return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);, +		}, +		catch (ConverterNotFoundException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new ConversionNotSupportedException(pce, td.getType(), ex);, +		}, +		catch (ConversionException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new TypeMismatchException(pce, requiredType, ex);, +		}, +		catch (IllegalStateException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new ConversionNotSupportedException(pce, requiredType, ex);, +		}, +		catch (IllegalArgumentException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new TypeMismatchException(pce, requiredType, ex);, +		}, +	}, +, +	private Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<?> requiredType), +			throws TypeMismatchException {, +, +		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType));, +	}, +, +		return convertForProperty(propertyName, null, value, pd);, +, +	private Object convertForProperty(String propertyName, Object oldValue, Object newValue, PropertyDescriptor pd), +			throws TypeMismatchException {, +, +		return convertIfNecessary(propertyName, oldValue, newValue, pd.getPropertyType(),, +				new PropertyTypeDescriptor(pd, BeanUtils.getWriteMethodParameter(pd)));, +						Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType);, +		catch (TypeMismatchException ex) {, +		catch (InvocationTargetException ex) {, +			throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,, +					"Getter for property '" + actualName + "' threw exception", ex);, +		}, +		catch (Exception ex) {, +			throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,, +					"Illegal attempt to get property '" + actualName + "' threw exception", ex);, +		}, +	@SuppressWarnings("unchecked"), +	private void growCollectionIfNecessary(, +			Collection collection, int index, String name, PropertyDescriptor pd, int nestingLevel) {, +, +					Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);, +					Array.set(propValue, arrayIndex, convertedValue);, +				Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);, +				Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType);, +				Object convertedMapValue = convertIfNecessary(, +						new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));, +							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&, +									!readMethod.isAccessible()) {, +						valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);, +					}, +					catch (PrivilegedActionException ex) {, +					writeMethod.invoke(this.object, value);, +			}, +			catch (TypeMismatchException ex) {, +				throw ex;, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +	public <T> T convertIfNecessary(Object value, Class<T> requiredType, MethodParameter methodParam), +			throws TypeMismatchException {, +	private Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<?> requiredType,, +			TypeDescriptor td) throws TypeMismatchException {, +		try {, +			return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);, +		}, +		catch (ConverterNotFoundException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new ConversionNotSupportedException(pce, td.getType(), ex);, +		}, +		catch (ConversionException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new TypeMismatchException(pce, requiredType, ex);, +		}, +		catch (IllegalStateException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new ConversionNotSupportedException(pce, requiredType, ex);, +		}, +		catch (IllegalArgumentException ex) {, +			PropertyChangeEvent pce =, +					new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);, +			throw new TypeMismatchException(pce, requiredType, ex);, +		}]