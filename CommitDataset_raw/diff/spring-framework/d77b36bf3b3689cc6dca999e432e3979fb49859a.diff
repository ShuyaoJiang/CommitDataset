[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AutowireUtils.java, +import java.lang.annotation.Annotation;, +import java.lang.reflect.AnnotatedElement;, +import java.lang.reflect.Parameter;, +import org.springframework.beans.BeansException;, +import org.springframework.beans.factory.annotation.Autowired;, +import org.springframework.beans.factory.annotation.Qualifier;, +import org.springframework.beans.factory.annotation.Value;, +import org.springframework.beans.factory.config.AutowireCapableBeanFactory;, +import org.springframework.beans.factory.config.DependencyDescriptor;, +import org.springframework.core.MethodParameter;, +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.core.annotation.SynthesizingMethodParameter;, +public abstract class AutowireUtils {, +	private static final AnnotatedElement EMPTY_ANNOTATED_ELEMENT = new AnnotatedElement() {, +		@Override, +		@Nullable, +		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {, +			return null;, +		}, +		@Override, +		public Annotation[] getAnnotations() {, +			return new Annotation[0];, +		}, +		@Override, +		public Annotation[] getDeclaredAnnotations() {, +			return new Annotation[0];, +		}, +	};, +, +	static void sortConstructors(Constructor<?>[] constructors) {, +	static void sortFactoryMethods(Method[] factoryMethods) {, +	static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {, +	static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {, +	static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {, +	static Class<?> resolveReturnTypeForFactoryMethod(, +	/**, +	 * Determine if the supplied {@link Parameter} can <em>potentially</em> be, +	 * autowired from an {@link AutowireCapableBeanFactory}., +	 * <p>Returns {@code true} if the supplied parameter is annotated or, +	 * meta-annotated with {@link Autowired @Autowired},, +	 * {@link Qualifier @Qualifier}, or {@link Value @Value}., +	 * <p>Note that {@link #resolveDependency} may still be able to resolve the, +	 * dependency for the supplied parameter even if this method returns {@code false}., +	 * @param parameter the parameter whose dependency should be autowired, +	 * @param parameterIndex the index of the parameter in the constructor or method, +	 * that declares the parameter, +	 * @see #resolveDependency, +	 * @since 5.2, +	 */, +	public static boolean isAutowirable(Parameter parameter, int parameterIndex) {, +		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);, +		return (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||, +				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||, +				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));, +	}, +, +	/**, +	 * Resolve the dependency for the supplied {@link Parameter} from the, +	 * supplied {@link AutowireCapableBeanFactory}., +	 * <p>Provides comprehensive autowiring support for individual method parameters, +	 * on par with Spring's dependency injection facilities for autowired fields and, +	 * methods, including support for {@link Autowired @Autowired},, +	 * {@link Qualifier @Qualifier}, and {@link Value @Value} with support for property, +	 * placeholders and SpEL expressions in {@code @Value} declarations., +	 * <p>The dependency is required unless the parameter is annotated or meta-annotated, +	 * with {@link Autowired @Autowired} with the {@link Autowired#required required}, +	 * flag set to {@code false}., +	 * <p>If an explicit <em>qualifier</em> is not declared, the name of the parameter, +	 * will be used as the qualifier for resolving ambiguities., +	 * @param parameter the parameter whose dependency should be resolved, +	 * @param parameterIndex the index of the parameter in the constructor or method, +	 * that declares the parameter, +	 * @param containingClass the concrete class that contains the parameter; this may, +	 * differ from the class that declares the parameter in that it may be a subclass, +	 * thereof, potentially substituting type variables, +	 * @param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve, +	 * the dependency, +	 * @return the resolved object, or {@code null} if none found, +	 * @throws BeansException if dependency resolution failed, +	 * @see #isAutowirable, +	 * @see Autowired#required, +	 * @see SynthesizingMethodParameter#forExecutable(Executable, int), +	 * @see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String), +	 * @since 5.2, +	 */, +	@Nullable, +	public static Object resolveDependency(, +			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory), +			throws BeansException {, +, +		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);, +		Autowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class);, +		boolean required = (autowired == null || autowired.required());, +, +		MethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(, +				parameter.getDeclaringExecutable(), parameterIndex);, +		DependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required);, +		descriptor.setContainingClass(containingClass);, +		return beanFactory.resolveDependency(descriptor, null);]