[+++ b/org.springframework.context/src/main/java/org/springframework/context/event/AbstractApplicationEventMulticaster.java, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import org.springframework.context.ApplicationEvent;, +	private final ListenerRetriever defaultRetriever = new ListenerRetriever();, +	private final Map<ListenerCacheKey, ListenerRetriever> retrieverCache =, +			new ConcurrentHashMap<ListenerCacheKey, ListenerRetriever>();, +		this.defaultRetriever.applicationListeners.add(listener);, +		this.defaultRetriever.applicationListenerBeans.add(listenerBeanName);, +	private BeanFactory getBeanFactory() {, +		if (this.beanFactory == null) {, +			throw new IllegalStateException("ApplicationEventMulticaster cannot retrieve listener beans " +, +					"because it is not associated with a BeanFactory");, +		}, +		return this.beanFactory;, +	}, +, +, +	 * Return a Collection containing all ApplicationListeners., +		return this.defaultRetriever.getApplicationListeners();, +, +	/**, +	 * Return a Collection of ApplicationListeners matching the given, +	 * event type. Non-matching listeners get excluded early., +	 * @param event the event to be propagated. Allows for excluding, +	 * non-matching listeners early, based on cached matching information., +	 * @return a Collection of ApplicationListeners, +	 * @see org.springframework.context.ApplicationListener, +	 */, +	protected Collection<ApplicationListener> getApplicationListeners(ApplicationEvent event) {, +		Class<? extends ApplicationEvent> eventType = event.getClass();, +		Class sourceType = event.getSource().getClass();, +		ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);, +		ListenerRetriever retriever = this.retrieverCache.get(cacheKey);, +		if (retriever != null) {, +			return retriever.getApplicationListeners();, +		}, +		else {, +			retriever = new ListenerRetriever();, +			LinkedList<ApplicationListener> allListeners = new LinkedList<ApplicationListener>();, +			for (ApplicationListener listener : this.defaultRetriever.applicationListeners) {, +				if (supportsEvent(listener, eventType, sourceType)) {, +					retriever.applicationListeners.add(listener);, +					allListeners.add(listener);, +			if (!this.defaultRetriever.applicationListenerBeans.isEmpty()) {, +				BeanFactory beanFactory = getBeanFactory();, +				for (String listenerBeanName : this.defaultRetriever.applicationListenerBeans) {, +					ApplicationListener listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class);, +					if (supportsEvent(listener, eventType, sourceType)) {, +						retriever.applicationListenerBeans.add(listenerBeanName);, +						allListeners.add(listener);, +					}, +				}, +			}, +			OrderComparator.sort(allListeners);, +			this.retrieverCache.put(cacheKey, retriever);, +	}, +, +	/**, +	 * Determine whether the given listener supports the given event., +	 * <p>The default implementation detects the {@link SmartApplicationListener}, +	 * interface. In case of a standard {@link ApplicationListener}, a, +	 * {@link GenericApplicationListenerAdapter} will be used to introspect, +	 * the generically declared type of the target listener., +	 * @param listener the target listener to check, +	 * @param eventType the event type to check against, +	 * @param sourceType the source type to check against, +	 * @return whether the given listener should be included in the, +	 * candidates for the given event type, +	 */, +	protected boolean supportsEvent(, +			ApplicationListener listener, Class<? extends ApplicationEvent> eventType, Class sourceType) {, +, +		SmartApplicationListener smartListener = (listener instanceof SmartApplicationListener ?, +				(SmartApplicationListener) listener : new GenericApplicationListenerAdapter(listener));, +		return (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));, +	}, +, +, +	/**, +	 * Cache key for ListenerRetrievers, based on event type and source type., +	 */, +	private static class ListenerCacheKey {, +, +		private final Class eventType;, +, +		private final Class sourceType;, +, +		public ListenerCacheKey(Class eventType, Class sourceType) {, +			this.eventType = eventType;, +			this.sourceType = sourceType;, +		}, +, +		@Override, +		public boolean equals(Object other) {, +			if (this == other) {, +				return true;, +			}, +			ListenerCacheKey otherKey = (ListenerCacheKey) other;, +			return (this.eventType.equals(otherKey.eventType) && this.sourceType.equals(otherKey.sourceType));]