[+++ b/spring-web/src/main/java/org/springframework/http/HttpHeaders.java, +		return getFirstDate(EXPIRES, false);, +		return getFirstDate(IF_MODIFIED_SINCE, false);, +		return getFirstDate(LAST_MODIFIED, false);, +	 * @param headerName the header name, +	 * @return the parsed date header, or -1 if none, +		return getFirstDate(headerName, true);, +	}, +, +	/**, +	 * Parse the first header value for the given header name as a date,, +	 * return -1 if there is no value or also in case of an invalid value, +	 * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}, +	 * if the value cannot be parsed as a date., +	 * @param headerName the header name, +	 * @param rejectInvalid whether to reject invalid values with an, +	 * {@link IllegalArgumentException} ({@code true}) or rather return -1, +	 * in that case ({@code false}), +	 * @return the parsed date header, or -1 if none (or invalid), + 	 */, +	private long getFirstDate(String headerName, boolean rejectInvalid) {, +			// No header value sent at all, +		if (headerValue.length() >= 3) {, +			// Short "0" or "-1" like values are never valid HTTP date headers..., +			// Let's only bother with SimpleDateFormat parsing for long enough values., +		}, +		if (rejectInvalid) {, +		return -1;, +	}, +++ b/spring-web/src/main/java/org/springframework/http/HttpHeaders.java, +		return getFirstDate(EXPIRES, false);, +		return getFirstDate(IF_MODIFIED_SINCE, false);, +		return getFirstDate(LAST_MODIFIED, false);, +	 * @param headerName the header name, +	 * @return the parsed date header, or -1 if none, +		return getFirstDate(headerName, true);, +	}, +, +	/**, +	 * Parse the first header value for the given header name as a date,, +	 * return -1 if there is no value or also in case of an invalid value, +	 * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}, +	 * if the value cannot be parsed as a date., +	 * @param headerName the header name, +	 * @param rejectInvalid whether to reject invalid values with an, +	 * {@link IllegalArgumentException} ({@code true}) or rather return -1, +	 * in that case ({@code false}), +	 * @return the parsed date header, or -1 if none (or invalid), + 	 */, +	private long getFirstDate(String headerName, boolean rejectInvalid) {, +			// No header value sent at all, +		if (headerValue.length() >= 3) {, +			// Short "0" or "-1" like values are never valid HTTP date headers..., +			// Let's only bother with SimpleDateFormat parsing for long enough values., +		}, +		if (rejectInvalid) {, +		return -1;, +	}, +++ b/spring-web/src/test/java/org/springframework/http/HttpHeadersTests.java, + * Copyright 2002-2016 the original author or authors., +import static org.junit.Assert.*;, +	@Test  // SPR-10648 (example is from INT-3063), +	@Test  // SPR-14144, +	public void invalidIfModifiedSinceHeader() {, +		headers.set(HttpHeaders.IF_MODIFIED_SINCE, "0");, +		assertEquals(-1, headers.getIfModifiedSince());, +, +		headers.set(HttpHeaders.IF_MODIFIED_SINCE, "-1");, +		assertEquals(-1, headers.getIfModifiedSince());, +, +		headers.set(HttpHeaders.IF_MODIFIED_SINCE, "XXX");, +		assertEquals(-1, headers.getIfModifiedSince());, +	}, +]