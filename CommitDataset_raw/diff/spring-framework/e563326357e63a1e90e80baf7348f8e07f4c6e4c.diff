[+++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java, +		registerReactiveType(, +				ReactiveTypeDescriptor.singleOptionalValue(Mono.class),, +				source -> (Mono<?>) source,, +				source -> source, +		);, +		registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class),, +				source -> (Flux<?>) source,, +				source -> source);, +		registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class),, +				source -> Flux.from((Publisher<?>) source),, +				source -> source);, +		registerReactiveType(, +				ReactiveTypeDescriptor.singleOptionalValue(CompletableFuture.class),, +				source -> Mono.fromFuture((CompletableFuture<?>) source),, +				source -> Mono.from(source).toFuture(), +			new RxJava1Registrar().registerAdapters(this);, +			new RxJava2Registrar().registerAdapters(this);, +	 * Register a reactive type along with functions to adapt to and from a, +		 * Reactive Streams {@link Publisher}. The functions can assume their, +	 * input is never be {@code null} nor {@link Optional}., +	public void registerReactiveType(ReactiveTypeDescriptor descriptor,, +			Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {, +		ReactiveAdapter adapter = (descriptor.isMultiValue() ?, +				new FluxReactiveAdapter(toAdapter, fromAdapter, descriptor) :, +				new MonoReactiveAdapter(toAdapter, fromAdapter, descriptor));, +, +		this.adapters.add(adapter);, +	 * Get the adapter to use to adapt from the given reactive type., +	 * Get the adapter to use to adapt from the given reactive type. Or if the, +	 * "source" object is not {@code null} its actual type is used instead., +	public ReactiveAdapter getAdapterFrom(Class<?> reactiveType, Object source) {, +		source = unwrapOptional(source);, +		Class<?> clazz = (source != null ? source.getClass() : reactiveType);, +		return getAdapter(type -> type.isAssignableFrom(clazz));, +		return getAdapter(reactiveType::equals);, +	private ReactiveAdapter getAdapter(Predicate<Class<?>> predicate) {, +		private final Function<Object, Publisher<?>> toAdapter;, +		private final Function<Publisher<?>, Object> fromAdapter;, +		MonoReactiveAdapter(Function<Object, Publisher<?>> to, Function<Publisher<?>, Object> from,, +			return (Mono<T>) Mono.from(this.toAdapter.apply(source));, +			return (Flux<T>) toMono(source).flux();, +			return (source != null ? this.fromAdapter.apply(source) : null);, +		private final Function<Object, Publisher<?>> toAdapter;, +		private final Function<Publisher<?>, Object> fromAdapter;, +		FluxReactiveAdapter(Function<Object, Publisher<?>> to, Function<Publisher<?>, Object> from,, +			return (Mono<T>) toFlux(source).next();, +			return (Flux<T>) Flux.from(this.toAdapter.apply(source));, +			return (source != null ? this.fromAdapter.apply(source) : null);, +	private static class RxJava1Registrar {, +		public void registerAdapters(ReactiveAdapterRegistry registry) {, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.multiValue(rx.Observable.class),, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.singleRequiredValue(rx.Single.class),, +					RxReactiveStreams::toSingle, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.noValue(rx.Completable.class),, +					RxReactiveStreams::toCompletable, +	private static class RxJava2Registrar {, +		public void registerAdapters(ReactiveAdapterRegistry registry) {, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.multiValue(Flowable.class),, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.multiValue(io.reactivex.Observable.class),, +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.Single.class),, +					source -> Flowable.fromPublisher(source).toObservable().singleElement().toSingle(), +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.singleOptionalValue(Maybe.class),, +					source -> Flowable.fromPublisher(source).toObservable().singleElement(), +			registry.registerReactiveType(, +					ReactiveTypeDescriptor.noValue(io.reactivex.Completable.class),, +					source -> Flowable.fromPublisher(source).toObservable().ignoreElements(), +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java, +		registerReactiveType(, +				ReactiveTypeDescriptor.singleOptionalValue(Mono.class),, +				source -> (Mono<?>) source,, +				source -> source, +		);, +		registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class),, +				source -> (Flux<?>) source,, +				source -> source);, +		registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class),, +				source -> Flux.from((Publisher<?>) source),, +				source -> source);, +		registerReactiveType(, +				ReactiveTypeDescriptor.singleOptionalValue(CompletableFuture.class),, +				source -> Mono.fromFuture((CompletableFuture<?>) source),, +				source -> Mono.from(source).toFuture(), +			new RxJava1Registrar().registerAdapters(this);, +			new RxJava2Registrar().registerAdapters(this);, +	 * Register a reactive type along with functions to adapt to and from a, +		 * Reactive Streams {@link Publisher}. The functions can assume their, +	 * input is never be {@code null} nor {@link Optional}., +	public void registerReactiveType(ReactiveTypeDescriptor descriptor,, +			Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {, +		ReactiveAdapter adapter = (descriptor.isMultiValue() ?, +				new FluxReactiveAdapter(toAdapter, fromAdapter, descriptor) :, +				new MonoReactiveAdapter(toAdapter, fromAdapter, descriptor));]