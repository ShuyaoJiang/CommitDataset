[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +		while (peekIdentifierToken("or") || peekToken(TokenKind.SYMBOLIC_OR)) {, +		while (peekIdentifierToken("and") || peekToken(TokenKind.SYMBOLIC_AND)) {, +			if (!nullToken.stringValue().equalsIgnoreCase("null")) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +		while (peekIdentifierToken("or") || peekToken(TokenKind.SYMBOLIC_OR)) {, +		while (peekIdentifierToken("and") || peekToken(TokenKind.SYMBOLIC_AND)) {, +			if (!nullToken.stringValue().equalsIgnoreCase("null")) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, + * Copyright 2002-2012 the original author or authors., +	ELVIS("?:"), SAFE_NAVI("?."), BEAN_REF("@"), SYMBOLIC_OR("||"), SYMBOLIC_AND("&&"), +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +		while (peekIdentifierToken("or") || peekToken(TokenKind.SYMBOLIC_OR)) {, +		while (peekIdentifierToken("and") || peekToken(TokenKind.SYMBOLIC_AND)) {, +			if (!nullToken.stringValue().equalsIgnoreCase("null")) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, + * Copyright 2002-2012 the original author or authors., +	ELVIS("?:"), SAFE_NAVI("?."), BEAN_REF("@"), SYMBOLIC_OR("||"), SYMBOLIC_AND("&&"), +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +				case '&':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_AND)) {, +						pushPairToken(TokenKind.SYMBOLIC_AND);, +					}, +					break;, +				case '|':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_OR)) {, +						pushPairToken(TokenKind.SYMBOLIC_OR);, +					}, +					break;					, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +		while (peekIdentifierToken("or") || peekToken(TokenKind.SYMBOLIC_OR)) {, +		while (peekIdentifierToken("and") || peekToken(TokenKind.SYMBOLIC_AND)) {, +			if (!nullToken.stringValue().equalsIgnoreCase("null")) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, + * Copyright 2002-2012 the original author or authors., +	ELVIS("?:"), SAFE_NAVI("?."), BEAN_REF("@"), SYMBOLIC_OR("||"), SYMBOLIC_AND("&&"), +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +				case '&':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_AND)) {, +						pushPairToken(TokenKind.SYMBOLIC_AND);, +					}, +					break;, +				case '|':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_OR)) {, +						pushPairToken(TokenKind.SYMBOLIC_OR);, +					}, +					break;					, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/standard/SpelParserTests.java, +		expr = parser.parseRaw("2\n+\t3");, +	public void booleanOperators_symbolic_spr9614() throws EvaluationException, ParseException {, +		SpelExpression expr = new SpelExpressionParser().parseRaw("true");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("false");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("false && false");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("true && (true || false)");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("true && true || false");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("!true");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("!(false || true)");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +	}, +, +	@Test, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, +		while (peekIdentifierToken("or") || peekToken(TokenKind.SYMBOLIC_OR)) {, +		while (peekIdentifierToken("and") || peekToken(TokenKind.SYMBOLIC_AND)) {, +			if (!nullToken.stringValue().equalsIgnoreCase("null")) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java, + * Copyright 2002-2012 the original author or authors., +	ELVIS("?:"), SAFE_NAVI("?."), BEAN_REF("@"), SYMBOLIC_OR("||"), SYMBOLIC_AND("&&"), +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java, +				case '&':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_AND)) {, +						pushPairToken(TokenKind.SYMBOLIC_AND);, +					}, +					break;, +				case '|':, +					if (isTwoCharToken(TokenKind.SYMBOLIC_OR)) {, +						pushPairToken(TokenKind.SYMBOLIC_OR);, +					}, +					break;					, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/standard/SpelParserTests.java, +		expr = parser.parseRaw("2\n+\t3");, +	public void booleanOperators_symbolic_spr9614() throws EvaluationException, ParseException {, +		SpelExpression expr = new SpelExpressionParser().parseRaw("true");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("false");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("false && false");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("true && (true || false)");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("true && true || false");, +		assertEquals(Boolean.TRUE, expr.getValue(Boolean.class));, +		expr = new SpelExpressionParser().parseRaw("!true");, +		assertEquals(Boolean.FALSE, expr.getValue(Boolean.class));]