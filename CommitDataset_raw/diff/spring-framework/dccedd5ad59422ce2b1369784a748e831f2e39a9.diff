[+++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, +	 * Match this pattern to the given URI path and return extracted URI template, +	 * variables as well as path parameters (matrix variables)., +	 * @param pathContainer the candidate path to attempt to match against, +	 * @return info object with the extracted variables, +	 * @throws IllegalStateException if the path does not match the pattern, +	 */, +	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {, +		MatchingContext matchingContext = new MatchingContext(pathContainer, true);, +		if (this.head != null && this.head.matches(0, matchingContext)) {, +			return matchingContext.getPathMatchResult();, +		}, +		else if (!hasLength(pathContainer)) {, +			return PathMatchInfo.EMPTY;, +		}, +		else {, +			throw new IllegalStateException(, +					"Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"");, +		}, +	}, +, +	/**, +	 * Match the beginning of the given path and return the remaining portion, +	 * not covered by this pattern. This is useful for matching nested routes, +	 * where the path is matched incrementally at each level., +	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {, +		// TODO: align behavior with matchStartOfPath with regards to this:, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, +	 * Match this pattern to the given URI path and return extracted URI template, +	 * variables as well as path parameters (matrix variables)., +	 * @param pathContainer the candidate path to attempt to match against, +	 * @return info object with the extracted variables, +	 * @throws IllegalStateException if the path does not match the pattern, +	 */, +	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {, +		MatchingContext matchingContext = new MatchingContext(pathContainer, true);, +		if (this.head != null && this.head.matches(0, matchingContext)) {, +			return matchingContext.getPathMatchResult();, +		}, +		else if (!hasLength(pathContainer)) {, +			return PathMatchInfo.EMPTY;, +		}, +		else {, +			throw new IllegalStateException(, +					"Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"");, +		}, +	}, +, +	/**, +	 * Match the beginning of the given path and return the remaining portion, +	 * not covered by this pattern. This is useful for matching nested routes, +	 * where the path is matched incrementally at each level., +	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {, +		// TODO: align behavior with matchStartOfPath with regards to this:, +++ b/spring-web/src/test/java/org/springframework/web/util/pattern/PathPatternTests.java, +		assertNull(parse("/foo").matchStartOfPath(toPathContainer("/footastic/bar")));, +		assertNull(parse("/f?o").matchStartOfPath(toPathContainer("/footastic/bar")));, +		assertNull(parse("/f*o*p").matchStartOfPath(toPathContainer("/flooptastic/bar")));, +		assertNull(parse("/{abc}abc").matchStartOfPath(toPathContainer("/xyzabcbar/bar")));, +		assertNull(parse("/resource/**").matchStartOfPath(toPathContainer("/resourceX")));, +		assertEquals("",parse("/resource/**").matchStartOfPath(toPathContainer("/resource")).getPathRemaining().value());, +		assertNull(parse("/resource/{*foo}").matchStartOfPath(toPathContainer("/resourceX")));, +		assertEquals("",parse("/resource/{*foo}").matchStartOfPath(toPathContainer("/resource")).getPathRemaining().value());, +		PathPattern.PathRemainingMatchInfo pri = parse("/aaa/{bbb}/c?d/e*f/*/g").matchStartOfPath(toPathContainer("/aaa/b/ccd/ef/x/g/i"));, +		pri = parse("/aaa/{bbb}/c?d/e*f/*/g/").matchStartOfPath(toPathContainer("/aaa/b/ccd/ef/x/g/i"));, +		pri = parse("/{aaa}_{bbb}/e*f/{x}/g").matchStartOfPath(toPathContainer("/aa_bb/ef/x/g/i"));, +		assertNull(parse("/a/b").matchStartOfPath(toPathContainer("")));, +		assertEquals("/a/b",parse("").matchStartOfPath(toPathContainer("/a/b")).getPathRemaining().value());, +		assertEquals("",parse("").matchStartOfPath(toPathContainer("")).getPathRemaining().value());, +		return parse(pattern).matchStartOfPath(toPathContainer(path));, +		return pattern.matchStartOfPath(toPathContainer(path));, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, +	 * Match this pattern to the given URI path and return extracted URI template, +	 * variables as well as path parameters (matrix variables)., +	 * @param pathContainer the candidate path to attempt to match against, +	 * @return info object with the extracted variables, +	 * @throws IllegalStateException if the path does not match the pattern, +	 */, +	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {, +		MatchingContext matchingContext = new MatchingContext(pathContainer, true);, +		if (this.head != null && this.head.matches(0, matchingContext)) {, +			return matchingContext.getPathMatchResult();, +		}, +		else if (!hasLength(pathContainer)) {, +			return PathMatchInfo.EMPTY;, +		}, +		else {, +			throw new IllegalStateException(, +					"Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"");, +		}, +	}, +, +	/**, +	 * Match the beginning of the given path and return the remaining portion, +	 * not covered by this pattern. This is useful for matching nested routes, +	 * where the path is matched incrementally at each level., +	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {, +		// TODO: align behavior with matchStartOfPath with regards to this:, +++ b/spring-web/src/test/java/org/springframework/web/util/pattern/PathPatternTests.java, +		assertNull(parse("/foo").matchStartOfPath(toPathContainer("/footastic/bar")));]