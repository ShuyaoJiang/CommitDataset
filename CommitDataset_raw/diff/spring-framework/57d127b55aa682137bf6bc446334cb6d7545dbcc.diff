[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompCommand.java, +import java.util.Collection;, +	private static Map<StompCommand, SimpMessageType> messageTypes = new HashMap<StompCommand, SimpMessageType>();, +	private static Collection<StompCommand> destinationRequired = Arrays.asList(SEND, SUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> subscriptionIdRequired = Arrays.asList(SUBSCRIBE, UNSUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> bodyAllowed = Arrays.asList(SEND, MESSAGE, ERROR);, +		messageTypes.put(StompCommand.CONNECT, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.STOMP, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.SEND, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.MESSAGE, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.SUBSCRIBE, SimpMessageType.SUBSCRIBE);, +		messageTypes.put(StompCommand.UNSUBSCRIBE, SimpMessageType.UNSUBSCRIBE);, +		messageTypes.put(StompCommand.DISCONNECT, SimpMessageType.DISCONNECT);, +		SimpMessageType type = messageTypes.get(this);, +		return destinationRequired.contains(this);, +		return subscriptionIdRequired.contains(this);, +	}, +, +	public boolean isBodyAllowed() {, +		return bodyAllowed.contains(this);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompCommand.java, +import java.util.Collection;, +	private static Map<StompCommand, SimpMessageType> messageTypes = new HashMap<StompCommand, SimpMessageType>();, +	private static Collection<StompCommand> destinationRequired = Arrays.asList(SEND, SUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> subscriptionIdRequired = Arrays.asList(SUBSCRIBE, UNSUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> bodyAllowed = Arrays.asList(SEND, MESSAGE, ERROR);, +		messageTypes.put(StompCommand.CONNECT, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.STOMP, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.SEND, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.MESSAGE, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.SUBSCRIBE, SimpMessageType.SUBSCRIBE);, +		messageTypes.put(StompCommand.UNSUBSCRIBE, SimpMessageType.UNSUBSCRIBE);, +		messageTypes.put(StompCommand.DISCONNECT, SimpMessageType.DISCONNECT);, +		SimpMessageType type = messageTypes.get(this);, +		return destinationRequired.contains(this);, +		return subscriptionIdRequired.contains(this);, +	}, +, +	public boolean isBodyAllowed() {, +		return bodyAllowed.contains(this);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java, + * A decoder for STOMP frames., + * @author Andy Wilkinson, +			StompCommand stompCommand = StompCommand.valueOf(command);, +			if ((payload.length > 0) && (!stompCommand.isBodyAllowed())) {, +				throw new StompConversionException(stompCommand +, +						" isn't allowed to have a body but has payload length=" + payload.length +, +						", headers=" + headers);, +			}, +, +			decodedMessage = MessageBuilder.withPayload(payload), +					.setHeaders(StompHeaderAccessor.create(stompCommand, headers)).build();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompCommand.java, +import java.util.Collection;, +	private static Map<StompCommand, SimpMessageType> messageTypes = new HashMap<StompCommand, SimpMessageType>();, +	private static Collection<StompCommand> destinationRequired = Arrays.asList(SEND, SUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> subscriptionIdRequired = Arrays.asList(SUBSCRIBE, UNSUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> bodyAllowed = Arrays.asList(SEND, MESSAGE, ERROR);, +		messageTypes.put(StompCommand.CONNECT, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.STOMP, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.SEND, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.MESSAGE, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.SUBSCRIBE, SimpMessageType.SUBSCRIBE);, +		messageTypes.put(StompCommand.UNSUBSCRIBE, SimpMessageType.UNSUBSCRIBE);, +		messageTypes.put(StompCommand.DISCONNECT, SimpMessageType.DISCONNECT);, +		SimpMessageType type = messageTypes.get(this);, +		return destinationRequired.contains(this);, +		return subscriptionIdRequired.contains(this);, +	}, +, +	public boolean isBodyAllowed() {, +		return bodyAllowed.contains(this);, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java, + * A decoder for STOMP frames., + * @author Andy Wilkinson, +			StompCommand stompCommand = StompCommand.valueOf(command);, +			if ((payload.length > 0) && (!stompCommand.isBodyAllowed())) {, +				throw new StompConversionException(stompCommand +, +						" isn't allowed to have a body but has payload length=" + payload.length +, +						", headers=" + headers);, +			}, +, +			decodedMessage = MessageBuilder.withPayload(payload), +					.setHeaders(StompHeaderAccessor.create(stompCommand, headers)).build();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompEncoder.java, + * An encoder for STOMP frames., +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompCommand.java, +import java.util.Collection;, +	private static Map<StompCommand, SimpMessageType> messageTypes = new HashMap<StompCommand, SimpMessageType>();, +	private static Collection<StompCommand> destinationRequired = Arrays.asList(SEND, SUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> subscriptionIdRequired = Arrays.asList(SUBSCRIBE, UNSUBSCRIBE, MESSAGE);, +	private static Collection<StompCommand> bodyAllowed = Arrays.asList(SEND, MESSAGE, ERROR);, +		messageTypes.put(StompCommand.CONNECT, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.STOMP, SimpMessageType.CONNECT);, +		messageTypes.put(StompCommand.SEND, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.MESSAGE, SimpMessageType.MESSAGE);, +		messageTypes.put(StompCommand.SUBSCRIBE, SimpMessageType.SUBSCRIBE);]