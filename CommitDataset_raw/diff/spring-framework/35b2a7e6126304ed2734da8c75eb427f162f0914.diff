[+++ b/spring-framework-reference/src/beans.xml, +    any type of object. <literal><ulink, +    in this chapter in descriptions of Spring's IoC container. <!--API spec says ApplicationContext is a subinterface of BeanFactory, so is it right to call it a superset?-->For, +    more information on using the <classname>BeanFactory</classname> instead, +    of the <classname>ApplicationContext,</classname> refer to <xref, +    <title>Container overview</title>, +    <para>Several implementations of the, +    <classname>ApplicationContext</classname> interface are supplied, +	out-of-the-box with Spring. In standalone applications it is common to create an, +    in a web application scenario, a simple eight (or so) lines of boilerplate, +    J2EE web descriptor XML in the <literal>web.xml</literal> file of the , +	application will typically suffice (see <xref, +      configuration metadata shows these beans configured as, +      <literal>&lt;bean/&gt;</literal> elements inside a top-level, +      <literal>&lt;beans/&gt;</literal> element.</para>, +      <para>In the preceding example, the service layer consists of the class, +        <para>It can be useful to have bean definitions span multiple XML, +        logical layer or module in your architecture.</para>, +        <para>You can use the application context constructor to load bean, +        definitions from all these XML fragments., +        This constructor takes multiple, +        <interfacename>Resource</interfacename> locations, as was shown in the, +        previous section. Alternatively, use one or more occurrences of the, +        from another file or files. For example:</para>, +        <para>In the preceding example, external bean definitions are loaded, +        from three files, <literal>services.xml</literal>,, +        <literal>themeSource.xml</literal>. All location paths are relative to, +        the definition file doing the importing, so, +        <literal>services.xml</literal> must be in the same directory or, +        classpath location as the file doing the importing, while, +        importing file. As you can see, a leading slash is ignored, but given, +        that these paths are relative, it is better form not to use the slash, +        at all. The contents of the files being imported, including the top, +        level <literal>&lt;beans/&gt;</literal> element, must be valid XML, +        bean definitions according to the Spring Schema or DTD.</para>, +          dependency on a file that is outside the current application. In, +          particular, this reference is not recommended for "classpath:" URLs, +          (for example, "classpath:../services.xml"), where the runtime, +          resolution process chooses the "nearest" classpath root and then, +          looks into its parent directory. Classpath configuration changes may, +          lead to the choice of a different, incorrect directory.</para>, +          placeholders</link>, "${...}", that are resolved against externally, +		  defined properties at runtime.</para>, +      <para>You use <methodname>getBean</methodname> to retrieve instances of, +      your beans. The <interfacename>ApplicationContext</interfacename> , +	  interface has a few other methods for retrieving beans, but ideally your application code, +    <title>Bean overview</title>, +    <emphasis>beans</emphasis>. These beans are created with the, +    <para>This metadata translates to a set of properties that make up each, +    bean definition. The following table lists some of, +            <entry>Property</entry>, +    <para>In addition to bean definitions that contain information on how to create a, +    specific bean, the <interfacename>ApplicationContext</interfacename>, +      <para>In XML-based configuration metadata, you use the, +      linkend="beans-servicelocation">Service Location</link> style lookup,, +      you must provide a name. Motivations for not, +        <literal>fromName</literal>, may also after the use of this alias, +        definition, be referred to as <literal>toName</literal>.</para>, +      (or class) of object that is to be instantiated in the, +      on a <interfacename>BeanDefinition</interfacename> instance, is usually, +            <para>Typically, to specify the bean class to be constructed in, +            the case where the container itself directly creates the bean by, +            calling its constructor reflectively, somewhat equivalent to Java, +            code using the <code>new</code> operator.</para>, +          <para>To specify the actual class containing the, +          <literal>static</literal> factory method that will be invoked to, +          create the object, in the less common case where the container, +          invokes a <literal>static</literal>, <emphasis>factory</emphasis>, +          method on a class to create the bean. The object type returned from, +          the invocation of the <literal>static</literal> factory method may, +          be the same class or another class entirely.</para>, +        <title>Instantiation with a constructor</title>, +        being developed does not need to implement any specific interfaces or to be, +        coded in a specific fashion. Simply specifying the bean class should, +        suffice. However, depending on what type of IoC you are going to use, +        <para>The Spring IoC container can manage virtually, +        JavaBeans with only a default (no-argument) constructor and, +        <para>For details about the mechanism for supplying arguments to the, +        constructor (if required) and setting object instance properties after, +        the object is constructed, see <link, +        <title>Instantiation with a static factory method</title>, +        (with optional arguments as described later) and return a live object,, +        which subsequently is treated as if it had been created through a, +        constructor. One use for such a bean definition is to call, +        <literal>static</literal> factories in legacy code.</para>, +        <para>The following bean definition specifies that the bean will be, +        created by calling a factory-method. The definition does not specify, +        the type (class) of the returned object, only the class containing the, +        factory method. In this example, the, +        <para>For details about the mechanism for supplying (optional), +        arguments to the factory method and setting object instance properties, +        after the object is returned from the factory, see <link, +        method</link>, instantiation with an instance factory method invokes a, +        non-static method of an existing bean from the container to create a, +        new bean. To use this mechanism, leave the <literal>class, +        </literal>attribute empty, and in the <literal>factory-bean</literal>, +        attribute, specify the name of a bean in the current (or, +        parent/ancestor) container that contains the instance method that is, +        to be invoked to create the object. Set the name of the factory method, +        itself with the <literal>factory-method</literal> attribute.</para>]