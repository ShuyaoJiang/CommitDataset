[+++ b/spring-jms/src/test/java/org/springframework/jms/listener/DefaultMessageListenerContainerTests.java, + * Copyright 2002-2016 the original author or authors., +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +		BackOff backOff = mock(BackOff.class);, +		given(backOff.start()).willReturn(execution);, +		DefaultMessageListenerContainer container = createContainer(createFailingContainerFactory());, +		container.setBackOff(backOff);, +		verify(backOff).start();, +		BackOff backOff = mock(BackOff.class);, +		given(backOff.start()).willReturn(execution);, +		DefaultMessageListenerContainer container = createContainer(createFailingContainerFactory());, +		container.setBackOff(backOff);, +		verify(backOff).start();, +		BackOff backOff = mock(BackOff.class);, +		given(backOff.start()).willReturn(execution);, +		DefaultMessageListenerContainer container = createContainer(createRecoverableContainerFactory(1));, +		container.setBackOff(backOff);, +		verify(backOff).start();, +	@Test, +	public void runnableIsInvokedEvenIfContainerIsNotRunning() throws InterruptedException {, +		DefaultMessageListenerContainer container = createRunningContainer();, +		container.stop();, +, +		// container is stopped but should nevertheless invoke the runnable argument, +		TestRunnable runnable2 = new TestRunnable();, +		container.stop(runnable2);, +		runnable2.waitForCompletion();, +	}, +, +	private DefaultMessageListenerContainer createRunningContainer() {, +		DefaultMessageListenerContainer container = createContainer(createSuccessfulConnectionFactory());, +		container.afterPropertiesSet();, +		container.start();, +		return container;, +	}, +, +	private DefaultMessageListenerContainer createContainer(ConnectionFactory connectionFactory) {, +	private ConnectionFactory createSuccessfulConnectionFactory() {, +		try {, +			ConnectionFactory connectionFactory = mock(ConnectionFactory.class);, +			given(connectionFactory.createConnection()).willReturn(mock(Connection.class));, +			return connectionFactory;, +		}, +		catch (JMSException e) {, +			throw new IllegalStateException(); // never happen, +		}, +	}, +, +	private static class TestRunnable implements Runnable {, +		private final CountDownLatch countDownLatch = new CountDownLatch(1);, +, +		@Override, +		public void run() {, +			this.countDownLatch.countDown();, +		}, +, +		public void waitForCompletion() throws InterruptedException {, +			this.countDownLatch.await(2, TimeUnit.SECONDS);, +			assertEquals("callback was not invoked", 0, this.countDownLatch.getCount());, +		}, +, +	}, +]