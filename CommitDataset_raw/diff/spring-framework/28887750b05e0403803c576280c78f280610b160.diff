[+++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/MessageConversionException.java, + * Copyright 2002-2014 the original author or authors., +	public MessageConversionException(String description) {, +		super(description);, +	}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/MessageConversionException.java, + * Copyright 2002-2014 the original author or authors., +	public MessageConversionException(String description) {, +		super(description);, +	}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractDestinationResolvingMessagingTemplate.java, + * Copyright 2002-2014 the original author or authors., +		doSend(destination, message);, +		Assert.state(this.destinationResolver != null, "DestinationResolver is required to resolve destination names");, +		convertAndSend(destinationName, payload, null, null);, +		convertAndSend(destinationName, payload, headers, null);, +		convertAndSend(destinationName, payload, null, postProcessor);, +	public <T> void convertAndSend(String destinationName, T payload, Map<String, Object> headers, MessagePostProcessor postProcessor) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/MessageConversionException.java, + * Copyright 2002-2014 the original author or authors., +	public MessageConversionException(String description) {, +		super(description);, +	}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractDestinationResolvingMessagingTemplate.java, + * Copyright 2002-2014 the original author or authors., +		doSend(destination, message);, +		Assert.state(this.destinationResolver != null, "DestinationResolver is required to resolve destination names");, +		convertAndSend(destinationName, payload, null, null);, +		convertAndSend(destinationName, payload, headers, null);, +		convertAndSend(destinationName, payload, null, postProcessor);, +	public <T> void convertAndSend(String destinationName, T payload, Map<String, Object> headers, MessagePostProcessor postProcessor) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +, +	protected final Log logger = LogFactory.getLog(getClass());, +		send(getRequiredDefaultDestination(), message);, +		Assert.state(this.defaultDestination != null, "No 'defaultDestination' configured");, +		doSend(destination, message);, +		convertAndSend(getRequiredDefaultDestination(), payload);, +		convertAndSend(destination, payload, (Map<String, Object>) null);, +		convertAndSend(destination, payload, headers, null);, +		convertAndSend(getRequiredDefaultDestination(), payload, postProcessor);, +		convertAndSend(destination, payload, null, postProcessor);, +		Map<String, Object> headersToUse = processHeadersToSend(headers);, +		if (headersToUse != null) {, +			if (headersToUse instanceof MessageHeaders) {, +				messageHeaders = (MessageHeaders) headersToUse;, +				messageHeaders = new MessageHeaders(headersToUse);, +		Message<?> message = getMessageConverter().toMessage(payload, messageHeaders);, +			String payloadType = (payload != null ? payload.getClass().getName() : null);, +			Object contentType = (messageHeaders != null ? messageHeaders.get(MessageHeaders.CONTENT_TYPE) : null);, +			throw new MessageConversionException("Unable to convert payload with type='" + payloadType +, +					"', contentType='" + contentType + "', converter=[" + getMessageConverter() + "]");, +		send(destination, message);, +	 * @param headers the headers to send or {@code null}, +	 * @return the actual headers to send or {@code null}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/MessageConversionException.java, + * Copyright 2002-2014 the original author or authors., +	public MessageConversionException(String description) {, +		super(description);, +	}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractDestinationResolvingMessagingTemplate.java, + * Copyright 2002-2014 the original author or authors., +		doSend(destination, message);, +		Assert.state(this.destinationResolver != null, "DestinationResolver is required to resolve destination names");, +		convertAndSend(destinationName, payload, null, null);, +		convertAndSend(destinationName, payload, headers, null);, +		convertAndSend(destinationName, payload, null, postProcessor);, +	public <T> void convertAndSend(String destinationName, T payload, Map<String, Object> headers, MessagePostProcessor postProcessor) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +, +	protected final Log logger = LogFactory.getLog(getClass());, +		send(getRequiredDefaultDestination(), message);, +		Assert.state(this.defaultDestination != null, "No 'defaultDestination' configured");, +		doSend(destination, message);, +		convertAndSend(getRequiredDefaultDestination(), payload);, +		convertAndSend(destination, payload, (Map<String, Object>) null);, +		convertAndSend(destination, payload, headers, null);, +		convertAndSend(getRequiredDefaultDestination(), payload, postProcessor);, +		convertAndSend(destination, payload, null, postProcessor);, +		Map<String, Object> headersToUse = processHeadersToSend(headers);, +		if (headersToUse != null) {, +			if (headersToUse instanceof MessageHeaders) {, +				messageHeaders = (MessageHeaders) headersToUse;, +				messageHeaders = new MessageHeaders(headersToUse);, +		Message<?> message = getMessageConverter().toMessage(payload, messageHeaders);, +			String payloadType = (payload != null ? payload.getClass().getName() : null);, +			Object contentType = (messageHeaders != null ? messageHeaders.get(MessageHeaders.CONTENT_TYPE) : null);, +			throw new MessageConversionException("Unable to convert payload with type='" + payloadType +, +					"', contentType='" + contentType + "', converter=[" + getMessageConverter() + "]");, +		send(destination, message);, +	 * @param headers the headers to send or {@code null}, +	 * @return the actual headers to send or {@code null}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessagingTemplate.java, +		return receive(getRequiredDefaultDestination());, +		return doReceive(destination);, +		return receiveAndConvert(getRequiredDefaultDestination(), targetClass);, +		Message<?> message = doReceive(destination);, +		return sendAndReceive(getRequiredDefaultDestination(), requestMessage);, +		return doSendAndReceive(destination, requestMessage);, +		return convertSendAndReceive(getRequiredDefaultDestination(), request, targetClass);]