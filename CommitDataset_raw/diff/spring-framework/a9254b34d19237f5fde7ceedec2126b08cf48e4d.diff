[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanDefinition.java, + * Copyright 2002-2009 the original author or authors., +	private boolean lenientConstructorResolution = true;, +, +			setLenientConstructorResolution(originalAbd.isLenientConstructorResolution());, +			setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());, +	public void copyQualifiersFrom(AbstractBeanDefinition source) {, +	 * Specify whether to resolve constructors in lenient mode (<code>true</code>,, +	 * which is the default) or to switch to strict resolution (throwing an exception, +	 * in case of ambigious constructors that all match when converting the arguments,, +	 * whereas lenient mode would use the one with the 'closest' type matches)., +	 */, +	public void setLenientConstructorResolution(boolean lenientConstructorResolution) {, +		this.lenientConstructorResolution = lenientConstructorResolution;, +	}, +, +	/**, +	 * Return whether to resolve constructors in lenient mode or in strict mode., +	 */, +	public boolean isLenientConstructorResolution() {, +		return this.lenientConstructorResolution;, +	}, +, +	/**, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanDefinition.java, + * Copyright 2002-2009 the original author or authors., +	private boolean lenientConstructorResolution = true;, +, +			setLenientConstructorResolution(originalAbd.isLenientConstructorResolution());, +			setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());, +	public void copyQualifiersFrom(AbstractBeanDefinition source) {, +	 * Specify whether to resolve constructors in lenient mode (<code>true</code>,, +	 * which is the default) or to switch to strict resolution (throwing an exception, +	 * in case of ambigious constructors that all match when converting the arguments,, +	 * whereas lenient mode would use the one with the 'closest' type matches)., +	 */, +	public void setLenientConstructorResolution(boolean lenientConstructorResolution) {, +		this.lenientConstructorResolution = lenientConstructorResolution;, +	}, +, +	/**, +	 * Return whether to resolve constructors in lenient mode or in strict mode., +	 */, +	public boolean isLenientConstructorResolution() {, +		return this.lenientConstructorResolution;, +	}, +, +	/**, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, +				else if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight &&, +						!mbd.isLenientConstructorResolution()) {, +					throw new BeanCreationException(mbd.getResourceDescription(), beanName,, +							"Ambiguous constructor matches found in bean '" + beanName + "' " +, +							"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");, +				}, +				ConstructorArgumentValues.ValueHolder sourceHolder =, +						(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();, +				Object originalValue = valueHolder.getValue();, +				Object sourceValue = sourceHolder.getValue();, +					args.rawArguments[paramIndex] =, +							(mbd.isLenientConstructorResolution() ? originalValue : convertedValue);, +						args.rawArguments[paramIndex] =, +								(mbd.isLenientConstructorResolution() ? originalValue : convertedValue);, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanDefinition.java, + * Copyright 2002-2009 the original author or authors., +	private boolean lenientConstructorResolution = true;, +, +			setLenientConstructorResolution(originalAbd.isLenientConstructorResolution());, +			setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());, +	public void copyQualifiersFrom(AbstractBeanDefinition source) {, +	 * Specify whether to resolve constructors in lenient mode (<code>true</code>,, +	 * which is the default) or to switch to strict resolution (throwing an exception, +	 * in case of ambigious constructors that all match when converting the arguments,, +	 * whereas lenient mode would use the one with the 'closest' type matches)., +	 */, +	public void setLenientConstructorResolution(boolean lenientConstructorResolution) {, +		this.lenientConstructorResolution = lenientConstructorResolution;, +	}, +, +	/**, +	 * Return whether to resolve constructors in lenient mode or in strict mode., +	 */, +	public boolean isLenientConstructorResolution() {, +		return this.lenientConstructorResolution;, +	}, +, +	/**, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java, +				else if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight &&, +						!mbd.isLenientConstructorResolution()) {, +					throw new BeanCreationException(mbd.getResourceDescription(), beanName,, +							"Ambiguous constructor matches found in bean '" + beanName + "' " +, +							"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");, +				}, +				ConstructorArgumentValues.ValueHolder sourceHolder =, +						(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();, +				Object originalValue = valueHolder.getValue();, +				Object sourceValue = sourceHolder.getValue();, +					args.rawArguments[paramIndex] =, +							(mbd.isLenientConstructorResolution() ? originalValue : convertedValue);]