[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +, +		StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.CONNECT);, +		headers.setAcceptVersion("1.1,1.2");, +		headers.setLogin(this.systemLogin);, +		headers.setPasscode(this.systemPasscode);, +		headers.setHeartbeat(this.systemHeartbeatSendInterval, this.systemHeartbeatReceiveInterval);, +		headers.setHost(getVirtualHost());, +		Message<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +, +		session.connect(message);, +, +			this.relaySessions.put(sessionId, session);, +		private static final long HEARTBEAT_MULTIPLIER = 3;, +, +		private final boolean isRemoteClientSession;, +, +		private final long reconnectInterval;, +, +		private volatile StompHeaderAccessor connectHeaders;, +, +		private volatile StompHeaderAccessor connectedHeaders;, +, +			this(sessionId, true, 0);, +		}, +, +		private StompRelaySession(String sessionId, boolean isRemoteClientSession, long reconnectInterval) {, +			this.isRemoteClientSession = isRemoteClientSession;, +			this.reconnectInterval = reconnectInterval;, +			Assert.notNull(connectMessage, "connectMessage is required");, +			this.connectHeaders = StompHeaderAccessor.wrap(connectMessage);, +, +			Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> promise;, +			if (this.reconnectInterval > 0) {, +				promise = tcpClient.open(new Reconnect() {, +					@Override, +					public Tuple2<InetSocketAddress, Long> reconnect(InetSocketAddress address, int attempt) {, +						return Tuple.of(address, 5000L);, +					}, +				});, +			}, +			else {, +				promise = tcpClient.open();, +			}, +, +				this.connectedHeaders = headers;, +				connected();, +		private void initHeartbeats() {, +, +			long clientSendInterval = this.connectHeaders.getHeartbeat()[0];, +			long clientReceiveInterval = this.connectHeaders.getHeartbeat()[1];, +, +			long serverSendInterval = this.connectedHeaders.getHeartbeat()[0];, +			long serverReceiveInterval = this.connectedHeaders.getHeartbeat()[1];, +, +			if ((clientSendInterval > 0) && (serverReceiveInterval > 0)) {, +				long interval = Math.max(clientSendInterval,  serverReceiveInterval);, +				stompConnection.connection.on().writeIdle(interval, new Runnable() {, +, +					@Override, +					public void run() {, +						TcpConnection<Message<byte[]>, Message<byte[]>> tcpConn = stompConnection.connection;, +						if (tcpConn != null) {, +							tcpConn.send(MessageBuilder.withPayload(new byte[] {'\n'}).build(),, +								new Consumer<Boolean>() {, +									@Override, +									public void accept(Boolean result) {, +										if (!result) {, +											handleTcpClientFailure("Failed to send heartbeat to the broker", null);, +										}, +									}, +								});, +						}, +					}, +				});, +			}, +, +			if (clientReceiveInterval > 0 && serverSendInterval > 0) {, +				final long interval = Math.max(clientReceiveInterval, serverSendInterval) * HEARTBEAT_MULTIPLIER;, +				stompConnection.connection.on().readIdle(interval,  new Runnable() {, +, +					@Override, +					public void run() {, +						String message = "Broker hearbeat missed: connection idle for more than " + interval + "ms";, +						if (logger.isWarnEnabled()) {, +							logger.warn(message);, +						}, +						disconnected(message);, +					}, +				});, +			}, +		}, +, +		protected void connected() {, +			if (!this.isRemoteClientSession) {, +				initHeartbeats();, +			}, +			if (this.isRemoteClientSession) {, +			else {, +				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message);]