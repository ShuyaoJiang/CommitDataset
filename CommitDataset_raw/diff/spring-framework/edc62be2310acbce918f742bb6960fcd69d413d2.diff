[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +		throw new NoSuchBeanDefinitionException(requiredType);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +		throw new NoSuchBeanDefinitionException(requiredType);, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java, +import org.springframework.beans.factory.BeanNameAware;, +import org.springframework.beans.factory.config.AutowireCapableBeanFactory;, +import org.springframework.beans.factory.config.ConfigurableBeanFactory;, +import org.springframework.beans.factory.config.NamedBeanHolder;, +import org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor;, +import org.springframework.beans.factory.support.RootBeanDefinition;, +public class ScheduledAnnotationBeanPostProcessor, +		implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor,, +		Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware,, +	private String beanName;, +, +	@Override, +	public void setBeanName(String beanName) {, +		this.beanName = beanName;, +	}, +, +				this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, false));, +					this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, true));, +					this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, false));, +						this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, true));, +	private <T> T resolveSchedulerBean(Class<T> schedulerType, boolean byName) {, +		if (byName) {, +			T scheduler = this.beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);, +			if (this.beanFactory instanceof ConfigurableBeanFactory) {, +				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(, +						DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);, +			}, +			return scheduler;, +		}, +		else if (this.beanFactory instanceof AutowireCapableBeanFactory) {, +			NamedBeanHolder<T> holder = ((AutowireCapableBeanFactory) this.beanFactory).resolveNamedBean(schedulerType);, +			if (this.beanFactory instanceof ConfigurableBeanFactory) {, +				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(, +						holder.getBeanName(), this.beanName);, +			}, +			return holder.getBeanInstance();, +		}, +		else {, +			return this.beanFactory.getBean(schedulerType);, +		}, +	}, +, +, +	@Override, +	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {, +	}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +		throw new NoSuchBeanDefinitionException(requiredType);, +++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java, +import org.springframework.beans.factory.BeanNameAware;, +import org.springframework.beans.factory.config.AutowireCapableBeanFactory;, +import org.springframework.beans.factory.config.ConfigurableBeanFactory;, +import org.springframework.beans.factory.config.NamedBeanHolder;, +import org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor;, +import org.springframework.beans.factory.support.RootBeanDefinition;, +public class ScheduledAnnotationBeanPostProcessor, +		implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor,, +		Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware,, +	private String beanName;, +, +	@Override, +	public void setBeanName(String beanName) {, +		this.beanName = beanName;, +	}, +, +				this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, false));, +					this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, true));, +					this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, false));, +						this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, true));, +	private <T> T resolveSchedulerBean(Class<T> schedulerType, boolean byName) {, +		if (byName) {, +			T scheduler = this.beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);, +			if (this.beanFactory instanceof ConfigurableBeanFactory) {, +				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(, +						DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);, +			}, +			return scheduler;, +		}, +		else if (this.beanFactory instanceof AutowireCapableBeanFactory) {, +			NamedBeanHolder<T> holder = ((AutowireCapableBeanFactory) this.beanFactory).resolveNamedBean(schedulerType);, +			if (this.beanFactory instanceof ConfigurableBeanFactory) {, +				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(, +						holder.getBeanName(), this.beanName);, +			}, +			return holder.getBeanInstance();, +		}, +		else {, +			return this.beanFactory.getBean(schedulerType);, +		}, +	}, +, +, +	@Override, +	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {, +	}]