[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java, + * Static factory methods for {@link BodyExtractor} implementations., + * @author Rossen Stoyanchev, +	private static final ResolvableType FORM_DATA_TYPE =, +	private static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(, +, +	 * Extractor to decode the input content into {@code Mono<T>}., +	 * @param elementClass the class of the element type to decode to, +	 * @param <T> the element type to decode to, +	 * @return {@code BodyExtractor} for {@code Mono<T>}, +	 * Variant of {@link #toMono(Class)} for type information with generics., +	 * @param typeRef the type reference for the type to decode to, +	 * @param <T> the element type to decode to, +	 * @return {@code BodyExtractor} for {@code Mono<T>}, +	public static <T> BodyExtractor<Mono<T>, ReactiveHttpInputMessage> toMono(ParameterizedTypeReference<T> typeRef) {, +		return toMono(ResolvableType.forType(typeRef.getType()));, +	private static <T> BodyExtractor<Mono<T>, ReactiveHttpInputMessage> toMono(ResolvableType elementType) {, +		return (inputMessage, context) ->, +				readWithMessageReaders(inputMessage, context, elementType,, +						(HttpMessageReader<T> reader) -> readToMono(inputMessage, context, elementType, reader),, +						ex -> Mono.from(unsupportedErrorHandler(inputMessage, ex)),, +	 * Extractor to decode the input content into {@code Flux<T>}., +	 * @param elementClass the class of the element type to decode to, +	 * @param <T> the element type to decode to, +	 * @return {@code BodyExtractor} for {@code Flux<T>}, +	 * Variant of {@link #toFlux(Class)} for type information with generics., +	 * @param typeRef the type reference for the type to decode to, +	 * @param <T> the element type to decode to, +	 * @return {@code BodyExtractor} for {@code Flux<T>}, +	public static <T> BodyExtractor<Flux<T>, ReactiveHttpInputMessage> toFlux(ParameterizedTypeReference<T> typeRef) {, +		return toFlux(ResolvableType.forType(typeRef.getType()));, +	private static <T> BodyExtractor<Flux<T>, ReactiveHttpInputMessage> toFlux(ResolvableType elementType) {, +		return (inputMessage, context) ->, +				readWithMessageReaders(inputMessage, context, elementType,, +						(HttpMessageReader<T> reader) -> readToFlux(inputMessage, context, elementType, reader),, +						ex -> unsupportedErrorHandler(inputMessage, ex),, +, +	// Extractors for specific content .., +	 * Extractor to read form data into {@code MultiValueMap<String, String>}., +	 * @return {@code BodyExtractor} for form data, +			ResolvableType elementType = FORM_DATA_TYPE;, +			MediaType mediaType = MediaType.APPLICATION_FORM_URLENCODED;, +			HttpMessageReader<MultiValueMap<String, String>> reader = findReader(elementType, mediaType, context);, +			return readToMono(message, context, elementType, reader);, +	 * Extractor to read multipart data into a {@code MultiValueMap<String, Part>}., +	 * @return {@code BodyExtractor} for multipart data, +	// Parameterized for server-side use, +			ResolvableType elementType = MULTIPART_DATA_TYPE;, +			MediaType mediaType = MediaType.MULTIPART_FORM_DATA;, +			HttpMessageReader<MultiValueMap<String, Part>> reader = findReader(elementType, mediaType, context);, +			return readToMono(serverRequest, context, elementType, reader);, +	 * Extractor to read multipart data into {@code Flux<Part>}., +	 * @return {@code BodyExtractor} for multipart request parts, +	// Parameterized for server-side use, +			ResolvableType elementType = PART_TYPE;, +			MediaType mediaType = MediaType.MULTIPART_FORM_DATA;, +			HttpMessageReader<Part> reader = findReader(elementType, mediaType, context);, +			return readToFlux(serverRequest, context, elementType, reader);, +	 * Extractor that returns the raw {@link DataBuffer}s., +	 * <p><strong>Note:</strong> the data buffers should be, +	 * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer), +	 * released} after being used., +	 * @return {@code BodyExtractor} for data buffers, +	// Private support methods, +, +			ReactiveHttpInputMessage message, BodyExtractor.Context context, ResolvableType elementType,, +			Function<UnsupportedMediaTypeException, S> errorFunction,, +			Supplier<S> emptySupplier) {, +			return emptySupplier.get();, +, +		MediaType contentType = Optional.ofNullable(message.getHeaders().getContentType()), +				.orElse(MediaType.APPLICATION_OCTET_STREAM);, +, +		return context.messageReaders().stream(), +				.filter(reader -> reader.canRead(elementType, contentType)), +				.orElseGet(() -> errorFunction.apply(unsupportedError(context, elementType, contentType)));, +	private static UnsupportedMediaTypeException unsupportedError(BodyExtractor.Context context,, +			ResolvableType elementType, MediaType contentType) {, +, +		List<MediaType> supportedMediaTypes = context.messageReaders().stream(), +				.flatMap(reader -> reader.getReadableMediaTypes().stream()), +				.collect(Collectors.toList());, +, +		return new UnsupportedMediaTypeException(contentType, supportedMediaTypes, elementType);, +	}, +, +	private static <T> Mono<T> readToMono(ReactiveHttpInputMessage message, BodyExtractor.Context context,, +			ResolvableType type, HttpMessageReader<T> reader) {, +, +		return context.serverResponse(), +				.map(response -> reader.readMono(type, type, (ServerHttpRequest) message, response, context.hints())), +				.orElseGet(() -> reader.readMono(type, message, context.hints()));, +	}, +, +	private static <T> Flux<T> readToFlux(ReactiveHttpInputMessage message, BodyExtractor.Context context,, +			ResolvableType type, HttpMessageReader<T> reader) {, +, +		return context.serverResponse(), +				.map(response -> reader.read(type, type, (ServerHttpRequest) message, response, context.hints())), +				.orElseGet(() -> reader.read(type, message, context.hints()));]