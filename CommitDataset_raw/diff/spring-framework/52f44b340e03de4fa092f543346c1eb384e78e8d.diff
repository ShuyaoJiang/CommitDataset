[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConditionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +				Condition condition = getCondition(conditionClass, this.context.getClassLoader());, +					if (!condition.matches(this.context, metadata)) {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConditionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +				Condition condition = getCondition(conditionClass, this.context.getClassLoader());, +					if (!condition.matches(this.context, metadata)) {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2014 the original author or authors., +	private final Set<ConfigurationClass> importedBy = new LinkedHashSet<ConfigurationClass>(1);, +		this.importedBy.add(importedBy);, +		this.importedBy.add(importedBy);, +		return !this.importedBy.isEmpty();, +	 * Merge the imported-by declarations from the given configuration class into this one., +	 * @since 4.0.5, +	 */, +	public void mergeImportedBy(ConfigurationClass otherConfigClass) {, +		this.importedBy.addAll(otherConfigClass.importedBy);, +	}, +, +	/**, +	 * Return the configuration classes that imported this class,, +	 * or an empty Set if this configuration was not imported., +	 * @since 4.0.5, +	public Set<ConfigurationClass> getImportedBy() {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConditionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +				Condition condition = getCondition(conditionClass, this.context.getClassLoader());, +					if (!condition.matches(this.context, metadata)) {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2014 the original author or authors., +	private final Set<ConfigurationClass> importedBy = new LinkedHashSet<ConfigurationClass>(1);, +		this.importedBy.add(importedBy);, +		this.importedBy.add(importedBy);, +		return !this.importedBy.isEmpty();, +	 * Merge the imported-by declarations from the given configuration class into this one., +	 * @since 4.0.5, +	 */, +	public void mergeImportedBy(ConfigurationClass otherConfigClass) {, +		this.importedBy.addAll(otherConfigClass.importedBy);, +	}, +, +	/**, +	 * Return the configuration classes that imported this class,, +	 * or an empty Set if this configuration was not imported., +	 * @since 4.0.5, +	public Set<ConfigurationClass> getImportedBy() {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, + * Copyright 2002-2014 the original author or authors., +					boolean allSkipped = true;, +					for (ConfigurationClass importedBy : configClass.getImportedBy()) {, +						if (!shouldSkip(importedBy)) {, +							allSkipped = false;, +						}, +					}, +					if (allSkipped) {, +						// The config classes that imported this one were all skipped, therefore we are skipped..., +					skip = conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConditionEvaluator.java, + * Copyright 2002-2014 the original author or authors., +				Condition condition = getCondition(conditionClass, this.context.getClassLoader());, +					if (!condition.matches(this.context, metadata)) {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, + * Copyright 2002-2014 the original author or authors., +	private final Set<ConfigurationClass> importedBy = new LinkedHashSet<ConfigurationClass>(1);, +		this.importedBy.add(importedBy);, +		this.importedBy.add(importedBy);, +		return !this.importedBy.isEmpty();, +	 * Merge the imported-by declarations from the given configuration class into this one., +	 * @since 4.0.5, +	 */, +	public void mergeImportedBy(ConfigurationClass otherConfigClass) {, +		this.importedBy.addAll(otherConfigClass.importedBy);, +	}, +, +	/**, +	 * Return the configuration classes that imported this class,, +	 * or an empty Set if this configuration was not imported., +	 * @since 4.0.5, +	public Set<ConfigurationClass> getImportedBy() {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, + * Copyright 2002-2014 the original author or authors., +					boolean allSkipped = true;, +					for (ConfigurationClass importedBy : configClass.getImportedBy()) {, +						if (!shouldSkip(importedBy)) {, +							allSkipped = false;, +						}, +					}, +					if (allSkipped) {, +						// The config classes that imported this one were all skipped, therefore we are skipped..., +					skip = conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import java.util.LinkedHashMap;, +	private final Map<ConfigurationClass, ConfigurationClass> configurationClasses =, +			new LinkedHashMap<ConfigurationClass, ConfigurationClass>();, +		ConfigurationClass existingClass = this.configurationClasses.get(configClass);, +		if (existingClass != null) {, +			if (configClass.isImported()) {, +				if (existingClass.isImported()) {]