[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, +	private boolean argumentConversionOccurred;, +, +		argumentConversionOccurred = false;, +		if (this.method == null || argumentConversionOccurred) {, +			return false;, +		}, +		int methodModifiers = this.method.getModifiers();, +		if (!Modifier.isStatic(methodModifiers) || , +			!Modifier.isPublic(methodModifiers) ||, +			!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {, +			return false;, +		}, +		for (SpelNodeImpl child : this.children) {, +			if (!child.isCompilable()) {, +				return false;, +			}, +		}, +		return true;, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java, +	private boolean argumentConversionOccurred;, +, +		argumentConversionOccurred = false;, +		if (this.method == null || argumentConversionOccurred) {, +			return false;, +		}, +		int methodModifiers = this.method.getModifiers();, +		if (!Modifier.isStatic(methodModifiers) || , +			!Modifier.isPublic(methodModifiers) ||, +			!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {, +			return false;, +		}, +		for (SpelNodeImpl child : this.children) {, +			if (!child.isCompilable()) {, +				return false;, +			}, +		}, +		return true;, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java, +, +	// TODO could do with more refactoring around argument handling and varargs, +	/**, +	 * Convert a supplied set of arguments into the requested types. If the parameterTypes are related to, +	 * a varargs method then the final entry in the parameterTypes array is going to be an array itself whose, +	 * component type should be used as the conversion target for extraneous arguments. (For example, if the, +	 * parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both, +	 * the boolean and float must be converted to strings). This method does *not* repackage the arguments, +	 * into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that., +	 * @param converter the converter to use for type conversions, +	 * @param arguments the arguments to convert to the requested parameter types, +	 * @param method the target Method, +	 * @return true if some kind of conversion occurred on the argument, +	 * @throws SpelEvaluationException if there is a problem with conversion, +	 */, +	public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {, +		Integer varargsPosition = method.isVarArgs() ? method.getParameterTypes().length-1:null;, +		return convertArguments(converter, arguments, method, varargsPosition);, +	}, +	, +	 * @param varargsPosition the known position of the varargs argument, if any (null if not varargs), +			// Convert everything up to the varargs position, +				// If the target is varargs and there is just one more argument, +				// then convert it here, +				// Three outcomes of that previous line:, +				// 1) the input argument was already compatible (ie. array of valid type) and nothing was done, +				// 2) the input argument was correct type but not in an array so it was made into an array, +				// 3) the input argument was the wrong type and got converted and put into an array, +				if (argument != arguments[varargsPosition] && , +					!isFirstEntryInArray(argument, arguments[varargsPosition])) {, +					conversionOccurred = true; // case 3, +				// Convert remaining arguments to the varargs element type, +	 * Check if the supplied value is the first entry in the array represented by the possibleArray value., +	 * @param value the value to check for in the array, +	 * @param possibleArray an array object that may have the supplied value as the first element, +	 * @return true if the supplied value is the first entry in the array, +	private static boolean isFirstEntryInArray(Object value, Object possibleArray) {, +		if (possibleArray == null) {, +			return false;, +		Class<?> type = possibleArray.getClass();, +		if (type.isArray()) {, +			Class<?> componentType = type.getComponentType();, +			if (componentType.isPrimitive()) {, +				if (componentType == Boolean.TYPE) {, +					return value instanceof Boolean && , +							((boolean[])possibleArray)[0] == (Boolean)value;, +				else if (componentType == Double.TYPE) {, +					return value instanceof Double && , +							((double[])possibleArray)[0] == (Double)value;, +				else if (componentType == Float.TYPE) {, +					return value instanceof Float && , +							((float[])possibleArray)[0] == (Float)value;, +				else if (componentType == Integer.TYPE) {, +					return value instanceof Integer && , +							((int[])possibleArray)[0] == (Integer)value;, +				else if (componentType == Long.TYPE) {, +					return value instanceof Long && , +							((long[])possibleArray)[0] == (Long)value;, +				else if (componentType == Short.TYPE) {, +					return value instanceof Short && , +							((short[])possibleArray)[0] == (Short)value;]