[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +			this.sourceAttributeName = sourceAttribute.getName();, +			this.aliasedAttributeName = getAliasedAttributeName(aliasFor, sourceAttribute);, +			if (this.aliasedAnnotationType == this.sourceAnnotationType &&, +					this.aliasedAttributeName.equals(this.sourceAttributeName)) {, +				String msg = String.format("@AliasFor declaration on attribute [%s] in annotation [%s] points to " +, +						"itself. Specify 'annotation' to point to a same-named attribute on a meta-annotation.",, +						sourceAttribute.getName(), declaringClass.getName());, +				throw new AnnotationConfigurationException(msg);, +			}, +		 * {@link AliasFor @AliasFor} annotation on the supplied {@code attribute},, +		 * or the original attribute if no aliased one specified (indicating that, +		 * the reference goes to a same-named attribute on a meta-annotation)., +		 * @param attribute the attribute that is annotated with {@code @AliasFor}, +		private String getAliasedAttributeName(AliasFor aliasFor, Method attribute) {, +			return (StringUtils.hasText(attributeName) ? attributeName.trim() : attribute.getName());, +		@Override, +		public String toString() {, +			return String.format("%s: @%s(%s) is an alias for @%s(%s)", getClass().getSimpleName(),, +					this.sourceAnnotationType.getSimpleName(), this.sourceAttributeName,, +					this.aliasedAnnotationType.getSimpleName(), this.aliasedAttributeName);, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +			this.sourceAttributeName = sourceAttribute.getName();, +			this.aliasedAttributeName = getAliasedAttributeName(aliasFor, sourceAttribute);, +			if (this.aliasedAnnotationType == this.sourceAnnotationType &&, +					this.aliasedAttributeName.equals(this.sourceAttributeName)) {, +				String msg = String.format("@AliasFor declaration on attribute [%s] in annotation [%s] points to " +, +						"itself. Specify 'annotation' to point to a same-named attribute on a meta-annotation.",, +						sourceAttribute.getName(), declaringClass.getName());, +				throw new AnnotationConfigurationException(msg);, +			}, +		 * {@link AliasFor @AliasFor} annotation on the supplied {@code attribute},, +		 * or the original attribute if no aliased one specified (indicating that, +		 * the reference goes to a same-named attribute on a meta-annotation)., +		 * @param attribute the attribute that is annotated with {@code @AliasFor}, +		private String getAliasedAttributeName(AliasFor aliasFor, Method attribute) {, +			return (StringUtils.hasText(attributeName) ? attributeName.trim() : attribute.getName());, +		@Override, +		public String toString() {, +			return String.format("%s: @%s(%s) is an alias for @%s(%s)", getClass().getSimpleName(),, +					this.sourceAnnotationType.getSimpleName(), this.sourceAttributeName,, +					this.aliasedAnnotationType.getSimpleName(), this.aliasedAttributeName);, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java, +		List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);, +		List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);, +, +		method = WebController.class.getMethod("handleMappedWithDifferentPathAndValueAttributes");, +		webMapping = method.getAnnotation(WebMapping.class);, +		exception.expectMessage(containsString("@AliasFor [location]"));, +, +		exception.expectMessage(containsString("points to itself"));, +		exception.expectMessage(containsString("@AliasFor [foo]"));, +		exception.expectMessage(containsString("same return type"));, +		exception.expectMessage(containsString("default values"));, +		exception.expectMessage(containsString("same default value"));, +		AliasedComposedContextConfigNotMetaPresent annotation =, +				AliasedComposedContextConfigNotMetaPresentClass.class.getAnnotation(AliasedComposedContextConfigNotMetaPresent.class);, +		exception.expectMessage(containsString("not meta-present"));, +		exception.expectMessage(containsString("default values"));, +		exception.expectMessage(containsString("same default value"));, +		AnnotationAttributes attributes = getAnnotationAttributes(, +				ComponentScanSingleFilterClass.class, componentScan, false, true);, +		ComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(, +				attributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);, +]