[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +		for (StompRelaySession session: this.relaySessions.values()) {, +			session.disconnect();, +		}, +		public void disconnect() {, +			this.stompConnection.setDisconnected();, +		}, +, +			publishBrokerAvailableEvent();, +		}, +, +		@Override, +		protected void disconnected(String errorMessage) {, +			super.disconnected(errorMessage);, +			publishBrokerUnavailableEvent();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +		for (StompRelaySession session: this.relaySessions.values()) {, +			session.disconnect();, +		}, +		public void disconnect() {, +			this.stompConnection.setDisconnected();, +		}, +, +			publishBrokerAvailableEvent();, +		}, +, +		@Override, +		protected void disconnected(String errorMessage) {, +			super.disconnected(errorMessage);, +			publishBrokerUnavailableEvent();, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandlerIntegrationTests.java, +		createAndStartRelay();, +	private void createAndStartRelay() throws InterruptedException {, +		this.relay = new StompBrokerRelayMessageHandler(this.responseChannel, Arrays.asList("/queue/", "/topic/"));, +		this.relay.setRelayPort(port);, +		this.relay.setApplicationEventPublisher(this.eventPublisher);, +, +		this.eventPublisher.expect(true);, +		this.relay.start();, +		this.eventPublisher.awaitAndAssert();, +	}, +, +		stopBrokerAndAwait();, +		this.relay.handleMessage(MessageBuilder.withPayloadAndHeaders("test".getBytes(), headers).build());, +	public void brokerAvailabilityEventWhenStopped() throws Exception {, +		this.eventPublisher.expect(false);]