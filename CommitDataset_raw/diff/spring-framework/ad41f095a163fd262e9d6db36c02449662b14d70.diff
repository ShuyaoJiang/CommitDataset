[+++ b/spring-websocket/src/main/java/org/springframework/web/messaging/PubSubHeaders.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.springframework.messaging.Message;, +import org.springframework.util.Assert;, +import org.springframework.util.LinkedMultiValueMap;, + * A base class for working with message headers in Web, messaging protocols that support, + * the publish-subscribe message pattern. Provides uniform access to specific values, + * common across protocols such as a destination, message type (publish,, + * subscribe/unsubscribe), session id, and others., + * <p>, + * This class can be used to prepare headers for a new pub-sub message, or to access, + * and/or modify headers of an existing message., + * <p>, + * Use one of the static factory method in this class, then call getters and setters, and, + * at the end if necessary call {@link #toMessageHeaders()} to obtain the updated headers., +	protected Log logger = LogFactory.getLog(getClass());, +, +	private static final String SUBSCRIPTION_ID = "subscriptionId";, +, +	private static final String EXTERNAL_SOURCE_HEADERS = "extSourceHeaders";, +	private static final Map<String, List<String>> emptyMultiValueMap =, +			Collections.unmodifiableMap(new LinkedMultiValueMap<String, String>(0));, +, +	// wrapped read-only message headers, +	private final MessageHeaders originalHeaders;, +, +	// header updates, +	private final Map<String, Object> headers = new HashMap<String, Object>(4);, +, +	// saved headers from a message from a remote source, +	private final Map<String, List<String>> externalSourceHeaders;, +, +	 * A constructor for creating new message headers., +	 * This constructor is protected. See factory methods in this and sub-classes., +	protected PubSubHeaders(MessageType messageType, Object protocolMessageType,, +			Map<String, List<String>> externalSourceHeaders) {, +		this.originalHeaders = null;, +, +		Assert.notNull(messageType, "messageType is required");, +		this.headers.put(MESSAGE_TYPE, messageType);, +, +			this.headers.put(PROTOCOL_MESSAGE_TYPE, protocolMessageType);, +		if (externalSourceHeaders == null) {, +			this.externalSourceHeaders = emptyMultiValueMap;, +		else {, +			this.externalSourceHeaders = Collections.unmodifiableMap(externalSourceHeaders); // TODO: list values must also be read-only, +			this.headers.put(EXTERNAL_SOURCE_HEADERS, this.externalSourceHeaders);, +		}, +	 * A constructor for accessing and modifying existing message headers. This, +	 * constructor is protected. See factory methods in this and sub-classes., +	protected PubSubHeaders(MessageHeaders originalHeaders) {, +		this.originalHeaders = originalHeaders;, +		this.externalSourceHeaders = (originalHeaders.get(EXTERNAL_SOURCE_HEADERS) != null) ?, +				(Map<String, List<String>>) originalHeaders.get(EXTERNAL_SOURCE_HEADERS) : emptyMultiValueMap;, +	/**, +	 * Create {@link PubSubHeaders} for a new {@link Message}., +	 */, +	public static PubSubHeaders create() {, +		return new PubSubHeaders(MessageType.MESSAGE, null, null);, +	/**, +	 * Create {@link PubSubHeaders} from existing message headers., +	 */, +	public static PubSubHeaders fromMessageHeaders(MessageHeaders originalHeaders) {, +		return new PubSubHeaders(originalHeaders);, +	}, +, +, +	/**, +	 * Return the original, wrapped headers (i.e. unmodified) or a new Map including any, +	 * updates made via setters., +	 */, +	public Map<String, Object> toMessageHeaders() {, +		if (!isModified()) {, +			return this.originalHeaders;, +		}, +		Map<String, Object> result = new HashMap<String, Object>();, +		if (this.originalHeaders != null) {, +			result.putAll(this.originalHeaders);, +		}, +		result.putAll(this.headers);, +		return result;, +	}, +, +	public boolean isModified() {, +		return ((this.originalHeaders == null) || !this.headers.isEmpty());, +		return (MessageType) getHeaderValue(MESSAGE_TYPE);, +	private Object getHeaderValue(String headerName) {, +		if (this.headers.get(headerName) != null) {, +			return this.headers.get(headerName);, +		}, +		else if (this.originalHeaders.get(headerName) != null) {, +			return this.originalHeaders.get(headerName);, +		}, +		return null;, +	protected void setProtocolMessageType(Object protocolMessageType) {, +		this.headers.put(PROTOCOL_MESSAGE_TYPE, protocolMessageType);, +	}, +, +	protected Object getProtocolMessageType() {]