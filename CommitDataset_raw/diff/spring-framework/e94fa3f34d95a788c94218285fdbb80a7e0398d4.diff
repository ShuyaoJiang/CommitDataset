[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2017 the original author or authors., +	 * Return the headers used in the handshake request (never {@code null})., +	 * @return a Map with the session attributes (never {@code null}), +	 * Return a {@link java.security.Principal} instance containing the name, +	 * of the authenticated user., +	 * Return the negotiated sub-protocol., +	 * @return the protocol identifier, or {@code null} if no protocol, +	 * was specified or negotiated successfully, +	 * Determine the negotiated extensions., +	 * @return the list of extensions, or an empty list if no extension, +	 * was specified or negotiated successfully, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2017 the original author or authors., +	 * Return the headers used in the handshake request (never {@code null})., +	 * @return a Map with the session attributes (never {@code null}), +	 * Return a {@link java.security.Principal} instance containing the name, +	 * of the authenticated user., +	 * Return the negotiated sub-protocol., +	 * @return the protocol identifier, or {@code null} if no protocol, +	 * was specified or negotiated successfully, +	 * Determine the negotiated extensions., +	 * @return the list of extensions, or an empty list if no extension, +	 * was specified or negotiated successfully, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/adapter/jetty/JettyWebSocketSession.java, +import java.util.Collections;, +import org.springframework.util.CollectionUtils;, +		this.headers = HttpHeaders.readOnlyHttpHeaders(this.headers);, +		List<ExtensionConfig> jettyExtensions = session.getUpgradeResponse().getExtensions();, +		if (!CollectionUtils.isEmpty(jettyExtensions)) {, +			this.extensions = new ArrayList<>(jettyExtensions.size());, +			for (ExtensionConfig jettyExtension : jettyExtensions) {, +				this.extensions.add(new WebSocketExtension(jettyExtension.getName(), jettyExtension.getParameters()));, +			this.extensions = Collections.unmodifiableList(this.extensions);, +			this.extensions = Collections.emptyList();, +		this.headers = HttpHeaders.readOnlyHttpHeaders(this.headers);, +		List<ExtensionConfig> extensions = (List<ExtensionConfig>) ReflectionUtils.invokeMethod(getExtensions, response);, +		if (!CollectionUtils.isEmpty(extensions)) {, +			this.extensions = new ArrayList<>(extensions.size());, +			for (ExtensionConfig extension : extensions) {, +				this.extensions.add(new WebSocketExtension(extension.getName(), extension.getParameters()));, +			this.extensions = Collections.unmodifiableList(this.extensions);, +			this.extensions = Collections.emptyList();, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2017 the original author or authors., +	 * Return the headers used in the handshake request (never {@code null})., +	 * @return a Map with the session attributes (never {@code null}), +	 * Return a {@link java.security.Principal} instance containing the name, +	 * of the authenticated user., +	 * Return the negotiated sub-protocol., +	 * @return the protocol identifier, or {@code null} if no protocol, +	 * was specified or negotiated successfully, +	 * Determine the negotiated extensions., +	 * @return the list of extensions, or an empty list if no extension, +	 * was specified or negotiated successfully, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/adapter/jetty/JettyWebSocketSession.java, +import java.util.Collections;, +import org.springframework.util.CollectionUtils;, +		this.headers = HttpHeaders.readOnlyHttpHeaders(this.headers);, +		List<ExtensionConfig> jettyExtensions = session.getUpgradeResponse().getExtensions();, +		if (!CollectionUtils.isEmpty(jettyExtensions)) {, +			this.extensions = new ArrayList<>(jettyExtensions.size());, +			for (ExtensionConfig jettyExtension : jettyExtensions) {, +				this.extensions.add(new WebSocketExtension(jettyExtension.getName(), jettyExtension.getParameters()));, +			this.extensions = Collections.unmodifiableList(this.extensions);, +			this.extensions = Collections.emptyList();, +		this.headers = HttpHeaders.readOnlyHttpHeaders(this.headers);, +		List<ExtensionConfig> extensions = (List<ExtensionConfig>) ReflectionUtils.invokeMethod(getExtensions, response);, +		if (!CollectionUtils.isEmpty(extensions)) {, +			this.extensions = new ArrayList<>(extensions.size());, +			for (ExtensionConfig extension : extensions) {, +				this.extensions.add(new WebSocketExtension(extension.getName(), extension.getParameters()));, +			this.extensions = Collections.unmodifiableList(this.extensions);, +			this.extensions = Collections.emptyList();, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/adapter/standard/StandardWebSocketSession.java, + * Copyright 2002-2017 the original author or authors., +import java.util.Collections;, +import org.springframework.util.CollectionUtils;, +	 * Constructor for a standard WebSocket session., +	 * Constructor that associates a user with the WebSocket session., +		List<Extension> standardExtensions = getNativeSession().getNegotiatedExtensions();, +		if (!CollectionUtils.isEmpty(standardExtensions)) {, +			this.extensions = new ArrayList<>(standardExtensions.size());, +			for (Extension standardExtension : standardExtensions) {, +				this.extensions.add(new StandardToWebSocketExtensionAdapter(standardExtension));, +			}, +			this.extensions = Collections.unmodifiableList(this.extensions);, +		}, +		else {, +			this.extensions = Collections.emptyList();, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2017 the original author or authors., +	 * Return the headers used in the handshake request (never {@code null})., +	 * @return a Map with the session attributes (never {@code null}), +	 * Return a {@link java.security.Principal} instance containing the name, +	 * of the authenticated user., +	 * Return the negotiated sub-protocol., +	 * @return the protocol identifier, or {@code null} if no protocol, +	 * was specified or negotiated successfully, +	 * Determine the negotiated extensions.]