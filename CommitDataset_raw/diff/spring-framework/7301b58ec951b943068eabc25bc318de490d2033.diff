[+++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/InvocableHandlerMethod.java, + * Copyright 2002-2014 the original author or authors., +			assertTargetBean(getBridgedMethod(), getBean(), args);, +			throw new IllegalArgumentException(getInvocationErrorMessage(e.getMessage(), args), e);, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual controller instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). {@code @Controller}'s that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	private void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String message = "The mapped controller method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual controller bean instance '" +, +					targetBeanClass.getName() + "'. If the controller requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalArgumentException(getInvocationErrorMessage(message, args));, +		}, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/InvocableHandlerMethod.java, + * Copyright 2002-2014 the original author or authors., +			assertTargetBean(getBridgedMethod(), getBean(), args);, +			throw new IllegalArgumentException(getInvocationErrorMessage(e.getMessage(), args), e);, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual controller instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). {@code @Controller}'s that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	private void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String message = "The mapped controller method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual controller bean instance '" +, +					targetBeanClass.getName() + "'. If the controller requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalArgumentException(getInvocationErrorMessage(message, args));, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java, + * Copyright 2002-2014 the original author or authors., +			assertTargetBean(getBridgedMethod(), getBean(), args);, +			throw new IllegalArgumentException(getInvocationErrorMessage(e.getMessage(), args), e);, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual controller instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). {@code @Controller}'s that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	private void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String message = "The mapped controller method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual controller bean instance '" +, +					targetBeanClass.getName() + "'. If the controller requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalArgumentException(getInvocationErrorMessage(message, args));, +		}, +	}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/InvocableHandlerMethod.java, + * Copyright 2002-2014 the original author or authors., +			assertTargetBean(getBridgedMethod(), getBean(), args);, +			throw new IllegalArgumentException(getInvocationErrorMessage(e.getMessage(), args), e);, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual controller instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype, +	 * beans, and others). {@code @Controller}'s that require proxying should prefer, +	 * class-based proxy mechanisms., +	 */, +	private void assertTargetBean(Method method, Object targetBean, Object[] args) {, +		Class<?> methodDeclaringClass = method.getDeclaringClass();, +		Class<?> targetBeanClass = targetBean.getClass();, +		if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {, +			String message = "The mapped controller method class '" + methodDeclaringClass.getName() +, +					"' is not an instance of the actual controller bean instance '" +, +					targetBeanClass.getName() + "'. If the controller requires proxying " +, +					"(e.g. due to @Transactional), please use class-based proxying.";, +			throw new IllegalArgumentException(getInvocationErrorMessage(message, args));, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java, + * Copyright 2002-2014 the original author or authors., +			assertTargetBean(getBridgedMethod(), getBean(), args);, +			throw new IllegalArgumentException(getInvocationErrorMessage(e.getMessage(), args), e);, +	/**, +	 * Assert that the target bean class is an instance of the class where the given, +	 * method is declared. In some cases the actual controller instance at request-, +	 * processing time may be a JDK dynamic proxy (lazy initialization, prototype]