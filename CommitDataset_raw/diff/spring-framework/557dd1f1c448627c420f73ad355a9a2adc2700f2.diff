[+++ b/org.springframework.transaction/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java, +			DefaultTransactionStatus status = null;, +			try {, +				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);, +				status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);, +				return status;, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +			DefaultTransactionStatus status = null;, +				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);, +				status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);, +				return status;, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				DefaultTransactionStatus status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, null);, +				try {, +					doBegin(transaction, definition);, +				}, +				catch (RuntimeException beginEx) {, +					if (status != null && status.isNewSynchronization()) {, +						TransactionSynchronizationManager.clear();, +					}, +					throw beginEx;, +				}, +				catch (Error beginErr) {, +					if (status != null && status.isNewSynchronization()) {, +						TransactionSynchronizationManager.clear();, +					}, +					throw beginErr;, +				}, +				return status;, +		try {, +		catch (Error err) {, +			// Can only really be an OutOfMemoryError..., +			if (actualNewSynchronization) {, +				TransactionSynchronizationManager.clear();, +			}, +			throw err;, +		}, +	}, +				logger.debug("Resuming suspended transaction after completion of inner transaction");, +++ b/org.springframework.transaction/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java, +			DefaultTransactionStatus status = null;, +			try {, +				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);, +				status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);, +				return status;, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +			DefaultTransactionStatus status = null;, +				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);, +				status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);, +				return status;, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				if (status != null && status.isNewSynchronization()) {, +					TransactionSynchronizationManager.clear();, +				}, +				DefaultTransactionStatus status = newTransactionStatus(, +						definition, transaction, true, newSynchronization, debugEnabled, null);, +				try {, +					doBegin(transaction, definition);, +				}, +				catch (RuntimeException beginEx) {, +					if (status != null && status.isNewSynchronization()) {, +						TransactionSynchronizationManager.clear();, +					}, +					throw beginEx;, +				}, +				catch (Error beginErr) {, +					if (status != null && status.isNewSynchronization()) {, +						TransactionSynchronizationManager.clear();, +					}, +					throw beginErr;, +				}, +				return status;, +		try {, +		catch (Error err) {, +			// Can only really be an OutOfMemoryError..., +			if (actualNewSynchronization) {, +				TransactionSynchronizationManager.clear();, +			}]