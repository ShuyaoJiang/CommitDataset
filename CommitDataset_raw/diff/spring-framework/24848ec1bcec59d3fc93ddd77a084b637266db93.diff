[+++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpClient.java, +		this.codec = codec;, +	}, +	/**, +	 * A variant of {@link #ReactorNettyTcpClient(String, int, ReactorNettyCodec)}, +	 * that still manages the lifecycle of the {@link TcpClient} and underlying, +	 * resources, but allows for direct configuration of other properties of the, +	 * client through a {@code Function<TcpClient, TcpClient>}., +	 * @param clientConfigurer the configurer function, +	 * @param codec for encoding and decoding the input/output byte streams, +	 * @since 5.1.3, +	 * @see org.springframework.messaging.simp.stomp.StompReactorNettyCodec, +	 */, +	public ReactorNettyTcpClient(Function<TcpClient, TcpClient> clientConfigurer, ReactorNettyCodec<P> codec) {, +		Assert.notNull(codec, "ReactorNettyCodec is required");, +, +		this.channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);, +		this.loopResources = LoopResources.create("tcp-client-loop");, +		this.poolResources = ConnectionProvider.elastic("tcp-client-pool");, +, +		this.tcpClient = clientConfigurer.apply(TcpClient, +				.create(this.poolResources), +				.runOn(this.loopResources, false), +				.doOnConnected(conn -> this.channelGroup.add(conn.channel())));, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpClient.java, +		this.codec = codec;, +	}, +	/**, +	 * A variant of {@link #ReactorNettyTcpClient(String, int, ReactorNettyCodec)}, +	 * that still manages the lifecycle of the {@link TcpClient} and underlying, +	 * resources, but allows for direct configuration of other properties of the, +	 * client through a {@code Function<TcpClient, TcpClient>}., +	 * @param clientConfigurer the configurer function, +	 * @param codec for encoding and decoding the input/output byte streams, +	 * @since 5.1.3, +	 * @see org.springframework.messaging.simp.stomp.StompReactorNettyCodec, +	 */, +	public ReactorNettyTcpClient(Function<TcpClient, TcpClient> clientConfigurer, ReactorNettyCodec<P> codec) {, +		Assert.notNull(codec, "ReactorNettyCodec is required");, +, +		this.channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);, +		this.loopResources = LoopResources.create("tcp-client-loop");, +		this.poolResources = ConnectionProvider.elastic("tcp-client-pool");, +, +		this.tcpClient = clientConfigurer.apply(TcpClient, +				.create(this.poolResources), +				.runOn(this.loopResources, false), +				.doOnConnected(conn -> this.channelGroup.add(conn.channel())));, +++ b/src/docs/asciidoc/web/websocket.adoc, +By default, the STOMP broker relay always connects, and reconnects as needed if, +connectivity is lost, to the same host and port. If you wish to supply multiple addresses,, +fixed host and port. The following example shows how to do that:, +		return new ReactorNettyTcpClient<>(, +				client -> client.addressSupplier(() -> ... ),, +				new StompReactorNettyCodec());]