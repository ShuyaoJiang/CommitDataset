[+++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +			return new FluxExchangeResult<>(this, body, getTimeout());, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +			return new FluxExchangeResult<>(this, body, getTimeout());, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/EntityExchangeResult.java, +	 * Return the entity extracted from the response body., +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +			return new FluxExchangeResult<>(this, body, getTimeout());, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/EntityExchangeResult.java, +	 * Return the entity extracted from the response body., +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/ExchangeResult.java, +import java.time.Duration;, +import org.springframework.util.Assert;, + * Container for request and response details for exchanges performed through, + * {@link WebTestClient}., + * <p>Note that a decoded response body is not exposed at this level since the, + * body may not have been decoded and consumed yet. Sub-types, + * {@link EntityExchangeResult} and {@link FluxExchangeResult} provide access, + * to a decoded response entity and a decoded (but not consumed) response body, + * respectively., +			MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML,, +			MediaType.parseMediaType("text/*"), MediaType.APPLICATION_FORM_URLENCODED);, +	 * Return the raw request body content written as a {@code byte[]}., +	 * @throws IllegalStateException if the request body is not fully written yet., +	public byte[] getRequestBodyContent() {, +		MonoProcessor<byte[]> body = this.request.getRecordedContent();, +		Assert.isTrue(body.isTerminated(), "Request body incomplete.");, +		return body.block(Duration.ZERO);, +, +	 * Return the raw request body content written as a {@code byte[]}., +	 * @throws IllegalStateException if the response is not fully read yet., +	public byte[] getResponseBodyContent() {, +		MonoProcessor<byte[]> body = this.response.getRecordedContent();, +		Assert.state(body.isTerminated(), "Response body incomplete.");, +		return body.block(Duration.ZERO);, +				formatBody(getRequestHeaders().getContentType(), this.request.getRecordedContent()) + "\n" +, +				formatBody(getResponseHeaders().getContentType(), this.response.getRecordedContent()) + "\n\n";, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/DefaultWebTestClient.java, +			return new FluxExchangeResult<>(this, body, getTimeout());, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/EntityExchangeResult.java, +	 * Return the entity extracted from the response body., +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/ExchangeResult.java, +import java.time.Duration;, +import org.springframework.util.Assert;, + * Container for request and response details for exchanges performed through, + * {@link WebTestClient}., + * <p>Note that a decoded response body is not exposed at this level since the, + * body may not have been decoded and consumed yet. Sub-types, + * {@link EntityExchangeResult} and {@link FluxExchangeResult} provide access, + * to a decoded response entity and a decoded (but not consumed) response body, + * respectively., +			MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML,, +			MediaType.parseMediaType("text/*"), MediaType.APPLICATION_FORM_URLENCODED);, +	 * Return the raw request body content written as a {@code byte[]}., +	 * @throws IllegalStateException if the request body is not fully written yet., +	public byte[] getRequestBodyContent() {, +		MonoProcessor<byte[]> body = this.request.getRecordedContent();, +		Assert.isTrue(body.isTerminated(), "Request body incomplete.");, +		return body.block(Duration.ZERO);, +, +	 * Return the raw request body content written as a {@code byte[]}., +	 * @throws IllegalStateException if the response is not fully read yet., +	public byte[] getResponseBodyContent() {, +		MonoProcessor<byte[]> body = this.response.getRecordedContent();, +		Assert.state(body.isTerminated(), "Response body incomplete.");, +		return body.block(Duration.ZERO);, +				formatBody(getRequestHeaders().getContentType(), this.request.getRecordedContent()) + "\n" +, +				formatBody(getResponseHeaders().getContentType(), this.response.getRecordedContent()) + "\n\n";, +++ b/spring-test/src/main/java/org/springframework/test/web/reactive/server/FluxExchangeResult.java, +import java.time.Duration;, +, +import reactor.core.publisher.Mono;, + * {@code ExchangeResult} variant with the response body decoded as, + * {@code Flux<T>} but not yet consumed., +	private static final IllegalStateException TIMEOUT_ERROR =, +			new IllegalStateException("Response timeout: for infinite streams " +, +					"use getResponseBody() first with explicit cancellation, e.g. via take(n).");, +, +, +	private final Duration timeout;, +, +	FluxExchangeResult(ExchangeResult result, Flux<T> body, Duration timeout) {, +		this.timeout = timeout;, +	 * Return the response body as a {@code Flux<T>} of decoded elements., +	 *, +	 * <p>The response body stream can then be consumed further with the, +	 * "reactor-test" {@code StepVerifier} and cancelled when enough elements have been, +	 * consumed from the (possibly infinite) stream:, +	 *, +	 * <pre>, +	 * FluxExchangeResult<Person> result = this.client.get(), +	 * 	.uri("/persons"), +	 * 	.accept(TEXT_EVENT_STREAM), +	 * 	.exchange(), +	 * 	.expectStatus().isOk(), +	 * 	.expectHeader().contentType(TEXT_EVENT_STREAM), +	 * 	.expectBody(Person.class), +	 * 	.returnResult();, +	 *, +	 * StepVerifier.create(result.getResponseBody())]