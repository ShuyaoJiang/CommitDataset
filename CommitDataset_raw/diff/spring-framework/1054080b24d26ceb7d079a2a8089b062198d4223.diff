[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, + * Copyright 2002-2014 the original author or authors., +import java.util.*;, + * @author Sebastien Deleuze, +		this.destinationCache.mapToDestination(destination, sessionId, subsId);, +	protected void removeSubscriptionInternal(String sessionId, String subsId, Message<?> message) {, +			String destination = info.removeSubscription(subsId);, +				this.destinationCache.unmapFromDestination(destination, sessionId, subsId);, +		MultiValueMap<String,String> result;, +		if (this.destinationCache.isCachedDestination(destination)) {, +			result = this.destinationCache.getSubscriptions(destination);, +		}, +		else {, +			if(!result.isEmpty()) {, +				this.destinationCache.addSubscriptions(destination, result);, +			}, +	 * Provide direct lookup of session subscriptions by destination, +		private AntPathMatcher pathMatcher = new AntPathMatcher();, +, +		private final Map<String, MultiValueMap<String, String>> subscriptionsByDestination =, +				new ConcurrentHashMap<String, MultiValueMap<String, String>>();, +		public void addSubscriptions(String destination, MultiValueMap<String, String> subscriptions) {, +			this.subscriptionsByDestination.put(destination, subscriptions);, +, +		public void mapToDestination(String destination, String sessionId, String subsId) {, +			synchronized(this.monitor) {, +				for (String cachedDestination : this.subscriptionsByDestination.keySet()) {, +					if (this.pathMatcher.match(destination, cachedDestination)) {, +						MultiValueMap<String, String> registrations = this.subscriptionsByDestination.get(cachedDestination);, +						if (registrations == null) {, +							registrations = new LinkedMultiValueMap<String, String>();, +						}, +						registrations.add(sessionId, subsId);, +					}, +				}, +		public void unmapFromDestination(String destination, String sessionId, String subsId) {, +				for (String cachedDestination : this.subscriptionsByDestination.keySet()) {, +					if (this.pathMatcher.match(destination, cachedDestination)) {, +						MultiValueMap<String, String> registrations = this.subscriptionsByDestination.get(cachedDestination);, +						List<String> subscriptions = registrations.get(sessionId);, +						while(subscriptions.remove(subsId));, +						if (subscriptions.isEmpty()) {, +							registrations.remove(sessionId);, +						}, +						if (registrations.isEmpty()) {, +							this.subscriptionsByDestination.remove(cachedDestination);, +						}, +			synchronized(this.monitor) {, +					for (String cachedDestination : this.subscriptionsByDestination.keySet()) {, +						if (this.pathMatcher.match(destination, cachedDestination)) {, +							MultiValueMap<String, String> map = this.subscriptionsByDestination.get(cachedDestination);, +							map.remove(info.getSessionId());, +							if (map.isEmpty()) {, +								this.subscriptionsByDestination.remove(cachedDestination);, +							}, +						}, +					}, +				}, +			return this.subscriptionsByDestination.get(destination);, +, +		public boolean isCachedDestination(String destination) {, +			return subscriptionsByDestination.containsKey(destination);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, + * Copyright 2002-2014 the original author or authors., +import java.util.*;, + * @author Sebastien Deleuze, +		this.destinationCache.mapToDestination(destination, sessionId, subsId);, +	protected void removeSubscriptionInternal(String sessionId, String subsId, Message<?> message) {, +			String destination = info.removeSubscription(subsId);, +				this.destinationCache.unmapFromDestination(destination, sessionId, subsId);, +		MultiValueMap<String,String> result;, +		if (this.destinationCache.isCachedDestination(destination)) {, +			result = this.destinationCache.getSubscriptions(destination);, +		}, +		else {, +			if(!result.isEmpty()) {, +				this.destinationCache.addSubscriptions(destination, result);, +			}, +	 * Provide direct lookup of session subscriptions by destination, +		private AntPathMatcher pathMatcher = new AntPathMatcher();, +, +		private final Map<String, MultiValueMap<String, String>> subscriptionsByDestination =, +				new ConcurrentHashMap<String, MultiValueMap<String, String>>();, +		public void addSubscriptions(String destination, MultiValueMap<String, String> subscriptions) {, +			this.subscriptionsByDestination.put(destination, subscriptions);, +, +		public void mapToDestination(String destination, String sessionId, String subsId) {, +			synchronized(this.monitor) {, +				for (String cachedDestination : this.subscriptionsByDestination.keySet()) {, +					if (this.pathMatcher.match(destination, cachedDestination)) {, +						MultiValueMap<String, String> registrations = this.subscriptionsByDestination.get(cachedDestination);, +						if (registrations == null) {, +							registrations = new LinkedMultiValueMap<String, String>();, +						}, +						registrations.add(sessionId, subsId);, +					}, +				}, +		public void unmapFromDestination(String destination, String sessionId, String subsId) {, +				for (String cachedDestination : this.subscriptionsByDestination.keySet()) {, +					if (this.pathMatcher.match(destination, cachedDestination)) {]