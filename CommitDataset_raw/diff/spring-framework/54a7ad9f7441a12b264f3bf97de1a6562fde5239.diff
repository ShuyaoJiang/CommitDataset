[+++ b/spring-framework-reference/src/beans-extension-points.xml, +  <title>Container Extension Points</title>, +  <para>Typically, an application developer does not need to subclass, +    Instead, the Spring IoC container can be extended by plugging in, +    <title>Customizing beans using a, +      <interfacename>BeanPostProcessor</interfacename></title>, +      configuring, and initializing a bean, you can plug in one or, +      instances, and you can control the order in which these, +      <literal>BeanPostProcessor</literal>s execute by setting the, +      further details, consult the Javadoc for the, +        <literal>BeanPostProcessor</literal>s do their work.</para>, +      <para><literal>BeanPostProcessor</literal>s are scoped, +        will <emphasis>only</emphasis> post-process the beans in that, +        container. In other words, beans that are defined in one container are not, +        post-processed by a <literal>BeanPostProcessor</literal> defined in another, +        container, even if both containers are part of the same hierarchy.</para>, +      <para>To change the actual bean definition (i.e., the, +        <emphasis>blueprint</emphasis> that defines the bean), you instead need to use a, +        <interfacename>BeanFactoryPostProcessor</interfacename> as described, +      methods (such as InitializingBean's <emphasis>afterPropertiesSet()</emphasis>, +      and any declared init method) are called as well as <emphasis>after</emphasis>, +      any bean initialization callbacks. The post-processor can take, +      interfaces or may wrap a bean with a proxy. Some Spring AOP, +      infrastructure classes are implemented as bean post-processors in order, +      to provide proxy-wrapping logic.</para>, +      the configuration metadata which implement the, +      post-processors so that they can be called later upon bean creation., +      Bean post-processors can be deployed in the container just like any other, +      beans.</para>, +        <emphasis>special</emphasis> and are treated differently by the, +        <emphasis>and beans that they reference directly</emphasis> are, +        <interfacename>ApplicationContext</interfacename>. Next, all, +        sorted fashion and applied to all further beans in the container., +        Because AOP auto-proxying is implemented as a, +        <interfacename>BeanPostProcessor</interfacename> itself, neither, +        <interfacename>BeanPostProcessors</interfacename> nor the beans they reference, +        directly are eligible for auto-proxying, and thus do not have aspects woven, +      <para>For any such bean, you should see an informational log message:, +        <quote><emphasis>Bean foo is not eligible for getting processed by all, +        auto-proxying)</emphasis></quote>.</para>, +      <literal>BeanPostProcessors</literal> in an, +      <para>The following simple Java application executes the preceding code and, +      <para>The output of the preceding application resembles the, +        Spring's <classname>RequiredAnnotationBeanPostProcessor</classname> &mdash; a, +    <title>Customizing configuration metadata with a, +      <interfacename>BeanFactoryPostProcessor</interfacename></title>, +      The semantics of this interface are similar to those of the, +      <literal>BeanFactoryPostProcessors</literal>, and you can control the order in, +      <interfacename>BeanFactoryPostProcessor</interfacename>, you should, +      too. Consult the Javadoc for the, +        (i.e., the objects that are created from the configuration metadata), then you, +        (described above in <xref linkend="beans-factory-extension-bpp"/>). While, +        <interfacename>BeanFactoryPostProcessor</interfacename> (e.g., using, +        premature bean instantiation, violating the standard container lifecycle., +        container, it will <emphasis>only</emphasis> be applied to the bean, +        definitions in that container. Bean definitions in one container, +      declared inside an <interfacename>ApplicationContext</interfacename>,, +      in order to apply changes to the configuration metadata that define the, +      container. Spring includes a number of predefined bean factory, +      and <classname>PropertyPlaceholderConfigurer</classname>. A custom, +    <para>An <interfacename>ApplicationContext</interfacename> automatically, +      detects any beans that are deployed into it that implement the, +      uses these beans as bean factory post-processors, at the, +      appropriate time. You can deploy these post-processor beans as you, +      <para>As with <interfacename>BeanPostProcessor</interfacename>s, you typically, +        do not want to configure <interfacename>BeanFactoryPostProcessor</interfacename>s, +        for lazy initialization. If no other bean references a, +        <interfacename>Bean(Factory)PostProcessor</interfacename>,, +        that post-processor will not get instantiated at all. Thus, marking it for, +        lazy initialization will be ignored, and the , +        <interfacename>Bean(Factory)PostProcessor</interfacename> will be, +        instantiated eagerly even if you set the <literal>default-lazy-init</literal>, +        attribute to <literal>true</literal> on the declaration of your, +        <code>&lt;beans /&gt;</code> element.</para>, +        externalize property values from a bean definition in a separate, +        file using the standard Java <classname>Properties</classname> format., +        to replace are specified as <emphasis>placeholders</emphasis> of the form, +        ${property-name} which follows the Ant / log4j / JSP EL style.</para>, +      <programlisting>jdbc.driverClassName=org.hsqldb.jdbcDriver, +      <para>Therefore, the string <literal>${jdbc.username}</literal> is replaced, +        at runtime with the value 'sa', and the same applies for other placeholder, +        values that match keys in the properties file. The, +        <classname>PropertyPlaceholderConfigurer</classname> checks for, +        placeholders in most properties and attributes of a bean definition., +        Furthermore, the placeholder prefix and suffix can be customized.</para>, +        configuration element. One or more locations can be provided as a, +      <para>The <classname>PropertyPlaceholderConfigurer</classname> not only, +        looks for properties in the <classname>Properties</classname> file, +        you specify. By default it also checks against the Java, +        in the specified properties files. You can customize this behavior by setting the, +        <literal>systemPropertiesMode</literal> property of the configurer with, +        one of the following three supported integer values:, +        </para>, +, +        <itemizedlist>, +        	<listitem>, +	        	<para><emphasis>never</emphasis> (0): Never check system properties</para>, +        	</listitem>, +        	<listitem>, +	        	<para><emphasis>fallback</emphasis> (1): Check system properties if not resolvable in the specified properties files. This is the default.</para>]