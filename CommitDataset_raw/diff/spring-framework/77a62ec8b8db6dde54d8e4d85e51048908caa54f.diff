[+++ b/spring-beans/src/main/java/org/springframework/beans/BeanInstantiationException.java, + * Copyright 2002-2014 the original author or authors., +, +		return this.beanClass;, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanInstantiationException.java, + * Copyright 2002-2014 the original author or authors., +, +		return this.beanClass;, +++ b/spring-context/src/main/java/org/springframework/jmx/export/MBeanExporter.java, +	 * Kick off bean registration automatically after the regular singleton instantiation phase., +++ b/spring-beans/src/main/java/org/springframework/beans/BeanInstantiationException.java, + * Copyright 2002-2014 the original author or authors., +, +		return this.beanClass;, +++ b/spring-context/src/main/java/org/springframework/jmx/export/MBeanExporter.java, +	 * Kick off bean registration automatically after the regular singleton instantiation phase., +++ b/spring-test/src/main/java/org/springframework/test/util/MetaAnnotationUtils.java, + * annotation attributes (e.g., + * {@link org.springframework.test.context.ContextConfiguration#inheritLocations})., +	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(, +			Class<?> clazz, Class<T> annotationType) {, +, +	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(, +			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {, +, +	private static void assertNonEmptyAnnotationTypeArray(Class<?>[] annotationTypes, String message) {, +		if (ObjectUtils.isEmpty(annotationTypes)) {, +			throw new IllegalArgumentException(message);, +		}, +		for (Class<?> clazz : annotationTypes) {, +			if (!Annotation.class.isAssignableFrom(clazz)) {, +				throw new IllegalArgumentException("Array elements must be of type Annotation");, +			}, +		}, +	}, +, +	 * <p>If the annotation is used as a meta-annotation, the descriptor also includes, +	 * <p>Given the following example, if we are searching for the {@code @Transactional}, +	 * <p>Given the following example, if we are searching for the {@code @Transactional}, +		private final Class<?> declaringClass;, +, +		private final Annotation composedAnnotation;, +, +		private final T annotation;, +, +		private final AnnotationAttributes annotationAttributes;, +			this.annotationAttributes = AnnotatedElementUtils.getAnnotationAttributes(, +					rootDeclaringClass, annotation.annotationType().getName());, +			return (this.composedAnnotation != null ? this.composedAnnotation.annotationType() : null);, +			return new ToStringCreator(this), +					.append("rootDeclaringClass", this.rootDeclaringClass), +					.append("declaringClass", this.declaringClass), +					.append("composedAnnotation", this.composedAnnotation), +					.append("annotation", this.annotation), +, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanInstantiationException.java, + * Copyright 2002-2014 the original author or authors., +, +		return this.beanClass;, +++ b/spring-context/src/main/java/org/springframework/jmx/export/MBeanExporter.java, +	 * Kick off bean registration automatically after the regular singleton instantiation phase., +++ b/spring-test/src/main/java/org/springframework/test/util/MetaAnnotationUtils.java, + * annotation attributes (e.g., + * {@link org.springframework.test.context.ContextConfiguration#inheritLocations})., +	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(, +			Class<?> clazz, Class<T> annotationType) {, +, +	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(, +			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {, +, +	private static void assertNonEmptyAnnotationTypeArray(Class<?>[] annotationTypes, String message) {, +		if (ObjectUtils.isEmpty(annotationTypes)) {, +			throw new IllegalArgumentException(message);, +		}, +		for (Class<?> clazz : annotationTypes) {, +			if (!Annotation.class.isAssignableFrom(clazz)) {, +				throw new IllegalArgumentException("Array elements must be of type Annotation");, +			}, +		}, +	}, +, +	 * <p>If the annotation is used as a meta-annotation, the descriptor also includes, +	 * <p>Given the following example, if we are searching for the {@code @Transactional}, +	 * <p>Given the following example, if we are searching for the {@code @Transactional}, +		private final Class<?> declaringClass;, +, +		private final Annotation composedAnnotation;, +, +		private final T annotation;, +, +		private final AnnotationAttributes annotationAttributes;, +			this.annotationAttributes = AnnotatedElementUtils.getAnnotationAttributes(, +					rootDeclaringClass, annotation.annotationType().getName());, +			return (this.composedAnnotation != null ? this.composedAnnotation.annotationType() : null);, +			return new ToStringCreator(this), +					.append("rootDeclaringClass", this.rootDeclaringClass), +					.append("declaringClass", this.declaringClass), +					.append("composedAnnotation", this.composedAnnotation), +					.append("annotation", this.annotation), +]