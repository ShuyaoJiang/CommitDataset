[+++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +, +	private Property property(PropertyDescriptor pd) {, +		GenericTypeAwarePropertyDescriptor typeAware = (GenericTypeAwarePropertyDescriptor) pd;, +		return new Property(typeAware.getBeanClass(), typeAware.getReadMethod(), typeAware.getWriteMethod());, +	}, +, +					Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +							requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				if (isExtractOldValueForEditor() && index < list.size()) {, +				Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				int size = list.size();, +				TypeDescriptor typeDescriptor = (mapKeyType != null ?, +						TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));, +				Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +, +	private Property property(PropertyDescriptor pd) {, +		GenericTypeAwarePropertyDescriptor typeAware = (GenericTypeAwarePropertyDescriptor) pd;, +		return new Property(typeAware.getBeanClass(), typeAware.getReadMethod(), typeAware.getWriteMethod());, +	}, +, +					Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +							requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				if (isExtractOldValueForEditor() && index < list.size()) {, +				Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				int size = list.size();, +				TypeDescriptor typeDescriptor = (mapKeyType != null ?, +						TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));, +				Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/GenericTypeAwarePropertyDescriptor.java, +		return this.beanClass;, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +, +	private Property property(PropertyDescriptor pd) {, +		GenericTypeAwarePropertyDescriptor typeAware = (GenericTypeAwarePropertyDescriptor) pd;, +		return new Property(typeAware.getBeanClass(), typeAware.getReadMethod(), typeAware.getWriteMethod());, +	}, +, +					Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +							requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				if (isExtractOldValueForEditor() && index < list.size()) {, +				Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +				int size = list.size();, +				TypeDescriptor typeDescriptor = (mapKeyType != null ?, +						TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));, +				Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),, +						mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));, +++ b/org.springframework.beans/src/main/java/org/springframework/beans/GenericTypeAwarePropertyDescriptor.java, +		return this.beanClass;, +++ b/org.springframework.context/src/test/java/org/springframework/validation/DataBinderTests.java, +import java.util.AbstractList;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.ListIterator;, +import org.springframework.core.convert.support.ConversionServiceFactory;, +	public void testNestedGrowingList() {, +		Form form = new Form();, +		DataBinder binder = new DataBinder(form, "form");, +		MutablePropertyValues mpv = new MutablePropertyValues();, +		mpv.add("f[list][0]", "firstValue");, +		mpv.add("f[list][1]", "secondValue");, +		binder.bind(mpv);, +		assertFalse(binder.getBindingResult().hasErrors());, +		List<Object> list = (List<Object>) form.getF().get("list");, +		assertEquals("firstValue", list.get(0));, +		assertEquals("secondValue", list.get(1));, +		assertEquals(2, list.size());, +	  }, +, +, +	private static class GrowingList<E> extends AbstractList<E> {, +, +		private List<E> list;, +, +		public GrowingList() {, +			this.list = new ArrayList<E>();, +		}, +, +		public List<E> getWrappedList() {, +			return list;, +		}, +, +		public E get(int index) {, +			if (index >= list.size()) {, +				for (int i = list.size(); i < index; i++) {, +					list.add(null);, +				}, +				list.add(null);, +				return null;, +			}, +			else {, +				return list.get(index);]