[+++ b/src/docs/asciidoc/core.adoc, +Foremost amongst these is the Spring Framework's Inversion of Control (IoC) container., +A thorough treatment of the Spring Framework's IoC container is closely followed by, +comprehensive coverage of Spring's Aspect-Oriented Programming (AOP) technologies., +The Spring Framework has its own AOP framework, which is conceptually easy to, +understand and which successfully addresses the 80% sweet spot of AOP requirements, +in Java enterprise programming., +features -- and certainly most mature AOP implementation in the Java enterprise space), +is also provided., +++ b/src/docs/asciidoc/core.adoc, +Foremost amongst these is the Spring Framework's Inversion of Control (IoC) container., +A thorough treatment of the Spring Framework's IoC container is closely followed by, +comprehensive coverage of Spring's Aspect-Oriented Programming (AOP) technologies., +The Spring Framework has its own AOP framework, which is conceptually easy to, +understand and which successfully addresses the 80% sweet spot of AOP requirements, +in Java enterprise programming., +features -- and certainly most mature AOP implementation in the Java enterprise space), +is also provided., +++ b/src/docs/asciidoc/core/core-appendix.adoc, +, +easy to do in Spring. You do not actually have to do anything or know anything about, +the Spring internals (or even about classes such as the `FieldRetrievingFactoryBean`)., +The following example enumeration shows how easy injecting an enum value is:, +This element activates the Spring infrastructure to detect annotations in bean classes:, +* Spring's <<core.adoc#beans-factory-metadata, `@Configuration`>> model, +* <<core.adoc#beans-annotation-config, `@Autowired`/`@Inject`>> and `@Value`, +* JSR-250's `@Resource`, `@PostConstruct` and `@PreDestroy` (if available), +* JPA's `@PersistenceContext` and `@PersistenceUnit` (if available), +* Spring's <<core.adoc#context-functionality-events-annotation, `@EventListener`>>, +Alternatively, you can choose to explicitly activate the individual `BeanPostProcessors`, +for those annotations., +<<data-access.adoc#transaction-declarative-annotations, `@Transactional`>> annotation;, +you can use the <<data-access.adoc#tx-decl-explained, `<tx:annotation-driven/>`>>, +element for that purpose. Similarly, Spring's, +<<integration.adoc#cache-annotations, caching annotations>> need to be explicitly, +<<integration.adoc#cache-annotation-enable, enabled>> as well., +This element is detailed in the section on <<core.adoc#beans-annotation-config,, +annotation-based container configuration>>., +This element is detailed in the section on <<core.adoc#aop-aj-ltw,, +load-time weaving with AspectJ in the Spring Framework>>., +This element is detailed in the section on <<core.adoc#aop-atconfigurable,, +using AspectJ to dependency inject domain objects with Spring>>., +This element is detailed in the section on <<integration.adoc#jmx-context-mbeanexport,, +configuring annotation-based MBean export>>., +in <<core.adoc#beans-factory-properties-detailed, dependencies and configuration in detail>>, +In the case of the preceding example, you could assume that there is some logic that consumes, +the bean definition and sets up some caching infrastructure that uses the supplied metadata., +, +, +This works nicely, but it exposes a lot of Spring plumbing to the end user. What we are, +going to do is write a custom extension that hides away all of this Spring plumbing., +If we stick to <<xsd-custom-introduction, the steps described previously>>, we start off, +by creating the XSD schema to define the structure of our custom tag, as the following, +listing shows:, +Again following <<xsd-custom-introduction, the process described earlier>>,, +we then create a custom `NamespaceHandler`:, +a `BeanDefinition` that describes a `ComponentFactoryBean`. The following, +listing shows our custom `BeanDefinitionParser` implementation:, +Writing your own custom parser and the associated artifacts is not hard. However,, +it is sometimes not the right thing to do. Consider a scenario where you need to, +add metadata to already existing bean definitions. In this case, you certainly, +do not want to have to write your own entire custom extension. Rather, you merely, +want to add an additional attribute to the existing bean definition element., +By way of another example, suppose that you define a bean definition for a, +service object that (unknown to it) accesses a clustered, +http://jcp.org/en/jsr/detail?id=107[JCache], and you want to ensure that the, +named JCache instance is eagerly started within the surrounding cluster., +The following listing shows such a definition:, +Now we can move onto the custom extension. First, we need to author, +the XSD schema that describes the custom attribute, as follows:, +Next, we need to create the parser. Note that, in this case, because we are going to parse, +an XML attribute, we write a `BeanDefinitionDecorator` rather than a `BeanDefinitionParser`., +The following listing shows our `BeanDefinitionDecorator` implementation:, +++ b/src/docs/asciidoc/core.adoc, +Foremost amongst these is the Spring Framework's Inversion of Control (IoC) container., +A thorough treatment of the Spring Framework's IoC container is closely followed by, +comprehensive coverage of Spring's Aspect-Oriented Programming (AOP) technologies., +The Spring Framework has its own AOP framework, which is conceptually easy to, +understand and which successfully addresses the 80% sweet spot of AOP requirements, +in Java enterprise programming., +features -- and certainly most mature AOP implementation in the Java enterprise space), +is also provided., +++ b/src/docs/asciidoc/core/core-appendix.adoc, +, +easy to do in Spring. You do not actually have to do anything or know anything about, +the Spring internals (or even about classes such as the `FieldRetrievingFactoryBean`)., +The following example enumeration shows how easy injecting an enum value is:, +This element activates the Spring infrastructure to detect annotations in bean classes:, +* Spring's <<core.adoc#beans-factory-metadata, `@Configuration`>> model, +* <<core.adoc#beans-annotation-config, `@Autowired`/`@Inject`>> and `@Value`, +* JSR-250's `@Resource`, `@PostConstruct` and `@PreDestroy` (if available), +* JPA's `@PersistenceContext` and `@PersistenceUnit` (if available), +* Spring's <<core.adoc#context-functionality-events-annotation, `@EventListener`>>, +Alternatively, you can choose to explicitly activate the individual `BeanPostProcessors`, +for those annotations., +<<data-access.adoc#transaction-declarative-annotations, `@Transactional`>> annotation;, +you can use the <<data-access.adoc#tx-decl-explained, `<tx:annotation-driven/>`>>, +element for that purpose. Similarly, Spring's, +<<integration.adoc#cache-annotations, caching annotations>> need to be explicitly, +<<integration.adoc#cache-annotation-enable, enabled>> as well.]