[+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.util.ArrayList;, +		if (cachePutRequests.isEmpty() && !hasCachePut(contexts)) {, +	private boolean hasCachePut(CacheOperationContexts contexts) {, +		// Evaluate the conditions *without* the result object because we don't have it yet., +		Collection<CacheOperationContext> cachePutContexts = contexts.get(CachePutOperation.class);, +		Collection<CacheOperationContext> excluded = new ArrayList<CacheOperationContext>();, +		for (CacheOperationContext context : cachePutContexts) {, +			try {, +				if (!context.isConditionPassing(ExpressionEvaluator.RESULT_UNAVAILABLE)) {, +	                excluded.add(context);, +				}, +			}, +			catch (VariableNotAvailableException e) {, +				// Ignoring failure due to missing result, consider the cache put has, +				// to proceed, +			}, +		}, +		// check if  all puts have been excluded by condition, +		return cachePutContexts.size() != excluded.size();, +, +, +	}, +, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java, +import java.util.ArrayList;, +		if (cachePutRequests.isEmpty() && !hasCachePut(contexts)) {, +	private boolean hasCachePut(CacheOperationContexts contexts) {, +		// Evaluate the conditions *without* the result object because we don't have it yet., +		Collection<CacheOperationContext> cachePutContexts = contexts.get(CachePutOperation.class);, +		Collection<CacheOperationContext> excluded = new ArrayList<CacheOperationContext>();, +		for (CacheOperationContext context : cachePutContexts) {, +			try {, +				if (!context.isConditionPassing(ExpressionEvaluator.RESULT_UNAVAILABLE)) {, +	                excluded.add(context);, +				}, +			}, +			catch (VariableNotAvailableException e) {, +				// Ignoring failure due to missing result, consider the cache put has, +				// to proceed, +			}, +		}, +		// check if  all puts have been excluded by condition, +		return cachePutContexts.size() != excluded.size();, +, +, +	}, +, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheEvaluationContext.java, +/*, + * Copyright 2002-2014 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.cache.interceptor;, +, +import java.lang.reflect.Method;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.Map;, +, +import org.springframework.aop.support.AopUtils;, +import org.springframework.core.ParameterNameDiscoverer;, +import org.springframework.expression.spel.support.StandardEvaluationContext;, +import org.springframework.util.ObjectUtils;, +, +/**, + * Cache specific evaluation context that adds a method parameters as SpEL, + * variables, in a lazy manner. The lazy nature eliminates unneeded, + * parsing of classes byte code for parameter discovery., + *, + * <p>Also define a set of "unavailable variables" (i.e. variables that should, + * lead to an exception right the way when they are accessed). This can be useful, + * to verify a condition does not match even when not all potential variables, + * are present., + *, + * <p>To limit the creation of objects, an ugly constructor is used, + * (rather then a dedicated 'closure'-like class for deferred execution)., + *, + * @author Costin Leau, + * @author Stephane Nicoll, + * @since 3.1, + */, +class CacheEvaluationContext extends StandardEvaluationContext {, +, +	private final ParameterNameDiscoverer paramDiscoverer;, +, +	private final Method method;, +]