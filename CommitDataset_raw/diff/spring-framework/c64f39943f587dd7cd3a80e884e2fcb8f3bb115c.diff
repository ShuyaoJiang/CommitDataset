[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlMapFactoryBean.java, +	 * returned by this factory., +	 * <p>The default implementation returns the merged {@code Map} instance., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlMapFactoryBean.java, +	 * returned by this factory., +	 * <p>The default implementation returns the merged {@code Map} instance., +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/BufferingStompDecoder.java, + * @see StompDecoder, +	private final Queue<ByteBuffer> chunks = new LinkedBlockingQueue<ByteBuffer>();, +	/**, +	 * Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}., +	 * @param stompDecoder the target decoder to wrap, +	 * @param bufferSizeLimit the buffer size limit, +	 */, +		Assert.notNull(stompDecoder, "StompDecoder is required");, +		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0");, +	 * Return the wrapped {@link StompDecoder}., +	public final StompDecoder getStompDecoder() {, +	public final int getBufferSizeLimit() {, +, +	/**, +	 * Decodes one or more STOMP frames from the given {@code ByteBuffer} into a, +	 * list of {@link Message}s., +	 * <p>If there was enough data to parse a "content-length" header, then the, +	 * value is used to determine how much more data is needed before a new, +	 * attempt to decode is made., +	 * <p>If there was not enough data to parse the "content-length", or if there, +	 * is "content-length" header, every subsequent call to decode attempts to, +	 * parse again with all available data. Therefore the presence of a "content-length", +	 * header helps to optimize the decoding of large messages., +	 * @param newBuffer a buffer containing new data to decode, +	 * @return decoded messages or an empty list, +	 * @throws StompConversionException raised in case of decoding issues, +	 */, +	public List<Message<byte[]>> decode(ByteBuffer newBuffer) {, +		this.chunks.add(newBuffer);, +		checkBufferLimits();, +, +		if (this.expectedContentLength != null && getBufferSize() < this.expectedContentLength) {, +			return Collections.emptyList();, +		}, +, +		ByteBuffer bufferToDecode = assembleChunksAndReset();, +		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>();, +		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers);, +, +		if (bufferToDecode.hasRemaining()) {, +			this.chunks.add(bufferToDecode);, +			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers);, +		}, +, +		return messages;, +	}, +, +	private ByteBuffer assembleChunksAndReset() {, +		ByteBuffer result;, +		if (this.chunks.size() == 1) {, +			result = this.chunks.remove();, +		}, +		else {, +			result = ByteBuffer.allocate(getBufferSize());, +			for (ByteBuffer partial : this.chunks) {, +				result.put(partial);, +			}, +			result.flip();, +		}, +		this.chunks.clear();, +		this.expectedContentLength = null;, +		return result;, +	}, +, +	private void checkBufferLimits() {, +		if (this.expectedContentLength != null) {, +			if (this.expectedContentLength > this.bufferSizeLimit) {, +				throw new StompConversionException(, +						"STOMP 'content-length' header value " + this.expectedContentLength +, +						"  exceeds configured buffer size limit " + this.bufferSizeLimit);, +			}, +		}, +		if (getBufferSize() > this.bufferSizeLimit) {, +			throw new StompConversionException("The configured STOMP buffer size limit of " +, +					this.bufferSizeLimit + " bytes has been exceeded");, +		}, +	}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlMapFactoryBean.java, +	 * returned by this factory., +	 * <p>The default implementation returns the merged {@code Map} instance., +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/BufferingStompDecoder.java, + * @see StompDecoder, +	private final Queue<ByteBuffer> chunks = new LinkedBlockingQueue<ByteBuffer>();, +	/**, +	 * Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}., +	 * @param stompDecoder the target decoder to wrap, +	 * @param bufferSizeLimit the buffer size limit, +	 */, +		Assert.notNull(stompDecoder, "StompDecoder is required");, +		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0");, +	 * Return the wrapped {@link StompDecoder}., +	public final StompDecoder getStompDecoder() {]