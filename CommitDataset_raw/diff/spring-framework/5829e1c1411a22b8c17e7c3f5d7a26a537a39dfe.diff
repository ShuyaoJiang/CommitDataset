[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +	private final AtomicBoolean sendCalled = new AtomicBoolean();, +, +	 * Whether the underlying WebSocket API has flow control and can suspend and, +	 * resume the receiving of messages., +	protected abstract boolean canSuspendReceiving();, +	 * Resume receiving new message(s) after demand is generated by the, +	 * downstream Subscriber., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should be a no-op, +	 * and {@link #canSuspendReceiving()} should return {@code false}., +	protected abstract void resumeReceiving();, +, +	// WebSocketHandler adapter delegate methods, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +	private final AtomicBoolean sendCalled = new AtomicBoolean();, +, +	 * Whether the underlying WebSocket API has flow control and can suspend and, +	 * resume the receiving of messages., +	protected abstract boolean canSuspendReceiving();, +	 * Resume receiving new message(s) after demand is generated by the, +	 * downstream Subscriber., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should be a no-op, +	 * and {@link #canSuspendReceiving()} should return {@code false}., +	protected abstract void resumeReceiving();, +, +	// WebSocketHandler adapter delegate methods, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketHandlerAdapter.java, +	private final DataBufferFactory bufferFactory = new DefaultDataBufferFactory(false);, +, +	@OnWebSocketClose, +	public void onWebSocketClose(int statusCode, String reason) {, +		if (this.session != null) {, +			this.session.handleClose(new CloseStatus(statusCode, reason));, +		}, +	}, +, +	@OnWebSocketError, +	public void onWebSocketError(Throwable cause) {, +		if (this.session != null) {, +			this.session.handleError(cause);, +		}, +	}, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +	private final AtomicBoolean sendCalled = new AtomicBoolean();, +, +	 * Whether the underlying WebSocket API has flow control and can suspend and, +	 * resume the receiving of messages., +	protected abstract boolean canSuspendReceiving();, +	 * Resume receiving new message(s) after demand is generated by the, +	 * downstream Subscriber., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should be a no-op, +	 * and {@link #canSuspendReceiving()} should return {@code false}., +	protected abstract void resumeReceiving();, +, +	// WebSocketHandler adapter delegate methods, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketHandlerAdapter.java, +	private final DataBufferFactory bufferFactory = new DefaultDataBufferFactory(false);, +, +	@OnWebSocketClose, +	public void onWebSocketClose(int statusCode, String reason) {, +		if (this.session != null) {, +			this.session.handleClose(new CloseStatus(statusCode, reason));, +		}, +	}, +, +	@OnWebSocketError, +	public void onWebSocketError(Throwable cause) {, +		if (this.session != null) {, +			this.session.handleError(cause);, +		}, +	}, +, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketSession.java, +	protected boolean canSuspendReceiving() {, +		return false;, +	}, +, +	@Override, +	protected void suspendReceiving() {, +		// No-op, +	}, +, +	@Override, +	protected void resumeReceiving() {, +		// No-op, +	protected Mono<Void> closeInternal(CloseStatus status) {, +		getDelegate().close(status.getCode(), status.getReason());, +		return Mono.empty();, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +	private final AtomicBoolean sendCalled = new AtomicBoolean();, +, +	 * Whether the underlying WebSocket API has flow control and can suspend and, +	 * resume the receiving of messages.]