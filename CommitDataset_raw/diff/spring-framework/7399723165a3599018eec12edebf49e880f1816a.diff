[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/support/AbstractFlashMapManager.java, +import java.util.LinkedList;, + * @author Juergen Hoeller, +	private static final Object DEFAULT_FLASH_MAPS_MUTEX = new Object();, +, +		List<FlashMap> allFlashMaps = retrieveFlashMaps(request);, +		if (CollectionUtils.isEmpty(allFlashMaps)) {, +			logger.debug("Retrieved FlashMap(s): " + allFlashMaps);, +		List<FlashMap> mapsToRemove = getExpiredFlashMaps(allFlashMaps);, +		FlashMap match = getMatchingFlashMap(allFlashMaps, request);, +			Object mutex = getFlashMapsMutex(request);, +			if (mutex != null) {, +				synchronized (mutex) {, +					allFlashMaps = retrieveFlashMaps(request);, +					if (allFlashMaps != null) {, +						allFlashMaps.removeAll(mapsToRemove);, +						updateFlashMaps(allFlashMaps, request, response);, +					}, +				}, +			}, +			else {, +				allFlashMaps.removeAll(mapsToRemove);, +				updateFlashMaps(allFlashMaps, request, response);, +		List<FlashMap> result = new LinkedList<FlashMap>();, +		List<FlashMap> result = new LinkedList<FlashMap>();, +			String requestUri = getUrlPathHelper().getOriginatingRequestUri(request);, +		flashMap.startExpirationPeriod(getFlashMapTimeout());, +		Object mutex = getFlashMapsMutex(request);, +		if (mutex != null) {, +			synchronized (mutex) {, +				List<FlashMap> allFlashMaps = retrieveFlashMaps(request);, +				allFlashMaps = (allFlashMaps != null ? allFlashMaps : new CopyOnWriteArrayList<FlashMap>());, +				allFlashMaps.add(flashMap);, +				updateFlashMaps(allFlashMaps, request, response);, +			}, +		}, +		else {, +			List<FlashMap> allFlashMaps = retrieveFlashMaps(request);, +			allFlashMaps = (allFlashMaps != null ? allFlashMaps : new LinkedList<FlashMap>());, +			allFlashMaps.add(flashMap);, +			updateFlashMaps(allFlashMaps, request, response);, +			path = getUrlPathHelper().decodeRequestString(request, path);, +				String requestUri = getUrlPathHelper().getRequestUri(request);, +				name = getUrlPathHelper().decodeRequestString(request, name);, +				value = getUrlPathHelper().decodeRequestString(request, value);, +, +	 * Retrieve saved FlashMap instances from the underlying storage., +	 * @param request the current request, +	 * @return a List with FlashMap instances, or {@code null} if none found, +	 */, +	protected abstract List<FlashMap> retrieveFlashMaps(HttpServletRequest request);, +, +	/**, +	 * Update the FlashMap instances in the underlying storage., +	 * @param flashMaps a (potentially empty) list of FlashMap instances to save, +	/**, +	 * Obtain a mutex for modifying the FlashMap List as handled by, +	 * {@link #retrieveFlashMaps} and {@link #updateFlashMaps},, +	 * <p>The default implementation returns a shared static mutex., +	 * Subclasses are encouraged to return a more specific mutex, or, +	 * {@code null} to indicate that no synchronization is necessary., +	 * @param request the current request, +	 * @return the mutex to use (may be {@code null} if none applicable), +	 * @since 4.0.3, +	 */, +	protected Object getFlashMapsMutex(HttpServletRequest request) {, +		return DEFAULT_FLASH_MAPS_MUTEX;, +	}, +, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/support/AbstractFlashMapManager.java, +import java.util.LinkedList;, + * @author Juergen Hoeller, +	private static final Object DEFAULT_FLASH_MAPS_MUTEX = new Object();, +, +		List<FlashMap> allFlashMaps = retrieveFlashMaps(request);, +		if (CollectionUtils.isEmpty(allFlashMaps)) {, +			logger.debug("Retrieved FlashMap(s): " + allFlashMaps);, +		List<FlashMap> mapsToRemove = getExpiredFlashMaps(allFlashMaps);, +		FlashMap match = getMatchingFlashMap(allFlashMaps, request);, +			Object mutex = getFlashMapsMutex(request);, +			if (mutex != null) {, +				synchronized (mutex) {, +					allFlashMaps = retrieveFlashMaps(request);, +					if (allFlashMaps != null) {, +						allFlashMaps.removeAll(mapsToRemove);, +						updateFlashMaps(allFlashMaps, request, response);, +					}, +				}, +			}, +			else {, +				allFlashMaps.removeAll(mapsToRemove);, +				updateFlashMaps(allFlashMaps, request, response);, +		List<FlashMap> result = new LinkedList<FlashMap>();, +		List<FlashMap> result = new LinkedList<FlashMap>();, +			String requestUri = getUrlPathHelper().getOriginatingRequestUri(request);, +		flashMap.startExpirationPeriod(getFlashMapTimeout());, +		Object mutex = getFlashMapsMutex(request);, +		if (mutex != null) {, +			synchronized (mutex) {, +				List<FlashMap> allFlashMaps = retrieveFlashMaps(request);]