[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java, + * Simple PropertyAccessor that uses reflection to access properties for reading and writing., + * A property can be accessed if it is accessible as a field on the object or through a, + * getter (if being read) or a setter (if being written)., +	private final Map<CacheKey, InvokerPair> readerCache = new ConcurrentHashMap<CacheKey, InvokerPair>();, +	private final Map<CacheKey, Member> writerCache = new ConcurrentHashMap<CacheKey, Member>();, +	private final Map<CacheKey, TypeDescriptor> typeDescriptorCache = new ConcurrentHashMap<CacheKey, TypeDescriptor>();, +, +	 * Captures the member (method/field) to call reflectively to access a property value, +	 * and the type descriptor for the value returned by the reflective call., +	private static class InvokerPair {, +, +		final Member member;, +, +		final TypeDescriptor typeDescriptor;, +, +		public InvokerPair(Member member, TypeDescriptor typeDescriptor) {, +			this.member = member;, +			this.typeDescriptor = typeDescriptor;, +		}, +	}, +, +, +	private static class CacheKey {, +, +		private final Class clazz;, +, +		private final String name;, +, +		public CacheKey(Class clazz, String name) {, +			this.clazz = clazz;, +			this.name = name;, +		}, +, +		@Override, +		public boolean equals(Object other) {, +			if (this == other) {, +				return true;, +			}, +			if (!(other instanceof CacheKey)) {, +				return false;, +			}, +			CacheKey otherKey = (CacheKey) other;, +			return (this.clazz.equals(otherKey.clazz) && this.name.equals(otherKey.name));, +		}, +, +		@Override, +		public int hashCode() {, +			return this.clazz.hashCode() * 29 + this.name.hashCode();, +		}, +	}, +, +, +	/**, +	 * An optimized form of a PropertyAccessor that will use reflection but only knows, +	 * how to access a particular property on a particular class. This is unlike the, +	 * general ReflectivePropertyResolver which manages a cache of methods/fields that, +	 * may be invoked to access different properties on different classes. This optimal, +	 * accessor exists because looking up the appropriate reflective object by class/name, +	 * on each read is not cheap., +	 */, +	private static class OptimalPropertyAccessor implements PropertyAccessor {, +, +, +, +				Field field = (Field) this.member;, +				this.needsToBeMadeAccessible = (!Modifier.isPublic(field.getModifiers()) ||, +						!Modifier.isPublic(field.getDeclaringClass().getModifiers())) && !field.isAccessible();, +				Method method = (Method) this.member;, +				this.needsToBeMadeAccessible = ((!Modifier.isPublic(method.getModifiers()) ||, +						!Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible());, +			if (this.member instanceof Method) {, +				Method method = (Method) this.member;, +				Field field = (Field) this.member;, +			if (this.member instanceof Method) {, +					if (this.needsToBeMadeAccessible) {, +						ReflectionUtils.makeAccessible((Method) this.member);, +					Object value = ((Method) this.member).invoke(target);, +					return new TypedValue(value, this.typeDescriptor.narrow(value));, +			if (this.member instanceof Field) {, +					if (this.needsToBeMadeAccessible) {, +						ReflectionUtils.makeAccessible((Field) this.member);, +					Object value = ((Field) this.member).get(target);, +					return new TypedValue(value, this.typeDescriptor.narrow(value));, +		public boolean canWrite(EvaluationContext context, Object target, String name) {, +		public void write(EvaluationContext context, Object target, String name, Object newValue) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java, + * Simple PropertyAccessor that uses reflection to access properties for reading and writing., + * A property can be accessed if it is accessible as a field on the object or through a, + * getter (if being read) or a setter (if being written)., +	private final Map<CacheKey, InvokerPair> readerCache = new ConcurrentHashMap<CacheKey, InvokerPair>();, +	private final Map<CacheKey, Member> writerCache = new ConcurrentHashMap<CacheKey, Member>();, +	private final Map<CacheKey, TypeDescriptor> typeDescriptorCache = new ConcurrentHashMap<CacheKey, TypeDescriptor>();, +, +	 * Captures the member (method/field) to call reflectively to access a property value, +	 * and the type descriptor for the value returned by the reflective call., +	private static class InvokerPair {, +, +		final Member member;, +]