[+++ b/build.gradle, +	ext.undertowVersion      = "1.1.1.Final", +			exclude group: "org.jboss.spec.javax.websocket", module: "jboss-websocket-api_1.1_spec", +++ b/build.gradle, +	ext.undertowVersion      = "1.1.1.Final", +			exclude group: "org.jboss.spec.javax.websocket", module: "jboss-websocket-api_1.1_spec", +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +import java.lang.reflect.Modifier;, +import java.util.Collection;, +			List<Method> methods = new ArrayList<Method>((getMethods(type, targetObject)));, +	private Collection<Method> getMethods(Class<?> type, Object targetObject) {, +			Set<Method> result = new LinkedHashSet<Method>();, +			result.addAll(Arrays.asList(getMethods(targetObject.getClass())));, +			// Add these also so that static result are invocable on the type: e.g. Float.valueOf(..), +			Method[] methods = getMethods(type);, +			for (Method method : methods) {, +				if (Modifier.isStatic(method.getModifiers())) {, +					result.add(method);, +			}, +			return result;, +		}, +		else {, +			return Arrays.asList(getMethods(type));, +		}, +++ b/build.gradle, +	ext.undertowVersion      = "1.1.1.Final", +			exclude group: "org.jboss.spec.javax.websocket", module: "jboss-websocket-api_1.1_spec", +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +import java.lang.reflect.Modifier;, +import java.util.Collection;, +			List<Method> methods = new ArrayList<Method>((getMethods(type, targetObject)));, +	private Collection<Method> getMethods(Class<?> type, Object targetObject) {, +			Set<Method> result = new LinkedHashSet<Method>();, +			result.addAll(Arrays.asList(getMethods(targetObject.getClass())));, +			// Add these also so that static result are invocable on the type: e.g. Float.valueOf(..), +			Method[] methods = getMethods(type);, +			for (Method method : methods) {, +				if (Modifier.isStatic(method.getModifiers())) {, +					result.add(method);, +			}, +			return result;, +		}, +		else {, +			return Arrays.asList(getMethods(type));, +		}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java, +			return new Class<?>[] {ContextObject.class};, +							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})};, +	@Test, +	public void SPR12502() throws Exception {, +		SpelExpressionParser parser = new SpelExpressionParser();, +		Expression expression = parser.parseExpression("#root.getClass().getName()");, +		assertEquals(UnnamedUser.class.getName(), expression.getValue(new UnnamedUser()));, +		assertEquals(NamedUser.class.getName(), expression.getValue(new NamedUser()));, +	}, +, +, +	public static class UnnamedUser {, +	}, +, +, +	public static class NamedUser {, +, +		public String getName() {, +			return "foo";, +		}, +	}, +, +++ b/build.gradle, +	ext.undertowVersion      = "1.1.1.Final", +			exclude group: "org.jboss.spec.javax.websocket", module: "jboss-websocket-api_1.1_spec", +++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, +import java.lang.reflect.Modifier;, +import java.util.Collection;, +			List<Method> methods = new ArrayList<Method>((getMethods(type, targetObject)));, +	private Collection<Method> getMethods(Class<?> type, Object targetObject) {, +			Set<Method> result = new LinkedHashSet<Method>();, +			result.addAll(Arrays.asList(getMethods(targetObject.getClass())));, +			// Add these also so that static result are invocable on the type: e.g. Float.valueOf(..), +			Method[] methods = getMethods(type);, +			for (Method method : methods) {, +				if (Modifier.isStatic(method.getModifiers())) {, +					result.add(method);, +			}, +			return result;, +		}, +		else {, +			return Arrays.asList(getMethods(type));, +		}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java, +			return new Class<?>[] {ContextObject.class};, +							Integer.class.getDeclaredMethod("parseInt", new Class<?>[] {String.class, Integer.TYPE})};, +	@Test, +	public void SPR12502() throws Exception {, +		SpelExpressionParser parser = new SpelExpressionParser();, +		Expression expression = parser.parseExpression("#root.getClass().getName()");, +		assertEquals(UnnamedUser.class.getName(), expression.getValue(new UnnamedUser()));, +		assertEquals(NamedUser.class.getName(), expression.getValue(new NamedUser()));, +	}, +]