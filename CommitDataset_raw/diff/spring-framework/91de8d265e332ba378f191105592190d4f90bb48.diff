[+++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufDecoder.java, +		private int offset;, +, +						if (!readMessageSize(input)) {, +							return messages;, +, +		/**, +		 * Parse message size as a varint from the input stream, updating {@code messageBytesToRead} and, +		 * {@code offset} fields if needed to allow processing of upcoming chunks., +		 * Inspired from {@link CodedInputStream#readRawVarint32(int, java.io.InputStream)}, +		 *, +		 * @return {code true} when the message size is parsed successfully, {code false} when the message size is, +		 * truncated, +		 * @see <a href ="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a>, +		 */, +		private boolean readMessageSize(DataBuffer input) {, +			if (this.offset == 0) {, +				if (input.readableByteCount() == 0) {, +					return false;, +				}, +				int firstByte = input.read();, +				if ((firstByte & 0x80) == 0) {, +					this.messageBytesToRead = firstByte;, +					return true;, +				}, +				this.messageBytesToRead = firstByte & 0x7f;, +				this.offset = 7;, +			}, +, +			if (this.offset < 32) {, +				for (; this.offset < 32; this.offset += 7) {, +					if (input.readableByteCount() == 0) {, +						return false;, +					}, +					final int b = input.read();, +					this.messageBytesToRead |= (b & 0x7f) << offset;, +					if ((b & 0x80) == 0) {, +						this.offset = 0;, +						return true;, +					}, +				}, +			}, +			// Keep reading up to 64 bits., +			for (; this.offset < 64; this.offset += 7) {, +				if (input.readableByteCount() == 0) {, +					return false;, +				}, +				final int b = input.read();, +				if ((b & 0x80) == 0) {, +					this.offset = 0;, +					return true;, +				}, +			}, +			this.offset = 0;, +			throw new DecodingException("Cannot parse message size: malformed varint");, +		}, +++ b/spring-web/src/main/java/org/springframework/http/codec/protobuf/ProtobufDecoder.java, +		private int offset;, +, +						if (!readMessageSize(input)) {, +							return messages;, +, +		/**, +		 * Parse message size as a varint from the input stream, updating {@code messageBytesToRead} and, +		 * {@code offset} fields if needed to allow processing of upcoming chunks., +		 * Inspired from {@link CodedInputStream#readRawVarint32(int, java.io.InputStream)}, +		 *, +		 * @return {code true} when the message size is parsed successfully, {code false} when the message size is, +		 * truncated, +		 * @see <a href ="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a>, +		 */, +		private boolean readMessageSize(DataBuffer input) {, +			if (this.offset == 0) {, +				if (input.readableByteCount() == 0) {, +					return false;, +				}, +				int firstByte = input.read();, +				if ((firstByte & 0x80) == 0) {, +					this.messageBytesToRead = firstByte;, +					return true;, +				}, +				this.messageBytesToRead = firstByte & 0x7f;, +				this.offset = 7;, +			}, +, +			if (this.offset < 32) {, +				for (; this.offset < 32; this.offset += 7) {, +					if (input.readableByteCount() == 0) {, +						return false;, +					}, +					final int b = input.read();, +					this.messageBytesToRead |= (b & 0x7f) << offset;, +					if ((b & 0x80) == 0) {, +						this.offset = 0;, +						return true;, +					}, +				}, +			}, +			// Keep reading up to 64 bits., +			for (; this.offset < 64; this.offset += 7) {]