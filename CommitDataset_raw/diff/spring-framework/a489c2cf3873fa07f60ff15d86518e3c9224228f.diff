[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +	private TcpClient<Message<byte[]>, Message<byte[]>> tcpClient;, +		this.tcpClient = new TcpClientSpec<Message<byte[]>, Message<byte[]>>(NettyTcpClient.class), +				.codec(new StompCodec()), +			Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> promise = openTcpConnection();, +			promise.consume(new Consumer<TcpConnection<Message<byte[]>, Message<byte[]>>>() {, +				public void accept(TcpConnection<Message<byte[]>, Message<byte[]>> connection) {, +			promise.when(Throwable.class, new Consumer<Throwable>() {, +		protected Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> openTcpConnection() {, +		protected void handleTcpConnection(TcpConnection<Message<byte[]>, Message<byte[]>> tcpConn, final Message<?> connectMessage) {, +			tcpConn.in().consume(new Consumer<Message<byte[]>>() {, +				public void accept(Message<byte[]> message) {, +		private void readStompFrame(Message<byte[]> message) {, +			TcpConnection<Message<byte[]>, Message<byte[]>> tcpConnection = this.stompConnection.getReadyConnection();, +		@SuppressWarnings("unchecked"), +		private boolean forwardInternal(TcpConnection<Message<byte[]>, Message<byte[]>> tcpConnection, final Message<?> message) {, +, +			Assert.isInstanceOf(byte[].class, message.getPayload(), "Message's payload must be a byte[]");, +			tcpConnection.send((Message<byte[]>)message, new Consumer<Boolean>() {, +		private volatile TcpConnection<Message<byte[]>, Message<byte[]>> connection;, +		private AtomicReference<TcpConnection<Message<byte[]>, Message<byte[]>>> readyConnection =, +				new AtomicReference<TcpConnection<Message<byte[]>, Message<byte[]>>>();, +		public void setTcpConnection(TcpConnection<Message<byte[]>, Message<byte[]>> connection) {, +		/**, +		 * Return the underlying {@link TcpConnection} but only after the CONNECTED STOMP, +		 * frame is received., +		 */, +		public TcpConnection<Message<byte[]>, Message<byte[]>> getReadyConnection() {, +		protected Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> openTcpConnection() {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +	private TcpClient<Message<byte[]>, Message<byte[]>> tcpClient;, +		this.tcpClient = new TcpClientSpec<Message<byte[]>, Message<byte[]>>(NettyTcpClient.class), +				.codec(new StompCodec()), +			Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> promise = openTcpConnection();, +			promise.consume(new Consumer<TcpConnection<Message<byte[]>, Message<byte[]>>>() {, +				public void accept(TcpConnection<Message<byte[]>, Message<byte[]>> connection) {, +			promise.when(Throwable.class, new Consumer<Throwable>() {, +		protected Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> openTcpConnection() {, +		protected void handleTcpConnection(TcpConnection<Message<byte[]>, Message<byte[]>> tcpConn, final Message<?> connectMessage) {, +			tcpConn.in().consume(new Consumer<Message<byte[]>>() {, +				public void accept(Message<byte[]> message) {, +		private void readStompFrame(Message<byte[]> message) {, +			TcpConnection<Message<byte[]>, Message<byte[]>> tcpConnection = this.stompConnection.getReadyConnection();, +		@SuppressWarnings("unchecked"), +		private boolean forwardInternal(TcpConnection<Message<byte[]>, Message<byte[]>> tcpConnection, final Message<?> message) {, +, +			Assert.isInstanceOf(byte[].class, message.getPayload(), "Message's payload must be a byte[]");, +			tcpConnection.send((Message<byte[]>)message, new Consumer<Boolean>() {, +		private volatile TcpConnection<Message<byte[]>, Message<byte[]>> connection;, +		private AtomicReference<TcpConnection<Message<byte[]>, Message<byte[]>>> readyConnection =, +				new AtomicReference<TcpConnection<Message<byte[]>, Message<byte[]>>>();, +		public void setTcpConnection(TcpConnection<Message<byte[]>, Message<byte[]>> connection) {, +		/**, +		 * Return the underlying {@link TcpConnection} but only after the CONNECTED STOMP, +		 * frame is received., +		 */, +		public TcpConnection<Message<byte[]>, Message<byte[]>> getReadyConnection() {, +		protected Composable<TcpConnection<Message<byte[]>, Message<byte[]>>> openTcpConnection() {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompCodec.java, +/*, + * Copyright 2002-2013 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.messaging.simp.stomp;, +, +import org.springframework.messaging.Message;, +, +import reactor.function.Consumer;, +import reactor.function.Function;, +import reactor.io.Buffer;, +import reactor.tcp.encoding.Codec;, +, +/**, + * A Reactor TCP {@link Codec} for sending and receiving STOMP messages, + *, + * @author Andy Wilkinson, + * @since 4.0, + */, +public class StompCodec implements Codec<Buffer, Message<byte[]>, Message<byte[]>> {, +, +	private static final StompDecoder DECODER = new StompDecoder();, +, +	private static final Function<Message<byte[]>, Buffer> ENCODER_FUNCTION = new Function<Message<byte[]>, Buffer>() {, +, +		private final StompEncoder encoder = new StompEncoder();, +, +		@Override, +		public Buffer apply(Message<byte[]> message) {]