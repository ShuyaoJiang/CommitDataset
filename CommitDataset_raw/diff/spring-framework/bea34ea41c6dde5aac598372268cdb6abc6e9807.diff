[+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {, +		return type.resolveGenerics(Object.class);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {, +		return type.resolveGenerics(Object.class);, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	 * Return {@code true} if this type contains unresolvable generics only,, +	 * that is, no substitute for any of its declared type variables., +	 */, +	boolean isEntirelyUnresolvable() {, +		if (this == NONE) {, +			return false;, +		}, +		ResolvableType[] generics = getGenerics();, +		for (ResolvableType generic : generics) {, +			if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	/**, +	 * Determine whether the underlying type has any unresolvable generics:, +	 * @param indexes the indexes that refer to the generic parameter, +	 * (may be omitted to return the first generic), +	 * Resolve this type to a {@link java.lang.Class}, returning {@code null}, +	 * if the type cannot be resolved. This method will consider bounds of, +	 * {@link TypeVariable}s and {@link WildcardType}s if direct resolution fails;, +	 * however, bounds of {@code Object.class} will be ignored., +	 * @return the resolved {@link Class}, or {@code null} if not resolvable, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {, +		return type.resolveGenerics(Object.class);, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	 * Return {@code true} if this type contains unresolvable generics only,, +	 * that is, no substitute for any of its declared type variables., +	 */, +	boolean isEntirelyUnresolvable() {, +		if (this == NONE) {, +			return false;, +		}, +		ResolvableType[] generics = getGenerics();, +		for (ResolvableType generic : generics) {, +			if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	/**, +	 * Determine whether the underlying type has any unresolvable generics:, +	 * @param indexes the indexes that refer to the generic parameter, +	 * (may be omitted to return the first generic), +	 * Resolve this type to a {@link java.lang.Class}, returning {@code null}, +	 * if the type cannot be resolved. This method will consider bounds of, +	 * {@link TypeVariable}s and {@link WildcardType}s if direct resolution fails;, +	 * however, bounds of {@code Object.class} will be ignored., +	 * @return the resolved {@link Class}, or {@code null} if not resolvable, +++ b/spring-core/src/test/java/org/springframework/core/GenericTypeResolverTests.java, +import java.io.Serializable;, +				WithArrayBase.class.getDeclaredMethod("array", Object[].class), WithArray.class);, +	@Test, +	public void resolveIncompleteTypeVariables() {, +		// SPR-11763, +		Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);, +		assertNotNull(resolved);, +		assertEquals(2, resolved.length);, +		assertEquals(Object.class, resolved[0]);, +		assertEquals(Long.class, resolved[1]);, +	}, +, +, +	interface Repository<T, ID extends Serializable> {, +	}, +, +	interface IdFixingRepository<T> extends Repository<T, Long> {, +	}, +]