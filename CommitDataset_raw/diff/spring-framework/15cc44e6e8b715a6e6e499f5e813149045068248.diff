[+++ b/spring-web/src/main/java/org/springframework/web/server/WebSession.java, +	 * Invalidate the current session and clear session storage., +	 * @return completion notification (success or error), +	 */, +	Mono<Void> invalidate();, +, +	/**, +++ b/spring-web/src/main/java/org/springframework/web/server/WebSession.java, +	 * Invalidate the current session and clear session storage., +	 * @return completion notification (success or error), +	 */, +	Mono<Void> invalidate();, +, +	/**, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSessionManager.java, +		List<String> ids = getSessionIdResolver().resolveSessionIds(exchange);, +, +		if (!session.isStarted() || session.isExpired()) {, +			if (!ids.isEmpty()) {, +				// Expired on retrieve or while processing request, or invalidated.., +		if (ids.isEmpty() || !session.getId().equals(ids.get(0))) {, +++ b/spring-web/src/main/java/org/springframework/web/server/WebSession.java, +	 * Invalidate the current session and clear session storage., +	 * @return completion notification (success or error), +	 */, +	Mono<Void> invalidate();, +, +	/**, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSessionManager.java, +		List<String> ids = getSessionIdResolver().resolveSessionIds(exchange);, +, +		if (!session.isStarted() || session.isExpired()) {, +			if (!ids.isEmpty()) {, +				// Expired on retrieve or while processing request, or invalidated.., +		if (ids.isEmpty() || !session.getId().equals(ids.get(0))) {, +++ b/spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java, +		private final AtomicReference<String> id = new AtomicReference<>(String.valueOf(idGenerator.generateId()));, +		private final Map<String, Object> attributes = new ConcurrentHashMap<>();, +		private volatile Duration maxIdleTime = Duration.ofMinutes(30);, +		private final AtomicReference<State> state = new AtomicReference<>(State.NEW);, +			this.state.compareAndSet(State.NEW, State.STARTED);, +			return this.state.get().equals(State.STARTED) || !getAttributes().isEmpty();, +		public Mono<Void> invalidate() {, +			this.state.set(State.EXPIRED);, +			getAttributes().clear();, +			InMemoryWebSessionStore.this.sessions.remove(this.id.get());, +			return Mono.empty();, +		}, +, +		@Override, +			if (!getAttributes().isEmpty()) {, +				this.state.compareAndSet(State.NEW, State.STARTED);, +			}, +			if (this.state.get().equals(State.EXPIRED)) {, +				return true;, +			}, +			if (checkExpired()) {, +				this.state.set(State.EXPIRED);, +				return true;, +			}, +			return false;, +		}, +, +		private boolean checkExpired() {, +			return isStarted() && !this.maxIdleTime.isNegative() &&, +					Instant.now(getClock()).minus(this.maxIdleTime).isAfter(this.lastAccessTime);, +, +	private enum State { NEW, STARTED, EXPIRED }, +, +++ b/spring-web/src/main/java/org/springframework/web/server/WebSession.java, +	 * Invalidate the current session and clear session storage., +	 * @return completion notification (success or error), +	 */, +	Mono<Void> invalidate();, +, +	/**, +++ b/spring-web/src/main/java/org/springframework/web/server/session/DefaultWebSessionManager.java, +		List<String> ids = getSessionIdResolver().resolveSessionIds(exchange);, +, +		if (!session.isStarted() || session.isExpired()) {, +			if (!ids.isEmpty()) {, +				// Expired on retrieve or while processing request, or invalidated.., +		if (ids.isEmpty() || !session.getId().equals(ids.get(0))) {, +++ b/spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java, +		private final AtomicReference<String> id = new AtomicReference<>(String.valueOf(idGenerator.generateId()));, +		private final Map<String, Object> attributes = new ConcurrentHashMap<>();, +		private volatile Duration maxIdleTime = Duration.ofMinutes(30);, +		private final AtomicReference<State> state = new AtomicReference<>(State.NEW);, +			this.state.compareAndSet(State.NEW, State.STARTED);, +			return this.state.get().equals(State.STARTED) || !getAttributes().isEmpty();, +		public Mono<Void> invalidate() {, +			this.state.set(State.EXPIRED);, +			getAttributes().clear();, +			InMemoryWebSessionStore.this.sessions.remove(this.id.get());, +			return Mono.empty();, +		}, +, +		@Override, +			if (!getAttributes().isEmpty()) {, +				this.state.compareAndSet(State.NEW, State.STARTED);]