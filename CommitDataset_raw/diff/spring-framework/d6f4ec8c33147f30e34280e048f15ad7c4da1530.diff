[+++ b/spring-messaging/spring-messaging.gradle, +def rsocketVersion = "0.11.17", +++ b/spring-messaging/spring-messaging.gradle, +def rsocketVersion = "0.11.17", +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +						if (data != null) {, +							return Flux.concat(, +									Mono.just(firstPayload(data)),, +									inner.skip(1).map(PayloadUtils::createPayload));, +						}, +						else {, +							return inner.map(PayloadUtils::createPayload);, +						}, +			return PayloadUtils.createPayload(getMetadata(), data);, +					payloadMono.map(this::wrapPayloadData), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::wrapPayloadData).concatMap(dataBuffer ->, +		private DataBuffer wrapPayloadData(Payload payload) {, +			return PayloadUtils.wrapPayloadData(payload, strategies.dataBufferFactory());, +++ b/spring-messaging/spring-messaging.gradle, +def rsocketVersion = "0.11.17", +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +						if (data != null) {, +							return Flux.concat(, +									Mono.just(firstPayload(data)),, +									inner.skip(1).map(PayloadUtils::createPayload));, +						}, +						else {, +							return inner.map(PayloadUtils::createPayload);, +						}, +			return PayloadUtils.createPayload(getMetadata(), data);, +					payloadMono.map(this::wrapPayloadData), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::wrapPayloadData).concatMap(dataBuffer ->, +		private DataBuffer wrapPayloadData(Payload payload) {, +			return PayloadUtils.wrapPayloadData(payload, strategies.dataBufferFactory());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingAcceptor.java, +	 * Configure the default content type to use for data payloads., +	 * <p>By default this is not set. However a server acceptor will use the, +	 * content type from the {@link ConnectionSetupPayload}., +		MessagingRSocket rsocket = createRSocket(sendingRSocket);, +		rsocket.handleConnectionSetupPayload(setupPayload).subscribe();, +		return Mono.just(rsocket);, +		return createRSocket(sendingRSocket);, +	private MessagingRSocket createRSocket(RSocket rsocket) {, +		return new MessagingRSocket(this.messageChannel, rsocket, this.defaultDataMimeType, this.rsocketStrategies);, +++ b/spring-messaging/spring-messaging.gradle, +def rsocketVersion = "0.11.17", +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/DefaultRSocketRequester.java, +						if (data != null) {, +							return Flux.concat(, +									Mono.just(firstPayload(data)),, +									inner.skip(1).map(PayloadUtils::createPayload));, +						}, +						else {, +							return inner.map(PayloadUtils::createPayload);, +						}, +			return PayloadUtils.createPayload(getMetadata(), data);, +					payloadMono.map(this::wrapPayloadData), elementType, dataMimeType, EMPTY_HINTS);, +			return payloadFlux.map(this::wrapPayloadData).concatMap(dataBuffer ->, +		private DataBuffer wrapPayloadData(Payload payload) {, +			return PayloadUtils.wrapPayloadData(payload, strategies.dataBufferFactory());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingAcceptor.java, +	 * Configure the default content type to use for data payloads., +	 * <p>By default this is not set. However a server acceptor will use the, +	 * content type from the {@link ConnectionSetupPayload}., +		MessagingRSocket rsocket = createRSocket(sendingRSocket);, +		rsocket.handleConnectionSetupPayload(setupPayload).subscribe();, +		return Mono.just(rsocket);, +		return createRSocket(sendingRSocket);, +	private MessagingRSocket createRSocket(RSocket rsocket) {, +		return new MessagingRSocket(this.messageChannel, rsocket, this.defaultDataMimeType, this.rsocketStrategies);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingRSocket.java, +import io.rsocket.AbstractRSocket;, +import org.springframework.util.MimeTypeUtils;, +import org.springframework.util.StringUtils;, +class MessagingRSocket extends AbstractRSocket {, +	private MimeType dataMimeType;, +			RSocket sendingRSocket, @Nullable MimeType defaultDataMimeType, RSocketStrategies strategies) {, +		this.requester = RSocketRequester.create(sendingRSocket, defaultDataMimeType, strategies);, +		this.dataMimeType = defaultDataMimeType;, +, +	public Mono<Void> handleConnectionSetupPayload(ConnectionSetupPayload payload) {, +		if (StringUtils.hasText(payload.dataMimeType())) {, +			this.dataMimeType = MimeTypeUtils.parseMimeType(payload.dataMimeType());, +		}, +		return handle(payload);, +		return handle(payload);, +		return handleAndReply(payload, Flux.just(payload)).next();, +		return handleAndReply(payload, Flux.just(payload));, +				.switchOnFirst((signal, innerFlux) -> {, +					Payload firstPayload = signal.get();, +					return firstPayload == null ? innerFlux : handleAndReply(firstPayload, innerFlux);, +		// This won't be very useful until createHeaders starting doing something more with metadata.., +		return handle(payload);, +	private Mono<Void> handle(Payload payload) {, +		Message<?> message = MessageBuilder.createMessage(, +				Mono.fromCallable(() -> wrapPayloadData(payload)),, +				createHeaders(payload, null));, +				Mono.empty() : Mono.error(new MessageDeliveryException("RSocket request not handled")));, +	private Flux<Payload> handleAndReply(Payload firstPayload, Flux<Payload> payloads) {, +		MonoProcessor<Flux<Payload>> replyMono = MonoProcessor.create();]