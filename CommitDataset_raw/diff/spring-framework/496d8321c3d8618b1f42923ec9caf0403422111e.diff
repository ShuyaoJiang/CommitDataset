[+++ b/build.gradle, +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +++ b/build.gradle, +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SubscriptionMethodReturnValueHandler.java, +import org.springframework.messaging.simp.SimpMessageType;, +			headers.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);, +++ b/build.gradle, +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SubscriptionMethodReturnValueHandler.java, +import org.springframework.messaging.simp.SimpMessageType;, +			headers.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +, +		if (command != null && command.requiresDestination() && !checkDestinationPrefix(destination)) {, +				connected(headers, this.stompConnection);, +		protected void connected(StompHeaderAccessor headers, StompConnection stompConnection) {, +			this.stompConnection.setReady();, +			publishBrokerAvailableEvent();, +		}, +, +			disconnected(message);, +		}, +, +		protected void disconnected(String errorMessage) {, +			sendError(errorMessage);, +		private static final long HEARTBEAT_RECEIVE_MULTIPLIER = 3;, +, +		private final byte[] heartbeatPayload = new byte[] {'\n'};, +, +		protected void connected(StompHeaderAccessor headers, final StompConnection stompConnection) {, +			long brokerReceiveInterval = headers.getHeartbeat()[1];, +, +			if (HEARTBEAT_SEND_INTERVAL > 0 && brokerReceiveInterval > 0) {, +				long interval = Math.max(HEARTBEAT_SEND_INTERVAL,  brokerReceiveInterval);, +				stompConnection.connection.on().writeIdle(interval, new Runnable() {, +, +					@Override, +					public void run() {, +						stompConnection.connection.send(MessageBuilder.withPayload(heartbeatPayload).build());, +					}, +, +				});, +			}, +, +			long brokerSendInterval = headers.getHeartbeat()[0];, +			if (HEARTBEAT_RECEIVE_INTERVAL > 0 && brokerSendInterval > 0) {, +				final long interval =, +						Math.max(HEARTBEAT_RECEIVE_INTERVAL, brokerSendInterval) * HEARTBEAT_RECEIVE_MULTIPLIER;, +				stompConnection.connection.on().readIdle(interval,  new Runnable() {, +					@Override, +					public void run() {, +						String message = "Broker hearbeat missed: connection idle for more than " + interval + "ms";, +						logger.warn(message);, +						disconnected(message);, +					}, +				});, +			}, +, +			super.connected(headers, stompConnection);, +		}, +, +		@Override, +++ b/build.gradle, +		maven { url 'http://repo.springsource.org/libs-snapshot' } // reactor, +		optional("org.projectreactor:reactor-core:1.0.0.BUILD-SNAPSHOT"), +		optional("org.projectreactor:reactor-tcp:1.0.0.BUILD-SNAPSHOT"), +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SubscriptionMethodReturnValueHandler.java, +import org.springframework.messaging.simp.SimpMessageType;, +			headers.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +, +		if (command != null && command.requiresDestination() && !checkDestinationPrefix(destination)) {, +				connected(headers, this.stompConnection);, +		protected void connected(StompHeaderAccessor headers, StompConnection stompConnection) {, +			this.stompConnection.setReady();, +			publishBrokerAvailableEvent();, +		}, +, +			disconnected(message);, +		}, +, +		protected void disconnected(String errorMessage) {, +			sendError(errorMessage);, +		private static final long HEARTBEAT_RECEIVE_MULTIPLIER = 3;, +, +		private final byte[] heartbeatPayload = new byte[] {'\n'};, +, +		protected void connected(StompHeaderAccessor headers, final StompConnection stompConnection) {, +			long brokerReceiveInterval = headers.getHeartbeat()[1];, +, +			if (HEARTBEAT_SEND_INTERVAL > 0 && brokerReceiveInterval > 0) {, +				long interval = Math.max(HEARTBEAT_SEND_INTERVAL,  brokerReceiveInterval);, +				stompConnection.connection.on().writeIdle(interval, new Runnable() {]