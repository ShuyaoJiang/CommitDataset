[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java, +, +, +, +, +, +, +, +, +	public boolean isWritable(ExpressionState expressionState) throws SpelEvaluationException {, +	private class ArrayIndexingValueRef implements ValueRef {, +		private final TypeConverter typeConverter;, +, +		private final Object array;, +, +		private final int idx;, +, +		private final TypeDescriptor typeDescriptor;, +, +		ArrayIndexingValueRef(TypeConverter typeConverter, Object array, int idx, TypeDescriptor typeDescriptor) {, +			Object arrayElement = accessArrayElement(this.array, this.idx);, +			return new TypedValue(arrayElement, this.typeDescriptor.elementTypeDescriptor(arrayElement));, +			setArrayElement(this.typeConverter, this.array, this.idx, newValue,, +					this.typeDescriptor.getElementTypeDescriptor().getType());, +, +	private class MapIndexingValueRef implements ValueRef {, +		private final TypeConverter typeConverter;, +		private final Map map;, +, +		private final Object key;, +, +		private final TypeDescriptor mapEntryTypeDescriptor;, +, +		MapIndexingValueRef(TypeConverter typeConverter, Map map, Object key, TypeDescriptor mapEntryTypeDescriptor) {, +			Object value = this.map.get(this.key);, +			return new TypedValue(value, this.mapEntryTypeDescriptor.getMapValueTypeDescriptor(value));, +			if (this.mapEntryTypeDescriptor.getMapValueTypeDescriptor() != null) {, +				newValue = this.typeConverter.convertValue(newValue, TypeDescriptor.forObject(newValue),, +						this.mapEntryTypeDescriptor.getMapValueTypeDescriptor());, +			this.map.put(this.key, newValue);, +	private class PropertyIndexingValueRef implements ValueRef {, +		private final Object targetObject;, +, +		private final String name;, +, +		private final EvaluationContext eContext;, +, +		private final TypeDescriptor td;, +, +		public PropertyIndexingValueRef(Object targetObject, String value, EvaluationContext evaluationContext,, +				if (cachedReadName != null && cachedReadName.equals(name) && cachedReadTargetType != null &&, +						cachedReadTargetType.equals(targetObjectRuntimeClass)) {, +					return cachedReadAccessor.read(this.eContext, this.targetObject, this.name);, +				List<PropertyAccessor> accessorsToTry =, +						AstUtils.getPropertyAccessorsToTry(targetObjectRuntimeClass, eContext.getPropertyAccessors());, +						if (accessor.canRead(this.eContext, this.targetObject, this.name)) {, +								accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(, +										this.eContext, this.targetObject, this.name);, +							cachedReadName = this.name;, +							return accessor.read(this.eContext, this.targetObject, this.name);, +			catch (AccessException ex) {, +				throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,, +						this.td.toString());, +			}, +			throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,, +					this.td.toString());, +				if (cachedWriteName != null && cachedWriteName.equals(name) && cachedWriteTargetType != null &&, +						cachedWriteTargetType.equals(contextObjectClass)) {, +					cachedWriteAccessor.write(this.eContext, this.targetObject, this.name, newValue);, +				List<PropertyAccessor> accessorsToTry =, +						AstUtils.getPropertyAccessorsToTry(contextObjectClass, this.eContext.getPropertyAccessors());, +						if (accessor.canWrite(this.eContext, this.targetObject, this.name)) {, +							cachedWriteName = this.name;, +							accessor.write(this.eContext, this.targetObject, this.name, newValue);, +			}, +			catch (AccessException ex) {, +				throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_PROPERTY_WRITE,, +						this.name, ex.getMessage());, +, +	private class CollectionIndexingValueRef implements ValueRef {, +		private final Collection collection;, +		private final int index;, +, +		private final TypeDescriptor collectionEntryTypeDescriptor;, +, +		private final TypeConverter typeConverter;, +, +		private final boolean growCollection;, +, +		CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryTypeDescriptor,, +				TypeConverter typeConverter, boolean growCollection) {, +			this.typeConverter = typeConverter;, +			this.growCollection = growCollection;, +			if (this.index >= this.collection.size()) {, +				if (this.growCollection) {, +					growCollection(this.collectionEntryTypeDescriptor, this.index, this.collection);, +				else {, +					throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,, +							this.collection.size(), this.index);, +				}]