[+++ b/spring-web/src/main/java/org/springframework/web/server/adapter/DefaultServerWebExchange.java, +	private static final ResolvableType FORM_DATA_TYPE =, +	private static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(, +	private static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, String>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED)), +						.orElseThrow(() -> new IllegalStateException("No form data HttpMessageReader."))), +						.readMono(FORM_DATA_TYPE, request, Collections.emptyMap()), +	private static Mono<MultiValueMap<String, Part>> initMultipartData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.MULTIPART_FORM_DATA.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, Part>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA)), +						.orElseThrow(() -> new IllegalStateException("No multipart HttpMessageReader."))), +						.readMono(MULTIPART_DATA_TYPE, request, Collections.emptyMap()), +++ b/spring-web/src/main/java/org/springframework/web/server/adapter/DefaultServerWebExchange.java, +	private static final ResolvableType FORM_DATA_TYPE =, +	private static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(, +	private static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, String>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED)), +						.orElseThrow(() -> new IllegalStateException("No form data HttpMessageReader."))), +						.readMono(FORM_DATA_TYPE, request, Collections.emptyMap()), +	private static Mono<MultiValueMap<String, Part>> initMultipartData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.MULTIPART_FORM_DATA.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, Part>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA)), +						.orElseThrow(() -> new IllegalStateException("No multipart HttpMessageReader."))), +						.readMono(MULTIPART_DATA_TYPE, request, Collections.emptyMap()), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestPartMethodArgumentResolver.java, +import org.springframework.core.ReactiveAdapter;, +, +		Mono<Object> partsMono = exchange.getMultipartData(), +				.filter(map -> !CollectionUtils.isEmpty(map.get(name))), +				.map(map -> {, +					List<Part> parts = map.get(name);, +					return parts.size() == 1 ? parts.get(0) : parts;, +, +		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(param.getParameterType());, +		return (adapter != null ? Mono.just(adapter.fromPublisher(partsMono)) : partsMono);, +++ b/spring-web/src/main/java/org/springframework/web/server/adapter/DefaultServerWebExchange.java, +	private static final ResolvableType FORM_DATA_TYPE =, +	private static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(, +	private static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, String>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED)), +						.orElseThrow(() -> new IllegalStateException("No form data HttpMessageReader."))), +						.readMono(FORM_DATA_TYPE, request, Collections.emptyMap()), +	private static Mono<MultiValueMap<String, Part>> initMultipartData(ServerHttpRequest request,, +			ServerCodecConfigurer configurer) {, +			MediaType contentType = request.getHeaders().getContentType();, +			if (MediaType.MULTIPART_FORM_DATA.isCompatibleWith(contentType)) {, +				return ((HttpMessageReader<MultiValueMap<String, Part>>) configurer.getReaders().stream(), +						.filter(reader -> reader.canRead(MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA)), +						.orElseThrow(() -> new IllegalStateException("No multipart HttpMessageReader."))), +						.readMono(MULTIPART_DATA_TYPE, request, Collections.emptyMap()), +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestPartMethodArgumentResolver.java, +import org.springframework.core.ReactiveAdapter;, +, +		Mono<Object> partsMono = exchange.getMultipartData(), +				.filter(map -> !CollectionUtils.isEmpty(map.get(name))), +				.map(map -> {, +					List<Part> parts = map.get(name);, +					return parts.size() == 1 ? parts.get(0) : parts;, +, +		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(param.getParameterType());, +		return (adapter != null ? Mono.just(adapter.fromPublisher(partsMono)) : partsMono);, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/MultipartIntegrationTests.java, +import java.time.Duration;, +import org.springframework.http.codec.multipart.FormFieldPart;, +		void requestPart(@RequestPart FormFieldPart barPart, @RequestPart Mono<FilePart> fooPart) {, +			assertEquals("bar", barPart.getValue());, +			assertEquals("foo.txt", fooPart.block(Duration.ZERO).getFilename());]