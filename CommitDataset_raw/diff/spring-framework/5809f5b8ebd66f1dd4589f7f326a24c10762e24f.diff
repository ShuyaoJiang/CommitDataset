[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, +							getId(), getTimeSinceSendStarted(), getBufferSize());, +				if (getTimeSinceSendStarted() > getSendTimeLimit()) {, +					String reason = String.format(format, getTimeSinceSendStarted(), getId(), getSendTimeLimit());, +				else if (getBufferSize() > getBufferSizeLimit()) {, +					String reason = String.format(format, getBufferSize(), getId(), getBufferSizeLimit());, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, +							getId(), getTimeSinceSendStarted(), getBufferSize());, +				if (getTimeSinceSendStarted() > getSendTimeLimit()) {, +					String reason = String.format(format, getTimeSinceSendStarted(), getId(), getSendTimeLimit());, +				else if (getBufferSize() > getBufferSizeLimit()) {, +					String reason = String.format(format, getBufferSize(), getId(), getBufferSizeLimit());, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolHandler.java, + * Copyright 2002-2017 the original author or authors., + * A contract for handling WebSocket messages as part of a higher level protocol,, + * referred to as "sub-protocol" in the WebSocket RFC specification. Handles both, + *, + * <p>Implementations of this interface can be configured on a, + * {@link SubProtocolWebSocketHandler} which selects a sub-protocol handler to, + * delegate messages to based on the sub-protocol requested by the client through, + * the {@code Sec-WebSocket-Protocol} request header., +	 * Return the list of sub-protocols supported by this handler (never {@code null})., +	void handleMessageFromClient(WebSocketSession session, WebSocketMessage<?> message, MessageChannel outputChannel), +			throws Exception;, +	 * Handle the given {@link Message} to the client associated with the given WebSocket session., +	void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel), +			throws Exception;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, +							getId(), getTimeSinceSendStarted(), getBufferSize());, +				if (getTimeSinceSendStarted() > getSendTimeLimit()) {, +					String reason = String.format(format, getTimeSinceSendStarted(), getId(), getSendTimeLimit());, +				else if (getBufferSize() > getBufferSizeLimit()) {, +					String reason = String.format(format, getBufferSize(), getId(), getBufferSizeLimit());, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolHandler.java, + * Copyright 2002-2017 the original author or authors., + * A contract for handling WebSocket messages as part of a higher level protocol,, + * referred to as "sub-protocol" in the WebSocket RFC specification. Handles both, + *, + * <p>Implementations of this interface can be configured on a, + * {@link SubProtocolWebSocketHandler} which selects a sub-protocol handler to, + * delegate messages to based on the sub-protocol requested by the client through, + * the {@code Sec-WebSocket-Protocol} request header., +	 * Return the list of sub-protocols supported by this handler (never {@code null})., +	void handleMessageFromClient(WebSocketSession session, WebSocketMessage<?> message, MessageChannel outputChannel), +			throws Exception;, +	 * Handle the given {@link Message} to the client associated with the given WebSocket session., +	void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel), +			throws Exception;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java, +		session = decorateSession(session);, +	/**, +	 * Decorate the given {@link WebSocketSession}, if desired., +	 * <p>The default implementation builds a {@link ConcurrentWebSocketSessionDecorator}, +	 * with the configured {@link #getSendTimeLimit() send-time limit} and, +	 * {@link #getSendBufferSizeLimit() buffer-size limit}., +	 * @param session the original {@code WebSocketSession}, +	 * @return the decorated {@code WebSocketSession}, or potentially the given session as-is, +	 * @since 4.3.13, +	 */, +	protected WebSocketSession decorateSession(WebSocketSession session) {, +		return new ConcurrentWebSocketSessionDecorator(session, getSendTimeLimit(), getSendBufferSizeLimit());, +	}, +, +	/**, +	 * Find a {@link SubProtocolHandler} for the given session., +	 * @param session the {@code WebSocketSession} to find a handler for, +	 */, +	 * before the higher level protocol is fully connected there is a possibility for, +	 * sessions to hang. This method checks and closes any sessions that have been, +	 * connected for more than 60 seconds without having received a single message., +	private void checkSessions() {, +		private final long createTime;, +		private volatile boolean hasHandledMessages;, +		public WebSocketSessionHolder(WebSocketSession session) {, +			this.createTime = System.currentTimeMillis();, +			this.hasHandledMessages = true;, +			return this.hasHandledMessages;, +					this.createTime + ", hasHandledMessages=" + this.hasHandledMessages + "]";]