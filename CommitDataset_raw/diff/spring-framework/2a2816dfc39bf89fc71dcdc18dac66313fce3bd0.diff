[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	 * {@link WildcardType}s if direct resolution fails; however, bounds of, +	 * {@code Object.class} will be ignored., +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +	 * {@link WildcardType}s if direct resolution fails; however, bounds of, +	 * {@code Object.class} will be ignored., +++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +		this.type = this.resolvableType.resolve(methodParameter.getParameterType());, +		this.type = this.resolvableType.resolve(field.getType());, +	 * Narrows this {@link TypeDescriptor} by setting its type to the class of the, +	 * provided value., +	 * <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor, +	 * is returned unchanged., +	 * <p>Designed to be called by binding frameworks when they read property, field,, +	 * or method return values. Allows such frameworks to narrow a TypeDescriptor built, +	 * from a declared property, field, or method return value type. For example, a field, +	 * declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}, +	 * if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor, +	 * can then be used to convert the HashMap to some other type. Annotation and nested, +	 * type context is preserved by the narrowed copy., +	 * @return this TypeDescriptor narrowed (returns a copy with its type updated to the, +	 * class of the provided value), +	 * Returns true if an object of this type descriptor can be assigned to the location, +	 * described by the given type descriptor., +	 * <p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}, +	 * returns {@code true} because a String value can be assigned to a CharSequence variable., +	 * On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}, +	 * returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers., +	 * <p>For arrays, collections, and maps, element and key/value types are checked if declared., +	 * For example, a List&lt;String&gt; field value is assignable to a Collection&lt;CharSequence&gt;, +	 * field, but List&lt;Number&gt; is not assignable to List&lt;Integer&gt;., +	 * @return {@code true} if this type is assignable to the type represented by the provided, +	 * type descriptor, +	 * If the Collection is not parameterized, returns {@code null} indicating the element type is not declared., +	 * @return the array component type or Collection element type, or {@code null} if this type is a, +	 * Collection but its element type is not parameterized, +	 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type, +			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations);, +		Assert.state(isCollection(), "Not an array or java.util.Collection");, +	 * If this type is a {@link Collection} or an array, creates a element TypeDescriptor, +	 * from the provided collection or array element., +	 * <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class, +	 * of the provided collection or array element. For example, if this describes a, +	 * {@code java.util.List&lt;java.lang.Number&lt;} and the element argument is an, +	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}., +	 * If this describes a {@code java.util.List&lt;?&gt;} and the element argument is an, +	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}, +	 * as well., +	 * <p>Annotation and nested type context will be preserved in the narrowed, +	 * TypeDescriptor that is returned., +	 * @throws IllegalStateException if this type is not a {@code java.util.Collection}, +	 * or array type, +	 * If this type is a {@link Map} and its key type is parameterized,, +	 * returns the map's key type. If the Map's key type is not parameterized,, +	 * returns {@code null} indicating the key type is not declared., +	 * @return the Map key type, or {@code null} if this type is a Map, +	 * but its key type is not parameterized, +	 * @throws IllegalStateException if this type is not a {@code java.util.Map}, +		Assert.state(isMap(), "Not a java.util.Map");, +	 * If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}, +	 * from the provided map key., +	 * <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property, +	 * to the class of the provided map key. For example, if this describes a, +	 * {@code java.util.Map&lt;java.lang.Number, java.lang.String&lt;} and the key, +	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be, +	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}, +	 * and the key argument is a {@code java.lang.Integer}, the returned, +	 * TypeDescriptor will be {@code java.lang.Integer} as well., +	 * <p>Annotation and nested type context will be preserved in the narrowed, +	 * TypeDescriptor that is returned., +	 * @throws IllegalStateException if this type is not a {@code java.util.Map}, +	 * If this type is a {@link Map} and its value type is parameterized,, +	 * returns the map's value type., +	 * <p>If the Map's value type is not parameterized, returns {@code null}, +	 * indicating the value type is not declared., +	 * @return the Map value type, or {@code null} if this type is a Map, +	 * but its value type is not parameterized, +	 * @throws IllegalStateException if this type is not a {@code java.util.Map}, +		Assert.state(isMap(), "Not a java.util.Map");, +	 * If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}, +	 * from the provided map value., +	 * <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property, +	 * to the class of the provided map value. For example, if this describes a, +	 * {@code java.util.Map&lt;java.lang.String, java.lang.Number&lt;} and the value, +	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be, +	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}, +	 * and the value argument is a {@code java.lang.Integer}, the returned, +	 * TypeDescriptor will be {@code java.lang.Integer} as well., +	 * <p>Annotation and nested type context will be preserved in the narrowed, +	 * TypeDescriptor that is returned., +	 * @throws IllegalStateException if this type is not a {@code java.util.Map}, +	 * @see #narrow(Object), +	 * Returns the value of {@link TypeDescriptor#getType() getType()} for the, +	 * {@link #getElementTypeDescriptor() elementTypeDescriptor}., +	 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type, +	 * Returns the value of {@link TypeDescriptor#getType() getType()} for the, +	 * {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}., +	 * @throws IllegalStateException if this type is not a {@code java.util.Map}, +	 * Returns the value of {@link TypeDescriptor#getType() getType()} for the, +	 * {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.]