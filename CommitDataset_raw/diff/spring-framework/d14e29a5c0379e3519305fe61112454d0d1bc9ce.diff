[+++ b/spring-test/src/main/java/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.java, +, +	 * Construct a new {@code SpringJUnit4ClassRunner} and initialize a, +	 * Create a new {@link TestContextManager} for the supplied test class., +	 * Return a description suitable for an ignored test class if the test is, +	 * otherwise delegate to the parent implementation., +	 * Check whether the test is enabled in the current execution environment., +	 * <p>This prevents classes with a non-matching {@code @IfProfileValue}, +	 * annotation from running altogether, even skipping the execution of, +	 * {@code prepareTestInstance()} methods in {@code TestExecutionListeners}., +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * default JUnit functionality while adding support for the Spring TestContext, +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * JUnit functionality while adding support for the Spring TestContext Framework., +	 * Delegate to the parent implementation for creating the test instance and, +	 * then allow the {@link #getTestContextManager() TestContextManager} to, +	 * @see TestContextManager#prepareTestInstance, +	 * Perform the same logic as, +	 * Augment the default JUnit behavior, +	 * {@linkplain #withPotentialRepeat with potential repeats} of the entire, +	 * execution chain., +	 * <p>Furthermore, support for timeouts has been moved down the execution, +	 * chain in order to include execution of {@link org.junit.Before @Before}, +	 * and {@link org.junit.After @After} methods within the timed execution., +	 * Note that this differs from the default JUnit behavior of executing, +	 * {@code @Before} and {@code @After} methods in the main thread while, +	 * executing the actual test method in a separate thread. Thus, the net, +	 * effect is that {@code @Before} and {@code @After} methods will be, +	 * executed in the same thread as the test method. As a consequence,, +	 * JUnit-specified timeouts will work fine in combination with Spring, +	 * transactions. However, JUnit-specific timeouts still differ from, +	 * Spring-specific timeouts in that the former execute in a separate, +	 * thread while the latter simply execute in the main thread (like regular, +	 * tests)., +	 * @see #withRulesReflectively(FrameworkMethod, Object, Statement), +	 * Return {@code true} if {@link Ignore @Ignore} is present for the supplied, +	 * {@linkplain FrameworkMethod test method} or if the test method is disabled, +	 * via {@code @IfProfileValue}., +	 * Perform the same logic as, +		return (expectedException != null ? new ExpectException(next, expectedException) : next);, +	 * Get the {@code exception} that the supplied {@linkplain FrameworkMethod, +	 * <p>Can be overridden by subclasses., +	 * Perform the same logic as, +	 * {@link BlockJUnit4ClassRunner#withPotentialTimeout(FrameworkMethod, Object, Statement)}, +	 * but with additional support for Spring's {@code @Timed} annotation., +	 * <p>Supports both Spring's {@link Timed @Timed} and JUnit's, +	 * simultaneously., +	 * @return either a {@link SpringFailOnTimeout}, a {@link FailOnTimeout},, +	 * or the supplied {@link Statement} as appropriate, +			String msg = String.format(, +				"Test method [%s] has been configured with Spring's @Timed(millis=%s) and ", +					+ "JUnit's @Test(timeout=%s) annotations, but only one declaration of ", +					+ "a 'timeout' is permitted per test method.",, +				frameworkMethod.getMethod(), springTimeout, junitTimeout);, +	 * Retrieve the configured JUnit {@code timeout} from the {@link Test @Test}, +	 * annotation on the supplied {@linkplain FrameworkMethod test method}., +	 * @return the timeout, or {@code 0} if none was specified, +	 * Retrieve the configured Spring-specific {@code timeout} from the, +	 * {@linkplain FrameworkMethod test method}., +	 * @return the timeout, or {@code 0} if none was specified, +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * default functionality while adding support for the Spring TestContext, +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * default functionality while adding support for the Spring TestContext, +	 * Return a {@link Statement} that potentially repeats the execution of, +	 * the {@code next} statement., +	 * <p>Supports Spring's {@link Repeat @Repeat} annotation by returning a, +	 * count (if greater than {@code 1}); otherwise, the supplied statement, +	 * is returned unmodified., +	 * @return either a {@link SpringRepeat} or the supplied {@link Statement}, +	 * as appropriate, +		return (repeat > 1 ? new SpringRepeat(next, frameworkMethod.getMethod(), repeat) : next);, +++ b/spring-test/src/main/java/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.java, +, +	 * Construct a new {@code SpringJUnit4ClassRunner} and initialize a, +	 * Create a new {@link TestContextManager} for the supplied test class., +	 * Return a description suitable for an ignored test class if the test is, +	 * otherwise delegate to the parent implementation., +	 * Check whether the test is enabled in the current execution environment., +	 * <p>This prevents classes with a non-matching {@code @IfProfileValue}, +	 * annotation from running altogether, even skipping the execution of, +	 * {@code prepareTestInstance()} methods in {@code TestExecutionListeners}., +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * default JUnit functionality while adding support for the Spring TestContext, +	 * Wrap the {@link Statement} returned by the parent implementation with a, +	 * JUnit functionality while adding support for the Spring TestContext Framework., +	 * Delegate to the parent implementation for creating the test instance and, +	 * then allow the {@link #getTestContextManager() TestContextManager} to, +	 * @see TestContextManager#prepareTestInstance, +	 * Perform the same logic as, +	 * Augment the default JUnit behavior, +	 * {@linkplain #withPotentialRepeat with potential repeats} of the entire, +	 * execution chain., +	 * <p>Furthermore, support for timeouts has been moved down the execution, +	 * chain in order to include execution of {@link org.junit.Before @Before}, +	 * and {@link org.junit.After @After} methods within the timed execution., +	 * Note that this differs from the default JUnit behavior of executing, +	 * {@code @Before} and {@code @After} methods in the main thread while, +	 * executing the actual test method in a separate thread. Thus, the net, +	 * effect is that {@code @Before} and {@code @After} methods will be]