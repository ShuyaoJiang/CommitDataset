[+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java, +import java.net.URLDecoder;, +, +import org.springframework.core.io.ClassPathResource;, +import org.springframework.core.io.UrlResource;, +	private Resource[] allowedLocations;, +, +, +	/**, +	 * By default when a Resource is found, the path of the resolved resource is, +	 * compared to ensure it's under the input location where it was found., +	 * However sometimes that may not be the case, e.g. when, +	 * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}, +	 * resolves public URLs of links it contains, the CSS file is the location, +	 * and the resources being resolved are css files, images, fonts and others, +	 * located in adjacent or parent directories., +	 * <p>This property allows configuring a complete list of locations under, +	 * which resources must be so that if a resource is not under the location, +	 * relative to which it was found, this list may be checked as well., +	 * <p>By default {@link ResourceHttpRequestHandler} initializes this property, +	 * to match its list of locations., +	 * @param locations the list of allowed locations, +	 * @since 4.1.2, +	 * @see ResourceHttpRequestHandler#initAllowedLocations(), +	 */, +	public void setAllowedLocations(Resource... locations) {, +		this.allowedLocations = locations;, +	}, +, +	public Resource[] getAllowedLocations() {, +		return this.allowedLocations;, +	}, +, +, +		if (resource.exists() && resource.isReadable()) {, +			if (checkResource(resource, location)) {, +				return resource;, +			}, +			else {, +				if (logger.isTraceEnabled()) {, +					logger.trace("resourcePath=\"" + resourcePath + "\" was successfully resolved " +, +							"but resource=\"" +	resource.getURL() + "\" is neither under the " +, +							"current location=\"" + location.getURL() + "\" nor under any of the " +, +							"allowed locations=" + getAllowedLocations());, +				}, +			}, +		}, +		return null;, +	}, +, +	/**, +	 * Perform additional checks on a resolved resource beyond checking whether, +	 * the resources exists and is readable. The default implementation also, +	 * verifies the resource is either under the location relative to which it, +	 * was found or is under one of the {@link #setAllowedLocations allowed, +	 * locations}., +	 * @param resource the resource to check, +	 * @param location the location relative to which the resource was found, +	 * @return "true" if resource is in a valid location, "false" otherwise., +	 * @since 4.1.2, +	 */, +	protected boolean checkResource(Resource resource, Resource location) throws IOException {, +		if (isResourceUnderLocation(resource, location)) {, +			return true;, +		}, +		if (getAllowedLocations() != null) {, +			for (Resource current : getAllowedLocations()) {, +				if (isResourceUnderLocation(resource, current)) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +, +	private boolean isResourceUnderLocation(Resource resource, Resource location) throws IOException {, +		if (!resource.getClass().equals(location.getClass())) {, +			return false;, +		}, +		String resourcePath;, +		String locationPath;, +		if (resource instanceof ClassPathResource) {, +			resourcePath = ((ClassPathResource) resource).getPath();, +			locationPath = ((ClassPathResource) location).getPath();, +		}, +		else if (resource instanceof UrlResource) {, +			resourcePath = resource.getURL().toExternalForm();, +			locationPath = location.getURL().toExternalForm();, +		}, +		else {, +			resourcePath = resource.getURL().getPath();, +			locationPath = location.getURL().getPath();, +		}, +		locationPath = (locationPath.endsWith("/") || locationPath.isEmpty() ? locationPath : locationPath + "/");, +		if (!resourcePath.startsWith(locationPath)) {, +			return false;, +		}, +		if (resourcePath.contains("%")) {, +			// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars, +			if (URLDecoder.decode(resourcePath, "UTF-8").contains("../")) {]