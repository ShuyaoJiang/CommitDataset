[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java, +						ex -> Mono.from(unsupportedErrorHandler(inputMessage, ex)),, +						skipBodyAsMono(inputMessage));, +						ex -> unsupportedErrorHandler(inputMessage, ex),, +						skipBodyAsFlux(inputMessage));, +				.orElseGet(() -> {, +					List<MediaType> mediaTypes = context.messageReaders().stream(), +					return errorFunction.apply(, +							new UnsupportedMediaTypeException(contentType, mediaTypes, elementType));, +				});, +			ReactiveHttpInputMessage message, UnsupportedMediaTypeException ex) {, +		if (message.getHeaders().getContentType() == null) {, +			// Maybe it's okay, if there is no content.., +			result = message.getBody().map(o -> {, +		if (message instanceof ClientHttpResponse) {, +			result = consumeAndCancel(message).thenMany(result);, +		}, +		return result;, +	private static <T> Supplier<Flux<T>> skipBodyAsFlux(ReactiveHttpInputMessage message) {, +		return message instanceof ClientHttpResponse ?, +				() -> consumeAndCancel(message).thenMany(Mono.empty()) : Flux::empty;, +	}, +, +	@SuppressWarnings("unchecked"), +	private static <T> Supplier<Mono<T>> skipBodyAsMono(ReactiveHttpInputMessage message) {, +		return message instanceof ClientHttpResponse ?, +				() -> consumeAndCancel(message).then(Mono.empty()) : Mono::empty;, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java, +						ex -> Mono.from(unsupportedErrorHandler(inputMessage, ex)),, +						skipBodyAsMono(inputMessage));, +						ex -> unsupportedErrorHandler(inputMessage, ex),, +						skipBodyAsFlux(inputMessage));, +				.orElseGet(() -> {, +					List<MediaType> mediaTypes = context.messageReaders().stream(), +					return errorFunction.apply(, +							new UnsupportedMediaTypeException(contentType, mediaTypes, elementType));, +				});, +			ReactiveHttpInputMessage message, UnsupportedMediaTypeException ex) {, +		if (message.getHeaders().getContentType() == null) {, +			// Maybe it's okay, if there is no content.., +			result = message.getBody().map(o -> {, +		if (message instanceof ClientHttpResponse) {, +			result = consumeAndCancel(message).thenMany(result);, +		}, +		return result;, +	private static <T> Supplier<Flux<T>> skipBodyAsFlux(ReactiveHttpInputMessage message) {, +		return message instanceof ClientHttpResponse ?, +				() -> consumeAndCancel(message).thenMany(Mono.empty()) : Flux::empty;, +	}, +, +	@SuppressWarnings("unchecked"), +	private static <T> Supplier<Mono<T>> skipBodyAsMono(ReactiveHttpInputMessage message) {, +		return message instanceof ClientHttpResponse ?, +				() -> consumeAndCancel(message).then(Mono.empty()) : Mono::empty;, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java, +, +, +, +			return this.responseMono.flatMap(response -> handleBody(response,, +					response.bodyToMono(bodyType), mono -> mono.flatMap(Mono::error)));, +		public <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> bodyType) {, +			return this.responseMono.flatMap(response ->, +					handleBody(response, response.bodyToMono(bodyType), mono -> mono.flatMap(Mono::error)));, +		@SuppressWarnings("unchecked"), +			return this.responseMono.flatMapMany(response ->, +					handleBody(response, response.bodyToFlux(elementType), mono -> mono.flatMapMany(Flux::error)));, +		@SuppressWarnings("unchecked"), +		public <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> elementType) {, +			return this.responseMono.flatMapMany(response -> handleBody(response,, +					response.bodyToFlux(elementType), mono -> mono.flatMapMany(Flux::error)));, +		private <T extends Publisher<?>> T handleBody(ClientResponse response,, +, +]