[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageType.java, +	CONNECT_ACK,, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageType.java, +	CONNECT_ACK,, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageType.java, +	CONNECT_ACK,, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageType.java, +	CONNECT_ACK,, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/handler/SimpleBrokerMessageHandler.java, +	private static final byte[] EMPTY_PAYLOAD = new byte[0];, +, +			String sessionId = headers.getSessionId();, +		} else if (SimpMessageType.CONNECT.equals(messageType)) {, +			String sessionId = headers.getSessionId();, +			SimpMessageHeaderAccessor connectAckHeaders =, +					SimpMessageHeaderAccessor.create(SimpMessageType.CONNECT_ACK);, +			connectAckHeaders.setSessionId(sessionId);, +			connectAckHeaders.setHeader(SimpMessageHeaderAccessor.CONNECT_MESSAGE_HEADER, message);, +			Message<byte[]> connectAck =, +					MessageBuilder.withPayloadAndHeaders(EMPTY_PAYLOAD, connectAckHeaders).build();, +			this.messageChannel.send(connectAck);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageHeaderAccessor.java, +	public static final String CONNECT_MESSAGE_HEADER = "connectMessage";, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageType.java, +	CONNECT_ACK,, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/ServletStompEndpointRegistry.java, +			MutableUserQueueSuffixResolver userQueueSuffixResolver, TaskScheduler defaultSockJsTaskScheduler) {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/config/WebSocketMessageBrokerConfigurationSupport.java, +				userQueueSuffixResolver(), brokerDefaultSockJsTaskScheduler());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/handler/SimpleBrokerMessageHandler.java, +	private static final byte[] EMPTY_PAYLOAD = new byte[0];, +, +			String sessionId = headers.getSessionId();, +		} else if (SimpMessageType.CONNECT.equals(messageType)) {, +			String sessionId = headers.getSessionId();, +			SimpMessageHeaderAccessor connectAckHeaders =, +					SimpMessageHeaderAccessor.create(SimpMessageType.CONNECT_ACK);, +			connectAckHeaders.setSessionId(sessionId);, +			connectAckHeaders.setHeader(SimpMessageHeaderAccessor.CONNECT_MESSAGE_HEADER, message);, +			Message<byte[]> connectAck =, +					MessageBuilder.withPayloadAndHeaders(EMPTY_PAYLOAD, connectAckHeaders).build();, +			this.messageChannel.send(connectAck);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompProtocolHandler.java, +		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {, +			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED);, +			connectedHeaders.setVersion(getVersion(headers));, +			connectedHeaders.setHeartbeat(0, 0);, +			headers = connectedHeaders;, +, +		if (headers.getCommand() == StompCommand.CONNECTED) {, +			augmentConnectedHeaders(headers, session);, +	private String getVersion(StompHeaderAccessor connectAckHeaders) {, +		Message<?> connectMessage =, +				(Message<?>) connectAckHeaders.getHeader(StompHeaderAccessor.CONNECT_MESSAGE_HEADER);, +		StompHeaderAccessor connectHeaders = StompHeaderAccessor.wrap(connectMessage);, +, +		Set<String> acceptVersions = connectHeaders.getAcceptVersion();, +		if (acceptVersions.contains("1.2")) {, +			return "1.2";, +		}, +		else if (acceptVersions.contains("1.1")) {, +			return "1.1";, +		}, +		else if (acceptVersions.isEmpty()) {, +			return null;, +		}, +		else {, +			throw new StompConversionException("Unsupported version '" + acceptVersions + "'");, +		}]