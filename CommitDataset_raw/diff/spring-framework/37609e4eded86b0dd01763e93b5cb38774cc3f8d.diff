[+++ b/spring-context/src/main/java/org/springframework/validation/DefaultBindingErrorProcessor.java, +		error.wrap(ex);, +++ b/spring-context/src/main/java/org/springframework/validation/DefaultBindingErrorProcessor.java, +		error.wrap(ex);, +++ b/spring-context/src/main/java/org/springframework/validation/ObjectError.java, +	 * Preserve the source behind this error: possibly an {@link Exception}, +	public void wrap(Object source) {, +		if (this.source != null) {, +			throw new IllegalStateException("Already wrapping " + this.source);, +		}, +	 * Unwrap the source behind this error: possibly an {@link Exception}, +	 * <p>The cause of the outermost exception will be introspected as well,, +	 * e.g. the underlying conversion exception or exception thrown from a setter, +	 * (instead of having to unwrap the {@code PropertyAccessException} in turn)., +	 * @return the source object of the given type, +	 * @throws IllegalArgumentException if no such source object is available, +	 * (i.e. none specified or not available anymore after deserialization), +	public <T> T unwrap(Class<T> sourceType) {, +		if (sourceType.isInstance(this.source)) {, +			return sourceType.cast(this.source);, +		}, +		else if (this.source instanceof Throwable) {, +			Throwable cause = ((Throwable) this.source).getCause();, +			if (sourceType.isInstance(cause)) {, +				return sourceType.cast(cause);, +			}, +		}, +		throw new IllegalArgumentException("No source object of the given type available: " + sourceType);, +	}, +, +	/**, +	 * Check the source behind this error: possibly an {@link Exception}, +	 * (typically {@link org.springframework.beans.PropertyAccessException}), +	 * or a Bean Validation {@link javax.validation.ConstraintViolation}., +	 * <p>The cause of the outermost exception will be introspected as well,, +	 * e.g. the underlying conversion exception or exception thrown from a setter, +	 * (instead of having to unwrap the {@code PropertyAccessException} in turn)., +	 * @return whether this error has been caused by a source object of the given type, +	 * @since 5.0.4, +	 */, +	public boolean contains(Class<?> sourceType) {, +		return (sourceType.isInstance(this.source) ||, +				(this.source instanceof Throwable && sourceType.isInstance(((Throwable) this.source).getCause())));, +++ b/spring-context/src/main/java/org/springframework/validation/DefaultBindingErrorProcessor.java, +		error.wrap(ex);, +++ b/spring-context/src/main/java/org/springframework/validation/ObjectError.java, +	 * Preserve the source behind this error: possibly an {@link Exception}, +	public void wrap(Object source) {, +		if (this.source != null) {, +			throw new IllegalStateException("Already wrapping " + this.source);, +		}, +	 * Unwrap the source behind this error: possibly an {@link Exception}, +	 * <p>The cause of the outermost exception will be introspected as well,, +	 * e.g. the underlying conversion exception or exception thrown from a setter, +	 * (instead of having to unwrap the {@code PropertyAccessException} in turn)., +	 * @return the source object of the given type, +	 * @throws IllegalArgumentException if no such source object is available, +	 * (i.e. none specified or not available anymore after deserialization), +	public <T> T unwrap(Class<T> sourceType) {, +		if (sourceType.isInstance(this.source)) {, +			return sourceType.cast(this.source);, +		}, +		else if (this.source instanceof Throwable) {, +			Throwable cause = ((Throwable) this.source).getCause();, +			if (sourceType.isInstance(cause)) {, +				return sourceType.cast(cause);, +			}, +		}, +		throw new IllegalArgumentException("No source object of the given type available: " + sourceType);, +	}, +, +	/**, +	 * Check the source behind this error: possibly an {@link Exception}, +	 * (typically {@link org.springframework.beans.PropertyAccessException}), +	 * or a Bean Validation {@link javax.validation.ConstraintViolation}., +	 * <p>The cause of the outermost exception will be introspected as well,, +	 * e.g. the underlying conversion exception or exception thrown from a setter, +	 * (instead of having to unwrap the {@code PropertyAccessException} in turn)., +	 * @return whether this error has been caused by a source object of the given type, +	 * @since 5.0.4, +	 */, +	public boolean contains(Class<?> sourceType) {, +		return (sourceType.isInstance(this.source) ||, +				(this.source instanceof Throwable && sourceType.isInstance(((Throwable) this.source).getCause())));, +++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, +							error.wrap(violation);, +							error.wrap(violation);, +++ b/spring-context/src/main/java/org/springframework/validation/DefaultBindingErrorProcessor.java, +		error.wrap(ex);, +++ b/spring-context/src/main/java/org/springframework/validation/ObjectError.java, +	 * Preserve the source behind this error: possibly an {@link Exception}, +	public void wrap(Object source) {, +		if (this.source != null) {, +			throw new IllegalStateException("Already wrapping " + this.source);, +		}, +	 * Unwrap the source behind this error: possibly an {@link Exception}, +	 * <p>The cause of the outermost exception will be introspected as well,, +	 * e.g. the underlying conversion exception or exception thrown from a setter, +	 * (instead of having to unwrap the {@code PropertyAccessException} in turn)., +	 * @return the source object of the given type]