[+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, + * Copyright 2002-2016 the original author or authors., +	private final Map<String, PreprocessedPattern> tokenizedPatternCache = new ConcurrentHashMap<String, PreprocessedPattern>(256);, +		PreprocessedPattern preprocessedPattern = tokenizePattern(pattern);, +		if (fullMatch && this.caseSensitive && preprocessedPattern.certainlyNotMatch(path)) {, +			return false;, +		}, +		String[] pattDirs = preprocessedPattern.tokenized;, +	protected PreprocessedPattern tokenizePattern(String pattern) {, +		PreprocessedPattern tokenized = null;, +			tokenized = compiledPattern(pattern);, +	private int firstSpecialCharIdx(int specialCharIdx, int prevFoundIdx) {, +		if (specialCharIdx != -1) {, +			return prevFoundIdx == -1 ? specialCharIdx : Math.min(prevFoundIdx, specialCharIdx);, +		}, +		else {, +			return prevFoundIdx;, +		}, +	}, +, +	private PreprocessedPattern compiledPattern(String pattern) {, +		String[] tokenized = tokenizePath(pattern);, +		int specialCharIdx = -1;, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('*'), specialCharIdx);, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('?'), specialCharIdx);, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('{'), specialCharIdx);, +		final String prefix;, +		if (specialCharIdx != -1) {, +			prefix = pattern.substring(0, specialCharIdx);, +		}, +		else {, +			prefix = pattern;, +		}, +		return new PreprocessedPattern(tokenized, prefix.isEmpty() ? null : prefix);, +	}, +, +	private static class PreprocessedPattern {, +		private final String[] tokenized;, +, +		private final String prefix;, +, +		public PreprocessedPattern(String[] tokenized, String prefix) {, +			this.tokenized = tokenized;, +			this.prefix = prefix;, +		}, +, +		private boolean certainlyNotMatch(String path) {, +			return prefix != null && !path.startsWith(prefix);, +		}, +	}, +, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, + * Copyright 2002-2016 the original author or authors., +	private final Map<String, PreprocessedPattern> tokenizedPatternCache = new ConcurrentHashMap<String, PreprocessedPattern>(256);, +		PreprocessedPattern preprocessedPattern = tokenizePattern(pattern);, +		if (fullMatch && this.caseSensitive && preprocessedPattern.certainlyNotMatch(path)) {, +			return false;, +		}, +		String[] pattDirs = preprocessedPattern.tokenized;, +	protected PreprocessedPattern tokenizePattern(String pattern) {, +		PreprocessedPattern tokenized = null;, +			tokenized = compiledPattern(pattern);, +	private int firstSpecialCharIdx(int specialCharIdx, int prevFoundIdx) {, +		if (specialCharIdx != -1) {, +			return prevFoundIdx == -1 ? specialCharIdx : Math.min(prevFoundIdx, specialCharIdx);, +		}, +		else {, +			return prevFoundIdx;, +		}, +	}, +, +	private PreprocessedPattern compiledPattern(String pattern) {, +		String[] tokenized = tokenizePath(pattern);, +		int specialCharIdx = -1;, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('*'), specialCharIdx);, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('?'), specialCharIdx);, +		specialCharIdx = firstSpecialCharIdx(pattern.indexOf('{'), specialCharIdx);, +		final String prefix;, +		if (specialCharIdx != -1) {, +			prefix = pattern.substring(0, specialCharIdx);, +		}, +		else {, +			prefix = pattern;, +		}, +		return new PreprocessedPattern(tokenized, prefix.isEmpty() ? null : prefix);, +	}, +, +	private static class PreprocessedPattern {, +		private final String[] tokenized;, +, +		private final String prefix;, +, +		public PreprocessedPattern(String[] tokenized, String prefix) {, +			this.tokenized = tokenized;, +			this.prefix = prefix;, +		}, +, +		private boolean certainlyNotMatch(String path) {, +			return prefix != null && !path.startsWith(prefix);, +		}]