[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerServerHttpResponse.java, + * Abstract base class for listener-based server responses, e.g. Servlet 3.1, + * and Undertow., + *, +, +, +			Processor<Publisher<DataBuffer>, Void> bodyProcessor = createBodyFlushProcessor();, +		}, +		else {, +, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerServerHttpResponse.java, + * Abstract base class for listener-based server responses, e.g. Servlet 3.1, + * and Undertow., + *, +, +, +			Processor<Publisher<DataBuffer>, Void> bodyProcessor = createBodyFlushProcessor();, +		}, +		else {, +, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, + * @author Violeta Georgieva, +abstract class AbstractResponseBodyFlushProcessor implements Processor<Publisher<DataBuffer>, Void> {, +	private final ResponseBodyWriteResultPublisher resultPublisher = new ResponseBodyWriteResultPublisher();, +	private final AtomicReference<State> state = new AtomicReference<>(State.UNSUBSCRIBED);, +, +, +		this.resultPublisher.subscribe(subscriber);, +, +, +	private boolean changeState(State oldState, State newState) {, +		return this.state.compareAndSet(oldState, newState);, +	private void cancel() {, +		this.subscription.cancel();, +, +, +, +			public void onSubscribe(AbstractResponseBodyFlushProcessor processor, Subscription subscription) {, +, +			public void onNext(AbstractResponseBodyFlushProcessor processor, Publisher<DataBuffer> chunk) {, +					Processor<DataBuffer, Void> chunkProcessor = processor.createBodyProcessor();, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +					processor.resultPublisher.publishComplete();, +, +						processor.resultPublisher.publishComplete();, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +, +			public void onError(AbstractResponseBodyFlushProcessor processor, Throwable t) {, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +		public void onSubscribe(AbstractResponseBodyFlushProcessor processor, Subscription subscription) {, +		public void onNext(AbstractResponseBodyFlushProcessor processor, Publisher<DataBuffer> publisher) {, +		public void onError(AbstractResponseBodyFlushProcessor processor, Throwable ex) {, +				processor.resultPublisher.publishError(ex);, +		public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +, +			public void onSubscribe(Subscription subscription) {, +				subscription.request(Long.MAX_VALUE);, +			public void onError(Throwable ex) {, +				this.processor.cancel();, +				this.processor.onError(ex);, +				this.processor.writeComplete();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerServerHttpResponse.java, + * Abstract base class for listener-based server responses, e.g. Servlet 3.1, + * and Undertow., + *, +, +, +			Processor<Publisher<DataBuffer>, Void> bodyProcessor = createBodyFlushProcessor();, +		}, +		else {, +, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractResponseBodyFlushProcessor.java, + * @author Violeta Georgieva, +abstract class AbstractResponseBodyFlushProcessor implements Processor<Publisher<DataBuffer>, Void> {, +	private final ResponseBodyWriteResultPublisher resultPublisher = new ResponseBodyWriteResultPublisher();, +	private final AtomicReference<State> state = new AtomicReference<>(State.UNSUBSCRIBED);, +, +, +		this.resultPublisher.subscribe(subscriber);, +, +, +	private boolean changeState(State oldState, State newState) {, +		return this.state.compareAndSet(oldState, newState);, +	private void cancel() {, +		this.subscription.cancel();, +, +, +, +			public void onSubscribe(AbstractResponseBodyFlushProcessor processor, Subscription subscription) {, +, +			public void onNext(AbstractResponseBodyFlushProcessor processor, Publisher<DataBuffer> chunk) {, +					Processor<DataBuffer, Void> chunkProcessor = processor.createBodyProcessor();, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +					processor.resultPublisher.publishComplete();, +, +						processor.resultPublisher.publishComplete();, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {, +, +			public void onError(AbstractResponseBodyFlushProcessor processor, Throwable t) {, +			public void onComplete(AbstractResponseBodyFlushProcessor processor) {]