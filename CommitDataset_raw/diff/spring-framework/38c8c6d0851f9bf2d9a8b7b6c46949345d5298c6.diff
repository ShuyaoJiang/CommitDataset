[+++ /dev/null, +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/web/client/AsyncRestOperations.java, +, +, +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +++ /dev/null, +++ b/spring-web/src/main/java/org/springframework/web/client/AsyncRestOperations.java, +, +, +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +	 * @param requestEntity the entity (headers and/or body) to write to the request, +	 * (may be {@code null}), +++ b/spring-web/src/main/java/org/springframework/web/client/AsyncRestTemplate.java, +import java.io.OutputStream;, +import org.springframework.http.client.ClientHttpRequest;, + * <p>For more information, please refer to the {@link RestTemplate} API documentation., +		Assert.notNull(taskExecutor, "AsyncTaskExecutor must not be null");, +	public AsyncRestTemplate(AsyncClientHttpRequestFactory asyncRequestFactory, ClientHttpRequestFactory syncRequestFactory) {, +	public AsyncRestTemplate(AsyncClientHttpRequestFactory requestFactory, RestTemplate restTemplate) {, +, +, +	public <T> Future<ResponseEntity<T>> getForEntity(String url, Class<T> responseType, Object... uriVariables), +			throws RestClientException {, +, +, +	public <T> Future<ResponseEntity<T>> getForEntity(URI url, Class<T> responseType) throws RestClientException {, +	public Future<HttpHeaders> headForHeaders(String url, Object... uriVariables) throws RestClientException {, +	public Future<HttpHeaders> headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {, +	public Future<Set<HttpMethod>> optionsForAllow(String url, Object... uriVariables) throws RestClientException {, +		Future<HttpHeaders> headersFuture = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);, +	public Future<Set<HttpMethod>> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {, +		Future<HttpHeaders> headersFuture = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);, +		Future<HttpHeaders> headersFuture = execute(url, HttpMethod.OPTIONS, null, headersExtractor);, +, +, +	public <T> Future<T> execute(URI url, HttpMethod method,, +			AsyncRequestCallback requestCallback, ResponseExtractor<T> responseExtractor), +			throws RestClientException {, +	protected <T> Future<T> doExecute(URI url, HttpMethod method, AsyncRequestCallback requestCallback,, +			ResponseExtractor<T> responseExtractor) throws RestClientException {, +	private void logResponseStatus(HttpMethod method, URI url, ClientHttpResponse response) {, +	private void handleResponseError(HttpMethod method, URI url, ClientHttpResponse response) throws IOException {, +	protected <T> AsyncRequestCallback acceptHeaderRequestCallback(Class<T> responseType) {, +		return new AsyncRequestCallbackAdapter(this.syncTemplate.acceptHeaderRequestCallback(responseType));, +		return new AsyncRequestCallbackAdapter(this.syncTemplate.httpEntityCallback(requestBody));, +	protected <T> AsyncRequestCallback httpEntityCallback(HttpEntity<T> request, Type responseType) {, +		return new AsyncRequestCallbackAdapter(this.syncTemplate.httpEntityCallback(request, responseType));, +	protected <T> ResponseExtractor<ResponseEntity<T>> responseEntityExtractor(Type responseType) {, +, +		public ResponseFuture(HttpMethod method, URI url, Future<ClientHttpResponse> responseFuture) {, +		public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {, +		public ResponseExtractorFuture(HttpMethod method, URI url, Future<ClientHttpResponse> responseFuture,, +, +		public VoidResponseFuture(HttpMethod method, URI url, Future<ClientHttpResponse> responseFuture) {, +	/**, +	 * Adapts a {@link RequestCallback} to the {@link AsyncRequestCallback} interface., +	 */, +	private static class AsyncRequestCallbackAdapter implements AsyncRequestCallback {, +, +		private final RequestCallback adaptee;, +, +		/**, +		 * Create a new {@code AsyncRequestCallbackAdapter} from the given, +		 * {@link RequestCallback}., +		 * @param requestCallback the callback to base this adapter on, +		 */, +		public AsyncRequestCallbackAdapter(RequestCallback requestCallback) {, +			this.adaptee = requestCallback;, +		}, +, +		@Override, +		public void doWithRequest(final AsyncClientHttpRequest request) throws IOException {, +			if (this.adaptee != null) {, +				this.adaptee.doWithRequest(new ClientHttpRequest() {, +					@Override, +					public ClientHttpResponse execute() throws IOException {, +						throw new UnsupportedOperationException("execute not supported");, +					}, +					@Override, +					public OutputStream getBody() throws IOException {, +						return request.getBody();, +					}, +					@Override, +					public HttpMethod getMethod() {, +						return request.getMethod();, +					}, +					@Override, +					public URI getURI() {, +						return request.getURI();, +					}, +					@Override]