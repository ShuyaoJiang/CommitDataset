[+++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java, + * Copyright 2002-2009 the original author or authors., +import org.springframework.util.ErrorHandler;, + * listener will ever fail. However, if error handling is necessary, then, + * any implementation of the {@link ErrorHandler} strategy may be provided to, + * the {@link #setErrorHandler(ErrorHandler)} method. Note that JMSExceptions, + * <b>will</b> be passed to the ErrorHandler in addition to (but after) being, + * passed to an {@link ExceptionListener}, if one has been provided., +	private ErrorHandler errorHandler;, +, +	 * Set an ErrorHandler to be invoked in case of any uncaught exceptions thrown, +	 * while processing a Message. By default there will be <b>no</b> ErrorHandler, +	 * so that error-level logging is the only result., +	 */, +	public void setErrorHandler(ErrorHandler errorHandler) {, +		this.errorHandler = errorHandler;, +	}, +, +	/**, +			// Invoke ErrorHandler if available., +			invokeErrorHandler(ex);, +	/**, +	 * Invoke the registered ErrorHandler, if any. Log at error level otherwise., +	 * @param ex the uncaught error that arose during JMS processing., +	 * @see #setErrorHandler, +	 */, +	protected void invokeErrorHandler(Throwable ex) {, +		if (this.errorHandler != null) {, +			this.errorHandler.handleError(ex);, +		}, +		else if (logger.isWarnEnabled()) {, +			logger.warn("Execution of JMS message listener failed, and no ErrorHandler has been set.", ex);, +		}, +	}, +, +++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java, + * Copyright 2002-2009 the original author or authors., +import org.springframework.util.ErrorHandler;, + * listener will ever fail. However, if error handling is necessary, then, + * any implementation of the {@link ErrorHandler} strategy may be provided to, + * the {@link #setErrorHandler(ErrorHandler)} method. Note that JMSExceptions, + * <b>will</b> be passed to the ErrorHandler in addition to (but after) being, + * passed to an {@link ExceptionListener}, if one has been provided., +	private ErrorHandler errorHandler;, +, +	 * Set an ErrorHandler to be invoked in case of any uncaught exceptions thrown, +	 * while processing a Message. By default there will be <b>no</b> ErrorHandler, +	 * so that error-level logging is the only result., +	 */, +	public void setErrorHandler(ErrorHandler errorHandler) {, +		this.errorHandler = errorHandler;, +	}, +, +	/**, +			// Invoke ErrorHandler if available., +			invokeErrorHandler(ex);, +	/**, +	 * Invoke the registered ErrorHandler, if any. Log at error level otherwise., +	 * @param ex the uncaught error that arose during JMS processing., +	 * @see #setErrorHandler, +	 */, +	protected void invokeErrorHandler(Throwable ex) {, +		if (this.errorHandler != null) {, +			this.errorHandler.handleError(ex);, +		}, +		else if (logger.isWarnEnabled()) {, +			logger.warn("Execution of JMS message listener failed, and no ErrorHandler has been set.", ex);, +		}, +	}, +, +++ b/org.springframework.jms/src/test/java/org/springframework/jms/listener/SimpleMessageListenerContainerTests.java, + * Copyright 2002-2009 the original author or authors., +import org.easymock.EasyMock;, +import org.springframework.util.ErrorHandler;, + * @author Mark Fisher, +	public void testRegisteredErrorHandlerIsInvokedOnException() throws Exception {, +		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();, +, +		Session session = EasyMock.createMock(Session.class);, +, +		// Queue gets created in order to create MessageConsumer for that Destination..., +		session.createQueue(DESTINATION_NAME);, +		EasyMock.expectLastCall().andReturn(QUEUE_DESTINATION);, +		// and then the MessageConsumer gets created..., +		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector..., +		EasyMock.expectLastCall().andReturn(messageConsumer);, +		// an exception is thrown, so the rollback logic is being applied here..., +		session.getTransacted();, +		EasyMock.expectLastCall().andReturn(false);, +		EasyMock.replay(session);, +, +		Connection connection = EasyMock.createMock(Connection.class);, +		connection.setExceptionListener(this.container);, +		// session gets created in order to register MessageListener..., +		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());, +		EasyMock.expectLastCall().andReturn(session);, +		// and the connection is start()ed after the listener is registered..., +		connection.start();, +		EasyMock.replay(connection);, +]