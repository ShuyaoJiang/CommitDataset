[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicate.java, +import java.util.Optional;, +, +		return new RequestPredicates.AndRequestPredicate(this, other);, +		return new RequestPredicates.OrRequestPredicate(this, other);, +	 * a path-based predicate can return a {@code ServerRequest} with a the path remaining after a, +	 * match., +	 * <p>The default implementation returns an {@code Optional} wrapping the given path if, +	 * {@link #test(ServerRequest)} evaluates to {@code true}; or {@link Optional#empty()} if it, +	 * evaluates to {@code false}., +	default Optional<ServerRequest> nest(ServerRequest request) {, +		return test(request) ? Optional.of(request) : Optional.empty();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicate.java, +import java.util.Optional;, +, +		return new RequestPredicates.AndRequestPredicate(this, other);, +		return new RequestPredicates.OrRequestPredicate(this, other);, +	 * a path-based predicate can return a {@code ServerRequest} with a the path remaining after a, +	 * match., +	 * <p>The default implementation returns an {@code Optional} wrapping the given path if, +	 * {@link #test(ServerRequest)} evaluates to {@code true}; or {@link Optional#empty()} if it, +	 * evaluates to {@code false}., +	default Optional<ServerRequest> nest(ServerRequest request) {, +		return test(request) ? Optional.of(request) : Optional.empty();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java, +import java.util.LinkedHashMap;, +				mergeTemplateVariables(request);, +		public Optional<ServerRequest> nest(ServerRequest request) {, +			String remainingPath = this.pattern.getPathRemaining(request.path());, +			return Optional.ofNullable(remainingPath), +					.map(path -> !path.startsWith("/") ? "/" + path : path), +					.map(path -> {, +						// TODO: re-enable when SPR-15419 has been fixed., +						// mergeTemplateVariables(request);, +						return new SubPathServerRequestWrapper(request, path);, +					});, +, +		private void mergeTemplateVariables(ServerRequest request) {, +			Map<String, String> newVariables = this.pattern.matchAndExtract(request.path());, +			if (!newVariables.isEmpty()) {, +				Map<String, String> oldVariables = request.pathVariables();, +				Map<String, String> variables = new LinkedHashMap<>(oldVariables);, +				variables.putAll(newVariables);, +				request.attributes().put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,, +						Collections.unmodifiableMap(variables));, +	static class AndRequestPredicate implements RequestPredicate {, +, +		private final RequestPredicate left;, +, +		private final RequestPredicate right;, +, +		public AndRequestPredicate(RequestPredicate left, RequestPredicate right) {, +			this.left = left;, +			this.right = right;, +		}, +, +		@Override, +		public boolean test(ServerRequest t) {, +			return this.left.test(t) && this.right.test(t);, +		}, +, +		@Override, +		public Optional<ServerRequest> nest(ServerRequest request) {, +			return this.left.nest(request).flatMap(this.right::nest);, +		}, +, +		@Override, +		public String toString() {, +			return String.format("(%s && %s)", this.left, this.right);, +		}, +	}, +, +	static class OrRequestPredicate implements RequestPredicate {, +, +		private final RequestPredicate left;, +, +		private final RequestPredicate right;, +, +		public OrRequestPredicate(RequestPredicate left, RequestPredicate right) {, +			this.left = left;, +			this.right = right;, +		}, +		@Override, +		public boolean test(ServerRequest t) {, +			return this.left.test(t) || this.right.test(t);, +		}, +, +		@Override, +		public Optional<ServerRequest> nest(ServerRequest request) {, +			Optional<ServerRequest> leftResult = this.left.nest(request);, +			if (leftResult.isPresent()) {, +				return leftResult;, +			}, +			else {, +				return this.right.nest(request);, +			}, +		}, +, +		@Override, +		public String toString() {]