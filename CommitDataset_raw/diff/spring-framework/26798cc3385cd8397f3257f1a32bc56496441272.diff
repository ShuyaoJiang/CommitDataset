[+++ b/src/asciidoc/testing.adoc, +JUnit, Spring also provides a custom JUnit `Runner` and custom JUnit `Rules` that allow, +one to write so-called __POJO test classes__. POJO test classes are not required to, +extend a particular class hierarchy., +from the `spring-test` module and hence does _not_ use a running Servlet container. It, +uses the `DispatcherServlet` to provide full Spring MVC runtime behavior and provides support, +for loading actual Spring configuration with the __TestContext framework__ in addition to a, +standalone mode in which controllers may be instantiated manually and tested one at a time., +the `RestTemplate`. Client-side tests mock the server responses and also do _not_, +use a running server., +For more information on the differences between out-of-container and end-to-end, +integration tests, see <<spring-mvc-test-vs-end-to-end-integration-tests>>., +The goal of __Spring MVC Test__ is to provide an effective way for testing controllers, +by performing requests and generating responses through the actual `DispatcherServlet`., +for loading Spring configuration from an XML configuration file located in the same package, +as the test class, but Java-based and Groovy-based configuration are also supported. See these, +The `MockMvc` instance is used to perform a `GET` request to `"/accounts/1"` and verify, +that the resulting response has status 200, the content type is `"application/json"`, and the, +response body has a JSON property called "name" with the value "Lee". The `jsonPath`, +into the test to use to build a `MockMvc` instance:, +request parameters provided through the `param(...)` method are expected to already be decoded., +`MockMvcResultMatchers.*` provides a number of expectations, some of which are further, +Expectations fall in two general categories. The first category of assertions verifies, +properties of the response: for example, the response status, headers, and content. These, +The second category of assertions goes beyond the response. These assertions allow, +one to inspect Spring MVC specific aspects such as which controller method processed, +the request, whether an exception was raised and handled, what the content of the model, +is, what view was selected, what flash attributes were added, and so on. They also allow, +one to inspect Servlet specific aspects such as request and session attributes., +, +The following test asserts that binding or validation failed:, +a `log()` method and two additional variants of the `print()` method, one that accepts, +cannot be verified otherwise. This can be achieved by appending `.andReturn()` after all, +other expectations:, +If all tests repeat the same expectations you can set up common expectations once, +Note that common expectations are __always__ applied and cannot be overridden without, +be verified using JsonPath expressions:, +be verified using XPath expressions:, +When setting up a `MockMvc` instance, you can register one or more Servlet `Filter` instances:, +Registered filters will be invoked through via the `MockFilterChain` from `spring-test`, and the, +last filter will delegate to the `DispatcherServlet`., +===== Differences between Out-of-Container and End-to-End Integration Tests, +the `spring-test` module and does not use a running Servlet container. Therefore, +Whatever you add to it is what the request will be. Things that may catch you by surprise, +are that there is no context path by default, no `jsessionid` cookie, no forwarding, error,, +or async dispatches, and therefore no actual JSP rendering. Instead, "forwarded" and, +"redirected" URLs are saved in the `MockHttpServletResponse` and can be asserted with, +expectations., +forwarded, but there won't be any HTML rendered. In other words, the JSP will not be, +_invoked_. Note however that all other rendering technologies which don't rely on, +forwarding such as Thymeleaf, Freemarker, and Velocity will render HTML to the response, +body as expected. The same is true for rendering JSON, XML, and other formats via, +`@ResponseBody` methods., +There are pros and cons for each approach. The options provided in __Spring MVC Test__, +are different stops on the scale from classic unit testing to full integration testing., +To be certain, none of the options in Spring MVC Test fall under the category of classic, +unit testing, but they _are_ a little closer to it. For example, you can isolate the web, +layer by injecting mocked services into controllers, in which case you're testing the web, +layer only through the `DispatcherServlet` but with actual Spring configuration, just, +like you might test the data access layer in isolation from the layers above. Or you, +can use the standalone setup focusing on one controller at a time and manually providing, +the configuration required to make it work., +tests are on the _inside_ of the server-side so you can check what handler was used,, +an actual HTTP client. This is generally an advantage of classic unit testing, that it's, +integration tests. At the same time it's important not to lose sight of the fact that, +the response is the most important thing to check. In short, there is room here for, +multiple styles and strategies of testing even within the same project.]