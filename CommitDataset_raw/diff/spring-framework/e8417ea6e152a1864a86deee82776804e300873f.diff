[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SimpAnnotationMethodMessageHandler.java, +	private static final boolean completableFuturePresent = ClassUtils.isPresent(, +			"java.util.concurrent.CompletableFuture", SimpAnnotationMethodMessageHandler.class.getClassLoader());, +		ConfigurableBeanFactory beanFactory = (getApplicationContext() instanceof ConfigurableApplicationContext ?, +						((ConfigurableApplicationContext) getApplicationContext()).getBeanFactory() : null);, +		SendToMethodReturnValueHandler sth =, +				new SendToMethodReturnValueHandler(this.brokerTemplate, true);, +		SubscriptionMethodReturnValueHandler sh =, +				new SubscriptionMethodReturnValueHandler(this.clientMessagingTemplate);, +		Set<String> patterns = mapping.getDestinationConditions().getPatterns();, +		if (!CollectionUtils.isEmpty(patterns)) {, +			String pattern = patterns.iterator().next();, +			Map<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, lookupDestination);, +				MessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +				Assert.state(mha != null && mha.isMutable());, +				mha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);, +			}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/SimpAnnotationMethodMessageHandler.java, +	private static final boolean completableFuturePresent = ClassUtils.isPresent(, +			"java.util.concurrent.CompletableFuture", SimpAnnotationMethodMessageHandler.class.getClassLoader());, +		ConfigurableBeanFactory beanFactory = (getApplicationContext() instanceof ConfigurableApplicationContext ?, +						((ConfigurableApplicationContext) getApplicationContext()).getBeanFactory() : null);, +		SendToMethodReturnValueHandler sth =, +				new SendToMethodReturnValueHandler(this.brokerTemplate, true);, +		SubscriptionMethodReturnValueHandler sh =, +				new SubscriptionMethodReturnValueHandler(this.clientMessagingTemplate);, +		Set<String> patterns = mapping.getDestinationConditions().getPatterns();, +		if (!CollectionUtils.isEmpty(patterns)) {, +			String pattern = patterns.iterator().next();, +			Map<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, lookupDestination);, +				MessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +				Assert.state(mha != null && mha.isMutable());, +				mha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);, +			}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/MessageHeaderAccessor.java, +			if (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||, +					MessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {, +	 * @return an accessor instance of the specified type, or {@code null} if none, +	public static <T extends MessageHeaderAccessor> T getAccessor(, +			MessageHeaders messageHeaders, Class<T> requiredType) {, +, +	 * @return an accessor of the required type (never {@code null})]