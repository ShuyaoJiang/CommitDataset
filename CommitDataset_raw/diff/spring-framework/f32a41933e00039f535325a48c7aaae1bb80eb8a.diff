[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +		/**, +		 * Sub-classes can invoke this before sending a message (false) and, +		 * after receiving the async send callback (true) effective translating, +		 * async completion callback into simple flow control., +		 */, +		public void setReadyToSend(boolean ready) {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +		/**, +		 * Sub-classes can invoke this before sending a message (false) and, +		 * after receiving the async send callback (true) effective translating, +		 * async completion callback into simple flow control., +		 */, +		public void setReadyToSend(boolean ready) {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketHandlerAdapter.java, +, +import org.springframework.core.io.buffer.DataBuffer;, +, +	private final WebSocketHandler delegate;, +	private JettyWebSocketSession session;, +, +	public JettyWebSocketHandlerAdapter(WebSocketHandler delegate) {, +		Assert.notNull("WebSocketHandler is required");, +		this.delegate = delegate;, +, +		this.session = new JettyWebSocketSession(session);, +		HandlerResultSubscriber subscriber = new HandlerResultSubscriber();, +		this.delegate.handle(this.session).subscribe(subscriber);, +		if (this.session != null) {, +			WebSocketMessage webSocketMessage = toMessage(Type.TEXT, message);, +			this.session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +			ByteBuffer buffer = ByteBuffer.wrap(message, offset, length);, +			WebSocketMessage webSocketMessage = toMessage(Type.BINARY, buffer);, +			session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +				ByteBuffer buffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);, +				WebSocketMessage webSocketMessage = toMessage(Type.PONG, buffer);, +				session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +			this.session.handleClose(new CloseStatus(statusCode, reason));, +		if (this.session != null) {, +			this.session.handleError(cause);, +			byte[] bytes = ((String) message).getBytes(StandardCharsets.UTF_8);, +			DataBuffer buffer = this.bufferFactory.wrap(bytes);, +			return WebSocketMessage.create(Type.TEXT, buffer);, +			DataBuffer buffer = this.bufferFactory.wrap((ByteBuffer) message);, +			return WebSocketMessage.create(Type.BINARY, buffer);, +			DataBuffer buffer = this.bufferFactory.wrap((ByteBuffer) message);, +			return WebSocketMessage.create(Type.PONG, buffer);, +, +			if (session != null) {, +				session.close(new CloseStatus(CloseStatus.SERVER_ERROR.getCode(), ex.getMessage()));, +			if (session != null) {, +				session.close();, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +		/**, +		 * Sub-classes can invoke this before sending a message (false) and, +		 * after receiving the async send callback (true) effective translating, +		 * async completion callback into simple flow control., +		 */, +		public void setReadyToSend(boolean ready) {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketHandlerAdapter.java, +, +import org.springframework.core.io.buffer.DataBuffer;, +, +	private final WebSocketHandler delegate;, +	private JettyWebSocketSession session;, +, +	public JettyWebSocketHandlerAdapter(WebSocketHandler delegate) {, +		Assert.notNull("WebSocketHandler is required");, +		this.delegate = delegate;, +, +		this.session = new JettyWebSocketSession(session);, +		HandlerResultSubscriber subscriber = new HandlerResultSubscriber();, +		this.delegate.handle(this.session).subscribe(subscriber);, +		if (this.session != null) {, +			WebSocketMessage webSocketMessage = toMessage(Type.TEXT, message);, +			this.session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +			ByteBuffer buffer = ByteBuffer.wrap(message, offset, length);, +			WebSocketMessage webSocketMessage = toMessage(Type.BINARY, buffer);, +			session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +				ByteBuffer buffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);, +				WebSocketMessage webSocketMessage = toMessage(Type.PONG, buffer);, +				session.handleMessage(webSocketMessage.getType(), webSocketMessage);, +		if (this.session != null) {, +			this.session.handleClose(new CloseStatus(statusCode, reason));, +		if (this.session != null) {, +			this.session.handleError(cause);, +			byte[] bytes = ((String) message).getBytes(StandardCharsets.UTF_8);, +			DataBuffer buffer = this.bufferFactory.wrap(bytes);, +			return WebSocketMessage.create(Type.TEXT, buffer);, +			DataBuffer buffer = this.bufferFactory.wrap((ByteBuffer) message);, +			return WebSocketMessage.create(Type.BINARY, buffer);, +			DataBuffer buffer = this.bufferFactory.wrap((ByteBuffer) message);, +			return WebSocketMessage.create(Type.PONG, buffer);, +, +			if (session != null) {]