[+++ b/org.springframework.context/src/main/java/org/springframework/context/annotation/Bean.java, + * Copyright 2002-2011 the original author or authors., + * to those of the {@code <bean/>} element in the Spring XML schema. For example:, + * <pre class="code">, + *     &#064;Bean, + *     public MyBean myBean() {, + *         // instantiate and configure MyBean obj, + *         return obj;, + *     }</pre>, + * <pre class="code">, + *     &#064;Bean(name={"b1","b2"}) // bean available as 'b1' and 'b2', but not 'myBean', + *     public MyBean myBean() {, + *         // instantiate and configure MyBean obj, + *         return obj;, + *     }</pre>, + * <p>Note that the {@code @Bean} annotation does not provide attributes for scope,, + * primary or lazy. Rather, it should be used in conjunction with {@link Scope @Scope},, + * {@link Primary @Primary}, and {@link Lazy @Lazy} annotations to achieve, + * those semantics. For example:, + * <pre class="code">, + *     &#064;Bean, + *     &#064;Scope("prototype"), + *     public MyBean myBean() {, + *         // instantiate and configure MyBean obj, + *         return obj;, + *     }</pre>, + *, + * <p>Typically, {@code @Bean} methods are declared within {@code @Configuration}, + * classes. In this case, bean methods may reference other <code>@Bean</code> methods, + * on the same class by calling them <i>directly</i>. This ensures that references between, + * beans are strongly typed and navigable. Such so-called 'inter-bean references' are, + * guaranteed to respect scoping and AOP semantics, just like <code>getBean</code> lookups, + * would. These are the semantics known from the original 'Spring JavaConfig' project, + * which require CGLIB subclassing of each such configuration class at runtime. As a, + * consequence, {@code @Configuration} classes and their factory methods must not be, + * marked as final or private in this mode. For example:, + * <pre class="code">, + * &#064;Configuration, + * public class AppConfig {, + *     &#064;Bean, + *     public FooService fooService() {, + *         return new FooService(fooRepository());, + *     }, + *     &#064;Bean, + *     public FooRepository fooRepository() {, + *         return new JdbcFooRepository(dataSource());, + *     }, + *     // ..., + * }</pre>, + *, + * <p>{@code @Bean} methods may also be declared wihtin any {@code @Component} class, in, + * which case they will get processed in a configuration class 'lite' mode in which, + * {@code factory-method} declarations in XML). The containing component classes remain, + * unmodified in this case, and there are no unusual constraints for factory methods,, + * however, scoping semantics are not respected as described above for inter-bean method, + * invocations in this mode. For example:, + * <pre class="code">, + * &#064;Component, + * public class Calculator {, + *     public int sum(int a, int b) {, + *         return a+b;, + *     }, + *     &#064;Bean, + *     public MyBean myBean() {, + *         return new MyBean();, + *     }, + * }</pre>, + *, + * <p>See @{@link Configuration} Javadoc for further details including how to bootstrap, + * the container using {@link AnnotationConfigApplicationContext} and friends., + * @see org.springframework.stereotype.Component, +	 * within the body of a Bean-annotated method. Default value is {@code ""}, indicating, +	 * that no init method should be called.]