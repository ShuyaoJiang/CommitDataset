[+++ b/org.springframework.oxm/src/main/java/org/springframework/oxm/jibx/JibxMarshaller.java, +import javax.xml.transform.Result;, +import javax.xml.transform.Source;, +import org.springframework.util.ClassUtils;, +	private Class<?> targetClass;, +	private String docTypeRootElementName;, +, +	private String docTypeSystemId;, +, +	private String docTypePublicId;, +, +	private String docTypeInternalSubset;, +, +	public void setTargetClass(Class<?> targetClass) {, +	/**, +	 * Sets the root element name for the DTD declaration written when marshalling. By default, this is, +	 * {@code null} (i.e. no DTD declaration is written). If set to a value, the system ID or public ID also need to, +	 * be set., +	 *, +	 * @see #setDocTypeSystemId(String), +	 * @see #setDocTypePublicId(String), +	 */, +	public void setDocTypeRootElementName(String docTypeRootElementName) {, +		this.docTypeRootElementName = docTypeRootElementName;, +	}, +, +	/**, +	 * Sets the system Id for the DTD declaration written when marshalling. By default, this is, +	 * {@code null}. Only used when the root element also has been set. Set either this property or, +	 * {@code docTypePublicId}, not both., +	 *, +	 * @see #setDocTypeRootElementName(String), +	 */, +	public void setDocTypeSystemId(String docTypeSystemId) {, +		this.docTypeSystemId = docTypeSystemId;, +	}, +, +	/**, +	 * Sets the public Id for the DTD declaration written when marshalling. By default, this is, +	 * {@code null}. Only used when the root element also has been set. Set either this property or, +	 * {@code docTypeSystemId}, not both., +	 *, +	 * @see #setDocTypeRootElementName(String), +	 */, +	public void setDocTypePublicId(String docTypePublicId) {, +		this.docTypePublicId = docTypePublicId;, +	}, +, +	/**, +	 * Sets the internal subset Id for the DTD declaration written when marshalling. By default, this is, +	 * {@code null}. Only used when the root element also has been set., +	 *, +	 * @see #setDocTypeRootElementName(String), +	 */, +	public void setDocTypeInternalSubset(String docTypeInternalSubset) {, +		this.docTypeInternalSubset = docTypeInternalSubset;, +	}, +		Assert.notNull(this.targetClass, "'targetClass' is required");, +		Assert.isTrue(!(StringUtils.hasLength(docTypePublicId) && StringUtils.hasLength(docTypeSystemId)),, +				"Set either 'docTypePublicId' or 'docTypeSystemId'; not both");, +			marshallingContext.startDocument(this.encoding, this.standalone, outputStream);, +			marshalDocument(marshallingContext, graph);, +			marshallingContext.startDocument(this.encoding, this.standalone, writer);, +			marshalDocument(marshallingContext, graph);, +	private void marshalDocument(IMarshallingContext marshallingContext, Object graph) throws IOException,, +			JiBXException {, +		if (StringUtils.hasLength(docTypeRootElementName)) {, +			IXMLWriter xmlWriter = marshallingContext.getXmlWriter();, +			xmlWriter.writeDocType(docTypeRootElementName, docTypeSystemId, docTypePublicId, docTypeInternalSubset);, +		}, +		marshallingContext.marshalDocument(graph);, +	}, +, +			Result result = new DOMResult(node);, +			transformAndMarshal(graph, result);, +		catch (IOException ex) {, +			SAXResult saxResult = new SAXResult(contentHandler);, +			saxResult.setLexicalHandler(lexicalHandler);, +			transformAndMarshal(graph, saxResult);, +		}, +		catch (IOException ex) {, +			throw new MarshallingFailureException("JiBX marshalling exception", ex);, +		}, +	}, +, +	private void transformAndMarshal(Object graph, Result result) throws IOException {, +		try {, +			transformer.transform(new StreamSource(is), result);, +		catch (TransformerException ex) {, +			throw new MarshallingFailureException(, +					"Could not transform to [" + ClassUtils.getShortName(result.getClass()) + "]");, +, +			return transformAndUnmarshal(new DOMSource(node));, +		catch (IOException ex) {, +		return transformAndUnmarshal(new SAXSource(xmlReader, inputSource));, +	}, +, +	private Object transformAndUnmarshal(Source source) throws IOException {, +			Transformer transformer = transformerFactory.newTransformer();, +			transformer.transform(source, new StreamResult(os));]