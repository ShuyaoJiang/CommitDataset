[+++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +import org.springframework.core.annotation.AnnotationUtils;, +	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels, +	 * of meta-annotations., +	 * Obtain the annotation of the specified {@code annotationType} that is, +	 * on this type descriptor., +	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels, +	 * of meta-annotations., +		// Search in annotations that are "present" (i.e., locally declared or inherited), +		//, +		// NOTE: this unfortunately favors inherited annotations over locally declared composed annotations., +, +		// Search in annotation hierarchy, +		for (Annotation composedAnnotation : getAnnotations()) {, +			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType);, +++ b/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +import org.springframework.core.annotation.AnnotationUtils;, +	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels, +	 * of meta-annotations., +	 * Obtain the annotation of the specified {@code annotationType} that is, +	 * on this type descriptor., +	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels, +	 * of meta-annotations., +		// Search in annotations that are "present" (i.e., locally declared or inherited), +		//, +		// NOTE: this unfortunately favors inherited annotations over locally declared composed annotations., +, +		// Search in annotation hierarchy, +		for (Annotation composedAnnotation : getAnnotations()) {, +			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType);, +++ b/spring-core/src/test/java/org/springframework/core/convert/TypeDescriptorTests.java, + * Copyright 2002-2015 the original author or authors., +import java.lang.annotation.Annotation;, + * @author Sam Brannen, +, +	@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE }), +	}, +	@MethodAnnotation1, +	@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE }), +	@Retention(RetentionPolicy.RUNTIME), +	public @interface ComposedMethodAnnotation1 {}, +, +	@ComposedMethodAnnotation1, +	@Target(ElementType.METHOD), +	@Retention(RetentionPolicy.RUNTIME), +	public @interface ComposedComposedMethodAnnotation1 {}, +, +	@MethodAnnotation1, +	public void methodWithLocalAnnotation() {}, +, +	@ComposedMethodAnnotation1, +	public void methodWithComposedAnnotation() {}, +, +	@ComposedComposedMethodAnnotation1, +	public void methodWithComposedComposedAnnotation() {}, +, +	private void assertAnnotationFoundOnMethod(Class<? extends Annotation> annotationType, String methodName) throws Exception {, +		TypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(getClass().getMethod(methodName), -1));, +		assertNotNull("Should have found @" + annotationType.getSimpleName() + " on " + methodName + ".",, +			typeDescriptor.getAnnotation(annotationType));, +	}, +, +	@Test, +	public void getAnnotationOnMethodThatIsLocallyAnnotated() throws Exception {, +		assertAnnotationFoundOnMethod(MethodAnnotation1.class, "methodWithLocalAnnotation");, +	}, +, +	@Test, +	public void getAnnotationOnMethodThatIsMetaAnnotated() throws Exception {, +		assertAnnotationFoundOnMethod(MethodAnnotation1.class, "methodWithComposedAnnotation");, +	}, +, +	@Test, +	public void getAnnotationOnMethodThatIsMetaMetaAnnotated() throws Exception {, +		assertAnnotationFoundOnMethod(MethodAnnotation1.class, "methodWithComposedComposedAnnotation");]