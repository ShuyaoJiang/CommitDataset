[+++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/RouterTests.java, +		public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType,, +				MediaType mediaType,, +		public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Flux<Object> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +		public Mono<Object> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/RouterTests.java, +		public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType,, +				MediaType mediaType,, +		public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Flux<Object> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +		public Mono<Object> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		return this.decoder != null && this.decoder.canDecode(elementType, mediaType, hints);, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decode(inputMessage.getBody(), elementType, contentType, hints);, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decodeToMono(inputMessage.getBody(), elementType, contentType, hints);, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/RouterTests.java, +		public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType,, +				MediaType mediaType,, +		public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Flux<Object> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +		public Mono<Object> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		return this.decoder != null && this.decoder.canDecode(elementType, mediaType, hints);, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decode(inputMessage.getBody(), elementType, contentType, hints);, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decodeToMono(inputMessage.getBody(), elementType, contentType, hints);, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +	public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		return this.encoder != null && this.encoder.canEncode(elementType, mediaType, hints);, +	public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,, +			MediaType mediaType, ReactiveHttpOutputMessage outputMessage,, +			MediaType contentTypeToUse = mediaType;, +			if (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {, +				contentTypeToUse = getDefaultContentType(elementType);, +			else if (MediaType.APPLICATION_OCTET_STREAM.equals(mediaType)) {, +				MediaType contentType = getDefaultContentType(elementType);, +				contentTypeToUse = (contentType != null ? contentType : contentTypeToUse);, +					MediaType contentType = getDefaultContentType(elementType);, +					if (contentType != null && contentType.getCharset() != null) {, +						contentTypeToUse = new MediaType(contentTypeToUse, contentType.getCharset());, +		Flux<DataBuffer> body = this.encoder.encode(inputStream, bufferFactory, elementType, mediaType, hints);, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/RouterTests.java, +		public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Mono<Void> write(Publisher<?> inputStream, ResolvableType elementType,, +				MediaType mediaType,, +		public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		public Flux<Object> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +		public Mono<Object> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage,, +++ b/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java, +	public boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		return this.decoder != null && this.decoder.canDecode(elementType, mediaType, hints);, +	public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decode(inputMessage.getBody(), elementType, contentType, hints);, +	public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {, +		return this.decoder.decodeToMono(inputMessage.getBody(), elementType, contentType, hints);, +++ b/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java, +	public boolean canWrite(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints) {, +		return this.encoder != null && this.encoder.canEncode(elementType, mediaType, hints);, +	public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,, +			MediaType mediaType, ReactiveHttpOutputMessage outputMessage,, +			MediaType contentTypeToUse = mediaType;, +			if (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {, +				contentTypeToUse = getDefaultContentType(elementType);, +			else if (MediaType.APPLICATION_OCTET_STREAM.equals(mediaType)) {, +				MediaType contentType = getDefaultContentType(elementType);, +				contentTypeToUse = (contentType != null ? contentType : contentTypeToUse);, +					MediaType contentType = getDefaultContentType(elementType);, +					if (contentType != null && contentType.getCharset() != null) {, +						contentTypeToUse = new MediaType(contentTypeToUse, contentType.getCharset());, +		Flux<DataBuffer> body = this.encoder.encode(inputStream, bufferFactory, elementType, mediaType, hints);, +++ b/spring-web/src/main/java/org/springframework/http/codec/HttpMessageReader.java, +	 * @param elementType the stream element type to test for readability, +	boolean canRead(ResolvableType elementType, MediaType mediaType, Map<String, Object> hints);, +	 * @param elementType the stream element type to return. This type must have previously been, +	Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints);, +	 * @param elementType the stream element type to return. This type must have previously been, +	Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints);, +++ b/spring-core/src/main/java/org/springframework/core/codec/Decoder.java, +++ b/spring-core/src/main/java/org/springframework/core/codec/Encoder.java, +++ b/spring-web-reactive/src/test/java/org/springframework/web/reactive/function/RouterTests.java]