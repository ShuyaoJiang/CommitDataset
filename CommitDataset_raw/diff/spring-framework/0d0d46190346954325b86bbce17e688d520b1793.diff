[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/NettyWebSocketSessionSupport.java, +import org.springframework.core.io.buffer.DataBuffer;, +	/**, +	 * The default max size for aggregating inbound WebSocket frames., +	 */, +	protected static final int DEFAULT_FRAME_MAX_SIZE = 64 * 1024;, +, +, +	protected WebSocketMessage toMessage(WebSocketFrame frame) {, +		DataBuffer payload = bufferFactory().wrap(frame.content());, +		return new WebSocketMessage(MESSAGE_TYPES.get(frame.getClass()), payload);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/NettyWebSocketSessionSupport.java, +import org.springframework.core.io.buffer.DataBuffer;, +	/**, +	 * The default max size for aggregating inbound WebSocket frames., +	 */, +	protected static final int DEFAULT_FRAME_MAX_SIZE = 64 * 1024;, +, +, +	protected WebSocketMessage toMessage(WebSocketFrame frame) {, +		DataBuffer payload = bufferFactory().wrap(frame.content());, +		return new WebSocketMessage(MESSAGE_TYPES.get(frame.getClass()), payload);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/ReactorNettyWebSocketSession.java, +import reactor.ipc.netty.http.websocket.WebsocketInbound;, +import reactor.ipc.netty.http.websocket.WebsocketOutbound;, +	public ReactorNettyWebSocketSession(WebsocketInbound inbound, WebsocketOutbound outbound,, +		return getDelegate().getInbound(), +				.aggregateFrames(DEFAULT_FRAME_MAX_SIZE), +				.receiveFrames(), +				.map(super::toMessage);, +		Flux<WebSocketFrame> frames = Flux.from(messages).map(this::toFrame);, +		return getDelegate().getOutbound(), +				.options(NettyPipeline.SendOptions::flushOnEach), +				.sendObject(frames), +		private final WebsocketInbound inbound;, +		private final WebsocketOutbound outbound;, +		public WebSocketConnection(WebsocketInbound inbound, WebsocketOutbound outbound) {, +		public WebsocketInbound getInbound() {, +		public WebsocketOutbound getOutbound() {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/NettyWebSocketSessionSupport.java, +import org.springframework.core.io.buffer.DataBuffer;, +	/**, +	 * The default max size for aggregating inbound WebSocket frames., +	 */, +	protected static final int DEFAULT_FRAME_MAX_SIZE = 64 * 1024;, +, +, +	protected WebSocketMessage toMessage(WebSocketFrame frame) {, +		DataBuffer payload = bufferFactory().wrap(frame.content());, +		return new WebSocketMessage(MESSAGE_TYPES.get(frame.getClass()), payload);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/ReactorNettyWebSocketSession.java, +import reactor.ipc.netty.http.websocket.WebsocketInbound;, +import reactor.ipc.netty.http.websocket.WebsocketOutbound;, +	public ReactorNettyWebSocketSession(WebsocketInbound inbound, WebsocketOutbound outbound,, +		return getDelegate().getInbound(), +				.aggregateFrames(DEFAULT_FRAME_MAX_SIZE), +				.receiveFrames(), +				.map(super::toMessage);, +		Flux<WebSocketFrame> frames = Flux.from(messages).map(this::toFrame);, +		return getDelegate().getOutbound(), +				.options(NettyPipeline.SendOptions::flushOnEach), +				.sendObject(frames), +		private final WebsocketInbound inbound;, +		private final WebsocketOutbound outbound;, +		public WebSocketConnection(WebsocketInbound inbound, WebsocketOutbound outbound) {, +		public WebsocketInbound getInbound() {, +		public WebsocketOutbound getOutbound() {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/RxNettyWebSocketSession.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;, +import org.springframework.util.Assert;, +	/**, +	 * The name of the {@link WebSocketFrameAggregator} inserted by, +	 * {@link #aggregateFrames(Channel, String)}., +	 */, +	public static final String FRAME_AGGREGATOR_NAME = "websocket-frame-aggregator";, +, +	/**, +	 * Inserts an {@link WebSocketFrameAggregator} after the, +	 * {@code WebSocketFrameDecoder} for receiving full messages., +	 * @param channel the channel for the session, +	 * @param frameDecoderName the name of the WebSocketFrame decoder, +	 */, +	public RxNettyWebSocketSession aggregateFrames(Channel channel, String frameDecoderName) {, +		ChannelPipeline pipeline = channel.pipeline();, +		if (pipeline.context(FRAME_AGGREGATOR_NAME) != null) {, +			logger.trace("WebSocketFrameAggregator already registered.");, +			return this;, +		}, +		ChannelHandlerContext context = pipeline.context(frameDecoderName);, +		Assert.notNull(context, "WebSocketFrameDecoder not found: " + frameDecoderName);, +		WebSocketFrameAggregator aggregator = new WebSocketFrameAggregator(DEFAULT_FRAME_MAX_SIZE);, +		pipeline.addAfter(context.name(), FRAME_AGGREGATOR_NAME, aggregator);, +		return this;, +	}, +, +, +		Observable<WebSocketMessage> observable = getDelegate().getInput().map(super::toMessage);]