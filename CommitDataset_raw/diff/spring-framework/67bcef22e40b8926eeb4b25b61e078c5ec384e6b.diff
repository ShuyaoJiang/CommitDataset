[+++ b/spring-test/src/main/java/org/springframework/mock/http/server/reactive/MockServerHttpRequest.java, +import java.util.Optional;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import org.springframework.util.MimeType;, + * Mock extension of {@link AbstractServerHttpRequest} for use in tests without, + * an actual server., + * <p>Use the static builder methods in this class to create an instance possibly, + * further creating a {@link MockServerWebExchange} via {@link #toExchange()}., +		B cookie(String name, HttpCookie... cookie);, +		private static final DataBufferFactory BUFFER_FACTORY = new DefaultDataBufferFactory();, +, +, +		public BodyBuilder cookie(String name, HttpCookie... cookies) {, +			this.cookies.put(name, Arrays.asList(cookies));, +, +		@Override, +		public MockServerHttpRequest body(String body) {, +			return body(Flux.just(BUFFER_FACTORY.wrap(body.getBytes(getCharset()))));, +		}, +, +		private Charset getCharset() {, +			return Optional.ofNullable(this.headers.getContentType()), +					.map(MimeType::getCharset).orElse(StandardCharsets.UTF_8);, +		}, +, +		@Override, +		public MockServerHttpRequest body(Publisher<? extends DataBuffer> body) {, +			return new MockServerHttpRequest(this.method, this.url, this.contextPath,, +					this.headers, this.cookies, this.remoteAddress, body);, +		}, +++ b/spring-test/src/main/java/org/springframework/mock/http/server/reactive/MockServerHttpRequest.java, +import java.util.Optional;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import org.springframework.util.MimeType;, + * Mock extension of {@link AbstractServerHttpRequest} for use in tests without, + * an actual server., + * <p>Use the static builder methods in this class to create an instance possibly, + * further creating a {@link MockServerWebExchange} via {@link #toExchange()}., +		B cookie(String name, HttpCookie... cookie);, +		private static final DataBufferFactory BUFFER_FACTORY = new DefaultDataBufferFactory();, +, +, +		public BodyBuilder cookie(String name, HttpCookie... cookies) {, +			this.cookies.put(name, Arrays.asList(cookies));, +, +		@Override, +		public MockServerHttpRequest body(String body) {, +			return body(Flux.just(BUFFER_FACTORY.wrap(body.getBytes(getCharset()))));, +		}, +, +		private Charset getCharset() {, +			return Optional.ofNullable(this.headers.getContentType()), +					.map(MimeType::getCharset).orElse(StandardCharsets.UTF_8);, +		}, +, +		@Override, +		public MockServerHttpRequest body(Publisher<? extends DataBuffer> body) {, +			return new MockServerHttpRequest(this.method, this.url, this.contextPath,, +					this.headers, this.cookies, this.remoteAddress, body);, +		}, +++ b/spring-test/src/main/java/org/springframework/mock/http/server/reactive/MockServerHttpResponse.java, + * Copyright 2002-2017 the original author or authors., +import java.util.Optional;, +import org.springframework.util.MimeType;, + * Mock extension of {@link AbstractServerHttpResponse} for use in tests without, + * an actual server., + *, + * <p>By default response content is consumed in full upon writing and cached, + * for subsequent access, however it is also possible to set a custom, + * {@link #setWriteHandler(Function) writeHandler}., + *, +	private Flux<DataBuffer> body = Flux.error(new IllegalStateException(, +			"No content was written nor was setComplete() called on this response."));, +	private Function<Flux<DataBuffer>, Mono<Void>> writeHandler;, +		this.writeHandler = body -> {, +	 * Configure a custom handler to consume the response body., +	 * <p>By default, response body content is consumed in full and cached for, +	 * subsequent access in tests. Use this option to take control over how the, +	 * response body is consumed., +		this.body = Flux.error(new IllegalStateException("Not available with custom write handler."));, +, +	protected Mono<Void> writeAndFlushWithInternal(, +			Publisher<? extends Publisher<? extends DataBuffer>> body) {, +, +	/**, +	 * Return the response body or an error stream if the body was not set., +	 */, +	public Flux<DataBuffer> getBody() {, +		return this.body;, +	}, +, +	/**, +	 * Aggregate response data and convert to a String using the "Content-Type", +	 * charset or "UTF-8" by default., +	 */, +	public Mono<String> getBodyAsString() {, +, +		Charset charset = Optional.ofNullable(getHeaders().getContentType()).map(MimeType::getCharset), +				.orElse(StandardCharsets.UTF_8);, +]