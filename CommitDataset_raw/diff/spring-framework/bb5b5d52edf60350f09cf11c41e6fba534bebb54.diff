[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	final Set<String> skippedBeanMethods = new HashSet<String>();, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	final Set<String> skippedBeanMethods = new HashSet<String>();, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +		String methodName = metadata.getMethodName();, +, +		// Do we need to mark the bean as skipped by its condition?, +		if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {, +			configClass.skippedBeanMethods.add(methodName);, +			return;, +		}, +		if (configClass.skippedBeanMethods.contains(methodName)) {, +			return;, +		}, +		String beanName = (names.size() > 0 ? names.remove(0) : methodName);, +			beanDef.setFactoryMethodName(methodName);, +			beanDef.setUniqueFactoryMethodName(methodName);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	final Set<String> skippedBeanMethods = new HashSet<String>();, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +		String methodName = metadata.getMethodName();, +, +		// Do we need to mark the bean as skipped by its condition?, +		if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {, +			configClass.skippedBeanMethods.add(methodName);, +			return;, +		}, +		if (configClass.skippedBeanMethods.contains(methodName)) {, +			return;, +		}, +		String beanName = (names.size() > 0 ? names.remove(0) : methodName);, +			beanDef.setFactoryMethodName(methodName);, +			beanDef.setUniqueFactoryMethodName(methodName);, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassWithConditionTests.java, +import java.util.Map;, +		Map<String, ExampleBean> beans = context.getBeansOfType(ExampleBean.class);, +		assertEquals(1, beans.size());, +		assertEquals("baz", beans.keySet().iterator().next());, +	}, +, +	@Test, +	public void configWithAlternativeBeans() {, +		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigWithAlternativeBeans.class);, +		Map<String, ExampleBean> beans = context.getBeansOfType(ExampleBean.class);, +		assertEquals(1, beans.size());, +		assertEquals("baz", beans.keySet().iterator().next());, +	static class AlwaysCondition implements Condition {, +, +		@Override, +		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {, +			return true;, +		}, +	}, +, +	static class ConfigWithBeanActive {, +	static class ConfigWithBeanSkipped extends ConfigWithBeanActive {, +	static class ConfigWithBeanReactivated extends ConfigWithBeanSkipped {, +	@Configuration, +	static class ConfigWithAlternativeBeans {, +, +		@Bean(name = "baz"), +		@Conditional(AlwaysCondition.class), +		public ExampleBean baz1() {, +			return new ExampleBean();, +		}, +, +		@Bean(name = "baz"), +		@Conditional(NeverCondition.class), +		public ExampleBean baz2() {, +			return new ExampleBean();, +		}, +	}, +]