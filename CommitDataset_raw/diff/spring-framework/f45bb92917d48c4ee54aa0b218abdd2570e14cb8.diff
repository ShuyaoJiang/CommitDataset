[+++ b/spring-framework-reference/src/validation.xml, +      and Spring offers a design for validation (and data binding) that does not, +      exclude either one of them. Specifically validation should not be tied to, +      the web tier, should be easy to localize and it should be possible to plug, +      in any validator available. Considering the above, Spring has come up with, +      a <interfacename>Validator</interfacename> interface that is both basic, +      ands eminently usable in every layer of an application. </para>, +    <para>Data binding is useful for allowing user input to be dynamically bound, +      to the domain model of an application (or whatever objects you use to, +      process user input). Spring provides the so-called, +      <interfacename>DataBinder</interfacename> make up the, +      <literal>validation</literal> package, which is primarily used in but not, +      limited to the MVC framework. </para>, +    <para>The <interfacename>BeanWrapper</interfacename> is a fundamental, +      concept in the Spring Framework and is used in a lot of places. However,, +      you probably will not have the need to use the, +      <interfacename>BeanWrapper</interfacename> directly. Because this is, +      reference documentation however, we felt that some explanation might be in, +      order. We will explain the <interfacename>BeanWrapper</interfacename> in, +      this chapter since, if you were going to use it at all, you would most, +      likely do so when trying to bind data to objects.</para>, +    <para>Spring's DataBinder and the lower-level BeanWrapper both use, +      PropertyEditors to parse and format property values. The, +      <interfacename>PropertyEditor</interfacename> concept is part of the, +      JavaBeans specification, and is also explained in this chapter. Spring 3, +      introduces a "core.convert" package that provides a general type, +      conversion facility, as well as a higher-level "format" package for, +      formatting UI field values. These new packages may be used as simpler, +      alternatives to PropertyEditors, and will also be discussed in this, +      chapter.</para>, +    <title>Validation using Spring's <interfacename>Validator</interfacename>, +      interface</title>, +, +    <para>Spring features a <interfacename>Validator</interfacename> interface, +      that you can use to validate objects. The, +      <interfacename>Validator</interfacename> interface works using an, +      <interfacename>Errors</interfacename> object so that while validating,, +      validators can report validation failures to the, +      <interfacename>Errors</interfacename> object.</para>, +, +, +, +    <para>We're going to provide validation behavior for the, +      <classname>Person</classname> class by implementing the following two, +      methods of the, +      <interfacename>org.springframework.validation.Validator</interfacename>, +      interface: <itemizedlist spacing="compact">, +          <interfacename>Validator</interfacename> validate instances of the, +          supplied <classname>Class</classname>?</para>, +        <para><methodname>validate(Object,, +          org.springframework.validation.Errors)</methodname> - validates the, +          given object and in case of validation errors, registers those with, +          the given <interfacename>Errors</interfacename> object</para>, +      </itemizedlist> </para>, +, +    <para> Implementing a <interfacename>Validator</interfacename> is fairly, +      straightforward, especially when you know of the, +      <classname>ValidationUtils</classname> helper class that the Spring, +      Framework also provides.</para>, +, +, +    <para>As you can see, the <literal>static</literal>, +      <methodname>rejectIfEmpty(..)</methodname> method on the, +      <classname>ValidationUtils</classname> class is used to reject the, +      <literal>'name'</literal> property if it is <literal>null</literal> or the, +      empty string. Have a look at the Javadoc for the, +      <classname>ValidationUtils</classname> class to see what functionality it, +      provides besides the example shown previously.</para>, +, +      <interfacename>Validator</interfacename> class to validate each of the, +      nested objects in a rich object, it may be better to encapsulate the, +      validation logic for each nested class of object in its own, +      <interfacename>Validator</interfacename> implementation. A simple example, +      of a <emphasis>'rich'</emphasis> object would be a, +      <classname>Customer</classname> that is composed of two, +      <classname>String</classname> properties (a first and second name) and a, +      complex <classname>Address</classname> object., +      <classname>AddressValidator</classname> has been implemented. If you want, +      your <classname>CustomerValidator</classname> to reuse the logic contained, +      within the <classname>AddressValidator</classname> class without resorting, +      to copy-and-paste, you can dependency-inject or instantiate an, +      <classname>AddressValidator</classname> within your, +      <classname>CustomerValidator</classname>, and use it like so:</para>, +, +, +    <para>Validation errors are reported to the, +      <interfacename>Errors</interfacename> object passed to the validator. In, +      case of Spring Web MVC you can use <literal>&lt;spring:bind/&gt;</literal>, +      tag to inspect the error messages, but of course you can also inspect the, +      errors object yourself. More information about the methods it offers can, +      be found from the Javadoc.</para>, +, +, +    <para>We've talked about databinding and validation. Outputting messages, +      corresponding to validation errors is the last thing we need to discuss., +      In the example we've shown above, we rejected the <literal>name</literal>, +      and the <literal>age</literal> field. If we're going to output the error, +      messages by using a <interfacename>MessageSource</interfacename>, we will, +      do so using the error code we've given when rejecting the field ('name', +      and 'age' in this case). When you call (either directly, or indirectly,]