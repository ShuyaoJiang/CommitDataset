[+++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapper.java, + * Copyright 2002-2016 the original author or authors., +	 * Specify a limit for array and collection auto-growing., +	 * <p>Default is unlimited on a plain BeanWrapper., +	 * @since 4.1, +	 */, +	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);, +, +	/**, +	 * Return the limit for array and collection auto-growing., +	 * @since 4.1, +	 */, +	int getAutoGrowCollectionLimit();, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapper.java, + * Copyright 2002-2016 the original author or authors., +	 * Specify a limit for array and collection auto-growing., +	 * <p>Default is unlimited on a plain BeanWrapper., +	 * @since 4.1, +	 */, +	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);, +, +	/**, +	 * Return the limit for array and collection auto-growing., +	 * @since 4.1, +	 */, +	int getAutoGrowCollectionLimit();, +, +	/**, +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SpringBeanJobFactory.java, + * Copyright 2002-2016 the original author or authors., +		if (isEligibleForPropertyPopulation(job)) {, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapper.java, + * Copyright 2002-2016 the original author or authors., +	 * Specify a limit for array and collection auto-growing., +	 * <p>Default is unlimited on a plain BeanWrapper., +	 * @since 4.1, +	 */, +	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);, +, +	/**, +	 * Return the limit for array and collection auto-growing., +	 * @since 4.1, +	 */, +	int getAutoGrowCollectionLimit();, +, +	/**, +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SpringBeanJobFactory.java, + * Copyright 2002-2016 the original author or authors., +		if (isEligibleForPropertyPopulation(job)) {, +++ b/spring-context/src/main/java/org/springframework/scheduling/config/ExecutorBeanDefinitionParser.java, + * Copyright 2002-2016 the original author or authors., +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapper.java, + * Copyright 2002-2016 the original author or authors., +	 * Specify a limit for array and collection auto-growing., +	 * <p>Default is unlimited on a plain BeanWrapper., +	 * @since 4.1, +	 */, +	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);, +, +	/**, +	 * Return the limit for array and collection auto-growing., +	 * @since 4.1, +	 */, +	int getAutoGrowCollectionLimit();, +, +	/**, +++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SpringBeanJobFactory.java, + * Copyright 2002-2016 the original author or authors., +		if (isEligibleForPropertyPopulation(job)) {, +++ b/spring-context/src/main/java/org/springframework/scheduling/config/ExecutorBeanDefinitionParser.java, + * Copyright 2002-2016 the original author or authors., +++ b/spring-context/src/main/java/org/springframework/scheduling/config/TaskExecutorFactoryBean.java, + * Copyright 2002-2016 the original author or authors., +import java.util.concurrent.RejectedExecutionHandler;, +, + * {@link FactoryBean} for creating {@link ThreadPoolTaskExecutor} instances,, + * primarily used behind the XML task namespace., +	private RejectedExecutionHandler rejectedExecutionHandler;, +	private ThreadPoolTaskExecutor target;, +	public void setRejectedExecutionHandler(RejectedExecutionHandler rejectedExecutionHandler) {, +	public void afterPropertiesSet() {, +		this.target = new ThreadPoolTaskExecutor();, +		determinePoolSizeRange();, +			this.target.setQueueCapacity(this.queueCapacity);, +			this.target.setKeepAliveSeconds(this.keepAliveSeconds);, +			this.target.setRejectedExecutionHandler(this.rejectedExecutionHandler);, +			this.target.setThreadNamePrefix(this.beanName + "-");, +		this.target.afterPropertiesSet();, +	private void determinePoolSizeRange() {, +						// No queue-capacity provided, so unbounded, +							// Actually set 'corePoolSize' to the upper bound of the range, +							// but allow core threads to timeout..., +							this.target.setAllowCoreThreadTimeOut(true);, +							// Non-zero lower bound implies a core-max size range..., +				this.target.setCorePoolSize(corePoolSize);, +				this.target.setMaxPoolSize(maxPoolSize);, +	public void destroy() {, +		this.target.destroy();]