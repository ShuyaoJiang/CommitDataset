[+++ b/build.gradle, +		if (project.name in ["spring",, +++ b/build.gradle, +		if (project.name in ["spring",, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2012 the original author or authors., +import java.util.HashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new HashMap<Method, AsyncTaskExecutor>();, +		this.setExecutor(defaultExecutor);, +		if (!this.executors.containsKey(method)) {, +			Executor executor = this.defaultExecutor;, +				Assert.notNull(this.beanFactory,, +						"BeanFactory must be set on " + this.getClass().getSimpleName() +, +						" to access qualified executor [" + qualifier + "]");, +				executor = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			if (executor instanceof AsyncTaskExecutor) {, +				this.executors.put(method, (AsyncTaskExecutor) executor);, +			else if (executor != null) {, +				this.executors.put(method, new TaskExecutorAdapter(executor));, +		}, +		return this.executors.get(method);, +++ b/build.gradle, +		if (project.name in ["spring",, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2012 the original author or authors., +import java.util.HashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new HashMap<Method, AsyncTaskExecutor>();, +		this.setExecutor(defaultExecutor);, +		if (!this.executors.containsKey(method)) {, +			Executor executor = this.defaultExecutor;, +				Assert.notNull(this.beanFactory,, +						"BeanFactory must be set on " + this.getClass().getSimpleName() +, +						" to access qualified executor [" + qualifier + "]");, +				executor = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			if (executor instanceof AsyncTaskExecutor) {, +				this.executors.put(method, (AsyncTaskExecutor) executor);, +			else if (executor != null) {, +				this.executors.put(method, new TaskExecutorAdapter(executor));, +		}, +		return this.executors.get(method);, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2012 the original author or authors., +, +		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(, +	 * {@inheritDoc}, +	 * <p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may, +	 * override to provide support for extracting qualifier information, e.g. via an, +	 * annotation on the given method., +++ b/build.gradle, +		if (project.name in ["spring",, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java, + * Copyright 2002-2012 the original author or authors., +import java.util.HashMap;, +	private final Map<Method, AsyncTaskExecutor> executors = new HashMap<Method, AsyncTaskExecutor>();, +		this.setExecutor(defaultExecutor);, +		if (!this.executors.containsKey(method)) {, +			Executor executor = this.defaultExecutor;, +				Assert.notNull(this.beanFactory,, +						"BeanFactory must be set on " + this.getClass().getSimpleName() +, +						" to access qualified executor [" + qualifier + "]");, +				executor = BeanFactoryAnnotationUtils.qualifiedBeanOfType(, +			if (executor instanceof AsyncTaskExecutor) {, +				this.executors.put(method, (AsyncTaskExecutor) executor);, +			else if (executor != null) {, +				this.executors.put(method, new TaskExecutorAdapter(executor));, +		}, +		return this.executors.get(method);, +++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java, + * Copyright 2002-2012 the original author or authors., +, +		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(, +	 * {@inheritDoc}, +	 * <p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may, +	 * override to provide support for extracting qualifier information, e.g. via an, +	 * annotation on the given method., +++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj, +import java.lang.reflect.Method;, +, +	 * Construct object using the given transaction metadata retrieval strategy., +	 * transaction metadata for each joinpoint. Write the subclass to pass in null, +	 * if it's intended to be configured by Setter Injection., +	before(Object txObject) : transactionalMethodExecution(txObject) {, +		Method method = methodSignature.getMethod();, +		createTransactionIfNecessary(method, txObject.getClass());, +	}, +, +	@SuppressAjWarnings("adviceDidNotMatch"), +	after(Object txObject) throwing(Throwable t) : transactionalMethodExecution(txObject) {, +      		completeTransactionAfterThrowing(TransactionAspectSupport.currentTransactionInfo(), t);, +		catch (Throwable t2) {, +			logger.error("Failed to close transaction after throwing in a transactional method", t2);, +, +	@SuppressAjWarnings("adviceDidNotMatch"), +	after(Object txObject) returning() : transactionalMethodExecution(txObject) {, +		commitTransactionAfterReturning(TransactionAspectSupport.currentTransactionInfo());, +, +	@SuppressAjWarnings("adviceDidNotMatch"), +	after(Object txObject) : transactionalMethodExecution(txObject) {, +		cleanupTransactionInfo(TransactionAspectSupport.currentTransactionInfo());, +++ b/build.gradle]