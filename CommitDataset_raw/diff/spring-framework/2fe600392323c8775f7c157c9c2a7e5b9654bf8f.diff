[+++ b/org.springframework.context/src/main/java/org/springframework/ui/format/support/GenericFormatterRegistry.java, +	private final Map<Class<?>, FormatterHolder> typeFormatters = new ConcurrentHashMap<Class<?>, FormatterHolder>();, +	private final Map<Class<?>, AnnotationFormatterFactoryHolder> annotationFormatters = new ConcurrentHashMap<Class<?>, AnnotationFormatterFactoryHolder>();, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		if (formatterObjectType == null) {, +		this.typeFormatters.put(formatterObjectType, new FormatterHolder(formatterObjectType, formatter));, +	}, +, +	public void addFormatterByType(Class<?> type, Formatter<?> formatter) {, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		if (formatterObjectType != null && !type.isAssignableFrom(formatterObjectType)) {, +			if (this.conversionService == null) {, +				throw new IllegalStateException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert from a [" + formatterObjectType.getName(), +						+ "] parsed by the Formatter to [" + type.getName(), +						+ "] because this.conversionService is null");, +			}, +			if (!this.conversionService.canConvert(formatterObjectType, type)) {, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert from a [" + formatterObjectType.getName(), +						+ "] parsed by the Formatter to [" + type.getName() + "]");, +			}, +			if (!this.conversionService.canConvert(type, formatterObjectType)) {, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert to [" + formatterObjectType.getName(), +						+ "] to format a [" + type.getName() + "]");, +			}, +		}, +		this.typeFormatters.put(type, new FormatterHolder(formatterObjectType, formatter));, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +				new AnnotationFormatterFactoryHolder(formatterObjectType, factory));, +		Class<?>[] typeArgs = GenericTypeResolver.resolveTypeArguments(factory.getClass(),, +		Class<?> objectType = type.getObjectType();, +			holder = findFormatterHolderForType(objectType);, +			holder = getDefaultFormatterHolder(objectType);, +		Class<?> formatterObjectType = holder.getFormatterObjectType();, +		if (formatterObjectType != null && !objectType.isAssignableFrom(formatterObjectType)) {, +				Formatter<?> formatter = createFormatter(formattedAnnotation.value());, +	private FormatterHolder findFormatterHolderForType(Class<?> type) {, +		LinkedList<Class<?>> classQueue = new LinkedList<Class<?>>();, +			Class<?> currentClass = classQueue.removeLast();, +			Class<?>[] interfaces = currentClass.getInterfaces();, +			for (Class<?> ifc : interfaces) {, +	private FormatterHolder getDefaultFormatterHolder(Class<?> type) {, +			Formatter<?> formatter = createFormatter(formatted.value());, +	private Formatter<?> createFormatter(Class<? extends Formatter> formatterClass) {, +		private Class<?> formatterObjectType;, +		public AbstractFormatterHolder(Class<?> formatterObjectType) {, +			this.formatterObjectType = formatterObjectType;, +		public Class<?> getFormatterObjectType() {, +			return formatterObjectType;, +		public FormatterHolder(Class<?> formatterObjectType, Formatter<?> formatter) {, +			super(formatterObjectType);, +		public AnnotationFormatterFactoryHolder(Class<?> formatterObjectType, AnnotationFormatterFactory<?, ?> factory) {, +			super(formatterObjectType);, +			return new FormatterHolder(getFormatterObjectType(), this.factory.getFormatter(annotation));, +		public SimpleAnnotationFormatterFactory(Formatter<?> instance) {, +					.getFormatterObjectType());, +					.valueOf(this.formatterHolder.getFormatterObjectType()), this.type);, +++ b/org.springframework.context/src/main/java/org/springframework/ui/format/support/GenericFormatterRegistry.java, +	private final Map<Class<?>, FormatterHolder> typeFormatters = new ConcurrentHashMap<Class<?>, FormatterHolder>();, +	private final Map<Class<?>, AnnotationFormatterFactoryHolder> annotationFormatters = new ConcurrentHashMap<Class<?>, AnnotationFormatterFactoryHolder>();, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		if (formatterObjectType == null) {, +		this.typeFormatters.put(formatterObjectType, new FormatterHolder(formatterObjectType, formatter));, +	}, +, +	public void addFormatterByType(Class<?> type, Formatter<?> formatter) {, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		if (formatterObjectType != null && !type.isAssignableFrom(formatterObjectType)) {, +			if (this.conversionService == null) {, +				throw new IllegalStateException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert from a [" + formatterObjectType.getName(), +						+ "] parsed by the Formatter to [" + type.getName(), +						+ "] because this.conversionService is null");, +			}, +			if (!this.conversionService.canConvert(formatterObjectType, type)) {, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert from a [" + formatterObjectType.getName(), +						+ "] parsed by the Formatter to [" + type.getName() + "]");, +			}, +			if (!this.conversionService.canConvert(type, formatterObjectType)) {, +				throw new IllegalArgumentException("Unable to index Formatter " + formatter + " under type [", +						+ type.getName() + "]; not able to convert to [" + formatterObjectType.getName(), +						+ "] to format a [" + type.getName() + "]");, +			}, +		}, +		this.typeFormatters.put(type, new FormatterHolder(formatterObjectType, formatter));, +		Class<?> formatterObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +				new AnnotationFormatterFactoryHolder(formatterObjectType, factory));, +		Class<?>[] typeArgs = GenericTypeResolver.resolveTypeArguments(factory.getClass(),, +		Class<?> objectType = type.getObjectType();, +			holder = findFormatterHolderForType(objectType);, +			holder = getDefaultFormatterHolder(objectType);, +		Class<?> formatterObjectType = holder.getFormatterObjectType();, +		if (formatterObjectType != null && !objectType.isAssignableFrom(formatterObjectType)) {, +				Formatter<?> formatter = createFormatter(formattedAnnotation.value());, +	private FormatterHolder findFormatterHolderForType(Class<?> type) {, +		LinkedList<Class<?>> classQueue = new LinkedList<Class<?>>();, +			Class<?> currentClass = classQueue.removeLast();]