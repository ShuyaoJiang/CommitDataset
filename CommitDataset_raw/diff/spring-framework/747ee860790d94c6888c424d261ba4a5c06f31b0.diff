[+++ b/org.springframework.core/src/main/java/org/springframework/core/CollectionFactory.java, +	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {, +		return new LinkedHashSet<T>(initialCapacity);, +	public static <T> Set<T> createCopyOnWriteSet() {, +		return new CopyOnWriteArraySet<T>();, +	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {, +		return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {, +			return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createIdentityMapIfPossible(int initialCapacity) {, +		return new IdentityHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createConcurrentMapIfPossible(int initialCapacity) {, +		return new ConcurrentHashMap<K,V>(initialCapacity);, +	public static <K,V> ConcurrentMap<K,V> createConcurrentMap(int initialCapacity) {, +		return new JdkConcurrentHashMap<K,V>(initialCapacity);, +	@SuppressWarnings("unchecked"), +	public static <K,V> Map<K,V> createApproximateMap(Object map, int initialCapacity) {, +			return new TreeMap<K,V>(((SortedMap<K,V>) map).comparator());, +			return new LinkedHashMap<K,V>(initialCapacity);, +		@SuppressWarnings("unchecked"), +		private static <K,V> Map<K,V> createListOrderedCaseInsensitiveMap(int initialCapacity) {, +	private static class JdkConcurrentHashMap<K,V> extends ConcurrentHashMap<K,V> implements ConcurrentMap<K,V> {, +		private JdkConcurrentHashMap(int initialCapacity) {, +++ b/org.springframework.core/src/main/java/org/springframework/core/CollectionFactory.java, +	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {, +		return new LinkedHashSet<T>(initialCapacity);, +	public static <T> Set<T> createCopyOnWriteSet() {, +		return new CopyOnWriteArraySet<T>();, +	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {, +		return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {, +			return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createIdentityMapIfPossible(int initialCapacity) {, +		return new IdentityHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createConcurrentMapIfPossible(int initialCapacity) {, +		return new ConcurrentHashMap<K,V>(initialCapacity);, +	public static <K,V> ConcurrentMap<K,V> createConcurrentMap(int initialCapacity) {, +		return new JdkConcurrentHashMap<K,V>(initialCapacity);, +	@SuppressWarnings("unchecked"), +	public static <K,V> Map<K,V> createApproximateMap(Object map, int initialCapacity) {, +			return new TreeMap<K,V>(((SortedMap<K,V>) map).comparator());, +			return new LinkedHashMap<K,V>(initialCapacity);, +		@SuppressWarnings("unchecked"), +		private static <K,V> Map<K,V> createListOrderedCaseInsensitiveMap(int initialCapacity) {, +	private static class JdkConcurrentHashMap<K,V> extends ConcurrentHashMap<K,V> implements ConcurrentMap<K,V> {, +		private JdkConcurrentHashMap(int initialCapacity) {, +++ b/org.springframework.core/src/main/java/org/springframework/core/ConcurrentMap.java, +public interface ConcurrentMap<K,V> extends Map<K,V> {, +	V putIfAbsent(K key, V value);, +	boolean replace(K key, V oldValue, V newValue);, +	V replace(K key, V value);, +++ b/org.springframework.core/src/main/java/org/springframework/core/CollectionFactory.java, +	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {, +		return new LinkedHashSet<T>(initialCapacity);, +	public static <T> Set<T> createCopyOnWriteSet() {, +		return new CopyOnWriteArraySet<T>();, +	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {, +		return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {, +			return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createIdentityMapIfPossible(int initialCapacity) {, +		return new IdentityHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createConcurrentMapIfPossible(int initialCapacity) {, +		return new ConcurrentHashMap<K,V>(initialCapacity);, +	public static <K,V> ConcurrentMap<K,V> createConcurrentMap(int initialCapacity) {, +		return new JdkConcurrentHashMap<K,V>(initialCapacity);, +	@SuppressWarnings("unchecked"), +	public static <K,V> Map<K,V> createApproximateMap(Object map, int initialCapacity) {, +			return new TreeMap<K,V>(((SortedMap<K,V>) map).comparator());, +			return new LinkedHashMap<K,V>(initialCapacity);, +		@SuppressWarnings("unchecked"), +		private static <K,V> Map<K,V> createListOrderedCaseInsensitiveMap(int initialCapacity) {, +	private static class JdkConcurrentHashMap<K,V> extends ConcurrentHashMap<K,V> implements ConcurrentMap<K,V> {, +		private JdkConcurrentHashMap(int initialCapacity) {, +++ b/org.springframework.core/src/main/java/org/springframework/core/ConcurrentMap.java, +public interface ConcurrentMap<K,V> extends Map<K,V> {, +	V putIfAbsent(K key, V value);, +	boolean replace(K key, V oldValue, V newValue);, +	V replace(K key, V value);, +++ b/org.springframework.jdbc/src/main/java/org/springframework/jdbc/core/ColumnMapRowMapper.java, +		return CollectionFactory.createLinkedCaseInsensitiveMapIfPossible(columnCount);, +++ b/org.springframework.core/src/main/java/org/springframework/core/CollectionFactory.java, +	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {, +		return new LinkedHashSet<T>(initialCapacity);, +	public static <T> Set<T> createCopyOnWriteSet() {, +		return new CopyOnWriteArraySet<T>();, +	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {, +		return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {, +			return new LinkedHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createIdentityMapIfPossible(int initialCapacity) {, +		return new IdentityHashMap<K,V>(initialCapacity);, +	public static <K,V> Map<K,V> createConcurrentMapIfPossible(int initialCapacity) {, +		return new ConcurrentHashMap<K,V>(initialCapacity);, +	public static <K,V> ConcurrentMap<K,V> createConcurrentMap(int initialCapacity) {, +		return new JdkConcurrentHashMap<K,V>(initialCapacity);, +	@SuppressWarnings("unchecked"), +	public static <K,V> Map<K,V> createApproximateMap(Object map, int initialCapacity) {, +			return new TreeMap<K,V>(((SortedMap<K,V>) map).comparator());, +			return new LinkedHashMap<K,V>(initialCapacity);]