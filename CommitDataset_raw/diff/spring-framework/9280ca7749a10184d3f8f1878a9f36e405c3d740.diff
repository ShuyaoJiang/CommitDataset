[+++ b/spring-core/src/main/java/org/springframework/asm/ClassWriter.java, +        // ยง4.7.6 of the JVMS states "Every CONSTANT_Class_info entry in the, +        // constant_pool table which represents a class or interface C that is, +        // not a package member must have exactly one corresponding entry in the, +        // classes array". To avoid duplicates we keep track in the intVal field, +        // of the Item of each CONSTANT_Class_info entry C whether an inner, +        // class entry has already been added for C (this field is unused for, +        // class entries, and changing its value does not change the hashcode, +        // and equality tests). If so we store the index of this inner class, +        // entry (plus one) in intVal. This hack allows duplicate detection in, +        // O(1) time., +        Item nameItem = newClassItem(name);, +        if (nameItem.intVal == 0) {, +            innerClasses.putShort(nameItem.index);, +            nameItem.intVal = innerClassesCount;, +        } else {, +            // Compare the inner classes entry nameItem.intVal - 1 with the, +            // arguments of this method and throw an exception if there is a, +            // difference?, +        }, +++ b/spring-core/src/main/java/org/springframework/asm/ClassWriter.java, +        // ยง4.7.6 of the JVMS states "Every CONSTANT_Class_info entry in the, +        // constant_pool table which represents a class or interface C that is, +        // not a package member must have exactly one corresponding entry in the, +        // classes array". To avoid duplicates we keep track in the intVal field, +        // of the Item of each CONSTANT_Class_info entry C whether an inner, +        // class entry has already been added for C (this field is unused for, +        // class entries, and changing its value does not change the hashcode, +        // and equality tests). If so we store the index of this inner class, +        // entry (plus one) in intVal. This hack allows duplicate detection in, +        // O(1) time., +        Item nameItem = newClassItem(name);, +        if (nameItem.intVal == 0) {, +            innerClasses.putShort(nameItem.index);, +            nameItem.intVal = innerClassesCount;, +        } else {, +            // Compare the inner classes entry nameItem.intVal - 1 with the, +            // arguments of this method and throw an exception if there is a, +            // difference?, +        }, +++ b/spring-core/src/main/java/org/springframework/asm/MethodWriter.java, +        if (resize) {, +            // replaces the temporary jump opcodes introduced by Label.resolve., +            if (ClassReader.RESIZE) {, +                resizeInstructions();, +            } else {, +                throw new RuntimeException("Method code too large!");, +            }, +        }, +        // updates the stack map frame labels, +                 * Detects the labels that are just after an IF instruction that, +                 * has been resized with the IFNOT GOTO_W pattern. These labels, +                 * are now the target of a jump instruction (the IFNOT, +                 * instruction). Note that we need the original label position, +                 * here. getNewOffset must therefore never have been called for, +                 * this label., +                if (u >= 0 && resize[u]) {, +                    l.status |= Label.TARGET;, +                getNewOffset(allIndexes, allSizes, l);, +            // Update the offsets in the uninitialized types, +            for (i = 0; i < cw.typeTable.length; ++i) {, +                Item item = cw.typeTable[i];, +                if (item != null && item.type == ClassWriter.TYPE_UNINIT) {, +                    item.intVal = getNewOffset(allIndexes, allSizes, 0,, +                            item.intVal);, +                }, +            }, +            // The stack map frames are not serialized yet, so we don't need, +            // to update them. They will be serialized in visitMaxs., +        } else if (frameCount > 0) {, +             * Resizing an existing stack map frame table is really hard. Not, +             * only the table must be parsed to update the offets, but new, +             * frames may be needed for jump instructions that were inserted by, +             * this method. And updating the offsets or inserting frames can, +             * change the format of the following frames, in case of packed, +             * frames. In practice the whole table must be recomputed. For this, +             * the frames are marked as potentially invalid. This will cause the, +             * whole class to be reread and rewritten with the COMPUTE_FRAMES, +             * option (see the ClassWriter.toByteArray method). This is not very, +             * efficient but is much easier and requires much less code than any, +             * other method I can think of.]