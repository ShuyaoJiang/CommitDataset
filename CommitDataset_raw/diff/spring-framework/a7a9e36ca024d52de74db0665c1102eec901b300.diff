[+++ b/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageWriter.java, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.List;, +import org.springframework.core.io.support.ResourceRegion;, +import org.springframework.http.HttpRange;, +import org.springframework.http.HttpStatus;, +import org.springframework.http.server.reactive.ServerHttpRequest;, +import org.springframework.http.server.reactive.ServerHttpResponse;, +import org.springframework.util.MimeTypeUtils;, +import org.springframework.web.server.ResponseStatusException;, + * @author Brian Clozel, +public class ResourceHttpMessageWriter extends AbstractServerHttpMessageWriter<Resource> {, +, +	public static final String HTTP_RANGE_REQUEST_HINT = ResourceHttpMessageWriter.class.getName() + ".httpRange";, +, +	private ResourceRegionHttpMessageWriter resourceRegionHttpMessageWriter;, +		super(new EncoderHttpMessageWriter<>(new ResourceEncoder()));, +		this.resourceRegionHttpMessageWriter = new ResourceRegionHttpMessageWriter();, +		super(new EncoderHttpMessageWriter<>(new ResourceEncoder(bufferSize)));, +		this.resourceRegionHttpMessageWriter = new ResourceRegionHttpMessageWriter(bufferSize);, +	@Override, +	protected Map<String, Object> beforeWrite(ResolvableType streamType, ResolvableType elementType,, +			MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {, +		try {, +			List<HttpRange> httpRanges = request.getHeaders().getRange();, +			if (!httpRanges.isEmpty()) {, +				response.setStatusCode(HttpStatus.PARTIAL_CONTENT);, +				return Collections.singletonMap(ResourceHttpMessageWriter.HTTP_RANGE_REQUEST_HINT, httpRanges);, +			}, +		}, +		catch (IllegalArgumentException ex) {, +			throw new ResponseStatusException(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE,, +					"Could not parse Range request header", ex);, +		}, +		return Collections.emptyMap();, +	}, +	@Override, +	@SuppressWarnings("unchecked"), +	public Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType streamType,, +			ResolvableType elementType, MediaType mediaType, ServerHttpRequest request,, +			ServerHttpResponse response, Map<String, Object> hints) {, +, +		Map<String, Object> mergedHints = new HashMap<>(hints);, +		mergedHints.putAll(beforeWrite(streamType, elementType, mediaType, request, response));, +		if (mergedHints.containsKey(HTTP_RANGE_REQUEST_HINT)) {, +			List<HttpRange> httpRanges = (List<HttpRange>) mergedHints.get(HTTP_RANGE_REQUEST_HINT);, +			if (httpRanges.size() > 1) {, +				final String boundary = MimeTypeUtils.generateMultipartBoundaryString();, +				mergedHints.put(ResourceRegionHttpMessageWriter.BOUNDARY_STRING_HINT, boundary);, +			}, +			Flux<ResourceRegion> regions = Flux.from(inputStream), +					.flatMap(resource -> Flux.fromIterable(HttpRange.toResourceRegions(httpRanges, resource)));, +, +			return this.resourceRegionHttpMessageWriter, +					.write(regions, ResolvableType.forClass(ResourceRegion.class), mediaType, response, mergedHints);, +		}, +		else {, +			return write(inputStream, elementType, mediaType, response, mergedHints);, +		}, +	}, +, +	private Mono<Void> writeContent(Resource resource, ResolvableType type,, +			ReactiveHttpOutputMessage outputMessage, Map<String, Object> hints) {, +++ b/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageWriter.java, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.List;, +import org.springframework.core.io.support.ResourceRegion;, +import org.springframework.http.HttpRange;, +import org.springframework.http.HttpStatus;, +import org.springframework.http.server.reactive.ServerHttpRequest;, +import org.springframework.http.server.reactive.ServerHttpResponse;, +import org.springframework.util.MimeTypeUtils;, +import org.springframework.web.server.ResponseStatusException;, + * @author Brian Clozel, +public class ResourceHttpMessageWriter extends AbstractServerHttpMessageWriter<Resource> {, +, +	public static final String HTTP_RANGE_REQUEST_HINT = ResourceHttpMessageWriter.class.getName() + ".httpRange";, +, +	private ResourceRegionHttpMessageWriter resourceRegionHttpMessageWriter;, +		super(new EncoderHttpMessageWriter<>(new ResourceEncoder()));, +		this.resourceRegionHttpMessageWriter = new ResourceRegionHttpMessageWriter();, +		super(new EncoderHttpMessageWriter<>(new ResourceEncoder(bufferSize)));, +		this.resourceRegionHttpMessageWriter = new ResourceRegionHttpMessageWriter(bufferSize);, +	@Override, +	protected Map<String, Object> beforeWrite(ResolvableType streamType, ResolvableType elementType,, +			MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {, +		try {, +			List<HttpRange> httpRanges = request.getHeaders().getRange();, +			if (!httpRanges.isEmpty()) {, +				response.setStatusCode(HttpStatus.PARTIAL_CONTENT);, +				return Collections.singletonMap(ResourceHttpMessageWriter.HTTP_RANGE_REQUEST_HINT, httpRanges);, +			}, +		}, +		catch (IllegalArgumentException ex) {, +			throw new ResponseStatusException(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE,, +					"Could not parse Range request header", ex);, +		}, +		return Collections.emptyMap();]