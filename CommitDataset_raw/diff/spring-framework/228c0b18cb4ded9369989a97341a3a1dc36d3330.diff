[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +				RequestMappingInfo mappingInfo = createRequestMappingInfo(handlerMethod);, +				if (mappingInfo.hasPatterns()) {, +					List<String> matchingPatterns = new ArrayList<String>(mappingInfo.patterns.length);, +					for (String pattern : mappingInfo.patterns) {, +						if (!hasTypeLevelMapping() && !pattern.startsWith("/")) {, +							pattern = "/" + pattern;, +						String combinedPattern = getCombinedPattern(pattern, lookupPath, request);, +						if (combinedPattern != null) {, +								matchingPatterns.add(combinedPattern);, +								if (!mappingInfo.matchesRequestMethod(request)) {, +									allowedMethods.addAll(mappingInfo.methodNames());, +					Collections.sort(matchingPatterns, pathComparator);, +					mappingInfo.matchedPatterns = matchingPatterns;, +						if (!mappingInfo.matchesRequestMethod(request)) {, +							allowedMethods.addAll(mappingInfo.methodNames());, +						if (methodNameResolver != null && mappingInfo.patterns.length == 0) {, +				String bestMatchedPath = bestMappingMatch.bestMatchedPattern();, +, +		private RequestMappingInfo createRequestMappingInfo(Method handlerMethod) {, +			RequestMappingInfo mappingInfo = new RequestMappingInfo();, +			RequestMapping mapping = AnnotationUtils.findAnnotation(handlerMethod, RequestMapping.class);, +			mappingInfo.patterns = mapping.value();, +			if (!hasTypeLevelMapping() || !Arrays.equals(mapping.method(), getTypeLevelMapping().method())) {, +				mappingInfo.methods = mapping.method();, +			}, +			if (!hasTypeLevelMapping() || !Arrays.equals(mapping.params(), getTypeLevelMapping().params())) {, +				mappingInfo.params = mapping.params();, +			}, +			if (!hasTypeLevelMapping() || !Arrays.equals(mapping.headers(), getTypeLevelMapping().headers())) {, +				mappingInfo.headers = mapping.headers();, +			}, +			return mappingInfo;, +		 * Determines the combined pattern for the given methodLevelPattern and path., +		 * <p>Uses the following algorithm: <ol>, +		 * <li>If there is a type-level mapping with path information, it is {@linkplain, +		 * PathMatcher#combine(String, String) combined} with the method-level pattern.</li>, +		 * <li>If there is a {@linkplain HandlerMapping#BEST_MATCHING_PATTERN_ATTRIBUTE best matching pattern} in the, +		 * request, it is combined with the method-level pattern.</li>, +		 * <li>Otherwise, the method-level pattern is returned.</li>, +		 * </ol>, +		private String getCombinedPattern(String methodLevelPattern, String lookupPath, HttpServletRequest request) {, +		String[] patterns = new String[0];, +		List<String> matchedPatterns = Collections.emptyList();, +		public boolean hasPatterns() {, +			return patterns.length > 0;, +		}, +, +		public String bestMatchedPattern() {, +			return (!this.matchedPatterns.isEmpty() ? this.matchedPatterns.get(0) : null);, +			return matchesRequestMethod(request) && matchesParameters(request) && matchesHeaders(request);, +		}, +, +		public boolean matchesHeaders(HttpServletRequest request) {, +			return ServletAnnotationMappingUtils.checkHeaders(this.headers, request);, +		}, +, +		public boolean matchesParameters(HttpServletRequest request) {, +			return ServletAnnotationMappingUtils.checkParameters(this.params, request);, +		}, +, +		public boolean matchesRequestMethod(HttpServletRequest request) {, +			return ServletAnnotationMappingUtils.checkRequestMethod(this.methods, request);, +		}, +, +		public Set<String> methodNames() {, +			Set<String> methodNames = new LinkedHashSet<String>(methods.length);, +			for (RequestMethod method : methods) {, +				methodNames.add(method.name());, +			}, +			return methodNames;, +			return (Arrays.equals(this.patterns, other.patterns) && Arrays.equals(this.methods, other.methods) &&, +			return (Arrays.hashCode(this.patterns) * 23 + Arrays.hashCode(this.methods) * 29 +, +, +		@Override, +		public String toString() {, +			StringBuilder builder = new StringBuilder();, +			builder.append(Arrays.asList(patterns));, +			if (methods.length > 0) {, +				builder.append(',');, +				builder.append(Arrays.asList(methods));, +			}, +			if (headers.length > 0) {, +				builder.append(',');, +				builder.append(Arrays.asList(headers));, +			}, +			if (params.length > 0) {, +				builder.append(',');, +				builder.append(Arrays.asList(params));, +			}, +			return builder.toString();, +		}, +	 * <li>RHIs with {@linkplain RequestMappingInfo#matchedPatterns better matched paths} take prescedence, +			int pathComparison = pathComparator.compare(info1.bestMatchedPattern(), info2.bestMatchedPattern());, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, +				RequestMappingInfo mappingInfo = createRequestMappingInfo(handlerMethod);, +				if (mappingInfo.hasPatterns()) {, +					List<String> matchingPatterns = new ArrayList<String>(mappingInfo.patterns.length);, +					for (String pattern : mappingInfo.patterns) {, +						if (!hasTypeLevelMapping() && !pattern.startsWith("/")) {]