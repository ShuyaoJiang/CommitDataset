[+++ b/spring-framework-reference/src/beans.xml, +    (for use in internationalization), event publication; and, +    application-layer specific contexts such as the, +  <section id="beans-basics">, +    <para>Spring provides implementations of the, +    <classname>ApplicationContext</classname> interface for use in standalone, +    and web applications. In standalone applications it is common to create an, +    instance of <ulink, +    While XML has been the traditional format for defining configuration, +    metadata you instruct the container to use Java annotations or code as the, +    metadata format by providng a small amount of XML configuration to, +    declaratively enable support for using these additional metadata, +    formats.</para>, +    in a web application scenario you configure the use of the, +    WebApplicationContext using simple eight (or so) lines of boilerplate J2EE, +    web descriptor XML in the <literal>web.xml</literal> file (see <xref, +    linkend="context-create" />). If you are using the <ulink, +    url="http://www.springsource.com/produts/sts">SpringSource Tool, +    Suite</ulink> Eclipse-powered development environment or <ulink, +    url="http://www.springsource.org/roo">Spring Roo</ulink> this boilerplate, +    configuration can be easily created with few mouse clicks or, +    keystrokes.</para>, +        <imageobject>, +      objects in your application.</para>, +      configuration represents beans as <literal>&lt;bean/&gt;</literal>, +      elements inside a top-level <literal>&lt;beans/&gt;</literal>, +      element.</para>, +      <programlisting language="java">ApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"services.xml",, +                                                                              "daos.xml"});</programlisting>, +        abstraction, as described in <xref linkend="resources" />, which, +        provides a convenient mechanism for reading an InputSream from, +        locations defined in a URI syntax. In particular, the use of, +        <classname>Resource</classname> paths to construct applications, +        contexts as described in <xref linkend="resources-app-ctx" />. </para>, +  &lt;bean id="petStore" , +        class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt;, +      <literal>(daos.xml</literal>) configuration file:</para>, +          selects the "nearest" classpath root and then looks into its parent, +          such absolute locations, for example, through <link, +          linkend="beans-factory-placeholderconfigurer">property, +          placeholders</link>, "${...}", that are resolved against JVM system, +          properties at runtime.</para>, +      <para>You use the method <methodname>getBean</methodname> to retrieve, +      instances of your beans. The, +      <interfacename>ApplicationContext</interfacename> interface has a few, +      other methods for retrieving beans, but ideally your application code, +      should never use them. Indeed, your application code should have no, +      calls to the <methodname>getBean</methodname> method at all, and thus no, +      dependency on Spring APIs at all. For example, Spring's integration with, +      web frameworks provides for dependency injection for various web, +      framework classes such as controllers and JSF-managed beans.</para>, +    configuration metadata that you supply to the container, for example, in, +    the form of XML <literal>&lt;bean/&gt;</literal> definitions.</para>, +    specific bean, The <interfacename>ApplicationContext</interfacename>, +    created outside the container, by users. This is done by accessing the, +    ApplicationContext's BeanFactory via the method, +    <methodname>getBeanFactory</methodname> which returns the BeanFactory, +    implementation <classname>DefaultListableBeanFactory</classname>., +    <classname>DefaultListableBeanFactory</classname> supports this, +    registration through the methods, +    <methodname>registerSingleton(..)</methodname> and, +    <methodname>registerBeanDefinition(..)</methodname>. However, typical, +    applications work solely with beans defined through metadata bean, +    definitions. For more information on the relationship between a, +    <classname>BeanFactory</classname> and the, +    <classname>ApplicationContext</classname> see <xref, +    linkend="beans-beanfactory" />.</para>, +      <para>Every bean has one or more identifiers. These identifiers must be, +      unique within the container that hosts the bean. A bean usually has only, +      one identifier, but if it requires more than one, the extra ones can be, +      considered aliases.</para>, +, +      <para>When using XML-based configuration metadata, you use the, +      <literal>id</literal> and/or <literal>name</literal> attributes to, +      specify the bean identifier(s). The <literal>id</literal> attribute, +      allows you to specify exactly one id, and because it is a real XML, +      element ID attribute, the XML parser can do some extra validation when, +      other elements reference the id. As such, it is the preferred way to, +      specify a bean identifier. However, the XML specification does limit the, +      characters that are legal in XML ids. This is usually not a constraint,, +      but if you need to use one of these special XML characters, or want to, +      introduce other aliases to the bean, you can also specify them in the, +      <literal>name</literal> attribute, separated by a comma, +      (<literal>,</literal>), semicolon (<literal>;</literal>), or white, +      space.</para>, +, +      <para>You are not required to specify a name or id for a bean. If no, +      name or id is supplied explicitly, the container generates a unique name, +      for that bean. However, if you want to refer to that bean by name,, +      through the use of the <literal>ref</literal> element or <link lang="", +      linkend="beans-servicelocation">Service Location</link> style lookup in, +      the ApplicationContext, you must provide a name. Motivations for not, +      supplying a name are related to using <link, +      linkend="beans-inner-beans">inner beans</link> and <link, +      linkend="beans-factory-autowire">autowiring collaborators</link>.</para>, +, +        alias for a bean that is defined elsewhere. This is commonly the case, +        in large systems where configuration is split amongst each subsystem,, +        each subsystem having its own set of object defintions. In XML-based, +        configuration metadata, you can use of the]