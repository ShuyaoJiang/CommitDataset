[+++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, +		boolean processConfigurationClasses = (contextLoader instanceof ResourceTypeAwareContextLoader), +				&& ((ResourceTypeAwareContextLoader) contextLoader).supportsClassResources();, +		return processConfigurationClasses ? //, +		resolveConfigurationClassNames(contextLoader, annotationType, declaringClass), +				: resolveStringLocations(contextLoader, annotationType, declaringClass);, +	/**, +	 * TODO Document resolveStringLocations()., +	 *, +	 * @param contextLoader, +	 * @param annotationType, +	 * @param declaringClass, +	 * @return, +	 */, +	private static String[] resolveStringLocations(ContextLoader contextLoader,, +			Class<ContextConfiguration> annotationType, Class<?> declaringClass) {, +		List<String> locationsList = new ArrayList<String>();, +	/**, +	 * TODO Document resolveConfigClassNames()., +	 *, +	 * @param contextLoader, +	 * @param annotationType, +	 * @param declaringClass, +	 * @return, +	 */, +	private static String[] resolveConfigurationClassNames(ContextLoader contextLoader,, +			Class<ContextConfiguration> annotationType, Class<?> declaringClass) {, +, +		// TODO [SPR-6184] Implement recursive search for configuration classes., +, +		ContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);, +		if (logger.isTraceEnabled()) {, +			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",, +				contextConfiguration, declaringClass));, +		}, +, +		String[] classNames = null;, +, +		Class<?>[] configClasses = contextConfiguration.classes();, +		if (!ObjectUtils.isEmpty(configClasses)) {, +			classNames = new String[configClasses.length];, +, +			for (int i = 0; i < configClasses.length; i++) {, +				classNames[i] = configClasses[i].getName();, +			}, +		}, +, +		return contextLoader.processLocations(declaringClass, classNames);, +	}, +, +++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, +		boolean processConfigurationClasses = (contextLoader instanceof ResourceTypeAwareContextLoader), +				&& ((ResourceTypeAwareContextLoader) contextLoader).supportsClassResources();, +		return processConfigurationClasses ? //, +		resolveConfigurationClassNames(contextLoader, annotationType, declaringClass), +				: resolveStringLocations(contextLoader, annotationType, declaringClass);, +	/**, +	 * TODO Document resolveStringLocations()., +	 *, +	 * @param contextLoader, +	 * @param annotationType, +	 * @param declaringClass, +	 * @return, +	 */, +	private static String[] resolveStringLocations(ContextLoader contextLoader,, +			Class<ContextConfiguration> annotationType, Class<?> declaringClass) {, +		List<String> locationsList = new ArrayList<String>();, +	/**, +	 * TODO Document resolveConfigClassNames()., +	 *, +	 * @param contextLoader, +	 * @param annotationType, +	 * @param declaringClass, +	 * @return, +	 */, +	private static String[] resolveConfigurationClassNames(ContextLoader contextLoader,, +			Class<ContextConfiguration> annotationType, Class<?> declaringClass) {, +, +		// TODO [SPR-6184] Implement recursive search for configuration classes., +, +		ContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);, +		if (logger.isTraceEnabled()) {, +			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",, +				contextConfiguration, declaringClass));, +		}, +, +		String[] classNames = null;, +, +		Class<?>[] configClasses = contextConfiguration.classes();, +		if (!ObjectUtils.isEmpty(configClasses)) {, +			classNames = new String[configClasses.length];, +, +			for (int i = 0; i < configClasses.length; i++) {, +				classNames[i] = configClasses[i].getName();, +			}, +		}, +, +		return contextLoader.processLocations(declaringClass, classNames);, +	}, +]