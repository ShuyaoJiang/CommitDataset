[+++ b/spring-web/src/main/java/org/springframework/web/util/pattern/CaptureVariablePathElement.java, +				if (!match && matchingContext.isMatchOptionalTrailingSeparator()) {, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/CaptureVariablePathElement.java, +				if (!match && matchingContext.isMatchOptionalTrailingSeparator()) {, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/InternalPathPatternParser.java, +	private int pathElementStart;, +	private int variableCaptureStart;, +	private List<String> capturedVariableNames;, +	private PathElement headPE;, +	private PathElement currentPE;, +	/**, +	 * Package private constructor for use in {@link PathPatternParser#parse}., +	 * @param parentParser reference back to the stateless, public parser, +	 */, +	 * Package private delegate for {@link PathPatternParser#parse(String)}., +			if (ch == this.parser.getSeparator()) {, +					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()));, +					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()));, +		return new PathPattern(pathPattern, this.parser, this.headPE);, +			if (ch == this.parser.getSeparator() && !previousBackslash) {, +					newPE = new CaptureTheRestPathElement(, +							this.pathElementStart, getPathElementText(), this.parser.getSeparator());, +								this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.pathPatternData, this.parser.getSeparator());, +					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator());, +							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator());, +						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.parser.isCaseSensitive(), this.parser.getSeparator());, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/CaptureVariablePathElement.java, +				if (!match && matchingContext.isMatchOptionalTrailingSeparator()) {, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/InternalPathPatternParser.java, +	private int pathElementStart;, +	private int variableCaptureStart;, +	private List<String> capturedVariableNames;, +	private PathElement headPE;, +	private PathElement currentPE;, +	/**, +	 * Package private constructor for use in {@link PathPatternParser#parse}., +	 * @param parentParser reference back to the stateless, public parser, +	 */, +	 * Package private delegate for {@link PathPatternParser#parse(String)}., +			if (ch == this.parser.getSeparator()) {, +					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()));, +					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()));, +		return new PathPattern(pathPattern, this.parser, this.headPE);, +			if (ch == this.parser.getSeparator() && !previousBackslash) {, +					newPE = new CaptureTheRestPathElement(, +							this.pathElementStart, getPathElementText(), this.parser.getSeparator());, +								this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.pathPatternData, this.parser.getSeparator());, +					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator());, +							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator());, +						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.parser.isCaseSensitive(), this.parser.getSeparator());, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/LiteralPathElement.java, +					return (matchingContext.isMatchOptionalTrailingSeparator() &&, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/CaptureVariablePathElement.java, +				if (!match && matchingContext.isMatchOptionalTrailingSeparator()) {, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/InternalPathPatternParser.java, +	private int pathElementStart;, +	private int variableCaptureStart;, +	private List<String> capturedVariableNames;, +	private PathElement headPE;, +	private PathElement currentPE;, +	/**, +	 * Package private constructor for use in {@link PathPatternParser#parse}., +	 * @param parentParser reference back to the stateless, public parser, +	 */, +	 * Package private delegate for {@link PathPatternParser#parse(String)}., +			if (ch == this.parser.getSeparator()) {, +					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()));, +					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()));, +		return new PathPattern(pathPattern, this.parser, this.headPE);, +			if (ch == this.parser.getSeparator() && !previousBackslash) {, +					newPE = new CaptureTheRestPathElement(, +							this.pathElementStart, getPathElementText(), this.parser.getSeparator());, +								this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.pathPatternData, this.parser.getSeparator());, +					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator());, +							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator());, +						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator());, +						this.parser.isCaseSensitive(), this.parser.getSeparator());, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/LiteralPathElement.java, +					return (matchingContext.isMatchOptionalTrailingSeparator() &&, +++ b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java, + * @see PathContainer, +, +	/** The text of the parsed pattern */, +	private final String patternString;, +, +	/** The separator used when parsing the pattern */, +	private final char separator;, +, +	/** If this pattern has no trailing slash, allow candidates to include one and still match successfully */, +	private final boolean matchOptionalTrailingSeparator;, +, +	/** Will this match candidates in a case sensitive way? (case sensitivity  at parse time) */, +	private final boolean caseSensitive;, +, +	PathPattern(String patternText, PathPatternParser parser, @Nullable PathElement head) {]