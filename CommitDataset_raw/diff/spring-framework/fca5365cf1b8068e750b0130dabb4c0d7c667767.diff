[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java, +			throw new BeanCreationException(beanName, "Failed to invoke init method", ex);, +			logger.error("Failed to invoke destroy method on bean with name '" + beanName + "'", ex);, +	@Override, +	public boolean requiresDestruction(Object bean) {, +		return findLifecycleMetadata(bean.getClass()).hasDestroyMethods();, +	}, +, +			Collection<LifecycleElement> destroyMethodsToUse =, +			if (!destroyMethodsToUse.isEmpty()) {, +				for (LifecycleElement element : destroyMethodsToUse) {, +, +		public boolean hasDestroyMethods() {, +			Collection<LifecycleElement> destroyMethodsToUse =, +					(this.checkedDestroyMethods != null ? this.checkedDestroyMethods : this.destroyMethods);, +			return !destroyMethodsToUse.isEmpty();, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java, +			throw new BeanCreationException(beanName, "Failed to invoke init method", ex);, +			logger.error("Failed to invoke destroy method on bean with name '" + beanName + "'", ex);, +	@Override, +	public boolean requiresDestruction(Object bean) {, +		return findLifecycleMetadata(bean.getClass()).hasDestroyMethods();, +	}, +, +			Collection<LifecycleElement> destroyMethodsToUse =, +			if (!destroyMethodsToUse.isEmpty()) {, +				for (LifecycleElement element : destroyMethodsToUse) {, +, +		public boolean hasDestroyMethods() {, +			Collection<LifecycleElement> destroyMethodsToUse =, +					(this.checkedDestroyMethods != null ? this.checkedDestroyMethods : this.destroyMethods);, +			return !destroyMethodsToUse.isEmpty();, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DestructionAwareBeanPostProcessor.java, + * Copyright 2002-2015 the original author or authors., +	/**, +	 * Determine whether the given bean instance requires destruction by this, +	 * post-processor., +	 * <p><b>NOTE:</b> Even as a late addition, this method has been introduced on, +	 * {@code DestructionAwareBeanPostProcessor} itself instead of on a SmartDABPP, +	 * subinterface. This allows existing {@code DestructionAwareBeanPostProcessor}, +	 * implementations to easily provide {@code requiresDestruction} logic while, +	 * retaining compatibility with Spring <4.3, and it is also an easier onramp to, +	 * declaring {@code requiresDestruction} as a Java 8 default method in Spring 5., +	 * <p>If an implementation of {@code DestructionAwareBeanPostProcessor} does, +	 * not provide a concrete implementation of this method, Spring's invocation, +	 * mechanism silently assumes a method returning {@code true} (the effective, +	 * default before 4.3, and the to-be-default in the Java 8 method in Spring 5)., +	 * @param bean the bean instance to check, +	 * @return {@code true} if {@link #postProcessBeforeDestruction} is supposed to, +	 * be called for this bean instance eventually, or {@code false} if not needed, +	 * @since 4.3, +	 */, +	boolean requiresDestruction(Object bean);, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java, +			throw new BeanCreationException(beanName, "Failed to invoke init method", ex);, +			logger.error("Failed to invoke destroy method on bean with name '" + beanName + "'", ex);, +	@Override, +	public boolean requiresDestruction(Object bean) {, +		return findLifecycleMetadata(bean.getClass()).hasDestroyMethods();, +	}, +, +			Collection<LifecycleElement> destroyMethodsToUse =, +			if (!destroyMethodsToUse.isEmpty()) {, +				for (LifecycleElement element : destroyMethodsToUse) {, +, +		public boolean hasDestroyMethods() {, +			Collection<LifecycleElement> destroyMethodsToUse =, +					(this.checkedDestroyMethods != null ? this.checkedDestroyMethods : this.destroyMethods);, +			return !destroyMethodsToUse.isEmpty();, +		}, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DestructionAwareBeanPostProcessor.java, + * Copyright 2002-2015 the original author or authors., +	/**, +	 * Determine whether the given bean instance requires destruction by this, +	 * post-processor., +	 * <p><b>NOTE:</b> Even as a late addition, this method has been introduced on, +	 * {@code DestructionAwareBeanPostProcessor} itself instead of on a SmartDABPP, +	 * subinterface. This allows existing {@code DestructionAwareBeanPostProcessor}, +	 * implementations to easily provide {@code requiresDestruction} logic while, +	 * retaining compatibility with Spring <4.3, and it is also an easier onramp to, +	 * declaring {@code requiresDestruction} as a Java 8 default method in Spring 5., +	 * <p>If an implementation of {@code DestructionAwareBeanPostProcessor} does, +	 * not provide a concrete implementation of this method, Spring's invocation, +	 * mechanism silently assumes a method returning {@code true} (the effective, +	 * default before 4.3, and the to-be-default in the Java 8 method in Spring 5)., +	 * @param bean the bean instance to check, +	 * @return {@code true} if {@link #postProcessBeforeDestruction} is supposed to, +	 * be called for this bean instance eventually, or {@code false} if not needed, +	 * @since 4.3, +	 */, +	boolean requiresDestruction(Object bean);, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, +				(DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || (hasDestructionAwareBeanPostProcessors() &&, +						DisposableBeanAdapter.hasApplicableProcessors(bean, getBeanPostProcessors()))));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java, +			throw new BeanCreationException(beanName, "Failed to invoke init method", ex);]