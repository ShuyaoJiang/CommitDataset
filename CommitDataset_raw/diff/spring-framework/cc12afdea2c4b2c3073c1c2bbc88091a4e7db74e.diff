[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.context.annotation.DeferredImportSelector.Group;, + * @author Stephane Nicoll, +		Map<Object, DeferredImportSelectorGrouping> groupings = new LinkedHashMap<>();, +		Map<AnnotationMetadata, ConfigurationClass> configurationClasses = new HashMap<>();, +			Class<? extends Group> group = deferredImport.getImportSelector().getImportGroup();, +			DeferredImportSelectorGrouping grouping = groupings.computeIfAbsent(, +					(group == null ? deferredImport : group),, +					(key) -> new DeferredImportSelectorGrouping(createGroup(group)));, +			grouping.add(deferredImport);, +			configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),, +					deferredImport.getConfigurationClass());, +		}, +		for (DeferredImportSelectorGrouping grouping : groupings.values()) {, +			grouping.getImports().forEach((entry) -> {, +				ConfigurationClass configurationClass = configurationClasses.get(, +						entry.getMetadata());, +					processImports(configurationClass, asSourceClass(configurationClass),, +							asSourceClasses(entry.getImportClassName()), false);, +									configurationClass.getMetadata().getClassName() + "]", ex);, +				}, +			});, +, +	private Group createGroup(@Nullable Class<? extends Group> type) {, +		Class<? extends Group> effectiveType = (type != null ? type, +				: DefaultDeferredImportSelectorGroup.class);, +		Group group = BeanUtils.instantiateClass(effectiveType);, +		ParserStrategyUtils.invokeAwareMethods(group,, +				ConfigurationClassParser.this.environment,, +				ConfigurationClassParser.this.resourceLoader,, +				ConfigurationClassParser.this.registry);, +		return group;, +	private Collection<SourceClass> asSourceClasses(String... classNames) throws IOException {, +	private static class DeferredImportSelectorGrouping {, +, +		private final DeferredImportSelector.Group group;, +, +		private final List<DeferredImportSelectorHolder> deferredImports = new ArrayList<>();, +, +		DeferredImportSelectorGrouping(Group group) {, +			this.group = group;, +		}, +, +		public void add(DeferredImportSelectorHolder deferredImport) {, +			this.deferredImports.add(deferredImport);, +		}, +, +		/**, +		 * Return the imports defined by the group., +		 * @return each import with its associated configuration class, +		 */, +		public Iterable<Group.Entry> getImports() {, +			for (DeferredImportSelectorHolder deferredImport : this.deferredImports) {, +				this.group.process(deferredImport.getConfigurationClass().getMetadata(),, +						deferredImport.getImportSelector());, +			}, +			return this.group.selectImports();, +		}, +	}, +, +, +	private static class DefaultDeferredImportSelectorGroup implements Group {, +, +		private final List<Entry> imports = new ArrayList<>();, +, +		@Override, +		public void process(AnnotationMetadata metadata, DeferredImportSelector selector) {, +			for (String importClassName : selector.selectImports(metadata)) {, +				this.imports.add(new Entry(metadata, importClassName));, +			}, +		}, +, +		@Override, +		public Iterable<Entry> selectImports() {, +			return this.imports;, +		}, +	}, +, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.context.annotation.DeferredImportSelector.Group;, + * @author Stephane Nicoll, +		Map<Object, DeferredImportSelectorGrouping> groupings = new LinkedHashMap<>();, +		Map<AnnotationMetadata, ConfigurationClass> configurationClasses = new HashMap<>();, +			Class<? extends Group> group = deferredImport.getImportSelector().getImportGroup();, +			DeferredImportSelectorGrouping grouping = groupings.computeIfAbsent(, +					(group == null ? deferredImport : group),, +					(key) -> new DeferredImportSelectorGrouping(createGroup(group)));, +			grouping.add(deferredImport);, +			configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),, +					deferredImport.getConfigurationClass());, +		}, +		for (DeferredImportSelectorGrouping grouping : groupings.values()) {, +			grouping.getImports().forEach((entry) -> {, +				ConfigurationClass configurationClass = configurationClasses.get(, +						entry.getMetadata());, +					processImports(configurationClass, asSourceClass(configurationClass),, +							asSourceClasses(entry.getImportClassName()), false);, +									configurationClass.getMetadata().getClassName() + "]", ex);, +				}]