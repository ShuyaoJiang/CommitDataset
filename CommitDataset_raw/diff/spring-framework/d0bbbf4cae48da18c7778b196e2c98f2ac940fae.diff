[+++ b/spring-core/src/main/java/org/springframework/core/annotation/OrderUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	/** Cache marker for a non-annotated Class. */, +	private static final Object NOT_ANNOTATED = new Object();, +, +, +	/** Cache for @Order value (or NOT_ANNOTATED marker) per Class. */, +	private static final Map<Class<?>, Object> orderCache = new ConcurrentReferenceHashMap<>(64);, +, +	/** Cache for @Priority value (or NOT_ANNOTATED marker) per Class. */, +	private static final Map<Class<?>, Object> priorityCache = new ConcurrentReferenceHashMap<>();, +, +, +		Object cached = orderCache.get(type);, +		if (cached != null) {, +			return (cached instanceof Integer ? (Integer) cached : null);, +		}, +		Integer result;, +			result = order.value();, +		else {, +			result = getPriority(type);, +		orderCache.put(type, (result != null ? result : NOT_ANNOTATED));, +		return result;, +		if (priorityAnnotationType == null) {, +		Object cached = priorityCache.get(type);, +		if (cached != null) {, +			return (cached instanceof Integer ? (Integer) cached : null);, +		}, +		Annotation priority = AnnotationUtils.findAnnotation(type, priorityAnnotationType);, +		Integer result = null;, +		if (priority != null) {, +			result = (Integer) AnnotationUtils.getValue(priority);, +		}, +		priorityCache.put(type, (result != null ? result : NOT_ANNOTATED));, +		return result;, +	}, +++ b/spring-core/src/main/java/org/springframework/core/annotation/OrderUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	/** Cache marker for a non-annotated Class. */, +	private static final Object NOT_ANNOTATED = new Object();, +, +, +	/** Cache for @Order value (or NOT_ANNOTATED marker) per Class. */, +	private static final Map<Class<?>, Object> orderCache = new ConcurrentReferenceHashMap<>(64);, +, +	/** Cache for @Priority value (or NOT_ANNOTATED marker) per Class. */, +	private static final Map<Class<?>, Object> priorityCache = new ConcurrentReferenceHashMap<>();, +, +, +		Object cached = orderCache.get(type);, +		if (cached != null) {, +			return (cached instanceof Integer ? (Integer) cached : null);, +		}, +		Integer result;, +			result = order.value();, +		else {, +			result = getPriority(type);, +		orderCache.put(type, (result != null ? result : NOT_ANNOTATED));, +		return result;, +		if (priorityAnnotationType == null) {, +		Object cached = priorityCache.get(type);, +		if (cached != null) {, +			return (cached instanceof Integer ? (Integer) cached : null);, +		}, +		Annotation priority = AnnotationUtils.findAnnotation(type, priorityAnnotationType);, +		Integer result = null;, +		if (priority != null) {, +			result = (Integer) AnnotationUtils.getValue(priority);, +		}, +		priorityCache.put(type, (result != null ? result : NOT_ANNOTATED));, +		return result;, +	}, +++ b/spring-core/src/test/java/org/springframework/core/annotation/OrderUtilsTests.java, + * Copyright 2002-2018 the original author or authors., + * @author Juergen Hoeller, +		assertEquals(Integer.valueOf(50), OrderUtils.getOrder(SimpleOrder.class, null));, +		assertEquals(Integer.valueOf(55), OrderUtils.getOrder(SimplePriority.class, null));, +		assertEquals(Integer.valueOf(50), OrderUtils.getOrder(OrderAndPriority.class, null));, +		assertEquals(33, OrderUtils.getOrder(NoOrder.class, 33));, +		assertNull(OrderUtils.getPriority(SimpleOrder.class));, +		assertEquals(Integer.valueOf(55), OrderUtils.getPriority(OrderAndPriority.class));, +]