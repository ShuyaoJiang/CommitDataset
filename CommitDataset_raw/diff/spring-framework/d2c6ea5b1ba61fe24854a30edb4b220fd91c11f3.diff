[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/AppCacheManifestTransformer.java, +							.map(LineAggregator::createResource);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/AppCacheManifestTransformer.java, +							.map(LineAggregator::createResource);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/resource/CssLinkResourceTransformer.java, +import java.util.SortedSet;, +import java.util.TreeSet;, +					byte[] bytes;, +					String cssContent = new String(bytes, DEFAULT_CHARSET);, +					List<ContentChunkInfo> contentChunkInfos = parseContent(cssContent);, +					if (contentChunkInfos.isEmpty()) {, +					return Flux.fromIterable(contentChunkInfos), +							.concatMap(contentChunkInfo -> {, +								String segmentContent = contentChunkInfo.getContent(cssContent);, +								if (contentChunkInfo.isLink() && !hasScheme(segmentContent)) {, +							.map(writer -> {, +								return new TransformedResource(resource, newContent);, +	private List<ContentChunkInfo> parseContent(String cssContent) {, +		SortedSet<ContentChunkInfo> links = new TreeSet<>();, +		this.linkParsers.forEach(parser -> parser.parse(cssContent, links));, +		List<ContentChunkInfo> result = new ArrayList<>();, +		for (ContentChunkInfo link : links) {, +			result.add(new ContentChunkInfo(index, link.getStart(), false));, +			result.add(link);, +		if (index < cssContent.length()) {, +			result.add(new ContentChunkInfo(index, cssContent.length(), false));, +		return result;, +	/**, +	 * Extract content chunks that represent links., +	 */, +		void parse(String cssContent, SortedSet<ContentChunkInfo> result);, +		/** Return the keyword to use to search for links, e.g. "@import", "url(" */, +		public void parse(String content, SortedSet<ContentChunkInfo> result) {, +			int position = 0;, +			while (true) {, +				position = content.indexOf(getKeyword(), position);, +				if (position == -1) {, +					return;, +				position += getKeyword().length();, +				while (Character.isWhitespace(content.charAt(position))) {, +					position++;, +				if (content.charAt(position) == '\'') {, +					position = extractLink(position, '\'', content, result);, +				}, +				else if (content.charAt(position) == '"') {, +					position = extractLink(position, '"', content, result);, +					position = extractUnquotedLink(position, content, result);, +		protected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result) {, +			int end = content.indexOf(endChar, start);, +			result.add(new ContentChunkInfo(start, end, true));, +			return end + 1;, +		protected abstract int extractUnquotedLink(int position, String content,, +				Set<ContentChunkInfo> linksToAdd);, +		protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {, +			if (content.substring(position, position + 4).equals("url(")) {, +				// Ignore, UrlFunctionContentParser will take care, +				logger.error("Unexpected syntax for @import link at index " + position);, +			return position;, +		protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {, +			return extractLink(position - 1, ')', content, result);, +	private static class ContentChunkInfo implements Comparable<ContentChunkInfo> {, +		private final boolean isLink;, +		ContentChunkInfo(int start, int end, boolean isLink) {, +			this.isLink = isLink;, +			return this.isLink;, +		public int compareTo(ContentChunkInfo other) {, +			if (obj != null && obj instanceof ContentChunkInfo) {, +				ContentChunkInfo other = (ContentChunkInfo) obj;]