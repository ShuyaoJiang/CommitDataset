[+++ b/spring-web/src/main/java/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.java, + * Copyright 2002-2017 the original author or authors., +, +import java.util.Locale;, +, +import reactor.core.publisher.Mono;, +, +import org.springframework.util.StringUtils;, + * support GET and POST, a common technique is to use a normal POST with an additional, + * hidden form field ({@code _method}) to pass the "real" HTTP method along., + * This filter reads that parameter and changes the {@link ServerHttpRequest#getMethod()}, + * return value using {@link ServerWebExchange#mutate()}., +	 * @return {@code Mono<Void>} to indicate when request processing is complete, +					.map(formData -> {, +						String method = formData.getFirst(methodParam);, +						if (StringUtils.hasLength(method)) {, +							return convertedRequest(exchange, method);, +						}, +						else {, +							return exchange;, +						}, +					}), +		}, +		else {, +	 * Mutate exchange into a new HTTP request method., +	 * @param exchange original {@link ServerWebExchange}, +	 * @param method request HTTP method based on form data, +	private ServerWebExchange convertedRequest(ServerWebExchange exchange, String method) {, +		HttpMethod resolved = HttpMethod.resolve(method.toUpperCase(Locale.ENGLISH));, +		Assert.notNull(resolved, () -> "HttpMethod '" + method + "' is not supported");, +				.request(builder -> builder.method(resolved)), +++ b/spring-web/src/main/java/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.java, + * Copyright 2002-2017 the original author or authors., +, +import java.util.Locale;, +, +import reactor.core.publisher.Mono;, +, +import org.springframework.util.StringUtils;, + * support GET and POST, a common technique is to use a normal POST with an additional, + * hidden form field ({@code _method}) to pass the "real" HTTP method along., + * This filter reads that parameter and changes the {@link ServerHttpRequest#getMethod()}, + * return value using {@link ServerWebExchange#mutate()}., +	 * @return {@code Mono<Void>} to indicate when request processing is complete, +					.map(formData -> {, +						String method = formData.getFirst(methodParam);, +						if (StringUtils.hasLength(method)) {, +							return convertedRequest(exchange, method);, +						}, +						else {, +							return exchange;, +						}, +					}), +		}, +		else {, +	 * Mutate exchange into a new HTTP request method., +	 * @param exchange original {@link ServerWebExchange}, +	 * @param method request HTTP method based on form data, +	private ServerWebExchange convertedRequest(ServerWebExchange exchange, String method) {, +		HttpMethod resolved = HttpMethod.resolve(method.toUpperCase(Locale.ENGLISH));, +		Assert.notNull(resolved, () -> "HttpMethod '" + method + "' is not supported");, +				.request(builder -> builder.method(resolved)), +++ b/spring-web/src/test/java/org/springframework/web/filter/reactive/HiddenHttpMethodFilterTests.java, + * Copyright 2002-2017 the original author or authors., +, +import java.util.Optional;, +, +import org.hamcrest.Matchers;, +import reactor.core.publisher.Mono;, +import reactor.test.StepVerifier;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertThat;, + * Tests for {@link HiddenHttpMethodFilter}, + *, +	public void filterWithInvalidParameter() {, +		ServerWebExchange mockExchange = createExchange(Optional.of("INVALID"));, +, +		WebFilterChain filterChain = exchange -> Mono.empty();, +, +		StepVerifier.create(filter.filter(mockExchange, filterChain)), +				.consumeErrorWith(error -> {, +					assertThat(error, Matchers.instanceOf(IllegalArgumentException.class));, +					assertEquals(error.getMessage(), "HttpMethod 'INVALID' is not supported");, +				}), +				.verify();, +	}, +, +	@Test, +	public void filterWithEmptyStringParameter() {, +		ServerWebExchange mockExchange = createExchange(Optional.of(""));, +, +		WebFilterChain filterChain = exchange -> {, +			assertEquals("Invalid method", HttpMethod.POST, exchange.getRequest().getMethod());, +			return Mono.empty();, +		};, +, +		StepVerifier.create(filter.filter(mockExchange, filterChain)), +				.expectComplete(), +				.verify();]