[+++ b/spring-framework-reference/src/orm.xml, +  <title>Object Relational Mapping (ORM) Data Access</title>, +    <title>Introduction to ORM with Spring</title>, +    <para>The Spring Framework supports <!--Changed from *provides* to *supports* because *provides* is too vague. If the integration is something you configure, then say *supports*.--><!--If Spring is preconfigured with integration support, say it *includes* integration with.But it sounds like it's *supports* because --><!--later in paragraph it refers to configuring support packages. TR: OK-->integration, +    with Hibernate, Java Persistence API (JPA), Java Data Objects (JDO) and, +    iBATIS SQL Maps for resource management, data access object (DAO), +    implementation, and transaction strategies. For example for Hibernate,, +    there is first-class support with lots of IoC convenience features,, +    addressing many typical Hibernate integration issues. You can configure, +    all of these supported features for O/R (object relational) mappers <!--GLOBAL: I have changed O/R mapping to ORM, to make all reference consistent and to be consistent with name of chapter. But when you--><!--refer to *mappers* as you do above, it's O/R mappers. The M in ORM stands for *mapping*, not *mappers.*--><!--TR: OK -->through, +    Dependency Injection. <!--Identify *these support packages*. Do you mean Hibernate, JPA, etc? Is it correct to call them support packages? , +TR: REVISED, PLS REVIEW. Changed to say features instead of packages. Reverted the "first-class support" sentence above since it is not , +IoC itself providing the support.-->They can participate in Spring's resource, +    and transaction management,and they comply with Spring's generic, +    transaction and DAO exception hierarchies. The recommended integration, +    style is to code DAOs against plain Hibernate, JPA, and JDO APIs. The, +    older style of using Spring's DAO templates is no longer recommended;, +    however, coverage of this style can be found in the <xref, +    linkend="classic-spring-orm" /> Appendix.</para>, +    <para>Spring adds significant enhancements to the ORM layer of your choice, +    when you create data access applications. You can leverage as much of the, +    integration support as you wish and you should compare this integration, +    effort with the cost and risk of building a similar infrastructure, +    in-house. You can use much of the ORM support as you would a library,, +    regardless of technology, because everything is designed as a set of, +    reusable JavaBeans. ORM in a Spring IoC container does facilitate, +    configuration and deployment; thus most examples in this section show, +    configuration inside a Spring container.</para>, +    <para>Benefits of using the Spring Framework to create your ORM DAOs, +    include:</para>, +        <para><emphasis>Easier testing.</emphasis> Spring's IoC approach makes, +        it easy to swap the implementations and configuration locations of, +        managers, and mapped object implementations (if needed). <!--I changed *mappes* to *mapped*; is that what you mean? Also, clarify whether *if needed* refers only to that or to the rest as well , +TR: OK. Refers only to mapped object implementations-->This in turn makes it, +        much easier to test each piece of persistence-related code in, +        isolation.<!--deleted redundancy; sentence already refers to isolating each piece of code. TR: OK. moved isolation to the end--></para>, +        wrap exceptions from your ORM tool, converting them from proprietary, +        (potentially checked) exceptions to a common runtime, +        DataAccessException hierarchy. This feature allows you to handle most, +        appropriate layers, without annoying boilerplate catches, throws, and, +        exception declarations. You can still trap and handle exceptions as, +        necessary. Remember that JDBC exceptions (including DB-specific, +        dialects) are also converted to the same hierarchy, meaning that you, +        can perform some operations with JDBC within a consistent programming, +        model.</para>, +        Hibernate <interfacename>SessionFactory</interfacename> instances, JPA, +        <interfacename>EntityManagerFactory</interfacename> instances, JDBC, +        <interfacename>DataSource</interfacename> instances, iBATIS SQL Maps, +        configuration objects, and other related resources. This makes these, +        values easy to manage and change. Spring offers efficient, easy, and, +        safe handling of persistence resources. For example, related code that, +        uses Hibernate generally needs to use the same Hibernate, +        <interfacename>Session</interfacename> to ensure efficiency and proper, +        transaction handling. Spring makes it easy to create and bind a, +        <interfacename>Session</interfacename> to the current thread, +        transparently, <!--This bullet and next refer to template wrapper class. Is this referring to using Spring DAO templates, whichis no longer recommend--><!--ed? If so, it's confusing to discuss it as an option. Sends a mixed message. If not, explain what you mean by *template* wrapper class. , +TR: REVISED, PLS REVIEW. Good point, removed coverage of template wrapper.-->by, +        exposing a current <interfacename>Session</interfacename> through the, +        Hibernate <interfacename>SessionFactory</interfacename>. Thus Spring, +        solves many chronic problems of typical Hibernate usage, for any local, +        or JTA transaction environment.</para>, +        <para><emphasis>Integrated transaction management.</emphasis> You can, +        wrap your ORM code with a declarative, aspect-oriented programming, +        (AOP) style method interceptor either through the, +        <interfacename>@Transactional</interfacename> annotation or by, +        explicitly configuring the transaction AOP advice in an XML, +        configuration file. In both cases, transaction semantics and exception, +        handling (rollback, and so on) are handled for you. As discussed, +        below, in <!--Instead of *below*, provide link to section. TR: OK--><link, +        linkend="orm-resource-mngmnt">Resource and transaction, +        management</link>, you can also swap various transaction managers,, +        without affecting your ORM-related code. For example, you can swap, +        between local transactions and JTA, with the same full services (such, +        as declarative transactions) available in both scenarios., +        Additionally, JDBC-related code can fully integrate transactionally, +        with the code you use to do ORM. This is useful for data access that, +        is not suitable for ORM, such as batch processing and BLOB streaming,, +        which still need <!--if both batch processing and BLOB streaming need to share common transactions w/ ORM, then change *needs* to *to need*. If --><!--it refers only to BLOB streaming, say *the latter of which still needs to share...* TR: OK. Chnaged to *to need*-->to, +    <para><!--The PetClinic sample in the Spring distribution offers alternative DAO implementations and application context configurations for JDBC, , +Hibernate, and JPA. PetClinic is a working sample application that illustrates the use of Hibernate and JPA in a Spring web application. , +It also leverages declarative transaction demarcation with different transaction strategies., +Beyond the samples shipped with Spring, vendors provide a variety of Spring-based ORM samples.  --><!--Name vendors, link to them? TR: WILL ADDRESS LATER. We need to point to the current samples which aren't completed yet. --><emphasis>TODO:, +    provide links to current samples</emphasis></para>, +    <para>This section highlights considerations that apply to all ORM, +    technologies. The <xref linkend="orm-hibernate" /> section provides more, +    details and also show these features and configurations in a concrete, +    context.</para>, +    <para>The major goal of Spring's ORM integration is clear application, +    layering, with any data access and transaction technology, and for loose, +    coupling of application objects. No more business service dependencies on, +    the data access or transaction strategy, no more hard-coded resource, +    lookups, no more hard-to-replace singletons, no more custom service, +    registries. One simple and consistent approach to wiring up application, +    objects, keeping them as reusable and free from container dependencies as, +    possible. All the individual data access features are usable on their own, +    but integrate nicely with Spring's application context concept, providing, +    XML-based configuration and cross-referencing of plain JavaBean instances, +    that need not be Spring-aware. In a typical Spring application, many, +    important objects are JavaBeans: data access templates, data access, +    objects, transaction managers, business services that use the data access]