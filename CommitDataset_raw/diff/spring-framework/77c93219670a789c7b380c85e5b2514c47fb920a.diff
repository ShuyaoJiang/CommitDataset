[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.annotation.Annotation;, +import java.util.Collections;, +import java.util.Comparator;, +import org.aspectj.lang.annotation.After;, +import org.aspectj.lang.annotation.Around;, +import org.aspectj.lang.annotation.Before;, +import org.springframework.core.convert.converter.Converter;, +import org.springframework.core.convert.converter.ConvertingComparator;, +import org.springframework.util.comparator.CompoundComparator;, +import org.springframework.util.comparator.InstanceComparator;, + * @author Phillip Webb, +	private static final Comparator<Method> METHOD_COMPARATOR;, +, +	static {, +		CompoundComparator<Method> comparator = new CompoundComparator<Method>();, +		comparator.addComparator(new ConvertingComparator<Method, Annotation>(, +				new InstanceComparator<Annotation>(, +						Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),, +				new Converter<Method, Annotation>() {, +					public Annotation convert(Method method) {, +						AspectJAnnotation<?> annotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);, +						return annotation == null ? null : annotation.getAnnotation();, +					}, +				}));, +		comparator.addComparator(new ConvertingComparator<Method, String>(, +				new Converter<Method, String>() {, +					public String convert(Method method) {, +						return method.getName();, +					}, +				}));, +		METHOD_COMPARATOR = comparator;, +	}, +, +, +		for (Method method : getAdvisorMethods(aspectClass)) {, +	private List<Method> getAdvisorMethods(Class<?> aspectClass) {, +		final List<Method> methods = new LinkedList<Method>();, +		ReflectionUtils.doWithMethods(aspectClass, new ReflectionUtils.MethodCallback() {, +			public void doWith(Method method) throws IllegalArgumentException {, +				// Exclude pointcuts, +				if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {, +					methods.add(method);, +				}, +			}, +		});, +		Collections.sort(methods, METHOD_COMPARATOR);, +		return methods;, +	}, +, +		DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);, +	@SuppressWarnings("serial"), +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.annotation.Annotation;, +import java.util.Collections;, +import java.util.Comparator;, +import org.aspectj.lang.annotation.After;, +import org.aspectj.lang.annotation.Around;, +import org.aspectj.lang.annotation.Before;, +import org.springframework.core.convert.converter.Converter;, +import org.springframework.core.convert.converter.ConvertingComparator;, +import org.springframework.util.comparator.CompoundComparator;, +import org.springframework.util.comparator.InstanceComparator;, + * @author Phillip Webb, +	private static final Comparator<Method> METHOD_COMPARATOR;, +, +	static {, +		CompoundComparator<Method> comparator = new CompoundComparator<Method>();, +		comparator.addComparator(new ConvertingComparator<Method, Annotation>(, +				new InstanceComparator<Annotation>(, +						Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),, +				new Converter<Method, Annotation>() {, +					public Annotation convert(Method method) {, +						AspectJAnnotation<?> annotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);, +						return annotation == null ? null : annotation.getAnnotation();, +					}, +				}));, +		comparator.addComparator(new ConvertingComparator<Method, String>(, +				new Converter<Method, String>() {, +					public String convert(Method method) {, +						return method.getName();, +					}, +				}));, +		METHOD_COMPARATOR = comparator;, +	}, +, +, +		for (Method method : getAdvisorMethods(aspectClass)) {, +	private List<Method> getAdvisorMethods(Class<?> aspectClass) {, +		final List<Method> methods = new LinkedList<Method>();, +		ReflectionUtils.doWithMethods(aspectClass, new ReflectionUtils.MethodCallback() {, +			public void doWith(Method method) throws IllegalArgumentException {, +				// Exclude pointcuts, +				if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {, +					methods.add(method);, +				}, +			}, +		});]