[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/parsing/ParseState.java, +import java.util.LinkedList;, + * Simple {@link LinkedList}-based structure for tracking the logical position during, + * a parsing process. {@link Entry entries} are added to the LinkedList at, +	 * Internal {@link LinkedList} storage., +	private final LinkedList<Entry> state;, +	 * Create a new {@code ParseState} with an empty {@link LinkedList}., +		this.state = new LinkedList<>();, +	 * Create a new {@code ParseState} whose {@link LinkedList} is a {@link Object#clone clone}, +		this.state = (LinkedList<Entry>) other.state.clone();, +	 * Add a new {@link Entry} to the {@link LinkedList}., +	 * Remove an {@link Entry} from the {@link LinkedList}., +	 * Return the {@link Entry} currently at the top of the {@link LinkedList} or, +	 * {@code null} if the {@link LinkedList} is empty., +		return this.state.isEmpty() ? null : this.state.peek();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/parsing/ParseState.java, +import java.util.LinkedList;, + * Simple {@link LinkedList}-based structure for tracking the logical position during, + * a parsing process. {@link Entry entries} are added to the LinkedList at, +	 * Internal {@link LinkedList} storage., +	private final LinkedList<Entry> state;, +	 * Create a new {@code ParseState} with an empty {@link LinkedList}., +		this.state = new LinkedList<>();, +	 * Create a new {@code ParseState} whose {@link LinkedList} is a {@link Object#clone clone}, +		this.state = (LinkedList<Entry>) other.state.clone();, +	 * Add a new {@link Entry} to the {@link LinkedList}., +	 * Remove an {@link Entry} from the {@link LinkedList}., +	 * Return the {@link Entry} currently at the top of the {@link LinkedList} or, +	 * {@code null} if the {@link LinkedList} is empty., +		return this.state.isEmpty() ? null : this.state.peek();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/ParserContext.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +	private final Deque<ComponentDefinition> containingComponents = new ArrayDeque<>();, +				(CompositeComponentDefinition) this.containingComponents.getLast() : null);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/parsing/ParseState.java, +import java.util.LinkedList;, + * Simple {@link LinkedList}-based structure for tracking the logical position during, + * a parsing process. {@link Entry entries} are added to the LinkedList at, +	 * Internal {@link LinkedList} storage., +	private final LinkedList<Entry> state;, +	 * Create a new {@code ParseState} with an empty {@link LinkedList}., +		this.state = new LinkedList<>();, +	 * Create a new {@code ParseState} whose {@link LinkedList} is a {@link Object#clone clone}, +		this.state = (LinkedList<Entry>) other.state.clone();, +	 * Add a new {@link Entry} to the {@link LinkedList}., +	 * Remove an {@link Entry} from the {@link LinkedList}., +	 * Return the {@link Entry} currently at the top of the {@link LinkedList} or, +	 * {@code null} if the {@link LinkedList} is empty., +		return this.state.isEmpty() ? null : this.state.peek();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/ParserContext.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +	private final Deque<ComponentDefinition> containingComponents = new ArrayDeque<>();, +				(CompositeComponentDefinition) this.containingComponents.getLast() : null);, +++ b/spring-context/src/main/java/org/springframework/validation/AbstractErrors.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +	private final Deque<String> nestedPathStack = new ArrayDeque<>();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/parsing/ParseState.java, +import java.util.LinkedList;, + * Simple {@link LinkedList}-based structure for tracking the logical position during, + * a parsing process. {@link Entry entries} are added to the LinkedList at, +	 * Internal {@link LinkedList} storage., +	private final LinkedList<Entry> state;, +	 * Create a new {@code ParseState} with an empty {@link LinkedList}., +		this.state = new LinkedList<>();, +	 * Create a new {@code ParseState} whose {@link LinkedList} is a {@link Object#clone clone}, +		this.state = (LinkedList<Entry>) other.state.clone();, +	 * Add a new {@link Entry} to the {@link LinkedList}., +	 * Remove an {@link Entry} from the {@link LinkedList}., +	 * Return the {@link Entry} currently at the top of the {@link LinkedList} or, +	 * {@code null} if the {@link LinkedList} is empty., +		return this.state.isEmpty() ? null : this.state.peek();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/ParserContext.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +	private final Deque<ComponentDefinition> containingComponents = new ArrayDeque<>();, +				(CompositeComponentDefinition) this.containingComponents.getLast() : null);, +++ b/spring-context/src/main/java/org/springframework/validation/AbstractErrors.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +	private final Deque<String> nestedPathStack = new ArrayDeque<>();, +++ b/spring-expression/src/main/java/org/springframework/expression/common/TemplateAwareExpressionParser.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +		Deque<Bracket> stack = new ArrayDeque<>();, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/parsing/ParseState.java, +import java.util.LinkedList;, + * Simple {@link LinkedList}-based structure for tracking the logical position during, + * a parsing process. {@link Entry entries} are added to the LinkedList at, +	 * Internal {@link LinkedList} storage., +	private final LinkedList<Entry> state;, +	 * Create a new {@code ParseState} with an empty {@link LinkedList}., +		this.state = new LinkedList<>();, +	 * Create a new {@code ParseState} whose {@link LinkedList} is a {@link Object#clone clone}, +		this.state = (LinkedList<Entry>) other.state.clone();, +	 * Add a new {@link Entry} to the {@link LinkedList}., +	 * Remove an {@link Entry} from the {@link LinkedList}., +	 * Return the {@link Entry} currently at the top of the {@link LinkedList} or]