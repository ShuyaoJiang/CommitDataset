[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.java, + * An abstract base class for use with HTTP transport SockJS sessions., +	private volatile SockJsFrameFormat frameFormat;, +, +, +	private final Object responseLock = new Object();, +	 * is closed., +	/**, +	 * Whether this HTTP transport streams message frames vs closing the response, +	 * after each frame written (long polling)., +	 */, +	protected abstract boolean isStreaming();, +, +	 * Handle the first request for receiving messages on a SockJS HTTP transport, +	 * based session., +	 *, +	 * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request, +	 * after writing the open frame. Streaming-based transports ("xhr_streaming",, +	 * "eventsource", and "htmlfile") leave the response open longer for further, +	 * streaming of message frames but will also close it eventually after some, +	 * amount of data has been sent., +, +		try {, +			// Let "our" handler know before sending the open frame to the remote handler, +			delegateConnectionEstablished();, +			writePrelude(request, response);, +			writeFrame(SockJsFrame.openFrame());, +			if (isStreaming() && !isClosed()) {, +				startAsyncRequest();, +			}, +		}, +		catch (Throwable ex) {, +			tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);, +			throw new SockJsTransportFailureException("Failed to open session", getId(), ex);, +		}, +	private void startAsyncRequest() {, +		this.asyncRequestControl.start(-1);, +		if (this.messageCache.size() > 0) {, +			flushCache();, +		}, +		else {, +			scheduleHeartbeat();, +		}, +		this.requestInitialized = true;, +	}, +, +	 * Handle all requests, except the first one, to receive messages on a SockJS, +	 * HTTP transport based session., +	 *, +	 * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request, +	 * after writing any buffered message frames (or the next one). Streaming-based, +	 * transports ("xhr_streaming", "eventsource", and "htmlfile") leave the, +	 * response open longer for further streaming of message frames but will also, +	 * close it eventually after some amount of data has been sent., +		synchronized (this.responseLock) {, +				if (isClosed()) {, +					response.getBody().write(SockJsFrame.closeFrameGoAway().getContentBytes());, +				}, +				this.response = response;, +				this.frameFormat = frameFormat;, +				this.asyncRequestControl = request.getAsyncRequestControl(response);, +				throw new SockJsTransportFailureException("Failed to handle SockJS receive request", getId(), ex);, +	}, +, +	private boolean tryFlushCache() throws SockJsTransportFailureException {, +		synchronized (this.responseLock) {, +				logger.trace("Nothing to flush in session=" + this.getId());, +				return false;, +				logger.trace(this.messageCache.size() + " message(s) to flush in session " + this.getId());, +				if (logger.isTraceEnabled()) {, +					logger.trace("Session is active, ready to flush.");, +				}, +				cancelHeartbeat();, +				return true;, +					logger.trace("Session is not active, not ready to flush.");, +				}, +				return false;, +	 * Called when the connection is active and ready to write to the response., +	 * Sub-classes should implement but never call this method directly., +		synchronized (this.responseLock) {, +			ServerHttpAsyncRequestControl control = this.asyncRequestControl;, +			this.asyncRequestControl = null;, +			this.response = null;, +, +			if (control != null && !control.isCompleted()) {, +		}, +				logger.trace("Writing to HTTP response: " + formattedFrame);, +			this.response.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));, +			if (isStreaming()) {, +				this.response.flush();, +			}, +			else {, +				resetRequest();, +			}, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.java, + * An abstract base class for use with HTTP transport SockJS sessions., +	private volatile SockJsFrameFormat frameFormat;, +, +, +	private final Object responseLock = new Object();]