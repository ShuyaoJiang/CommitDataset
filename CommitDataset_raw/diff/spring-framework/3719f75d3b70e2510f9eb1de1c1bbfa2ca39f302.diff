[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/RxNettyWebSocketSession.java, +import io.netty.channel.ChannelHandler;, +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +	 * The {@code ChannelHandler} name to use when inserting a, +	 * {@link WebSocketFrameAggregator} in the channel pipeline., +		ChannelHandlerContext frameDecoder = pipeline.context(frameDecoderName);, +		Assert.notNull(frameDecoder, "WebSocketFrameDecoder not found: " + frameDecoderName);, +		ChannelHandler frameAggregator = new WebSocketFrameAggregator(DEFAULT_FRAME_MAX_SIZE);, +		pipeline.addAfter(frameDecoder.name(), FRAME_AGGREGATOR_NAME, frameAggregator);, +		Observable<WebSocketMessage> messages = getDelegate(), +				.getInput(), +				.filter(frame -> !(frame instanceof CloseWebSocketFrame)), +				.map(super::toMessage);, +		return Flux.from(RxReactiveStreams.toPublisher(messages));, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/RxNettyWebSocketSession.java, +import io.netty.channel.ChannelHandler;, +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +	 * The {@code ChannelHandler} name to use when inserting a, +	 * {@link WebSocketFrameAggregator} in the channel pipeline., +		ChannelHandlerContext frameDecoder = pipeline.context(frameDecoderName);, +		Assert.notNull(frameDecoder, "WebSocketFrameDecoder not found: " + frameDecoderName);, +		ChannelHandler frameAggregator = new WebSocketFrameAggregator(DEFAULT_FRAME_MAX_SIZE);, +		pipeline.addAfter(frameDecoder.name(), FRAME_AGGREGATOR_NAME, frameAggregator);, +		Observable<WebSocketMessage> messages = getDelegate(), +				.getInput(), +				.filter(frame -> !(frame instanceof CloseWebSocketFrame)), +				.map(super::toMessage);, +		return Flux.from(RxReactiveStreams.toPublisher(messages));, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/ReactorNettyWebSocketClient.java, +		String[] protocols = beforeHandshake(url, headers, handler);, +					HandshakeInfo info = afterHandshake(url,  response.status().code(), responseHeaders);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/RxNettyWebSocketSession.java, +import io.netty.channel.ChannelHandler;, +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +	 * The {@code ChannelHandler} name to use when inserting a, +	 * {@link WebSocketFrameAggregator} in the channel pipeline., +		ChannelHandlerContext frameDecoder = pipeline.context(frameDecoderName);, +		Assert.notNull(frameDecoder, "WebSocketFrameDecoder not found: " + frameDecoderName);, +		ChannelHandler frameAggregator = new WebSocketFrameAggregator(DEFAULT_FRAME_MAX_SIZE);, +		pipeline.addAfter(frameDecoder.name(), FRAME_AGGREGATOR_NAME, frameAggregator);, +		Observable<WebSocketMessage> messages = getDelegate(), +				.getInput(), +				.filter(frame -> !(frame instanceof CloseWebSocketFrame)), +				.map(super::toMessage);, +		return Flux.from(RxReactiveStreams.toPublisher(messages));, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/ReactorNettyWebSocketClient.java, +		String[] protocols = beforeHandshake(url, headers, handler);, +					HandshakeInfo info = afterHandshake(url,  response.status().code(), responseHeaders);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/RxNettyWebSocketClient.java, +, +		String[] protocols = beforeHandshake(url, headers, handler);, +, +		return createRequest(url, headers, protocols), +					HandshakeInfo info = afterHandshake(url,  response.getStatus().code(), responseHeaders);, +	private WebSocketRequest<ByteBuf> createRequest(URI url, HttpHeaders headers, String[] protocols) {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/adapter/RxNettyWebSocketSession.java, +import io.netty.channel.ChannelHandler;, +import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;, +	 * The {@code ChannelHandler} name to use when inserting a, +	 * {@link WebSocketFrameAggregator} in the channel pipeline., +		ChannelHandlerContext frameDecoder = pipeline.context(frameDecoderName);, +		Assert.notNull(frameDecoder, "WebSocketFrameDecoder not found: " + frameDecoderName);, +		ChannelHandler frameAggregator = new WebSocketFrameAggregator(DEFAULT_FRAME_MAX_SIZE);, +		pipeline.addAfter(frameDecoder.name(), FRAME_AGGREGATOR_NAME, frameAggregator);, +		Observable<WebSocketMessage> messages = getDelegate(), +				.getInput(), +				.filter(frame -> !(frame instanceof CloseWebSocketFrame)), +				.map(super::toMessage);, +		return Flux.from(RxReactiveStreams.toPublisher(messages));, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/ReactorNettyWebSocketClient.java, +		String[] protocols = beforeHandshake(url, headers, handler);, +					HandshakeInfo info = afterHandshake(url,  response.status().code(), responseHeaders);, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/RxNettyWebSocketClient.java, +, +		String[] protocols = beforeHandshake(url, headers, handler);, +, +		return createRequest(url, headers, protocols), +					HandshakeInfo info = afterHandshake(url,  response.getStatus().code(), responseHeaders);, +	private WebSocketRequest<ByteBuf> createRequest(URI url, HttpHeaders headers, String[] protocols) {, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/socket/client/WebSocketClientSupport.java, +import java.net.URI;, +import java.util.Optional;, +, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import reactor.core.publisher.Mono;, +, +import org.springframework.util.Assert;, +import org.springframework.web.reactive.socket.HandshakeInfo;, +	protected final Log logger = LogFactory.getLog(getClass());, +, +, +	protected String[] beforeHandshake(URI url, HttpHeaders headers, WebSocketHandler handler) {, +		if (logger.isDebugEnabled()) {, +			logger.debug("Executing handshake to " + url);, +		}, +		return handler.getSubProtocols();, +	}, +, +	protected HandshakeInfo afterHandshake(URI url, int statusCode, HttpHeaders headers) {]