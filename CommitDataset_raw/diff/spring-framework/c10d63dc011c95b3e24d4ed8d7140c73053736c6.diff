[+++ b/spring-core/src/main/java/org/springframework/core/MethodParameter.java, + * Copyright 2002-2012 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, + * @author Nikita Tovstoles, + * @author Chris Beams, +, +	private static final Annotation[][] EMPTY_ANNOTATION_MATRIX = new Annotation[0][0];, +, +	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +, +	static final ConcurrentMap<Method, Annotation[][]> methodParamAnnotationsCache =, +			new ConcurrentHashMap<Method, Annotation[][]>();, +, +					getMethodParameterAnnotations(this.method) : this.constructor.getParameterAnnotations());, +	/**, +	 * Return the parameter annotations for the given method, retrieving cached values, +	 * if a lookup has already been performed for this method, otherwise perform a fresh, +	 * lookup and populate the cache with the result before returning. <strong>For, +	 * internal use only.</strong>, +	 * @param method the method to introspect for parameter annotations, +	 */, +	static Annotation[][] getMethodParameterAnnotations(Method method) {, +		Assert.notNull(method);, +, +		Annotation[][] result = methodParamAnnotationsCache.get(method);, +		if (result == null) {, +			result = method.getParameterAnnotations();, +, +			if(result.length == 0) {, +				result = EMPTY_ANNOTATION_MATRIX;, +			}, +			else {, +				for (int i = 0; i < result.length; i++) {, +					if (result[i].length == 0) {, +						result[i] = EMPTY_ANNOTATION_ARRAY;, +					}, +				}, +			}, +			methodParamAnnotationsCache.put(method, result);, +		}, +, +		//always return deep copy to prevent caller from modifying cache state, +		Annotation[][] resultCopy = new Annotation[result.length][0];, +		for(int i = 0; i < result.length; i++) {, +			resultCopy[i] = result[i].clone();, +		}, +		return resultCopy;, +	}, +, +++ b/spring-core/src/main/java/org/springframework/core/MethodParameter.java, + * Copyright 2002-2012 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, + * @author Nikita Tovstoles, + * @author Chris Beams, +, +	private static final Annotation[][] EMPTY_ANNOTATION_MATRIX = new Annotation[0][0];, +, +	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +, +	static final ConcurrentMap<Method, Annotation[][]> methodParamAnnotationsCache =, +			new ConcurrentHashMap<Method, Annotation[][]>();, +, +					getMethodParameterAnnotations(this.method) : this.constructor.getParameterAnnotations());, +	/**, +	 * Return the parameter annotations for the given method, retrieving cached values, +	 * if a lookup has already been performed for this method, otherwise perform a fresh, +	 * lookup and populate the cache with the result before returning. <strong>For, +	 * internal use only.</strong>, +	 * @param method the method to introspect for parameter annotations, +	 */, +	static Annotation[][] getMethodParameterAnnotations(Method method) {, +		Assert.notNull(method);, +, +		Annotation[][] result = methodParamAnnotationsCache.get(method);, +		if (result == null) {, +			result = method.getParameterAnnotations();, +, +			if(result.length == 0) {, +				result = EMPTY_ANNOTATION_MATRIX;, +			}, +			else {, +				for (int i = 0; i < result.length; i++) {, +					if (result[i].length == 0) {, +						result[i] = EMPTY_ANNOTATION_ARRAY;, +					}, +				}, +			}, +			methodParamAnnotationsCache.put(method, result);, +		}, +, +		//always return deep copy to prevent caller from modifying cache state, +		Annotation[][] resultCopy = new Annotation[result.length][0];, +		for(int i = 0; i < result.length; i++) {, +			resultCopy[i] = result[i].clone();, +		}, +		return resultCopy;, +	}, +]