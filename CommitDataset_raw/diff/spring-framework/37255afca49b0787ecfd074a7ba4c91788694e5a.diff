[+++ /dev/null, +++ /dev/null, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AliasFor.java, + * enforced, annotations must be <em>loaded</em> via {@link MergedAnnotations}., + * @see MergedAnnotations, +++ /dev/null, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AliasFor.java, + * enforced, annotations must be <em>loaded</em> via {@link MergedAnnotations}., + * @see MergedAnnotations, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +	public static AnnotatedElement forAnnotations(Annotation... annotations) {, +		return new AnnotatedElementForAnnotations(annotations);, +		return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));, +		return getAnnotations(element).stream(annotationType), +				.anyMatch(MergedAnnotation::isMetaPresent);, +		return getAnnotations(element).stream(annotationName), +				.anyMatch(MergedAnnotation::isMetaPresent);, +		return getAnnotations(element).isPresent(annotationType);, +		return getAnnotations(element).isPresent(annotationName);, +, +		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {, +			return null;, +		}, +		A annotation = AnnotationsScanner.getDeclaredAnnotation(element, annotationType);, +		if (annotation != null) {, +			return AnnotationUtils.synthesizeAnnotation(annotation, element);, +		}, +		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {, +			return null;, +		}, +		return getAnnotations(element), +				.synthesize(MergedAnnotation::isPresent).orElse(null);, +		return getAnnotations(element).stream(annotationType), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		return getAnnotations(element).stream(), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		return getRepeatableAnnotations(element, containerType, annotationType), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		// Shortcut: directly present on the element, with no processing needed?, +		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {, +			return false;, +		}, +		if (AnnotationsScanner.getDeclaredAnnotation(element, annotationType) != null) {, +			return true;, +		}, +		return findAnnotations(element).isPresent(annotationType);, +		A annotation = AnnotationsScanner.getDeclaredAnnotation(element, annotationType);, +		if (annotation != null) {, +			return AnnotationUtils.synthesizeAnnotation(annotation, element);, +		}, +		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {, +			return null;, +		}, +		return findAnnotations(element), +				.synthesize(MergedAnnotation::isPresent).orElse(null);, +		return findAnnotations(element).stream(annotationType), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		return findAnnotations(element).stream(), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		return findRepeatableAnnotations(element, containerType, annotationType), +				.collect(MergedAnnotationCollectors.toAnnotationSet());, +		return Comparator.<MergedAnnotation<A>> comparingInt(, +				MergedAnnotation::getAggregateIndex).reversed();, +, +	/**, +	 * Adapted {@link AnnotatedElement} that hold specific annotations., +	 */, +	private static class AnnotatedElementForAnnotations implements AnnotatedElement {, +, +		private final Annotation[] annotations;, +, +		AnnotatedElementForAnnotations(Annotation... annotations) {, +			this.annotations = annotations;, +		}, +, +		@Override, +		@SuppressWarnings("unchecked"), +		@Nullable, +		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {, +			for (Annotation annotation : this.annotations) {, +				if (annotation.annotationType() == annotationClass) {, +					return (T) annotation;, +				}, +			}, +			return null;, +		}, +, +		@Override, +		public Annotation[] getAnnotations() {, +			return this.annotations;, +		}, +, +		@Override, +		public Annotation[] getDeclaredAnnotations() {, +			return this.annotations;, +		}, +, +	};, +, +++ /dev/null]