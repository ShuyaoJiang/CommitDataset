[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2014 the original author or authors., +import java.io.Closeable;, +public interface WebSocketSession extends Closeable {, +	 * {@link org.springframework.web.socket.client.WebSocketClient} handshake methods., +	 * Send a WebSocket message: either {@link TextMessage} or {@link BinaryMessage}., +	 */, +	void sendMessage(WebSocketMessage<?> message) throws IOException;, +, +	/**, +	@Override, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/WebSocketSession.java, + * Copyright 2002-2014 the original author or authors., +import java.io.Closeable;, +public interface WebSocketSession extends Closeable {, +	 * {@link org.springframework.web.socket.client.WebSocketClient} handshake methods., +	 * Send a WebSocket message: either {@link TextMessage} or {@link BinaryMessage}., +	 */, +	void sendMessage(WebSocketMessage<?> message) throws IOException;, +, +	/**, +	@Override, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractSockJsSession.java, +	private static enum State {NEW, OPEN, CLOSED}, +, +	protected final Log logger = LogFactory.getLog(getClass());, +, +, +	// Message sending, +, +	public final void sendMessage(WebSocketMessage<?> message) throws IOException {, +		Assert.state(!isClosed(), "Cannot send a message when session is closed");, +		if (!(message instanceof TextMessage)) {, +			throw new IllegalArgumentException("Expected text message: " + message);, +		}, +		sendMessageInternal(((TextMessage) message).getPayload());, +	}, +, +	protected abstract void sendMessageInternal(String message) throws IOException;, +, +, +	// Lifecycle related methods, +, +	 * Performs cleanup and notify the {@link WebSocketHandler}., +	 * Performs cleanup and notify the {@link WebSocketHandler}., +	@Override, +	public long getTimeSinceLastActive() {, +		if (isNew()) {, +			return (System.currentTimeMillis() - this.timeCreated);, +			return (isActive() ? 0 : System.currentTimeMillis() - this.timeLastActive);, +	/**, +	 * Should be invoked whenever the session becomes inactive., +	 */, +	protected void updateLastActiveTime() {, +		this.timeLastActive = System.currentTimeMillis();, +	}, +, +	@Override, +	public void disableHeartbeat() {, +		this.heartbeatDisabled = true;, +		cancelHeartbeat();, +	}, +, +		Assert.state(this.config.getTaskScheduler() != null, "Expected SockJS TaskScheduler");, +, +	/**, +	 * Polling and Streaming sessions periodically close the current HTTP request and, +	 * wait for the next request to come through. During this "downtime" the session is, +	 * still open but inactive and unable to send messages and therefore has to buffer, +	 * them temporarily. A WebSocket session by contrast is stateful and remain active, +	 * until closed., +	 */, +	public abstract boolean isActive();, +, +	/**, +	 * Actually close the underlying WebSocket session or in the case of HTTP, +	 * transports complete the underlying request., +	 */, +	protected abstract void disconnect(CloseStatus status) throws IOException;, +, +, +	// Frame writing, +, +	/**, +	 * For internal use within a TransportHandler and the (TransportHandler-specific), +	 * session class., +	 */, +	protected void writeFrame(SockJsFrame frame) throws SockJsTransportFailureException {, +		if (logger.isTraceEnabled()) {, +			logger.trace("Preparing to write " + frame);, +		}, +		try {, +			writeFrameInternal(frame);, +		}, +		catch (Throwable ex) {, +			logWriteFrameFailure(ex);, +			try {, +				// Force disconnect (so we won't try to send close frame), +				disconnect(CloseStatus.SERVER_ERROR);, +			}]