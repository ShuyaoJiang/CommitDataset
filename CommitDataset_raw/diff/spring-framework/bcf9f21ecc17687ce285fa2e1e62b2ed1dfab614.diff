[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {, +			this.cachedReadAccessor = null;, +		}, +			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {, +			this.cachedWriteAccessor = null;, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java, +			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {, +			this.cachedReadAccessor = null;, +		}, +			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {, +			this.cachedWriteAccessor = null;, +		}, +++ b/spring-expression/src/test/java/org/springframework/expression/spel/PropertyAccessTests.java, + * Copyright 2002-2017 the original author or authors., +import java.util.Collections;, +import java.util.Map;, + * @author Juergen Hoeller, +	@Test, +	public void shouldAlwaysUsePropertyAccessorFromEvaluationContext() {, +		SpelExpressionParser parser = new SpelExpressionParser();, +		Expression expression = parser.parseExpression("name");, +, +		StandardEvaluationContext context = new StandardEvaluationContext();, +		context.addPropertyAccessor(new ConfigurablePropertyAccessor(Collections.singletonMap("name", "Ollie")));, +		assertEquals("Ollie", expression.getValue(context));, +, +		context = new StandardEvaluationContext();, +		context.addPropertyAccessor(new ConfigurablePropertyAccessor(Collections.singletonMap("name", "Jens")));, +		assertEquals("Jens", expression.getValue(context));, +	}, +, +, +	private static class ConfigurablePropertyAccessor implements PropertyAccessor {, +, +		private final Map<String, Object> values;, +, +		public ConfigurablePropertyAccessor(Map<String, Object> values) {, +			this.values = values;, +		}, +, +		@Override, +		public Class<?>[] getSpecificTargetClasses() {, +			return null;, +		}, +, +		@Override, +		public boolean canRead(EvaluationContext context, Object target, String name) {, +			return true;, +		}, +, +		@Override, +		public TypedValue read(EvaluationContext context, Object target, String name) {, +			return new TypedValue(this.values.get(name));, +		}, +, +		@Override, +		public boolean canWrite(EvaluationContext context, Object target, String name) {, +			return false;, +		}, +, +		@Override, +		public void write(EvaluationContext context, Object target, String name, Object newValue) {, +		}, +	}, +]