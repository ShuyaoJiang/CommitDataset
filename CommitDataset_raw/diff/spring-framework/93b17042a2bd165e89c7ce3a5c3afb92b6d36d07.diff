[+++ b/org.springframework.context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2009 the original author or authors., + * <p>Note that the Lifecycle interface is only supported on <b>top-level singleton beans</b>., + * On any other component, the Lifecycle interface will remain undetected and hence ignored., + * Also, note that the extended {@link SmartLifecycle} interface provides more sophisticated, + * integration with the container's startup and shutdown phases., + *, + * @see SmartLifecycle, +++ b/org.springframework.context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2009 the original author or authors., + * <p>Note that the Lifecycle interface is only supported on <b>top-level singleton beans</b>., + * On any other component, the Lifecycle interface will remain undetected and hence ignored., + * Also, note that the extended {@link SmartLifecycle} interface provides more sophisticated, + * integration with the container's startup and shutdown phases., + *, + * @see SmartLifecycle, +++ b/org.springframework.context/src/main/java/org/springframework/context/SmartLifecycle.java, + *, + * <p>This interface extends {@link Phased}, and the {@link #getPhase()} method's, + *, + * <p>Example: if component B depends on component A having already started, then, + *, + * <p>Any explicit "depends-on" relationship will take precedence over, + *, + * <p>Any Lifecycle components within the context that do not also implement, + * <p>Note that, due to the auto-startup support in SmartLifecycle,, + * a SmartLifecycle bean instance will get initialized on startup of the, + * application context in any case. As a consequence, the bean definition, + * lazy-init flag has very limited actual effect on SmartLifecycle beans., + *, +	 * <p>The provided callback is used by the LifecycleProcessor to support an, +++ b/org.springframework.context/src/main/java/org/springframework/context/Lifecycle.java, + * Copyright 2002-2009 the original author or authors., + * <p>Note that the Lifecycle interface is only supported on <b>top-level singleton beans</b>., + * On any other component, the Lifecycle interface will remain undetected and hence ignored., + * Also, note that the extended {@link SmartLifecycle} interface provides more sophisticated, + * integration with the container's startup and shutdown phases., + *, + * @see SmartLifecycle, +++ b/org.springframework.context/src/main/java/org/springframework/context/SmartLifecycle.java, + *, + * <p>This interface extends {@link Phased}, and the {@link #getPhase()} method's, + *, + * <p>Example: if component B depends on component A having already started, then, + *, + * <p>Any explicit "depends-on" relationship will take precedence over, + *, + * <p>Any Lifecycle components within the context that do not also implement, + * <p>Note that, due to the auto-startup support in SmartLifecycle,, + * a SmartLifecycle bean instance will get initialized on startup of the, + * application context in any case. As a consequence, the bean definition, + * lazy-init flag has very limited actual effect on SmartLifecycle beans., + *, +	 * <p>The provided callback is used by the LifecycleProcessor to support an, +++ b/org.springframework.context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java, + * @author Juergen Hoeller, +		Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory);, +	// Lifecycle implementation, +		startBeans(false);, +		this.running = true;, +		stopBeans();, +		startBeans(true);, +		this.running = true;, +		stopBeans();, +		this.running = false;, +	public boolean isRunning() {, +		return this.running;, +	}, +, +, +	// internal helpers, +, +	private void stopBeans() {, +		Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();, +		Map<Integer, LifecycleGroup> phases = new HashMap<Integer, LifecycleGroup>();, +		for (Map.Entry<String, Lifecycle> entry : lifecycleBeans.entrySet()) {, +			Lifecycle lifecycle = entry.getValue();, +			int shutdownOrder = getPhase(lifecycle);, +			LifecycleGroup group = phases.get(shutdownOrder);, +			if (group == null) {, +				group = new LifecycleGroup(shutdownOrder, this.timeoutPerShutdownPhase, lifecycleBeans);, +				phases.put(shutdownOrder, group);, +			}, +			group.add(entry.getKey(), lifecycle);, +		}, +		if (phases.size() > 0) {, +			List<Integer> keys = new ArrayList<Integer>(phases.keySet());, +			Collections.sort(keys, Collections.reverseOrder());, +			for (Integer key : keys) {, +				phases.get(key).stop();, +			}, +		}, +	}, +, +		String[] beanNames = this.beanFactory.getBeanNamesForType(Lifecycle.class, false, false);, +			if (this.beanFactory.containsSingleton(beanName) ||, +					SmartLifecycle.class.isAssignableFrom(this.beanFactory.getType(beanName))) {, +				Object bean = this.beanFactory.getBean(beanName);, +				if (!this.equals(bean)) {, +		}]