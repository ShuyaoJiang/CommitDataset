[+++ b/spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java, + * Copyright 2002-2014 the original author or authors., + * Delegate for creating a variety of {@link javax.persistence.EntityManager}, + * proxies that follow the JPA spec's semantics for "extended" EntityManagers., + * <p>Supports several different variants of "extended" EntityManagers:, + * in particular, an "application-managed extended EntityManager", as defined, + * by {@link javax.persistence.EntityManagerFactory#createEntityManager()},, + * as well as a "container-managed extended EntityManager", as defined by, + * {@link javax.persistence.PersistenceContextType#EXTENDED}., + * <p>The original difference between "application-managed" and "container-managed", + * was the need for explicit joining of an externally managed transaction through, + * the {@link EntityManager#joinTransaction()} method in the "application" case, + * versus the automatic joining on each user-level EntityManager operation in the, + * "container" case. As of JPA 2.1, both join modes are available with both kinds of, + * EntityManagers, so the difference between "application-" and "container-managed", + * is now primarily in the join mode default and in the restricted lifecycle of a, + * container-managed EntityManager (i.e. tied to the object that it is injected into)., + *, + * @author Rod Johnson, + * @see javax.persistence.EntityManagerFactory#createEntityManager(), + * @see javax.persistence.PersistenceContextType#EXTENDED, + * @see javax.persistence.EntityManager#joinTransaction(), + * @see SharedEntityManagerCreator, +	 * Create an application-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create an application-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create a container-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create a container-managed extended EntityManager proxy., +	 * Create a container-managed extended EntityManager proxy., +	 * Create a container-managed extended EntityManager proxy., +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java, + * Copyright 2002-2014 the original author or authors., + * Delegate for creating a variety of {@link javax.persistence.EntityManager}, + * proxies that follow the JPA spec's semantics for "extended" EntityManagers., + * <p>Supports several different variants of "extended" EntityManagers:, + * in particular, an "application-managed extended EntityManager", as defined, + * by {@link javax.persistence.EntityManagerFactory#createEntityManager()},, + * as well as a "container-managed extended EntityManager", as defined by, + * {@link javax.persistence.PersistenceContextType#EXTENDED}., + * <p>The original difference between "application-managed" and "container-managed", + * was the need for explicit joining of an externally managed transaction through, + * the {@link EntityManager#joinTransaction()} method in the "application" case, + * versus the automatic joining on each user-level EntityManager operation in the, + * "container" case. As of JPA 2.1, both join modes are available with both kinds of, + * EntityManagers, so the difference between "application-" and "container-managed", + * is now primarily in the join mode default and in the restricted lifecycle of a, + * container-managed EntityManager (i.e. tied to the object that it is injected into)., + *, + * @author Rod Johnson, + * @see javax.persistence.EntityManagerFactory#createEntityManager(), + * @see javax.persistence.PersistenceContextType#EXTENDED, + * @see javax.persistence.EntityManager#joinTransaction(), + * @see SharedEntityManagerCreator, +	 * Create an application-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create an application-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create a container-managed extended EntityManager proxy., +	 * @param rawEntityManager the raw EntityManager to decorate, +	 * Create a container-managed extended EntityManager proxy., +	 * Create a container-managed extended EntityManager proxy., +	 * Create a container-managed extended EntityManager proxy., +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/SharedEntityManagerCreator.java, + * Copyright 2002-2014 the original author or authors., +, + * Delegate for creating a shareable JPA {@link javax.persistence.EntityManager}, + * reference for a given {@link javax.persistence.EntityManagerFactory}., + * <p>A shared EntityManager will behave just like an EntityManager fetched from, + * an application server's JNDI environment, as defined by the JPA specification., + * It will delegate all calls to the current transactional EntityManager, if any;, + * otherwise it will fall back to a newly created EntityManager per operation., + *, + * <p>For a behavioral definition of such a shared transactional EntityManager,, + * see {@link javax.persistence.PersistenceContextType#TRANSACTION} and its, + * discussion in the JPA spec document. This is also the default being used, + * for the annotation-based {@link javax.persistence.PersistenceContext#type()}., + * @see javax.persistence.PersistenceContext, + * @see javax.persistence.PersistenceContextType#TRANSACTION, + * @see ExtendedEntityManagerCreator, +	 * Create a transactional EntityManager proxy for the given EntityManagerFactory., +		private EntityManager em;, +					// Actual execution of the query: close the EntityManager right, +					// afterwards, since that was the only reason we kept it open., +					this.em = null;, +, +		@Override, +		protected void finalize() {, +			// Trigger explicit EntityManager.close() call on garbage collection,, +			// in particular for open/close statistics to be in sync. This is, +			// only relevant if the Query object has not been executed, e.g., +			// when just used for the early validation of query definitions., +			EntityManagerFactoryUtils.closeEntityManager(this.em);, +		}]