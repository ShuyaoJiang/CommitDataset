[+++ b/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/ParameterAutowireUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.Constructor;, +import java.lang.reflect.Executable;, +import org.springframework.util.ClassUtils;, +	private static final AnnotatedElement EMPTY_ANNOTATED_ELEMENT = new AnnotatedElement() {, +, +		@Override, +		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {, +			return null;, +		}, +, +		@Override, +		public Annotation[] getAnnotations() {, +			return new Annotation[0];, +		}, +, +		@Override, +		public Annotation[] getDeclaredAnnotations() {, +			return new Annotation[0];, +		}, +	};, +, +, +, +	 * @param parameter the parameter whose dependency should be autowired, +	 * @param parameterIndex the index of the parameter, +	static boolean isAutowirable(Parameter parameter, int parameterIndex) {, +		if (ApplicationContext.class.isAssignableFrom(parameter.getType())) {, +			return true;, +		}, +		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);, +		return AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class), +				|| AnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class), +				|| AnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class);, +	 * @param parameterIndex the index of the parameter, +	static Object resolveDependency(Parameter parameter, int parameterIndex, Class<?> containingClass, ApplicationContext applicationContext) {, +		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);, +		boolean required = findMergedAnnotation(annotatedParameter, Autowired.class).map(Autowired::required).orElse(true);, +	/**, +	 * Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up, +	 * annotations directly on a {@link Parameter} will fail for inner class, +	 * constructors., +	 *, +	 * <h4>Bug in javac in JDK &lt; 9</h4>, +	 * <p>The parameter annotations array in the compiled byte code excludes an entry, +	 * for the implicit <em>enclosing instance</em> parameter for an inner class, +	 * constructor., +	 *, +	 * <h4>Workaround</h4>, +	 * <p>This method provides a workaround for this off-by-one error by allowing the, +	 * caller to access annotations on the preceding {@link Parameter} object (i.e.,, +	 * {@code index - 1}). If the supplied {@code index} is zero, this method returns, +	 * an empty {@code AnnotatedElement}., +	 *, +	 * <h4>WARNING</h4>, +	 * <p>The {@code AnnotatedElement} returned by this method should never be cast and, +	 * treated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},, +	 * {@link Parameter#getType()}, etc.) will not match those for the declared parameter, +	 * at the given index in an inner class constructor., +	 *, +	 * @return the supplied {@code parameter} or the <em>effective</em> {@code Parameter}, +	 * if the aforementioned bug is in effect, +	 */, +	private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {, +		Executable executable = parameter.getDeclaringExecutable();, +, +		if (executable instanceof Constructor &&, +				ClassUtils.isInnerClass(executable.getDeclaringClass()) &&, +				executable.getParameterAnnotations().length == executable.getParameterCount() - 1) {, +, +			// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter, +			// for inner classes, so access it with the actual parameter index lowered by 1, +			return (index == 0) ? EMPTY_ANNOTATED_ELEMENT : executable.getParameters()[index - 1];, +		}, +, +		return parameter;, +	}, +, +++ b/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/ParameterAutowireUtils.java, + * Copyright 2002-2018 the original author or authors., +import java.lang.reflect.Constructor;, +import java.lang.reflect.Executable;, +import org.springframework.util.ClassUtils;, +	private static final AnnotatedElement EMPTY_ANNOTATED_ELEMENT = new AnnotatedElement() {, +, +		@Override, +		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {, +			return null;, +		}, +, +		@Override, +		public Annotation[] getAnnotations() {, +			return new Annotation[0];, +		}, +, +		@Override, +		public Annotation[] getDeclaredAnnotations() {, +			return new Annotation[0];, +		}]