[+++ b/spring-core/src/main/java/org/springframework/core/convert/ConversionFailedException.java, + * Copyright 2002-2015 the original author or authors., +		super("Failed to convert from type [" + sourceType + "] to type [" + targetType +, +				"] for value '" + ObjectUtils.nullSafeToString(value) + "'", cause);, +++ b/spring-core/src/main/java/org/springframework/core/convert/ConversionFailedException.java, + * Copyright 2002-2015 the original author or authors., +		super("Failed to convert from type [" + sourceType + "] to type [" + targetType +, +				"] for value '" + ObjectUtils.nullSafeToString(value) + "'", cause);, +++ b/spring-core/src/main/java/org/springframework/core/convert/ConverterNotFoundException.java, + * Copyright 2002-2015 the original author or authors., +		super("No converter found capable of converting from type [" + sourceType + "] to type [" + targetType + "]");, +	 * Return the source type that was requested to convert from., +	 * Return the target type that was requested to convert to., +++ b/spring-core/src/main/java/org/springframework/core/convert/ConversionFailedException.java, + * Copyright 2002-2015 the original author or authors., +		super("Failed to convert from type [" + sourceType + "] to type [" + targetType +, +				"] for value '" + ObjectUtils.nullSafeToString(value) + "'", cause);, +++ b/spring-core/src/main/java/org/springframework/core/convert/ConverterNotFoundException.java, + * Copyright 2002-2015 the original author or authors., +		super("No converter found capable of converting from type [" + sourceType + "] to type [" + targetType + "]");, +	 * Return the source type that was requested to convert from., +	 * Return the target type that was requested to convert to., +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java, +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	// Cache for the latest to-method resolved on a given Class, +	private static final Map<Class<?>, Method> toMethodCache =, +			new ConcurrentReferenceHashMap<Class<?>, Method>(16);, +, +	// Cache for the latest factory-method resolved on a given Class, +	private static final Map<Class<?>, Method> factoryMethodCache =, +			new ConcurrentReferenceHashMap<Class<?>, Method>(16);, +, +	// Cache for the latest factory-constructor resolved on a given Class, +	private static final Map<Class<?>, Constructor<?>> factoryConstructorCache =, +			new ConcurrentReferenceHashMap<Class<?>, Constructor<?>>(16);, +, +, +		if (sourceType.getType() == targetType.getType()) {, +		// No toInteger() method exists on java.lang.Number, and no static valueOf/of/from(java.lang.Number), +		// method or Integer(java.lang.Number) constructor exists on java.lang.Integer., +		Method method = toMethodCache.get(sourceClass);, +		if (method == null || !ClassUtils.isAssignable(targetClass, method.getReturnType())) {, +			method = ClassUtils.getMethodIfAvailable(sourceClass, "to" + targetClass.getSimpleName());, +			if (method == null || !ClassUtils.isAssignable(targetClass, method.getReturnType())) {, +				return null;, +			}, +			toMethodCache.put(sourceClass, method);, +		}, +		return method;, +		Method method = factoryMethodCache.get(targetClass);, +		if (method == null || method.getParameterTypes()[0] != sourceClass) {, +			method = ClassUtils.getStaticMethod(targetClass, "valueOf", sourceClass);, +					if (method == null) {, +						return null;, +			}, +			factoryMethodCache.put(targetClass, method);, +		}, +		Constructor<?> ctor = factoryConstructorCache.get(targetClass);, +		if (ctor == null || ctor.getParameterTypes()[0] != sourceClass) {, +			ctor = ClassUtils.getConstructorIfAvailable(targetClass, sourceClass);, +			if (ctor == null) {, +				return null;, +			}, +			factoryConstructorCache.put(targetClass, ctor);, +		}, +		return ctor;, +++ b/spring-core/src/main/java/org/springframework/core/convert/ConversionFailedException.java, + * Copyright 2002-2015 the original author or authors., +		super("Failed to convert from type [" + sourceType + "] to type [" + targetType +, +				"] for value '" + ObjectUtils.nullSafeToString(value) + "'", cause);, +++ b/spring-core/src/main/java/org/springframework/core/convert/ConverterNotFoundException.java, + * Copyright 2002-2015 the original author or authors., +		super("No converter found capable of converting from type [" + sourceType + "] to type [" + targetType + "]");, +	 * Return the source type that was requested to convert from., +	 * Return the target type that was requested to convert to., +++ b/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java, +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	// Cache for the latest to-method resolved on a given Class, +	private static final Map<Class<?>, Method> toMethodCache =, +			new ConcurrentReferenceHashMap<Class<?>, Method>(16);, +, +	// Cache for the latest factory-method resolved on a given Class, +	private static final Map<Class<?>, Method> factoryMethodCache =, +			new ConcurrentReferenceHashMap<Class<?>, Method>(16);, +, +	// Cache for the latest factory-constructor resolved on a given Class, +	private static final Map<Class<?>, Constructor<?>> factoryConstructorCache =, +			new ConcurrentReferenceHashMap<Class<?>, Constructor<?>>(16);, +, +, +		if (sourceType.getType() == targetType.getType()) {, +		// No toInteger() method exists on java.lang.Number, and no static valueOf/of/from(java.lang.Number), +		// method or Integer(java.lang.Number) constructor exists on java.lang.Integer., +		Method method = toMethodCache.get(sourceClass);, +		if (method == null || !ClassUtils.isAssignable(targetClass, method.getReturnType())) {, +			method = ClassUtils.getMethodIfAvailable(sourceClass, "to" + targetClass.getSimpleName());, +			if (method == null || !ClassUtils.isAssignable(targetClass, method.getReturnType())) {, +				return null;]