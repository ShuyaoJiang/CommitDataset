[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, + * Copyright 2002-2018 the original author or authors., +			return (candidateMethod.getDeclaringClass() != Object.class &&, +					BeanAnnotationHelper.isBeanAnnotated(candidateMethod));, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, + * Copyright 2002-2018 the original author or authors., +			return (candidateMethod.getDeclaringClass() != Object.class &&, +					BeanAnnotationHelper.isBeanAnnotated(candidateMethod));, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +import org.springframework.util.CollectionUtils;, +			if (hasSearchableMetaAnnotations(currentAnnotationType, annotationType, annotationName)) {, +				// Recursively search in meta-annotations, +					if (hasSearchableMetaAnnotations(currentAnnotationType, annotationType, annotationName)) {, +				if (!CollectionUtils.isEmpty(aggregatedResults)) {, +					T result;, +					if (resolvedMethod != method) {, +						result = searchWithFindSemantics(resolvedMethod, annotationType, annotationName,, +								containerType, processor, visited, metaDepth);, +					}, +					if (ifcs.length > 0) {, +						result = searchOnInterfaces(method, annotationType, annotationName, containerType,, +								processor, visited, metaDepth, ifcs);, +					}, +		for (Class<?> ifc : ifcs) {, +			if (AnnotationUtils.isInterfaceWithAnnotatedMethods(ifc)) {, +					Method equivalentMethod = ifc.getMethod(method.getName(), method.getParameterTypes());, +	 * Determine whether the current annotation type is generally expected to have, +	 * meta-annotations of the specified annotation type that we're searching for,, +	 * explicitly excluding some common cases that would never deliver any results., +	 */, +	private static boolean hasSearchableMetaAnnotations(Class<? extends Annotation> currentAnnotationType,, +			@Nullable Class<?> annotationType, @Nullable String annotationName) {, +, +		if (AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) {, +			return false;, +		}, +		if (currentAnnotationType == Nullable.class || currentAnnotationType.getName().startsWith("java")) {, +			// @Nullable and standard Java annotations are only meant to have standard Java meta-annotations, +			// -> not worth searching otherwise., +			return ((annotationType != null && annotationType.getName().startsWith("java")) ||, +					(annotationName != null && annotationName.startsWith("java")));, +		}, +		return true;, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java, + * Copyright 2002-2018 the original author or authors., +			return (candidateMethod.getDeclaringClass() != Object.class &&, +					BeanAnnotationHelper.isBeanAnnotated(candidateMethod));, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +import org.springframework.util.CollectionUtils;, +			if (hasSearchableMetaAnnotations(currentAnnotationType, annotationType, annotationName)) {, +				// Recursively search in meta-annotations, +					if (hasSearchableMetaAnnotations(currentAnnotationType, annotationType, annotationName)) {, +				if (!CollectionUtils.isEmpty(aggregatedResults)) {, +					T result;, +					if (resolvedMethod != method) {, +						result = searchWithFindSemantics(resolvedMethod, annotationType, annotationName,, +								containerType, processor, visited, metaDepth);, +					}, +					if (ifcs.length > 0) {, +						result = searchOnInterfaces(method, annotationType, annotationName, containerType,, +								processor, visited, metaDepth, ifcs);, +					}, +		for (Class<?> ifc : ifcs) {, +			if (AnnotationUtils.isInterfaceWithAnnotatedMethods(ifc)) {, +					Method equivalentMethod = ifc.getMethod(method.getName(), method.getParameterTypes());, +	 * Determine whether the current annotation type is generally expected to have, +	 * meta-annotations of the specified annotation type that we're searching for,, +	 * explicitly excluding some common cases that would never deliver any results., +	 */, +	private static boolean hasSearchableMetaAnnotations(Class<? extends Annotation> currentAnnotationType,, +			@Nullable Class<?> annotationType, @Nullable String annotationName) {, +, +		if (AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) {, +			return false;, +		}, +		if (currentAnnotationType == Nullable.class || currentAnnotationType.getName().startsWith("java")) {, +			// @Nullable and standard Java annotations are only meant to have standard Java meta-annotations, +			// -> not worth searching otherwise., +			return ((annotationType != null && annotationType.getName().startsWith("java")) ||, +					(annotationName != null && annotationName.startsWith("java")));, +		}, +		return true;, +	}, +, +	/**, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +import org.springframework.util.ClassUtils;, +	 * @param annotation the Annotation to check, +	public static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {, +		if (annotationType.isInstance(annotation)) {, +			return synthesizeAnnotation((A) annotation);, +		Class<? extends Annotation> annotatedElement = annotation.annotationType();, +		for (Class<?> ifc : ifcs) {, +			if (isInterfaceWithAnnotatedMethods(ifc)) {, +					Method equivalentMethod = ifc.getMethod(method.getName(), method.getParameterTypes());, +	static boolean isInterfaceWithAnnotatedMethods(Class<?> ifc) {, +		if (ClassUtils.isJavaLanguageInterface(ifc)) {]