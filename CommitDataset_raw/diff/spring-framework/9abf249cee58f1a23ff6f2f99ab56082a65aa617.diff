[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyUtils.java, + * Copyright 2002-2017 the original author or authors., +	 * Obtain the singleton target object behind the given proxy, if any., +	 * @param candidate the (potential) proxy to check, +	 * @return the singleton target object managed in a {@link SingletonTargetSource},, +	 * or {@code null} in any other case (not a proxy, not an existing singleton target), +	 * @since 4.3.8, +	 * @see Advised#getTargetSource(), +	 * @see SingletonTargetSource#getTarget(), +	 */, +	public static Object getSingletonTarget(Object candidate) {, +		if (candidate instanceof Advised) {, +			TargetSource targetSource = ((Advised) candidate).getTargetSource();, +			if (targetSource instanceof SingletonTargetSource) {, +				return ((SingletonTargetSource) targetSource).getTarget();, +			}, +		}, +		return null;, +	}, +, +	/**, +			current = getSingletonTarget(current);, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyUtils.java, + * Copyright 2002-2017 the original author or authors., +	 * Obtain the singleton target object behind the given proxy, if any., +	 * @param candidate the (potential) proxy to check, +	 * @return the singleton target object managed in a {@link SingletonTargetSource},, +	 * or {@code null} in any other case (not a proxy, not an existing singleton target), +	 * @since 4.3.8, +	 * @see Advised#getTargetSource(), +	 * @see SingletonTargetSource#getTarget(), +	 */, +	public static Object getSingletonTarget(Object candidate) {, +		if (candidate instanceof Advised) {, +			TargetSource targetSource = ((Advised) candidate).getTargetSource();, +			if (targetSource instanceof SingletonTargetSource) {, +				return ((SingletonTargetSource) targetSource).getTarget();, +			}, +		}, +		return null;, +	}, +, +	/**, +			current = getSingletonTarget(current);, +++ b/spring-context/src/main/java/org/springframework/context/event/AbstractApplicationEventMulticaster.java, +import org.springframework.aop.framework.AopProxyUtils;, +			// Explicitly remove target for a proxy, if registered already,, +			// in order to avoid double invocations of the same listener., +			Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);, +			if (singletonTarget instanceof ApplicationListener) {, +				this.defaultRetriever.applicationListeners.remove(singletonTarget);, +			}, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyUtils.java, + * Copyright 2002-2017 the original author or authors., +	 * Obtain the singleton target object behind the given proxy, if any., +	 * @param candidate the (potential) proxy to check, +	 * @return the singleton target object managed in a {@link SingletonTargetSource},, +	 * or {@code null} in any other case (not a proxy, not an existing singleton target), +	 * @since 4.3.8, +	 * @see Advised#getTargetSource(), +	 * @see SingletonTargetSource#getTarget(), +	 */, +	public static Object getSingletonTarget(Object candidate) {, +		if (candidate instanceof Advised) {, +			TargetSource targetSource = ((Advised) candidate).getTargetSource();, +			if (targetSource instanceof SingletonTargetSource) {, +				return ((SingletonTargetSource) targetSource).getTarget();, +			}, +		}, +		return null;, +	}, +, +	/**, +			current = getSingletonTarget(current);, +++ b/spring-context/src/main/java/org/springframework/context/event/AbstractApplicationEventMulticaster.java, +import org.springframework.aop.framework.AopProxyUtils;, +			// Explicitly remove target for a proxy, if registered already,, +			// in order to avoid double invocations of the same listener., +			Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);, +			if (singletonTarget instanceof ApplicationListener) {, +				this.defaultRetriever.applicationListeners.remove(singletonTarget);, +			}, +++ b/spring-context/src/test/java/org/springframework/context/event/ApplicationContextEventTests.java, + * Copyright 2002-2017 the original author or authors., +import java.util.LinkedList;, +import java.util.List;, +		assertEquals(2, listener1.seenEvents.size());, +		assertEquals(2, listener1.seenEvents.size());, +		assertEquals(2, listener1.seenEvents.size());, +	}, +, +	@Test, +	@SuppressWarnings("unchecked"), +	public void proxiedListenersMixedWithTargetListeners() {, +		MyOrderedListener1 listener1 = new MyOrderedListener1();, +		MyOrderedListener2 listener2 = new MyOrderedListener2(listener1);, +		ApplicationListener<ApplicationEvent> proxy1 = (ApplicationListener<ApplicationEvent>) new ProxyFactory(listener1).getProxy();, +		ApplicationListener<ApplicationEvent> proxy2 = (ApplicationListener<ApplicationEvent>) new ProxyFactory(listener2).getProxy();, +, +		SimpleApplicationEventMulticaster smc = new SimpleApplicationEventMulticaster();]