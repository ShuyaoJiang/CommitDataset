[+++ b/spring-framework-reference/src/beans.xml, +    out-of-the-box with Spring. In standalone applications it is common to, +    create an instance of <ulink, +    <!-- MLP: Beverly to review --> While XML has been the traditional format, +    for defining configuration metadata you can instruct the container to use, +    Java annotations or code as the metadata format by providng a small amount, +    of XML configuration to declaratively enable support for these additional, +    metadata formats.</para>, +        <classname>Resource</classname> paths are used to construct, +        applications contexts as described in <xref, +        linkend="resources-app-ctx" />.</para>, +        definitions from all these XML fragments. This constructor takes, +        multiple <interfacename>Resource</interfacename> locations, as was, +        shown in the previous section. Alternatively, use one or more, +        occurrences of the <literal>&lt;import/&gt;</literal> element to load, +        bean definitions from another file or files. For example:</para>, +      interface has a few other methods for retrieving beans, but ideally your, +      application code should never use them. Indeed, your application code, +      should have no calls to the <methodname>getBean</methodname> method at, +      all, and thus no dependency on Spring APIs at all. For example, Spring's, +      integration with web frameworks provides for dependency injection for, +      various web framework classes such as controllers and JSF-managed, +      beans.</para>, +    <emphasis>beans</emphasis>. These beans are created with the configuration, +    metadata that you supply to the container, for example, in the form of XML, +    <literal>&lt;bean/&gt;</literal> definitions.</para>, +    <para>In addition to bean definitions that contain information on how to, +    create a specific bean, the, +    <interfacename>ApplicationContext</interfacename> implementations also, +    permit the registration of existing objects that are created outside the, +    container, by users. This is done by accessing the ApplicationContext's, +    BeanFactory via the method <methodname>getBeanFactory</methodname> which, +    returns the BeanFactory implementation, +    <classname>DefaultListableBeanFactory</classname>., +      <para>You are not required to supply a name or id for a bean. If no name, +      or id is supplied explicitly, the container generates a unique name for, +      that bean. However, if you want to refer to that bean by name, through, +      the use of the <literal>ref</literal> element or <link lang="", +      you must provide a name. Motivations for not supplying a name are, +      related to using <link linkend="beans-inner-beans">inner beans</link>, +      and <link linkend="beans-factory-autowire">autowiring, +      collaborators</link>.</para>, +, +, +        being developed does not need to implement any specific interfaces or, +        to be coded in a specific fashion. Simply specifying the bean class, +        should suffice. However, depending on what type of IoC you use for, +        that specific bean, you may need a default (empty) constructor.</para>, +, +, +, +, +        <para>You can also configure a, +        <classname>java.util.Properties</classname> instance as:</para>, +        <para>The <literal>ref</literal> element is the final element inside a, +        <literal>&lt;constructor-arg/&gt;</literal> or, +        <literal>&lt;property/&gt;</literal> definition element. Here you set, +        the value of the specified property of a bean to be a reference to, +        another bean (a collaborator) managed by the container. The referenced, +        bean is a dependency of the bean whose property will be set, and it is, +        initialized on demand as needed before the property is set. (If the, +        collaborator is a singleton bean, it may be initialized already by the, +        container.) All references are ultimately a reference to another, +        object. Scoping and validation depend on whether you specify the, +        id/name of the other object through the, +        definition can specify both an initialization time dependency and, in, +        the case of <link, +        a corresponding destroy time dependency. Dependent beans that define a, +        <literal>depends-on</literal> relationship with a given bean are, +, +, +      a bean deployed into the container. When enabling checking for, +      unresolved dependencies all JavaBean properties of the bean must have, +      explicit values set for them in the bean definition or have their values, +      set via autowiring.<!--Please revise preceding sentence, wording doesn't track.--></para>, +      dependency checking via the <literal>dependency-check</literal>, +      attribute in a bean definition, which can have the following, +      values.</para>, +      <interfacename>ApplicationContextAware</interfacename> interface, and by, +      <link linkend="beans-factory-client">making a getBean("B") call to the, +      container</link> ask for (a typically new) bean B instance every time, +      bean A needs it. The following is an example of this approach:</para>, +        library to generate dynamically a subclass that overrides the, +        method.<!--Note was plain text; I made it a note and moved it up.--></para>, +      <para>In contrast to the other scopes, Spring does not manage the, +      complete lifecycle of a prototype bean: the container instantiates,, +      configures, and otherwise assembles a prototype object, and hands it to, +      the client, with no further record of that prototype instance. Thus,, +      although <emphasis>initialization</emphasis> lifecycle callback methods, +      are called on all objects regardless of scope, in the case of, +      prototypes, configured <emphasis>destruction</emphasis> lifecycle, +      callbacks are <emphasis>not</emphasis> called. The client code must, +      clean up prototype-scoped objects and release expensive resources that, +      the prototype bean(s) are holding. To get the Spring container to, +      release resources held by prototype-scoped beans, try using a custom, +      <link linkend="beans-factory-extension-bpp">bean post-processor</link>,, +      which holds a reference to beans that need to be cleaned up.</para>, +      <literal>new</literal> operator. All lifecycle management past that, +      point must be handled by the client. (For details on the lifecycle of a, +      bean in the Spring container, see <xref]