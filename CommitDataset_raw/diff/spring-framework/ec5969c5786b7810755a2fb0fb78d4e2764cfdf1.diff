[+++ b/spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java, +import java.util.Iterator;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.locks.ReentrantLock;, +	/** Minimum period between expiration checks */, +	private static final Duration EXPIRATION_CHECK_PERIOD = Duration.ofSeconds(60);, +, +, +	private final ConcurrentMap<String, InMemoryWebSession> sessions = new ConcurrentHashMap<>();, +, +	private volatile Instant nextExpirationCheckTime = Instant.now(this.clock).plus(EXPIRATION_CHECK_PERIOD);, +, +	private final ReentrantLock expirationCheckLock = new ReentrantLock();, +		// Force a check when clock changes.., +		this.nextExpirationCheckTime = Instant.now(this.clock);, +, +		Instant currentTime = Instant.now(this.clock);, +, +		if (!this.sessions.isEmpty() && !currentTime.isBefore(this.nextExpirationCheckTime)) {, +			checkExpiredSessions(currentTime);, +		}, +, +		else if (session.isExpired(currentTime)) {, +			session.updateLastAccessTime(currentTime);, +	private void checkExpiredSessions(Instant currentTime) {, +		if (this.expirationCheckLock.tryLock()) {, +			try {, +				Iterator<InMemoryWebSession> iterator = this.sessions.values().iterator();, +				while (iterator.hasNext()) {, +					InMemoryWebSession session = iterator.next();, +					if (session.isExpired(currentTime)) {, +						iterator.remove();, +						session.invalidate();, +					}, +				}, +			}, +			finally {, +				this.nextExpirationCheckTime = currentTime.plus(EXPIRATION_CHECK_PERIOD);, +				this.expirationCheckLock.unlock();, +			}, +		}, +	}, +, +			session.updateLastAccessTime(Instant.now(getClock()));, +		public InMemoryWebSession() {, +			return isExpired(Instant.now(getClock()));, +		}, +, +		private boolean isExpired(Instant currentTime) {, +			if (checkExpired(currentTime)) {, +		private boolean checkExpired(Instant currentTime) {, +					currentTime.minus(this.maxIdleTime).isAfter(this.lastAccessTime);, +		private void updateLastAccessTime(Instant currentTime) {, +			this.lastAccessTime = currentTime;, +++ b/spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java, +import java.util.Iterator;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.locks.ReentrantLock;, +	/** Minimum period between expiration checks */, +	private static final Duration EXPIRATION_CHECK_PERIOD = Duration.ofSeconds(60);, +, +, +	private final ConcurrentMap<String, InMemoryWebSession> sessions = new ConcurrentHashMap<>();, +, +	private volatile Instant nextExpirationCheckTime = Instant.now(this.clock).plus(EXPIRATION_CHECK_PERIOD);, +, +	private final ReentrantLock expirationCheckLock = new ReentrantLock();, +		// Force a check when clock changes.., +		this.nextExpirationCheckTime = Instant.now(this.clock);, +, +		Instant currentTime = Instant.now(this.clock);, +, +		if (!this.sessions.isEmpty() && !currentTime.isBefore(this.nextExpirationCheckTime)) {, +			checkExpiredSessions(currentTime);, +		}, +, +		else if (session.isExpired(currentTime)) {, +			session.updateLastAccessTime(currentTime);, +	private void checkExpiredSessions(Instant currentTime) {, +		if (this.expirationCheckLock.tryLock()) {, +			try {, +				Iterator<InMemoryWebSession> iterator = this.sessions.values().iterator();, +				while (iterator.hasNext()) {, +					InMemoryWebSession session = iterator.next();, +					if (session.isExpired(currentTime)) {, +						iterator.remove();, +						session.invalidate();, +					}, +				}, +			}, +			finally {, +				this.nextExpirationCheckTime = currentTime.plus(EXPIRATION_CHECK_PERIOD);, +				this.expirationCheckLock.unlock();, +			}, +		}, +	}, +, +			session.updateLastAccessTime(Instant.now(getClock()));, +		public InMemoryWebSession() {, +			return isExpired(Instant.now(getClock()));]