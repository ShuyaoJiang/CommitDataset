[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +				.doOnError(ex -> logger.error("Handling completed with error", ex)), +				.doOnSuccess(aVoid -> logger.debug("Handling completed with success"));, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +				.doOnError(ex -> logger.error("Handling completed with error", ex)), +				.doOnSuccess(aVoid -> logger.debug("Handling completed with success"));, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServletHttpHandlerAdapter.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import javax.servlet.DispatcherType;, +import javax.servlet.ServletException;, +import org.springframework.web.util.NestedServletException;, +	private static final String WRITE_ERROR_ATTRIBUTE_NAME = ServletHttpHandlerAdapter.class.getName() + ".ERROR";, +, +	public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {, +, +		if (DispatcherType.ASYNC.equals(request.getDispatcherType())) {, +			Throwable ex = (Throwable) request.getAttribute(WRITE_ERROR_ATTRIBUTE_NAME);, +			Assert.notNull(ex, "Unexpected async dispatch");, +			throw new NestedServletException("Write publisher error", ex);, +		}, +, +		AtomicBoolean isCompleted = new AtomicBoolean();, +		HandlerResultAsyncListener listener = new HandlerResultAsyncListener(isCompleted);, +		asyncContext.addListener(listener);, +		HandlerResultSubscriber subscriber = new HandlerResultSubscriber(asyncContext, isCompleted);, +	private static void runIfAsyncNotComplete(AsyncContext asyncContext, AtomicBoolean isCompleted, Runnable task) {, +			if (asyncContext.getRequest().isAsyncStarted() && isCompleted.compareAndSet(false, true)) {, +	private static class HandlerResultAsyncListener implements AsyncListener {, +, +		private final AtomicBoolean isCompleted;, +, +, +		public HandlerResultAsyncListener(AtomicBoolean isCompleted) {, +			this.isCompleted = isCompleted;, +		}, +			logger.debug("Timeout notification from Servlet container");, +			runIfAsyncNotComplete(context, this.isCompleted, context::complete);, +			logger.debug("Error notification from Servlet container");, +			runIfAsyncNotComplete(context, this.isCompleted, context::complete);, +		private final AtomicBoolean isCompleted;, +, +, +		public HandlerResultSubscriber(AsyncContext asyncContext, AtomicBoolean isCompleted) {, +			this.isCompleted = isCompleted;, +			logger.error("Handling completed with error", ex);, +			runIfAsyncNotComplete(this.asyncContext, this.isCompleted, () -> {, +				if (this.asyncContext.getResponse().isCommitted()) {, +					logger.debug("Dispatching into container to raise error");, +					this.asyncContext.getRequest().setAttribute(WRITE_ERROR_ATTRIBUTE_NAME, ex);, +					this.asyncContext.dispatch();, +				}, +				else {, +					try {, +						logger.debug("Setting response status code to 500");, +						this.asyncContext.getResponse().resetBuffer();, +						((HttpServletResponse) this.asyncContext.getResponse()).setStatus(500);, +					}, +					finally {, +					}, +				}, +			logger.debug("Handling completed with success");, +			runIfAsyncNotComplete(this.asyncContext, this.isCompleted, this.asyncContext::complete);, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java, +				.doOnError(ex -> logger.error("Handling completed with error", ex)), +				.doOnSuccess(aVoid -> logger.debug("Handling completed with success"));, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/ServletHttpHandlerAdapter.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import javax.servlet.DispatcherType;, +import javax.servlet.ServletException;, +import org.springframework.web.util.NestedServletException;, +	private static final String WRITE_ERROR_ATTRIBUTE_NAME = ServletHttpHandlerAdapter.class.getName() + ".ERROR";, +, +	public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {, +, +		if (DispatcherType.ASYNC.equals(request.getDispatcherType())) {, +			Throwable ex = (Throwable) request.getAttribute(WRITE_ERROR_ATTRIBUTE_NAME);, +			Assert.notNull(ex, "Unexpected async dispatch");, +			throw new NestedServletException("Write publisher error", ex);, +		}, +, +		AtomicBoolean isCompleted = new AtomicBoolean();, +		HandlerResultAsyncListener listener = new HandlerResultAsyncListener(isCompleted);, +		asyncContext.addListener(listener);, +		HandlerResultSubscriber subscriber = new HandlerResultSubscriber(asyncContext, isCompleted);, +	private static void runIfAsyncNotComplete(AsyncContext asyncContext, AtomicBoolean isCompleted, Runnable task) {, +			if (asyncContext.getRequest().isAsyncStarted() && isCompleted.compareAndSet(false, true)) {, +	private static class HandlerResultAsyncListener implements AsyncListener {, +, +		private final AtomicBoolean isCompleted;, +, +, +		public HandlerResultAsyncListener(AtomicBoolean isCompleted) {, +			this.isCompleted = isCompleted;, +		}, +			logger.debug("Timeout notification from Servlet container");, +			runIfAsyncNotComplete(context, this.isCompleted, context::complete);, +			logger.debug("Error notification from Servlet container");, +			runIfAsyncNotComplete(context, this.isCompleted, context::complete);, +		private final AtomicBoolean isCompleted;, +]