[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, + * Copyright 2002-2011 the original author or authors., + * Reflection-based {@link MethodResolver} used by default in, + * {@link StandardEvaluationContext} unless explicit method resolvers have been specified., + * @author Chris Beams, + * @see StandardEvaluationContext#addMethodResolver(MethodResolver), +			Method[] methods = getMethods(type);, +					Class<?>[] paramTypes = method.getParameterTypes();, +	/**, +	 * Return the set of methods for this type. The default implementation returns the, +	 * result of Class#getMethods for the given {@code type}, but subclasses may override, +	 * in order to alter the results, e.g. specifying static methods declared elsewhere., +	 *, +	 * @param type the class for which to return the methods, +	 * @since 3.1.1, +	 */, +	protected Method[] getMethods(Class<?> type) {, +		return type.getMethods();, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java, + * Copyright 2002-2011 the original author or authors., + * Reflection-based {@link MethodResolver} used by default in, + * {@link StandardEvaluationContext} unless explicit method resolvers have been specified., + * @author Chris Beams, + * @see StandardEvaluationContext#addMethodResolver(MethodResolver), +			Method[] methods = getMethods(type);, +					Class<?>[] paramTypes = method.getParameterTypes();, +	/**, +	 * Return the set of methods for this type. The default implementation returns the, +	 * result of Class#getMethods for the given {@code type}, but subclasses may override, +	 * in order to alter the results, e.g. specifying static methods declared elsewhere., +	 *, +	 * @param type the class for which to return the methods, +	 * @since 3.1.1, +	 */, +	protected Method[] getMethods(Class<?> type) {, +		return type.getMethods();, +	}, +, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/SpringEL300Tests.java, +import static org.junit.Assert.fail;, +import java.lang.reflect.Method;, +import org.springframework.expression.MethodResolver;, +		Map<String,String> m = new HashMap<String,String>();, +			return (((Map<?,?>) target).containsKey(name));, +			return new TypedValue(((Map<?,?>) target).get(name));, +			((Map<String, Object>) target).put(name, newValue);, +		public Class<?>[] getSpecificTargetClasses() {, +	/**, +	 * Should be accessing (setting) Goo.wibble field because 'bar' variable evaluates to, +	 * "wibble", +	 */, +		public Map<String,String> map = new HashMap<String,String>();, +		Map<String,Object> map = new LinkedHashMap<String,Object>();, +		Map<String,String> nameMap = new LinkedHashMap<String,String>();, +		List<?> value = (List<?>)exp.getValue(ctx);, +		List<?> value = (List<?>)exp.getValue(ctx);, +	 * Test whether {@link ReflectiveMethodResolver} follows Java Method Invocation, +	 * Conversion order. And more precisely that widening reference conversion is 'higher', +	 * than a unboxing conversion., +			public Map<String,String> m = new HashMap<String,String>();, +	/**, +	 * Test the ability to subclass the ReflectiveMethodResolver and change how it, +	 * determines the set of methods for a type., +	 */, +	@Test, +	public void testCustomStaticFunctions_SPR9038() {, +		try {, +			ExpressionParser parser = new SpelExpressionParser();, +			StandardEvaluationContext context = new StandardEvaluationContext();, +			List<MethodResolver> methodResolvers = new ArrayList<MethodResolver>();, +			methodResolvers.add(new ReflectiveMethodResolver() {, +				@Override, +				protected Method[] getMethods(Class<?> type) {, +					try {, +						return new Method[] {, +								Integer.class.getDeclaredMethod("parseInt", new Class[] {, +										String.class, Integer.TYPE }) };, +					} catch (NoSuchMethodException e1) {, +						return new Method[0];, +					}, +				}, +			});, +, +			context.setMethodResolvers(methodResolvers);, +			org.springframework.expression.Expression expression =, +					parser.parseExpression("parseInt('-FF', 16)");, +, +			Integer result = expression.getValue(context, "", Integer.class);, +			assertEquals("Equal assertion failed: ", -255, result.intValue());, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail("Unexpected exception: "+e.toString());, +		}, +	}, +]