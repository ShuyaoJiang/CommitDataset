[+++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/RequestMappingHandlerMapping.java, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +import java.util.Set;, +import java.util.TreeMap;, +import java.util.TreeSet;, +import org.springframework.http.HttpMethod;, +import org.springframework.web.bind.annotation.RequestMethod;, +	private final Map<RequestMappingInfo, HandlerMethod> methodMap = new TreeMap<>();, +					RequestMethod[] methods = annotation.method();, +					RequestMappingInfo info = new RequestMappingInfo(path, methods);, +					if (this.methodMap.containsKey(info)) {, +						throw new IllegalStateException("Duplicate mapping found for " + info);, +					}, +					methodMap.put(info, handlerMethod);, +		HttpMethod method = request.getMethod();, +		for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : this.methodMap.entrySet()) {, +			RequestMappingInfo info = entry.getKey();, +			if (path.equals(info.getPath()) && (info.getMethods().isEmpty() || info.getMethods().contains(RequestMethod.valueOf(method.name())))) {, +					logger.debug("Mapped " + method + " " + path + " to [" + entry.getValue() + "]");, +				return entry.getValue();, +			}, +		}, +		return null;, +	}, +, +, +	private static class RequestMappingInfo implements Comparable {, +, +		private String path;, +, +		private Set<RequestMethod> methods;, +, +, +		public RequestMappingInfo(String path, RequestMethod... methods) {, +			this(path, asList(methods));, +		}, +, +		public RequestMappingInfo(String path, Collection<RequestMethod> methods) {, +			this.path = path;, +			this.methods = new TreeSet<>(methods);, +		}, +, +, +		public String getPath() {, +			return path;, +		}, +, +		public Set<RequestMethod> getMethods() {, +			return methods;, +		}, +, +		private static List<RequestMethod> asList(RequestMethod... requestMethods) {, +			return (requestMethods != null ? Arrays.asList(requestMethods) : Collections.<RequestMethod>emptyList());, +		}, +, +		@Override, +		public int compareTo(Object o) {, +			RequestMappingInfo other = (RequestMappingInfo)o;, +			if (!this.path.equals(other.getPath())) {, +				return -1;, +			}, +			if (this.methods.isEmpty() && !other.methods.isEmpty()) {, +				return 1;, +			}, +			if (!this.methods.isEmpty() && other.methods.isEmpty()) {, +				return -1;, +			}, +			if (this.methods.equals(other.methods)) {, +				return 0;, +			}, +			return -1;, +		}, +++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/RequestMappingHandlerMapping.java, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +import java.util.Set;, +import java.util.TreeMap;, +import java.util.TreeSet;, +import org.springframework.http.HttpMethod;, +import org.springframework.web.bind.annotation.RequestMethod;, +	private final Map<RequestMappingInfo, HandlerMethod> methodMap = new TreeMap<>();, +					RequestMethod[] methods = annotation.method();, +					RequestMappingInfo info = new RequestMappingInfo(path, methods);, +					if (this.methodMap.containsKey(info)) {, +						throw new IllegalStateException("Duplicate mapping found for " + info);, +					}, +					methodMap.put(info, handlerMethod);, +		HttpMethod method = request.getMethod();, +		for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : this.methodMap.entrySet()) {, +			RequestMappingInfo info = entry.getKey();, +			if (path.equals(info.getPath()) && (info.getMethods().isEmpty() || info.getMethods().contains(RequestMethod.valueOf(method.name())))) {, +					logger.debug("Mapped " + method + " " + path + " to [" + entry.getValue() + "]");, +				return entry.getValue();, +			}, +		}]