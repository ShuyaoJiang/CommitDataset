[+++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +, +		MessageHeaders messageHeaders;, +		if (headers != null && headers instanceof MessageHeaders) {, +			MessageHeaderAccessor.getAccessor(), +, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +, +		MessageHeaders messageHeaders;, +		if (headers != null && headers instanceof MessageHeaders) {, +			MessageHeaderAccessor.getAccessor(), +, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/HeadersMethodArgumentResolver.java, +import org.springframework.util.Assert;, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			return (accessor != null ? accessor : new MessageHeaderAccessor(message));, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			if (accessor != null && paramType.isAssignableFrom(accessor.getClass())) {, +				return accessor;, +				Method method = ReflectionUtils.findMethod(paramType, "wrap", Message.class);, +				Assert.notNull(method, "Cannot create accessor of type " + paramType + " for message " +  message);, +				return ReflectionUtils.invokeMethod(method, null, message);, +			}, +		}, +		else {, +			throw new IllegalStateException(, +					"Unexpected method parameter type " + paramType + "in method " + parameter.getMethod() + ". ", +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +, +		MessageHeaders messageHeaders;, +		if (headers != null && headers instanceof MessageHeaders) {, +			MessageHeaderAccessor.getAccessor(), +, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/HeadersMethodArgumentResolver.java, +import org.springframework.util.Assert;, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			return (accessor != null ? accessor : new MessageHeaderAccessor(message));, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			if (accessor != null && paramType.isAssignableFrom(accessor.getClass())) {, +				return accessor;, +				Method method = ReflectionUtils.findMethod(paramType, "wrap", Message.class);, +				Assert.notNull(method, "Cannot create accessor of type " + paramType + " for message " +  message);, +				return ReflectionUtils.invokeMethod(method, null, message);, +			}, +		}, +		else {, +			throw new IllegalStateException(, +					"Unexpected method parameter type " + paramType + "in method " + parameter.getMethod() + ". ", +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/AbstractMethodMessageHandler.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +		MessageHeaderAccessor headerAccessor = MessageHeaderAccessor.getMutableAccessor(message);, +		headerAccessor.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, lookupDestination);, +		message = MessageBuilder.createMessage(message.getPayload(), headerAccessor.getMessageHeaders());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +, +		MessageHeaders messageHeaders;, +		if (headers != null && headers instanceof MessageHeaders) {, +			MessageHeaderAccessor.getAccessor(), +, +		}, +, +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/HeadersMethodArgumentResolver.java, +import org.springframework.util.Assert;, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			return (accessor != null ? accessor : new MessageHeaderAccessor(message));, +			MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);, +			if (accessor != null && paramType.isAssignableFrom(accessor.getClass())) {, +				return accessor;, +				Method method = ReflectionUtils.findMethod(paramType, "wrap", Message.class);, +				Assert.notNull(method, "Cannot create accessor of type " + paramType + " for message " +  message);, +				return ReflectionUtils.invokeMethod(method, null, message);, +			}, +		}, +		else {, +			throw new IllegalStateException(, +					"Unexpected method parameter type " + paramType + "in method " + parameter.getMethod() + ". ", +++ b/spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/AbstractMethodMessageHandler.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +		MessageHeaderAccessor headerAccessor = MessageHeaderAccessor.getMutableAccessor(message);, +		headerAccessor.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, lookupDestination);, +		message = MessageBuilder.createMessage(message.getPayload(), headerAccessor.getMessageHeaders());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessageTypeMessageCondition.java, +		Object actualMessageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());, +		Object actualMessageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());, +++ b/spring-messaging/src/main/java/org/springframework/messaging/core/AbstractMessageSendingTemplate.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +, +		MessageHeaders messageHeaders;, +		if (headers != null && headers instanceof MessageHeaders) {, +			MessageHeaderAccessor.getAccessor()]