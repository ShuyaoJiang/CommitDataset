[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +			// Track which attribute values have already been replaced so that we can short, +			// circuit the search algorithms., +			Set<String> valuesAlreadyReplaced = new HashSet<String>();, +, +					if (valuesAlreadyReplaced.contains(attributeOverrideName)) {, +						continue;, +, +					List<String> targetAttributeNames = new ArrayList<String>();, +					targetAttributeNames.add(attributeOverrideName);, +					valuesAlreadyReplaced.add(attributeOverrideName);, +, +					// Ensure all aliased attributes in the target annotation are also overridden. (SPR-14069), +					List<String> aliases = AnnotationUtils.getAttributeAliasMap(targetAnnotationType).get(attributeOverrideName);, +					if (aliases != null) {, +						for (String alias : aliases) {, +							if (!valuesAlreadyReplaced.contains(alias)) {, +								targetAttributeNames.add(alias);, +								valuesAlreadyReplaced.add(alias);, +							}, +						}, +					}, +, +					overrideAttributes(element, annotation, attributes, attributeName, targetAttributeNames);, +		private void overrideAttributes(AnnotatedElement element, Annotation annotation, AnnotationAttributes attributes,, +				String sourceAttributeName, List<String> targetAttributeNames) {, +			Object adaptedValue = AnnotationUtils.adaptValue(element, value, this.classValuesAsString,, +				this.nestedAnnotationsAsMap);, +, +			for (String targetAttributeName : targetAttributeNames) {, +		private void overrideAttribute(AnnotatedElement element, Annotation annotation, AnnotationAttributes attributes,, +				String sourceAttributeName, String targetAttributeName) {, +, +			Object value = AnnotationUtils.getValue(annotation, sourceAttributeName);, +			Object adaptedValue = AnnotationUtils.adaptValue(element, value, this.classValuesAsString,, +				this.nestedAnnotationsAsMap);, +			attributes.put(targetAttributeName, adaptedValue);, +		}, +, +	}, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +			// Track which attribute values have already been replaced so that we can short, +			// circuit the search algorithms., +			Set<String> valuesAlreadyReplaced = new HashSet<String>();, +, +					if (valuesAlreadyReplaced.contains(attributeOverrideName)) {, +						continue;, +, +					List<String> targetAttributeNames = new ArrayList<String>();, +					targetAttributeNames.add(attributeOverrideName);, +					valuesAlreadyReplaced.add(attributeOverrideName);, +, +					// Ensure all aliased attributes in the target annotation are also overridden. (SPR-14069), +					List<String> aliases = AnnotationUtils.getAttributeAliasMap(targetAnnotationType).get(attributeOverrideName);, +					if (aliases != null) {, +						for (String alias : aliases) {, +							if (!valuesAlreadyReplaced.contains(alias)) {, +								targetAttributeNames.add(alias);, +								valuesAlreadyReplaced.add(alias);, +							}, +						}, +					}, +, +					overrideAttributes(element, annotation, attributes, attributeName, targetAttributeNames);, +		private void overrideAttributes(AnnotatedElement element, Annotation annotation, AnnotationAttributes attributes,, +				String sourceAttributeName, List<String> targetAttributeNames) {, +			Object adaptedValue = AnnotationUtils.adaptValue(element, value, this.classValuesAsString,, +				this.nestedAnnotationsAsMap);, +, +			for (String targetAttributeName : targetAttributeNames) {, +		private void overrideAttribute(AnnotatedElement element, Annotation annotation, AnnotationAttributes attributes,, +				String sourceAttributeName, String targetAttributeName) {, +, +			Object value = AnnotationUtils.getValue(annotation, sourceAttributeName);, +			Object adaptedValue = AnnotationUtils.adaptValue(element, value, this.classValuesAsString,, +				this.nestedAnnotationsAsMap);, +			attributes.put(targetAttributeName, adaptedValue);, +		}, +, +	}, +, +++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotatedElementUtilsTests.java, +	public void getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {, +		Class<?> element = ShadowedAliasComposedContextConfigClass.class;, +		AnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);, +, +		String[] expected = asArray("test.xml");, +, +		assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), attributes);, +		assertArrayEquals("locations", expected, attributes.getStringArray("locations"));, +		assertArrayEquals("value", expected, attributes.getStringArray("value"));, +		// intentionally omitted: attribute = "locations" (SPR-14069), +		@AliasFor(annotation = ContextConfig.class), +	 * Although the configuration declares an explicit value for 'value' and, +	 * requires a value for the aliased 'locations', this does not result in, +	 * an error since 'locations' effectively <em>shadows</em> the 'value', +	 * attribute (which cannot be set via the composed annotation anyway)., +	 *, +	 * If 'value' were not shadowed, such a declaration would not make sense.]