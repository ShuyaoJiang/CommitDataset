[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	public void setBeanFactory(BeanFactory beanFactory) {, +	public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, final String beanName), +			throws BeanCreationException {, +, +		// Let's check for lookup methods here.., +			try {, +			}, +			catch (IllegalStateException ex) {, +				throw new BeanCreationException(beanName, "Lookup method resolution failed", ex);, +			}, +			// Fully synchronized resolution now..., +					Constructor<?>[] rawCandidates;, +					try {, +						rawCandidates = beanClass.getDeclaredConstructors();, +					}, +					catch (Throwable ex) {, +						throw new BeanCreationException(beanName,, +								"Resolution of declared constructors on bean Class [" + beanClass.getName() +, +								"] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);, +					}, +					List<Constructor<?>> candidates = new ArrayList<Constructor<?>>(rawCandidates.length);, +										"': single autowire-marked constructor flagged as optional - " +, +										"this constructor is effectively required since there is no " +, +										"default constructor to fall back to: " + candidates.get(0));, +	 * @throws BeanCreationException if autowiring failed, +	public void processInjection(Object bean) throws BeanCreationException {, +			throw new BeanCreationException(, +					"Injection of autowired dependencies failed for class [" + clazz + "]", ex);, +			final LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<>();, +								logger.warn("Autowired annotation should only be used on methods with parameters: " +, +										method);, +				Set<String> autowiredBeans = new LinkedHashSet<>(paramTypes.length);, +						Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);, +							registerDependentBeans(beanName, autowiredBeans);, +							if (autowiredBeans.size() == paramTypes.length) {, +								Iterator<String> it = autowiredBeans.iterator();, +		private final String shortcut;, +		public ShortcutDependencyDescriptor(DependencyDescriptor original, String shortcut, Class<?> requiredType) {, +			this.shortcut = shortcut;, +			return resolveCandidate(this.shortcut, this.requiredType, beanFactory);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	public void setBeanFactory(BeanFactory beanFactory) {, +	public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, final String beanName), +			throws BeanCreationException {, +, +		// Let's check for lookup methods here.., +			try {, +			}, +			catch (IllegalStateException ex) {, +				throw new BeanCreationException(beanName, "Lookup method resolution failed", ex);, +			}, +			// Fully synchronized resolution now..., +					Constructor<?>[] rawCandidates;, +					try {, +						rawCandidates = beanClass.getDeclaredConstructors();, +					}, +					catch (Throwable ex) {, +						throw new BeanCreationException(beanName,, +								"Resolution of declared constructors on bean Class [" + beanClass.getName() +, +								"] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);, +					}, +					List<Constructor<?>> candidates = new ArrayList<Constructor<?>>(rawCandidates.length);, +										"': single autowire-marked constructor flagged as optional - " +, +										"this constructor is effectively required since there is no " +, +										"default constructor to fall back to: " + candidates.get(0));, +	 * @throws BeanCreationException if autowiring failed, +	public void processInjection(Object bean) throws BeanCreationException {, +			throw new BeanCreationException(, +					"Injection of autowired dependencies failed for class [" + clazz + "]", ex);, +			final LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<>();, +								logger.warn("Autowired annotation should only be used on methods with parameters: " +, +										method);, +				Set<String> autowiredBeans = new LinkedHashSet<>(paramTypes.length);, +						Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);, +							registerDependentBeans(beanName, autowiredBeans);, +							if (autowiredBeans.size() == paramTypes.length) {, +								Iterator<String> it = autowiredBeans.iterator();, +		private final String shortcut;, +		public ShortcutDependencyDescriptor(DependencyDescriptor original, String shortcut, Class<?> requiredType) {, +			this.shortcut = shortcut;, +			return resolveCandidate(this.shortcut, this.requiredType, beanFactory);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java, +			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +	public void setBeanFactory(BeanFactory beanFactory) {, +	public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, final String beanName), +			throws BeanCreationException {, +, +		// Let's check for lookup methods here.., +			try {, +			}, +			catch (IllegalStateException ex) {, +				throw new BeanCreationException(beanName, "Lookup method resolution failed", ex);, +			}, +			// Fully synchronized resolution now..., +					Constructor<?>[] rawCandidates;, +					try {, +						rawCandidates = beanClass.getDeclaredConstructors();, +					}]