[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java, +import org.springframework.context.ApplicationEvent;, +	 * This handler supports assembling large STOMP messages split into multiple, +	 * WebSocket messages and STOMP clients (like stomp.js) indeed split large STOMP, +	 * messages at 16K boundaries. Therefore the WebSocket server input message, +	 * buffer size must allow 16K at least plus a little extra for SockJS framing., +				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getMessageType())) {, +					publishEvent(new SessionConnectEvent(this, message));, +	private void publishEvent(ApplicationEvent event) {, +		try {, +			this.eventPublisher.publishEvent(event);, +		}, +		catch (Throwable ex) {, +			logger.error("Failed to publish event " + event, ex);, +		}, +	}, +, +			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getMessageType())) {, +				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message));, +			publishEvent(new SessionDisconnectEvent(this, session.getId(), closeStatus));, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java, +import org.springframework.context.ApplicationEvent;, +	 * This handler supports assembling large STOMP messages split into multiple, +	 * WebSocket messages and STOMP clients (like stomp.js) indeed split large STOMP, +	 * messages at 16K boundaries. Therefore the WebSocket server input message, +	 * buffer size must allow 16K at least plus a little extra for SockJS framing., +				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getMessageType())) {, +					publishEvent(new SessionConnectEvent(this, message));, +	private void publishEvent(ApplicationEvent event) {, +		try {, +			this.eventPublisher.publishEvent(event);, +		}, +		catch (Throwable ex) {, +			logger.error("Failed to publish event " + event, ex);, +		}, +	}, +, +			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getMessageType())) {, +				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message));, +			publishEvent(new SessionDisconnectEvent(this, session.getId(), closeStatus));, +++ b/spring-websocket/src/test/java/org/springframework/web/socket/messaging/StompSubProtocolHandlerTests.java, +import static org.junit.Assert.assertEquals;, +		Message<byte[]> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		TextMessage textMessage = new TextMessage(new StompEncoder().encode(message));, +		message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		this.protocolHandler.handleMessageToClient(this.session, message);, +	public void eventPublicationWithExceptions() {, +, +		ApplicationEventPublisher publisher = new ApplicationEventPublisher() {, +, +			@Override, +			public void publishEvent(ApplicationEvent event) {, +				throw new IllegalStateException();, +			}, +		};, +, +		UserSessionRegistry registry = new DefaultUserSessionRegistry();, +		this.protocolHandler.setUserSessionRegistry(registry);, +		this.protocolHandler.setApplicationEventPublisher(publisher);, +		this.protocolHandler.afterSessionStarted(this.session, this.channel);, +, +		StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.CONNECT);, +		Message<byte[]> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		TextMessage textMessage = new TextMessage(new StompEncoder().encode(message));, +		this.protocolHandler.handleMessageFromClient(this.session, textMessage, this.channel);, +, +		verify(this.channel).send(this.messageCaptor.capture());, +		Message<?> actual = this.messageCaptor.getValue();, +		assertNotNull(actual);, +		assertEquals(StompCommand.CONNECT, StompHeaderAccessor.wrap(actual).getCommand());, +		reset(this.channel);, +, +		headers = StompHeaderAccessor.create(StompCommand.CONNECTED);, +		message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();, +		this.protocolHandler.handleMessageToClient(this.session, message);, +, +		assertEquals(1, this.session.getSentMessages().size());, +		textMessage = (TextMessage) this.session.getSentMessages().get(0);, +		assertEquals("CONNECTED\n" + "user-name:joe\n" + "\n" + "\u0000", textMessage.getPayload());, +, +		this.protocolHandler.afterSessionEnded(this.session, CloseStatus.BAD_DATA, this.channel);, +, +		verify(this.channel).send(this.messageCaptor.capture());, +		actual = this.messageCaptor.getValue();, +		assertNotNull(actual);, +		assertEquals(StompCommand.DISCONNECT, StompHeaderAccessor.wrap(actual).getCommand());, +	}, +, +	@Test]