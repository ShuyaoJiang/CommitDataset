[+++ b/org.springframework.core/src/main/java/org/springframework/util/CollectionUtils.java, +import java.io.Serializable;, +import java.util.Collections;, +import java.util.LinkedHashMap;, +import java.util.LinkedList;, +import java.util.Set;, + * @author Arjen Poutsma, +	/**, +	 * Adapts a {@code Map<K, List<V>>} to an {@code MultiValueMap<K,V>}., +	 *, +	 * @param map the map, +	 * @return the multi-value map, +	 */, +	public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map) {, +		return new MultiValueMapAdapter<K, V>(map);, +, +	}, +, +	/**, +	 * Returns an unmodifiable view of the specified multi-value map., +	 *, +	 * @param  map the map for which an unmodifiable view is to be returned., +	 * @return an unmodifiable view of the specified multi-value map., +	 */, +	public static <K,V> MultiValueMap<K,V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map) {, +		Assert.notNull(map, "'map' must not be null");, +		Map<K, List<V>> result = new LinkedHashMap<K, List<V>>(map.size());, +		for (Map.Entry<? extends K, ? extends List<? extends V>> entry : map.entrySet()) {, +			List<V> values = Collections.unmodifiableList(entry.getValue());, +			result.put(entry.getKey(), values);, +		}, +		Map<K, List<V>> unmodifiableMap = Collections.unmodifiableMap(result);, +		return toMultiValueMap(unmodifiableMap);, +	}, +, +, +	/**, +	 * Adapts a Map to the MultiValueMap contract., +	 */, +	private static class MultiValueMapAdapter<K, V> implements MultiValueMap<K, V>, Serializable {, +, +		private final Map<K, List<V>> map;, +, +		public MultiValueMapAdapter(Map<K, List<V>> map) {, +			Assert.notNull(map, "'map' must not be null");, +			this.map = map;, +		}, +, +		public void add(K key, V value) {, +			List<V> values = this.map.get(key);, +			if (values == null) {, +				values = new LinkedList<V>();, +				this.map.put(key, values);, +			}, +			values.add(value);, +		}, +, +		public V getFirst(K key) {, +			List<V> values = this.map.get(key);, +			return (values != null ? values.get(0) : null);, +		}, +, +		public void set(K key, V value) {, +			List<V> values = new LinkedList<V>();, +			values.add(value);, +			this.map.put(key, values);, +		}, +, +		public void setAll(Map<K, V> values) {, +			for (Entry<K, V> entry : values.entrySet()) {, +				set(entry.getKey(), entry.getValue());, +			}, +		}, +, +		public Map<K, V> toSingleValueMap() {, +			LinkedHashMap<K, V> singleValueMap = new LinkedHashMap<K,V>(this.map.size());, +			for (Entry<K, List<V>> entry : map.entrySet()) {, +				singleValueMap.put(entry.getKey(), entry.getValue().get(0));, +			}, +			return singleValueMap;, +		}, +, +		public int size() {, +			return this.map.size();, +		}, +, +		public boolean isEmpty() {, +			return this.map.isEmpty();, +		}, +, +		public boolean containsKey(Object key) {, +			return this.map.containsKey(key);, +		}, +, +		public boolean containsValue(Object value) {, +			return this.map.containsValue(value);, +		}, +, +		public List<V> get(Object key) {, +			return this.map.get(key);]