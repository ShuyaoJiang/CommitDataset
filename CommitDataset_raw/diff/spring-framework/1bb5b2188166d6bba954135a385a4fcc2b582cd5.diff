[+++ b/spring-framework-reference/src/testing.xml, +        to the test instance. Note that dependency injection support is, +        provided by the, +        <classname>DependencyInjectionTestExecutionListener</classname> which, +        is configured by default. In addition,, +        <classname>AbstractTestNGSpringContextTests</classname> implement, +        <interfacename>ApplicationContextAware</interfacename> and therefore, +        provide access to the <classname>ApplicationContext</classname>, +        out-of-the-box.</para>, +        <para>The following sections explain how to configure and manage, +        <interfacename>ApplicationContext</interfacename>s via XML, +        configuration files and <interfacename>@Configuration</interfacename>, +        classes using Spring's, +        <interfacename>@ContextConfiguration</interfacename>, +        annotation.</para>, +, +          <title>Context management with XML resources</title>, +          <para>To load an, +          <interfacename>ApplicationContextAware</interfacename> for your, +          tests from XML configuration files, annotate your test class with, +          <interfacename>@ContextConfiguration</interfacename> and configure, +          the <literal>locations</literal> attribute with an array that, +          contains the resource locations of XML configuration metadata. A, +          plain path — for example <literal>"context.xml"</literal> — will be, +          treated as a classpath resource from the package in which the test, +          class is defined. A path starting with a slash is treated as a fully, +          qualified classpath location, for example, +          <literal>"/org/example/config.xml"</literal>. A path which, +          represents a URL (i.e., a path prefixed with, +          own custom <interfacename>ContextLoader</interfacename> for advanced, +          use cases.</para>, +, +          <para>If you omit both the <varname>locations</varname> and, +          <varname>value</varname> attributes from the, +          <interfacename>@ContextConfiguration</interfacename> annotation, the, +          TestContext framework will attempt to detect a default XML resource, +          location. Specifically,, +          <classname>GenericXmlContextLoader</classname> detects a default, +          location based on the name of the test class. If your class is named, +          <literal>com.example.MyTest</literal>,, +          <classname>GenericXmlContextLoader</classname> loads your, +          application context from, +          <literal>"classpath:/com/example/MyTest-context.xml"</literal>.</para>, +, +          <programlisting language="java">package com.example;, +, +@RunWith(SpringJUnit4ClassRunner.class), +<lineannotation>// ApplicationContext will be loaded from <literal>"classpath:/com/example/MyTest-context.xml"</literal></lineannotation>, +<emphasis role="bold">@ContextConfiguration</emphasis>, +public class MyTest {, +    <lineannotation>// class body...</lineannotation>, +}</programlisting>, +        </section>, +, +        <section id="testcontext-ctx-management-javaconfig">, +          <title>Context management with @Configuration classes</title>, +, +          <para>To load an, +          <interfacename>ApplicationContextAware</interfacename> for your, +          tests from <interfacename>@Configuration</interfacename> classes,, +          annotate your test class with, +          <interfacename>@ContextConfiguration</interfacename> and configure, +          the <literal>classes</literal> attribute with an array that contains, +          class references to configuration classes. Alternatively, you can, +          implement and configure your own custom, +          <interfacename>ContextLoader</interfacename> for advanced use, +          cases.</para>, +, +          <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class), +<lineannotation>// ApplicationContext will be loaded from AppConfig and TestAppConfig</lineannotation>, +<emphasis role="bold">@ContextConfiguration(classes={AppConfig.class, TestAppConfig.class})</emphasis>, +public class MyTest {, +    <lineannotation>// class body...</lineannotation>, +}</programlisting>, +, +          <para>If you omit the <varname>classes</varname> attribute from the, +          <interfacename>@ContextConfiguration</interfacename> annotation, the, +          TestContext framework will attempt to detect the presence of default, +          configuration classes. Specifically,, +          <classname>AnnotationConfigContextLoader</classname> will detect all, +          static inner classes of the annotated test class that meet the, +          requirements for configuration class implementations as specified in, +          the Javadoc for <interfacename>@Configuration</interfacename> (see, +          <xref linkend="beans-java" /> for further details). In the following, +          example, the <classname>OrderServiceTest</classname> class declares, +          a static inner configuration class named, +          <classname>Config</classname> that will be automatically used to, +          load the <interfacename>ApplicationContext</interfacename> for the, +          test class. Note that the name of the configuration class is, +          arbitrary. In addition, a test class can contain more than one, +          static inner configuration class if desired.</para>, +, +          <programlisting language="java">package com.example;, + , +@RunWith(SpringJUnit4ClassRunner.class), +<lineannotation>// ApplicationContext will be loaded from the static inner Config class</lineannotation>, +<emphasis role="bold">@ContextConfiguration</emphasis>, +public class OrderServiceTest {, + , +    @Configuration]