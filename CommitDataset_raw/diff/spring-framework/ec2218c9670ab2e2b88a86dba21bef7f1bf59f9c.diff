[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerWriteFlushProcessor.java, +	/**, +	 * Whether writing is possible., +	 */, +	protected abstract boolean isWritePossible();, +, +	/**, +	 * Whether flushing is pending., +	 */, +	protected abstract boolean isFlushPending();, +, +	/**, +	 * Listeners can call this to notify when flushing is possible., +	 */, +	protected final void onFlushPossible() {, +		this.state.get().onFlushPossible(this);, +	}, +, +	private void flushIfPossible() {, +		if (isWritePossible()) {, +			onFlushPossible();, +		}, +	}, +, +					if (processor.isFlushPending()) {, +						// Ensure the final flush, +						processor.changeState(this, FLUSHING);, +						processor.flushIfPossible();, +					}, +					else if (processor.changeState(this, COMPLETED)) {, +		FLUSHING {, +			public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {, +				try {, +					processor.flush();, +				}, +				catch (IOException ex) {, +					processor.flushingFailed(ex);, +					return;, +				}, +				if (processor.changeState(this, COMPLETED)) {, +					processor.resultPublisher.publishComplete();, +				}, +			}, +			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {, +				// ignore, +			}, +			@Override, +			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {, +				// ignore, +			}, +		},, +, +		public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {, +			// ignore, +		}, +, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerWriteFlushProcessor.java, +	/**, +	 * Whether writing is possible., +	 */, +	protected abstract boolean isWritePossible();, +, +	/**, +	 * Whether flushing is pending., +	 */, +	protected abstract boolean isFlushPending();, +, +	/**, +	 * Listeners can call this to notify when flushing is possible., +	 */, +	protected final void onFlushPossible() {, +		this.state.get().onFlushPossible(this);, +	}, +, +	private void flushIfPossible() {, +		if (isWritePossible()) {, +			onFlushPossible();, +		}, +	}, +, +					if (processor.isFlushPending()) {, +						// Ensure the final flush, +						processor.changeState(this, FLUSHING);, +						processor.flushIfPossible();, +					}, +					else if (processor.changeState(this, COMPLETED)) {, +		FLUSHING {, +			public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {, +				try {, +					processor.flush();, +				}, +				catch (IOException ex) {, +					processor.flushingFailed(ex);, +					return;, +				}, +				if (processor.changeState(this, COMPLETED)) {, +					processor.resultPublisher.publishComplete();, +				}, +			}, +			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {]