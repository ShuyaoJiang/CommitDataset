[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +		A annotation = element.getDeclaredAnnotation(annotationType);, +, +		// Shortcut: no non-java annotations to be found on plain Java classes and org.springframework.lang types..., +		if (AnnotationUtils.hasPlainJavaAnnotationsOnly(element) && !annotationType.getName().startsWith("java")) {, +			return null;, +		A annotation = element.getDeclaredAnnotation(annotationType);, +								if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +					if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +	 * annotation for the supplied repeatable {@code annotationType} (i.e., +	 * <p>Depending on the use case, a processor may choose to {@linkplain #process}, +	 * a single target annotation, multiple target annotations, or all annotations, +	 * discovered by the currently executing search. The term "target" in this, +	 * context refers to a matching annotation (i.e. a specific annotation type, +	 * that was found during the search)., +	 * <p>Returning a non-null value from the {@link #process} method instructs, +	 * the search algorithm to stop searching further; whereas, returning, +	 * {@code null} from the {@link #process} method instructs the search, +	 * algorithm to continue searching for additional annotations. One exception, +	 * to this rule applies to processors that {@linkplain #aggregates aggregate}, +	 * results. If an aggregating processor returns a non-null value, that value, +	 * will be added to the {@linkplain #getAggregatedResults aggregated results}, +	 * <p>Processors can optionally {@linkplain #postProcess post-process} the, +	 * result of the {@link #process} method as the search algorithm goes back, +	 * down the annotation hierarchy from an invocation of {@link #process} that, +	 * returned a non-null value down to the {@link AnnotatedElement} that was, +	 * supplied as the starting point to the search algorithm., +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +		A annotation = element.getDeclaredAnnotation(annotationType);, +, +		// Shortcut: no non-java annotations to be found on plain Java classes and org.springframework.lang types..., +		if (AnnotationUtils.hasPlainJavaAnnotationsOnly(element) && !annotationType.getName().startsWith("java")) {, +			return null;, +		A annotation = element.getDeclaredAnnotation(annotationType);, +								if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +					if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +	 * annotation for the supplied repeatable {@code annotationType} (i.e., +	 * <p>Depending on the use case, a processor may choose to {@linkplain #process}, +	 * a single target annotation, multiple target annotations, or all annotations, +	 * discovered by the currently executing search. The term "target" in this, +	 * context refers to a matching annotation (i.e. a specific annotation type, +	 * that was found during the search)., +	 * <p>Returning a non-null value from the {@link #process} method instructs, +	 * the search algorithm to stop searching further; whereas, returning, +	 * {@code null} from the {@link #process} method instructs the search, +	 * algorithm to continue searching for additional annotations. One exception, +	 * to this rule applies to processors that {@linkplain #aggregates aggregate}, +	 * results. If an aggregating processor returns a non-null value, that value, +	 * will be added to the {@linkplain #getAggregatedResults aggregated results}, +	 * <p>Processors can optionally {@linkplain #postProcess post-process} the, +	 * result of the {@link #process} method as the search algorithm goes back, +	 * down the annotation hierarchy from an invocation of {@link #process} that, +	 * returned a non-null value down to the {@link AnnotatedElement} that was, +	 * supplied as the starting point to the search algorithm., +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +	 * {@link Method}, traversing its super methods (i.e. from superclasses and, +						if (isOverride(method, annotatedMethod)) {, +	static boolean isOverride(Method method, Method candidate) {, +	 * is declared locally (i.e. <em>directly present</em>) on the supplied, +	 * {@linkplain java.lang.annotation.Inherited inherited}, +	 * (i.e. not <em>directly present</em>)., +	 * <p>For <em>explicit</em> alias pairs such as x and y (i.e. where x, +	 * <p>For <em>implicit</em> aliases (i.e. attributes that are declared, +	 * <em>synthesizable</em> (i.e. in need of being wrapped in a dynamic, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +		A annotation = element.getDeclaredAnnotation(annotationType);, +, +		// Shortcut: no non-java annotations to be found on plain Java classes and org.springframework.lang types..., +		if (AnnotationUtils.hasPlainJavaAnnotationsOnly(element) && !annotationType.getName().startsWith("java")) {, +			return null;, +		A annotation = element.getDeclaredAnnotation(annotationType);, +								if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +					if (AnnotationUtils.isOverride(method, annotatedMethod)) {, +	 * annotation for the supplied repeatable {@code annotationType} (i.e., +	 * <p>Depending on the use case, a processor may choose to {@linkplain #process}, +	 * a single target annotation, multiple target annotations, or all annotations, +	 * discovered by the currently executing search. The term "target" in this, +	 * context refers to a matching annotation (i.e. a specific annotation type, +	 * that was found during the search)., +	 * <p>Returning a non-null value from the {@link #process} method instructs, +	 * the search algorithm to stop searching further; whereas, returning, +	 * {@code null} from the {@link #process} method instructs the search, +	 * algorithm to continue searching for additional annotations. One exception, +	 * to this rule applies to processors that {@linkplain #aggregates aggregate}, +	 * results. If an aggregating processor returns a non-null value, that value, +	 * will be added to the {@linkplain #getAggregatedResults aggregated results}, +	 * <p>Processors can optionally {@linkplain #postProcess post-process} the, +	 * result of the {@link #process} method as the search algorithm goes back, +	 * down the annotation hierarchy from an invocation of {@link #process} that, +	 * returned a non-null value down to the {@link AnnotatedElement} that was, +	 * supplied as the starting point to the search algorithm., +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java, +	 * {@link Method}, traversing its super methods (i.e. from superclasses and, +						if (isOverride(method, annotatedMethod)) {, +	static boolean isOverride(Method method, Method candidate) {, +	 * is declared locally (i.e. <em>directly present</em>) on the supplied, +	 * {@linkplain java.lang.annotation.Inherited inherited}, +	 * (i.e. not <em>directly present</em>)., +	 * <p>For <em>explicit</em> alias pairs such as x and y (i.e. where x, +	 * <p>For <em>implicit</em> aliases (i.e. attributes that are declared]