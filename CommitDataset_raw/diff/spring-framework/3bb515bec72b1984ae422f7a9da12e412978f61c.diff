[+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, +import javax.servlet.http.HttpServletRequest;, +, +import org.springframework.web.context.request.async.WebAsyncManager;, +import org.springframework.web.context.request.async.WebAsyncUtils;, +	private CountDownLatch asyncResultLatch;, +, +	public void setAsyncResultLatch(CountDownLatch asyncResultLatch) {, +		this.asyncResultLatch = asyncResultLatch;, +	}, +, +	public Object getAsyncResult() {, +		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(this.mockRequest);, +		if (asyncManager.isConcurrentHandlingStarted()) {, +			if (!awaitAsyncResult()) {, +				throw new IllegalStateException(, +						"Gave up waiting on async result from [" + this.handler + "] to complete");, +			}, +			if (asyncManager.hasConcurrentResult()) {, +				return asyncManager.getConcurrentResult();, +			}, +		}, +, +		return null;, +	}, +, +	private boolean awaitAsyncResult() {, +		if (this.asyncResultLatch == null) {, +			return true;, +		}, +		long timeout = ((HttpServletRequest) this.mockRequest).getAsyncContext().getTimeout();, +		try {, +			return this.asyncResultLatch.await(timeout, TimeUnit.MILLISECONDS);, +		}, +		catch (InterruptedException e) {, +			return false;, +		}, +	}, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, +import javax.servlet.http.HttpServletRequest;, +, +import org.springframework.web.context.request.async.WebAsyncManager;, +import org.springframework.web.context.request.async.WebAsyncUtils;, +	private CountDownLatch asyncResultLatch;, +, +	public void setAsyncResultLatch(CountDownLatch asyncResultLatch) {, +		this.asyncResultLatch = asyncResultLatch;, +	}, +, +	public Object getAsyncResult() {, +		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(this.mockRequest);, +		if (asyncManager.isConcurrentHandlingStarted()) {, +			if (!awaitAsyncResult()) {, +				throw new IllegalStateException(, +						"Gave up waiting on async result from [" + this.handler + "] to complete");, +			}, +			if (asyncManager.hasConcurrentResult()) {, +				return asyncManager.getConcurrentResult();, +			}, +		}, +, +		return null;, +	}, +, +	private boolean awaitAsyncResult() {, +		if (this.asyncResultLatch == null) {, +			return true;, +		}, +		long timeout = ((HttpServletRequest) this.mockRequest).getAsyncContext().getTimeout();, +		try {, +			return this.asyncResultLatch.await(timeout, TimeUnit.MILLISECONDS);, +		}, +		catch (InterruptedException e) {, +			return false;, +		}, +	}, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/MvcResult.java, +	/**, +	 * Get the result of asynchronous execution or {@code null} if concurrent, +	 * handling did not start. This method will hold and await the completion, +	 * of concurrent handling., +	 *, +	 * @throws IllegalStateException if concurrent handling does not complete, +	 * within the allocated async timeout value., +	 */, +	Object getAsyncResult();, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, +import javax.servlet.http.HttpServletRequest;]