[+++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, + * <p>TODO Consider refactoring into a stateful ContextLoaderResolver., +	private static final ClassNameLocationsResolver classNameLocationsResolver = new ClassNameLocationsResolver();, +	private static final ResourcePathLocationsResolver resourcePathLocationsResolver = new ResourcePathLocationsResolver();, +, +		Assert.notNull(declaringClass, String.format(, +			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]", annotationType,, +			clazz));, +		LocationsResolver locationsResolver = processConfigurationClasses ? classNameLocationsResolver, +				: resourcePathLocationsResolver;, +, +			String[] resolvedLocations = locationsResolver.resolveLocations(contextConfiguration, declaringClass);, +			String[] processedLocations = contextLoader.processLocations(declaringClass, resolvedLocations);, +			locationsList.addAll(0, Arrays.<String> asList(processedLocations));, +	private static interface LocationsResolver {, +		String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass);, +	private static final class ResourcePathLocationsResolver implements LocationsResolver {, +, +		public String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass) {, +, +			String[] locations = contextConfiguration.locations();, +			String[] valueLocations = contextConfiguration.value();, +, +			if (!ObjectUtils.isEmpty(valueLocations) && !ObjectUtils.isEmpty(locations)) {, +				String msg = String.format(, +					"Test class [%s] has been configured with @ContextConfiguration's 'value' [%s] and 'locations' [%s] attributes. Only one declaration of resource locations is permitted per @ContextConfiguration annotation.",, +					declaringClass, ObjectUtils.nullSafeToString(valueLocations),, +					ObjectUtils.nullSafeToString(locations));, +				ContextLoaderUtils.logger.error(msg);, +				throw new IllegalStateException(msg);, +			}, +			else if (!ObjectUtils.isEmpty(valueLocations)) {, +				locations = valueLocations;, +			}, +, +			return locations;, +		}, +	}, +, +	private static final class ClassNameLocationsResolver implements LocationsResolver {, +, +		public String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass) {, +, +			return classNames;, +		}, +++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, + * <p>TODO Consider refactoring into a stateful ContextLoaderResolver., +	private static final ClassNameLocationsResolver classNameLocationsResolver = new ClassNameLocationsResolver();, +	private static final ResourcePathLocationsResolver resourcePathLocationsResolver = new ResourcePathLocationsResolver();, +, +		Assert.notNull(declaringClass, String.format(, +			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]", annotationType,, +			clazz));, +		LocationsResolver locationsResolver = processConfigurationClasses ? classNameLocationsResolver, +				: resourcePathLocationsResolver;, +, +			String[] resolvedLocations = locationsResolver.resolveLocations(contextConfiguration, declaringClass);, +			String[] processedLocations = contextLoader.processLocations(declaringClass, resolvedLocations);, +			locationsList.addAll(0, Arrays.<String> asList(processedLocations));, +	private static interface LocationsResolver {, +		String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass);, +	private static final class ResourcePathLocationsResolver implements LocationsResolver {, +, +		public String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass) {, +, +			String[] locations = contextConfiguration.locations();, +			String[] valueLocations = contextConfiguration.value();, +, +			if (!ObjectUtils.isEmpty(valueLocations) && !ObjectUtils.isEmpty(locations)) {, +				String msg = String.format(, +					"Test class [%s] has been configured with @ContextConfiguration's 'value' [%s] and 'locations' [%s] attributes. Only one declaration of resource locations is permitted per @ContextConfiguration annotation.",, +					declaringClass, ObjectUtils.nullSafeToString(valueLocations),, +					ObjectUtils.nullSafeToString(locations));, +				ContextLoaderUtils.logger.error(msg);, +				throw new IllegalStateException(msg);, +			}, +			else if (!ObjectUtils.isEmpty(valueLocations)) {, +				locations = valueLocations;, +			}, +, +			return locations;, +		}, +	}, +, +	private static final class ClassNameLocationsResolver implements LocationsResolver {, +, +		public String[] resolveLocations(ContextConfiguration contextConfiguration, Class<?> declaringClass) {, +, +			return classNames;, +		}, +++ b/org.springframework.test/src/test/java/org/springframework/test/context/junit4/SpringJUnit4SuiteTests.java, +import org.springframework.test.context.junit4.annotation.DefaultConfigClassBaseTests;, +import org.springframework.test.context.junit4.annotation.DefaultConfigClassInheritedTests;, +	DefaultConfigClassBaseTests.class,//, +	DefaultConfigClassInheritedTests.class,//, +++ b/org.springframework.test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, + * <p>TODO Consider refactoring into a stateful ContextLoaderResolver., +	private static final ClassNameLocationsResolver classNameLocationsResolver = new ClassNameLocationsResolver();, +	private static final ResourcePathLocationsResolver resourcePathLocationsResolver = new ResourcePathLocationsResolver();, +]