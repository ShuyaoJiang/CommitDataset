[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.core.annotation.AnnotationAttributes;, +						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);, +				AnnotationAttributes annotation = findAutowiredAnnotation(field);, +				AnnotationAttributes annotation = BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod) ?, +	private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {, +			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());, +	 * Determine if the annotated field or method requires its dependency., +	 * <p>A 'required' dependency means that autowiring should fail when no beans, +	 * are found. Otherwise, the autowiring process will simply bypass the field, +	 * or method when no beans are found., +	 * @param annotation the Autowired annotation, +	 * @return whether the annotation indicates that a dependency is required, +	 */, +	protected boolean determineRequiredStatus(AnnotationAttributes annotation) {, +		return (!annotation.containsKey(this.requiredParameterName) ||, +				this.requiredParameterValue == annotation.getBoolean(this.requiredParameterName));, +	}, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.core.annotation.AnnotationAttributes;, +						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);, +				AnnotationAttributes annotation = findAutowiredAnnotation(field);, +				AnnotationAttributes annotation = BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod) ?, +	private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {, +			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());, +	 * Determine if the annotated field or method requires its dependency., +	 * <p>A 'required' dependency means that autowiring should fail when no beans, +	 * are found. Otherwise, the autowiring process will simply bypass the field, +	 * or method when no beans are found., +	 * @param annotation the Autowired annotation, +	 * @return whether the annotation indicates that a dependency is required, +	 */, +	protected boolean determineRequiredStatus(AnnotationAttributes annotation) {, +		return (!annotation.containsKey(this.requiredParameterName) ||, +				this.requiredParameterValue == annotation.getBoolean(this.requiredParameterName));, +	}, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/AnnotationScopeMetadataResolverTests.java, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import static org.junit.Assert.*;, +, +	@Test, +	public void testCustomRequestScopeWithAttribute() {, +		AnnotatedBeanDefinition bd = new AnnotatedGenericBeanDefinition(AnnotatedWithCustomRequestScopeWithAttribute.class);, +		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(bd);, +		assertNotNull("resolveScopeMetadata(..) must *never* return null.", scopeMetadata);, +		assertEquals("request", scopeMetadata.getScopeName());, +		assertEquals(ScopedProxyMode.TARGET_CLASS, scopeMetadata.getScopedProxyMode());, +	}, +, +	@Target({ElementType.TYPE, ElementType.METHOD}), +	@Retention(RetentionPolicy.RUNTIME), +	@Scope("request"), +	public @interface CustomRequestScope {, +	}, +, +	public @interface CustomRequestScopeWithAttribute {, +		ScopedProxyMode proxyMode();, +	}, +, +	@CustomRequestScopeWithAttribute(proxyMode = ScopedProxyMode.TARGET_CLASS), +	private static final class AnnotatedWithCustomRequestScopeWithAttribute {, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, + * Copyright 2002-2013 the original author or authors., +import org.springframework.core.annotation.AnnotatedElementUtils;, +import org.springframework.core.annotation.AnnotationAttributes;, +						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);, +				AnnotationAttributes annotation = findAutowiredAnnotation(field);, +				AnnotationAttributes annotation = BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod) ?, +	private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {, +			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());, +	 * Determine if the annotated field or method requires its dependency., +	 * <p>A 'required' dependency means that autowiring should fail when no beans, +	 * are found. Otherwise, the autowiring process will simply bypass the field, +	 * or method when no beans are found., +	 * @param annotation the Autowired annotation, +	 * @return whether the annotation indicates that a dependency is required, +	 */, +	protected boolean determineRequiredStatus(AnnotationAttributes annotation) {, +		return (!annotation.containsKey(this.requiredParameterName) ||, +				this.requiredParameterValue == annotation.getBoolean(this.requiredParameterName));, +	}, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/AnnotationScopeMetadataResolverTests.java, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import static org.junit.Assert.*;, +, +	@Test, +	public void testCustomRequestScopeWithAttribute() {, +		AnnotatedBeanDefinition bd = new AnnotatedGenericBeanDefinition(AnnotatedWithCustomRequestScopeWithAttribute.class);]