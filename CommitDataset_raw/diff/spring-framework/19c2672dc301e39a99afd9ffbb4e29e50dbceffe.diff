[+++ b/org.springframework.jdbc/src/main/java/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.java, + * Copyright 2002-2011 the original author or authors., +, +, +, +		}, +		else {, +				}, +				catch (SQLException ex) {, +					}, +					else {, +		}, +		finally {, +			}, +			catch (Throwable ex) {, +			if (StringUtils.hasText(currentStatement) &&, +					this.commentPrefix != null && !currentStatement.startsWith(this.commentPrefix)) {, +		if (this.separator == null) {, +		String trimmed = this.separator.trim();, +		if (trimmed.length() == this.separator.length()) {, +			return;, +		}, +			scriptBuilder.append(this.separator.substring(trimmed.length()));, +				}, +				else if (c == '\n' || c == '\t') {, +++ b/org.springframework.jdbc/src/main/java/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.java, + * Copyright 2002-2011 the original author or authors., +, +, +, +		}, +		else {, +				}, +				catch (SQLException ex) {, +					}, +					else {, +		}, +		finally {, +			}, +			catch (Throwable ex) {, +			if (StringUtils.hasText(currentStatement) &&, +					this.commentPrefix != null && !currentStatement.startsWith(this.commentPrefix)) {, +		if (this.separator == null) {, +		String trimmed = this.separator.trim();, +		if (trimmed.length() == this.separator.length()) {, +			return;, +		}, +			scriptBuilder.append(this.separator.substring(trimmed.length()));, +				}, +				else if (c == '\n' || c == '\t') {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, + * Copyright 2002-2011 the original author or authors., +					throw new HttpRequestMethodNotSupportedException(request.getMethod(), StringUtils.toStringArray(allowedMethods));, +				throw new NoSuchRequestHandlingMethodException(lookupPath, request.getMethod(), request.getParameterMap());, +			return (Boolean) request.getAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING);, +		 * <p>Uses the following algorithm:, +		 * <ol>, +		 * <li>If there is a {@linkplain HandlerMapping#BEST_MATCHING_PATTERN_ATTRIBUTE best matching pattern}, +		 * in the request, it is combined with the method-level pattern.</li>, +				if (matchingPattern != null && !matchingPattern.equals(bestMatchingPattern)) {, +			if (!hasSuffix) {, +				String patternWithSuffix = pattern + ".*";, +				if (pathMatcher.match(patternWithSuffix, lookupPath)) {, +					return patternWithSuffix;, +				}, +			if (!endsWithSlash) {, +				String patternWithSlash = pattern + "/";, +				if (pathMatcher.match(patternWithSlash, lookupPath)) {, +					return patternWithSlash;, +				}, +		private void extractHandlerMethodUriTemplates(String mappedPattern, String lookupPath, HttpServletRequest request) {, +			if ((variables == null || patternVariableCount != variables.size()) && pathMatcher.match(mappedPattern, lookupPath)) {, +++ b/org.springframework.jdbc/src/main/java/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.java, + * Copyright 2002-2011 the original author or authors., +, +, +, +		}, +		else {, +				}, +				catch (SQLException ex) {, +					}, +					else {, +		}, +		finally {, +			}, +			catch (Throwable ex) {, +			if (StringUtils.hasText(currentStatement) &&, +					this.commentPrefix != null && !currentStatement.startsWith(this.commentPrefix)) {, +		if (this.separator == null) {, +		String trimmed = this.separator.trim();, +		if (trimmed.length() == this.separator.length()) {, +			return;, +		}, +			scriptBuilder.append(this.separator.substring(trimmed.length()));, +				}, +				else if (c == '\n' || c == '\t') {, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/annotation/AnnotationMethodHandlerAdapter.java, + * Copyright 2002-2011 the original author or authors., +					throw new HttpRequestMethodNotSupportedException(request.getMethod(), StringUtils.toStringArray(allowedMethods));]