[+++ b/spring-test/src/test/java/org/springframework/test/context/event/EventPublishingTestExecutionListenerIntegrationTests.java, +import java.lang.annotation.Target;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Executor;, +import java.util.concurrent.TimeUnit;, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, +import org.junit.runner.RunWith;, +import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;, +import org.springframework.scheduling.annotation.Async;, +import org.springframework.scheduling.annotation.AsyncConfigurerSupport;, +import org.springframework.scheduling.annotation.EnableAsync;, +import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;, +import org.springframework.stereotype.Component;, +import org.springframework.test.context.junit4.SpringRunner;, +import static java.lang.annotation.ElementType.METHOD;, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.CoreMatchers.startsWith;, +import static org.junit.Assert.assertThat;, +import static org.springframework.test.context.TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS;, +	private static final String THREAD_NAME_PREFIX = "Test-";, +, +	private static final CountDownLatch countDownLatch = new CountDownLatch(1);, +, +	private final TestExecutionListener listener = testContext.getApplicationContext().getBean(TestExecutionListener.class);, +	private final Method testMethod = ReflectionUtils.findMethod(ExampleTestCase.class, "traceableTest");, +, +	@Rule, +	public final ExpectedException exception = ExpectedException.none();, +	public void beforeTestMethodAnnotation() throws Exception {, +		Method standardTest = ReflectionUtils.findMethod(ExampleTestCase.class, "standardTest");, +		testContextManager.beforeTestMethod(testInstance, standardTest);, +	public void beforeTestMethodAnnotationWithFailingEventListener() throws Exception {, +		Method method = ReflectionUtils.findMethod(ExampleTestCase.class, "testWithFailingEventListener");, +, +		exception.expect(RuntimeException.class);, +		exception.expectMessage("Boom!");, +, +		try {, +			testContextManager.beforeTestMethod(testInstance, method);, +		}, +		finally {, +			verify(listener, only()).beforeTestMethod(testContext);, +		}, +	}, +, +	@Test, +	public void beforeTestMethodAnnotationWithFailingAsyncEventListener() throws Exception {, +		TrackingAsyncUncaughtExceptionHandler.asyncException = null;, +, +		String methodName = "testWithFailingAsyncEventListener";, +		Method method = ReflectionUtils.findMethod(ExampleTestCase.class, methodName);, +, +		testContextManager.beforeTestMethod(testInstance, method);, +, +		assertThat(countDownLatch.await(2, TimeUnit.SECONDS), equalTo(true));, +, +		verify(listener, only()).beforeTestMethod(testContext);, +		assertThat(TrackingAsyncUncaughtExceptionHandler.asyncException.getMessage(),, +			startsWith("Asynchronous exception for test method [" + methodName + "] in thread [" + THREAD_NAME_PREFIX));, +	}, +, +	@Test, +	@Target(METHOD), +	@Retention(RUNTIME), +	@interface Traceable {, +	}, +, +	@RunWith(SpringRunner.class), +	@ContextConfiguration(classes = EventCaptureConfiguration.class), +	@TestExecutionListeners(listeners = EventPublishingTestExecutionListener.class, mergeMode = MERGE_WITH_DEFAULTS), +	public static class ExampleTestCase {, +, +		@Traceable, +		@Test, +		public void traceableTest() {, +			/* no-op */, +		}, +, +		@Test, +		public void standardTest() {, +			/* no-op */, +		}, +, +		@Test, +		public void testWithFailingEventListener() {, +			/* no-op */, +		}, +, +		@Test, +		public void testWithFailingAsyncEventListener() {, +			/* no-op */, +		}, +, +	}, +, +	@EnableAsync(proxyTargetClass = true), +	static class EventCaptureConfiguration extends AsyncConfigurerSupport {, +, +		@Override]