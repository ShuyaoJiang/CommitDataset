[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +				throwSimpleExceptionIfPossible(state, ae);, +			// Same unwrapping exception handling as above in above catch block, +			throwSimpleExceptionIfPossible(state, ae);, +, +	/**, +	 * Decode the AccessException, throwing a lightweight evaluation exception or, if the cause was a RuntimeException, , +	 * throw the RuntimeException directly., +	 */, +	private void throwSimpleExceptionIfPossible(ExpressionState state, AccessException ae) {, +		Throwable causeOfAccessException = ae.getCause();, +		Throwable rootCause = (causeOfAccessException==null?null:causeOfAccessException.getCause());, +		if (rootCause!=null) {, +			// User exception was the root cause - exit now, +			if (rootCause instanceof RuntimeException) {, +				throw (RuntimeException)rootCause;, +			} else {, +				throw new SpelEvaluationException( getStartPosition(), rootCause, SpelMessage.EXCEPTION_DURING_METHOD_INVOCATION,, +					this.name, state.getActiveContextObject().getValue().getClass().getName(), rootCause.getMessage());, +			}, +		}, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +				throwSimpleExceptionIfPossible(state, ae);, +			// Same unwrapping exception handling as above in above catch block, +			throwSimpleExceptionIfPossible(state, ae);, +, +	/**, +	 * Decode the AccessException, throwing a lightweight evaluation exception or, if the cause was a RuntimeException, , +	 * throw the RuntimeException directly., +	 */, +	private void throwSimpleExceptionIfPossible(ExpressionState state, AccessException ae) {, +		Throwable causeOfAccessException = ae.getCause();, +		Throwable rootCause = (causeOfAccessException==null?null:causeOfAccessException.getCause());, +		if (rootCause!=null) {, +			// User exception was the root cause - exit now, +			if (rootCause instanceof RuntimeException) {, +				throw (RuntimeException)rootCause;, +			} else {, +				throw new SpelEvaluationException( getStartPosition(), rootCause, SpelMessage.EXCEPTION_DURING_METHOD_INVOCATION,, +					this.name, state.getActiveContextObject().getValue().getClass().getName(), rootCause.getMessage());, +			}, +		}, +	}, +, +++ b/org.springframework.expression/src/test/java/org/springframework/expression/spel/MethodInvocationTests.java, +	/**, +	 * Check on first usage (when the cachedExecutor in MethodReference is null) that the exception is not wrapped., +	 */, +	@Test, +	public void testMethodThrowingException_SPR6941() {, +		// Test method on inventor: throwException(), +		// On 1 it will throw an IllegalArgumentException, +		// On 2 it will throw a RuntimeException, +		// On 3 it will exit normally, +		// In each case it increments the Inventor field 'counter' when invoked, +		, +		SpelExpressionParser parser = new SpelExpressionParser();, +		Expression expr = parser.parseExpression("throwException(#bar)");, +		, +		eContext.setVariable("bar",2);, +		try {, +			expr.getValue(eContext);, +			Assert.fail();, +		} catch (Exception e) {, +			if (e instanceof SpelEvaluationException) {, +				e.printStackTrace();, +				Assert.fail("Should not be a SpelEvaluationException");, +			}, +			// normal, +		}, +	}, +	]