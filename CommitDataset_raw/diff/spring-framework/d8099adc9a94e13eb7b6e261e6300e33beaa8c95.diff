[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +import java.util.Queue;, +import reactor.util.concurrent.Queues;, +	 * Returns {@code true} if receiving new message(s) is suspended otherwise, +	 * {@code false}., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should return, +	 * {@code false} and {@link #canSuspendReceiving()} should return {@code false}., +	 * @return returns {@code true} if receiving new message(s) is suspended, +	 * otherwise {@code false}., +	 */, +	protected abstract boolean isSuspended();, +, +	/**, +		private volatile Queue<Object> pendingWebSocketMessages = Queues.unbounded().get();, +			if (isSuspended()) {, +				resumeReceiving();, +			}, +			if (!pendingWebSocketMessages.isEmpty()) {, +		protected void suspendReading() {, +			suspendReceiving();, +		@Override, +		@Nullable, +		protected WebSocketMessage read() throws IOException {, +			return (WebSocketMessage) pendingWebSocketMessages.poll();, +		}, +, +		@Override, +		public void onAllDataRead() {, +			if (isSuspended()) {, +				resumeReceiving();, +			}, +			super.onAllDataRead();, +			this.pendingWebSocketMessages.offer(webSocketMessage);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +import java.util.Queue;, +import reactor.util.concurrent.Queues;, +	 * Returns {@code true} if receiving new message(s) is suspended otherwise, +	 * {@code false}., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should return, +	 * {@code false} and {@link #canSuspendReceiving()} should return {@code false}., +	 * @return returns {@code true} if receiving new message(s) is suspended, +	 * otherwise {@code false}., +	 */, +	protected abstract boolean isSuspended();, +, +	/**, +		private volatile Queue<Object> pendingWebSocketMessages = Queues.unbounded().get();, +			if (isSuspended()) {, +				resumeReceiving();, +			}, +			if (!pendingWebSocketMessages.isEmpty()) {, +		protected void suspendReading() {, +			suspendReceiving();, +		@Override, +		@Nullable, +		protected WebSocketMessage read() throws IOException {, +			return (WebSocketMessage) pendingWebSocketMessages.poll();, +		}, +, +		@Override, +		public void onAllDataRead() {, +			if (isSuspended()) {, +				resumeReceiving();, +			}, +			super.onAllDataRead();, +			this.pendingWebSocketMessages.offer(webSocketMessage);, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketSession.java, +	protected boolean isSuspended() {, +		return this.suspendToken != null;, +	}, +, +	@Override, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java, +import java.util.Queue;, +import reactor.util.concurrent.Queues;, +	 * Returns {@code true} if receiving new message(s) is suspended otherwise, +	 * {@code false}., +	 * <p><strong>Note:</strong> if the underlying WebSocket API does not provide, +	 * flow control for receiving messages, and this method should return, +	 * {@code false} and {@link #canSuspendReceiving()} should return {@code false}., +	 * @return returns {@code true} if receiving new message(s) is suspended, +	 * otherwise {@code false}., +	 */, +	protected abstract boolean isSuspended();, +, +	/**, +		private volatile Queue<Object> pendingWebSocketMessages = Queues.unbounded().get();, +			if (isSuspended()) {, +				resumeReceiving();, +			}, +			if (!pendingWebSocketMessages.isEmpty()) {, +		protected void suspendReading() {, +			suspendReceiving();, +		@Override, +		@Nullable, +		protected WebSocketMessage read() throws IOException {, +			return (WebSocketMessage) pendingWebSocketMessages.poll();, +		}]