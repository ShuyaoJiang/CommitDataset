[+++ b/org.springframework.context/src/main/java/org/springframework/ui/format/GenericFormatterRegistry.java, +import java.text.ParseException;, +import java.util.Locale;, +import org.springframework.core.convert.ConversionService;, +import org.springframework.core.convert.support.DefaultConversionService;, + * @see #add(Formatter), +	private ConversionService conversionService = new DefaultConversionService();, +, +	/**, +	 * Sets the type conversion service used to coerse objects to the types required for Formatting purposes., +	 * @param conversionService the conversion service, +	 * @see #add(Class, Formatter), +	 */, +	public void setConversionService(ConversionService conversionService) {, +		this.conversionService = conversionService;, +	}, +, +		typeFormatters.put(getFormattedObjectType(formatter.getClass()), formatter);, +		annotationFormatters.put(getAnnotationType(factory.getClass()), factory);, +		Formatter formatter = getAnnotationFormatter(type);, +		if (formatter == null) {, +			formatter = getTypeFormatter(type.getType());, +		}, +		return formatter;, +	}, +, +	// internal helpers, +, +	private Class getFormattedObjectType(Class formatterClass) {, +		Class classToIntrospect = formatterClass;, +		while (classToIntrospect != null) {, +			Type[] ifcs = classToIntrospect.getGenericInterfaces();, +			for (Type ifc : ifcs) {, +				if (ifc instanceof ParameterizedType) {, +					ParameterizedType paramIfc = (ParameterizedType) ifc;, +					Type rawType = paramIfc.getRawType();, +					if (Formatter.class.equals(rawType)) {, +						Type arg = paramIfc.getActualTypeArguments()[0];, +						if (arg instanceof TypeVariable) {, +							arg = GenericTypeResolver.resolveTypeVariable((TypeVariable) arg, formatterClass);, +						}, +						if (arg instanceof Class) {, +							return (Class) arg;, +						}, +					} else if (Formatter.class.isAssignableFrom((Class) rawType)) {, +						return getFormattedObjectType((Class) rawType);, +					}, +				} else if (Formatter.class.isAssignableFrom((Class) ifc)) {, +					return getFormattedObjectType((Class) ifc);, +				}, +			}, +			classToIntrospect = classToIntrospect.getSuperclass();, +		}, +		return null;, +	}, +, +	private Class getAnnotationType(Class factoryClass) {, +		Class classToIntrospect = factoryClass;, +		while (classToIntrospect != null) {, +			Type[] ifcs = classToIntrospect.getGenericInterfaces();, +			for (Type ifc : ifcs) {, +				if (ifc instanceof ParameterizedType) {, +					ParameterizedType paramIfc = (ParameterizedType) ifc;, +					Type rawType = paramIfc.getRawType();, +					if (AnnotationFormatterFactory.class.equals(rawType)) {, +						Type arg = paramIfc.getActualTypeArguments()[0];, +						if (arg instanceof TypeVariable) {, +							arg = GenericTypeResolver.resolveTypeVariable((TypeVariable) arg, factoryClass);, +						}, +						if (arg instanceof Class) {, +							return (Class) arg;, +						}, +					} else if (AnnotationFormatterFactory.class.isAssignableFrom((Class) rawType)) {, +						return getAnnotationType((Class) rawType);, +					}, +				} else if (AnnotationFormatterFactory.class.isAssignableFrom((Class) ifc)) {, +					return getAnnotationType((Class) ifc);, +				}, +			}, +			classToIntrospect = classToIntrospect.getSuperclass();, +		}, +		throw new IllegalArgumentException(, +				"Unable to extract Annotation type A argument from AnnotationFormatterFactory [", +						+ factoryClass.getName() + "]; does the factory parameterize the <A> generic type?");, +	}, +, +	private Formatter<?> getAnnotationFormatter(TypeDescriptor type) {, +		return null;, +	private Formatter<?> getTypeFormatter(Class<?> type) {, +			Class<?> formattedObjectType = getFormattedObjectType(formatter.getClass());, +			if (type.isAssignableFrom(formattedObjectType)) {, +				return new ConvertingFormatter(type, formattedObjectType, formatter);, +			}, +		} else {, +			return getDefaultFormatter(type);, +		}, +	}, +, +	private Formatter<?> getDefaultFormatter(Class<?> type) {, +				Formatter formatter = (Formatter) formatterClass.newInstance();]