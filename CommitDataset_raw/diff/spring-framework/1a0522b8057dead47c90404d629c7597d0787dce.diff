[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +import java.util.concurrent.atomic.AtomicReference;, +								sink.next(dataBuffer);, +	 * @since 5.1, +	 */, +	public static Flux<DataBuffer> write(, +			Publisher<DataBuffer> source, AsynchronousFileChannel channel) {, +		return write(source, channel, 0);, +	}, +, +, +	/**, +	 * Write the given stream of {@link DataBuffer DataBuffers} to the given {@code AsynchronousFileChannel}., +	 * Does <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed to., +	 * @param source the stream of data buffers to be written, +	 * @param channel the channel to write to, +	 * @param position the file position at which the write is to begin; must be non-negative, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +		private final AtomicReference<Throwable> error = new AtomicReference<>();, +, +		private final AtomicReference<DataBuffer> dataBuffer = new AtomicReference<>();, +			if (!this.dataBuffer.compareAndSet(null, value)) {, +				throw new IllegalStateException();, +			}, +			this.error.set(throwable);, +, +			if (this.dataBuffer.get() == null) {, +		}, +			if (this.dataBuffer.get() == null) {, +			sinkDataBuffer();, +, +			Throwable throwable = this.error.get();, +			if (throwable != null) {, +				this.sink.error(throwable);, +			else if (this.completed.get()) {, +			sinkDataBuffer();, +, +		private void sinkDataBuffer() {, +			DataBuffer dataBuffer = this.dataBuffer.get();, +			Assert.state(dataBuffer != null, "DataBuffer should not be null");, +			this.sink.next(dataBuffer);, +			this.dataBuffer.set(null);, +		}, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +import java.util.concurrent.atomic.AtomicReference;, +								sink.next(dataBuffer);, +	 * @since 5.1, +	 */, +	public static Flux<DataBuffer> write(, +			Publisher<DataBuffer> source, AsynchronousFileChannel channel) {, +		return write(source, channel, 0);, +	}, +, +, +	/**, +	 * Write the given stream of {@link DataBuffer DataBuffers} to the given {@code AsynchronousFileChannel}., +	 * Does <strong>not</strong> close the channel when the flux is terminated, and does, +	 * <strong>not</strong> {@linkplain #release(DataBuffer) release} the data buffers in the, +	 * source. If releasing is required, then subscribe to the returned {@code Flux} with a, +	 * {@link #releaseConsumer()}., +	 * <p>Note that the writing process does not start until the returned {@code Flux} is subscribed to., +	 * @param source the stream of data buffers to be written, +	 * @param channel the channel to write to, +	 * @param position the file position at which the write is to begin; must be non-negative, +	 * @return a flux containing the same buffers as in {@code source}, that starts the writing, +	 * process when subscribed to, and that publishes any writing errors and the completion signal, +		private final AtomicReference<Throwable> error = new AtomicReference<>();, +, +		private final AtomicReference<DataBuffer> dataBuffer = new AtomicReference<>();, +			if (!this.dataBuffer.compareAndSet(null, value)) {, +				throw new IllegalStateException();, +			}, +			this.error.set(throwable);, +, +			if (this.dataBuffer.get() == null) {, +		}, +			if (this.dataBuffer.get() == null) {, +			sinkDataBuffer();, +, +			Throwable throwable = this.error.get();, +			if (throwable != null) {, +				this.sink.error(throwable);, +			else if (this.completed.get()) {, +			sinkDataBuffer();, +, +		private void sinkDataBuffer() {, +			DataBuffer dataBuffer = this.dataBuffer.get();, +			Assert.state(dataBuffer != null, "DataBuffer should not be null");, +			this.sink.next(dataBuffer);, +			this.dataBuffer.set(null);, +		}, +++ b/spring-core/src/test/java/org/springframework/core/io/buffer/DataBufferUtilsTests.java, +import java.io.IOException;, +import java.nio.channels.CompletionHandler;, +import java.util.concurrent.CountDownLatch;]