[+++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java, + * Copyright 2002-2018 the original author or authors., +import java.util.concurrent.RunnableFuture;, +				for (Runnable remainingTask : this.executor.shutdownNow()) {, +					cancelRemainingTask(remainingTask);, +				}, +	 * Cancel the given remaining task which never commended execution,, +	 * as returned from {@link ExecutorService#shutdownNow()}., +	 * @param task the task to cancel (potentially a {@link RunnableFuture}), +	 * @since 5.0.5, +	 * @see #shutdown(), +	 * @see RunnableFuture#cancel(boolean), +	 */, +	protected void cancelRemainingTask(Runnable task) {, +		if (task instanceof RunnableFuture) {, +			((RunnableFuture<?>) task).cancel(true);, +		}, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java, + * Copyright 2002-2018 the original author or authors., +import java.util.concurrent.RunnableFuture;, +				for (Runnable remainingTask : this.executor.shutdownNow()) {, +					cancelRemainingTask(remainingTask);, +				}, +	 * Cancel the given remaining task which never commended execution,, +	 * as returned from {@link ExecutorService#shutdownNow()}., +	 * @param task the task to cancel (potentially a {@link RunnableFuture}), +	 * @since 5.0.5, +	 * @see #shutdown(), +	 * @see RunnableFuture#cancel(boolean), +	 */, +	protected void cancelRemainingTask(Runnable task) {, +		if (task instanceof RunnableFuture) {, +			((RunnableFuture<?>) task).cancel(true);, +		}, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.java, + * Copyright 2002-2018 the original author or authors., +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	// Runnable decorator to user-level FutureTask, if different, +	private final Map<Runnable, Object> decoratedTaskMap =, +			new ConcurrentReferenceHashMap<>(16, ConcurrentReferenceHashMap.ReferenceType.WEAK);, +, +					Runnable decorated = taskDecorator.decorate(command);, +					if (decorated != command) {, +						decoratedTaskMap.put(decorated, command);, +					}, +					super.execute(decorated);, +	@Override, +	protected void cancelRemainingTask(Runnable task) {, +		super.cancelRemainingTask(task);, +		// Cancel associated user-level Future handle as well, +		Object original = this.decoratedTaskMap.get(task);, +		if (original instanceof Future) {, +			((Future<?>) original).cancel(true);, +		}, +	}, +, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java, + * Copyright 2002-2018 the original author or authors., +import java.util.concurrent.RunnableFuture;, +				for (Runnable remainingTask : this.executor.shutdownNow()) {, +					cancelRemainingTask(remainingTask);, +				}, +	 * Cancel the given remaining task which never commended execution,, +	 * as returned from {@link ExecutorService#shutdownNow()}., +	 * @param task the task to cancel (potentially a {@link RunnableFuture}), +	 * @since 5.0.5, +	 * @see #shutdown(), +	 * @see RunnableFuture#cancel(boolean), +	 */, +	protected void cancelRemainingTask(Runnable task) {, +		if (task instanceof RunnableFuture) {, +			((RunnableFuture<?>) task).cancel(true);, +		}, +	}, +, +	/**, +++ b/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.java, + * Copyright 2002-2018 the original author or authors., +import java.util.Map;, +import org.springframework.util.ConcurrentReferenceHashMap;, +	// Runnable decorator to user-level FutureTask, if different, +	private final Map<Runnable, Object> decoratedTaskMap =, +			new ConcurrentReferenceHashMap<>(16, ConcurrentReferenceHashMap.ReferenceType.WEAK);, +, +					Runnable decorated = taskDecorator.decorate(command);, +					if (decorated != command) {, +						decoratedTaskMap.put(decorated, command);, +					}, +					super.execute(decorated);, +	@Override, +	protected void cancelRemainingTask(Runnable task) {, +		super.cancelRemainingTask(task);, +		// Cancel associated user-level Future handle as well]