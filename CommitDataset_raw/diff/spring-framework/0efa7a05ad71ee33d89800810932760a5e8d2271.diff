[+++ b/spring-core/src/main/java/org/springframework/util/ClassUtils.java, +	public static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader), +			throws IllegalArgumentException {, +, +	 * (may be {@code null} which indicates the default class loader), +	 * Check whether the given class is visible in the given ClassLoader., +	 * @param clazz the class to check (typically an interface), +	 * @param classLoader the ClassLoader to check against, +	 * (may be {@code null} in which case this method will always return {@code true}), +	public static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {, +		if (classLoader == null) {, +			return true;, +		try {, +			return (clazz == classLoader.loadClass(clazz.getName()));, +			// Else: different class with same name found, +		catch (ClassNotFoundException ex) {, +			// No corresponding class found at all, +			return false;, +	 * (may be {@code null} which indicates the system class loader), +		return (classLoader != null && isVisible(clazz, classLoader));, +, +	/**, +	 * Resolve the given class name as primitive class, if appropriate,, +	 * according to the JVM's naming rules for primitive classes., +	 * <p>Also supports the JVM's internal class names for primitive arrays., +	 * Does <i>not</i> support the "[]" suffix notation for primitive arrays;, +	 * this is only supported by {@link #forName(String, ClassLoader)}., +	 * @param name the name of the potentially primitive class, +	 * @return the primitive class, or {@code null} if the name does not denote, +	 * a primitive class or primitive array class, +	 */, +	@Nullable, +	public static Class<?> resolvePrimitiveClassName(@Nullable String name) {, +		Class<?> result = null;, +		// Most class names will be quite long, considering that they, +		// SHOULD sit in a package, so a length check is worthwhile., +		if (name != null && name.length() <= 8) {, +			// Could be a primitive - likely., +			result = primitiveTypeNameMap.get(name);, +		}, +		return result;, +	}, +, +	/**, +	 * Check if the given class represents a primitive wrapper,, +	 * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double., +	 * @param clazz the class to check, +	 * @return whether the given class is a primitive wrapper class, +	 */, +	public static boolean isPrimitiveWrapper(Class<?> clazz) {, +		Assert.notNull(clazz, "Class must not be null");, +		return primitiveWrapperTypeMap.containsKey(clazz);, +	}, +, +	/**, +	 * Check if the given class represents a primitive (i.e. boolean, byte,, +	 * char, short, int, long, float, or double) or a primitive wrapper, +	 * (i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double)., +	 * @param clazz the class to check, +	 * @return whether the given class is a primitive or primitive wrapper class, +	 */, +	public static boolean isPrimitiveOrWrapper(Class<?> clazz) {, +		Assert.notNull(clazz, "Class must not be null");, +		return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));, +	}, +, +	/**, +	 * Check if the given class represents an array of primitives,, +	 * i.e. boolean, byte, char, short, int, long, float, or double., +	 * @param clazz the class to check, +	 * @return whether the given class is a primitive array class, +	 */, +	public static boolean isPrimitiveArray(Class<?> clazz) {, +		Assert.notNull(clazz, "Class must not be null");, +		return (clazz.isArray() && clazz.getComponentType().isPrimitive());, +	}, +, +	/**, +	 * Check if the given class represents an array of primitive wrappers,, +	 * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double., +	 * @param clazz the class to check, +	 * @return whether the given class is a primitive wrapper array class, +	 */, +	public static boolean isPrimitiveWrapperArray(Class<?> clazz) {, +		Assert.notNull(clazz, "Class must not be null");, +		return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));, +	}, +, +	/**, +	 * Resolve the given class if it is a primitive class,, +	 * returning the corresponding primitive wrapper type instead., +	 * @param clazz the class to check, +	 * @return the original class, or a primitive wrapper for the original primitive type, +	 */, +	public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {, +		Assert.notNull(clazz, "Class must not be null");, +		return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);, +	}, +, +	/**]