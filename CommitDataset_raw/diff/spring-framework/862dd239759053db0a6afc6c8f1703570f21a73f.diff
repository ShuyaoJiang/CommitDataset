[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	/**, +	 * Invoked after an I/O read error from the underlying server or after a, +	 * cancellation signal from the downstream consumer to allow sub-classes, +	 * to discard any current cached data they might have., +	 * @since 5.1.2, +	 */, +	protected abstract void discardData();, +, +			if (publisher.changeState(this, COMPLETED)) {, +				publisher.discardData();, +			}, +			else {, +				publisher.discardData();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	/**, +	 * Invoked after an I/O read error from the underlying server or after a, +	 * cancellation signal from the downstream consumer to allow sub-classes, +	 * to discard any current cached data they might have., +	 * @since 5.1.2, +	 */, +	protected abstract void discardData();, +, +			if (publisher.changeState(this, COMPLETED)) {, +				publisher.discardData();, +			}, +			else {, +				publisher.discardData();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerWriteProcessor.java, +		// Technically, cancellation from the result subscriber should be propagated, +		// to the upstream subscription. In practice, HttpHandler server adapters, +		// don't have a reason to cancel the result subscription., +		T prev = this.currentData;, +		if (prev != null) {, +			// This shouldn't happen:, +			//   1. dataReceived can only be called from REQUESTED state, +			//   2. currentData is cleared before requesting, +			discardData(data);, +			cancel();, +			onError(new IllegalStateException("Received new data while current not processed yet."));, +	/**, +	 * Invoked after any error (either from the upstream write Publisher, or, +	 * from I/O operations to the underlying server) and cancellation, +	 * to discard in-flight data that was in, +	 * the process of being written when the error took place., +	 * @param data the data to be released, +	 * @since 5.1.2, +	 */, +	protected abstract void discardData(T data);, +, +			discardCurrentData();, +	private void discardCurrentData() {, +		T data = this.currentData;, +		this.currentData = null;, +		if (data != null) {, +			discardData(data);, +		}, +	}, +, +			processor.discardData(data);, +			processor.cancel();, +			processor.onError(new IllegalStateException("Illegal onNext without demand"));, +				processor.discardCurrentData();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	/**, +	 * Invoked after an I/O read error from the underlying server or after a, +	 * cancellation signal from the downstream consumer to allow sub-classes, +	 * to discard any current cached data they might have., +	 * @since 5.1.2, +	 */, +	protected abstract void discardData();, +, +			if (publisher.changeState(this, COMPLETED)) {, +				publisher.discardData();, +			}, +			else {, +				publisher.discardData();, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerWriteProcessor.java, +		// Technically, cancellation from the result subscriber should be propagated, +		// to the upstream subscription. In practice, HttpHandler server adapters, +		// don't have a reason to cancel the result subscription., +		T prev = this.currentData;, +		if (prev != null) {, +			// This shouldn't happen:, +			//   1. dataReceived can only be called from REQUESTED state, +			//   2. currentData is cleared before requesting, +			discardData(data);, +			cancel();, +			onError(new IllegalStateException("Received new data while current not processed yet."));, +	/**, +	 * Invoked after any error (either from the upstream write Publisher, or, +	 * from I/O operations to the underlying server) and cancellation, +	 * to discard in-flight data that was in, +	 * the process of being written when the error took place., +	 * @param data the data to be released, +	 * @since 5.1.2, +	 */, +	protected abstract void discardData(T data);, +, +			discardCurrentData();]