[+++ b/spring-framework-reference/src/scheduling.xml, +, +, +    <para>The Spring Framework provides abstractions for asynchronous, +    execution and scheduling of tasks with the, +    <interfacename>TaskExecutor</interfacename> and, +    <interfacename>TaskScheduler</interfacename> interfaces, respectively., +    Spring also features implementations of those interfaces that support, +    thread pools or delegation to CommonJ within an application server, +    environment. Ultimately the use of these implementations behind the common, +    interfaces abstracts away the differences between Java SE 5, Java SE 6 and, +    Java EE environments.</para>, +, +    <para>Spring also features integration classes for supporting scheduling, +    with the <classname>Timer</classname>, part of the JDK since 1.3, and the, +    Quartz Scheduler (<ulink, +    url="http://www.opensymphony.com/quartz/"></ulink>). Both of those, +    schedulers are set up using a <interfacename>FactoryBean</interfacename>, +    with optional references to <classname>Timer</classname> or, +    <classname>Trigger</classname> instances, respectively. Furthermore, a, +    convenience class for both the Quartz Scheduler and the, +    <classname>Timer</classname> is available that allows you to invoke a, +    method of an existing target object (analogous to the normal, +    <classname>MethodInvokingFactoryBean</classname> operation).</para>, +    <title>The Spring <interfacename>TaskExecutor</interfacename>, +    abstraction</title>, +    <para>Spring 2.0 introduces a new abstraction for dealing with executors., +    Executors are the Java 5 name for the concept of thread pools. The, +    "executor" naming is due to the fact that there is no guarantee that the, +    underlying implementation is actually a pool; an executor may be, +    single-threaded or even synchronous. Spring's abstraction hides, +    implementation details between Java SE 1.4, Java SE 5 and Java EE, +    environments.</para>, +    for execution based on the semantics and configuration of the thread, +    pool.</para>, +, +    created to give other Spring components an abstraction for thread pooling, +    where needed. Components such as the, +    <classname>ApplicationEventMulticaster</classname>, JMS's, +    <classname>AbstractMessageListenerContainer</classname>, and Quartz, +    integration all use the <interfacename>TaskExecutor</interfacename>, +    abstraction to pool threads. However, if your beans need thread pooling, +    behavior, it is possible to use this abstraction for your own, +    needs.</para>, +, +      <interfacename>TaskExecutor</interfacename> included with the Spring, +      distribution. In all likelihood, you shouldn't ever need to implement, +      your own.</para>, +          <para><classname>SimpleAsyncTaskExecutor</classname></para>, +          <para>This implementation does not reuse any threads, rather it, +          starts up a new thread for each invocation. However, it does support, +          a concurrency limit which will block any invocations that are over, +          the limit until a slot has been freed up. If you're looking for true, +          pooling, keep scrolling further down the page.</para>, +          <para><classname>SyncTaskExecutor</classname></para>, +          <para>This implementation doesn't execute invocations, +          asynchronously. Instead, each invocation takes place in the calling, +          thread. It is primarily used in situations where multithreading, +          isn't necessary such as simple test cases.</para>, +          <para><classname>ConcurrentTaskExecutor</classname></para>, +          <para>This implementation is a wrapper for a Java 5, +          <classname>java.util.concurrent.Executor</classname>. There is an, +          alternative, <classname>ThreadPoolTaskExecutor</classname>, that, +          exposes the <classname>Executor</classname> configuration parameters, +          as bean properties. It is rare to need to use the, +          <classname>ConcurrentTaskExecutor</classname> but if the <link, +          linkend="threadPoolTaskExecutor"><classname>ThreadPoolTaskExecutor</classname></link>, +          <classname>ConcurrentTaskExecutor</classname> is an, +          alternative.</para>, +          <para><classname>SimpleThreadPoolTaskExecutor</classname></para>, +          <para>This implementation is actually a subclass of Quartz's, +          <classname>SimpleThreadPool</classname> which listens to Spring's, +          lifecycle callbacks. This is typically used when you have a thread, +          pool that may need to be shared by both Quartz and non-Quartz, +          components.</para>, +          <para><classname>ThreadPoolTaskExecutor</classname></para>, +            <para>It is not possible to use any backport or alternate versions, +            of the <classname>java.util.concurrent</classname> package with, +            this implementation. Both Doug Lea's and Dawid Kurzyniec's, +            implementations use different package structures which will, +            prevent them from working correctly.</para>, +          <para>This implementation can only be used in a Java 5 environment, +          but is also the most commonly used one in that environment. It, +          exposes bean properties for configuring a, +          <classname>java.util.concurrent.ThreadPoolExecutor</classname> and, +          wraps it in a <interfacename>TaskExecutor</interfacename>. If you, +          need something advanced such as a, +          <classname>ScheduledThreadPoolExecutor</classname>, it is, +          recommended that you use a <link, +          linkend="concurrentTaskExecutor"><classname>ConcurrentTaskExecutor</classname></link>, +          instead.</para>, +          <para><classname>TimerTaskExecutor</classname></para>, +          <para>This implementation uses a single, +          <classname>TimerTask</classname> as its backing implementation. It's, +          different from the <link, +          linkend="syncTaskExecutor"><classname>SyncTaskExecutor</classname></link>, +          in that the method invocations are executed in a separate thread,, +          although they are synchronous in that thread.</para>, +          <para><classname>WorkManagerTaskExecutor</classname></para>, +          <sidebar>]