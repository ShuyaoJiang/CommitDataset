[+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +		return getAsyncResult(-1);, +	}, +, +	public Object getAsyncResult(long timeout) {, +		if ((timeout != 0) && request.isAsyncStarted()) {, +			if (!awaitAsyncResult(request, timeout)) {, +	private boolean awaitAsyncResult(HttpServletRequest request, long timeout) {, +		if (timeout != -1) {, +			timeout = request.getAsyncContext().getTimeout();, +		}, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +		return getAsyncResult(-1);, +	}, +, +	public Object getAsyncResult(long timeout) {, +		if ((timeout != 0) && request.isAsyncStarted()) {, +			if (!awaitAsyncResult(request, timeout)) {, +	private boolean awaitAsyncResult(HttpServletRequest request, long timeout) {, +		if (timeout != -1) {, +			timeout = request.getAsyncContext().getTimeout();, +		}, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/MvcResult.java, +	/**, +	 * Get the result of asynchronous execution or {@code null} if concurrent, +	 * handling did not start. This method will wait for up to the given timeout, +	 * for the completion of concurrent handling., +	 *, +	 * @param timeout how long to wait for the async result to be set in, +	 * milliseconds; if -1, the wait will be as long as the async timeout set, +	 * on the Servlet request, +	 */, +	Object getAsyncResult(long timeout);, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +		return getAsyncResult(-1);, +	}, +, +	public Object getAsyncResult(long timeout) {, +		if ((timeout != 0) && request.isAsyncStarted()) {, +			if (!awaitAsyncResult(request, timeout)) {, +	private boolean awaitAsyncResult(HttpServletRequest request, long timeout) {, +		if (timeout != -1) {, +			timeout = request.getAsyncContext().getTimeout();, +		}, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/MvcResult.java, +	/**, +	 * Get the result of asynchronous execution or {@code null} if concurrent, +	 * handling did not start. This method will wait for up to the given timeout, +	 * for the completion of concurrent handling., +	 *, +	 * @param timeout how long to wait for the async result to be set in, +	 * milliseconds; if -1, the wait will be as long as the async timeout set, +	 * on the Servlet request, +	 */, +	Object getAsyncResult(long timeout);, +, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/result/PrintingResultHandler.java, +import java.util.Map;, +, +import javax.servlet.ServletRequest;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +		if (ClassUtils.hasMethod(ServletRequest.class, "startAsync")) {, +			this.printer.printHeading("Async");, +			printAsyncResult(result);, +		}, +, +		this.printer.printValue("Parameters", getParamsMultiValueMap(request));, +	protected final HttpHeaders getRequestHeaders(MockHttpServletRequest request) {, +	protected final MultiValueMap<String, String> getParamsMultiValueMap(MockHttpServletRequest request) {, +		Map<String, String[]> params = request.getParameterMap();, +		MultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<String, String>();, +		for (String name : params.keySet()) {, +			if (params.get(name) != null) {, +				for (String value : params.get(name)) {, +					multiValueMap.add(name, value);, +				}, +			}, +		}, +		return multiValueMap;, +	}, +, +	protected void printAsyncResult(MvcResult result) throws Exception {, +		this.printer.printValue("Was async started", result.getRequest().isAsyncStarted());, +		this.printer.printValue("Async result", result.getAsyncResult(0));, +	}, +, +	protected final HttpHeaders getResponseHeaders(MockHttpServletResponse response) {, +++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/DefaultMvcResult.java, +		return getAsyncResult(-1);, +	}, +, +	public Object getAsyncResult(long timeout) {, +		if ((timeout != 0) && request.isAsyncStarted()) {, +			if (!awaitAsyncResult(request, timeout)) {, +	private boolean awaitAsyncResult(HttpServletRequest request, long timeout) {, +		if (timeout != -1) {, +			timeout = request.getAsyncContext().getTimeout();]