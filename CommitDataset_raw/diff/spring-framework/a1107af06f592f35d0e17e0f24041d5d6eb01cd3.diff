[+++ b/spring-orm-hibernate5/src/main/java/org/springframework/orm/hibernate5/HibernateTransactionManager.java, +		if (this.prepareConnection && isPhysicallyConnected(session)) {, +		if (!(session instanceof SessionImplementor)) {, +			// The best we can do is to assume we're safe., +		ConnectionReleaseMode releaseMode =, +				((SessionImplementor) session).getJdbcCoordinator().getConnectionReleaseMode();, +		return ConnectionReleaseMode.ON_CLOSE.equals(releaseMode);, +	}, +, +	/**, +	 * Determine whether the given Session is (still) physically connected, +	 * to the database, that is, holds an active JDBC Connection internally., +	 * @param session the Hibernate Session to check, +	 * @see #isSameConnectionForEntireSession(Session), +	 */, +	protected boolean isPhysicallyConnected(Session session) {, +		if (!(session instanceof SessionImplementor)) {, +			// The best we can do is to check whether we're logically connected., +			return session.isConnected();, +		}, +		return ((SessionImplementor) session).getJdbcCoordinator().getLogicalConnection().isPhysicallyConnected();, +	}, +++ b/spring-orm-hibernate5/src/main/java/org/springframework/orm/hibernate5/HibernateTransactionManager.java, +		if (this.prepareConnection && isPhysicallyConnected(session)) {, +		if (!(session instanceof SessionImplementor)) {, +			// The best we can do is to assume we're safe., +		ConnectionReleaseMode releaseMode =, +				((SessionImplementor) session).getJdbcCoordinator().getConnectionReleaseMode();, +		return ConnectionReleaseMode.ON_CLOSE.equals(releaseMode);, +	}, +, +	/**, +	 * Determine whether the given Session is (still) physically connected, +	 * to the database, that is, holds an active JDBC Connection internally., +	 * @param session the Hibernate Session to check, +	 * @see #isSameConnectionForEntireSession(Session), +	 */, +	protected boolean isPhysicallyConnected(Session session) {, +		if (!(session instanceof SessionImplementor)) {, +			// The best we can do is to check whether we're logically connected., +			return session.isConnected();, +		}, +		return ((SessionImplementor) session).getJdbcCoordinator().getLogicalConnection().isPhysicallyConnected();, +	}, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java, +import org.apache.commons.logging.LogFactory;, +		Connection preparedCon = null;, +				preparedCon = HibernateConnectionHandle.doGetConnection(session);, +				previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition);, +		return new SessionTransactionData(session, previousFlushMode, preparedCon, previousIsolationLevel);, +		return new SessionTransactionData(session, previousFlushMode, null, null);, +		private final Connection preparedCon;, +				Session session, FlushMode previousFlushMode, Connection preparedCon, Integer previousIsolationLevel) {, +			this.preparedCon = preparedCon;, +			if (this.preparedCon != null && this.session.isConnected()) {, +				Connection conToReset = HibernateConnectionHandle.doGetConnection(this.session);, +				if (conToReset != this.preparedCon) {, +					LogFactory.getLog(HibernateJpaDialect.class).warn(, +							"JDBC Connection to reset not identical to originally prepared Connection - please " +, +							"make sure to use connection release mode ON_CLOSE (the default) and to run against " +, +							"Hibernate 4.2+ (or switch HibernateJpaDialect's prepareConnection flag to false");, +				}, +				DataSourceUtils.resetConnectionAfterTransaction(conToReset, this.previousIsolationLevel);]