[+++ b/build.gradle, +		optional("org.glassfish.tyrus:tyrus-container-servlet:1.0-SNAPSHOT"), +		optional("com.fasterxml.jackson.core:jackson-databind:2.0.1") // required for SockJS support currently, +++ b/build.gradle, +		optional("org.glassfish.tyrus:tyrus-container-servlet:1.0-SNAPSHOT"), +		optional("com.fasterxml.jackson.core:jackson-databind:2.0.1") // required for SockJS support currently, +++ b/spring-websocket/src/main/java/org/springframework/websocket/server/AbstractHandshakeHandler.java, +import org.springframework.util.StringUtils;, +	private List<String> supportedProtocols;, +	public void setSupportedProtocols(String... protocols) {, +		this.supportedProtocols = Arrays.asList(protocols);, +	public String[] getSupportedProtocols() {, +		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()]);, +		if (!"WebSocket".equalsIgnoreCase(request.getHeaders().getUpgrade())) {, +			handleInvalidUpgradeHeader(request, response);, +		if (!request.getHeaders().getConnection().contains("Upgrade")) {, +			handleInvalidConnectHeader(request, response);, +		if (!isWebSocketVersionSupported(request)) {, +			handleWebSocketVersionNotSupported(request, response);, +		if (!isValidOrigin(request)) {, +			response.setStatusCode(HttpStatus.FORBIDDEN);, +, +		// TODO: select extensions, +		// TODO: surely there is a better way to flush headers, +, +	protected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {, +		logger.debug("Invalid Upgrade header " + request.getHeaders().getUpgrade());, +	protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {, +		logger.debug("Invalid Connection header " + request.getHeaders().getConnection());, +	protected boolean isWebSocketVersionSupported(ServerHttpRequest request) {, +		String requestedVersion = request.getHeaders().getSecWebSocketVersion();, +		for (String supportedVersion : getSupportedVerions()) {, +			if (supportedVersion.equals(requestedVersion)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	protected String[] getSupportedVerions() {, +		return new String[] { "13" };, +	}, +, +	protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {, +		response.setStatusCode(HttpStatus.UPGRADE_REQUIRED);, +		response.getHeaders().setSecWebSocketVersion(StringUtils.arrayToCommaDelimitedString(getSupportedVerions()));, +	protected boolean isValidOrigin(ServerHttpRequest request) {, +			// UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(origin);, +			// A simple strategy checks against the current request's scheme/port/host, +			// Or match scheme, port, and host against configured allowed origins (wild cards for hosts?), +			for (String protocol : requestedProtocols) {, +				if (this.supportedProtocols.contains(protocol)) {, +					return protocol;, +++ b/build.gradle, +		optional("org.glassfish.tyrus:tyrus-container-servlet:1.0-SNAPSHOT"), +		optional("com.fasterxml.jackson.core:jackson-databind:2.0.1") // required for SockJS support currently, +++ b/spring-websocket/src/main/java/org/springframework/websocket/server/AbstractHandshakeHandler.java, +import org.springframework.util.StringUtils;, +	private List<String> supportedProtocols;, +	public void setSupportedProtocols(String... protocols) {, +		this.supportedProtocols = Arrays.asList(protocols);, +	public String[] getSupportedProtocols() {, +		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()]);, +		if (!"WebSocket".equalsIgnoreCase(request.getHeaders().getUpgrade())) {, +			handleInvalidUpgradeHeader(request, response);, +		if (!request.getHeaders().getConnection().contains("Upgrade")) {, +			handleInvalidConnectHeader(request, response);, +		if (!isWebSocketVersionSupported(request)) {, +			handleWebSocketVersionNotSupported(request, response);, +		if (!isValidOrigin(request)) {, +			response.setStatusCode(HttpStatus.FORBIDDEN);, +, +		// TODO: select extensions, +		// TODO: surely there is a better way to flush headers, +, +	protected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {, +		logger.debug("Invalid Upgrade header " + request.getHeaders().getUpgrade());, +	protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {, +		logger.debug("Invalid Connection header " + request.getHeaders().getConnection());, +	protected boolean isWebSocketVersionSupported(ServerHttpRequest request) {, +		String requestedVersion = request.getHeaders().getSecWebSocketVersion();, +		for (String supportedVersion : getSupportedVerions()) {, +			if (supportedVersion.equals(requestedVersion)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	protected String[] getSupportedVerions() {, +		return new String[] { "13" };, +	}, +, +	protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {, +		response.setStatusCode(HttpStatus.UPGRADE_REQUIRED);, +		response.getHeaders().setSecWebSocketVersion(StringUtils.arrayToCommaDelimitedString(getSupportedVerions()));, +	protected boolean isValidOrigin(ServerHttpRequest request) {, +			// UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(origin);, +			// A simple strategy checks against the current request's scheme/port/host, +			// Or match scheme, port, and host against configured allowed origins (wild cards for hosts?)]