[+++ b/build.gradle, +		if (project.name in ["spring", "spring-jms",, +++ b/build.gradle, +		if (project.name in ["spring", "spring-jms",, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, + * Copyright 2002-2012 the original author or authors., +		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +++ b/build.gradle, +		if (project.name in ["spring", "spring-jms",, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, + * Copyright 2002-2012 the original author or authors., +		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +++ b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java, + * Copyright 2002-2009 the original author or authors., +++ b/build.gradle, +		if (project.name in ["spring", "spring-jms",, +++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java, + * Copyright 2002-2012 the original author or authors., +		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);, +		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);, +++ b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java, + * Copyright 2002-2009 the original author or authors., +++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateInterceptorTests.java, + * Copyright 2002-2013 the original author or authors., +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static org.mockito.BDDMockito.given;, +import static org.mockito.BDDMockito.willThrow;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Test;, +import org.mockito.InOrder;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, + * @author Phillip Webb, +public class HibernateInterceptorTests {, +	private SessionFactory sessionFactory;, +	private Session session;, +	private MethodInvocation invocation;, +, +	@Before, +	public void setUp() throws Throwable {, +		this.sessionFactory = mock(SessionFactory.class);, +		this.session = mock(Session.class);, +		this.invocation = mock(MethodInvocation.class);, +		given(sessionFactory.openSession()).willReturn(session);, +		given(session.getSessionFactory()).willReturn(sessionFactory);, +		given(invocation.proceed()).willAnswer(new Answer<Object>() {, +			@Override, +			public Object answer(InvocationOnMock invocation) throws Throwable {, +				if (!TransactionSynchronizationManager.hasResource(sessionFactory)) {, +					throw new IllegalStateException("Session not bound");, +				}, +				return null;, +			}, +		});, +	}, +, +	@After, +	public void tearDown() {, +		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());, +		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());, +	}, +, +	@Test, +		interceptor.setSessionFactory(sessionFactory);, +			interceptor.invoke(invocation);, +		verify(session).flush();, +		verify(session).close();, +	@Test, +		interceptor.setSessionFactory(sessionFactory);, +			interceptor.invoke(invocation);, +		verify(session).setFlushMode(FlushMode.MANUAL);, +		verify(session, never()).flush();, +		verify(session).close();, +	@Test, +		interceptor.setSessionFactory(sessionFactory);, +			interceptor.invoke(invocation);, +		verify(session).flush();, +		verify(session).close();, +	@Test, +		given(session.isOpen()).willReturn(true);, +		TransactionSynchronizationManager.bindResource(sessionFactory, new SessionHolder(session));, +		interceptor.setSessionFactory(sessionFactory);]