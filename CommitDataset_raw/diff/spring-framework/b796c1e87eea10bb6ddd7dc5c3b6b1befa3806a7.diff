[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.java, +	private volatile boolean readyToSend;, +		synchronized (this.responseLock) {, +			try {, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					writeFrame(SockJsFrame.openFrame());, +					return;, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					if (this.messageCache.isEmpty()) {, +						scheduleHeartbeat();, +						this.readyToSend = true;, +					}, +					else {, +						flushCache();, +					}, +				}, +			this.messageCache.add(message);, +			if (isActive() && this.readyToSend) {, +				return;, +				return;, +			this.readyToSend = false;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.java, +	private volatile boolean readyToSend;, +		synchronized (this.responseLock) {, +			try {, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					writeFrame(SockJsFrame.openFrame());, +					return;, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					if (this.messageCache.isEmpty()) {, +						scheduleHeartbeat();, +						this.readyToSend = true;, +					}, +					else {, +						flushCache();, +					}, +				}, +			this.messageCache.add(message);, +			if (isActive() && this.readyToSend) {, +				return;, +				return;, +			this.readyToSend = false;, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/StreamingSockJsSession.java, +		while (!getMessageCache().isEmpty()) {, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.java, +	private volatile boolean readyToSend;, +		synchronized (this.responseLock) {, +			try {, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					writeFrame(SockJsFrame.openFrame());, +					return;, +				this.asyncRequestControl.start(-1);, +, +				if (isStreaming()) {, +					flushCache();, +					this.readyToSend = true;, +				}, +				else {, +					if (this.messageCache.isEmpty()) {, +						scheduleHeartbeat();, +						this.readyToSend = true;, +					}, +					else {, +						flushCache();, +					}, +				}, +			this.messageCache.add(message);, +			if (isActive() && this.readyToSend) {, +				return;, +				return;]