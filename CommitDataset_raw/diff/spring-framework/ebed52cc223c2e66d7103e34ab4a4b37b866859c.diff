[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, + * Java's {@link java.lang.annotation.Inherited @Inherited} annotation except, + * that locally declared annotations (including custom composed annotations), + * will be favored over inherited annotations. In contrast, methods following, + * <em>find semantics</em> will completely ignore the presence of, + * {@code @Inherited} since the <em>find</em> search algorithm manually, + * traverses type and method hierarchies and thereby implicitly supports, + * annotation inheritance without the need for {@code @Inherited}., +		return searchWithFindSemantics(element, annotationType, new MergedAnnotationAttributesProcessor(annotationType,, +			classValuesAsString, nestedAnnotationsAsMap));, +				// Start searching within locally declared annotations, +				List<Annotation> declaredAnnotations = Arrays.asList(element.getDeclaredAnnotations());, +				T result = searchWithGetSemanticsInAnnotations(declaredAnnotations, annotationType, processor, visited,, +					metaDepth);, +				if (result != null) {, +					return result;, +				}, +, +				List<Annotation> inheritedAnnotations = new ArrayList<Annotation>();, +				for (Annotation annotation : element.getAnnotations()) {, +					if (!declaredAnnotations.contains(annotation)) {, +						inheritedAnnotations.add(annotation);, +					}, +				}, +, +				// Continue searching within inherited annotations, +				result = searchWithGetSemanticsInAnnotations(inheritedAnnotations, annotationType, processor, visited,, +					metaDepth);, +				if (result != null) {, +					return result;, +				}, +			}, +			catch (Exception ex) {, +				AnnotationUtils.logIntrospectionFailure(element, ex);, +			}, +		}, +		return null;, +	}, +, +	/**, +	 * This method is invoked by, +	 * {@link #searchWithGetSemantics(AnnotatedElement, String, Processor, Set, int)}, +	 * to perform the actual search within the supplied list of annotations., +	 * <p>This method should be invoked first with locally declared annotations, +	 * and then subsequently with inherited annotations, thereby allowing, +	 * local annotations to take precedence over inherited annotations., +	 *, +	 * <p>The {@code metaDepth} parameter is explained in the, +	 * {@link Processor#process process()} method of the {@link Processor}, +	 * API., +	 *, +	 * @param annotations the annotations to search in; never {@code null}, +	 * @param annotationType the fully qualified class name of the annotation, +	 * type to find; never {@code null} or empty, +	 * @param processor the processor to delegate to, +	 * @param visited the set of annotated elements that have already been visited, +	 * @param metaDepth the meta-depth of the annotation, +	 * @return the result of the processor, potentially {@code null}, +	 */, +	private static <T> T searchWithGetSemanticsInAnnotations(List<Annotation> annotations, String annotationType,, +			Processor<T> processor, Set<AnnotatedElement> visited, int metaDepth) {, +, +		// Search in annotations, +		// Recursively search in meta-annotations, +				T result = searchWithGetSemantics(annotation.annotationType(), annotationType, processor, visited,, +					metaDepth + 1);, +	 * @param processor the processor to delegate to, +	 * @return the result of the processor, potentially {@code null}, +	 */, +	private static <T> T searchWithFindSemantics(AnnotatedElement element, String annotationType, Processor<T> processor) {, +		return searchWithFindSemantics(element, annotationType, true, true, true, true, processor);, +	}, +, +	/**, +	 * Search for annotations of the specified {@code annotationType} on, +	 * the specified {@code element}, following <em>find semantics</em>., +	 *, +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the fully qualified class name of the annotation, +	 * type to find; never {@code null} or empty, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, + * Java's {@link java.lang.annotation.Inherited @Inherited} annotation except, + * that locally declared annotations (including custom composed annotations), + * will be favored over inherited annotations. In contrast, methods following, + * <em>find semantics</em> will completely ignore the presence of, + * {@code @Inherited} since the <em>find</em> search algorithm manually, + * traverses type and method hierarchies and thereby implicitly supports, + * annotation inheritance without the need for {@code @Inherited}., +		return searchWithFindSemantics(element, annotationType, new MergedAnnotationAttributesProcessor(annotationType,, +			classValuesAsString, nestedAnnotationsAsMap));, +				// Start searching within locally declared annotations, +				List<Annotation> declaredAnnotations = Arrays.asList(element.getDeclaredAnnotations());, +				T result = searchWithGetSemanticsInAnnotations(declaredAnnotations, annotationType, processor, visited,, +					metaDepth);]