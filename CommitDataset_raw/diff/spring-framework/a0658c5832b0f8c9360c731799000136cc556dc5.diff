[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java, + * Copyright 2002-2014 the original author or authors., +, +			if (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {, +				// Add our local Advisor to the existing proxy's Advisor chain..., +		}, +, +		if (isEligible(bean, beanName)) {, +, +	 * <p>Delegates to {@link #isEligible(Class)} for target class checking., +	 * <p>Note: Only called for regular bean instances but not for existing, +	 * proxy instances which implement {@link Advised} and allow for adding, +	 * the local {@link Advisor} to the existing proxy's {@link Advisor} chain., +	 * For the latter, {@link #isEligible(Class)} is being called directly,, +	 * with the actual target class behind the existing proxy (as determined, +	 * by {@link AopUtils#getTargetClass(Object)})., +	 * @see #isEligible(Class), +		return isEligible(bean.getClass());, +	}, +, +	/**, +	 * Check whether the given class is eligible for advising with this, +	 * post-processor's {@link Advisor}., +	 * <p>Implements caching of {@code canApply} results per bean target class., +	 * @param targetClass the class to check against, +	 * @see AopUtils#canApply(Advisor, Class), +	 */, +	protected boolean isEligible(Class<?> targetClass) {, +++ b/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java, + * Copyright 2002-2014 the original author or authors., +, +			if (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {, +				// Add our local Advisor to the existing proxy's Advisor chain..., +		}, +, +		if (isEligible(bean, beanName)) {, +, +	 * <p>Delegates to {@link #isEligible(Class)} for target class checking., +	 * <p>Note: Only called for regular bean instances but not for existing, +	 * proxy instances which implement {@link Advised} and allow for adding, +	 * the local {@link Advisor} to the existing proxy's {@link Advisor} chain., +	 * For the latter, {@link #isEligible(Class)} is being called directly,, +	 * with the actual target class behind the existing proxy (as determined, +	 * by {@link AopUtils#getTargetClass(Object)})., +	 * @see #isEligible(Class), +		return isEligible(bean.getClass());, +	}, +, +	/**, +	 * Check whether the given class is eligible for advising with this, +	 * post-processor's {@link Advisor}., +	 * <p>Implements caching of {@code canApply} results per bean target class., +	 * @param targetClass the class to check against, +	 * @see AopUtils#canApply(Advisor, Class), +	 */, +	protected boolean isEligible(Class<?> targetClass) {, +++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java, +import java.util.HashMap;, +import org.aopalliance.intercept.MethodInterceptor;, +import org.aopalliance.intercept.MethodInvocation;, +import org.springframework.aop.framework.ProxyFactory;, +import org.springframework.aop.support.DefaultIntroductionAdvisor;, +import org.springframework.beans.factory.FactoryBean;, +	public void asyncClassWithPostProcessor() throws Exception {, +		originalThreadName = Thread.currentThread().getName();, +		GenericApplicationContext context = new GenericApplicationContext();, +		context.registerBeanDefinition("asyncTest", new RootBeanDefinition(AsyncClassBean.class));, +		context.registerBeanDefinition("asyncProcessor", new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class));, +		context.refresh();, +		AsyncClassBean asyncTest = context.getBean("asyncTest", AsyncClassBean.class);, +		asyncTest.doSomething(10);, +		Future<String> future = asyncTest.returnSomething(20);, +		assertEquals("20", future.get());, +	}, +, +	@Test, +	public void asyncClassWithInterface() throws Exception {, +		originalThreadName = Thread.currentThread().getName();, +		GenericApplicationContext context = new GenericApplicationContext();, +		context.registerBeanDefinition("asyncTest", new RootBeanDefinition(AsyncClassBeanWithInterface.class));, +		context.registerBeanDefinition("autoProxyCreator", new RootBeanDefinition(DefaultAdvisorAutoProxyCreator.class));, +		context.registerBeanDefinition("asyncAdvisor", new RootBeanDefinition(AsyncAnnotationAdvisor.class));, +		context.refresh();, +		RegularInterface asyncTest = context.getBean("asyncTest", RegularInterface.class);, +		asyncTest.doSomething(10);, +		Future<String> future = asyncTest.returnSomething(20);, +		assertEquals("20", future.get());, +	}, +, +	@Test, +	public void asyncClassWithInterfaceAndPostProcessor() throws Exception {, +		originalThreadName = Thread.currentThread().getName();, +		GenericApplicationContext context = new GenericApplicationContext();, +		context.registerBeanDefinition("asyncTest", new RootBeanDefinition(AsyncClassBeanWithInterface.class));, +		context.registerBeanDefinition("asyncProcessor", new RootBeanDefinition(AsyncAnnotationBeanPostProcessor.class));, +		context.refresh();, +		RegularInterface asyncTest = context.getBean("asyncTest", RegularInterface.class);, +		asyncTest.doSomething(10);, +		Future<String> future = asyncTest.returnSomething(20);, +		assertEquals("20", future.get());]