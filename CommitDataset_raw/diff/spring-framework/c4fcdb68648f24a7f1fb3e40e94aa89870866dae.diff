[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +	@SuppressWarnings("unchecked"), +		String[] candidateNames = getBeanNamesForType(requiredType);, +		if (candidateNames.length > 1) {, +			for (String beanName : candidateNames) {, +				candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);, +		if (candidateNames.length == 1) {, +			String beanName = candidateNames[0];, +		else if (candidateNames.length > 1) {, +			Map<String, Object> candidates = new LinkedHashMap<>(candidateNames.length);, +			for (String candidateName : candidateNames) {, +				if (containsSingleton(candidateName)) {, +					candidates.put(candidateName, getBean(candidateName, requiredType, args));, +				else {, +					candidates.put(candidateName, getType(candidateName));, +			}, +			String candidateName = determinePrimaryCandidate(candidates, requiredType);, +			if (candidateName == null) {, +				candidateName = determineHighestPriorityCandidate(candidates, requiredType);, +			}, +			if (candidateName != null) {, +				Object beanInstance = candidates.get(candidateName);, +				if (beanInstance instanceof Class) {, +					beanInstance = getBean(candidateName, requiredType, args);, +				}, +				return new NamedBeanHolder<>(candidateName, (T) beanInstance);, +, +			String autowiredBeanName;, +			Object instanceCandidate;, +, +				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);, +				if (autowiredBeanName == null) {, +				instanceCandidate = matchingBeans.get(autowiredBeanName);, +			else {, +				autowiredBeanName = entry.getKey();, +				instanceCandidate = entry.getValue();, +, +			if (autowiredBeanNames != null) {, +				autowiredBeanNames.add(autowiredBeanName);, +			}, +			return (instanceCandidate instanceof Class ?, +					descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);, +			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,, +					new MultiElementDependencyDescriptor(descriptor));, +			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,, +					new MultiElementDependencyDescriptor(descriptor));, +			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,, +					new MultiElementDependencyDescriptor(descriptor));, +				addCandidateEntry(result, candidateName, descriptor, requiredType);, +					addCandidateEntry(result, candidateName, descriptor, requiredType);, +						addCandidateEntry(result, candidateName, descriptor, requiredType);, +	 * Add an entry to the candidate map: a bean instance if available or just the resolved, +	 * type, preventing early bean initialization ahead of primary candidate selection., +	 */, +	private void addCandidateEntry(Map<String, Object> candidates, String candidateName,, +			DependencyDescriptor descriptor, Class<?> requiredType) {, +, +		if (descriptor instanceof MultiElementDependencyDescriptor || containsSingleton(candidateName)) {, +			candidates.put(candidateName, descriptor.resolveCandidate(candidateName, requiredType, this));, +		}, +		else {, +			candidates.put(candidateName, getType(candidateName));, +		}, +	}, +, +	/**, +	 * @param candidates a Map of candidate names and candidate instances, +	protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {, +		String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);, +		String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);, +		for (Map.Entry<String, Object> entry : candidates.entrySet()) {, +			String candidateName = entry.getKey();, +					matchesBeanName(candidateName, descriptor.getDependencyName())) {, +				return candidateName;, +	 * @param candidates a Map of candidate names and candidate instances, +	 * (or candidate classes if not created yet) that match the required type, +	protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {, +		for (Map.Entry<String, Object> entry : candidates.entrySet()) {, +						throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),, +								"more than one 'primary' bean found among candidates: " + candidates.keySet());, +	 * Determine the candidate with the highest priority in the given set of beans., +	 * <p>Based on {@code @javax.annotation.Priority}. As defined by the related, +	 * {@link org.springframework.core.Ordered} interface, the lowest value has, +	 * the highest priority., +	 * @param candidates a Map of candidate names and candidate instances, +	 * (or candidate classes if not created yet) that match the required type, +	protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {, +		for (Map.Entry<String, Object> entry : candidates.entrySet()) {, +						throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),, +								"Multiple beans found with the same priority ('" + highestPriority +, +								"') among candidates: " + candidates.keySet());, +		DependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) {, +			this.descriptor = new NestedDependencyDescriptor(descriptor);, +, +	private static class NestedDependencyDescriptor extends DependencyDescriptor {, +, +		public NestedDependencyDescriptor(DependencyDescriptor original) {, +			super(original);, +			increaseNestingLevel();, +		}]