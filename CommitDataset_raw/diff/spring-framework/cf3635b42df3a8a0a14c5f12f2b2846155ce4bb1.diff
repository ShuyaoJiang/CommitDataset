[+++ b/spring-core/src/main/java/org/springframework/core/io/AbstractFileResolvingResource.java, +				if (con.getContentLengthLong() > 0) {, +				long contentLength = con.getContentLengthLong();, +			File file = getFile();, +			long length = file.length();, +			if (length == 0L && !file.exists()) {, +				throw new FileNotFoundException(getDescription() +, +						" cannot be resolved in the file system for checking its content length");, +			}, +			return length;, +			return con.getContentLengthLong();, +		boolean fileCheck = false;, +			fileCheck = true;, +				File fileToCheck = getFileForLastModifiedCheck();, +				long lastModified = fileToCheck.lastModified();, +				if (lastModified > 0L || fileToCheck.exists()) {, +					return lastModified;, +				}, +		long lastModified = con.getLastModified();, +		if (fileCheck && lastModified == 0 && con.getContentLengthLong() <= 0) {, +			throw new FileNotFoundException(getDescription() +, +					" cannot be resolved in the file system for checking its last-modified timestamp");, +		}, +		return lastModified;, +++ b/spring-core/src/main/java/org/springframework/core/io/AbstractFileResolvingResource.java, +				if (con.getContentLengthLong() > 0) {, +				long contentLength = con.getContentLengthLong();, +			File file = getFile();, +			long length = file.length();, +			if (length == 0L && !file.exists()) {, +				throw new FileNotFoundException(getDescription() +, +						" cannot be resolved in the file system for checking its content length");, +			}, +			return length;, +			return con.getContentLengthLong();, +		boolean fileCheck = false;, +			fileCheck = true;, +				File fileToCheck = getFileForLastModifiedCheck();, +				long lastModified = fileToCheck.lastModified();, +				if (lastModified > 0L || fileToCheck.exists()) {, +					return lastModified;, +				}, +		long lastModified = con.getLastModified();, +		if (fileCheck && lastModified == 0 && con.getContentLengthLong() <= 0) {, +			throw new FileNotFoundException(getDescription() +, +					" cannot be resolved in the file system for checking its last-modified timestamp");, +		}, +		return lastModified;, +++ b/spring-core/src/main/java/org/springframework/core/io/AbstractResource.java, +			byte[] buf = new byte[256];, +		File fileToCheck = getFileForLastModifiedCheck();, +		long lastModified = fileToCheck.lastModified();, +		if (lastModified == 0L && !fileToCheck.exists()) {, +					" cannot be resolved in the file system for checking its last-modified timestamp");, +++ b/spring-core/src/main/java/org/springframework/core/io/AbstractFileResolvingResource.java, +				if (con.getContentLengthLong() > 0) {, +				long contentLength = con.getContentLengthLong();, +			File file = getFile();, +			long length = file.length();, +			if (length == 0L && !file.exists()) {, +				throw new FileNotFoundException(getDescription() +, +						" cannot be resolved in the file system for checking its content length");, +			}, +			return length;, +			return con.getContentLengthLong();, +		boolean fileCheck = false;, +			fileCheck = true;, +				File fileToCheck = getFileForLastModifiedCheck();, +				long lastModified = fileToCheck.lastModified();, +				if (lastModified > 0L || fileToCheck.exists()) {, +					return lastModified;, +				}, +		long lastModified = con.getLastModified();, +		if (fileCheck && lastModified == 0 && con.getContentLengthLong() <= 0) {, +			throw new FileNotFoundException(getDescription() +, +					" cannot be resolved in the file system for checking its last-modified timestamp");, +		}, +		return lastModified;, +++ b/spring-core/src/main/java/org/springframework/core/io/AbstractResource.java, +			byte[] buf = new byte[256];, +		File fileToCheck = getFileForLastModifiedCheck();, +		long lastModified = fileToCheck.lastModified();, +		if (lastModified == 0L && !fileToCheck.exists()) {, +					" cannot be resolved in the file system for checking its last-modified timestamp");, +++ b/spring-core/src/main/java/org/springframework/core/io/FileSystemResource.java, +import java.nio.file.FileSystem;, +	 * If you prefer to have relative paths built underneath the given root directory,, +	 * use the {@link #FileSystemResource(String) constructor with a file path}, +	 * to append a trailing slash to the root path: "C:/dir1/", which indicates, +	 * this directory as root for all relative paths., +	 * Create a new {@code FileSystemResource} from a {@link Path} handle,, +	 * performing all file system interactions via NIO.2 instead of {@link File}., +		this.file = null;, +		this.filePath = filePath;, +	}, +, +	/**, +	 * Create a new {@code FileSystemResource} from a {@link FileSystem} handle,, +	 * locating the specified path., +	 * <p>This is an alternative to {@link #FileSystemResource(String)},]