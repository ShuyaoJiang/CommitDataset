[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java, +import org.springframework.messaging.support.MessageHeaderAccessor;, +		LinkedMultiValueMap<String, String> result = this.destinationCache.getSubscriptions(destination);, +		private final Map<String, LinkedMultiValueMap<String, String>> accessCache =, +				new ConcurrentHashMap<String, LinkedMultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT);, +		private final Map<String, LinkedMultiValueMap<String, String>> updateCache =, +				new LinkedHashMap<String, LinkedMultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT, 0.75f, true) {, +					protected boolean removeEldestEntry(Map.Entry<String, LinkedMultiValueMap<String, String>> eldest) {, +		public LinkedMultiValueMap<String, String> getSubscriptions(String destination) {, +		public void addSubscriptions(String destination, LinkedMultiValueMap<String, String> subscriptions) {, +				this.updateCache.put(destination, subscriptions.deepCopy());, +				for (Map.Entry<String, LinkedMultiValueMap<String, String>> entry : this.updateCache.entrySet()) {, +						LinkedMultiValueMap<String, String> subs = entry.getValue();, +						this.accessCache.put(cachedDestination, subs.deepCopy());, +				for (Map.Entry<String, LinkedMultiValueMap<String, String>> entry : this.updateCache.entrySet()) {, +					LinkedMultiValueMap<String, String> sessionMap = entry.getValue();, +							this.accessCache.put(destination, sessionMap.deepCopy());, +				for (Map.Entry<String, LinkedMultiValueMap<String, String>> entry : this.updateCache.entrySet()) {, +					LinkedMultiValueMap<String, String> sessionMap = entry.getValue();, +							this.accessCache.put(destination, sessionMap.deepCopy());, +, +, +, +			return "subscription(id=" + this.id + ")";, +, +			SimpMessageHeaderAccessor accessor =, +					MessageHeaderAccessor.getAccessor(headers, SimpMessageHeaderAccessor.class);]