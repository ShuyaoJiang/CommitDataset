[+++ b/org.springframework.core/src/main/java/org/springframework/core/convert/AbstractDescriptor.java, +		if (type == null) {, +			throw new IllegalArgumentException("type cannot be null");, +		}, +			Class<?> elementType = resolveCollectionElementType();, +			return elementType != null ? nested(elementType, 0) : null;, +			Class<?> mapValueType = resolveMapValueType();, +			return mapValueType != null ? nested(mapValueType, 1) : null;, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/AbstractDescriptor.java, +		if (type == null) {, +			throw new IllegalArgumentException("type cannot be null");, +		}, +			Class<?> elementType = resolveCollectionElementType();, +			return elementType != null ? nested(elementType, 0) : null;, +			Class<?> mapValueType = resolveMapValueType();, +			return mapValueType != null ? nested(mapValueType, 1) : null;, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	 * If this type is a {@link Collection} or an Array, creates a elementType descriptor from the provided collection or array element., +	 * Narrows the {@link #getElementType() elementType} property to the class of the provided collection or array element., +	 * For example, if this describes a java.util.List&lt;java.lang.Number&lt; and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.List&lt;?&gt; and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @return a element type descriptor, narrowed to the type of the provided element, +	 * @throws IllegalStateException if this type is not a java.util.Collection or Array type, +	 * @see #narrow(Object), +	 * If this type is a {@link Map}, creates a mapKeyType descriptor from the provided map key., +	 * Narrows the {@link #getMapKeyType() mapKeyType} property to the class of the provided map key., +	 * For example, if this describes a java.util.Map&lt;java.lang.Number, java.lang.String&lt; and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.Map&lt;?, ?&gt; and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @throws IllegalStateException if this type is not a java.util.Map., +	 * @see #narrow(Object), +	 * If this type is a {@link Map}, creates a mapValueType descriptor from the provided map value., +	 * Narrows the {@link #getMapValueType() mapValueType} property to the class of the provided map value., +	 * For example, if this describes a java.util.Map&lt;java.lang.String, java.lang.Number&lt; and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.Map&lt;?, ?&gt; and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @throws IllegalStateException if this type is not a java.util.Map. , +			if (descriptor == null) {, +				return null;, +			}, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/AbstractDescriptor.java, +		if (type == null) {, +			throw new IllegalArgumentException("type cannot be null");, +		}, +			Class<?> elementType = resolveCollectionElementType();, +			return elementType != null ? nested(elementType, 0) : null;, +			Class<?> mapValueType = resolveMapValueType();, +			return mapValueType != null ? nested(mapValueType, 1) : null;, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/TypeDescriptor.java, +	 * If this type is a {@link Collection} or an Array, creates a elementType descriptor from the provided collection or array element., +	 * Narrows the {@link #getElementType() elementType} property to the class of the provided collection or array element., +	 * For example, if this describes a java.util.List&lt;java.lang.Number&lt; and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.List&lt;?&gt; and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @return a element type descriptor, narrowed to the type of the provided element, +	 * @throws IllegalStateException if this type is not a java.util.Collection or Array type, +	 * @see #narrow(Object), +	 * If this type is a {@link Map}, creates a mapKeyType descriptor from the provided map key., +	 * Narrows the {@link #getMapKeyType() mapKeyType} property to the class of the provided map key., +	 * For example, if this describes a java.util.Map&lt;java.lang.Number, java.lang.String&lt; and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.Map&lt;?, ?&gt; and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @throws IllegalStateException if this type is not a java.util.Map., +	 * @see #narrow(Object), +	 * If this type is a {@link Map}, creates a mapValueType descriptor from the provided map value., +	 * Narrows the {@link #getMapValueType() mapValueType} property to the class of the provided map value., +	 * For example, if this describes a java.util.Map&lt;java.lang.String, java.lang.Number&lt; and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer., +	 * If this describes a java.util.Map&lt;?, ?&gt; and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well., +	 * Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned. , +	 * @throws IllegalStateException if this type is not a java.util.Map. , +			if (descriptor == null) {, +				return null;, +			}, +++ b/org.springframework.core/src/test/java/org/springframework/core/convert/TypeDescriptorTests.java, +	public void nestedTooManyLevels() throws Exception {, +		TypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod("test4", List.class), 0), 3);, +		assertEquals(String.class, t1.getType());, +	}, +, +	@Test(expected=IllegalStateException.class), +	public void nestedNotParameterized() throws Exception {, +		TypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod("test6", List.class), 0), 1);, +		assertEquals(List.class,t1.getType());, +		assertEquals("java.util.List<?>", t1.toString());, +		TypeDescriptor t2 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod("test6", List.class), 0), 2);, +		assertNull(t2);, +	}, +, +	public void test6(List<List> param1) {, +		, +	}, +, +	@Test, +++ b/org.springframework.core/src/main/java/org/springframework/core/convert/AbstractDescriptor.java, +		if (type == null) {, +			throw new IllegalArgumentException("type cannot be null");, +		}, +			Class<?> elementType = resolveCollectionElementType();, +			return elementType != null ? nested(elementType, 0) : null;]