[+++ b/spring-jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java, + * Abstract base class for Spring message listener container implementations., + * Can either host a standard JMS {@link javax.jms.MessageListener} or Spring's, + * {@link SessionAwareMessageListener} for actual message processing., + * <p>Usually holds a single JMS {@link Connection} that all listeners are supposed, + * to be registered on, which is the standard JMS way of managing listener sessions., + * Can alternatively also be used with a fresh Connection per listener, for Java EE, + * style XA-aware JMS messaging. The actual registration process is up to concrete, + * subclasses., + * <p><b>NOTE:</b> The default behavior of this message listener container is to, + * <b>never</b> propagate an exception thrown by a message listener up to the JMS, + * provider. Instead, it will log any such exception at the error level., + * no redelivery in case of an exception and no redelivery in case of other listener, + * execution interruptions either. For {@link SimpleMessageListenerContainer},, + * no redelivery in case of a user exception thrown but potential redelivery in case, + * of the JVM dying during listener execution. In order to consistently arrange for, + * redelivery with any container variant, consider "CLIENT_ACKNOWLEDGE" mode or -, + * preferably - setting "sessionTransacted" to "true" instead., + * <li>"sessionAcknowledgeMode" set to "DUPS_OK_ACKNOWLEDGE":, + * <i>Lazy</i> message acknowledgment during ({@link DefaultMessageListenerContainer}), + * or shortly after ({@link SimpleMessageListenerContainer}) listener execution;, + * no redelivery in case of a user exception thrown but potential redelivery in case, + * of the JVM dying during listener execution. In order to consistently arrange for, + * redelivery with any container variant, consider "CLIENT_ACKNOWLEDGE" mode or -, + * preferably - setting "sessionTransacted" to "true" instead., + * best-effort redelivery in case of a user exception thrown as well as in case, + * of other listener execution interruptions (such as the JVM dying)., + * <i>guaranteed redelivery</i> in case of a user exception thrown as well as, + * in case of other listener execution interruptions (such as the JVM dying)., + * <p>There are two solutions to the duplicate message processing problem:, + * set on the incoming message (otherwise just process straightforwardly)., + * Note that with "sessionTransacted" set to "true", duplicate messages will, + * only appear in case of the JVM dying at the most unfortunate point possible, + * (i.e. after your business logic executed but before the JMS part got committed),, + * so duplicate message detection is just there to cover a corner case., + * <li>Or wrap your <i>entire processing with an XA transaction</i>, covering the, + * reception of the JMS message as well as the execution of the business logic in, + * your message listener (including database operations etc). This is only, + * supported by {@link DefaultMessageListenerContainer}, through specifying, + * an external "transactionManager" (typically a, + * a corresponding XA-aware JMS {@link javax.jms.ConnectionFactory} passed in, + * as "connectionFactory")., + * running on a Java EE server, but also for other environments with a JTA, +		else {, +++ b/spring-jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java, + * Abstract base class for Spring message listener container implementations., + * Can either host a standard JMS {@link javax.jms.MessageListener} or Spring's, + * {@link SessionAwareMessageListener} for actual message processing., + * <p>Usually holds a single JMS {@link Connection} that all listeners are supposed, + * to be registered on, which is the standard JMS way of managing listener sessions., + * Can alternatively also be used with a fresh Connection per listener, for Java EE, + * style XA-aware JMS messaging. The actual registration process is up to concrete, + * subclasses., + * <p><b>NOTE:</b> The default behavior of this message listener container is to, + * <b>never</b> propagate an exception thrown by a message listener up to the JMS, + * provider. Instead, it will log any such exception at the error level., + * no redelivery in case of an exception and no redelivery in case of other listener, + * execution interruptions either. For {@link SimpleMessageListenerContainer},, + * no redelivery in case of a user exception thrown but potential redelivery in case, + * of the JVM dying during listener execution. In order to consistently arrange for, + * redelivery with any container variant, consider "CLIENT_ACKNOWLEDGE" mode or -, + * preferably - setting "sessionTransacted" to "true" instead., + * <li>"sessionAcknowledgeMode" set to "DUPS_OK_ACKNOWLEDGE":, + * <i>Lazy</i> message acknowledgment during ({@link DefaultMessageListenerContainer}), + * or shortly after ({@link SimpleMessageListenerContainer}) listener execution;, + * no redelivery in case of a user exception thrown but potential redelivery in case, + * of the JVM dying during listener execution. In order to consistently arrange for, + * redelivery with any container variant, consider "CLIENT_ACKNOWLEDGE" mode or -, + * preferably - setting "sessionTransacted" to "true" instead., + * best-effort redelivery in case of a user exception thrown as well as in case, + * of other listener execution interruptions (such as the JVM dying)., + * <i>guaranteed redelivery</i> in case of a user exception thrown as well as, + * in case of other listener execution interruptions (such as the JVM dying)., + * <p>There are two solutions to the duplicate message processing problem:, + * set on the incoming message (otherwise just process straightforwardly)., + * Note that with "sessionTransacted" set to "true", duplicate messages will, + * only appear in case of the JVM dying at the most unfortunate point possible, + * (i.e. after your business logic executed but before the JMS part got committed),, + * so duplicate message detection is just there to cover a corner case., + * <li>Or wrap your <i>entire processing with an XA transaction</i>, covering the, + * reception of the JMS message as well as the execution of the business logic in, + * your message listener (including database operations etc). This is only, + * supported by {@link DefaultMessageListenerContainer}, through specifying, + * an external "transactionManager" (typically a, + * a corresponding XA-aware JMS {@link javax.jms.ConnectionFactory} passed in, + * as "connectionFactory")., + * running on a Java EE server, but also for other environments with a JTA, +		else {, +++ b/spring-jms/src/main/java/org/springframework/jms/listener/SimpleMessageListenerContainer.java, + * with no redelivery in case of a user exception thrown but potential, + * redelivery in case of the JVM dying during listener execution., +++ b/spring-jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java, + * Abstract base class for Spring message listener container implementations., + * Can either host a standard JMS {@link javax.jms.MessageListener} or Spring's, + * {@link SessionAwareMessageListener} for actual message processing., + * <p>Usually holds a single JMS {@link Connection} that all listeners are supposed, + * to be registered on, which is the standard JMS way of managing listener sessions., + * Can alternatively also be used with a fresh Connection per listener, for Java EE, + * style XA-aware JMS messaging. The actual registration process is up to concrete, + * subclasses.]