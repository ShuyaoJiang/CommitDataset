[+++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/AbstractMessageConverter.java, +	private final List<MimeType> supportedMimeTypes;, +	private boolean strictContentTypeMatch = false;, +, +	private Class<?> serializedPayloadClass = byte[].class;, +, +	 * Construct an {@code AbstractMessageConverter} supporting a single MIME type., +		Assert.notNull(supportedMimeType, "supportedMimeType is required");, +	 * Construct an {@code AbstractMessageConverter} supporting multiple MIME types., +	 * Return the supported MIME types., +	 * Configure the {@link ContentTypeResolver} to use to resolve the content, +	 * type of an input message., +	 * <p>, +	 * By default, no {@code ContentTypeResolver} is configured. When a resolver, +	 * is not configured, then {@link #setStrictContentTypeMatch(boolean)} should, +	 * be left {@code false} (the default) or otherwise this converter will ignore, +	 * all input messages., +	 * Return the configured {@link ContentTypeResolver}., +	 * Whether this converter should convert messages for which no content type, +	 * could be resolved through the configured, +	 * {@link org.springframework.messaging.converter.ContentTypeResolver}., +	 * A converter can configured to be strict only when a, +	 * {@link #setContentTypeResolver(ContentTypeResolver) contentTypeResolver}, +	 * is  configured and the list of {@link #getSupportedMimeTypes() supportedMimeTypes}, +	 * is not be empty., +	 *, +	 * then requires the content type of a message to be resolved, +	 *, +	 * When set to true, #supportsMimeType(MessageHeaders) will return false if the, +	 * contentTypeResolver is not defined or if no content-type header is present., +	 */, +	public void setStrictContentTypeMatch(boolean strictContentTypeMatch) {, +		if (strictContentTypeMatch) {, +			Assert.notEmpty(getSupportedMimeTypes(),, +					"A strict converter requires a non-empty list of supported mime types");, +			Assert.notNull(getContentTypeResolver(),, +					"A strict converter requires a ContentTypeResolver");, +		}, +		this.strictContentTypeMatch = strictContentTypeMatch;, +	}, +, +	/**, +	 * Whether content type resolution must produce a value that matches one of, +	 * the supported MIME types., +	 */, +	public boolean isStrictContentTypeMatch() {, +		return this.strictContentTypeMatch;, +	}, +, +	/**, +, +		MimeType mimeType = getMimeType(headers);, +		if (mimeType == null) {, +			if (isStrictContentTypeMatch()) {, +				return false;, +			}, +			else {, +				return true;, +			}, +		}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/converter/AbstractMessageConverter.java, +	private final List<MimeType> supportedMimeTypes;, +	private boolean strictContentTypeMatch = false;, +, +	private Class<?> serializedPayloadClass = byte[].class;, +, +	 * Construct an {@code AbstractMessageConverter} supporting a single MIME type., +		Assert.notNull(supportedMimeType, "supportedMimeType is required");, +	 * Construct an {@code AbstractMessageConverter} supporting multiple MIME types., +	 * Return the supported MIME types., +	 * Configure the {@link ContentTypeResolver} to use to resolve the content, +	 * type of an input message., +	 * <p>, +	 * By default, no {@code ContentTypeResolver} is configured. When a resolver, +	 * is not configured, then {@link #setStrictContentTypeMatch(boolean)} should, +	 * be left {@code false} (the default) or otherwise this converter will ignore, +	 * all input messages., +	 * Return the configured {@link ContentTypeResolver}., +	 * Whether this converter should convert messages for which no content type, +	 * could be resolved through the configured, +	 * {@link org.springframework.messaging.converter.ContentTypeResolver}., +	 * A converter can configured to be strict only when a, +	 * {@link #setContentTypeResolver(ContentTypeResolver) contentTypeResolver}, +	 * is  configured and the list of {@link #getSupportedMimeTypes() supportedMimeTypes}, +	 * is not be empty., +	 *, +	 * then requires the content type of a message to be resolved, +	 *, +	 * When set to true, #supportsMimeType(MessageHeaders) will return false if the, +	 * contentTypeResolver is not defined or if no content-type header is present., +	 */, +	public void setStrictContentTypeMatch(boolean strictContentTypeMatch) {, +		if (strictContentTypeMatch) {, +			Assert.notEmpty(getSupportedMimeTypes(),, +					"A strict converter requires a non-empty list of supported mime types");, +			Assert.notNull(getContentTypeResolver(),, +					"A strict converter requires a ContentTypeResolver");, +		}, +		this.strictContentTypeMatch = strictContentTypeMatch;, +	}]