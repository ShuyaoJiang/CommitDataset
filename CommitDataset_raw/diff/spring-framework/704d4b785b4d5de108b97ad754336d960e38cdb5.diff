[+++ b/org.springframework.core/src/main/java/org/springframework/util/ClassUtils.java, + * framework; consider, + * <a href="http://commons.apache.org/lang/" target="_blank">Apache Commons Lang</a>, + * for a more comprehensive suite of class utilities., + * @author Sam Brannen, +@SuppressWarnings("unchecked"), +	private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new HashMap<Class<?>, Class<?>>(8);, +	private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new HashMap<Class<?>, Class<?>>(8);, +	private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(16);, +	private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);, +		for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {, +		Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(16);, +		for (Class<?> primitiveType : primitiveTypes) {, +	private static void registerCommonClasses(Class<?>... commonClasses) {, +		for (Class<?> clazz : commonClasses) {, +	public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {, +	public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {, +		Class<?> clazz = resolvePrimitiveClassName(name);, +			Class<?> elementClass = forName(elementClassName, classLoader);, +			Class<?> elementClass = forName(elementName, classLoader);, +			Class<?> elementClass = forName(elementName, classLoader);, +	public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {, +	public static Class<?> resolvePrimitiveClassName(String name) {, +		Class<?> result = null;, +	public static Class<?> getUserClass(Object instance) {, +	public static Class<?> getUserClass(Class<?> clazz) {, +	public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {, +	public static String getShortName(Class<?> clazz) {, +	 * Return the short string name of a Java class in uncapitalized JavaBeans, +	public static String getShortNameAsProperty(Class<?> clazz) {, +	public static String getClassFileName(Class<?> clazz) {, +	public static String getPackageName(Class<?> clazz) {, +	public static String getQualifiedName(Class<?> clazz) {, +	private static String getQualifiedNameForArray(Class<?> clazz) {, +		Class<?> clazz = value.getClass();, +			Class<?>[] ifcs = clazz.getInterfaces();, +	public static boolean matchesTypeName(Class<?> clazz, String typeName) {, +	public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {, +	public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {, +	public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {, +	public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {, +	public static int getMethodCountForName(Class<?> clazz, String methodName) {, +		Class<?>[] ifcs = clazz.getInterfaces();, +		for (Class<?> ifc : ifcs) {, +	 * Does the given class or one of its superclasses at least have one or more, +	 * methods with the supplied name (with any argument types)?, +	 * Includes non-public methods., +	public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {, +		Class<?>[] ifcs = clazz.getInterfaces();, +		for (Class<?> ifc : ifcs) {, +	public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {, +	public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {, +	public static boolean isPrimitiveWrapper(Class<?> clazz) {, +	public static boolean isPrimitiveOrWrapper(Class<?> clazz) {, +	public static boolean isPrimitiveArray(Class<?> clazz) {, +	public static boolean isPrimitiveWrapperArray(Class<?> clazz) {, +	public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {, +	public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {, +	public static boolean isAssignableValue(Class<?> type, Object value) {, +	 * slash ('/') to the return value). Built by taking the package of the specified, +	 * if necessary, and concatenating the specified resource name to this., +	public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {, +	 * could be concatenated with a slash and the name of a resource and fed, +	public static String classPackageAsResourcePath(Class<?> clazz) {, +	 * @param instance the instance to analyze for interfaces, +	 * @param clazz the class to analyze for interfaces, +	public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {, +	 * @param clazz the class to analyze for interfaces, +	public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {, +		List<Class<?>> interfaces = new ArrayList<Class<?>>();, +			Class<?>[] ifcs = clazz.getInterfaces();, +			for (Class<?> ifc : ifcs) {, +	 * @param instance the instance to analyze for interfaces, +	 * @param clazz the class to analyze for interfaces, +	 * @param clazz the class to analyze for interfaces, +				Class<?> ifc = clazz.getInterfaces()[i];, +	public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {, +	public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {, +			Class<?> actualClass = classLoader.loadClass(clazz.getName());]