[+++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, +	private final OverflowStrategy overflowStrategy;, +, +	 * Basic constructor., +		this(delegate, sendTimeLimit, bufferSizeLimit, OverflowStrategy.TERMINATE);, +	}, +, +	/**, +	 * Constructor that also specifies the overflow strategy to use., +	 * @param delegate the {@code WebSocketSession} to delegate to, +	 * @param sendTimeLimit the send-time limit (milliseconds), +	 * @param bufferSizeLimit the buffer-size limit (number of bytes), +	 * @param overflowStrategy the overflow strategy to use; by default the, +	 * session is terminated., +	 * @since 5.1, +	 */, +	public ConcurrentWebSocketSessionDecorator(, +			WebSocketSession delegate, int sendTimeLimit, int bufferSizeLimit, OverflowStrategy overflowStrategy) {, +, +		this.overflowStrategy = overflowStrategy;, +					this.bufferSize.addAndGet(-message.getPayloadLength());, +					String format = "Send time %d (ms) for session '%s' exceeded the allowed limit %d";, +					switch (this.overflowStrategy) {, +						case TERMINATE:, +							String format = "Buffer size %d bytes for session '%s' exceeds the allowed limit %d";, +							break;, +						case DROP:, +							int i = 0;, +							while (getBufferSize() > getBufferSizeLimit()) {, +								WebSocketMessage<?> message = this.buffer.poll();, +								if (message == null) {, +									break;, +								}, +								this.bufferSize.addAndGet(-message.getPayloadLength());, +								i++;, +							}, +							if (logger.isDebugEnabled()) {, +								logger.debug("Dropped " + i + " messages, buffer size: " + getBufferSize());, +							}, +							break;, +						default:, +							// Should never happen.., +							throw new IllegalStateException("Unexpected OverflowStrategy: " + this.overflowStrategy);, +					}, +, +	/**, +	 * Enum for options of what to do when the buffer fills up., +	 * @since 5.1, +	 */, +	public enum OverflowStrategy {, +, +		/**, +		 * Throw {@link SessionLimitExceededException} that would will result, +		 * in the session being terminated., +		 */, +		TERMINATE,, +, +		/**, +		 * Drop the oldest messages from the buffer., +		 */, +		DROP, +	}, +, +++ b/spring-websocket/src/main/java/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.java, +	private final OverflowStrategy overflowStrategy;, +, +	 * Basic constructor., +		this(delegate, sendTimeLimit, bufferSizeLimit, OverflowStrategy.TERMINATE);, +	}, +, +	/**, +	 * Constructor that also specifies the overflow strategy to use., +	 * @param delegate the {@code WebSocketSession} to delegate to, +	 * @param sendTimeLimit the send-time limit (milliseconds), +	 * @param bufferSizeLimit the buffer-size limit (number of bytes), +	 * @param overflowStrategy the overflow strategy to use; by default the, +	 * session is terminated., +	 * @since 5.1, +	 */, +	public ConcurrentWebSocketSessionDecorator(, +			WebSocketSession delegate, int sendTimeLimit, int bufferSizeLimit, OverflowStrategy overflowStrategy) {, +, +		this.overflowStrategy = overflowStrategy;, +					this.bufferSize.addAndGet(-message.getPayloadLength());, +					String format = "Send time %d (ms) for session '%s' exceeded the allowed limit %d";, +					switch (this.overflowStrategy) {, +						case TERMINATE:, +							String format = "Buffer size %d bytes for session '%s' exceeds the allowed limit %d";, +							break;, +						case DROP:, +							int i = 0;, +							while (getBufferSize() > getBufferSizeLimit()) {, +								WebSocketMessage<?> message = this.buffer.poll();, +								if (message == null) {, +									break;, +								}, +								this.bufferSize.addAndGet(-message.getPayloadLength());, +								i++;, +							}, +							if (logger.isDebugEnabled()) {]