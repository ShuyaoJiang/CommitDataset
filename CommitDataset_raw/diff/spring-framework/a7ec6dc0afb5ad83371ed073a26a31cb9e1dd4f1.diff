[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		@Override, +		public void removeImportingClass(String importingClass) {, +			for (List<AnnotationMetadata> list : this.imports.values()) {, +				for (Iterator<AnnotationMetadata> iterator = list.iterator(); iterator.hasNext();) {, +					if (iterator.next().getClassName().equals(importingClass)) {, +						iterator.remove();, +						break;, +					}, +				}, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		@Override, +		public void removeImportingClass(String importingClass) {, +			for (List<AnnotationMetadata> list : this.imports.values()) {, +				for (Iterator<AnnotationMetadata> iterator = list.iterator(); iterator.hasNext();) {, +					if (iterator.next().getClassName().equals(importingClass)) {, +						iterator.remove();, +						break;, +					}, +				}, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationCondition.java, + * Copyright 2002-2016 the original author or authors., +	enum ConfigurationPhase {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		@Override, +		public void removeImportingClass(String importingClass) {, +			for (List<AnnotationMetadata> list : this.imports.values()) {, +				for (Iterator<AnnotationMetadata> iterator = list.iterator(); iterator.hasNext();) {, +					if (iterator.next().getClassName().equals(importingClass)) {, +						iterator.remove();, +						break;, +					}, +				}, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationCondition.java, + * Copyright 2002-2016 the original author or authors., +	enum ConfigurationPhase {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ImportRegistry.java, + * Copyright 2002-2016 the original author or authors., +	void removeImportingClass(String importingClass);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		@Override, +		public void removeImportingClass(String importingClass) {, +			for (List<AnnotationMetadata> list : this.imports.values()) {, +				for (Iterator<AnnotationMetadata> iterator = list.iterator(); iterator.hasNext();) {, +					if (iterator.next().getClassName().equals(importingClass)) {, +						iterator.remove();, +						break;, +					}, +				}, +			}, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationCondition.java, + * Copyright 2002-2016 the original author or authors., +	enum ConfigurationPhase {, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ImportRegistry.java, + * Copyright 2002-2016 the original author or authors., +	void removeImportingClass(String importingClass);, +++ b/spring-tx/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementTests.java, +import org.springframework.context.annotation.ConditionContext;, +import org.springframework.context.annotation.Conditional;, +import org.springframework.context.annotation.ConfigurationCondition;, +import org.springframework.core.type.AnnotatedTypeMetadata;, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(, +				EnableTxConfig.class, TxManagerConfig.class);, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(, +				InheritedEnableTxConfig.class, TxManagerConfig.class);, +		TransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);, +		assertTrue("testBean is not a proxy", AopUtils.isAopProxy(bean));, +		Map<?,?> services = ctx.getBeansWithAnnotation(Service.class);, +		assertTrue("Stereotype annotation not visible", services.containsKey("testBean"));, +		ctx.close();, +	}, +, +	@Test, +	public void transactionProxyIsCreatedWithEnableOnExcludedSuperclass() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(, +				ParentEnableTxConfig.class, ChildEnableTxConfig.class, TxManagerConfig.class);, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(, +				EnableTxConfig.class, TxManagerConfig.class);, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(]