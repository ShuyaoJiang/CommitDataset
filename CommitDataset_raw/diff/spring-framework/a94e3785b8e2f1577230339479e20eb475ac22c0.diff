[+++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/AbstractJmsListeningContainer.java, + * Copyright 2002-2011 the original author or authors., +	 * Specify the JMS client ID for a shared Connection created and used, +	 * <p>Note that client IDs need to be unique among all active Connections, +	 * of the underlying JMS provider. Furthermore, a client ID can only be, +				for (Iterator<?> it = this.pausedTasks.iterator(); it.hasNext();) {, +	@SuppressWarnings("serial"), +++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/AbstractJmsListeningContainer.java, + * Copyright 2002-2011 the original author or authors., +	 * Specify the JMS client ID for a shared Connection created and used, +	 * <p>Note that client IDs need to be unique among all active Connections, +	 * of the underlying JMS provider. Furthermore, a client ID can only be, +				for (Iterator<?> it = this.pausedTasks.iterator(); it.hasNext();) {, +	@SuppressWarnings("serial"), +++ b/org.springframework.jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java, + * Copyright 2002-2011 the original author or authors., + * Message listener container variant that uses plain JMS client APIs, specifically, + * and optionally allows for dynamic adaptation at runtime (up to a maximum number)., + * not even the JMS {@code ServerSessionPool} facility is required. Beyond that, it is, + * fully self-recovering in case the broker is temporarily unavailable, and allows, + * for stops/restarts as well as runtime changes to its configuration., + * <p>Actual {@code MessageListener} execution happens in asynchronous work units which are, + * created through Spring's {@link org.springframework.core.task.TaskExecutor TaskExecutor}, + * setting. Specify an alternative {@code TaskExecutor} to integrate with an existing, + * cached JMS {@code Session} and {@code MessageConsumer} (only refreshed in case, + * of failure), using the JMS provider's resources as efficiently as possible., + * in transactions by passing a Spring, + * J2EE environment, in combination with a JTA-aware JMS {@code ConnectionFactory}, + * obtained from JNDI (check your J2EE server's documentation). Note that this, + * listener container will automatically reobtain all JMS handles for each transaction, + * in case an external transaction manager is specified, for compatibility with, + * {@link #setCacheLevelName "cacheLevelName"} property, enforcing caching of, + * the {@code Connection} (or also {@code Session} and {@code MessageConsumer}), + * even if an external transaction manager is involved., + * by specifying a {@link #setMaxConcurrentConsumers "maxConcurrentConsumers"}, + * and down, in particular if the {@code ConnectionFactory} does not pool JMS , + * {@code Sessions} and/or the {@code TaskExecutor} does not pool threads (check, + * your configuration!). Note that dynamic scaling only really makes sense for a, + * queue in the first place; for a topic, you will typically stick with the default, + * number of 1 consumer, else you'd receive the same message multiple times on, + * the same node., +	 * Constant that indicates to cache a shared JMS {@code Connection} for each, +	 * listener thread., +	 * Constant that indicates to cache a shared JMS {@code Connection} and a JMS, +	 * {@code Session} for each listener thread., +	 * Constant that indicates to cache a shared JMS {@code Connection}, a JMS, +	 * {@code Session}, and a JMS MessageConsumer for each listener thread., +	 * Constant that indicates automatic choice of an appropriate caching level, +	 * (depending on the transaction management strategy)., +	 * Set the Spring {@code TaskExecutor} to use for running the listener threads., +	 * <p>Specify an alternative {@code TaskExecutor} for integration with an existing, +	 * <p>Default is {@link #CACHE_NONE} if an external transaction manager has been specified, +	 * and {@link #CACHE_CONSUMER} otherwise (operating with local JMS resources)., +	 * transaction in case of a freshly obtained JMS {@code Connection} and {@code Session},, +	 * which is why this listener container by default does not cache any of those., +	 * this setting to at least {@link #CACHE_CONNECTION} or {@link #CACHE_SESSION} even in, +	 * <p>Currently known servers that absolutely require {@link #CACHE_NONE} for XA, +	 * transaction processing: JBoss 4. For any others, consider raising the cache level., +	 * <p>This number will always be between "concurrentConsumers" and, +	 * (in case some consumers are scheduled but not executing at the moment)., +	 * <p>This number will always be between "concurrentConsumers" and, +	 * "maxConcurrentConsumers", but might be lower than "scheduledConsumerCount", +	 * (in case some consumers are scheduled but not executing at the moment)., +	 * Return whether at least one consumer has entered a fixed registration with the, +	 * not to miss any messages that are just about to be published., +	 * <code>true</code> &ndash; provided that the listener container ever actually establishes, +	 * only {@link #CACHE_CONSUMER} will lead to a fixed registration., +				logger.info("JMS message listener invoker needs to establish shared Connection");, +	 * Called between recovery attempts.]