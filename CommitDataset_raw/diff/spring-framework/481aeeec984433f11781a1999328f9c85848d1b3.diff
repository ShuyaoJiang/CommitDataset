[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {, +	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {, +	 * <p>For example, it is common for a {@code @Configuration} class to declare direct, +	private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {, +	private void processImports(ConfigurationClass configClass, Collection<SourceClass> sourceClasses, boolean checkForCircularImports), +, +	public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {, +	public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {, +	public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {, +		for (String className : classNames) {, +	public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {, +			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className));, +		public SourceClass(Object source) {, +		public final AnnotationMetadata getMetadata() {, +			return this.metadata;, +		}, +			if (this.source instanceof Class<?>) {, +				return (Class<?>) this.source;, +			if (this.source instanceof Class) {, +				return clazz.isAssignableFrom((Class) this.source);, +			return new AssignableTypeFilter(clazz).match((MetadataReader) this.source, metadataReaderFactory);, +		public ConfigurationClass asConfigClass(ConfigurationClass importedBy) throws IOException {, +			return new ConfigurationClass((MetadataReader) this.source, importedBy);, +			if (this.source instanceof Class<?>) {, +				Class<?> sourceClass = (Class<?>) this.source;, +					catch (ClassNotFoundException ex) {, +						// ignore, +					catch (ClassNotFoundException ex) {, +						// ignore, +		public SourceClass getSuperClass() throws IOException, ClassNotFoundException {, +			if (this.source instanceof Class<?>) {, +				return asSourceClass(((Class<?>) this.source).getSuperclass());, +			return asSourceClass(((MetadataReader) this.source).getClassMetadata().getSuperClassName());, +		public Set<SourceClass> getAnnotations() throws IOException, ClassNotFoundException {, +			for (String annotation : this.metadata.getAnnotationTypes()) {, +		public Collection<SourceClass> getAnnotationAttributes(String annotationType, String attribute), +				throws IOException, ClassNotFoundException {, +, +			Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annotationType, true);, +			if (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {, +		private SourceClass getRelated(String className) throws IOException, ClassNotFoundException {, +			if (this.source instanceof Class<?>) {, +					// ignore, +		@Override, +		public boolean equals(Object other) {, +			return (this == other || (other instanceof SourceClass &&, +					this.metadata.getClassName().equals(((SourceClass) other).metadata.getClassName())));, +			return this.metadata.getClassName().hashCode();, +			return this.metadata.getClassName();, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {, +	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {, +	 * <p>For example, it is common for a {@code @Configuration} class to declare direct, +	private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited) throws IOException {, +	private void processImports(ConfigurationClass configClass, Collection<SourceClass> sourceClasses, boolean checkForCircularImports), +, +	public SourceClass asSourceClass(ConfigurationClass configurationClass) throws IOException {, +	public SourceClass asSourceClass(Class<?> classType) throws IOException, ClassNotFoundException {, +	public Collection<SourceClass> asSourceClasses(String[] classNames) throws IOException, ClassNotFoundException {, +		for (String className : classNames) {, +	public SourceClass asSourceClass(String className) throws IOException, ClassNotFoundException {, +			return new SourceClass(this.resourceLoader.getClassLoader().loadClass( className));, +		public SourceClass(Object source) {, +		public final AnnotationMetadata getMetadata() {, +			return this.metadata;, +		}, +			if (this.source instanceof Class<?>) {, +				return (Class<?>) this.source;, +			if (this.source instanceof Class) {, +				return clazz.isAssignableFrom((Class) this.source);, +			return new AssignableTypeFilter(clazz).match((MetadataReader) this.source, metadataReaderFactory);, +		public ConfigurationClass asConfigClass(ConfigurationClass importedBy) throws IOException {, +			return new ConfigurationClass((MetadataReader) this.source, importedBy);, +			if (this.source instanceof Class<?>) {, +				Class<?> sourceClass = (Class<?>) this.source;, +					catch (ClassNotFoundException ex) {, +						// ignore, +					catch (ClassNotFoundException ex) {, +						// ignore, +		public SourceClass getSuperClass() throws IOException, ClassNotFoundException {, +			if (this.source instanceof Class<?>) {, +				return asSourceClass(((Class<?>) this.source).getSuperclass());, +			return asSourceClass(((MetadataReader) this.source).getClassMetadata().getSuperClassName());, +		public Set<SourceClass> getAnnotations() throws IOException, ClassNotFoundException {, +			for (String annotation : this.metadata.getAnnotationTypes()) {, +		public Collection<SourceClass> getAnnotationAttributes(String annotationType, String attribute), +				throws IOException, ClassNotFoundException {, +, +			Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annotationType, true);, +			if (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {, +		private SourceClass getRelated(String className) throws IOException, ClassNotFoundException {, +			if (this.source instanceof Class<?>) {, +					// ignore, +		@Override, +		public boolean equals(Object other) {, +			return (this == other || (other instanceof SourceClass &&, +					this.metadata.getClassName().equals(((SourceClass) other).metadata.getClassName())));, +			return this.metadata.getClassName().hashCode();, +			return this.metadata.getClassName();]