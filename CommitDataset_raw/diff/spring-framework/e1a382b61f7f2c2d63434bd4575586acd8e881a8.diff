[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java, +import java.util.Optional;, + * A sub-class of {@link HandlerMethod} that can resolve method arguments from, + * a {@link ServerWebExchange} and use that to invoke the underlying method., +	private static final Mono<Object[]> EMPTY_ARGS = Mono.just(new Object[0]);, +	private static final Object NO_ARG_VALUE = new Object();, +	 * Configure the argument resolvers to use to use for resolving method, +	 * argument values against a {@code ServerWebExchange}., +	public void setParameterNameDiscoverer(ParameterNameDiscoverer nameDiscoverer) {, +		this.parameterNameDiscoverer = nameDiscoverer;, +	 * Invoke the method for the given exchange., +	 *, +	 * @param providedArgs optional list of argument values to match by type, +	 * @return Mono with a {@link HandlerResult}., +			return EMPTY_ARGS;, +			List<Mono<Object>> argMonos = Stream.of(getMethodParameters()), +						return findProvidedArg(param, providedArgs), +								.map(Mono::just), +								.orElseGet(() -> {, +									HandlerMethodArgumentResolver resolver = findResolver(param);, +									return resolveArg(resolver, param, bindingContext, exchange);, +								});, +, +			return Mono.when(argMonos, argValues ->, +					Stream.of(argValues).map(o -> o != NO_ARG_VALUE ? o : null).toArray());, +	private Optional<Object> findProvidedArg(MethodParameter param, Object... providedArgs) {, +		if (ObjectUtils.isEmpty(providedArgs)) {, +			return Optional.empty();, +		}, +		return Arrays.stream(providedArgs), +				.filter(arg -> param.getParameterType().isInstance(arg)), +				.findFirst();, +	}, +, +	private HandlerMethodArgumentResolver findResolver(MethodParameter param) {, +		return this.resolvers.stream(), +				.filter(r -> r.supportsParameter(param)), +				.findFirst(), +				.orElseThrow(() -> getArgumentError("No resolver for ", param, null));, +	}, +, +	private Mono<Object> resolveArg(HandlerMethodArgumentResolver resolver, MethodParameter param,, +			BindingContext bindingContext, ServerWebExchange exchange) {, +, +		try {, +			return resolver.resolveArgument(param, bindingContext, exchange), +					.defaultIfEmpty(NO_ARG_VALUE), +					.doOnError(cause -> {, +						if(logger.isDebugEnabled()) {, +							logger.debug(getDetailedErrorMessage("Error resolving ", param), cause);, +						}, +					});, +		}, +		catch (Exception ex) {, +			throw getArgumentError("Error resolving ", param, ex);, +		}, +	}, +, +	private IllegalStateException getArgumentError(String message, MethodParameter param, Throwable ex) {, +		return new IllegalStateException(getDetailedErrorMessage(message, param), ex);, +		return message + "argument [" + param.getParameterIndex() + "] " +, +				"of type [" + param.getParameterType().getName() + "] " +, +				"on method [" + getBridgedMethod().toGenericString() + "]";, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java, +import java.util.Optional;, + * A sub-class of {@link HandlerMethod} that can resolve method arguments from, + * a {@link ServerWebExchange} and use that to invoke the underlying method., +	private static final Mono<Object[]> EMPTY_ARGS = Mono.just(new Object[0]);, +	private static final Object NO_ARG_VALUE = new Object();, +	 * Configure the argument resolvers to use to use for resolving method, +	 * argument values against a {@code ServerWebExchange}., +	public void setParameterNameDiscoverer(ParameterNameDiscoverer nameDiscoverer) {, +		this.parameterNameDiscoverer = nameDiscoverer;, +	 * Invoke the method for the given exchange., +	 *, +	 * @param providedArgs optional list of argument values to match by type, +	 * @return Mono with a {@link HandlerResult}., +			return EMPTY_ARGS;, +			List<Mono<Object>> argMonos = Stream.of(getMethodParameters()), +						return findProvidedArg(param, providedArgs), +								.map(Mono::just), +								.orElseGet(() -> {, +									HandlerMethodArgumentResolver resolver = findResolver(param);, +									return resolveArg(resolver, param, bindingContext, exchange);, +								});, +, +			return Mono.when(argMonos, argValues ->, +					Stream.of(argValues).map(o -> o != NO_ARG_VALUE ? o : null).toArray());, +	private Optional<Object> findProvidedArg(MethodParameter param, Object... providedArgs) {, +		if (ObjectUtils.isEmpty(providedArgs)) {, +			return Optional.empty();, +		}, +		return Arrays.stream(providedArgs), +				.filter(arg -> param.getParameterType().isInstance(arg)), +				.findFirst();, +	}, +, +	private HandlerMethodArgumentResolver findResolver(MethodParameter param) {, +		return this.resolvers.stream(), +				.filter(r -> r.supportsParameter(param))]