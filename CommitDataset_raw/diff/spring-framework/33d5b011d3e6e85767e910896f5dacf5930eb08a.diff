[+++ b/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, +	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the, +	 * supplied list of {@link ContextConfigurationAttributes} and then, +	 * instantiate and return that {@code ContextLoader}., +	 * {@code null} or <em>empty</em>, depending on the absence or presence, +	 * of @{@link WebAppConfiguration} either {@value #DEFAULT_CONTEXT_LOADER_CLASS_NAME}, +	 * or {@value #DEFAULT_WEB_CONTEXT_LOADER_CLASS_NAME} will be used as the, +	 * default context loader class name. For details on the class resolution, +	 * process, see {@link #resolveContextLoaderClass()}., +	 * should be resolved; must not be {@code null}, +	 * @param configAttributesList the list of configuration attributes to process;, +	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>, +	 * (i.e., as if we were traversing up the class hierarchy), +	 * {@code ContextLoader} class to use; may be {@code null} or <em>empty</em>, +	 * <code>testClass</code> (never {@code null}), +	static ContextLoader resolveContextLoader(Class<?> testClass,, +			List<ContextConfigurationAttributes> configAttributesList, String defaultContextLoaderClassName) {, +		Assert.notNull(testClass, "Class must not be null");, +		Assert.notEmpty(configAttributesList, "ContextConfigurationAttributes list must not be empty");, +		Class<? extends ContextLoader> contextLoaderClass = resolveContextLoaderClass(testClass, configAttributesList,, +	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the, +	 * supplied list of {@link ContextConfigurationAttributes}., +	 * , +	 * <p>Beginning with the first level in the context configuration attributes, +	 * hierarchy: , +	 * <li>If the {@link ContextConfigurationAttributes#getContextLoaderClass(), +	 * contextLoaderClass} property of {@link ContextConfigurationAttributes} is, +	 * configured with an explicit class, that class will be returned.</li>, +	 * <li>If an explicit {@code ContextLoader} class is not specified at the , +	 * current level in the hierarchy, traverse to the next level in the hierarchy, +	 * and return to step #1.</li>, +	 * <li>If no explicit {@code ContextLoader} class is found after traversing, +	 * the hierarchy, an attempt will be made to load and return the class, +	 * class; must not be {@code null}; only used for logging purposes, +	 * @param configAttributesList the list of configuration attributes to process;, +	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>, +	 * (i.e., as if we were traversing up the class hierarchy), +	 * {@code ContextLoader} class to use; must not be {@code null} or empty, +			List<ContextConfigurationAttributes> configAttributesList, String defaultContextLoaderClassName) {, +		Assert.notEmpty(configAttributesList, "ContextConfigurationAttributes list must not be empty");, +		for (ContextConfigurationAttributes configAttributes : configAttributesList) {, +				logger.trace(String.format("Processing ContextLoader for context configuration attributes %s",, +					configAttributes));, +			Class<? extends ContextLoader> contextLoaderClass = configAttributes.getContextLoaderClass();, +						"Found explicit ContextLoader class [%s] for context configuration attributes %s",, +						contextLoaderClass.getName(), configAttributes));, +					defaultContextLoaderClassName, testClass.getName()));, +		}, +		catch (ClassNotFoundException ex) {, +	 * @param testClass the class for which to resolve the configuration attributes (must, +	 * not be {@code null}), +	 * @return the list of configuration attributes for the specified class, ordered <em>bottom-up</em>, +	 * (i.e., as if we were traversing up the class hierarchy); never {@code null}, +	 * @throws IllegalArgumentException if the supplied class is {@code null} or, +	static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {, +		Assert.notNull(testClass, "Class must not be null");, +		Class<?> declaringClass = findAnnotationDeclaringClass(annotationType, testClass);, +			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",, +			annotationType.getName(), testClass.getName()));, +					contextConfiguration, declaringClass.getName()));, +			attributesList.add(attributes);, +	 * @param configAttributesList the list of configuration attributes to process;, +	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>, +	 * (i.e., as if we were traversing up the class hierarchy), +	 * @return the set of merged context initializer classes, including those, +	 * from superclasses if appropriate (never {@code null}), +		Assert.notEmpty(configAttributesList, "ContextConfigurationAttributes list must not be empty");, +		for (ContextConfigurationAttributes configAttributes : configAttributesList) {, +	 * @param testClass the class for which to resolve the active profiles (must, +	 * not be {@code null}), +	 * active profiles from superclasses if appropriate (never {@code null}), +	static String[] resolveActiveProfiles(Class<?> testClass) {, +		Assert.notNull(testClass, "Class must not be null");, +		Class<?> declaringClass = findAnnotationDeclaringClass(annotationType, testClass);, +				annotationType.getName(), testClass.getName()));, +					declaringClass.getName()));, +						+ "definition profiles is permitted per @ActiveProfiles annotation.", declaringClass.getName(),, +			}, +			else if (!ObjectUtils.isEmpty(valueProfiles)) {, +	 * should be built (must not be {@code null}), +	 * {@code ContextLoader} class to use (may be {@code null}), +		final ContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList,, +			defaultContextLoaderClassName);, +		for (ContextConfigurationAttributes configAttributes : configAttributesList) {, +			}, +			else {, +++ b/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java, +	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the, +	 * supplied list of {@link ContextConfigurationAttributes} and then, +	 * instantiate and return that {@code ContextLoader}., +	 * {@code null} or <em>empty</em>, depending on the absence or presence, +	 * of @{@link WebAppConfiguration} either {@value #DEFAULT_CONTEXT_LOADER_CLASS_NAME}, +	 * or {@value #DEFAULT_WEB_CONTEXT_LOADER_CLASS_NAME} will be used as the, +	 * default context loader class name. For details on the class resolution, +	 * process, see {@link #resolveContextLoaderClass()}., +	 * should be resolved; must not be {@code null}, +	 * @param configAttributesList the list of configuration attributes to process;, +	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>, +	 * (i.e., as if we were traversing up the class hierarchy), +	 * {@code ContextLoader} class to use; may be {@code null} or <em>empty</em>]