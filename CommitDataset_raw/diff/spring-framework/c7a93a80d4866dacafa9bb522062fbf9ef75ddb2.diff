[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +		Assert.hasText(beanName, "Bean name must not be null");, +	/**, +	 * Create a new {@link ConfigurationClass} with the given name., +	 * @param metadata the metadata for the underlying class to represent, +	 * @param beanName name of the {@code @Configuration} class bean, +	 * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass), +	 */, +	public ConfigurationClass(AnnotationMetadata metadata, String beanName) {, +		Assert.hasText(beanName, "Bean name must not be null");, +		this.metadata = metadata;, +		this.resource = new DescriptiveResource(metadata.getClassName());, +		this.beanName = beanName;, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +		Assert.hasText(beanName, "Bean name must not be null");, +	/**, +	 * Create a new {@link ConfigurationClass} with the given name., +	 * @param metadata the metadata for the underlying class to represent, +	 * @param beanName name of the {@code @Configuration} class bean, +	 * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass), +	 */, +	public ConfigurationClass(AnnotationMetadata metadata, String beanName) {, +		Assert.hasText(beanName, "Bean name must not be null");, +		this.metadata = metadata;, +		this.resource = new DescriptiveResource(metadata.getClassName());, +		this.beanName = beanName;, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;, +				if (bd instanceof AnnotatedBeanDefinition) {, +					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());, +				}, +				else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {, +				throw new BeanDefinitionStoreException(, +						"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);, +	protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {, +		processConfigurationClass(new ConfigurationClass(metadata, beanName));, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +		Assert.hasText(beanName, "Bean name must not be null");, +	/**, +	 * Create a new {@link ConfigurationClass} with the given name., +	 * @param metadata the metadata for the underlying class to represent, +	 * @param beanName name of the {@code @Configuration} class bean, +	 * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass), +	 */, +	public ConfigurationClass(AnnotationMetadata metadata, String beanName) {, +		Assert.hasText(beanName, "Bean name must not be null");, +		this.metadata = metadata;, +		this.resource = new DescriptiveResource(metadata.getClassName());, +		this.beanName = beanName;, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;, +				if (bd instanceof AnnotatedBeanDefinition) {, +					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());, +				}, +				else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {, +				throw new BeanDefinitionStoreException(, +						"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);, +	protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {, +		processConfigurationClass(new ConfigurationClass(metadata, beanName));, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java, +import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;, +		String className = beanDef.getBeanClassName();, +		if (className == null) {, +			return false;, +		}, +		AnnotationMetadata metadata;, +		if (beanDef instanceof AnnotatedBeanDefinition &&, +				className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {, +			// Can reuse the pre-parsed metadata from the given BeanDefinition..., +			metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();, +		}, +		else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {, +					logger.debug("Could not find class file for introspecting configuration annotations: " + className, ex);, +		else {, +	}]