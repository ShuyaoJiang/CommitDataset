[+++ b/org.springframework.core/src/test/java/org/springframework/core/BridgeMethodResolverTests.java, +/*, + * Copyright 2002-2008 the original author or authors., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.springframework.core;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNotSame;, +import static org.junit.Assert.assertTrue;, +, +import java.io.Serializable;, +import java.lang.reflect.Method;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.lang.reflect.TypeVariable;, +import java.util.Collection;, +import java.util.Date;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.List;, +import java.util.ListIterator;, +import java.util.Map;, +import java.util.concurrent.DelayQueue;, +import java.util.concurrent.Delayed;, +, +import org.junit.Ignore;, +import org.junit.Test;, +, +/**, + * @author Rob Harrop, + * @author Juergen Hoeller, + * @author Chris Beams, + */, +public class BridgeMethodResolverTests {, +, +	private static TypeVariable<?> findTypeVariable(Class<?> clazz, String name) {, +		TypeVariable<?>[] variables = clazz.getTypeParameters();, +		for (int i = 0; i < variables.length; i++) {, +			TypeVariable<?> variable = variables[i];, +			if (variable.getName().equals(name)) {, +				return variable;, +			}, +		}, +		return null;, +	}, +, +	private static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {, +		Method[] methods = targetType.getMethods();, +		for (Method m : methods) {, +			if (m.getName().equals(name) && m.getReturnType().equals(returnType)) {, +				return m;, +			}, +		}, +		return null;, +	}, +, +, +	@Test, +	public void testFindBridgedMethod() throws Exception {, +		Method unbridged = MyFoo.class.getDeclaredMethod("someMethod", String.class, Object.class);, +		Method bridged = MyFoo.class.getDeclaredMethod("someMethod", Serializable.class, Object.class);, +		assertFalse(unbridged.isBridge());, +		assertTrue(bridged.isBridge());, +, +		assertEquals("Unbridged method not returned directly", unbridged, BridgeMethodResolver.findBridgedMethod(unbridged));, +		assertEquals("Incorrect bridged method returned", unbridged, BridgeMethodResolver.findBridgedMethod(bridged));, +	}, +, +	@Test, +	public void testFindBridgedVarargMethod() throws Exception {, +		Method unbridged = MyFoo.class.getDeclaredMethod("someVarargMethod", String.class, Object[].class);, +		Method bridged = MyFoo.class.getDeclaredMethod("someVarargMethod", Serializable.class, Object[].class);, +		assertFalse(unbridged.isBridge());, +		assertTrue(bridged.isBridge());, +, +		assertEquals("Unbridged method not returned directly", unbridged, BridgeMethodResolver.findBridgedMethod(unbridged));, +		assertEquals("Incorrect bridged method returned", unbridged, BridgeMethodResolver.findBridgedMethod(bridged));, +	}, +, +	@Ignore, +	@Test, +	public void testFindBridgedMethodInHierarchy() throws Exception {, +		Method unbridged = DateAdder.class.getMethod("add", Date.class);, +		Method bridged = DateAdder.class.getMethod("add", Object.class);, +		assertFalse(unbridged.isBridge());]