[+++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapter.java, +, + * <p>An adapter supports a specific adaptee type whose stream semantics, + * can be checked via {@link #getDescriptor()}., +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapter.java, +, + * <p>An adapter supports a specific adaptee type whose stream semantics, + * can be checked via {@link #getDescriptor()}., +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java, +, +	private final Map<Class<?>, ReactiveAdapter> adapterMap = new LinkedHashMap<>(4);, +				source -> (Mono<?>) source, source -> source,, +				new ReactiveAdapter.Descriptor(false, true, false));, +				source -> Mono.fromFuture((CompletableFuture<?>) source), Mono::toFuture,, +				new ReactiveAdapter.Descriptor(false, true, false), +	public void registerMonoAdapter(Class<?> adapteeType, Function<Object, Mono<?>> toAdapter,, +			Function<Mono<?>, Object> fromAdapter, ReactiveAdapter.Descriptor descriptor) {, +	public void registerFluxAdapter(Class<?> adapteeType, Function<Object, Flux<?>> toAdapter,, +			Function<Flux<?>, Object> fromAdapter) {, +	private ReactiveAdapter getAdapterInternal(Predicate<Class<?>> adapteeTypePredicate) {, +		return this.adapterMap.keySet().stream(), +				.filter(adapteeTypePredicate), +				.map(this.adapterMap::get), +				.findFirst(), +				.orElse(null);, +	}, +, +		return (value instanceof Optional ? ((Optional<?>) value).orElse(null) : value);, +, +					new ReactiveAdapter.Descriptor(false, false, false), +					new ReactiveAdapter.Descriptor(false, true, true), +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapter.java, +, + * <p>An adapter supports a specific adaptee type whose stream semantics, + * can be checked via {@link #getDescriptor()}., +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java, +, +	private final Map<Class<?>, ReactiveAdapter> adapterMap = new LinkedHashMap<>(4);, +				source -> (Mono<?>) source, source -> source,, +				new ReactiveAdapter.Descriptor(false, true, false));, +				source -> Mono.fromFuture((CompletableFuture<?>) source), Mono::toFuture,, +				new ReactiveAdapter.Descriptor(false, true, false), +	public void registerMonoAdapter(Class<?> adapteeType, Function<Object, Mono<?>> toAdapter,, +			Function<Mono<?>, Object> fromAdapter, ReactiveAdapter.Descriptor descriptor) {, +	public void registerFluxAdapter(Class<?> adapteeType, Function<Object, Flux<?>> toAdapter,, +			Function<Flux<?>, Object> fromAdapter) {, +	private ReactiveAdapter getAdapterInternal(Predicate<Class<?>> adapteeTypePredicate) {, +		return this.adapterMap.keySet().stream(), +				.filter(adapteeTypePredicate), +				.map(this.adapterMap::get), +				.findFirst(), +				.orElse(null);, +	}, +, +		return (value instanceof Optional ? ((Optional<?>) value).orElse(null) : value);, +, +					new ReactiveAdapter.Descriptor(false, false, false), +					new ReactiveAdapter.Descriptor(false, true, true), +++ b/spring-web/src/test/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBeanTests.java, +import static org.junit.Assert.*;, + *, +	@Test(expected = HttpMediaTypeNotAcceptableException.class)  // SPR-10170, +	@Test(expected = HttpMediaTypeNotAcceptableException.class)  // SPR-10170, +	@Test  // SPR-12286, +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapter.java, +, + * <p>An adapter supports a specific adaptee type whose stream semantics, + * can be checked via {@link #getDescriptor()}., +++ b/spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java, +, +	private final Map<Class<?>, ReactiveAdapter> adapterMap = new LinkedHashMap<>(4);, +				source -> (Mono<?>) source, source -> source,, +				new ReactiveAdapter.Descriptor(false, true, false));, +				source -> Mono.fromFuture((CompletableFuture<?>) source), Mono::toFuture,, +				new ReactiveAdapter.Descriptor(false, true, false), +	public void registerMonoAdapter(Class<?> adapteeType, Function<Object, Mono<?>> toAdapter,, +			Function<Mono<?>, Object> fromAdapter, ReactiveAdapter.Descriptor descriptor) {, +	public void registerFluxAdapter(Class<?> adapteeType, Function<Object, Flux<?>> toAdapter,, +			Function<Flux<?>, Object> fromAdapter) {, +	private ReactiveAdapter getAdapterInternal(Predicate<Class<?>> adapteeTypePredicate) {, +		return this.adapterMap.keySet().stream(), +				.filter(adapteeTypePredicate), +				.map(this.adapterMap::get), +				.findFirst(), +				.orElse(null);, +	}, +, +		return (value instanceof Optional ? ((Optional<?>) value).orElse(null) : value);, +, +					new ReactiveAdapter.Descriptor(false, false, false), +					new ReactiveAdapter.Descriptor(false, true, true), +++ b/spring-web/src/test/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBeanTests.java, +import static org.junit.Assert.*;, + *, +	@Test(expected = HttpMediaTypeNotAcceptableException.class)  // SPR-10170, +	@Test(expected = HttpMediaTypeNotAcceptableException.class)  // SPR-10170, +	@Test  // SPR-12286, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java, +			throw new IllegalStateException("Failed to retrieve internal handler method for HTTP OPTIONS", ex);, +				this.methodsMatch = (info.getMethodsCondition().getMatchingCondition(request) != null);]