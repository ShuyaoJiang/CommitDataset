[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +import java.lang.reflect.Member;, +	 * @param member the method or constructor for which arguments are being setup, +	public static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {, +		String[] paramDescriptors = null;, +		boolean isVarargs = false;, +		if (member instanceof Constructor) {, +			Constructor<?> ctor = (Constructor<?>)member;, +			paramDescriptors = toDescriptors(ctor.getParameterTypes());, +			isVarargs = ctor.isVarArgs();, +		}, +		else { // Method, +			Method method = (Method)member;, +			paramDescriptors = toDescriptors(method.getParameterTypes());, +			isVarargs = method.isVarArgs();, +		}, +		if (isVarargs) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +import java.lang.reflect.Member;, +	 * @param member the method or constructor for which arguments are being setup, +	public static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {, +		String[] paramDescriptors = null;, +		boolean isVarargs = false;, +		if (member instanceof Constructor) {, +			Constructor<?> ctor = (Constructor<?>)member;, +			paramDescriptors = toDescriptors(ctor.getParameterTypes());, +			isVarargs = ctor.isVarArgs();, +		}, +		else { // Method, +			Method method = (Method)member;, +			paramDescriptors = toDescriptors(method.getParameterTypes());, +			isVarargs = method.isVarArgs();, +		}, +		if (isVarargs) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, +		return (Modifier.isPublic(constructor.getModifiers()) &&, +		// children[0] is the type of the constructor, don't want to include that in argument processing, +		SpelNodeImpl[] arguments = new SpelNodeImpl[children.length-1];, +		System.arraycopy(children, 1, arguments, 0, children.length-1);, +		CodeFlow.generateCodeForArguments(mv, cf, constructor, arguments);	, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +import java.lang.reflect.Member;, +	 * @param member the method or constructor for which arguments are being setup, +	public static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {, +		String[] paramDescriptors = null;, +		boolean isVarargs = false;, +		if (member instanceof Constructor) {, +			Constructor<?> ctor = (Constructor<?>)member;, +			paramDescriptors = toDescriptors(ctor.getParameterTypes());, +			isVarargs = ctor.isVarArgs();, +		}, +		else { // Method, +			Method method = (Method)member;, +			paramDescriptors = toDescriptors(method.getParameterTypes());, +			isVarargs = method.isVarArgs();, +		}, +		if (isVarargs) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, +		return (Modifier.isPublic(constructor.getModifiers()) &&, +		// children[0] is the type of the constructor, don't want to include that in argument processing, +		SpelNodeImpl[] arguments = new SpelNodeImpl[children.length-1];, +		System.arraycopy(children, 1, arguments, 0, children.length-1);, +		CodeFlow.generateCodeForArguments(mv, cf, constructor, arguments);	, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		, +		if (CodeFlow.isPrimitive(descriptor)) {, +			CodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java, +import java.lang.reflect.Member;, +	 * @param member the method or constructor for which arguments are being setup, +	public static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {, +		String[] paramDescriptors = null;, +		boolean isVarargs = false;, +		if (member instanceof Constructor) {, +			Constructor<?> ctor = (Constructor<?>)member;, +			paramDescriptors = toDescriptors(ctor.getParameterTypes());, +			isVarargs = ctor.isVarArgs();, +		}, +		else { // Method, +			Method method = (Method)member;, +			paramDescriptors = toDescriptors(method.getParameterTypes());, +			isVarargs = method.isVarArgs();, +		}, +		if (isVarargs) {, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java, +		return (Modifier.isPublic(constructor.getModifiers()) &&, +		// children[0] is the type of the constructor, don't want to include that in argument processing, +		SpelNodeImpl[] arguments = new SpelNodeImpl[children.length-1];, +		System.arraycopy(children, 1, arguments, 0, children.length-1);, +		CodeFlow.generateCodeForArguments(mv, cf, constructor, arguments);	, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java, +		, +		if (CodeFlow.isPrimitive(descriptor)) {, +			CodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/SpelExpression.java, +				TypedValue contextRoot = context == null ? null : context.getRootObject();, +				Object result = this.compiledAst.getValue(contextRoot==null?null:contextRoot.getValue(),context);, +				TypedValue contextRoot = context == null ? null : context.getRootObject();]