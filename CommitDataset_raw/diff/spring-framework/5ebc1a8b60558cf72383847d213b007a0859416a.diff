[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/Reactor2TcpStompClient.java, +import reactor.io.net.NetStreams;, + * {@link Reactor2TcpClient}., +			implements NetStreams.TcpClientFactory<Message<byte[]>, Message<byte[]>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/Reactor2TcpStompClient.java, +import reactor.io.net.NetStreams;, + * {@link Reactor2TcpClient}., +			implements NetStreams.TcpClientFactory<Message<byte[]>, Message<byte[]>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/TcpOperations.java, +	ListenableFuture<Void> shutdown();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/Reactor2TcpStompClient.java, +import reactor.io.net.NetStreams;, + * {@link Reactor2TcpClient}., +			implements NetStreams.TcpClientFactory<Message<byte[]>, Message<byte[]>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/TcpOperations.java, +	ListenableFuture<Void> shutdown();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/Reactor2TcpClient.java, +import org.reactivestreams.Publisher;, +import reactor.io.net.*;, +import reactor.rx.Promises;, + * <p>, +	private final NetStreams.TcpClientFactory<Message<P>, Message<P>> tcpClientSpecFactory;, +	 *, +		this.tcpClientSpecFactory = new NetStreams.TcpClientFactory<Message<P>, Message<P>>() {, +		} catch (Exception i) {, +	public Reactor2TcpClient(NetStreams.TcpClientFactory<Message<P>, Message<P>> tcpClientSpecFactory) {, +, +, +		Promise<Void> promise = tcpClient.start(composeConnectionHandling(tcpClient, connectionHandler));, +, +		return new PassThroughPromiseToListenableFutureAdapter<Void>(, +				promise.onError(new Consumer<Throwable>() {, +					@Override, +					public void accept(Throwable throwable) {, +						connectionHandler.afterConnectFailure(throwable);, +					}, +				}), +		);, +, +, +		Stream<Tuple2<InetSocketAddress, Integer>> stream = tcpClient.start(, +				composeConnectionHandling(tcpClient, handler),, +				new ReactorRectonnectAdapter(strategy), +		);, +, +		return new PassThroughPromiseToListenableFutureAdapter<Void>(stream.next().after());, +	private MessageHandler<P> composeConnectionHandling(, +			final TcpClient<Message<P>, Message<P>> tcpClient,, +			final TcpConnectionHandler<P> connectionHandler, +	) {, +		return new MessageHandler<P>() {, +			public Publisher<Void> apply(ChannelStream<Message<P>, Message<P>> connection) {, +				Promise<Void> closePromise = Promises.prepare();, +, +				connectionHandler.afterConnected(new Reactor2TcpConnection<P>(connection, closePromise));, +, +								} else if (signal.isOnComplete()) {, +, +				return closePromise;, +		};, +	public ListenableFuture<Void> shutdown() {, +		Promise<Void> promise = Streams.from(clients), +				.flatMap(new Function<TcpClient<Message<P>, Message<P>>, Promise<Void>>() {, +					public Promise<Void> apply(final TcpClient<Message<P>, Message<P>> client) {, +						return client.shutdown().onComplete(new Consumer<Promise<Void>>() {, +							@Override, +							public void accept(Promise<Void> voidPromise) {, +								synchronized (tcpClients) {, +									tcpClients.remove(client);, +							}, +						});, +		return new PassThroughPromiseToListenableFutureAdapter<Void>(promise);, +, +	private interface MessageHandler<P>, +			extends ReactorChannelHandler<Message<P>, Message<P>, ChannelStream<Message<P>, Message<P>>>{, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/Reactor2TcpStompClient.java, +import reactor.io.net.NetStreams;, + * {@link Reactor2TcpClient}., +			implements NetStreams.TcpClientFactory<Message<byte[]>, Message<byte[]>> {, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/TcpOperations.java, +	ListenableFuture<Void> shutdown();, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/Reactor2TcpClient.java, +import org.reactivestreams.Publisher;, +import reactor.io.net.*;, +import reactor.rx.Promises;, + * <p>, +	private final NetStreams.TcpClientFactory<Message<P>, Message<P>> tcpClientSpecFactory;, +	 *, +		this.tcpClientSpecFactory = new NetStreams.TcpClientFactory<Message<P>, Message<P>>() {, +		} catch (Exception i) {, +	public Reactor2TcpClient(NetStreams.TcpClientFactory<Message<P>, Message<P>> tcpClientSpecFactory) {, +, +, +		Promise<Void> promise = tcpClient.start(composeConnectionHandling(tcpClient, connectionHandler));, +, +		return new PassThroughPromiseToListenableFutureAdapter<Void>(, +				promise.onError(new Consumer<Throwable>() {, +					@Override, +					public void accept(Throwable throwable) {, +						connectionHandler.afterConnectFailure(throwable);]