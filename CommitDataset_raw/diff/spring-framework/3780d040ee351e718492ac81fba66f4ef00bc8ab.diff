[+++ b/spring-web/src/test/java/org/springframework/web/method/ResolvableMethod.java, +		public Builder<T> named(String methodName) {, +		public final Builder<T> annot(Predicate<Method>... filters) {, +		public final Builder<T> annotPresent(Class<? extends Annotation>... annotationTypes) {, +		public final Builder<T> annotNotPresent(Class<? extends Annotation>... annotationTypes) {, +		public Builder<T> returning(Class<?> returnType, Class<?>... generics) {, +		public Builder<T> returning(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {, +		public Builder<T> returning(ResolvableType returnType) {, +++ b/spring-web/src/test/java/org/springframework/web/method/ResolvableMethod.java, +		public Builder<T> named(String methodName) {, +		public final Builder<T> annot(Predicate<Method>... filters) {, +		public final Builder<T> annotPresent(Class<? extends Annotation>... annotationTypes) {, +		public final Builder<T> annotNotPresent(Class<? extends Annotation>... annotationTypes) {, +		public Builder<T> returning(Class<?> returnType, Class<?>... generics) {, +		public Builder<T> returning(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {, +		public Builder<T> returning(ResolvableType returnType) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.java, +		return (CharSequence.class.isAssignableFrom(type) || Rendering.class.isAssignableFrom(type) ||, +				void.class.equals(type) || View.class.isAssignableFrom(type) ||, +				!BeanUtils.isSimpleProperty(type));, +					else if (Model.class.isAssignableFrom(clazz)) {, +						model.addAllAttributes(((Model) returnValue).asMap());, +						viewsMono = resolveViews(getDefaultViewName(exchange), locale);, +					}, +					else if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {, +						model.addAllAttributes((Map<String, ?>) returnValue);, +						viewsMono = resolveViews(getDefaultViewName(exchange), locale);, +					}, +					else if (View.class.isAssignableFrom(clazz)) {, +						viewsMono = Mono.just(Collections.singletonList((View) returnValue));, +					}, +++ b/spring-web/src/test/java/org/springframework/web/method/ResolvableMethod.java, +		public Builder<T> named(String methodName) {, +		public final Builder<T> annot(Predicate<Method>... filters) {, +		public final Builder<T> annotPresent(Class<? extends Annotation>... annotationTypes) {, +		public final Builder<T> annotNotPresent(Class<? extends Annotation>... annotationTypes) {, +		public Builder<T> returning(Class<?> returnType, Class<?>... generics) {, +		public Builder<T> returning(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {, +		public Builder<T> returning(ResolvableType returnType) {, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.java, +		return (CharSequence.class.isAssignableFrom(type) || Rendering.class.isAssignableFrom(type) ||, +				void.class.equals(type) || View.class.isAssignableFrom(type) ||, +				!BeanUtils.isSimpleProperty(type));, +					else if (Model.class.isAssignableFrom(clazz)) {, +						model.addAllAttributes(((Model) returnValue).asMap());, +						viewsMono = resolveViews(getDefaultViewName(exchange), locale);, +					}, +					else if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {, +						model.addAllAttributes((Map<String, ?>) returnValue);, +						viewsMono = resolveViews(getDefaultViewName(exchange), locale);, +					}, +					else if (View.class.isAssignableFrom(clazz)) {, +						viewsMono = Mono.just(Collections.singletonList((View) returnValue));, +					}, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/ViewResolutionResultHandlerTests.java, +import org.springframework.core.ResolvableType;, +		testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class));, +		testSupports(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class));, +		testSupports(on(Handler.class).resolveReturnType(Mono.class, String.class));, +		testSupports(on(Handler.class).resolveReturnType(Rendering.class));, +		testSupports(on(Handler.class).resolveReturnType(Mono.class, Rendering.class));, +, +		testSupports(on(Handler.class).resolveReturnType(View.class));, +		testSupports(on(Handler.class).resolveReturnType(Mono.class, View.class));, +, +		testSupports(on(Handler.class).resolveReturnType(void.class));, +		testSupports(on(Handler.class).resolveReturnType(Mono.class, Void.class));, +		testSupports(on(Handler.class).resolveReturnType(Completable.class));, +, +		testSupports(on(Handler.class).resolveReturnType(Model.class));, +, +		testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Map.class));, +		testSupports(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Map.class));, +, +		testSupports(on(Handler.class).resolveReturnType(TestBean.class));, +, +		testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Long.class));, +		testDoesNotSupport(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Long.class));, +		testSupports(returnType, true);, +	private void testDoesNotSupport(MethodParameter returnType) {, +		testSupports(returnType, false);, +	}, +, +	private void testSupports(MethodParameter returnType, boolean supports) {, +		assertEquals(supports, resultHandler.supports(handlerResult));, +		returnType = on(Handler.class).resolveReturnType(View.class);, +		returnType = on(Handler.class).resolveReturnType(Mono.class, View.class);, +		returnType = on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class);, +		returnType = on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class);, +		returnValue = "123";, +		testHandle("/account", returnType, returnValue, "account: {id=123, myString=123}", resolver);, +, +		returnType = on(Handler.class).resolveReturnType(Mono.class, String.class);, +		returnType = on(Handler.class).resolveReturnType(Model.class);, +		// Work around  caching issue..., +		ResolvableType.clearCache();, +, +		returnType = on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Map.class);, +		// Work around  caching issue..., +		ResolvableType.clearCache();]