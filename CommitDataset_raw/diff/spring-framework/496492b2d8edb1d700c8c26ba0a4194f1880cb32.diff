[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {, +		String primaryCandidate = determinePrimaryCandidate(candidateBeans, requiredType);, +		String priorityCandidate = determineHighestPriorityCandidate(candidateBeans, requiredType);, +	 * Determine whether the given beanName/candidateName pair indicates a self reference,, +	 * i.e. whether the candidate points back to the original bean or to a factory method, +	 * on the original bean., +	 */, +	private boolean isSelfReference(String beanName, String candidateName) {, +		if (beanName.equals(candidateName)) {, +			return true;, +		}, +		if (candidateName != null && containsBeanDefinition(candidateName)) {, +			if (beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName())) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {, +		String primaryCandidate = determinePrimaryCandidate(candidateBeans, requiredType);, +		String priorityCandidate = determineHighestPriorityCandidate(candidateBeans, requiredType);, +	 * Determine whether the given beanName/candidateName pair indicates a self reference,, +	 * i.e. whether the candidate points back to the original bean or to a factory method, +	 * on the original bean., +	 */, +	private boolean isSelfReference(String beanName, String candidateName) {, +		if (beanName.equals(candidateName)) {, +			return true;, +		}, +		if (candidateName != null && containsBeanDefinition(candidateName)) {, +			if (beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName())) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassPostProcessorTests.java, +import javax.annotation.PostConstruct;, +import org.springframework.util.Assert;, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(WildcardWithExtendsConfiguration.class));, +		new ConfigurationClassPostProcessor().postProcessBeanFactory(beanFactory);, +		new ConfigurationClassPostProcessor().postProcessBeanFactory(beanFactory);, +	@Test, +	public void testSelfReferenceExclusionForFactoryMethodOnSameBean() {, +		AutowiredAnnotationBeanPostProcessor bpp = new AutowiredAnnotationBeanPostProcessor();, +		bpp.setBeanFactory(beanFactory);, +		beanFactory.addBeanPostProcessor(bpp);, +		beanFactory.addBeanPostProcessor(new CommonAnnotationBeanPostProcessor());, +		beanFactory.registerBeanDefinition("configClass", new RootBeanDefinition(ConcreteConfig.class));, +		beanFactory.registerBeanDefinition("serviceBeanProvider", new RootBeanDefinition(ServiceBeanProvider.class));, +		new ConfigurationClassPostProcessor().postProcessBeanFactory(beanFactory);, +		beanFactory.preInstantiateSingletons();, +	}, +, +	public static class ServiceBean {, +, +		private final String parameter;, +, +		public ServiceBean(String parameter) {, +			this.parameter = parameter;, +, +		public String getParameter() {, +			return parameter;, +		}, +	}, +, +	@Configuration, +	public static abstract class AbstractConfig {, +, +		@Bean, +		public ServiceBean serviceBean() {, +			return provider().getServiceBean();, +		}, +, +		@Bean, +		public ServiceBeanProvider provider() {, +			return new ServiceBeanProvider();, +		}, +	}, +, +	@Configuration, +	public static class ConcreteConfig extends AbstractConfig {, +, +		@Autowired, +		private ServiceBeanProvider provider;, +, +		@Bean, +		@Override, +		public ServiceBeanProvider provider() {, +			return provider;, +		}, +, +		@PostConstruct, +		public void validate() {]