[+++ b/spring-context/src/main/java/org/springframework/context/annotation/AnnotationConfigApplicationContext.java, +		getBeanFactory().registerSingleton(, +	 * Note that {@link #refresh()} must be called in order for the context, +	 * to fully process the new class., +	 * <p>Calls to {@code register} are idempotent; adding the same, +++ b/spring-context/src/main/java/org/springframework/context/annotation/AnnotationConfigApplicationContext.java, +		getBeanFactory().registerSingleton(, +	 * Note that {@link #refresh()} must be called in order for the context, +	 * to fully process the new class., +	 * <p>Calls to {@code register} are idempotent; adding the same, +++ b/spring-web/src/main/java/org/springframework/web/context/support/AnnotationConfigWebApplicationContext.java, + * Copyright 2002-2013 the original author or authors., +import java.util.Arrays;, +import java.util.LinkedHashSet;, +import java.util.Set;, +, + * method, which is primarily for use by {@code ContextLoader}., +	private final Set<Class<?>> annotatedClasses = new LinkedHashSet<Class<?>>();, +, +	private final Set<String> basePackages = new LinkedHashSet<String>();, +, +, +	 * Set a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}, +	 * and/or {@link ClassPathBeanDefinitionScanner}., +	 * <p>Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}., +	 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator, +	 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator, +	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {, +		this.beanNameGenerator = beanNameGenerator;, +	 * Return the custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}, +	 * and/or {@link ClassPathBeanDefinitionScanner}, if any., +	protected BeanNameGenerator getBeanNameGenerator() {, +		return this.beanNameGenerator;, +	 * Set a custom {@link ScopeMetadataResolver} for use with {@link AnnotatedBeanDefinitionReader}, +	 * and/or {@link ClassPathBeanDefinitionScanner}., +	 * <p>Default is an {@link org.springframework.context.annotation.AnnotationScopeMetadataResolver}., +	 * @see AnnotatedBeanDefinitionReader#setScopeMetadataResolver, +	 * @see ClassPathBeanDefinitionScanner#setScopeMetadataResolver, +	 */, +	public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {, +		this.scopeMetadataResolver = scopeMetadataResolver;, +	}, +, +	/**, +	 * Return the custom {@link ScopeMetadataResolver} for use with {@link AnnotatedBeanDefinitionReader}, +	 * and/or {@link ClassPathBeanDefinitionScanner}, if any., +	 */, +	protected ScopeMetadataResolver getScopeMetadataResolver() {, +		return this.scopeMetadataResolver;, +	}, +, +, +	/**, +	 * Note that {@link #refresh()} must be called in order for the context, +	 * to fully process the new class., +	 * <p>Calls to {@code register} are idempotent; adding the same, +		this.annotatedClasses.addAll(Arrays.asList(annotatedClasses));, +		this.basePackages.addAll(Arrays.asList(basePackages));, +, +		if (!this.annotatedClasses.isEmpty()) {, +						StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + "]");, +			reader.register(this.annotatedClasses.toArray(new Class<?>[this.annotatedClasses.size()]));, +		if (!this.basePackages.isEmpty()) {, +						StringUtils.collectionToCommaDelimitedString(this.basePackages) + "]");, +			scanner.scan(this.basePackages.toArray(new String[this.basePackages.size()]));]