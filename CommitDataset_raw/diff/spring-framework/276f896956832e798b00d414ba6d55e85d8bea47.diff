[+++ b/src/asciidoc/web-flux.adoc, +When using stream types like `Flux` or `Observable`, the media type specified in the, +request/response or at mapping/routing level is used to determine how the data should be serialized, +and flushed. For example a REST endpoint that returns a `Flux<User>` will be serialized by, +default as following:, +, +* `application/json`: a `Flux<User>` is handled as an asynchronous collection and, +  serialized as a JSON array with an explicit flush when the `complete` event is emitted., +* `application/stream+json`: a `Flux<User>` will be handled as a stream of `User` elements, +  serialized as individual JSON object separated by new lines and explicitly flushed after, +  each element. The `WebClient` supports JSON stream decoding so this is a good use case, +  for server to server use case., +* `text/event-stream`: a `Flux<User>` or `Flux<ServerSentEvent<User>>` will be handled as, +  a stream of `User` or  `ServerSentEvent` elements serialized as individual SSE elements, +  using by default JSON for data encoding and explicit flush after each element. This, +  is well suited for exposing a stream to browser clients. `WebClient` supports, +  reading SSE streams as well., +, +, +This starter also supports the functional web API and will detect automatically `RouterFunction`, +beans. Your Spring Boot WebFlux application should use the `RouterFunction` *or* the, +`RequestMapping` approach, it is currently not possible to mix them in the same application.]