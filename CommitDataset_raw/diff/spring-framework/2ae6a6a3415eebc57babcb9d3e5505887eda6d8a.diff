[+++ b/spring-web/src/main/java/org/springframework/http/converter/xml/SourceHttpMessageConverter.java, + * Copyright 2002-2013 the original author or authors., +import java.io.InputStream;, +import javax.xml.parsers.DocumentBuilder;, +import javax.xml.parsers.DocumentBuilderFactory;, +import javax.xml.parsers.ParserConfigurationException;, +import javax.xml.stream.XMLInputFactory;, +import javax.xml.stream.XMLStreamException;, +import javax.xml.stream.XMLStreamReader;, +import javax.xml.transform.TransformerFactory;, +import javax.xml.transform.stax.StAXSource;, +import org.w3c.dom.Document;, +import org.xml.sax.SAXException;, +import org.xml.sax.XMLReader;, +import org.xml.sax.helpers.XMLReaderFactory;, +import org.springframework.http.HttpInputMessage;, +import org.springframework.http.HttpOutputMessage;, +import org.springframework.http.converter.AbstractHttpMessageConverter;, +import org.springframework.util.StreamUtils;, + * Implementation of {@link org.springframework.http.converter.HttpMessageConverter}, + * that can read and write {@link Source} objects., +public class SourceHttpMessageConverter<T extends Source> extends AbstractHttpMessageConverter<T> {, +, +	private final TransformerFactory transformerFactory = TransformerFactory.newInstance();, +, +	private boolean processExternalEntities = false;, +, +	/**, +	 * Sets the {@link #setSupportedMediaTypes(java.util.List) supportedMediaTypes}, +	 * to {@code text/xml} and {@code application/xml}, and {@code application/*-xml}., +	 */, +	public SourceHttpMessageConverter() {, +		super(MediaType.APPLICATION_XML, MediaType.TEXT_XML, new MediaType("application", "*+xml"));, +	}, +, +, +	/**, +	 * Indicates whether external XML entities are processed when converting, +	 * to a Source., +	 * <p>Default is {@code false}, meaning that external entities are not resolved., +	 */, +	public void setProcessExternalEntities(boolean processExternalEntities) {, +		this.processExternalEntities = processExternalEntities;, +	}, +		return DOMSource.class.equals(clazz) || SAXSource.class.equals(clazz), +				|| StreamSource.class.equals(clazz) || Source.class.equals(clazz);, +	protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage), +			throws IOException, HttpMessageNotReadableException {, +, +		InputStream body = inputMessage.getBody();, +			return (T) readDOMSource(body);, +			return (T) readSAXSource(body);, +		}, +		else if (StAXSource.class.equals(clazz)) {, +			return (T) readStAXSource(body);, +			return (T) readStreamSource(body);, +, +	private DOMSource readDOMSource(InputStream body) throws IOException {, +		try {, +			DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();, +			documentBuilderFactory.setNamespaceAware(true);, +			documentBuilderFactory.setFeature("http://xml.org/sax/features/external-general-entities", processExternalEntities);, +			DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();, +			Document document = documentBuilder.parse(body);, +			return new DOMSource(document);, +		}, +		catch (ParserConfigurationException ex) {, +			throw new HttpMessageNotReadableException("Could not set feature: " + ex.getMessage(), ex);, +		}, +		catch (SAXException ex) {, +			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);, +	private SAXSource readSAXSource(InputStream body) throws IOException {, +		try {, +			XMLReader reader = XMLReaderFactory.createXMLReader();, +			reader.setFeature("http://xml.org/sax/features/external-general-entities", processExternalEntities);, +			byte[] bytes = StreamUtils.copyToByteArray(body);, +			return new SAXSource(reader, new InputSource(new ByteArrayInputStream(bytes)));, +		}, +		catch (SAXException ex) {, +			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);, +		}, +	}, +, +	private Source readStAXSource(InputStream body) {, +		try {, +			XMLInputFactory inputFactory = XMLInputFactory.newFactory();, +			inputFactory.setProperty("javax.xml.stream.isSupportingExternalEntities", processExternalEntities);, +			XMLStreamReader streamReader = inputFactory.createXMLStreamReader(body);, +			return new StAXSource(streamReader);, +		}, +		catch (XMLStreamException ex) {, +			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);, +		}, +	}, +, +	private StreamSource readStreamSource(InputStream body) throws IOException {, +		byte[] bytes = StreamUtils.copyToByteArray(body);, +		return new StreamSource(new ByteArrayInputStream(bytes));, +	protected void writeInternal(T t, HttpOutputMessage outputMessage), +			throws IOException, HttpMessageNotWritableException {]