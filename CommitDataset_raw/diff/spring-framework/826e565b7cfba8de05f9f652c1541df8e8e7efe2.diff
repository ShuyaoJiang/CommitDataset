[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = GenericTypeResolver.resolveReturnTypeForGenericMethod(factoryMethod, args);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = GenericTypeResolver.resolveReturnTypeForGenericMethod(factoryMethod, args);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	 * where formal type variables are declared on the given class., +	 * @see #resolveReturnTypeForGenericMethod, +	 * <em>generic method</em>, where formal type variables are declared on, +	 * the given method itself., +	 * if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected, +	 * {@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will, +	 * <li>the target return type, if it can be inferred</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if, +	 * the given {@code method} does not declare any {@linkplain, +	 * Method#getTypeParameters() formal type variables}</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if the, +	 * than the length of the {@linkplain, +	public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {, +			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",, +		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters();, +		final Type genericReturnType = method.getGenericReturnType();, +		final Type[] methodArgumentTypes = method.getGenericParameterTypes();, +, +		// No declared type variables to inspect, so just return the standard return type., +		if (declaredTypeVariables.length == 0) {, +		if (args.length < methodArgumentTypes.length) {, +		// Ensure that the type variable (e.g., T) is declared directly on the method, +		// itself (e.g., via <T>), not on the enclosing class or interface., +		boolean locallyDeclaredTypeVariableMatchesReturnType = false;, +		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {, +			if (currentTypeVariable.equals(genericReturnType)) {, +						"Found declared type variable [%s] that matches the target return type [%s].",, +						currentTypeVariable, genericReturnType));, +				locallyDeclaredTypeVariableMatchesReturnType = true;, +		if (locallyDeclaredTypeVariableMatchesReturnType) {, +			for (int i = 0; i < methodArgumentTypes.length; i++) {, +				final Type currentMethodArgumentType = methodArgumentTypes[i];, +				if (currentMethodArgumentType.equals(genericReturnType)) {, +							"Found method argument type at index [%s] that matches the target return type.", i));, +				if (currentMethodArgumentType instanceof ParameterizedType) {, +					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType;, +									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",, +									"Could not determine the target type for type argument [%s] for method [%s].",, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = GenericTypeResolver.resolveReturnTypeForGenericMethod(factoryMethod, args);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	 * where formal type variables are declared on the given class., +	 * @see #resolveReturnTypeForGenericMethod, +	 * <em>generic method</em>, where formal type variables are declared on, +	 * the given method itself., +	 * if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected, +	 * {@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will, +	 * <li>the target return type, if it can be inferred</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if, +	 * the given {@code method} does not declare any {@linkplain, +	 * Method#getTypeParameters() formal type variables}</li>, +	 * <li>the {@linkplain Method#getReturnType() standard return type}, if the, +	 * than the length of the {@linkplain, +	public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {, +			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",, +		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters();, +		final Type genericReturnType = method.getGenericReturnType();, +		final Type[] methodArgumentTypes = method.getGenericParameterTypes();, +, +		// No declared type variables to inspect, so just return the standard return type., +		if (declaredTypeVariables.length == 0) {, +		if (args.length < methodArgumentTypes.length) {, +		// Ensure that the type variable (e.g., T) is declared directly on the method, +		// itself (e.g., via <T>), not on the enclosing class or interface., +		boolean locallyDeclaredTypeVariableMatchesReturnType = false;, +		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {, +			if (currentTypeVariable.equals(genericReturnType)) {, +						"Found declared type variable [%s] that matches the target return type [%s].",, +						currentTypeVariable, genericReturnType));, +				locallyDeclaredTypeVariableMatchesReturnType = true;, +		if (locallyDeclaredTypeVariableMatchesReturnType) {, +			for (int i = 0; i < methodArgumentTypes.length; i++) {, +				final Type currentMethodArgumentType = methodArgumentTypes[i];, +				if (currentMethodArgumentType.equals(genericReturnType)) {, +							"Found method argument type at index [%s] that matches the target return type.", i));, +				if (currentMethodArgumentType instanceof ParameterizedType) {, +					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType;, +									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",, +									"Could not determine the target type for type argument [%s] for method [%s].",, +++ b/spring-core/src/test/java/org/springframework/core/GenericTypeResolverTests.java, +	public void genericMethodReturnTypes() {, +		assertEquals(String.class, resolveReturnTypeForGenericMethod(notParameterized, new Object[] {}));, +			resolveReturnTypeForGenericMethod(notParameterizedWithArguments, new Object[] { 99, true }));, +		assertEquals(String.class, resolveReturnTypeForGenericMethod(createProxy, new Object[] { "foo" }));, +		assertNull(resolveReturnTypeForGenericMethod(createNamedProxyWithDifferentTypes, new Object[] { "enigma" }));, +			resolveReturnTypeForGenericMethod(createNamedProxyWithDifferentTypes, new Object[] { "enigma", 99L }));, +			resolveReturnTypeForGenericMethod(createNamedProxyWithDuplicateTypes, new Object[] { "enigma", "foo" }));, +		assertEquals(Runnable.class, resolveReturnTypeForGenericMethod(createMock, new Object[] { Runnable.class }));, +			resolveReturnTypeForGenericMethod(createNamedMock, new Object[] { "foo", Runnable.class }));, +			resolveReturnTypeForGenericMethod(createVMock, new Object[] { "foo", Runnable.class }));, +		// resolveReturnTypeForGenericMethod() does not currently support this form of, +			resolveReturnTypeForGenericMethod(extractValueFrom, new Object[] { new MySimpleInterfaceType() }));, +		assertEquals(Object.class, resolveReturnTypeForGenericMethod(extractMagicValue, new Object[] { map }));, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, +				Class<?> returnType = GenericTypeResolver.resolveReturnTypeForGenericMethod(factoryMethod, args);]