[+++ b/spring-messaging/src/main/java/org/springframework/messaging/support/MessageBuilder.java, +		MessageHeaders headersToUse = this.headerAccessor.toMessageHeaders();, +			return (Message<T>) new ErrorMessage((Throwable) this.payload, headersToUse);, +			return new GenericMessage<T>(this.payload, headersToUse);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/MessageBuilder.java, +		MessageHeaders headersToUse = this.headerAccessor.toMessageHeaders();, +			return (Message<T>) new ErrorMessage((Throwable) this.payload, headersToUse);, +			return new GenericMessage<T>(this.payload, headersToUse);, +++ b/spring-messaging/src/main/java/org/springframework/messaging/support/MessageHeaderAccessor.java, + * accessor.setHeader("foo", "bar");, + * accessor.setHeader("foo", "bar");, + * accessor.setHeader("bar", "baz");, + * @author Juergen Hoeller, +	private boolean enableTimestamp = false;, +, +	/**, +	 * Build a 'nested' accessor for the given message., +	 * @param message the message to build a new accessor for, +	 * @return the nested accessor (typically a specific subclass), +	 */, +	// Configuration properties, +	 * Mark the underlying message headers as modified., +	 * @param modified typically {@code true}, or {@code false} to reset the flag, +	 * @since 4.1, +	protected void setModified(boolean modified) {, +		this.modified = modified;, +	/**, +	 * Check whether the underlying message headers have been marked as modified., +	 * @return {@code true} if the flag has been set, {@code false} otherwise, +	 */, +	/**, +	 * A package private mechanism to enables the automatic addition of the, +	 * {@link org.springframework.messaging.MessageHeaders#TIMESTAMP} header., +	 * <p>By default, this property is set to {@code false}., +	 * @see IdTimestampMessageHeaderInitializer, +	 */, +	void setEnableTimestamp(boolean enableTimestamp) {, +		this.enableTimestamp = enableTimestamp;, +, +	// Accessors for the resulting MessageHeaders, +, +	/**, +	 * Return the underlying {@code MessageHeaders} instance., +	 * <p>Unless {@link #setLeaveMutable(boolean)} was set to {@code true}, after, +	 * this call, the headers are immutable and this accessor can no longer, +	 * modify them., +	 * <p>This method always returns the same {@code MessageHeaders} instance if, +	 * invoked multiples times. To obtain a copy of the underlying headers, use, +	 * {@link #toMessageHeaders()} or {@link #toMap()} instead., +	 * @since 4.1, +	 */, +	public MessageHeaders getMessageHeaders() {, +		if (!this.leaveMutable) {, +			setImmutable();, +		}, +		return this.headers;, +	}, +, +	/**, +	 * Return a copy of the underlying header values as a {@link MessageHeaders} object., +	 * <p>This method can be invoked many times, with modifications in between, +	 * where each new call returns a fresh copy of the current header values., +	 * @since 4.1, +	 */, +	public MessageHeaders toMessageHeaders() {, +		return new MessageHeaders(this.headers);, +	}, +, +	/**, +	 * Return a copy of the underlying header values as a plain {@link Map} object., +	 * <p>This method can be invoked many times, with modifications in between, +	 * where each new call returns a fresh copy of the current header values., +	 */, +	public Map<String, Object> toMap() {, +		return new HashMap<String, Object>(this.headers);, +	}, +, +, +	// Generic header accessors, +, +	/**, +	 * Retrieve the value for the header with the given name., +	 * @param headerName the name of the header, +	 * @return the associated value, or {@code null} if none found, +	 */, +	 * Remove the value for the given header name., +	 */, +	public void removeHeader(String headerName) {, +		if (StringUtils.hasLength(headerName) && !isReadOnly(headerName)) {, +			setHeader(headerName, null);, +		}, +	}, +, +	/**, +				if (!isReadOnly(key)) {, +	protected boolean isReadOnly(String headerName) {, +		return (MessageHeaders.ID.equals(headerName) || MessageHeaders.TIMESTAMP.equals(headerName));, +	}, +, +]