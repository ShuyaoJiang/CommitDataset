[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +import static org.springframework.core.annotation.AnnotationUtils.*;, +, +		process(element, annotationType, true, new Processor<Object>() {, +, +			public Object process(Annotation annotation, int metaDepth) {, +				if (metaDepth > 0) {, +, +		return Boolean.TRUE.equals(process(element, annotationType, true, new Processor<Boolean>() {, +, +			public Boolean process(Annotation annotation, int metaDepth) {, +				if (metaDepth > 0) {, +					return Boolean.TRUE;, +, +		return Boolean.TRUE.equals(process(element, annotationType, true, new Processor<Boolean>() {, +, +			public Boolean process(Annotation annotation, int metaDepth) {, +				return Boolean.TRUE;, +, +	public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element, String annotationType,, +		return process(element, annotationType, true, new Processor<AnnotationAttributes>() {, +, +			public AnnotationAttributes process(Annotation annotation, int metaDepth) {, +, +					if (!VALUE.equals(key)) {, +						Object value = getValue(annotation, key);, +	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,, +			final String annotationType) {, +		return getAllAnnotationAttributes(element, annotationType, false, false);, +	}, +, +	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,, +			final String annotationType, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {, +		process(element, annotationType, false, new Processor<Void>() {, +, +			public Void process(Annotation annotation, int metaDepth) {, +					for (Map.Entry<String, Object> entry : AnnotationUtils.getAnnotationAttributes(annotation,, +						classValuesAsString, nestedAnnotationsAsMap).entrySet()) {, +, +					if (!VALUE.equals(key)) {, +						Object value = getValue(annotation, key);, +	 * Process all annotations of the specified {@code annotationType} and, +	 * recursively all meta-annotations on the specified {@code element}., +	 *, +	 * <p>If the {@code traverseClassHierarchy} flag is {@code true} and the sought, +	 * annotation is neither <em>directly present</em> on the given element nor, +	 * present on the given element as a meta-annotation, then the algorithm will, +	 * recursively search through the class hierarchy of the given element., +	 *, +	 * @param annotationType the annotation type to find, +	 * @param traverseClassHierarchy whether or not to traverse up the class, +	 * hierarchy recursively, +	 * @param processor the processor to delegate to, +	private static <T> T process(AnnotatedElement element, String annotationType, boolean traverseClassHierarchy,, +			Processor<T> processor) {, +		return doProcess(element, annotationType, traverseClassHierarchy, processor, new HashSet<AnnotatedElement>(), 0);, +	/**, +	 * Perform the search algorithm for the {@link #process} method, avoiding, +	 * endless recursion by tracking which annotated elements have already been, +	 * <em>visited</em>., +	 * , +	 * <p>The {@code metaDepth} parameter represents the depth of the annotation, +	 * relative to the initial element. For example, an annotation that is, +	 * <em>present</em> on the element will have a depth of 0; a meta-annotation, +	 * will have a depth of 1; and a meta-meta-annotation will have a depth of 2., +	 *, +	 * @param element the annotated element, +	 * @param annotationType the annotation type to find, +	 * @param traverseClassHierarchy whether or not to traverse up the class, +	 * hierarchy recursively, +	 * @param processor the processor to delegate to, +	 * @param visited the set of annotated elements that have already been visited, +	 * @param metaDepth the depth of the annotation relative to the initial element, +	 * @return the result of the processor, +	 */, +	private static <T> T doProcess(AnnotatedElement element, String annotationType, boolean traverseClassHierarchy,, +			Processor<T> processor, Set<AnnotatedElement> visited, int metaDepth) {, +, +			Annotation[] annotations = traverseClassHierarchy ? element.getDeclaredAnnotations(), +					: element.getAnnotations();, +, +			for (Annotation annotation : annotations) {, +				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {, +					T result = processor.process(annotation, metaDepth);, +					result = doProcess(annotation.annotationType(), annotationType, traverseClassHierarchy, processor,, +						visited, metaDepth + 1);, +, +			for (Annotation annotation : annotations) {, +				if (!isInJavaLangAnnotationPackage(annotation)) {, +					T result = doProcess(annotation.annotationType(), annotationType, traverseClassHierarchy,, +						processor, visited, metaDepth);, +, +			if (traverseClassHierarchy && element instanceof Class) {, +				Class<?> superclass = ((Class<?>) element).getSuperclass();, +				if (superclass != null && !superclass.equals(Object.class)) {, +					T result = doProcess(superclass, annotationType, traverseClassHierarchy, processor, visited,, +						metaDepth);, +					if (result != null) {, +						return result;, +				}]