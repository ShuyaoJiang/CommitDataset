[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final ConditionEvaluator conditionEvaluator;, +, +	public int getPropertySourceCount() {, +		return this.propertySources.size();, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final ConditionEvaluator conditionEvaluator;, +, +	public int getPropertySourceCount() {, +		return this.propertySources.size();, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import java.util.Arrays;, +		String[] candidateNames = registry.getBeanDefinitionNames();, +, +		for (String beanName : candidateNames) {, +, +		Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());, +		int propertySourceCount = 0;, +		do {, +			if (parser.getPropertySourceCount() > propertySourceCount) {, +				propertySourceCount = parser.getPropertySourceCount();, +			}, +, +			Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());, +			configClasses.removeAll(alreadyParsed);, +			this.reader.loadBeanDefinitions(configClasses);, +			alreadyParsed.addAll(configClasses);, +			configCandidates.clear();, +			if (registry.getBeanDefinitionCount() > candidateNames.length) {, +				String[] newCandidateNames = registry.getBeanDefinitionNames();, +				Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));, +				for (String candidateName : newCandidateNames) {, +					if (!oldCandidateNames.contains(candidateName)) {, +						BeanDefinition beanDef = registry.getBeanDefinition(candidateName);, +						if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {, +							configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));, +						}, +					}, +				}, +				candidateNames = newCandidateNames;, +			}, +		}, +		while (!configCandidates.isEmpty());, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final ConditionEvaluator conditionEvaluator;, +, +	public int getPropertySourceCount() {, +		return this.propertySources.size();, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java, +import java.util.Arrays;, +		String[] candidateNames = registry.getBeanDefinitionNames();, +, +		for (String beanName : candidateNames) {, +, +		Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());, +		int propertySourceCount = 0;, +		do {, +			if (parser.getPropertySourceCount() > propertySourceCount) {, +				propertySourceCount = parser.getPropertySourceCount();, +			}, +, +			Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());, +			configClasses.removeAll(alreadyParsed);, +			this.reader.loadBeanDefinitions(configClasses);, +			alreadyParsed.addAll(configClasses);, +			configCandidates.clear();, +			if (registry.getBeanDefinitionCount() > candidateNames.length) {, +				String[] newCandidateNames = registry.getBeanDefinitionNames();, +				Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));, +				for (String candidateName : newCandidateNames) {, +					if (!oldCandidateNames.contains(candidateName)) {, +						BeanDefinition beanDef = registry.getBeanDefinition(candidateName);, +						if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {, +							configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));, +						}, +					}, +				}, +				candidateNames = newCandidateNames;, +			}, +		}, +		while (!configCandidates.isEmpty());, +++ b/spring-context/src/test/java/org/springframework/context/annotation/ImportAwareTests.java, + * Copyright 2002-2014 the original author or authors., +, + * @author Juergen Hoeller, +		assertNotNull(ctx.getBean("importedConfigBean"));, +		assertNotNull(ctx.getBean("importedConfigBean"));, +		assertNotNull(ctx.getBean("otherImportedConfigBean"));, +		assertNotNull(ctx.getBean("otherImportedConfigBean"));, +		assertNotNull(ctx.getBean("importedConfigBean"));, +, +	@Configuration, +	static class OtherImportedConfig {, +]