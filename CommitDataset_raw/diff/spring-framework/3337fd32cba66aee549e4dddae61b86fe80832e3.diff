[+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?> resolveType(Type genericType, final Map<TypeVariable, Type> typeVariableMap) {, +, +		ResolvableType.VariableResolver variableResolver = new ResolvableType.VariableResolver() {, +			@Override, +			public ResolvableType resolveVariable(TypeVariable<?> variable) {, +				Type type = typeVariableMap.get(variable);, +				return (type == null ? null : ResolvableType.forType(type));, +			}, +, +			@Override, +			public Object getSource() {, +				return typeVariableMap;, +			}, +		};, +, +		return ResolvableType.forType(genericType, variableResolver).resolve(Object.class);, +++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?> resolveType(Type genericType, final Map<TypeVariable, Type> typeVariableMap) {, +, +		ResolvableType.VariableResolver variableResolver = new ResolvableType.VariableResolver() {, +			@Override, +			public ResolvableType resolveVariable(TypeVariable<?> variable) {, +				Type type = typeVariableMap.get(variable);, +				return (type == null ? null : ResolvableType.forType(type));, +			}, +, +			@Override, +			public Object getSource() {, +				return typeVariableMap;, +			}, +		};, +, +		return ResolvableType.forType(genericType, variableResolver).resolve(Object.class);, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +import java.io.ObjectStreamException;, +import java.io.Serializable;, + * {@link #forMethodReturnType(Method) method returns} or, + * {@link #forClass(Class) classes}. Most methods on this class will themselves return, + * {@link ResolvableType}s, allowing easy navigation. For example:, +public final class ResolvableType implements Serializable {, +	public static final ResolvableType NONE = new ResolvableType(null, null, null);, +	 * The {@link VariableResolver} to use or {@code null} if no resolver is available., +	private final VariableResolver variableResolver;, +	/**, +	 * The component type for an array or {@code null} if the type should be deduced., +	 */, +	private final ResolvableType componentType;, +, +, +	 * @param componentType an option declared component type for arrays (may be {@code null}), +	private ResolvableType(Type type, VariableResolver variableResolver, ResolvableType componentType) {, +		this.componentType = componentType;, +		if (this.componentType != null) {, +			return this.componentType;, +		}, +			return forType(componentType, this.variableResolver);, +		final Class<?> resolved = resolve();, +		return forType(SerializableTypeWrapper.forGenericSuperclass(resolved), asVariableResolver());, +		final Class<?> resolved = resolve();, +		return forTypes(SerializableTypeWrapper.forGenericInterfaces(resolved), asVariableResolver());, +		if (this.type instanceof Class<?>) {, +			Class<?> typeClass = (Class<?>) this.type;, +			return forTypes(SerializableTypeWrapper.forTypeParameters(typeClass), this.variableResolver);, +		}, +			Type[] actualTypeArguments = ((ParameterizedType) this.type).getActualTypeArguments();, +			ResolvableType[] generics = new ResolvableType[actualTypeArguments.length];, +			for (int i = 0; i < actualTypeArguments.length; i++) {, +				generics[i] = forType(actualTypeArguments[i], this.variableResolver);, +			Class<?> resolvedClass = resolveClass();, +			this.resolved = (resolvedClass == null ? void.class : resolvedClass);, +	 * NOTE: the returned {@link ResolvableType} should only be used as an intermediary as, +	 * it cannot be serialized., +, +			return forType(((ParameterizedType) this.type).getRawType(),, +					this.variableResolver);, +, +		if (this.type instanceof WildcardType) {, +			Type resolved = resolveBounds(((WildcardType) this.type).getUpperBounds());, +			return forType(resolved, this.variableResolver);, +, +		if (this.type instanceof TypeVariable) {, +			TypeVariable<?> variable = (TypeVariable<?>) this.type;, +, +			// Try default variable resolution, +				ResolvableType resolved = this.variableResolver.resolveVariable(variable);, +				if(resolved != null) {, +					return resolved;, +, +			// Fallback to bounds, +			return forType(resolveBounds(variable.getBounds()), this.variableResolver);, +		}, +, +		return NONE;, +	private ResolvableType resolveVariable(TypeVariable<?> variable) {, +, +		if (this.type instanceof TypeVariable) {, +			return resolveType().resolveVariable(variable);, +		}, +]