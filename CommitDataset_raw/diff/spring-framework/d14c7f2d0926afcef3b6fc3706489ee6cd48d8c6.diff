[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java, +import org.springframework.util.LinkedMultiValueMap;, +import org.springframework.util.MultiValueMap;, +import org.springframework.web.util.UrlPathHelper;, + * @param <T> Represents a mapping key with conditions for mapping a request to a {@link HandlerMethod}., +	private UrlPathHelper urlPathHelper = new UrlPathHelper();, +, +	private final MultiValueMap<String, T> urlMap = new LinkedMultiValueMap<String, T>();, +	, +	 * Set if URL lookup should always use the full path within the current servlet context. Else, the path within the, +	 * current servlet mapping is used if applicable (that is, in the case of a ".../*" servlet mapping in web.xml)., +	 * <p>Default is "false"., +	 *, +	 * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath, +	 */, +	public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {, +		this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);, +	}, +, +	/**, +	 * Set if context path and request URI should be URL-decoded. Both are returned <i>undecoded</i> by the Servlet API, in, +	 * contrast to the servlet path. <p>Uses either the request encoding or the default encoding according to the Servlet, +	 * spec (ISO-8859-1)., +	 *, +	 * @see org.springframework.web.util.UrlPathHelper#setUrlDecode, +	 */, +	public void setUrlDecode(boolean urlDecode) {, +		this.urlPathHelper.setUrlDecode(urlDecode);, +	}, +, +	/**, +	 * Set the UrlPathHelper to use for resolution of lookup paths. <p>Use this to override the default UrlPathHelper , +	 * with a custom subclass, or to share common UrlPathHelper settings across multiple HandlerMappings and, +	 * MethodNameResolvers., +	 *, +	 */, +	public void setUrlPathHelper(UrlPathHelper urlPathHelper) {, +		Assert.notNull(urlPathHelper, "UrlPathHelper must not be null");, +		this.urlPathHelper = urlPathHelper;, +	}, +	, +	/**, +	 * Return the {@link UrlPathHelper} to use for resolution of lookup paths., +	 */, +	public UrlPathHelper getUrlPathHelper() {, +		return urlPathHelper;, +	}, +, +	/**, +	 * <p>The actual mapping for a handler is up to the concrete {@link #getMappingKeyForMethod(String, Method)}, +	 * implementation., +			logger.debug("Looking for request mappings in application context: " + getApplicationContext());, +				return getMappingKeyForMethod(beanName, method) != null;, +			T mapping = getMappingKeyForMethod(beanName, method);, +			Set<String> paths = getMappingPaths(mapping);, +			registerHandlerMethod(paths, mapping, handlerMethod);, +	 * Provides a mapping key for the given bean method. A method for which no mapping can be determined is, +	 * @param method the method to create a mapping for, +	 * @return the mapping key, or {@code null} if the method is not mapped, +	protected abstract T getMappingKeyForMethod(String beanName, Method method);, +	 * Registers a {@link HandlerMethod} with the given mapping., +	 * @param paths URL paths mapped to this method, +	 * @param mappingKey the mapping key for the method, +	 * @throws IllegalStateException if another method was already register under the same mapping, +	protected void registerHandlerMethod(Set<String> paths, T mappingKey, HandlerMethod handlerMethod) {, +		Assert.notNull(mappingKey, "'mapping' must not be null");, +		HandlerMethod mappedHandlerMethod = handlerMethods.get(mappingKey);, +					+ "' bean method \n" + handlerMethod + "\nto " + mappingKey + ": There is already '", +		handlerMethods.put(mappingKey, handlerMethod);, +			logger.info("Mapped \"" + mappingKey + "\" onto " + handlerMethod);, +		}, +		for (String path : paths) {, +			urlMap.add(path, mappingKey);, +	/**, +	 * Get the URL paths for the given mapping. , +	 */, +	protected abstract Set<String> getMappingPaths(T mappingKey);, +, +		String lookupPath = urlPathHelper.getLookupPathForRequest(request);, +			logger.debug("Looking up handler method for path " + lookupPath);, +		HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);, +				logger.debug("Did not find handler method for [" + lookupPath + "]");, +	 * @param lookupPath mapping lookup path within the current servlet mapping if applicable, +	protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {, +		List<T> keys = urlMap.get(lookupPath);, +		if (keys == null) {, +			keys = new ArrayList<T>(handlerMethods.keySet());, +		for (T key : keys) {, +			T match = getMatchingMappingKey(key, lookupPath, request);, +				matches.add(new Match(match, handlerMethods.get(key)));, +			Comparator<Match> comparator = new MatchComparator(getMappingKeyComparator(lookupPath, request));, +				logger.trace("Found " + matches.size() + " matching mapping(s) for [" + lookupPath + "] : " + matches);, +			handleMatch(bestMatch.mappingKey, lookupPath, request);, +			return handleNoMatch(handlerMethods.keySet(), lookupPath, request);, +	 * Invoked when a request has been matched to a mapping., +	 * @param mappingKey the mapping selected for the request returned by , +	 * {@link #getMatchingMappingKey(Object, String, HttpServletRequest)}., +	 * @param lookupPath mapping lookup path within the current servlet mapping if applicable, +	protected void handleMatch(T mappingKey, String lookupPath, HttpServletRequest request) {, +	 * Checks if the mapping matches the current request and returns a mapping updated to contain only conditions ]