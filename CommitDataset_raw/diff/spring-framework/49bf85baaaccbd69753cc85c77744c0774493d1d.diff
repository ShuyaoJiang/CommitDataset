[+++ b/org.springframework.context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, +, +		Class typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +		return (typeArg == null || typeArg.isAssignableFrom(eventType));, +++ b/org.springframework.context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, +, +		Class typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +		return (typeArg == null || typeArg.isAssignableFrom(eventType));, +++ b/org.springframework.context/src/main/java/org/springframework/ui/format/support/GenericFormatterRegistry.java, +		Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +			throw new IllegalArgumentException("Unable to register Formatter " + formatter + " for type [" +, +					type.getName() + "]; not able to convert from [" + formattedObjectType.getName() + "] to parse");, +			throw new IllegalArgumentException("Unable to register Formatter " + formatter + " for type [" +, +					type.getName() + "]; not able to convert to [" + formattedObjectType.getName() + "] to format");, +		Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		Class[] typeArgs = GenericTypeResolver.resolveTypeArguments(factory.getClass(), AnnotationFormatterFactory.class);, +		if (typeArgs == null) {, +			throw new IllegalArgumentException(, +					"Unable to extract Annotation type A argument from AnnotationFormatterFactory [" +, +							factory.getClass().getName() + "]; does the factory parameterize the <A> generic type?");, +		}, +		this.annotationFormatters.put(typeArgs[0], factory);, +			Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +++ b/org.springframework.context/src/main/java/org/springframework/context/event/GenericApplicationListenerAdapter.java, +, +		Class typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);, +		return (typeArg == null || typeArg.isAssignableFrom(eventType));, +++ b/org.springframework.context/src/main/java/org/springframework/ui/format/support/GenericFormatterRegistry.java, +		Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +			throw new IllegalArgumentException("Unable to register Formatter " + formatter + " for type [" +, +					type.getName() + "]; not able to convert from [" + formattedObjectType.getName() + "] to parse");, +			throw new IllegalArgumentException("Unable to register Formatter " + formatter + " for type [" +, +					type.getName() + "]; not able to convert to [" + formattedObjectType.getName() + "] to format");, +		Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +		Class[] typeArgs = GenericTypeResolver.resolveTypeArguments(factory.getClass(), AnnotationFormatterFactory.class);, +		if (typeArgs == null) {, +			throw new IllegalArgumentException(, +					"Unable to extract Annotation type A argument from AnnotationFormatterFactory [" +, +							factory.getClass().getName() + "]; does the factory parameterize the <A> generic type?");, +		}, +		this.annotationFormatters.put(typeArgs[0], factory);, +			Class<?> formattedObjectType = GenericTypeResolver.resolveTypeArgument(formatter.getClass(), Formatter.class);, +++ b/org.springframework.core/src/main/java/org/springframework/core/GenericTypeResolver.java, +	public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {, +	public static Class<?> resolveReturnType(Method method, Class clazz) {, +	 * Resolve the single type argument of the given generic interface against, +	 * the given target class which is assumed to implement the generic interface, +	 * and possibly declare a concrete type for its type variable., +	 * @param clazz the target class to check against, +	 * @param genericIfc the generic interface to resolve the type argument from, +	 * @return the resolved type of the argument, or <code>null</code> if not resolvable, +	public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {, +		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc);, +		if (typeArgs == null) {, +			return null;, +		}, +		if (typeArgs.length != 1) {, +			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +, +					genericIfc.getName() + "] but found " + typeArgs.length);, +		}, +		return typeArgs[0];, +	}, +, +	/**, +	 * Resolve the type arguments of the given generic interface against the given, +	 * target class which is assumed to implement the generic interface and possibly, +	 * declare concrete types for its type variables., +	 * @param clazz the target class to check against, +	 * @param genericIfc the generic interface to resolve the type argument from, +	 * @return the resolved type of each argument, with the array size matching the, +	 * number of actual type arguments, or <code>null</code> if not resolvable, +	 */, +	public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {, +		return doResolveTypeArguments(clazz, clazz, genericIfc);, +	}, +, +	private static Class[] doResolveTypeArguments(Class ownerClass, Class classToIntrospect, Class genericIfc) {, +		while (classToIntrospect != null) {, +			Type[] ifcs = classToIntrospect.getGenericInterfaces();, +			for (Type ifc : ifcs) {, +				if (ifc instanceof ParameterizedType) {, +					ParameterizedType paramIfc = (ParameterizedType) ifc;, +					Type rawType = paramIfc.getRawType();, +					if (genericIfc.equals(rawType)) {, +						Type[] typeArgs = paramIfc.getActualTypeArguments();, +						Class[] result = new Class[typeArgs.length];, +						for (int i = 0; i < typeArgs.length; i++) {, +							Type arg = typeArgs[i];, +							if (arg instanceof TypeVariable) {, +								arg = getTypeVariableMap(ownerClass).get((TypeVariable) arg);, +							}, +							result[i] = (arg instanceof Class ? (Class) arg : Object.class);, +						}, +						return result;, +					}, +					else if (genericIfc.isAssignableFrom((Class) rawType)) {, +						return doResolveTypeArguments(ownerClass, (Class) rawType, genericIfc);, +					}, +				}, +				else if (genericIfc.isAssignableFrom((Class) ifc)) {]