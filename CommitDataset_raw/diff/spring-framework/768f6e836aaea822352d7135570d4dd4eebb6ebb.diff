[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, + * Copyright 2002-2015 the original author or authors., +	protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {, +		RootBeanDefinition mbdToUse = mbd;, +, +		// Make sure bean class is actually resolved at this point, and, +		// clone the bean definition in case of a dynamically resolved Class, +		// which cannot be stored in the shared merged bean definition., +		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);, +		if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {, +			mbdToUse = new RootBeanDefinition(mbd);, +			mbdToUse.setBeanClass(resolvedClass);, +		}, +			mbdToUse.prepareMethodOverrides();, +			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),, +			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);, +			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,, +		Object beanInstance = doCreateBean(beanName, mbdToUse, args);, +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, + * Copyright 2002-2015 the original author or authors., +	protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {, +		RootBeanDefinition mbdToUse = mbd;, +, +		// Make sure bean class is actually resolved at this point, and, +		// clone the bean definition in case of a dynamically resolved Class, +		// which cannot be stored in the shared merged bean definition., +		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);, +		if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {, +			mbdToUse = new RootBeanDefinition(mbd);, +			mbdToUse.setBeanClass(resolvedClass);, +		}, +			mbdToUse.prepareMethodOverrides();, +			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),, +			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);, +			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,, +		Object beanInstance = doCreateBean(beanName, mbdToUse, args);, +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, + * Copyright 2002-2015 the original author or authors., +		ClassLoader beanClassLoader = getBeanClassLoader();, +		ClassLoader classLoaderToUse = beanClassLoader;, +			// When just doing type checks (i.e. not creating an actual instance yet),, +			// use the specified temporary class loader (e.g. in a weaving scenario)., +				classLoaderToUse = tempClassLoader;, +			}, +		}, +		if (className != null) {, +			Object evaluated = evaluateBeanDefinitionString(className, mbd);, +			if (!className.equals(evaluated)) {, +				// A dynamically resolved expression, supported as of 4.2..., +				if (evaluated instanceof Class) {, +					return (Class<?>) evaluated;, +				}, +				else if (evaluated instanceof String) {, +					return ClassUtils.forName((String) evaluated, classLoaderToUse);, +				}, +				else {, +					throw new IllegalStateException("Invalid class name expression result: " + evaluated);, +			// When resolving against a temporary class loader, exit early in order, +			// to avoid storing the resolved Class in the bean definition., +			if (classLoaderToUse != beanClassLoader) {, +				return ClassUtils.forName(className, classLoaderToUse);, +			}, +		}, +		return mbd.resolveBeanClass(beanClassLoader);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java, + * Copyright 2002-2015 the original author or authors., +	protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {, +		RootBeanDefinition mbdToUse = mbd;, +, +		// Make sure bean class is actually resolved at this point, and, +		// clone the bean definition in case of a dynamically resolved Class, +		// which cannot be stored in the shared merged bean definition., +		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);, +		if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {, +			mbdToUse = new RootBeanDefinition(mbd);, +			mbdToUse.setBeanClass(resolvedClass);, +		}, +			mbdToUse.prepareMethodOverrides();, +			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),, +			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);, +			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,, +		Object beanInstance = doCreateBean(beanName, mbdToUse, args);, +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +	 * {@code getObjectType()} call, without full initialization of the FactoryBean., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java, + * Copyright 2002-2015 the original author or authors., +		ClassLoader beanClassLoader = getBeanClassLoader();, +		ClassLoader classLoaderToUse = beanClassLoader;, +			// When just doing type checks (i.e. not creating an actual instance yet),, +			// use the specified temporary class loader (e.g. in a weaving scenario)., +				classLoaderToUse = tempClassLoader;, +			}, +		}, +		if (className != null) {, +			Object evaluated = evaluateBeanDefinitionString(className, mbd);, +			if (!className.equals(evaluated)) {]