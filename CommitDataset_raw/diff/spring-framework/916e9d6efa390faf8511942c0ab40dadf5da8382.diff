[+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/TypeReference.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.reflect.Array;, +, +	private int dimensions;, +, +		this(pos,qualifiedId,0);, +	}, +, +	public TypeReference(int pos,SpelNodeImpl qualifiedId,int dims) {, +		this.dimensions = dims;, +				Class<?> clazz = tc.getType();, +				clazz = makeArrayIfNecessary(clazz);, +				return new TypedValue(clazz);, +		Class<?> clazz = state.findType(typename);, +		clazz = makeArrayIfNecessary(clazz);, +		return new TypedValue(clazz);, +	}, +, +	private Class makeArrayIfNecessary(Class clazz) {, +		if (dimensions!=0) {, +			for (int i=0;i<dimensions;i++) {, +				Object o = Array.newInstance(clazz, 0);, +				clazz = o.getClass();, +			}, +		}, +		return clazz;, +		for (int d=0;d<dimensions;d++) {, +			sb.append("[]");, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/TypeReference.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.reflect.Array;, +, +	private int dimensions;, +, +		this(pos,qualifiedId,0);, +	}, +, +	public TypeReference(int pos,SpelNodeImpl qualifiedId,int dims) {, +		this.dimensions = dims;, +				Class<?> clazz = tc.getType();, +				clazz = makeArrayIfNecessary(clazz);, +				return new TypedValue(clazz);, +		Class<?> clazz = state.findType(typename);, +		clazz = makeArrayIfNecessary(clazz);, +		return new TypedValue(clazz);, +	}, +, +	private Class makeArrayIfNecessary(Class clazz) {, +		if (dimensions!=0) {, +			for (int i=0;i<dimensions;i++) {, +				Object o = Array.newInstance(clazz, 0);, +				clazz = o.getClass();, +			}, +		}, +		return clazz;, +		for (int d=0;d<dimensions;d++) {, +			sb.append("[]");, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, + * Copyright 2002-2012 the original author or authors., +			// Are there array dimensions?, +			int dims = 0;, +			while (peekToken(TokenKind.LSQUARE,true)) {, +				eatToken(TokenKind.RSQUARE);, +				dims++;, +			}, +			constructedNodes.push(new TypeReference(toPos(typeName),node,dims));, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/TypeReference.java, + * Copyright 2002-2012 the original author or authors., +import java.lang.reflect.Array;, +, +	private int dimensions;, +, +		this(pos,qualifiedId,0);, +	}, +, +	public TypeReference(int pos,SpelNodeImpl qualifiedId,int dims) {, +		this.dimensions = dims;, +				Class<?> clazz = tc.getType();, +				clazz = makeArrayIfNecessary(clazz);, +				return new TypedValue(clazz);, +		Class<?> clazz = state.findType(typename);, +		clazz = makeArrayIfNecessary(clazz);, +		return new TypedValue(clazz);, +	}, +, +	private Class makeArrayIfNecessary(Class clazz) {, +		if (dimensions!=0) {, +			for (int i=0;i<dimensions;i++) {, +				Object o = Array.newInstance(clazz, 0);, +				clazz = o.getClass();, +			}, +		}, +		return clazz;, +		for (int d=0;d<dimensions;d++) {, +			sb.append("[]");, +		}, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java]