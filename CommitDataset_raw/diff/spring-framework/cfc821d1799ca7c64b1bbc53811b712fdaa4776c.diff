[+++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		Object value = getPropertyValue(tokens);, +		if (value == null || (value.getClass().equals(javaUtilOptionalClass) && OptionalUnwrapper.isEmpty(value))) {, +				value = setDefaultValue(tokens);, +		if (nestedBw == null || nestedBw.getWrappedInstance() !=, +				(value.getClass().equals(javaUtilOptionalClass) ? OptionalUnwrapper.unwrap(value) : value)) {, +			nestedBw = newNestedBeanWrapper(value, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);, +			Object result = optional.get();, +			Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");, +			return result;, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		Object value = getPropertyValue(tokens);, +		if (value == null || (value.getClass().equals(javaUtilOptionalClass) && OptionalUnwrapper.isEmpty(value))) {, +				value = setDefaultValue(tokens);, +		if (nestedBw == null || nestedBw.getWrappedInstance() !=, +				(value.getClass().equals(javaUtilOptionalClass) ? OptionalUnwrapper.unwrap(value) : value)) {, +			nestedBw = newNestedBeanWrapper(value, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);, +			Object result = optional.get();, +			Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");, +			return result;, +++ b/spring-context/src/main/java/org/springframework/validation/DataBinder.java, +import java.util.Optional;, +import org.springframework.lang.UsesJava8;, +import org.springframework.util.ClassUtils;, +	private static Class<?> javaUtilOptionalClass = null;, +, +	static {, +		try {, +			javaUtilOptionalClass =, +					ClassUtils.forName("java.util.Optional", DataBinder.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// Java 8 not available - Optional references simply not supported then., +		}, +	}, +, +, +		if (target != null && target.getClass().equals(javaUtilOptionalClass)) {, +			this.target = OptionalUnwrapper.unwrap(target);, +		}, +		else {, +		}, +, +	/**, +	 * Inner class to avoid a hard dependency on Java 8., +	 */, +	@UsesJava8, +	private static class OptionalUnwrapper {, +, +		public static Object unwrap(Object optionalObject) {, +			Optional<?> optional = (Optional<?>) optionalObject;, +			if (!optional.isPresent()) {, +				return null;, +			}, +			Object result = optional.get();, +			Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");, +			return result;, +		}, +	}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java, +		Object value = getPropertyValue(tokens);, +		if (value == null || (value.getClass().equals(javaUtilOptionalClass) && OptionalUnwrapper.isEmpty(value))) {, +				value = setDefaultValue(tokens);, +		if (nestedBw == null || nestedBw.getWrappedInstance() !=, +				(value.getClass().equals(javaUtilOptionalClass) ? OptionalUnwrapper.unwrap(value) : value)) {, +			nestedBw = newNestedBeanWrapper(value, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);, +			Object result = optional.get();, +			Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");, +			return result;, +++ b/spring-context/src/main/java/org/springframework/validation/DataBinder.java, +import java.util.Optional;, +import org.springframework.lang.UsesJava8;, +import org.springframework.util.ClassUtils;, +	private static Class<?> javaUtilOptionalClass = null;, +, +	static {, +		try {, +			javaUtilOptionalClass =, +					ClassUtils.forName("java.util.Optional", DataBinder.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// Java 8 not available - Optional references simply not supported then., +		}, +	}, +, +, +		if (target != null && target.getClass().equals(javaUtilOptionalClass)) {, +			this.target = OptionalUnwrapper.unwrap(target);, +		}, +		else {, +		}, +, +	/**, +	 * Inner class to avoid a hard dependency on Java 8., +	 */, +	@UsesJava8, +	private static class OptionalUnwrapper {, +, +		public static Object unwrap(Object optionalObject) {]