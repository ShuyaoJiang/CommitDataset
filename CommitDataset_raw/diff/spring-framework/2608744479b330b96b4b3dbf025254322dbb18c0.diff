[+++ b/spring-framework-reference/src/mvc.xml, +      <literal>AbstractController.setSynchronizeOnSession()</literal> method., +      Refer to <xref linkend="aop-understanding-aop-proxies" /> for more, +      information on AOP proxies and why you cannot add advice to final, +      methods.</para>, +    <interfacename>Controller</interfacename> is typically responsible for, +    preparing a model <classname>Map</classname> with data and selecting a, +    view name but it can also write directly to the response stream and, +    complete the request. View name resolution is highly configurable through, +    file extension or Accept header content type negotiation, through bean, +    names, a properties file, or even a custom, +    <interfacename>ViewResolver</interfacename> implementation. The model (the, +    M in MVC) is a <interfacename>Map</interfacename> interface, which allows, +    for the complete abstraction of the view technology. You can integrate, +    directly with template based rendering technologies such as JSP, Velocity, +    and Freemarker, or directly generate XML, JSON, Atom, and many other types, +    of content. The model <interfacename>Map</interfacename> is simply, +    transformed into an appropriate format, such as JSP request attributes, a, +    Velocity template model.</para>, +          <para><emphasis>Clear separation of roles</emphasis>. Each role —, +          resolver, and so on — can be fulfilled by a specialized, +    request-driven, designed around a central Servlet that dispatches requests, +        <caption><para>The request processing workflow in Spring Web MVC (high, +        level)</para></caption>, +    file. This is standard J2EE Servlet configuration; the following example, +    <literal>/example</literal> will be handled by the, +    <classname>DispatcherServlet</classname> instance named, +    <literal>example</literal>. This is only the first step in setting up, +    Spring Web MVC. <!--The discussion below is a little vague about what you're doing, when you do it, and what you're accomplishing. --><!-- Is the next step shown in the next example screen?-->You, +    new scope-specific beans local to a given Servlet instance.</para>, +    Servlet configuration (in the <literal>web.xml</literal> file):</para>, +    <para>With the above Servlet configuration in place, <!--Is this something you need to do (in above example)? -->you, +    configuration file through a Servlet initialization parameter (see below, +    and that it knows which Servlet it is associated with (by having a link to, +, +        linkend="mvc-multipart" /> for further information about multipart, +        handling.</para>, +    <classname>DispatcherServlet</classname> instances by adding Servlet, +    Servlet declaration in the <literal>web.xml</literal> file. See the, +, +            instantiates the context used by this Servlet. By default, the, +, +      <para>Available in the <link linkend="new-in-3.0-samples">samples, +      repository</link>, a number of web applications leverage the annotation, +      support described in this section including, +      <emphasis>MvcShowcase</emphasis>, <emphasis>MvcAjax</emphasis>,, +    annotations form the basis for the Spring MVC implementation. This section, +    documents these annotations and how they are most commonly used in a, +    Servlet environment.</para>, +, +, +    <lineannotation>&lt;!-- ... --&gt;</lineannotation>, +      <para>The following example from the <emphasis>Petcare</emphasis> sample, +      shows a controller in a Spring MVC application that uses this, +      annotation:</para>, +      not relative. The following example from the, +      <emphasis>PetClinic</emphasis> sample application shows a multi-action, +      controller using <classname>@RequestMapping</classname>:</para>, +        <title>Using <interfacename>@RequestMapping</interfacename> On, +        Interface Methods</title>, +, +        <para>A common pitfall when working with annotated controller classes, +        happens when applying functionality that requires creating a proxy for, +        the controller object (e.g., +        interface as well as the mapping mechanism can only "see" the, +        interface exposed by the proxy. Alternatively, you could activate, +        mechanisms see <xref linkend="aop-proxying" />.</para>, +        <para><emphasis>URI templates</emphasis> can be used for convenient, +        access to selected parts of a URL in a, +        <interfacename>@RequestMapping</interfacename> method.</para>, +        url="http://bitworking.org/projects/URI-Templates/">proposed, +        RFC</ulink> for URI Templates defines how a URI is parameterized. For, +        example, the URI Template, +        <code>http://www.example.com/users/{userId}</code> contains the, +        variable <emphasis>userId</emphasis>. Assigning the value, +        <emphasis>fred</emphasis> to the variable yields, +        <code>http://www.example.com/users/fred</code>.</para>, +        <para>In Spring MVC you can use the, +        <interfacename>@PathVariable</interfacename> annotation on a method, +        argument to bind it to the value of a URI template variable:</para>, +}</programlisting>, +        controller handles this request, the value of, +        <literal>ownerId</literal> is set to the value found in the, +        appropriate part of the URI. For example, when a request comes in for, +        <code>/owners/fred</code>, the value of <literal>ownerId</literal> is, +        <literal>fred</literal>.</para>, +          <para>To process the @PathVariable annotation, Spring MVC needs to, +          find the matching URI template variable by name. You can specify it, +          in the annotation:</para>, +          <para>Or if the URI template variable name matches the method, +          argument name you can omit that detail. As long as your code is not, +          compiled without debugging information, Spring MVC will match the, +          method argument name to the URI template variable name:</para>, +        <para>A method can have any number of, +        <interfacename>@PathVariable</interfacename> annotations:</para>, +}</programlisting>, +        <para>A URI template can be assembled from type and path level, +        <emphasis>@RequestMapping</emphasis> annotations. As a result the, +        <methodname>findPet()</methodname> method can be invoked with a URL, +}</programlisting>]