[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	private volatile boolean completionBeforeDemand;, +	private volatile Throwable errorBeforeDemand;, +	// Methods for sub-classes to delegate to, when async I/O events occur..., +	// Methods for sub-classes to implement..., +, +	/**, +	 * Check if data is available, calling {@link #onDataAvailable()} either, +	 * immediately or later when reading is possible., +	 */, +	 * Read once from the input, if possible., +	 * @return the item that was read; or {@code null}, +	// Private methods for use in State..., +, +	 * Read and publish data one at a time until there is no more data, no more, +	 * demand, or perhaps we completed in the mean time., +	 * @return {@code true} if there is more demand; {@code false} if there is, +	 * no more demand or we have completed., +		while ((r = this.demand) > 0 && !this.state.get().equals(State.COMPLETED)) {, +	private Subscription createSubscription() {, +		return new ReadSubscription();, +, +	/**, +	 * Subscription that delegates signals to State., +	 */, +	private final class ReadSubscription implements Subscription {, +, +, +			if (logger.isTraceEnabled()) {, +				logger.trace(state + " request: " + n);, +			state.get().request(AbstractListenerReadPublisher.this, n);, +			if (logger.isTraceEnabled()) {, +				logger.trace(state + " cancel");, +			state.get().cancel(AbstractListenerReadPublisher.this);, +	 * Represents a state for the {@link Publisher} to be in., +	 * <p><pre>, +	 *        SUBSCRIBING, +	 *             |, +	 *             v, +	 *    +---- NO_DEMAND ---------------> DEMAND ---+, +	 *    |        +------- READING <--------+       |, +	 *    +--------------> COMPLETED <---------------+, +					Subscription subscription = publisher.createSubscription();, +					// Now safe to check "beforeDemand" flags, they won't change once in NO_DEMAND, +					if (publisher.completionBeforeDemand) {, +						publisher.state.get().onAllDataRead(publisher);, +					Throwable ex = publisher.errorBeforeDemand;, +					if (ex != null) {, +						publisher.state.get().onError(publisher, ex);, +					throw new IllegalStateException("Failed to transition to SUBSCRIBING, " +, +							"subscriber: " + subscriber);, +				publisher.completionBeforeDemand = true;, +			<T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable ex) {, +				publisher.errorBeforeDemand = ex;, +		/**, +		 * Very brief state where we know we have a Subscriber but must not, +		 * send onComplete and onError until we after onSubscribe., +		 */, +				publisher.completionBeforeDemand = true;, +			<T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable ex) {, +				publisher.errorBeforeDemand = ex;, +					// or else we completed at the same time..., +					// Did a concurrent read transition to NO_DEMAND just before us?, +					// Maybe demand arrived between readAndPublish and READING->NO_DEMAND?, +			/**, +			 * @return whether to exit the read loop; false means stop trying, +			 * to read, true means check demand one more time., +			 */, +							return true;, +				// Either competing onDataAvailable calls (via request or container callback), +				// Or a concurrent completion, +					// Did a concurrent read transition to NO_DEMAND just before us?, +			if (!publisher.changeState(this, COMPLETED)) {, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java, +	private volatile boolean completionBeforeDemand;, +	private volatile Throwable errorBeforeDemand;, +	// Methods for sub-classes to delegate to, when async I/O events occur..., +	// Methods for sub-classes to implement..., +, +	/**, +	 * Check if data is available, calling {@link #onDataAvailable()} either, +	 * immediately or later when reading is possible., +	 */, +	 * Read once from the input, if possible., +	 * @return the item that was read; or {@code null}, +	// Private methods for use in State..., +, +	 * Read and publish data one at a time until there is no more data, no more, +	 * demand, or perhaps we completed in the mean time., +	 * @return {@code true} if there is more demand; {@code false} if there is, +	 * no more demand or we have completed., +		while ((r = this.demand) > 0 && !this.state.get().equals(State.COMPLETED)) {, +	private Subscription createSubscription() {, +		return new ReadSubscription();, +, +	/**, +	 * Subscription that delegates signals to State., +	 */, +	private final class ReadSubscription implements Subscription {, +]