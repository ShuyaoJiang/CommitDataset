[+++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/resource/AbstractResourceResolver.java, +import reactor.core.publisher.Mono;, +	public Mono<Resource> resolveResource(ServerWebExchange exchange, String requestPath,, +	public Mono<String> resolveUrlPath(String resourceUrlPath, List<? extends Resource> locations,, +	protected abstract Mono<Resource> resolveResourceInternal(ServerWebExchange exchange,, +			String requestPath, List<? extends Resource> locations, ResourceResolverChain chain);, +	protected abstract Mono<String> resolveUrlPathInternal(String resourceUrlPath,, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/resource/AbstractResourceResolver.java, +import reactor.core.publisher.Mono;, +	public Mono<Resource> resolveResource(ServerWebExchange exchange, String requestPath,, +	public Mono<String> resolveUrlPath(String resourceUrlPath, List<? extends Resource> locations,, +	protected abstract Mono<Resource> resolveResourceInternal(ServerWebExchange exchange,, +			String requestPath, List<? extends Resource> locations, ResourceResolverChain chain);, +	protected abstract Mono<String> resolveUrlPathInternal(String resourceUrlPath,, +++ b/spring-web-reactive/src/main/java/org/springframework/web/reactive/resource/AppCacheManifestTransformer.java, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.function.Consumer;, +import reactor.core.Exceptions;, +import reactor.core.publisher.Flux;, +import reactor.core.publisher.Mono;, +import reactor.core.publisher.SynchronousSink;, +	private static final Collection<String> MANIFEST_SECTION_HEADERS =, +			Arrays.asList("CACHE MANIFEST", "NETWORK:", "FALLBACK:", "CACHE:");, +, +	private static final String CACHE_HEADER = "CACHE:";, +, +	public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,, +			ResourceTransformerChain chain) {, +		return chain.transform(exchange, inputResource), +				.then(resource -> {, +					String name = resource.getFilename();, +					if (!this.fileExtension.equals(StringUtils.getFilenameExtension(name))) {, +						return Mono.just(resource);, +					String content = new String(getResourceBytes(resource), DEFAULT_CHARSET);, +							logger.trace("Manifest should start with 'CACHE MANIFEST', skip: " + resource);, +						return Mono.just(resource);, +					return Flux.generate(new LineGenerator(content)), +							.concatMap(info -> processLine(info, exchange, resource, chain)), +							.collect(() -> new LineAggregator(resource, content), LineAggregator::add), +							.then(aggregator -> Mono.just(aggregator.createResource()));, +				});, +, +	private static byte[] getResourceBytes(Resource resource) {, +		try {, +			return FileCopyUtils.copyToByteArray(resource.getInputStream());, +		}, +		catch (IOException ex) {, +			throw Exceptions.propagate(ex);, +	private Mono<LineOutput> processLine(LineInfo info, ServerWebExchange exchange,, +			Resource resource, ResourceTransformerChain chain) {, +, +		if (!info.isLink()) {, +			return Mono.just(new LineOutput(info.getLine(), null));, +		}, +, +		Mono<String> pathMono = resolveUrlPath(info.getLine(), exchange, resource, chain), +				.doOnNext(path -> {, +						logger.trace("Link modified: " + path + " (original: " + info.getLine() + ")");, +				});, +		Mono<Resource> resourceMono = chain.getResolverChain(), +				.resolveResource(null, info.getLine(), Collections.singletonList(resource));, +, +		return Flux.zip(pathMono, resourceMono, LineOutput::new).next();, +	private static class LineGenerator implements Consumer<SynchronousSink<LineInfo>> {, +		private final Scanner scanner;, +, +		private LineInfo previous;, +, +, +		public LineGenerator(String content) {, +			this.scanner = new Scanner(content);, +		public void accept(SynchronousSink<LineInfo> sink) {, +			if (this.scanner.hasNext()) {, +				String line = this.scanner.nextLine();, +				LineInfo current = new LineInfo(line, this.previous);, +				sink.next(current);, +				this.previous = current;, +			else {, +				sink.complete();, +	private static class LineInfo {, +		private final String line;, +, +		private final boolean cacheSection;, +, +		private final boolean link;, +, +, +		public LineInfo(String line, LineInfo previousLine) {, +			this.line = line;, +			this.cacheSection = initCacheSectionFlag(line, previousLine);, +			this.link = iniLinkFlag(line, this.cacheSection);, +		}, +, +		private static boolean initCacheSectionFlag(String line, LineInfo previousLine) {, +			if (MANIFEST_SECTION_HEADERS.contains(line.trim())) {, +				return line.trim().equals(CACHE_HEADER);, +			}, +			else if (previousLine != null) {, +				return previousLine.isCacheSection();]