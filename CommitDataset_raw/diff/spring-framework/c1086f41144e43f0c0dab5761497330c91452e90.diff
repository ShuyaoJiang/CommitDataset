[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/BindingContext.java, + * Copyright 2002-2017 the original author or authors., + * Context to assist with processing a request and binding it onto Objects., + *, + * <p>Provides  methods to create a {@link WebExchangeDataBinder} for a specific, + * target, command Object to apply data binding and validation to, or without a, + * target Object for simple type conversion from request values., + *, + * <p>Container for the default model for the request., +	private final Model model = new BindingAwareConcurrentModel();, +, +	 * Create a {@link WebExchangeDataBinder} to apply data binding and, +	 * validation with on the target, command object., +	 *, +	 *, +	 * @return the created data binder, +		WebExchangeDataBinder dataBinder = new WebExchangeDataBinder(target, name);, +	/**, +	 * Create a {@link WebExchangeDataBinder} without a target object for type, +	 * conversion of request values to simple types., +	 *, +	 * @param exchange the current exchange, +	 * @param name the name of the target object, +	 *, +	 * @return the created data binder, +	 */, +	public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {, +		return createDataBinder(exchange, null, name);, +	}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/BindingContext.java, + * Copyright 2002-2017 the original author or authors., + * Context to assist with processing a request and binding it onto Objects., + *, + * <p>Provides  methods to create a {@link WebExchangeDataBinder} for a specific, + * target, command Object to apply data binding and validation to, or without a, + * target Object for simple type conversion from request values., + *, + * <p>Container for the default model for the request., +	private final Model model = new BindingAwareConcurrentModel();, +, +	 * Create a {@link WebExchangeDataBinder} to apply data binding and, +	 * validation with on the target, command object., +	 *, +	 *, +	 * @return the created data binder, +		WebExchangeDataBinder dataBinder = new WebExchangeDataBinder(target, name);, +	/**, +	 * Create a {@link WebExchangeDataBinder} without a target object for type, +	 * conversion of request values to simple types., +	 *, +	 * @param exchange the current exchange, +	 * @param name the name of the target object, +	 *, +	 * @return the created data binder, +	 */, +	public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {, +		return createDataBinder(exchange, null, name);, +	}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/InitBinderBindingContext.java, + * Copyright 2002-2017 the original author or authors., +import java.util.Optional;, + * Variant of {@link BindingContext} that further initializes {@code DataBinder}, + * instances through {@code @InitBinder} methods., +class InitBinderBindingContext extends BindingContext {, +	/* Simple BindingContext to help with the invoking @InitBinder methods */, +	private final BindingContext binderMethodContext;, +		this.binderMethodContext = new BindingContext(initializer);, +	protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {, +				.filter(binderMethod -> {, +					InitBinder annotation = binderMethod.getMethodAnnotation(InitBinder.class);, +					Collection<String> names = Arrays.asList(annotation.value());, +					return (names.size() == 0 || names.contains(binder.getObjectName()));, +				}), +				.forEach(method -> invokeBinderMethod(binder, exchange, method));, +	private void invokeBinderMethod(WebExchangeDataBinder binder, ServerWebExchange exchange,, +			SyncInvocableHandlerMethod binderMethod) {, +, +		Optional<Object> returnValue = binderMethod, +				.invokeForHandlerResult(exchange, this.binderMethodContext, binder), +				.getReturnValue();, +, +		if (returnValue.isPresent()) {, +			throw new IllegalStateException(, +					"@InitBinder methods should return void: " + binderMethod);, +		// Should not happen (no argument resolvers)..., +		if (!this.binderMethodContext.getModel().asMap().isEmpty()) {, +			throw new IllegalStateException(, +					"@InitBinder methods should not add model attributes: " + binderMethod);]