[+++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/http/undertow/RequestBodyPublisher.java, +		if (this.subscriber != null) {, +		this.subscriber = s;, +		this.subscriber.onSubscribe(new RequestBodySubscription());, +			this.subscriptionClosed = true;, +			if (this.subscriptionClosed) {, +			this.draining = false;, +			this.subscriptionClosed = true;, +			this.subscriptionClosed = true;, +			if (this.pooledBuffer != null) {, +				safeClose(this.pooledBuffer);, +				this.pooledBuffer = null;, +			if (this.channel != null) {, +				safeClose(this.channel);, +				this.channel = null;, +			if (this.subscriptionClosed || this.draining) {, +			this.draining = true;, +			if (this.channel == null) {, +				this.channel = exchange.getRequestChannel();, +				if (this.channel == null) {, +			if (this.pooledBuffer == null) {, +				this.pooledBuffer = exchange.getConnection().getByteBufferPool().allocate();, +				this.pooledBuffer.getBuffer().clear();, +				ByteBuffer buffer = this.pooledBuffer.getBuffer();, +					count = this.channel.read(buffer);, +						this.channel.getReadSetter().set(this);, +						this.channel.resumeReads();, +							if (this.demand == 0) {, +								this.channel.suspendReads();, +							if (this.demand > 0) {, +			if (this.subscriptionClosed) {, +				ByteBuffer buffer = this.pooledBuffer.getBuffer();, +							if (this.demand == 0) {, +							if (this.demand > 0) {, +++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/http/undertow/RequestBodyPublisher.java, +		if (this.subscriber != null) {, +		this.subscriber = s;, +		this.subscriber.onSubscribe(new RequestBodySubscription());, +			this.subscriptionClosed = true;, +			if (this.subscriptionClosed) {, +			this.draining = false;, +			this.subscriptionClosed = true;, +			this.subscriptionClosed = true;, +			if (this.pooledBuffer != null) {, +				safeClose(this.pooledBuffer);, +				this.pooledBuffer = null;, +			if (this.channel != null) {, +				safeClose(this.channel);, +				this.channel = null;, +			if (this.subscriptionClosed || this.draining) {, +			this.draining = true;, +			if (this.channel == null) {, +				this.channel = exchange.getRequestChannel();, +				if (this.channel == null) {, +			if (this.pooledBuffer == null) {, +				this.pooledBuffer = exchange.getConnection().getByteBufferPool().allocate();, +				this.pooledBuffer.getBuffer().clear();, +				ByteBuffer buffer = this.pooledBuffer.getBuffer();, +					count = this.channel.read(buffer);, +						this.channel.getReadSetter().set(this);, +						this.channel.resumeReads();, +							if (this.demand == 0) {, +								this.channel.suspendReads();, +							if (this.demand > 0) {, +			if (this.subscriptionClosed) {, +				ByteBuffer buffer = this.pooledBuffer.getBuffer();, +							if (this.demand == 0) {, +							if (this.demand > 0) {, +++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/http/undertow/RequestHandlerAdapter.java, +		this.httpHandler.handle(request, response).subscribe(new Subscriber<Void>() {, +++ b/spring-web-reactive/src/main/java/org/springframework/reactive/web/http/undertow/RequestBodyPublisher.java, +		if (this.subscriber != null) {, +		this.subscriber = s;, +		this.subscriber.onSubscribe(new RequestBodySubscription());, +			this.subscriptionClosed = true;, +			if (this.subscriptionClosed) {, +			this.draining = false;, +			this.subscriptionClosed = true;, +			this.subscriptionClosed = true;, +			if (this.pooledBuffer != null) {, +				safeClose(this.pooledBuffer);, +				this.pooledBuffer = null;, +			if (this.channel != null) {, +				safeClose(this.channel);, +				this.channel = null;, +			if (this.subscriptionClosed || this.draining) {, +			this.draining = true;, +			if (this.channel == null) {, +				this.channel = exchange.getRequestChannel();, +				if (this.channel == null) {, +			if (this.pooledBuffer == null) {, +				this.pooledBuffer = exchange.getConnection().getByteBufferPool().allocate();, +				this.pooledBuffer.getBuffer().clear();, +				ByteBuffer buffer = this.pooledBuffer.getBuffer();, +					count = this.channel.read(buffer);, +						this.channel.getReadSetter().set(this);, +						this.channel.resumeReads();, +							if (this.demand == 0) {, +								this.channel.suspendReads();, +							if (this.demand > 0) {]