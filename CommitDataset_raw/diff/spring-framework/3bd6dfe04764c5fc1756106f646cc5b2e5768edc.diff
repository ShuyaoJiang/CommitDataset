[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +					DependencyDescriptor desc = new DependencyDescriptor(field, this.required);, +					desc.setContainingClass(bean.getClass());, +					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +								this.cachedFieldValue = desc;, +						DependencyDescriptor desc = new DependencyDescriptor(methodParam, this.required);, +						desc.setContainingClass(bean.getClass());, +						descriptors[i] = desc;, +						Object arg = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +					DependencyDescriptor desc = new DependencyDescriptor(field, this.required);, +					desc.setContainingClass(bean.getClass());, +					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +								this.cachedFieldValue = desc;, +						DependencyDescriptor desc = new DependencyDescriptor(methodParam, this.required);, +						desc.setContainingClass(bean.getClass());, +						descriptors[i] = desc;, +						Object arg = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +import org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver;, +public class QualifierAnnotationAutowireCandidateResolver extends GenericTypeAwareAutowireCandidateResolver {, +		boolean match = super.isAutowireCandidate(bdHolder, descriptor);, +		if (match && descriptor != null) {, +			match = checkQualifiers(bdHolder, descriptor.getAnnotations());, +		}, +				if (getBeanFactory() != null) {, +					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +					DependencyDescriptor desc = new DependencyDescriptor(field, this.required);, +					desc.setContainingClass(bean.getClass());, +					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +								this.cachedFieldValue = desc;, +						DependencyDescriptor desc = new DependencyDescriptor(methodParam, this.required);, +						desc.setContainingClass(bean.getClass());, +						descriptors[i] = desc;, +						Object arg = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +import org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver;, +public class QualifierAnnotationAutowireCandidateResolver extends GenericTypeAwareAutowireCandidateResolver {, +		boolean match = super.isAutowireCandidate(bdHolder, descriptor);, +		if (match && descriptor != null) {, +			match = checkQualifiers(bdHolder, descriptor.getAnnotations());, +		}, +				if (getBeanFactory() != null) {, +					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +import org.springframework.core.GenericTypeResolver;, +import org.springframework.core.ResolvableType;, +	private Class<?> containingClass;, +, +		this.containingClass = methodParameter.getContainingClass();, +		this.containingClass = original.containingClass;, +	 * Optionally set the concrete class that contains this dependency., +	 * This may differ from the class that declares the parameter/field in that, +	 * it may be a subclass thereof, potentially substituting type variables., +	 */, +	public void setContainingClass(Class<?> containingClass) {, +		this.containingClass = containingClass;, +		if (this.methodParameter != null) {, +			GenericTypeResolver.resolveParameterType(this.methodParameter, containingClass);, +		}, +	}, +, +	/**, +	 * Build a ResolvableType object for the wrapped parameter/field., +	 */, +	public ResolvableType getResolvableType() {, +		return (this.field != null ? ResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :, +				ResolvableType.forMethodParameter(this.methodParameter));, +	}, +, +	/**, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java, +					DependencyDescriptor desc = new DependencyDescriptor(field, this.required);, +					desc.setContainingClass(bean.getClass());, +					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +								this.cachedFieldValue = desc;, +						DependencyDescriptor desc = new DependencyDescriptor(methodParam, this.required);, +						desc.setContainingClass(bean.getClass());, +						descriptors[i] = desc;, +						Object arg = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.java, +import org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver;, +public class QualifierAnnotationAutowireCandidateResolver extends GenericTypeAwareAutowireCandidateResolver {, +		boolean match = super.isAutowireCandidate(bdHolder, descriptor);, +		if (match && descriptor != null) {, +			match = checkQualifiers(bdHolder, descriptor.getAnnotations());, +		}, +				if (getBeanFactory() != null) {, +					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/DependencyDescriptor.java, +import org.springframework.core.GenericTypeResolver;, +import org.springframework.core.ResolvableType;, +	private Class<?> containingClass;, +, +		this.containingClass = methodParameter.getContainingClass();, +		this.containingClass = original.containingClass;, +	 * Optionally set the concrete class that contains this dependency., +	 * This may differ from the class that declares the parameter/field in that, +	 * it may be a subclass thereof, potentially substituting type variables.]