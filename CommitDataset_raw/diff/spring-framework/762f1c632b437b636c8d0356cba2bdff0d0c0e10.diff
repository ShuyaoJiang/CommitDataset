[+++ b/spring-framework-reference/src/remoting.xml, +, +    <para>Spring features integration classes for remoting support using, +    various technologies. The remoting support eases the development of, +    remote-enabled services, implemented by your usual (Spring) POJOs., +    Currently, Spring supports four remoting technologies: <itemizedlist>, +          <para><emphasis>Remote Method Invocation (RMI)</emphasis>. Through, +          the use of the <classname>RmiProxyFactoryBean</classname> and the, +          <classname>RmiServiceExporter</classname> Spring supports both, +          traditional RMI (with <interfacename>java.rmi.Remote</interfacename>, +          interfaces and, +          transparent remoting via RMI invokers (with any Java, +          interface).</para>, +, +          <para><emphasis>Spring's HTTP invoker</emphasis>. Spring provides a, +          special remoting strategy which allows for Java serialization via, +          HTTP, supporting any Java interface (just like the RMI invoker). The, +          corresponding support classes are, +          <classname>HttpInvokerProxyFactoryBean</classname> and, +, +          expose your services using the lightweight binary HTTP-based, +          protocol provided by Caucho.</para>, +, +          alternative to Hessian. Spring provides support classes such as, +          <classname>BurlapProxyFactoryBean</classname> and, +, +, +, +          <para><emphasis>JMS</emphasis>. Remoting using JMS as the underlying, +          protocol is supported via the, +          <classname>JmsInvokerServiceExporter</classname> and, +, +    <para>While discussing the remoting capabilities of Spring, we'll use the, +    following domain model and corresponding services:</para>, +, +    public String getName(){, +        return name;, +    }, +, +    public List<Account> getAccounts(String name);, +, +    public List<Account> getAccounts(String name) throws RemoteException;, +, +    <programlisting language="java"><lineannotation>// the implementation doing nothing at the moment</lineannotation>, +        <lineannotation>// do something...</lineannotation>, +    public List&lt;Account&gt; getAccounts(String name) {, +        <lineannotation>// do something...</lineannotation>, +}</programlisting>, +, +    <para>We will start exposing the service to a remote client by using RMI, +    and talk a bit about the drawbacks of using RMI. We'll then continue to, +    show an example using Hessian as the protocol.</para>, +, +    <para>Using Spring's support for RMI, you can transparently expose your, +    services through the RMI infrastructure. After having this set up, you, +    basically have a configuration similar to remote EJBs, except for the fact, +    that there is no standard support for security context propagation or, +    remote transaction propagation. Spring does provide hooks for such, +    additional invocation context when using the RMI invoker, so you can for, +    example plug in security frameworks or custom security credentials, +    here.</para>, +      <title>Exporting the service using the, +      <classname>RmiServiceExporter</classname></title>, +, +      <para>Using the <classname>RmiServiceExporter</classname>, we can expose, +      the interface of our AccountService object as RMI object. The interface, +      can be accessed by using <classname>RmiProxyFactoryBean</classname>, or, +      via plain RMI in case of a traditional RMI service. The, +      <classname>RmiServiceExporter</classname> explicitly supports the, +      exposing of any non-RMI services via RMI invokers.</para>, +, +      <para>Of course, we first have to set up our service in the Spring, +      container:</para>, +, +      <programlisting language="xml">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;, +    <lineannotation>&lt;!-- any additional properties, maybe a DAO? --&gt;</lineannotation>, +&lt;/bean&gt;</programlisting>, +, +      <para>Next we'll have to expose our service using the, +      <classname>RmiServiceExporter</classname>:</para>, +, +      <programlisting language="xml">&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;, +    <lineannotation>&lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;</lineannotation>, +    &lt;property name="serviceName" value="AccountService"/&gt;, +    &lt;property name="service" ref="accountService"/&gt;, +    &lt;property name="serviceInterface" value="example.AccountService"/&gt;, +    <lineannotation>&lt;!-- defaults to <literal>1099</literal> --&gt;</lineannotation>, +    &lt;property name="registryPort" value="1199"/&gt;, +&lt;/bean&gt;</programlisting>, +, +      <para>As you can see, we're overriding the port for the RMI registry., +      Often, your application server also maintains an RMI registry and it is, +      wise to not interfere with that one. Furthermore, the service name is, +      used to bind the service under. So right now, the service will be bound, +      at <literal>'rmi://HOST:1199/AccountService'</literal>. We'll use the, +      URL later on to link in the service at the client side.</para>, +, +        <para>The <literal>servicePort</literal> property has been omitted (it, +        defaults to 0). This means that an anonymous port will be used to, +        communicate with the service.</para>]