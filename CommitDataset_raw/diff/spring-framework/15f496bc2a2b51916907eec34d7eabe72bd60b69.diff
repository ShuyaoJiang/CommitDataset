[+++ b/src/asciidoc/index.adoc, +[[beans-environment]], +=== Environment abstraction, +The {javadoc-baseurl}/org/springframework/core/env/Environment.html[`Environment`], +is an abstraction integrated in the container that models two key, +aspects of the application environment: <<beans-definition-profiles,_profiles_>>, +and <<beans-property-source-abstraction,_properties_>>., +, +A _profile_ is a named, logical group of bean definitions to be registered with the, +container only if the given profile is active. Beans may be assigned to a profile, +whether defined in XML or via annotations. The role of the `Environment` object with, +relation to profiles is in determining which profiles (if any) are currently active,, +and which profiles (if any) should be active by default., +, +Properties play an important role in almost all applications, and may originate from, +a variety of sources: properties files, JVM system properties, system environment, +variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so, +on. The role of the `Environment` object with relation to properties is to provide the, +user with a convenient service interface for configuring property sources and resolving, +properties from them., +, +[[beans-definition-profiles]], +==== Bean definition profiles, +, +Bean definition profiles is a mechanism in the core container that allows for, +registration of different beans in different environments. The word _environment_, +can mean different things to different users and this feature can help with many, +use cases, including:, +* registering customized implementations of beans for customer A vs. customer, +B deployments, +Let's consider the first use case in a practical application that requires a, +`DataSource`. In a test environment, the configuration may look like this:, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@Bean, +	public DataSource dataSource() {, +		return new EmbeddedDatabaseBuilder(), +			.setType(EmbeddedDatabaseType.HSQL), +			.addScript("my-schema.sql"), +			.addScript("my-test-data.sql"), +			.build();, +	}, +----, +, +Let's now consider how this application will be deployed into a QA or production, +environment, assuming that the datasource for the application will be registered, +with the production application server's JNDI directory. Our `dataSource` bean, +now looks like this:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@Bean, +	public DataSource dataSource() throws Exception {, +		Context ctx = new InitialContext();, +		return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");, +	}, +----, +, +The problem is how to switch between using these two variations based on the, +current environment. Over time, Spring users have devised a number of ways to, +get this done, usually relying on a combination of system environment variables, +and XML `<import/>` statements containing `${placeholder}` tokens that resolve, +to the correct configuration file path depending on the value of an environment, +variable. Bean definition profiles is a core container feature that provides a, +solution to this problem., +, +If we generalize the example use case above of environment-specific bean, +definitions, we end up with the need to register certain bean definitions in, +certain contexts, while not in others. You could say that you want to register a, +certain profile of bean definitions in situation A, and a different profile in, +situation B. Let's first see how we can update our configuration to reflect, +this need., +, +[[beans-definition-profiles-java]], +===== @Profile, +, +The {javadoc-baseurl}/org/springframework/context/annotation/Profile.html[`@Profile`], +annotation allows to indicate that a component is eligible for registration, +when one or more specified profiles are active. Using our example above, we, +can rewrite the _dataSource_ configuration as follows:, +, +[source,java,indent=0], +[subs="verbatim,quotes"], +----, +	@Configuration, +	**@Profile("dev")**, +	public class StandaloneDataConfig {, +, +		@Bean, +		public DataSource dataSource() {, +			return new EmbeddedDatabaseBuilder(), +				.setType(EmbeddedDatabaseType.HSQL), +				.addScript("classpath:com/bank/config/sql/schema.sql"), +				.addScript("classpath:com/bank/config/sql/test-data.sql"), +				.build();, +		}, +	}, +----]