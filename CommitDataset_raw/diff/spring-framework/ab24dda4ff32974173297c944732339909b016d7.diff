[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final MultiValueMap<String, ResourcePropertySource> propertySources =, +			new LinkedMultiValueMap<String, ResourcePropertySource>();, +				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);, +				Resource resource = this.resourceLoader.getResource(resolvedLocation);, +		for (Map.Entry<String, List<ResourcePropertySource>> entry : this.propertySources.entrySet()) {, +	private PropertySource<?> collatePropertySources(String name, List<ResourcePropertySource> propertySources) {, +			return propertySources.get(0).withName(name);, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final MultiValueMap<String, ResourcePropertySource> propertySources =, +			new LinkedMultiValueMap<String, ResourcePropertySource>();, +				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);, +				Resource resource = this.resourceLoader.getResource(resolvedLocation);, +		for (Map.Entry<String, List<ResourcePropertySource>> entry : this.propertySources.entrySet()) {, +	private PropertySource<?> collatePropertySources(String name, List<ResourcePropertySource> propertySources) {, +			return propertySources.get(0).withName(name);, +++ b/spring-context/src/test/java/org/springframework/context/annotation/PropertySourceAnnotationTests.java, +	@Test(expected = IllegalArgumentException.class), +	public void withEmptyResourceLocations() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithEmptyResourceLocations.class);, +		ctx.refresh();, +	}, +, +	// SPR-10820, +	public void withNamedPropertySources() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigWithNamedPropertySources.class);, +		assertThat(ctx.getEnvironment().containsProperty("from.p1"), is(true));, +		assertThat(ctx.getEnvironment().containsProperty("from.p2"), is(true));, +		// p2 should 'win' as it was registered last, +		assertThat(ctx.getEnvironment().getProperty("testbean.name"), equalTo("p2TestBean"));, +	}, +, +	@Test, +		@PropertySource("classpath:org/springframework/context/annotation/p1.properties"),, +		@PropertySource("classpath:org/springframework/context/annotation/p2.properties"),, +			@PropertySource(name = "psName", value = "classpath:org/springframework/context/annotation/p2.properties"),, +	}), +	static class ConfigWithNamedPropertySources {, +	}, +, +, +	@Configuration, +	@PropertySources({, +		@PropertySource(name = "psName", value = "classpath:org/springframework/context/annotation/p1.properties"),, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final MultiValueMap<String, ResourcePropertySource> propertySources =, +			new LinkedMultiValueMap<String, ResourcePropertySource>();, +				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);, +				Resource resource = this.resourceLoader.getResource(resolvedLocation);, +		for (Map.Entry<String, List<ResourcePropertySource>> entry : this.propertySources.entrySet()) {, +	private PropertySource<?> collatePropertySources(String name, List<ResourcePropertySource> propertySources) {, +			return propertySources.get(0).withName(name);, +++ b/spring-context/src/test/java/org/springframework/context/annotation/PropertySourceAnnotationTests.java, +	@Test(expected = IllegalArgumentException.class), +	public void withEmptyResourceLocations() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithEmptyResourceLocations.class);, +		ctx.refresh();, +	}, +, +	// SPR-10820, +	public void withNamedPropertySources() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigWithNamedPropertySources.class);, +		assertThat(ctx.getEnvironment().containsProperty("from.p1"), is(true));, +		assertThat(ctx.getEnvironment().containsProperty("from.p2"), is(true));, +		// p2 should 'win' as it was registered last, +		assertThat(ctx.getEnvironment().getProperty("testbean.name"), equalTo("p2TestBean"));, +	}, +, +	@Test, +		@PropertySource("classpath:org/springframework/context/annotation/p1.properties"),, +		@PropertySource("classpath:org/springframework/context/annotation/p2.properties"),, +			@PropertySource(name = "psName", value = "classpath:org/springframework/context/annotation/p2.properties"),, +	}), +	static class ConfigWithNamedPropertySources {, +	}, +, +, +	@Configuration, +	@PropertySources({, +		@PropertySource(name = "psName", value = "classpath:org/springframework/context/annotation/p1.properties"),, +++ b/spring-core/src/main/java/org/springframework/core/env/PropertiesPropertySource.java, + * Copyright 2002-2014 the original author or authors., + * @author Juergen Hoeller, +	protected PropertiesPropertySource(String name, Map<String, Object> source) {, +		super(name, source);, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java, +	private final MultiValueMap<String, ResourcePropertySource> propertySources =, +			new LinkedMultiValueMap<String, ResourcePropertySource>();, +				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);, +				Resource resource = this.resourceLoader.getResource(resolvedLocation);, +		for (Map.Entry<String, List<ResourcePropertySource>> entry : this.propertySources.entrySet()) {, +	private PropertySource<?> collatePropertySources(String name, List<ResourcePropertySource> propertySources) {, +			return propertySources.get(0).withName(name);, +++ b/spring-context/src/test/java/org/springframework/context/annotation/PropertySourceAnnotationTests.java, +	@Test(expected = IllegalArgumentException.class), +	public void withEmptyResourceLocations() {]