[+++ b/spring-web/src/main/java/org/springframework/http/server/reactive/RxNettyServerHttpResponse.java, +import rx.functions.Func1;, + * @author Sebastien Deleuze, +	// 8 Kb flush threshold to avoid blocking RxNetty when the send buffer has reached the high watermark, +	private static final long FLUSH_THRESHOLD = 8192;, +, +		return Flux.from(RxReactiveStreams.toPublisher(this.response.write(content, new FlushSelector(FLUSH_THRESHOLD)))), +	private class FlushSelector implements Func1<ByteBuf, Boolean> {, +, +		private final long flushEvery;, +		private long count;, +, +		public FlushSelector(long flushEvery) {, +			this.flushEvery = flushEvery;, +		}, +, +		@Override, +		public Boolean call(ByteBuf byteBuf) {, +			this.count += byteBuf.readableBytes();, +			if (this.count >= this.flushEvery) {, +				this.count = 0;, +				return true;, +			}, +			return false;, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/server/reactive/RxNettyServerHttpResponse.java, +import rx.functions.Func1;, + * @author Sebastien Deleuze, +	// 8 Kb flush threshold to avoid blocking RxNetty when the send buffer has reached the high watermark, +	private static final long FLUSH_THRESHOLD = 8192;, +, +		return Flux.from(RxReactiveStreams.toPublisher(this.response.write(content, new FlushSelector(FLUSH_THRESHOLD)))), +	private class FlushSelector implements Func1<ByteBuf, Boolean> {, +, +		private final long flushEvery;, +		private long count;, +, +		public FlushSelector(long flushEvery) {, +			this.flushEvery = flushEvery;, +		}, +, +		@Override, +		public Boolean call(ByteBuf byteBuf) {, +			this.count += byteBuf.readableBytes();, +			if (this.count >= this.flushEvery) {, +				this.count = 0;, +				return true;, +			}, +			return false;, +		}, +	}, +, +++ b/spring-web/src/test/java/org/springframework/http/server/reactive/FlushingIntegrationTests.java, +import java.nio.charset.StandardCharsets;, +import org.springframework.core.io.buffer.DataBufferFactory;, +import org.springframework.util.Assert;, +	public void writeAndFlushWith() throws Exception {, +		ClientRequest<Void> request = ClientRequest.GET("http://localhost:" + port + "/write-and-flush").build();, +	@Test  // SPR-14991, +	public void writeAndAutoFlushOnComplete() {, +		ClientRequest<Void> request = ClientRequest.GET("http://localhost:" + port + "/write-and-complete").build();, +		Mono<String> result = this.webClient, +				.exchange(request), +				.flatMap(response -> response.bodyToFlux(String.class)), +				.reduce((s1, s2) -> s1 + s2);, +, +		StepVerifier.create(result), +				.consumeNextWith(value -> Assert.isTrue(value.length() == 200000)), +				.expectComplete(), +				.verify();, +	}, +, +			String path = request.getURI().getPath();, +			if (path.endsWith("write-and-flush")) {, +						.map(l -> toDataBuffer("data" + l, response.bufferFactory())), +			else if (path.endsWith("write-and-complete")){, +				Flux<DataBuffer> responseBody = Flux, +						.just("0123456789"), +						.repeat(20000), +						.map(value -> toDataBuffer(value, response.bufferFactory()));, +				return response.writeWith(responseBody);, +			}, +			return response.writeWith(Flux.empty());, +		}, +, +		private DataBuffer toDataBuffer(String value, DataBufferFactory factory) {, +			byte[] data = (value).getBytes(StandardCharsets.UTF_8);, +			DataBuffer buffer = factory.allocateBuffer(data.length);, +			buffer.write(data);, +			return buffer;, +		}, +]