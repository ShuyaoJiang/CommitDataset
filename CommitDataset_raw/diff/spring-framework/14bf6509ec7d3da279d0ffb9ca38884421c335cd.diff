[+++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, +	private final Map<MethodClassKey, Object> cache = new ConcurrentHashMap<MethodClassKey, Object>(1024);, +		MethodClassKey cacheKey = new MethodClassKey(method, targetClass);, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, +	private final Map<MethodClassKey, Object> cache = new ConcurrentHashMap<MethodClassKey, Object>(1024);, +		MethodClassKey cacheKey = new MethodClassKey(method, targetClass);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/AbstractFallbackCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, + * Abstract implementation of {@link CacheOperation} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. target class; 3. declaring method; 4. declaring class/interface., + * associated with the target method. Any caching attribute associated with, + * the target method completely overrides a class caching attribute., + * If none found on the target class, the interface that the invoked method, + * has been called through (in case of a JDK proxy) will be checked., + * <p>This implementation caches attributes by method after they are first, + * used. If it is ever desirable to allow dynamic changing of cacheable, + * attributes (which is very unlikely), caching could be made configurable., +	 * Cache of CacheOperations, keyed by method on a specific target class., +		return new MethodClassKey(method, targetClass);, +		if (opDef != null && ClassUtils.isUserLevelMethod(method)) {, +			opDef = findCacheOperations(method.getDeclaringClass());, +			if (opDef != null && ClassUtils.isUserLevelMethod(method)) {, +				return opDef;, +		}, +, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, +	private final Map<MethodClassKey, Object> cache = new ConcurrentHashMap<MethodClassKey, Object>(1024);, +		MethodClassKey cacheKey = new MethodClassKey(method, targetClass);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/AbstractFallbackCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, + * Abstract implementation of {@link CacheOperation} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. target class; 3. declaring method; 4. declaring class/interface., + * associated with the target method. Any caching attribute associated with, + * the target method completely overrides a class caching attribute., + * If none found on the target class, the interface that the invoked method, + * has been called through (in case of a JDK proxy) will be checked., + * <p>This implementation caches attributes by method after they are first, + * used. If it is ever desirable to allow dynamic changing of cacheable, + * attributes (which is very unlikely), caching could be made configurable., +	 * Cache of CacheOperations, keyed by method on a specific target class., +		return new MethodClassKey(method, targetClass);, +		if (opDef != null && ClassUtils.isUserLevelMethod(method)) {, +			opDef = findCacheOperations(method.getDeclaringClass());, +			if (opDef != null && ClassUtils.isUserLevelMethod(method)) {, +				return opDef;, +		}, +, +++ b/spring-context/src/main/java/org/springframework/context/expression/CachedExpressionEvaluator.java, +	protected static class ExpressionKey implements Comparable<ExpressionKey> {, +		private final AnnotatedElementKey element;, +		protected ExpressionKey(AnnotatedElementKey element, String expression) {, +			this.element = element;, +			return (this.element.equals(otherKey.element) &&, +			return this.element.hashCode() + (this.expression != null ? this.expression.hashCode() * 29 : 0);, +		}, +, +		@Override, +		public String toString() {, +			return this.element + (this.expression != null ? " with expression \"" + this.expression : "\"");, +		}, +, +		@Override, +		public int compareTo(ExpressionKey other) {, +			int result = this.element.toString().compareTo(other.element.toString());, +			if (result == 0 && this.expression != null) {, +				result = this.expression.compareTo(other.expression);, +			}, +			return result;, +++ b/spring-context-support/src/main/java/org/springframework/cache/jcache/interceptor/AbstractFallbackJCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, +	private final Map<MethodClassKey, Object> cache = new ConcurrentHashMap<MethodClassKey, Object>(1024);, +		MethodClassKey cacheKey = new MethodClassKey(method, targetClass);, +++ b/spring-context/src/main/java/org/springframework/cache/interceptor/AbstractFallbackCacheOperationSource.java, + * Copyright 2002-2016 the original author or authors., +import org.springframework.core.MethodClassKey;, + * Abstract implementation of {@link CacheOperation} that caches attributes, + * for methods and implements a fallback policy: 1. specific target method;, + * 2. target class; 3. declaring method; 4. declaring class/interface., + * associated with the target method. Any caching attribute associated with, + * the target method completely overrides a class caching attribute., + * If none found on the target class, the interface that the invoked method, + * has been called through (in case of a JDK proxy) will be checked., + * <p>This implementation caches attributes by method after they are first, + * used. If it is ever desirable to allow dynamic changing of cacheable, + * attributes (which is very unlikely), caching could be made configurable., +	 * Cache of CacheOperations, keyed by method on a specific target class., +		return new MethodClassKey(method, targetClass);, +		if (opDef != null && ClassUtils.isUserLevelMethod(method)) {, +			opDef = findCacheOperations(method.getDeclaringClass());]