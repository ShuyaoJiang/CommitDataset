[+++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractServerSockJsSession.java, +		Assert.notNull(getSockJsConfig().getTaskScheduler(), "heartbeatScheduler not configured");, +		this.heartbeatTask = getSockJsConfig().getTaskScheduler().schedule(new Runnable() {, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractServerSockJsSession.java, +		Assert.notNull(getSockJsConfig().getTaskScheduler(), "heartbeatScheduler not configured");, +		this.heartbeatTask = getSockJsConfig().getTaskScheduler().schedule(new Runnable() {, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractSockJsService.java, +public abstract class AbstractSockJsService implements SockJsService, SockJsConfiguration {, +	private final TaskScheduler taskScheduler;, +	public AbstractSockJsService(TaskScheduler scheduler) {, +		Assert.notNull(scheduler, "scheduler is required");, +		this.taskScheduler = scheduler;, +	public TaskScheduler getTaskScheduler() {, +		return this.taskScheduler;, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractServerSockJsSession.java, +		Assert.notNull(getSockJsConfig().getTaskScheduler(), "heartbeatScheduler not configured");, +		this.heartbeatTask = getSockJsConfig().getTaskScheduler().schedule(new Runnable() {, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractSockJsService.java, +public abstract class AbstractSockJsService implements SockJsService, SockJsConfiguration {, +	private final TaskScheduler taskScheduler;, +	public AbstractSockJsService(TaskScheduler scheduler) {, +		Assert.notNull(scheduler, "scheduler is required");, +		this.taskScheduler = scheduler;, +	public TaskScheduler getTaskScheduler() {, +		return this.taskScheduler;, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/SockJsConfiguration.java, +	 * A scheduler instance to use for scheduling heart-beat messages., +	public TaskScheduler getTaskScheduler();, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractServerSockJsSession.java, +		Assert.notNull(getSockJsConfig().getTaskScheduler(), "heartbeatScheduler not configured");, +		this.heartbeatTask = getSockJsConfig().getTaskScheduler().schedule(new Runnable() {, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/AbstractSockJsService.java, +public abstract class AbstractSockJsService implements SockJsService, SockJsConfiguration {, +	private final TaskScheduler taskScheduler;, +	public AbstractSockJsService(TaskScheduler scheduler) {, +		Assert.notNull(scheduler, "scheduler is required");, +		this.taskScheduler = scheduler;, +	public TaskScheduler getTaskScheduler() {, +		return this.taskScheduler;, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/SockJsConfiguration.java, +	 * A scheduler instance to use for scheduling heart-beat messages., +	public TaskScheduler getTaskScheduler();, +++ b/spring-websocket/src/main/java/org/springframework/sockjs/server/support/DefaultSockJsService.java, +import java.util.Collection;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import java.util.concurrent.ScheduledFuture;, +import org.springframework.util.CollectionUtils;, +	private ScheduledFuture sessionCleanupTask;, +, +	public DefaultSockJsService(TaskScheduler taskScheduler) {, +		this(taskScheduler, null);, +	public DefaultSockJsService(TaskScheduler taskScheduler, Set<TransportHandler> transportHandlers,, +			TransportHandler... transportHandlerOverrides) {, +, +		super(taskScheduler);, +, +		transportHandlers = CollectionUtils.isEmpty(transportHandlers) ? getDefaultTransportHandlers() : transportHandlers;, +		addTransportHandlers(transportHandlers);, +		addTransportHandlers(Arrays.asList(transportHandlerOverrides));, +	protected Set<TransportHandler> getDefaultTransportHandlers() {, +		Set<TransportHandler> result = new HashSet<TransportHandler>();, +		result.add(new XhrPollingTransportHandler());, +		result.add(new XhrTransportHandler());, +		result.add(new JsonpPollingTransportHandler());, +		result.add(new JsonpTransportHandler());, +		result.add(new XhrStreamingTransportHandler());, +		result.add(new EventSourceTransportHandler());, +		result.add(new HtmlFileTransportHandler());, +		if (isWebSocketEnabled()) {, +			try {, +				result.add(new WebSocketTransportHandler(new DefaultHandshakeHandler()));, +			}, +			catch (Exception ex) {, +				if (logger.isWarnEnabled()) {, +					logger.warn("Failed to add default WebSocketTransportHandler: " + ex.getMessage());, +				}, +			}, +		}, +		return result;, +	}, +, +	protected void addTransportHandlers(Collection<TransportHandler> handlers) {, +			if (handler instanceof ConfigurableTransportHandler) {, +				((ConfigurableTransportHandler) handler).setSockJsConfiguration(this);, +			}, +	public Map<TransportType, TransportHandler> getTransportHandlers() {, +		return Collections.unmodifiableMap(this.transportHandlers);, +				if (this.sessionCleanupTask == null) {, +					scheduleSessionTask();, +				}, +	private void scheduleSessionTask() {, +		this.sessionCleanupTask = getTaskScheduler().scheduleAtFixedRate(new Runnable() {, +			public void run() {, +				try {, +					int count = sessions.size();, +					if (logger.isTraceEnabled() && (count != 0)) {, +						logger.trace("Checking " + count + " session(s) for timeouts [" + getName() + "]");, +					}]