[+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java, + * @param <T> A type containing request mapping conditions required to match a request to a {@link HandlerMethod}., +	 * <p>The actual mapping for a handler is up to the concrete {@link #getMappingForMethod(String, Method)}, +				return getMappingForMethod(beanName, method) != null;, +			T mapping = getMappingForMethod(beanName, method);, +	 * Provides a request mapping for the given bean method. A method for which no request mapping can be determined , +	 * is not considered a handler method., +	 * @return the mapping, or {@code null} if the method is not mapped, +	protected abstract T getMappingForMethod(String beanName, Method method);, +	 * @param mapping the mapping for the method, +	protected void registerHandlerMethod(Set<String> paths, T mapping, HandlerMethod handlerMethod) {, +		Assert.notNull(mapping, "'mapping' must not be null");, +		HandlerMethod mappedHandlerMethod = handlerMethods.get(mapping);, +					+ "' bean method \n" + handlerMethod + "\nto " + mapping + ": There is already '", +		handlerMethods.put(mapping, handlerMethod);, +			logger.info("Mapped \"" + mapping + "\" onto " + handlerMethod);, +			urlMap.add(path, mapping);, +	protected abstract Set<String> getMappingPaths(T mapping);, +	 * <p>This implementation iterators through all handler methods, calls , +	 * {@link #getMatchingMapping(Object, String, HttpServletRequest)} for each of them, , +	 * sorts all matches via {@linkplain #getMappingComparator(String, HttpServletRequest)} , and returns the , +	 * top match, if any. If no matches are found, {@link #handleNoMatch(Set, HttpServletRequest)} is invoked., +		List<T> mappings = urlMap.get(lookupPath);, +		if (mappings == null) {, +			mappings = new ArrayList<T>(handlerMethods.keySet());, +		for (T mapping : mappings) {, +			T match = getMatchingMapping(mapping, lookupPath, request);, +				matches.add(new Match(match, handlerMethods.get(mapping)));, +			Comparator<Match> comparator = new MatchComparator(getMappingComparator(lookupPath, request));, +			handleMatch(bestMatch.mapping, lookupPath, request);, +	 * @param mapping the mapping selected for the request returned by , +	 * {@link #getMatchingMapping(Object, String, HttpServletRequest)}., +	protected void handleMatch(T mapping, String lookupPath, HttpServletRequest request) {, +	 * @param mapping the mapping to get a match for, +	protected abstract T getMatchingMapping(T mapping, String lookupPath, HttpServletRequest request);, +	 * Returns a comparator to sort request mappings with. The returned comparator should sort 'better' matches higher., +	protected abstract Comparator<T> getMappingComparator(String lookupPath, HttpServletRequest request);, +	 * @param mappings all registered request mappings, +	protected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request), +		private final T mapping;, +			this.mapping = mapping;, +			return mapping.toString();, +			return comparator.compare(match1.mapping, match2.mapping);, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java, + * @param <T> A type containing request mapping conditions required to match a request to a {@link HandlerMethod}., +	 * <p>The actual mapping for a handler is up to the concrete {@link #getMappingForMethod(String, Method)}, +				return getMappingForMethod(beanName, method) != null;, +			T mapping = getMappingForMethod(beanName, method);, +	 * Provides a request mapping for the given bean method. A method for which no request mapping can be determined , +	 * is not considered a handler method., +	 * @return the mapping, or {@code null} if the method is not mapped, +	protected abstract T getMappingForMethod(String beanName, Method method);, +	 * @param mapping the mapping for the method, +	protected void registerHandlerMethod(Set<String> paths, T mapping, HandlerMethod handlerMethod) {, +		Assert.notNull(mapping, "'mapping' must not be null");, +		HandlerMethod mappedHandlerMethod = handlerMethods.get(mapping);, +					+ "' bean method \n" + handlerMethod + "\nto " + mapping + ": There is already '", +		handlerMethods.put(mapping, handlerMethod);, +			logger.info("Mapped \"" + mapping + "\" onto " + handlerMethod);, +			urlMap.add(path, mapping);, +	protected abstract Set<String> getMappingPaths(T mapping);, +	 * <p>This implementation iterators through all handler methods, calls , +	 * {@link #getMatchingMapping(Object, String, HttpServletRequest)} for each of them, , +	 * sorts all matches via {@linkplain #getMappingComparator(String, HttpServletRequest)} , and returns the , +	 * top match, if any. If no matches are found, {@link #handleNoMatch(Set, HttpServletRequest)} is invoked., +		List<T> mappings = urlMap.get(lookupPath);, +		if (mappings == null) {, +			mappings = new ArrayList<T>(handlerMethods.keySet());, +		for (T mapping : mappings) {, +			T match = getMatchingMapping(mapping, lookupPath, request);, +				matches.add(new Match(match, handlerMethods.get(mapping)));, +			Comparator<Match> comparator = new MatchComparator(getMappingComparator(lookupPath, request));, +			handleMatch(bestMatch.mapping, lookupPath, request);, +	 * @param mapping the mapping selected for the request returned by , +	 * {@link #getMatchingMapping(Object, String, HttpServletRequest)}., +	protected void handleMatch(T mapping, String lookupPath, HttpServletRequest request) {, +	 * @param mapping the mapping to get a match for, +	protected abstract T getMatchingMapping(T mapping, String lookupPath, HttpServletRequest request);, +	 * Returns a comparator to sort request mappings with. The returned comparator should sort 'better' matches higher., +	protected abstract Comparator<T> getMappingComparator(String lookupPath, HttpServletRequest request);, +	 * @param mappings all registered request mappings, +	protected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request), +		private final T mapping;, +			this.mapping = mapping;, +			return mapping.toString();, +			return comparator.compare(match1.mapping, match2.mapping);, +++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMethodMapping.java, + * An {@link AbstractHandlerMethodMapping} variant that uses {@link RequestMappingInfo}s for the registration and , +public class RequestMappingHandlerMethodMapping extends AbstractHandlerMethodMapping<RequestMappingInfo> {, +	 * Provides a {@link RequestMappingInfo} for the given method. , +	 * @param method the method to create a mapping for, +	 * @return the mapping, or {@code null}, +	 * @see RequestMappingInfo#combine(RequestMappingInfo, PathMatcher), +	protected RequestMappingInfo getMappingForMethod(String beanName, Method method) {, +			RequestMappingInfo methodMapping = createFromRequestMapping(annotation);, +				RequestMappingInfo typeMapping = createFromRequestMapping(typeAnnot);, +				return typeMapping.combine(methodMapping, pathMatcher);, +				return methodMapping;, +	private static RequestMappingInfo createFromRequestMapping(RequestMapping annotation) {, +		return new RequestMappingInfo(Arrays.asList(annotation.value()), Arrays.asList(annotation.method()),]