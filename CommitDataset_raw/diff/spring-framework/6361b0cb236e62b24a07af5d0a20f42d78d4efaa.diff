[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, +import java.nio.CharBuffer;, +import java.nio.charset.Charset;, +import java.nio.charset.CharsetEncoder;, +import java.nio.charset.CoderResult;, +import java.nio.charset.CodingErrorAction;, +import org.springframework.util.Assert;, +, + * @author Brian Clozel, +	 * Ensure that the current buffer has enough {@link #writableByteCount()}, +	 * to write the amount of data given as an argument. If not, the missing, +	 * capacity will be added to the buffer., +	 * @param capacity the writable capacity to check for, +	 * @return this buffer, +	 * @since 5.1.4, +	 */, +	DataBuffer ensureCapacity(int capacity);, +, +	/**, +	 * Write the given source into this buffer, starting at the current writing position, +	 * Write the given {@code CharSequence} using the given {@code Charset},, +	 * starting at the current writing position., +	 * @param charSequence the char sequence to write into this buffer, +	 * @param charset the charset to encode the char sequence with, +	 * @return this buffer, +	 * @since 5.1.4, +	 */, +	default DataBuffer write(CharSequence charSequence, Charset charset) {, +		Assert.notNull(charSequence, "'charSequence' must not be null");, +		Assert.notNull(charset, "'charset' must not be null");, +		CharsetEncoder charsetEncoder = charset.newEncoder(), +				.onMalformedInput(CodingErrorAction.REPLACE), +				.onUnmappableCharacter(CodingErrorAction.REPLACE);, +		CharBuffer inBuffer = CharBuffer.wrap(charSequence);, +		int estimatedSize = (int) (inBuffer.remaining() * charsetEncoder.averageBytesPerChar());, +		ByteBuffer outBuffer = ensureCapacity(estimatedSize), +				.asByteBuffer(writePosition(), writableByteCount());, +		for (; ; ) {, +			CoderResult cr = inBuffer.hasRemaining() ?, +					charsetEncoder.encode(inBuffer, outBuffer, true) : CoderResult.UNDERFLOW;, +			if (cr.isUnderflow()) {, +				cr = charsetEncoder.flush(outBuffer);, +			}, +			if (cr.isUnderflow()) {, +				break;, +			}, +			if (cr.isOverflow()) {, +				writePosition(outBuffer.position());, +				int maximumSize = (int) (inBuffer.remaining() * charsetEncoder.maxBytesPerChar());, +				ensureCapacity(maximumSize);, +				outBuffer = asByteBuffer(writePosition(), writableByteCount());, +			}, +		}, +		writePosition(outBuffer.position());, +		return this;, +	}, +, +	/**, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, +import java.nio.CharBuffer;, +import java.nio.charset.Charset;, +import java.nio.charset.CharsetEncoder;, +import java.nio.charset.CoderResult;, +import java.nio.charset.CodingErrorAction;, +import org.springframework.util.Assert;, +, + * @author Brian Clozel, +	 * Ensure that the current buffer has enough {@link #writableByteCount()}, +	 * to write the amount of data given as an argument. If not, the missing, +	 * capacity will be added to the buffer., +	 * @param capacity the writable capacity to check for, +	 * @return this buffer, +	 * @since 5.1.4, +	 */, +	DataBuffer ensureCapacity(int capacity);, +, +	/**, +	 * Write the given source into this buffer, starting at the current writing position, +	 * Write the given {@code CharSequence} using the given {@code Charset},, +	 * starting at the current writing position., +	 * @param charSequence the char sequence to write into this buffer, +	 * @param charset the charset to encode the char sequence with, +	 * @return this buffer, +	 * @since 5.1.4, +	 */, +	default DataBuffer write(CharSequence charSequence, Charset charset) {, +		Assert.notNull(charSequence, "'charSequence' must not be null");, +		Assert.notNull(charset, "'charset' must not be null");, +		CharsetEncoder charsetEncoder = charset.newEncoder(), +				.onMalformedInput(CodingErrorAction.REPLACE), +				.onUnmappableCharacter(CodingErrorAction.REPLACE);, +		CharBuffer inBuffer = CharBuffer.wrap(charSequence);, +		int estimatedSize = (int) (inBuffer.remaining() * charsetEncoder.averageBytesPerChar());, +		ByteBuffer outBuffer = ensureCapacity(estimatedSize), +				.asByteBuffer(writePosition(), writableByteCount());, +		for (; ; ) {, +			CoderResult cr = inBuffer.hasRemaining() ?, +					charsetEncoder.encode(inBuffer, outBuffer, true) : CoderResult.UNDERFLOW;, +			if (cr.isUnderflow()) {, +				cr = charsetEncoder.flush(outBuffer);]