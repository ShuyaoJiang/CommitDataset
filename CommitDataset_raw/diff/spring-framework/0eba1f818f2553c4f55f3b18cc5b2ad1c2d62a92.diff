[+++ b/src/asciidoc/index.adoc, +  JCA aware ++ApplicationContext++s, +in which these ++BeanPostProcessor++s execute by setting the `order` property. You can, +++BeanPostProcessor++s operate on bean (or object) __instances__; that is to say, the, +Spring IoC container instantiates a bean instance and __then__ ++BeanPostProcessor++s do, +++BeanPostProcessor++s are scoped __per-container__. This is only relevant if you are, +As with ++BeanPostProcessor++s , you typically do not want to configure, +++BeanFactoryPostProcessor++s for lazy initialization. If no other bean references a, +populated; this allows for eager and explicit failure, avoiding ++NullPointerException++s, +++BeanDefinition++s with the `ApplicationContext`. For example, the following two classes, +CGLIB proxying is the means by which invoking methods or fields within `@Bean` methods , +in `@Configuration` classes creates bean metadata references to collaborating objects;, +such methods are __not__ invoked with normal Java semantics. In contrast, invoking a, +method or field in an `@Bean` method within a `@Component` class __has__ standard Java, +semantics., +When ++@Bean++s have dependencies on one another, expressing that dependency is as simple, +An application context is a `ResourceLoader`, which can be used to load ++Resource++s. A, +"META-INF/ra.xml" deployment descriptor (as shown in ++SpringContextResourceAdapter++'s, +The following table summarizes the strategy for converting ++String++s to ++Resource++s:, +support for declaratively validating `@Controller` inputs., +`@Controller` inputs. In previous versions it was up to the developer to manually invoke, +To trigger validation of a `@Controller` input, simply annotate the input argument as, +++@Valid++:, +The `Validator` instance invoked when a `@Valid` method argument is encountered may be, +configured in two ways. First, you may call `binder.setValidator(Validator)` within a, +++@Controller++'s `@InitBinder` callback. This allows you to configure a `Validator`, +instance per `@Controller` class:, +Second, you may call `setValidator(Validator)` on the global `WebBindingInitializer`. This, +allows you to configure a `Validator` instance across all `@Controller` classes. This can be, +With this minimal configuration, anytime a `@Valid` `@Controller` input is encountered, it, +any constraints declared against the input. Any ++ConstraintViolation++s will automatically, +be exposed as errors in the `BindingResult` renderable by standard Spring MVC form tags., +++ConstructorResolver++s, ++MethodResolver++s, and ++PropertyAccessor++s to extend how SpEL, +SpEL expressions can be used with XML or annotation-based configuration metadata for, +defining ++BeanDefinition++s. In both cases the syntax to define the expression is of the, +A property or constructor-arg value can be set using expressions as shown below., +The variable `systemProperties` is predefined, so you can use it in your expressions as, +shown below. Note that you do not have to prefix the predefined variable with the `#`, +Navigating with property references is easy: just use a period to indicate a nested, +property value. The instances of the `Inventor` class, pupin, and tesla, were populated with, +Lists can be expressed directly in an expression using `{}` notation., +`{}` by itself means an empty list. For performance reasons, if the list is itself, +In addition to standard relational operators SpEL supports the `instanceof` and regular, +expression based `matches` operator., +shown here: `lt` (`<`), `gt` (`>`), `le` (`<=`), `ge` (`>=`), `eq` (`==`),, +`ne` (`!=`), `div` (`/`), `mod` (`%`), `not` (`!`). These are case insensitive., +The special `T` operator can be used to specify an instance of java.lang.Class (the, +_type_). Static methods are invoked using this operator as well. The, +Variables can be referenced in the expression using the syntax `#variableName`. Variables, +are set using the method setVariable on the `StandardEvaluationContext`., +an execution join point both '++this++' and '++target++' refer to the same object - the, +between the proxy object itself (bound to '++this++') and the target object behind the, +proxy (bound to '++target++')., +Spring AOP also supports an additional PCD named '++bean++'. This PCD allows you to limit, +Spring beans (when using wildcards). The '++bean++' PCD has the following form:, +The '++idOrNameOfBean++' token can be the name of any Spring bean: limited wildcard, +support using the '++*++' character is provided, so if you establish some naming, +conventions for your Spring beans you can quite easily write a '++bean++' PCD expression, +to pick them out. As is the case with other pointcut designators, the '++bean++' PCD can, +Please note that the '++bean++' PCD is __only__ supported in Spring AOP - and __not__ in, +The '++bean++' PCD operates at the __instance__ level (building on the Spring bean name, +* any join point (method execution only in Spring AOP) on a Spring bean named, +  '++tradeService++':, +  match the wildcard expression '++*Service++':, +The downside of the XML approach is that you cannot define the, +'++accountPropertyAccess++' pointcut by combining these definitions., +To be clear: using '++proxy-target-class="true"++' on `<tx:annotation-driven/>`,, +all. To have Spring apply autowiring use the '++autowire++' property of the, +the '++new++' operator) as well as to `Serializable` objects that are undergoing, +aspects via Spring depends on the AspectJ instantiation model (the '++per-xxx++' clause), +We will also need to create an '++META-INF/aop.xml++' file, to inform the AspectJ weaver, +namely the presence of a file (or files) on the Java classpath called, +'++META-INF/aop.xml++' is standard AspectJ., +one or more '++META-INF/aop.xml++' files into the classes in your application. The good, +Now that all the required artifacts are in place - the aspect, the '++META-INF/aop.xml++', +The '++-javaagent++' is a flag for specifying and enabling, +The AspectJ LTW infrastructure is configured using one or more '++META-INF/aop.xml++', +that resource]. (I appreciate that this section is brief, but the '++aop.xml++' file is, +`<context:load-time-weaver/>` element. Note that the element is defined in the, +'++context++' namespace., +as the value of the '++weaver-class++' attribute on the `<context:load-time-weaver/>`, +retrieved from the Spring container using the well-known name '++loadTimeWeaver++'., +There is one final attribute of the configuration left to discuss: the, +'++aspectjWeaving++' attribute (or '++aspectj-weaving++' if you are using XML). This is a, +simple attribute that controls whether LTW is enabled or not; it is as simple as that., +It accepts one of three possible values, summarized below, with the default value being, +'++autodetect++' if the attribute is not present., +| If the Spring LTW infrastructure can find at least one '++META-INF/aop.xml++' file,, +applications. If, for example, JDBC ++DataSource++s get bound to the same JNDI names in, +To test your Spring MVC ++Controller++s, use `ModelAndViewAssert` combined with, +++ApplicationContext++s and ++WebApplicationContext++s as well as caching of those, +transactional proxies, ++DataSource++s, etc.), thus avoiding the need to duplicate, +A class-level annotation that is used to define a hierarchy of ++ApplicationContext++s, +++ApplicationContext++s that reside in a sub-hierarchy of the common ancestor context, +Defines class-level metadata for configuring which ++TestExecutionListener++s should be, +of the `TestContext` as the test progresses and delegates to ++TestExecutionListener++s,, +  ++TestExecutionListener++s at well-defined test execution points:, +beneficial or even necessary to test against a hierarchy of ++ApplicationContext++s. For, +++ContextConfiguration++'s `inheritLocations` flag to `false`. Consequently, the, +++Error++s will also - by default - result in a rollback). Checked exceptions that are]