[+++ b/spring-web/src/main/java/org/springframework/http/codec/BodyExtractors.java, +import org.springframework.core.io.buffer.DataBuffer;, +		return (inputMessage, context) -> readWithMessageReaders(inputMessage, context,, +				reader -> reader.read(elementType, inputMessage, Collections.emptyMap()),, +	/**, +	 * Return a {@code BodyExtractor} that returns the body of the message as a {@link Flux} of, +	 * {@link DataBuffer}s., +	 * <p><strong>Note</strong> that the returned buffers should be released after usage by calling, +	 * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, +	 * @return a {@code BodyExtractor} that returns the body, +	 * @see ReactiveHttpInputMessage#getBody(), +	 */, +	public static BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> toDataBuffers() {, +		return (inputMessage, context) -> inputMessage.getBody();, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/BodyExtractors.java, +import org.springframework.core.io.buffer.DataBuffer;, +		return (inputMessage, context) -> readWithMessageReaders(inputMessage, context,, +				reader -> reader.read(elementType, inputMessage, Collections.emptyMap()),, +	/**, +	 * Return a {@code BodyExtractor} that returns the body of the message as a {@link Flux} of, +	 * {@link DataBuffer}s., +	 * <p><strong>Note</strong> that the returned buffers should be released after usage by calling, +	 * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, +	 * @return a {@code BodyExtractor} that returns the body, +	 * @see ReactiveHttpInputMessage#getBody(), +	 */, +	public static BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> toDataBuffers() {, +		return (inputMessage, context) -> inputMessage.getBody();, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/BodyInserters.java, +import org.springframework.core.io.buffer.DataBuffer;, +				(outputMessage, context) -> {, +							MediaType.TEXT_EVENT_STREAM, outputMessage, Collections.emptyMap());, +	/**, +	 * Return a {@code BodyInserter} that writes the given {@code Publisher<DataBuffer>} to the, +	 * body., +	 * @param publisher the data buffer publisher to write, +	 * @param <T> the type of the publisher, +	 * @return a {@code BodyInserter} that writes directly to the body, +	 * @see ReactiveHttpOutputMessage#writeWith(Publisher), +	 */, +	public static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromDataBuffers(T publisher) {, +		Assert.notNull(publisher, "'publisher' must not be null");, +, +		return BodyInserter.of(, +				(outputMessage, context) -> outputMessage.writeWith(publisher),, +				() -> publisher, +		);, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/BodyExtractors.java, +import org.springframework.core.io.buffer.DataBuffer;, +		return (inputMessage, context) -> readWithMessageReaders(inputMessage, context,, +				reader -> reader.read(elementType, inputMessage, Collections.emptyMap()),, +	/**, +	 * Return a {@code BodyExtractor} that returns the body of the message as a {@link Flux} of, +	 * {@link DataBuffer}s., +	 * <p><strong>Note</strong> that the returned buffers should be released after usage by calling, +	 * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}, +	 * @return a {@code BodyExtractor} that returns the body, +	 * @see ReactiveHttpInputMessage#getBody(), +	 */, +	public static BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> toDataBuffers() {, +		return (inputMessage, context) -> inputMessage.getBody();, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/codec/BodyInserters.java, +import org.springframework.core.io.buffer.DataBuffer;, +				(outputMessage, context) -> {, +							MediaType.TEXT_EVENT_STREAM, outputMessage, Collections.emptyMap());, +	/**, +	 * Return a {@code BodyInserter} that writes the given {@code Publisher<DataBuffer>} to the, +	 * body., +	 * @param publisher the data buffer publisher to write, +	 * @param <T> the type of the publisher, +	 * @return a {@code BodyInserter} that writes directly to the body, +	 * @see ReactiveHttpOutputMessage#writeWith(Publisher), +	 */, +	public static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromDataBuffers(T publisher) {, +		Assert.notNull(publisher, "'publisher' must not be null");, +, +		return BodyInserter.of(, +				(outputMessage, context) -> outputMessage.writeWith(publisher),, +				() -> publisher, +		);, +	}, +, +++ b/spring-web/src/test/java/org/springframework/http/codec/BodyExtractorsTests.java, +				return Stream::empty;, +	@Test, +	public void toDataBuffers() throws Exception {, +		BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> extractor = BodyExtractors.toDataBuffers();, +, +		DefaultDataBufferFactory factory = new DefaultDataBufferFactory();, +		DefaultDataBuffer dataBuffer =, +				factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8)));, +		Flux<DataBuffer> body = Flux.just(dataBuffer);]