[+++ b/org.springframework.context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2011 the original author or authors., +import org.springframework.validation.BindingResult;, +import org.springframework.validation.ObjectError;, +					String errorCode = violation.getConstraintDescriptor().getAnnotation().annotationType().getSimpleName();, +					Object[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, violation.getConstraintDescriptor());, +					if (errors instanceof BindingResult) {, +						// can do custom FieldError registration with invalid value from ConstraintViolation,, +						// as necessary for Hibernate Validator compatibility (non-indexed set path in field), +						BindingResult bindingResult = (BindingResult) errors;, +						String[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field);, +						String nestedField = bindingResult.getNestedPath() + field;, +						ObjectError error;, +						if ("".equals(nestedField)) {, +							error = new ObjectError(, +									errors.getObjectName(), errorCodes, errorArgs, violation.getMessage());, +						}, +						else {, +							error = new FieldError(, +									errors.getObjectName(), nestedField, violation.getInvalidValue(), false,, +									errorCodes, errorArgs, violation.getMessage());, +						}, +						bindingResult.addError(error);, +					}, +					else {, +						// got no BindingResult - can only do standard rejectValue call, +						// with automatic extraction of the current field value, +						errors.rejectValue(field, errorCode, errorArgs, violation.getMessage());, +					}, +++ b/org.springframework.context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java, + * Copyright 2002-2011 the original author or authors., +import org.springframework.validation.BindingResult;, +import org.springframework.validation.ObjectError;, +					String errorCode = violation.getConstraintDescriptor().getAnnotation().annotationType().getSimpleName();, +					Object[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, violation.getConstraintDescriptor());, +					if (errors instanceof BindingResult) {, +						// can do custom FieldError registration with invalid value from ConstraintViolation,, +						// as necessary for Hibernate Validator compatibility (non-indexed set path in field), +						BindingResult bindingResult = (BindingResult) errors;, +						String[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field);, +						String nestedField = bindingResult.getNestedPath() + field;, +						ObjectError error;, +						if ("".equals(nestedField)) {, +							error = new ObjectError(, +									errors.getObjectName(), errorCodes, errorArgs, violation.getMessage());, +						}, +						else {, +							error = new FieldError(, +									errors.getObjectName(), nestedField, violation.getInvalidValue(), false,, +									errorCodes, errorArgs, violation.getMessage());, +						}, +						bindingResult.addError(error);, +					}, +					else {, +						// got no BindingResult - can only do standard rejectValue call, +						// with automatic extraction of the current field value, +						errors.rejectValue(field, errorCode, errorArgs, violation.getMessage());, +					}, +++ b/org.springframework.context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java, +import java.util.LinkedHashSet;, +import java.util.LinkedList;, +import java.util.List;, +import static org.junit.Assert.*;, +, +		ObjectError globalError = result.getGlobalError();, +		System.out.println(Arrays.asList(globalError.getCodes()));, +		System.out.println(globalError.getDefaultMessage());, +	}, +, +	@Test, +	public void testSpringValidationWithErrorInListElement() throws Exception {, +		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();, +		validator.afterPropertiesSet();, +		ValidPerson person = new ValidPerson();, +		person.getAddressList().add(new ValidAddress());, +		BeanPropertyBindingResult result = new BeanPropertyBindingResult(person, "person");, +		validator.validate(person, result);, +		assertEquals(3, result.getErrorCount());, +		FieldError fieldError = result.getFieldError("name");, +		assertEquals("name", fieldError.getField());, +		System.out.println(Arrays.asList(fieldError.getCodes()));, +		System.out.println(fieldError.getDefaultMessage());, +		fieldError = result.getFieldError("address.street");, +		assertEquals("address.street", fieldError.getField());, +		System.out.println(Arrays.asList(fieldError.getCodes()));, +		System.out.println(fieldError.getDefaultMessage());, +		fieldError = result.getFieldError("addressList[0].street");, +		assertEquals("addressList[0].street", fieldError.getField());, +		System.out.println(Arrays.asList(fieldError.getCodes()));, +		System.out.println(fieldError.getDefaultMessage());, +	}, +, +	@Test, +	public void testSpringValidationWithErrorInSetElement() throws Exception {, +		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();, +		validator.afterPropertiesSet();, +		ValidPerson person = new ValidPerson();, +		person.getAddressSet().add(new ValidAddress());, +		BeanPropertyBindingResult result = new BeanPropertyBindingResult(person, "person");, +		validator.validate(person, result);]