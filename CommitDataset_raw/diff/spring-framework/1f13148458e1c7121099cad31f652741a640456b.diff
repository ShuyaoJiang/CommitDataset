[+++ b/spring-framework-reference/src/mvc.xml, +    <para>In previous versions of Spring MVC, users were required to define, +    <interfacename>HandlerMapping</interfacename>s in the web application, +    context to map incoming web requests to appropriate handlers. With the, +    introduction of Spring 2.5, the <classname>DispatcherServlet</classname>, +    enables the <classname>DefaultAnnotationHandlerMapping</classname>, which, +    looks for <interfacename>@RequestMapping</interfacename> annotations on, +    <interfacename>@Controllers</interfacename>. Typically, you do not need to, +    override this default mapping, except when overriding the properties., +    These properties are:</para>, +    <para>The following example shows how to override the default mapping, and, +    add an interceptor:</para>, +    <programlisting language="xml">&lt;beans&gt;, +  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"&gt;, +    &lt;property name="interceptors"&gt;, +      &lt;bean class="example.MyInterceptor"/&gt;, +    &lt;/property&gt;, +  &lt;/bean&gt;, +&lt;beans&gt;</programlisting>, +              <entry>An implementation of the, +              <interfacename>ViewResolver</interfacename> interface that that, +              resolves a view based on the request file name or, +              <literal>Accept</literal> header. See <xref, +              linkend="mvc-multiple-representations" />.</entry>, +      <para>The <classname>ContentNegotiatingViewResolver</classname> does not, +      resolve views itself, but rather delegates to other view resolvers,, +      selecting the view that resembles the representation requested by the, +      client. There are two strategies for a client to inform the server of, +      <programlisting language="xml">&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt;, +  &lt;property name="mediaTypes"&gt;, +    &lt;map&gt;, +      &lt;entry key="atom" value="application/atom+xml"/&gt;, +      &lt;entry key="html" value="text/html"/&gt;, +    &lt;/map&gt;, +  &lt;/property&gt;, +  &lt;property name="viewResolvers"&gt;, +    &lt;list&gt;, +      &lt;bean class="org.springframework.web.servlet.view.BeanNameViewResolver"/&gt;, +      &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;, +        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;, +        &lt;property name="suffix" value=".jsp"/&gt;, +      &lt;/bean&gt;, +    &lt;/list&gt;, +  &lt;/property&gt;, +&lt;/bean&gt;, +&lt;bean id="content" class="com.springsource.samples.rest.SampleContentAtomView"/&gt;</programlisting>, +      <para>As an alternative to implementing the, +      <interfacename>HandlerExceptionResolver</interfacename>, you can use the, +      <interfacename>@ExceptionHandler</interfacename>. The, +      <classname>@ExceptionHandler</classname> method annotation is used, +      within a controller to specify which method will be invoked when an, +  <section id="mvc-etag">, +    <title>ETag support</title>, +, +    <para>An <ulink url="http://en.wikipedia.org/wiki/HTTP_ETag">ETag</ulink>, +    (entity tag) is an HTTP response header returned by an HTTP/1.1 compliant, +    web server used to determine change in content at a given URL. It can be, +    considered to be the more sophisticated successor to the, +    <literal>Last-Modified</literal> header. When a server returns a, +    representation with an ETag header, the client can use this header in, +    subsequent GETs, in an <literal>If-None-Match</literal> header. If the, +    content has not changed, the server will return <literal>304: Not, +    Modified</literal>.</para>, +, +    <para>Support for ETags is provided by the servlet filter, +    <classname>ShallowEtagHeaderFilter</classname>. Since it is a plain, +    Servlet Filter, and thus can be used in combination with any web, +    framework. The <classname>ShallowEtagHeaderFilter</classname> filter, +    creates so-called shallow ETags (as opposed to deep ETags, more about that, +    later). The way it works is quite simple: the filter simply caches the, +    content of the rendered JSP (or other content), generates an MD5 hash over, +    that, and returns that as an ETag header in the response. The next time a, +    client sends a request for the same resource, it uses that hash as the, +    <literal>If-None-Match</literal> value. The filter notices this, renders, +    the view again, and compares the two hashes. If they are equal, a, +    <literal>304</literal> is returned. It is important to note that this, +    filter will not save processing power, as the view is still rendered. The, +    only thing it saves is bandwidth, as the rendered response is not sent, +    back over the wire.</para>, +, +    <para>You configure the <classname>ShallowEtagHeaderFilter</classname> in, +    <filename>web.xml</filename>:</para>, +, +    <programlisting language="xml">&lt;filter&gt;, +  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;, +    &lt;filter-class&gt;org.springframework.web.filter.ShallowEtagHeaderFilter&lt;/filter-class&gt;, +&lt;/filter&gt;, +, +&lt;filter-mapping&gt;, +  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;, +  &lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;, +&lt;/filter-mapping&gt;</programlisting>, +  </section>, +]