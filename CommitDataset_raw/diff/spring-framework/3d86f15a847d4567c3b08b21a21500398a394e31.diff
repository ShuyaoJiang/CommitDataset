[+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java, + * Copyright 2002-2015 the original author or authors., +		itb.getSpouse();, +++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java, + * Copyright 2002-2015 the original author or authors., +		itb.getSpouse();, +++ b/spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java, + * Copyright 2002-2015 the original author or authors., +import java.beans.PropertyChangeEvent;, +import java.lang.reflect.Array;, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.UndeclaredThrowableException;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.Optional;, +import java.util.Set;, +, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +, +import org.springframework.core.CollectionFactory;, +import org.springframework.core.ResolvableType;, +import org.springframework.core.convert.ConversionException;, +import org.springframework.core.convert.ConverterNotFoundException;, +import org.springframework.core.convert.TypeDescriptor;, +import org.springframework.lang.UsesJava8;, +import org.springframework.util.Assert;, +import org.springframework.util.ClassUtils;, +import org.springframework.util.ObjectUtils;, +import org.springframework.util.StringUtils;, + * Abstract implementation of the {@link ConfigurablePropertyAccessor} interface., + * Provides the necessary infrastructure for all typical use cases., + * <p>This accessor will convert collection and array values to the corresponding, + * target collections or arrays, if necessary. Custom property editors that deal, + * with collections or arrays can either be written via PropertyEditor's, + * {@code setValue}, or against a comma-delimited String via {@code setAsText},, + * as String arrays are converted in such a format if the array itself is not, + * assignable., + *, + * @author Rod Johnson, + * @author Rob Harrop, + * @see #registerCustomEditor, + * @see #setPropertyValues, + * @see #getPropertyValue, + * @see #getPropertyType, + * @see BeanWrapper, + * @see PropertyEditorRegistrySupport, +	/**, +	 * We'll create a lot of these objects, so we don't want a new logger every time., +	 */, +	private static final Log logger = LogFactory.getLog(AbstractPropertyAccessor.class);, +, +	private static Class<?> javaUtilOptionalClass = null;, +, +	static {, +		try {, +			javaUtilOptionalClass =, +					ClassUtils.forName("java.util.Optional", AbstractPropertyAccessor.class.getClassLoader());, +		}, +		catch (ClassNotFoundException ex) {, +			// Java 8 not available - Optional references simply not supported then., +		}, +	}, +, +	private int autoGrowCollectionLimit = Integer.MAX_VALUE;, +, +	/** The wrapped object */, +	private Object object;, +, +	private String nestedPath = "";, +, +	private Object rootObject;, +, +	/**, +	 * Map with cached nested Accessors: nested path -> Accessor instance., +	 */, +	private Map<String, AbstractPropertyAccessor> nestedPropertyAccessors;, +, +	/**, +	 * Create new empty accessor. Wrapped instance needs to be set afterwards., +	 * Registers default editors., +	 * @see #setWrappedInstance, +	 */, +	protected AbstractPropertyAccessor() {, +		this(true);, +	}, +, +	/**, +	 * Create new empty accessor. Wrapped instance needs to be set afterwards., +	 * @param registerDefaultEditors whether to register default editors, +	 * (can be suppressed if the accessor won't need any type conversion), +	 * @see #setWrappedInstance, +	 */, +	protected AbstractPropertyAccessor(boolean registerDefaultEditors) {, +		if (registerDefaultEditors) {, +			registerDefaultEditors();, +		}, +		this.typeConverterDelegate = new TypeConverterDelegate(this);]