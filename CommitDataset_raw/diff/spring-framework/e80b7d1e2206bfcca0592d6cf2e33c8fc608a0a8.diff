[+++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +import org.springframework.core.SerializableTypeWrapper.FieldTypeProvider;, +import org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider;, +import org.springframework.core.SerializableTypeWrapper.TypeProvider;, +	public static final ResolvableType NONE = new ResolvableType(null, null, null, null);, +	 * Optional provider for the type., +	 */, +	private TypeProvider typeProvider;, +, +	/**, +	private ResolvableType(Type type, TypeProvider typeProvider,, +			VariableResolver variableResolver, ResolvableType componentType) {, +		this.typeProvider = typeProvider;, +	 * Return the underlying source of the resolvable type. Will return a {@link Field},, +	 * {@link MethodParameter} or {@link Type} depending on how the {@link ResolvableType}, +	 * was constructed. With the exception of the {@link #NONE} constant, this method will, +	 * never return {@code null}. This method is primarily to provide access to additional, +	 * type information or meta-data that alternative JVM languages may provide., +	 */, +	public Object getSource() {, +		Object source = (this.typeProvider == null ? null : this.typeProvider.getSource());, +		return (source == null ? this.type : source);, +	}, +, +	/**, +			equals &= ObjectUtils.nullSafeEquals(getSource(), other.getSource());, +		return forType(null, new FieldTypeProvider(field), null);, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());, +		return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);, +		return forType(null, new MethodParameterTypeProvider(methodParameter),, +		return new ResolvableType(arrayClass, null, null, componentType);, +		return forType(type, null, variableResolver);, +	}, +, +	/**, +	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given, +	 * {@link VariableResolver}., +	 * @param type the source type or {@code null}, +	 * @param typeProvider the type provider or {@code null}, +	 * @param variableResolver the variable resolver or {@code null}, +	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}, +	 */, +	static ResolvableType forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver) {, +		if (type == null && typeProvider != null) {, +			type = SerializableTypeWrapper.forTypeProvider(typeProvider);, +		}, +		ResolvableType key = new ResolvableType(type, typeProvider, variableResolver, null);, +++ b/spring-core/src/main/java/org/springframework/core/ResolvableType.java, +import org.springframework.core.SerializableTypeWrapper.FieldTypeProvider;, +import org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider;, +import org.springframework.core.SerializableTypeWrapper.TypeProvider;, +	public static final ResolvableType NONE = new ResolvableType(null, null, null, null);, +	 * Optional provider for the type., +	 */, +	private TypeProvider typeProvider;, +, +	/**, +	private ResolvableType(Type type, TypeProvider typeProvider,, +			VariableResolver variableResolver, ResolvableType componentType) {, +		this.typeProvider = typeProvider;, +	 * Return the underlying source of the resolvable type. Will return a {@link Field},, +	 * {@link MethodParameter} or {@link Type} depending on how the {@link ResolvableType}, +	 * was constructed. With the exception of the {@link #NONE} constant, this method will, +	 * never return {@code null}. This method is primarily to provide access to additional, +	 * type information or meta-data that alternative JVM languages may provide., +	 */, +	public Object getSource() {, +		Object source = (this.typeProvider == null ? null : this.typeProvider.getSource());, +		return (source == null ? this.type : source);, +	}, +, +	/**, +			equals &= ObjectUtils.nullSafeEquals(getSource(), other.getSource());, +		return forType(null, new FieldTypeProvider(field), null);, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());, +		return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);, +		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);, +		return forType(null, new MethodParameterTypeProvider(methodParameter),, +		return new ResolvableType(arrayClass, null, null, componentType);, +		return forType(type, null, variableResolver);, +	}, +, +	/**, +	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given, +	 * {@link VariableResolver}., +	 * @param type the source type or {@code null}, +	 * @param typeProvider the type provider or {@code null}, +	 * @param variableResolver the variable resolver or {@code null}, +	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}, +	 */, +	static ResolvableType forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver) {, +		if (type == null && typeProvider != null) {, +			type = SerializableTypeWrapper.forTypeProvider(typeProvider);, +		}, +		ResolvableType key = new ResolvableType(type, typeProvider, variableResolver, null);, +++ b/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java, +		return forTypeProvider(new DefaultTypeProvider() {, +			result[i] = forTypeProvider(new DefaultTypeProvider() {, +			result[i] = forTypeProvider(new DefaultTypeProvider() {]