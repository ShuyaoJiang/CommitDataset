[+++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/IntLiteral.java, +/**, + * Expression language AST node that represents an integer literal., + * , + * @author Andy Clement, + */, +	private final Integer value;, +	IntLiteral(Token payload, int value) {, +		this.value = value;, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/IntLiteral.java, +/**, + * Expression language AST node that represents an integer literal., + * , + * @author Andy Clement, + */, +	private final Integer value;, +	IntLiteral(Token payload, int value) {, +		this.value = value;, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Literal.java, +import org.springframework.expression.spel.SpelException;, +import org.springframework.expression.spel.SpelMessages;, +import org.springframework.expression.spel.internal.InternalELException;, +	/**, +	 * Process the string form of a number, using the specified base if supplied and return an appropriate literal to, +	 * hold it. Any suffix to indicate a long will be taken into account (either 'l' or 'L' is supported)., +	 * , +	 * @param numberToken the token holding the number as its payload (eg. 1234 or 0xCAFE), +	 * @param radix the base of number, +	 * @return a subtype of Literal that can represent it, +	 */, +	public static Literal getIntLiteral(Token numberToken, int radix) {, +		String numberString = numberToken.getText();, +, +		boolean isLong = false;, +		boolean isHex = (radix == 16);, +, +		if (numberString.length() > 0) {, +			isLong = numberString.endsWith("L") || numberString.endsWith("l");, +		}, +, +		if (isLong || isHex) { // needs to be chopped up a little, +			int len = numberString.length();, +			// assert: if hex then startsWith 0x or 0X, +			numberString = numberString.substring((isHex ? 2 : 0), isLong ? len - 1 : len);, +		}, +, +		if (isLong) {, +			try {, +				long value = Long.parseLong(numberString, radix);, +				return new LongLiteral(numberToken, value);, +			} catch (NumberFormatException nfe) {, +				throw new InternalELException(new SpelException(numberToken.getCharPositionInLine(), nfe,, +						SpelMessages.NOT_A_LONG, numberToken.getText()));, +			}, +		} else {, +			try {, +				int value = Integer.parseInt(numberString, radix);, +				return new IntLiteral(numberToken, value);, +			} catch (NumberFormatException nfe) {, +				throw new InternalELException(new SpelException(numberToken.getCharPositionInLine(), nfe,, +						SpelMessages.NOT_AN_INTEGER, numberToken.getText()));, +			}, +		}, +	}, +, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/IntLiteral.java, +/**, + * Expression language AST node that represents an integer literal., + * , + * @author Andy Clement, + */, +	private final Integer value;, +	IntLiteral(Token payload, int value) {, +		this.value = value;, +++ b/org.springframework.expression/src/main/java/org/springframework/expression/spel/ast/Literal.java, +import org.springframework.expression.spel.SpelException;, +import org.springframework.expression.spel.SpelMessages;, +import org.springframework.expression.spel.internal.InternalELException;, +	/**, +	 * Process the string form of a number, using the specified base if supplied and return an appropriate literal to, +	 * hold it. Any suffix to indicate a long will be taken into account (either 'l' or 'L' is supported)., +	 * , +	 * @param numberToken the token holding the number as its payload (eg. 1234 or 0xCAFE), +	 * @param radix the base of number, +	 * @return a subtype of Literal that can represent it, +	 */, +	public static Literal getIntLiteral(Token numberToken, int radix) {, +		String numberString = numberToken.getText();, +, +		boolean isLong = false;, +		boolean isHex = (radix == 16);, +, +		if (numberString.length() > 0) {, +			isLong = numberString.endsWith("L") || numberString.endsWith("l");, +		}, +, +		if (isLong || isHex) { // needs to be chopped up a little, +			int len = numberString.length();, +			// assert: if hex then startsWith 0x or 0X, +			numberString = numberString.substring((isHex ? 2 : 0), isLong ? len - 1 : len);]