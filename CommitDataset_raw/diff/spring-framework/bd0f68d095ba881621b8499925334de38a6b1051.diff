[+++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, +import org.aspectj.weaver.reflect.ReflectionWorld.ReflectionWorldException;, + * @author Dave Syer, +		ClassLoader cl = (this.beanFactory instanceof ConfigurableBeanFactory ? ((ConfigurableBeanFactory) this.beanFactory), +				.getBeanClassLoader() : Thread.currentThread(), +				.getContextClassLoader());, +		return buildPointcutExpression(cl);, +	}, +, +	/**, +	 * Build the underlying AspectJ pointcut expression., +	 */, +	private PointcutExpression buildPointcutExpression(ClassLoader classLoader) {, +		PointcutParser parser = initializePointcutParser(classLoader);, +					this.pointcutParameterNames[i],, +					this.pointcutParameterTypes[i]);, +				replaceBooleanOperators(getExpression()),, +				this.pointcutDeclarationScope, pointcutParameters);, +	private PointcutParser initializePointcutParser(ClassLoader cl) {, +		PointcutParser parser = PointcutParser, +				.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(, +, +		} catch (ReflectionWorldException e) {, +			logger.debug("PointcutExpression matching rejected target class", e);, +			try {, +				// Actually this is still a "maybe" - treat the pointcut as dynamic if we, +				// don't know enough yet, +				return getFallbackPointcutExpression(targetClass).couldMatchJoinPointsInType(targetClass);, +			} catch (BCException ex) {, +				logger.debug(, +						"Fallback PointcutExpression matching rejected target class",, +						ex);, +				return false;, +			}, +			RuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(originalShadowMatch);, +	 * Get a new pointcut expression based on a target class's loader, rather, +	 * than the default., +	 */, +	private PointcutExpression getFallbackPointcutExpression(, +			Class<?> targetClass) {, +		ClassLoader classLoader = targetClass.getClassLoader();, +		return classLoader == null ? this.pointcutExpression : buildPointcutExpression(classLoader);, +	}, +, +	/**, +		return !(getRuntimeTestWalker(shadowMatch).testsSubtypeSensitiveVars());, +		return getRuntimeTestWalker(shadowMatch).testTargetInstanceOfResidue(targetClass);, +	}, +, +	private RuntimeTestWalker getRuntimeTestWalker(ShadowMatch shadowMatch) {, +		if (shadowMatch instanceof DefensiveShadowMatch) {, +			return new RuntimeTestWalker(((DefensiveShadowMatch)shadowMatch).primary);, +		}, +		return new RuntimeTestWalker(shadowMatch);, +				Method methodToMatch = targetMethod;, +				PointcutExpression fallbackPointcutExpression = null;, +				shadowMatch = this.shadowMatchCache.get(methodToMatch);, +						try {, +							fallbackPointcutExpression = getFallbackPointcutExpression(methodToMatch.getDeclaringClass());, +							shadowMatch = fallbackPointcutExpression.matchesMethodExecution(methodToMatch);, +						} catch (ReflectionWorld.ReflectionWorldException e) {, +									methodToMatch = originalMethod;, +									fallbackPointcutExpression = getFallbackPointcutExpression(methodToMatch.getDeclaringClass());, +									try {, +										shadowMatch = fallbackPointcutExpression.matchesMethodExecution(methodToMatch);, +									} catch (ReflectionWorld.ReflectionWorldException e2) {, +						}, +					}, +					if (shadowMatch.maybeMatches() && fallbackPointcutExpression!=null) {, +						shadowMatch = new DefensiveShadowMatch(shadowMatch,, +								fallbackPointcutExpression.matchesMethodExecution(methodToMatch));, +					}, +	private static class DefensiveShadowMatch implements ShadowMatch {, +, +		private final ShadowMatch primary;, +		private final ShadowMatch other;, +, +		public DefensiveShadowMatch(ShadowMatch primary, ShadowMatch other) {, +			this.primary = primary;, +			this.other = other;, +		}, +, +		public boolean alwaysMatches() {, +			return primary.alwaysMatches();, +		}, +, +		public boolean maybeMatches() {, +			return primary.maybeMatches();, +		}, +, +		public boolean neverMatches() {, +			return primary.neverMatches();, +		}, +, +		public JoinPointMatch matchesJoinPoint(Object thisObject,, +				Object targetObject, Object[] args) {, +			try {, +				return primary.matchesJoinPoint(thisObject, targetObject, args);, +			} catch (ReflectionWorldException e) {, +				return other.matchesJoinPoint(thisObject, targetObject, args);]