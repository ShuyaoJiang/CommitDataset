[+++ b/spring-core/src/main/java/org/springframework/util/MultiValueMap.java, +	 * @since 5.0, +++ b/spring-core/src/main/java/org/springframework/util/MultiValueMap.java, +	 * @since 5.0, +++ b/spring-core/src/test/java/org/springframework/util/LinkedMultiValueMapTests.java, +import static org.junit.Assert.*;, +	private final LinkedMultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();, +++ b/spring-core/src/main/java/org/springframework/util/MultiValueMap.java, +	 * @since 5.0, +++ b/spring-core/src/test/java/org/springframework/util/LinkedMultiValueMapTests.java, +import static org.junit.Assert.*;, +	private final LinkedMultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, + * Hand-written SpEL parser. Instances are reusable but are not thread-safe., +		boolean nullSafeNavigation = (t.kind == TokenKind.SAFE_NAVI);, +		if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() ||, +				maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {, +			raiseInternalException(t.startPos, SpelMessage.UNEXPECTED_DATA_AFTER_DOT, toString(peekToken()));, +			push(new VariableReference(functionOrVariableName.data,, +					toPos(t.startPos, functionOrVariableName.endPos)));, +		push(new FunctionReference(functionOrVariableName.data,, +				toPos(t.startPos, functionOrVariableName.endPos), args));, +			throw new InternalParseException(new SpelParseException(this.expressionString,, +					positionOf(peekToken()), SpelMessage.MISSING_CONSTRUCTOR_ARGS));, +			nextToken();  // consume (first time through) or comma (subsequent times), +			BeanReference beanReference;, +				String beanNameString = new StringBuilder()., +						append(TokenKind.FACTORY_BEAN_REF.tokenChars).append(beanName).toString();, +				beanReference = new BeanReference(, +						toPos(beanRefToken.startPos, beanNameToken.endPos), beanNameString);, +			if (!"T".equals(typeName.stringValue())) {, +			if (!"null".equalsIgnoreCase(nullToken.stringValue())) {, +				expr = new InlineList(toPos(t.startPos, closingCurly.endPos),, +						listElements.toArray(new SpelNodeImpl[listElements.size()]));, +			else if (peekToken(TokenKind.COMMA, true)) {  // multi-item list, +				expr = new InlineList(toPos(t.startPos, closingCurly.endPos),, +						listElements.toArray(new SpelNodeImpl[listElements.size()]));, +				expr = new InlineMap(toPos(t.startPos, closingCurly.endPos),, +						mapElements.toArray(new SpelNodeImpl[mapElements.size()]));, +		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),, +				qualifiedIdPieces.getLast().getEndPosition());, +		return new QualifiedIdentifier(pos,, +				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]));, +	// This is complicated due to the support for dollars in identifiers., +	// Dollars are normally separate tokens but there we want to combine, +	// a series of identifiers and dollars into a single identifier., +				push(new PropertyOrFieldReference(nullSafeNavigation, methodOrPropertyName.data,, +						toPos(methodOrPropertyName)));, +			push(new MethodReference(nullSafeNavigation, methodOrPropertyName.data,, +					toPos(methodOrPropertyName), args));, +				push(new ConstructorReference(toPos(newToken),, +						dimensions.toArray(new SpelNodeImpl[dimensions.size()]),, +			// Might be one of the textual forms of the operators (e.g. NE for != ) -, +			// in which case we can treat it as an identifier. The list is represented here:, +			// Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum., +			if (t.kind.ordinal() >= TokenKind.DIV.ordinal() && t.kind.ordinal() <= TokenKind.NOT.ordinal() &&, +					t.data != null) {, +		// Compress the start and end of a token into a single int, +++ b/spring-core/src/main/java/org/springframework/util/MultiValueMap.java, +	 * @since 5.0, +++ b/spring-core/src/test/java/org/springframework/util/LinkedMultiValueMapTests.java, +import static org.junit.Assert.*;, +	private final LinkedMultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();, +++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java, + * Hand-written SpEL parser. Instances are reusable but are not thread-safe., +		boolean nullSafeNavigation = (t.kind == TokenKind.SAFE_NAVI);, +		if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() ||, +				maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {, +			raiseInternalException(t.startPos, SpelMessage.UNEXPECTED_DATA_AFTER_DOT, toString(peekToken()));, +			push(new VariableReference(functionOrVariableName.data,, +					toPos(t.startPos, functionOrVariableName.endPos)));, +		push(new FunctionReference(functionOrVariableName.data,, +				toPos(t.startPos, functionOrVariableName.endPos), args));, +			throw new InternalParseException(new SpelParseException(this.expressionString,, +					positionOf(peekToken()), SpelMessage.MISSING_CONSTRUCTOR_ARGS));, +			nextToken();  // consume (first time through) or comma (subsequent times), +			BeanReference beanReference;, +				String beanNameString = new StringBuilder()., +						append(TokenKind.FACTORY_BEAN_REF.tokenChars).append(beanName).toString();, +				beanReference = new BeanReference(, +						toPos(beanRefToken.startPos, beanNameToken.endPos), beanNameString);, +			if (!"T".equals(typeName.stringValue())) {, +			if (!"null".equalsIgnoreCase(nullToken.stringValue())) {, +				expr = new InlineList(toPos(t.startPos, closingCurly.endPos),, +						listElements.toArray(new SpelNodeImpl[listElements.size()]));, +			else if (peekToken(TokenKind.COMMA, true)) {  // multi-item list, +				expr = new InlineList(toPos(t.startPos, closingCurly.endPos),, +						listElements.toArray(new SpelNodeImpl[listElements.size()]));, +				expr = new InlineMap(toPos(t.startPos, closingCurly.endPos),, +						mapElements.toArray(new SpelNodeImpl[mapElements.size()]));, +		int pos = toPos(qualifiedIdPieces.getFirst().getStartPosition(),, +				qualifiedIdPieces.getLast().getEndPosition());, +		return new QualifiedIdentifier(pos,, +				qualifiedIdPieces.toArray(new SpelNodeImpl[qualifiedIdPieces.size()]));, +	// This is complicated due to the support for dollars in identifiers., +	// Dollars are normally separate tokens but there we want to combine, +	// a series of identifiers and dollars into a single identifier., +				push(new PropertyOrFieldReference(nullSafeNavigation, methodOrPropertyName.data,, +						toPos(methodOrPropertyName)));, +			push(new MethodReference(nullSafeNavigation, methodOrPropertyName.data,]