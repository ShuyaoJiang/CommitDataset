[+++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +	private String mimetype;, +, +		if (this.mimetype == null) {, +			this.mimetype = builder.toString();, +		}, +		return this.mimetype;, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +	private String mimetype;, +, +		if (this.mimetype == null) {, +			this.mimetype = builder.toString();, +		}, +		return this.mimetype;, +++ b/spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java, + * Copyright 2002-2019 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +import java.util.function.Function;, + * @author Brian Clozel, +	private static final ConcurrentLRUCache<String, MimeType> CACHED_MIMETYPES =, +			new ConcurrentLRUCache<>(32, MimeTypeUtils::parseMimeTypeInternal);, +, +		ALL = new MimeType("*", "*");, +		APPLICATION_JSON = new MimeType("application", "json");, +		APPLICATION_OCTET_STREAM = new MimeType("application", "octet-stream");, +		APPLICATION_XML = new MimeType("application", "xml");, +		IMAGE_GIF = new MimeType("image", "gif");, +		IMAGE_JPEG = new MimeType("image", "jpeg");, +		IMAGE_PNG = new MimeType("image", "png");, +		TEXT_HTML = new MimeType("text", "html");, +		TEXT_PLAIN = new MimeType("text", "plain");, +		TEXT_XML = new MimeType("text", "xml");, +	 * Recently parsed {@code MimeType} are cached for further retrieval., +		return CACHED_MIMETYPES.get(mimeType);, +	}, +, +	private static MimeType parseMimeTypeInternal(String mimeType) {, +	static class ConcurrentLRUCache<K, V> {, +, +		private final int maxSize;, +, +		private final ConcurrentLinkedQueue<K> queue = new ConcurrentLinkedQueue<>();, +, +		private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();, +, +		private final ReadWriteLock lock = new ReentrantReadWriteLock();, +, +		private final Function<K, V> generator;, +, +		ConcurrentLRUCache(int maxSize, Function<K, V> generator) {, +			Assert.isTrue(maxSize > 0, "LRU max size should be positive");, +			Assert.notNull(generator, "Generator function should not be null");, +			this.maxSize = maxSize;, +			this.generator = generator;, +		}, +, +		public V get(K key) {, +			this.lock.readLock().lock();, +			try {, +				if (this.queue.remove(key)) {, +					this.queue.add(key);, +					return this.cache.get(key);, +				}, +			}, +			finally {, +				this.lock.readLock().unlock();, +			}, +			this.lock.writeLock().lock();, +			try {, +				if (this.queue.size() == this.maxSize) {, +					K leastUsed = this.queue.poll();, +					this.cache.remove(leastUsed);, +				}, +				V value = this.generator.apply(key);, +				this.queue.add(key);, +				this.cache.put(key, value);, +				return value;, +			}, +			finally {, +				this.lock.writeLock().unlock();, +			}, +		}, +, +	}, +, +++ b/spring-core/src/main/java/org/springframework/util/MimeType.java, +	private String mimetype;, +, +		if (this.mimetype == null) {, +			this.mimetype = builder.toString();, +		}, +		return this.mimetype;, +++ b/spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java, + * Copyright 2002-2019 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.locks.ReadWriteLock;]