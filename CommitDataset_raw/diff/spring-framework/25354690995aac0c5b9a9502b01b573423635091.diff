[+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, + * General utility methods for finding annotations, meta-annotations, and, + * repeatable annotations on {@link AnnotatedElement AnnotatedElements}., + * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},, + * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}, +	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];, +	 * @see #hasAnnotation(AnnotatedElement, Class), +	 * @see #isAnnotated(AnnotatedElement, Class), +	 * <p>This method follows <em>find semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * <p>This method follows <em>find semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * hierarchy and synthesize the result back into an annotation of the specified, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>find semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the result back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>The container type that holds the repeatable annotations will be looked up, +	 * via {@link java.lang.annotation.Repeatable}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>find semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @return the set of all merged repeatable {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #findMergedAnnotation(AnnotatedElement, Class), +	 * @see #findAllMergedAnnotations(AnnotatedElement, Class), +	 * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class), +	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}, +	 * is {@code null}, or if the container type cannot be resolved, +	 */, +	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType) {, +, +		return findMergedRepeatableAnnotations(element, annotationType, null);, +	}, +, +	/**, +	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}, +	 * within the annotation hierarchy <em>above</em> the supplied {@code element};, +	 * and for each annotation found, merge that annotation's attributes with, +	 * <em>matching</em> attributes from annotations in lower levels of the annotation, +	 * hierarchy and synthesize the result back into an annotation of the specified, +	 * {@code annotationType}., +	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a, +	 * single annotation and within annotation hierarchies., +	 * <p>This method follows <em>find semantics</em> as described in the, +	 * {@linkplain AnnotatedElementUtils class-level javadoc}., +	 * @param element the annotated element; never {@code null}, +	 * @param annotationType the annotation type to find; never {@code null}, +	 * @param containerType the type of the container that holds the annotations;, +	 * may be {@code null} if the container type should be looked up via, +	 * {@link java.lang.annotation.Repeatable}, +	 * @return the set of all merged repeatable {@code Annotations} found, or an empty, +	 * set if none were found, +	 * @since 4.3, +	 * @see #findMergedAnnotation(AnnotatedElement, Class), +	 * @see #findAllMergedAnnotations(AnnotatedElement, Class), +	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}, +	 * is {@code null}, or if the container type cannot be resolved, +	 * @throws AnnotationConfigurationException if the supplied {@code containerType}, +	 * is not a valid container annotation for the supplied {@code annotationType}, +	 */, +	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,, +			Class<A> annotationType, Class<? extends Annotation> containerType) {, +, +		Assert.notNull(element, "AnnotatedElement must not be null");, +		Assert.notNull(annotationType, "annotationType must not be null");, +, +		if (containerType == null) {, +			containerType = AnnotationUtils.resolveContainerAnnotationType(annotationType);, +			if (containerType == null) {, +				throw new IllegalArgumentException(, +					"annotationType must be a repeatable annotation: failed to resolve container type for ", +							+ annotationType.getName());, +			}, +		}, +		else {, +			validateRepeatableContainerType(annotationType, containerType);, +		}, +, +		MergedAnnotationAttributesProcessor processor = new MergedAnnotationAttributesProcessor(annotationType, null,, +			false, false, true);, +, +		searchWithFindSemantics(element, annotationType, annotationType.getName(), containerType, processor);, +, +		Set<A> annotations = new LinkedHashSet<A>();, +		for (AnnotationAttributes attributes : processor.getAggregatedResults()) {, +			AnnotationUtils.postProcessAnnotationAttributes(element, attributes, false, false);, +			annotations.add(AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element));, +		}, +		return annotations;]