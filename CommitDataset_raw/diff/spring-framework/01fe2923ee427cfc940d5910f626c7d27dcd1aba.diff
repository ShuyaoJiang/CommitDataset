[+++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandlerIntegrationTests.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +	private TestMessageHandler responseHandler;, +	private TestEventPublisher eventPublisher;, +		this.responseHandler = new TestMessageHandler();, +		this.eventPublisher = new TestEventPublisher();, +		this.eventPublisher.expectBrokerAvailabilityEvent(true);, +		MessageExchange conn1 = MessageExchangeBuilder.connect(sess1).build();, +		MessageExchange conn2 = MessageExchangeBuilder.connect(sess2).build();, +		this.relay.handleMessage(conn1.message);, +		this.relay.handleMessage(conn2.message);, +		this.responseHandler.expectMessages(conn1, conn2);, +		MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build();, +		this.responseHandler.expectMessages(subscribe);, +		this.responseHandler.expectMessages(send);, +	public void messageDeliveryExceptionIfSystemSessionForwardFails() throws Exception {, +		this.responseHandler.expectMessages(connect);, +		MessageExchange error = MessageExchangeBuilder.error(sess1).build();, +		this.responseHandler.expectMessages(error);, +		this.eventPublisher.expectBrokerAvailabilityEvent(false);, +		this.responseHandler.expectMessages(conn1);, +		MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build();, +		this.responseHandler.expectMessages(subscribe);, +		MessageExchange error = MessageExchangeBuilder.error(sess1).build();, +		this.responseHandler.expectMessages(error);, +		this.eventPublisher.expectBrokerAvailabilityEvent(false);, +		this.eventPublisher.expectBrokerAvailabilityEvent(true);, +		this.responseHandler.expectMessages(connect);, +		assertTrue("Unexpected messages: " + this.responseHandler.queue, this.responseHandler.queue.isEmpty());, +	private static class TestEventPublisher implements ApplicationEventPublisher {, +		private final BlockingQueue<BrokerAvailabilityEvent> eventQueue = new LinkedBlockingQueue<>();, +		@Override, +		public void publishEvent(ApplicationEvent event) {, +			logger.debug("Processing ApplicationEvent " + event);, +			if (event instanceof BrokerAvailabilityEvent) {, +				this.eventQueue.add((BrokerAvailabilityEvent) event);, +		public void expectBrokerAvailabilityEvent(boolean isBrokerAvailable) throws InterruptedException {, +			BrokerAvailabilityEvent event = this.eventQueue.poll(10000, TimeUnit.MILLISECONDS);, +			assertEquals(isBrokerAvailable, event.isBrokerAvailable());, +	private static class TestMessageHandler implements MessageHandler {, +, +		private final BlockingQueue<Message<?>> queue = new LinkedBlockingQueue<>();, +			if (SimpMessageType.HEARTBEAT == SimpMessageHeaderAccessor.getMessageType(message.getHeaders())) {, +			this.queue.add(message);, +		public void expectMessages(MessageExchange... messageExchanges) throws InterruptedException {, +			for (MessageExchange exchange : messageExchanges) {, +				Message<?> message = this.queue.poll(10000, TimeUnit.MILLISECONDS);, +				assertTrue("Expected: " + exchange + " but got: " + message, exchange.matchMessage(message));, +			return "Forwarded message:\n" + this.message + "\n" +, +					"Should receive back:\n" + Arrays.toString(this.expected) + "\n" +, +					"Actually received:\n" + Arrays.toString(this.actual) + "\n";, +++ b/spring-messaging/src/test/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandlerIntegrationTests.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +	private TestMessageHandler responseHandler;, +	private TestEventPublisher eventPublisher;, +		this.responseHandler = new TestMessageHandler();, +		this.eventPublisher = new TestEventPublisher();, +		this.eventPublisher.expectBrokerAvailabilityEvent(true);, +		MessageExchange conn1 = MessageExchangeBuilder.connect(sess1).build();, +		MessageExchange conn2 = MessageExchangeBuilder.connect(sess2).build();, +		this.relay.handleMessage(conn1.message);, +		this.relay.handleMessage(conn2.message);, +		this.responseHandler.expectMessages(conn1, conn2);, +		MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build();, +		this.responseHandler.expectMessages(subscribe);, +		this.responseHandler.expectMessages(send);, +	public void messageDeliveryExceptionIfSystemSessionForwardFails() throws Exception {, +		this.responseHandler.expectMessages(connect);, +		MessageExchange error = MessageExchangeBuilder.error(sess1).build();, +		this.responseHandler.expectMessages(error);, +		this.eventPublisher.expectBrokerAvailabilityEvent(false);, +		this.responseHandler.expectMessages(conn1);, +		MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build();, +		this.responseHandler.expectMessages(subscribe);, +		MessageExchange error = MessageExchangeBuilder.error(sess1).build();, +		this.responseHandler.expectMessages(error);, +		this.eventPublisher.expectBrokerAvailabilityEvent(false);, +		this.eventPublisher.expectBrokerAvailabilityEvent(true);, +		this.responseHandler.expectMessages(connect);, +		assertTrue("Unexpected messages: " + this.responseHandler.queue, this.responseHandler.queue.isEmpty());, +	private static class TestEventPublisher implements ApplicationEventPublisher {, +		private final BlockingQueue<BrokerAvailabilityEvent> eventQueue = new LinkedBlockingQueue<>();, +		@Override, +		public void publishEvent(ApplicationEvent event) {, +			logger.debug("Processing ApplicationEvent " + event);, +			if (event instanceof BrokerAvailabilityEvent) {, +				this.eventQueue.add((BrokerAvailabilityEvent) event);, +		public void expectBrokerAvailabilityEvent(boolean isBrokerAvailable) throws InterruptedException {, +			BrokerAvailabilityEvent event = this.eventQueue.poll(10000, TimeUnit.MILLISECONDS);, +			assertEquals(isBrokerAvailable, event.isBrokerAvailable());, +	private static class TestMessageHandler implements MessageHandler {, +, +		private final BlockingQueue<Message<?>> queue = new LinkedBlockingQueue<>();, +			if (SimpMessageType.HEARTBEAT == SimpMessageHeaderAccessor.getMessageType(message.getHeaders())) {, +			this.queue.add(message);, +		public void expectMessages(MessageExchange... messageExchanges) throws InterruptedException {, +			for (MessageExchange exchange : messageExchanges) {, +				Message<?> message = this.queue.poll(10000, TimeUnit.MILLISECONDS);]