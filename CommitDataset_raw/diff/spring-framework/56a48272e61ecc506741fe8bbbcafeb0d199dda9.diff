[+++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2009 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import org.aspectj.weaver.reflect.ShadowMatchImpl;, +	private final Map<Method, ShadowMatch> shadowMatchCache = new ConcurrentHashMap<Method, ShadowMatch>(32);, +		ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);, +		ShadowMatch shadowMatch = getShadowMatch(AopUtils.getMostSpecificMethod(method, targetClass), method);, +		ShadowMatch originalShadowMatch = getShadowMatch(method, method);, +					shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +				else {, +					try {, +					catch (ReflectionWorld.ReflectionWorldException ex2) {, +						// Could neither introspect the target class nor the proxy class ->, +						// let's simply consider this method as non-matching., +						shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +					}, +				}, +			}, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2009 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import org.aspectj.weaver.reflect.ShadowMatchImpl;, +	private final Map<Method, ShadowMatch> shadowMatchCache = new ConcurrentHashMap<Method, ShadowMatch>(32);, +		ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);, +		ShadowMatch shadowMatch = getShadowMatch(AopUtils.getMostSpecificMethod(method, targetClass), method);, +		ShadowMatch originalShadowMatch = getShadowMatch(method, method);, +					shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +				else {, +					try {, +					catch (ReflectionWorld.ReflectionWorldException ex2) {, +						// Could neither introspect the target class nor the proxy class ->, +						// let's simply consider this method as non-matching., +						shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +					}, +				}, +			}, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/annotation/LazySingletonAspectInstanceFactoryDecorator.java, + * Copyright 2002-2009 the original author or authors., + * Decorator to cause a {@link MetadataAwareAspectInstanceFactory} to instantiate only once., +	private volatile Object materialized;, +, +			synchronized (this) {, +				if (this.materialized == null) {, +			}, +		}, +	public ClassLoader getAspectClassLoader() {, +		return this.maaif.getAspectClassLoader();, +	}, +, +		return this.maaif.getOrder();, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2009 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import org.aspectj.weaver.reflect.ShadowMatchImpl;, +	private final Map<Method, ShadowMatch> shadowMatchCache = new ConcurrentHashMap<Method, ShadowMatch>(32);, +		ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);, +		ShadowMatch shadowMatch = getShadowMatch(AopUtils.getMostSpecificMethod(method, targetClass), method);, +		ShadowMatch originalShadowMatch = getShadowMatch(method, method);, +					shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +				else {, +					try {, +					catch (ReflectionWorld.ReflectionWorldException ex2) {, +						// Could neither introspect the target class nor the proxy class ->, +						// let's simply consider this method as non-matching., +						shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +					}, +				}, +			}, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/annotation/LazySingletonAspectInstanceFactoryDecorator.java, + * Copyright 2002-2009 the original author or authors., + * Decorator to cause a {@link MetadataAwareAspectInstanceFactory} to instantiate only once., +	private volatile Object materialized;, +, +			synchronized (this) {, +				if (this.materialized == null) {, +			}, +		}, +	public ClassLoader getAspectClassLoader() {, +		return this.maaif.getAspectClassLoader();, +	}, +, +		return this.maaif.getOrder();, +++ b/org.springframework.aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.java, + * Copyright 2002-2009 the original author or authors., +++ b/org.springframework.aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java, + * Copyright 2002-2009 the original author or authors., +import java.util.concurrent.ConcurrentHashMap;, +import org.aspectj.weaver.reflect.ShadowMatchImpl;, +	private final Map<Method, ShadowMatch> shadowMatchCache = new ConcurrentHashMap<Method, ShadowMatch>(32);, +		ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);, +		ShadowMatch shadowMatch = getShadowMatch(AopUtils.getMostSpecificMethod(method, targetClass), method);, +		ShadowMatch originalShadowMatch = getShadowMatch(method, method);, +					shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +				else {, +					try {, +					catch (ReflectionWorld.ReflectionWorldException ex2) {, +						// Could neither introspect the target class nor the proxy class ->, +						// let's simply consider this method as non-matching., +						shadowMatch = new ShadowMatchImpl(org.aspectj.util.FuzzyBoolean.NO, null, null, null);, +					}]