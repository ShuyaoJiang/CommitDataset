[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java, +import org.springframework.stereotype.Component;, + * @author Juergen Hoeller, +	 * Check whether the given bean definition is a candidate for a configuration class, +	 * (or a nested component class declared within a configuration/component class,, +	 * to be auto-registered as well), and mark it accordingly., +	/**, +	 * Check the given metadata for a configuration class candidate, +	 * (or nested component class declared within a configuration/component class)., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be registered as a, +	 * reflection-detected bean definition; {@code false} otherwise, +	 */, +	/**, +	 * Check the given metadata for a full configuration class candidate, +	 * (i.e. a class annotated with {@code @Configuration})., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be processed as a full, +	 * configuration class, including cross-method call interception, +	 */, +	/**, +	 * Check the given metadata for a lite configuration class candidate, +	 * (i.e. a class annotated with {@code @Component} or just having, +	 * {@code @Import} declarations or {@code @Bean methods})., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be processed as a lite, +	 * configuration class, just registering it and scanning it for {@code @Bean} methods, +	 */, +		return (!metadata.isInterface() && (metadata.isAnnotated(Component.class.getName()) ||, +	 * Determine whether the given bean definition indicates a full {@code @Configuration}, +	 * class, through checking {@link #checkConfigurationClassCandidate}'s metadata marker., +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java, +import org.springframework.stereotype.Component;, + * @author Juergen Hoeller, +	 * Check whether the given bean definition is a candidate for a configuration class, +	 * (or a nested component class declared within a configuration/component class,, +	 * to be auto-registered as well), and mark it accordingly., +	/**, +	 * Check the given metadata for a configuration class candidate, +	 * (or nested component class declared within a configuration/component class)., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be registered as a, +	 * reflection-detected bean definition; {@code false} otherwise, +	 */, +	/**, +	 * Check the given metadata for a full configuration class candidate, +	 * (i.e. a class annotated with {@code @Configuration})., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be processed as a full, +	 * configuration class, including cross-method call interception, +	 */, +	/**, +	 * Check the given metadata for a lite configuration class candidate, +	 * (i.e. a class annotated with {@code @Component} or just having, +	 * {@code @Import} declarations or {@code @Bean methods})., +	 * @param metadata the metadata of the annotated class, +	 * @return {@code true} if the given class is to be processed as a lite, +	 * configuration class, just registering it and scanning it for {@code @Bean} methods, +	 */, +		return (!metadata.isInterface() && (metadata.isAnnotated(Component.class.getName()) ||, +	 * Determine whether the given bean definition indicates a full {@code @Configuration}, +	 * class, through checking {@link #checkConfigurationClassCandidate}'s metadata marker., +++ b/spring-context/src/test/java/org/springframework/context/annotation/NestedConfigurationClassTests.java, +import org.springframework.stereotype.Component;, +import static org.hamcrest.CoreMatchers.*;, +import static org.junit.Assert.*;, +, + * @author Juergen Hoeller, +	@Test, +	public void twoLevelsInLiteMode() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(L0ConfigLight.class);, +		ctx.refresh();, +, +		ctx.getBean(L0ConfigLight.class);, +		ctx.getBean("l0Bean");, +, +		ctx.getBean(L0ConfigLight.L1ConfigLight.class);, +		ctx.getBean("l1Bean");, +, +		ctx.getBean(L0ConfigLight.L1ConfigLight.L2ConfigLight.class);, +		ctx.getBean("l2Bean");, +, +		// ensure that override order is correct, +		assertThat(ctx.getBean("overrideBean", TestBean.class).getName(), is("override-l0"));, +	}, +, +	@Test, +	public void twoLevelsWithNoBeanMethods() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(L0ConfigEmpty.class);, +		ctx.refresh();, +, +		ctx.getBean(L0ConfigEmpty.class);, +		ctx.getBean(L0ConfigEmpty.L1ConfigEmpty.class);, +		ctx.getBean(L0ConfigEmpty.L1ConfigEmpty.L2ConfigEmpty.class);, +	}, +, +	@Component, +	static class L0ConfigLight {]