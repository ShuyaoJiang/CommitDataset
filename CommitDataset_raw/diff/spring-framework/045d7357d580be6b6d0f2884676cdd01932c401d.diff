[+++ b/spring-orm/src/main/java/org/springframework/orm/jpa/SharedEntityManagerCreator.java, +import java.util.HashSet;, +import java.util.Set;, +import javax.persistence.TransactionRequiredException;, +	private static final Set<String> transactionRequiringMethods = new HashSet<String>(6);, +, +	private static final Set<String> queryTerminationMethods = new HashSet<String>(3);, +, +	static {, +		transactionRequiringMethods.add("joinTransaction");, +		transactionRequiringMethods.add("flush");, +		transactionRequiringMethods.add("persist");, +		transactionRequiringMethods.add("merge");, +		transactionRequiringMethods.add("remove");, +		transactionRequiringMethods.add("refresh");, +, +		queryTerminationMethods.add("getResultList");, +		queryTerminationMethods.add("getSingleResult");, +		queryTerminationMethods.add("executeUpdate");, +	}, +, +			else if (transactionRequiringMethods.contains(method.getName())) {, +				// We need a transactional target now, according to the JPA spec., +				// Otherwise, the operation would get accepted but remain unflushed..., +				if (target == null) {, +					throw new TransactionRequiredException("No transactional EntityManager available");, +				}, +			}, +				if (queryTerminationMethods.contains(method.getName())) {, +++ b/spring-orm/src/main/java/org/springframework/orm/jpa/SharedEntityManagerCreator.java, +import java.util.HashSet;, +import java.util.Set;, +import javax.persistence.TransactionRequiredException;, +	private static final Set<String> transactionRequiringMethods = new HashSet<String>(6);, +, +	private static final Set<String> queryTerminationMethods = new HashSet<String>(3);, +, +	static {, +		transactionRequiringMethods.add("joinTransaction");, +		transactionRequiringMethods.add("flush");, +		transactionRequiringMethods.add("persist");, +		transactionRequiringMethods.add("merge");, +		transactionRequiringMethods.add("remove");, +		transactionRequiringMethods.add("refresh");, +, +		queryTerminationMethods.add("getResultList");, +		queryTerminationMethods.add("getSingleResult");, +		queryTerminationMethods.add("executeUpdate");, +	}, +, +			else if (transactionRequiringMethods.contains(method.getName())) {, +				// We need a transactional target now, according to the JPA spec., +				// Otherwise, the operation would get accepted but remain unflushed..., +				if (target == null) {, +					throw new TransactionRequiredException("No transactional EntityManager available");, +				}, +			}, +				if (queryTerminationMethods.contains(method.getName())) {, +++ b/spring-orm/src/test/java/org/springframework/orm/jpa/SharedEntityManagerCreatorTests.java, + * Copyright 2002-2014 the original author or authors., +import javax.persistence.EntityManager;, +import javax.persistence.TransactionRequiredException;, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnJoinTransaction() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);, +		EntityManager em = SharedEntityManagerCreator.createSharedEntityManager(emf);, +		em.joinTransaction();, +	}, +, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnFlush() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);, +		EntityManager em = SharedEntityManagerCreator.createSharedEntityManager(emf);, +		em.flush();, +	}, +, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnPersist() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);, +		EntityManager em = SharedEntityManagerCreator.createSharedEntityManager(emf);, +		em.persist(new Object());, +	}, +, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnMerge() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);, +		EntityManager em = SharedEntityManagerCreator.createSharedEntityManager(emf);, +		em.merge(new Object());, +	}, +, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnRemove() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);, +		EntityManager em = SharedEntityManagerCreator.createSharedEntityManager(emf);, +		em.remove(new Object());, +	}, +, +	@Test(expected = TransactionRequiredException.class), +	public void transactionRequiredExceptionOnRefresh() {, +		EntityManagerFactory emf = mock(EntityManagerFactory.class);]