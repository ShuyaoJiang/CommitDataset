[+++ b/spring-core/src/main/java/org/springframework/core/io/ClassPathResource.java, + * Copyright 2002-2012 the original author or authors., + * @author Sam Brannen, +			throw new FileNotFoundException(getDescription() + " cannot be opened because it does not exist");, +			throw new FileNotFoundException(getDescription() + " cannot be resolved to URL because it does not exist");, +		String pathToUse = path;, +, +		if (this.clazz != null && !pathToUse.startsWith("/")) {, +		if (pathToUse.startsWith("/")) {, +			pathToUse = pathToUse.substring(1);, +		}, +, +		builder.append(pathToUse);, +			return (this.path.equals(otherRes.path), +					&& ObjectUtils.nullSafeEquals(this.classLoader, otherRes.classLoader) && ObjectUtils.nullSafeEquals(, +				this.clazz, otherRes.clazz));, +++ b/spring-core/src/main/java/org/springframework/core/io/ClassPathResource.java, + * Copyright 2002-2012 the original author or authors., + * @author Sam Brannen, +			throw new FileNotFoundException(getDescription() + " cannot be opened because it does not exist");, +			throw new FileNotFoundException(getDescription() + " cannot be resolved to URL because it does not exist");, +		String pathToUse = path;, +, +		if (this.clazz != null && !pathToUse.startsWith("/")) {, +		if (pathToUse.startsWith("/")) {, +			pathToUse = pathToUse.substring(1);, +		}, +, +		builder.append(pathToUse);, +			return (this.path.equals(otherRes.path), +					&& ObjectUtils.nullSafeEquals(this.classLoader, otherRes.classLoader) && ObjectUtils.nullSafeEquals(, +				this.clazz, otherRes.clazz));, +++ b/spring-core/src/test/java/org/springframework/core/io/ClassPathResourceTests.java, + * Copyright 2002-2012 the original author or authors., +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, + * Unit tests that serve as regression tests for the bugs described in SPR-6888, + * and SPR-9413., + * @author Sam Brannen, +, +	private static final String NONEXISTENT_RESOURCE_NAME = "nonexistent.xml";, +	private static final String FQ_RESOURCE_PATH = PACKAGE_PATH + '/' + NONEXISTENT_RESOURCE_NAME;, +, +	/**, +	 * Absolute path version of {@link #FQ_RESOURCE_PATH}., +	 */, +	private static final String FQ_RESOURCE_PATH_WITH_LEADING_SLASH = '/' + FQ_RESOURCE_PATH;, +, +	private static final Pattern DESCRIPTION_PATTERN = Pattern.compile("^class path resource \\[(.+?)\\]$");, +, +, +	private void assertDescriptionContainsExpectedPath(ClassPathResource resource, String expectedPath) {, +		Matcher matcher = DESCRIPTION_PATTERN.matcher(resource.getDescription());, +		assertTrue(matcher.matches());, +		assertEquals(1, matcher.groupCount());, +		String match = matcher.group(1);, +, +		assertEquals(expectedPath, match);, +	}, +, +	private void assertExceptionContainsFullyQualifiedPath(ClassPathResource resource) {, +		try {, +			resource.getInputStream();, +			fail("FileNotFoundException expected for resource: " + resource);, +		}, +		catch (IOException ex) {, +			assertThat(ex, instanceOf(FileNotFoundException.class));, +			assertThat(ex.getMessage(), containsString(FQ_RESOURCE_PATH));, +		}, +	}, +		assertExceptionContainsFullyQualifiedPath(new ClassPathResource(NONEXISTENT_RESOURCE_NAME, this.getClass()));, +		assertExceptionContainsFullyQualifiedPath(new ClassPathResource(FQ_RESOURCE_PATH,, +			this.getClass().getClassLoader()));, +	@Test, +	public void getDescriptionWithStringConstructor() {, +		assertDescriptionContainsExpectedPath(new ClassPathResource(FQ_RESOURCE_PATH), FQ_RESOURCE_PATH);, +, +	@Test, +	public void getDescriptionWithStringConstructorAndLeadingSlash() {, +		assertDescriptionContainsExpectedPath(new ClassPathResource(FQ_RESOURCE_PATH_WITH_LEADING_SLASH),, +			FQ_RESOURCE_PATH);, +, +	@Test, +	public void getDescriptionWithClassLiteralConstructor() {, +		assertDescriptionContainsExpectedPath(new ClassPathResource(NONEXISTENT_RESOURCE_NAME, this.getClass()),, +			FQ_RESOURCE_PATH);, +	}, +, +	@Test, +	public void getDescriptionWithClassLiteralConstructorAndLeadingSlash() {, +		assertDescriptionContainsExpectedPath(, +			new ClassPathResource(FQ_RESOURCE_PATH_WITH_LEADING_SLASH, this.getClass()), FQ_RESOURCE_PATH);, +	}, +, +	@Test, +	public void getDescriptionWithClassLoaderConstructor() {, +		assertDescriptionContainsExpectedPath(, +			new ClassPathResource(FQ_RESOURCE_PATH, this.getClass().getClassLoader()), FQ_RESOURCE_PATH);]