[+++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java, +import java.util.EnumSet;, +import java.util.Set;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.http.HttpMethod;, +	private static final Set<HttpMethod> SUPPORTED_METHODS =, +			EnumSet.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);, +, +, +, +		MediaType contentType = request.getHeaders().getContentType();, +		MediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);, +					// Single-value (with or without reactive type wrapper), +		// No compatible reader but body may be empty.., +, +		HttpMethod method = request.getMethod();, +		if (contentType == null && method != null && SUPPORTED_METHODS.contains(method)) {, +			Flux<DataBuffer> body = request.getBody().doOnNext(o -> {, +				// Body not empty, back to 415.., +				throw new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes);, +			});, +			if (isBodyRequired || (adapter != null && !adapter.supportsEmpty())) {, +				body = body.switchIfEmpty(Mono.error(handleMissingBody(bodyParameter)));, +			}, +			return (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body));, +		}, +, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java, +import java.util.EnumSet;, +import java.util.Set;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.http.HttpMethod;, +	private static final Set<HttpMethod> SUPPORTED_METHODS =, +			EnumSet.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);, +, +, +, +		MediaType contentType = request.getHeaders().getContentType();, +		MediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);, +					// Single-value (with or without reactive type wrapper), +		// No compatible reader but body may be empty.., +, +		HttpMethod method = request.getMethod();, +		if (contentType == null && method != null && SUPPORTED_METHODS.contains(method)) {, +			Flux<DataBuffer> body = request.getBody().doOnNext(o -> {, +				// Body not empty, back to 415.., +				throw new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes);, +			});, +			if (isBodyRequired || (adapter != null && !adapter.supportsEmpty())) {, +				body = body.switchIfEmpty(Mono.error(handleMissingBody(bodyParameter)));, +			}, +			return (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body));, +		}, +, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/MessageReaderArgumentResolverTests.java, +	@SuppressWarnings("unchecked"), +		Mono<TestBean> value = (Mono<TestBean>) result.block(Duration.ofSeconds(1));, +		StepVerifier.create(value).expectError(UnsupportedMediaTypeStatusException.class).verify();, +++ b/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java, +import java.util.EnumSet;, +import java.util.Set;, +import org.springframework.core.io.buffer.DataBuffer;, +import org.springframework.http.HttpMethod;, +	private static final Set<HttpMethod> SUPPORTED_METHODS =, +			EnumSet.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);, +, +, +, +		MediaType contentType = request.getHeaders().getContentType();, +		MediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);, +					// Single-value (with or without reactive type wrapper), +		// No compatible reader but body may be empty.., +, +		HttpMethod method = request.getMethod();, +		if (contentType == null && method != null && SUPPORTED_METHODS.contains(method)) {, +			Flux<DataBuffer> body = request.getBody().doOnNext(o -> {, +				// Body not empty, back to 415.., +				throw new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes);, +			});, +			if (isBodyRequired || (adapter != null && !adapter.supportsEmpty())) {, +				body = body.switchIfEmpty(Mono.error(handleMissingBody(bodyParameter)));, +			}, +			return (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body));, +		}, +, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/MessageReaderArgumentResolverTests.java, +	@SuppressWarnings("unchecked"), +		Mono<TestBean> value = (Mono<TestBean>) result.block(Duration.ofSeconds(1));, +		StepVerifier.create(value).expectError(UnsupportedMediaTypeStatusException.class).verify();, +++ b/spring-webflux/src/test/java/org/springframework/web/reactive/result/method/annotation/RequestBodyArgumentResolverTests.java, +import java.util.Map;, +	@Test // SPR-15758, +	public void emptyBodyWithoutContentType() throws Exception {, +		MethodParameter param = this.testMethod.annot(requestBody().notRequired()).arg(Map.class);, +		String body = resolveValueWithEmptyBody(param);, +, +		assertNull(body);, +	}, +, +			@RequestBody(required = false) Map<?, ?> mapNotRequired,]