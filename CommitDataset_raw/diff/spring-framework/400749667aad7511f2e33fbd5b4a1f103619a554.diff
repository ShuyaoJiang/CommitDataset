[+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.java, + * Copyright 2002-2015 the original author or authors., +, +		private void appendTypes(StringBuilder sb, Class<?>[] types, boolean includeArgs,, +				boolean useLongReturnAndArgumentTypeName) {, +, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.java, + * Copyright 2002-2015 the original author or authors., +, +		private void appendTypes(StringBuilder sb, Class<?>[] types, boolean includeArgs,, +				boolean useLongReturnAndArgumentTypeName) {, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +		return (!types.isEmpty() ? types : null);, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +				return (found && metaDepth > 0 ? Boolean.TRUE : CONTINUE);, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +, +		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);, +		return (attributes != null ?, +				AnnotationUtils.synthesizeAnnotation(attributes, (Class<A>) attributes.annotationType(), element) : null);, +		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);, +		return (!attributesMap.isEmpty() ? attributesMap : null);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +				result = searchWithGetSemanticsInAnnotations(, +						element, inheritedAnnotations, annotationName, processor, visited, metaDepth);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +			if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation) &&, +					(annotation.annotationType().getName().equals(annotationName) || metaDepth > 0)) {, +				T result = searchWithGetSemantics(, +						annotation.annotationType(), annotationName, processor, visited, metaDepth + 1);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +							Method equivalentMethod = clazz.getDeclaredMethod(method.getName(), method.getParameterTypes());, +							result = searchWithFindSemantics(, +									resolvedEquivalentMethod, annotationName, processor, visited, metaDepth);, +, +	private interface Processor<T> {, +, +			// no-op, +, +		private final boolean classValuesAsString;, +, +		private final boolean nestedAnnotationsAsMap;, +, +			Object adaptedValue = AnnotationUtils.adaptValue(, +					element, value, this.classValuesAsString, this.nestedAnnotationsAsMap);, +++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.java, + * Copyright 2002-2015 the original author or authors., +, +		private void appendTypes(StringBuilder sb, Class<?>[] types, boolean includeArgs,, +				boolean useLongReturnAndArgumentTypeName) {, +, +++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +		return (!types.isEmpty() ? types : null);, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +				return (found && metaDepth > 0 ? Boolean.TRUE : CONTINUE);, +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +, +		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);, +		return (attributes != null ?, +				AnnotationUtils.synthesizeAnnotation(attributes, (Class<A>) attributes.annotationType(), element) : null);, +		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);, +		return (!attributesMap.isEmpty() ? attributesMap : null);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +				result = searchWithGetSemanticsInAnnotations(, +						element, inheritedAnnotations, annotationName, processor, visited, metaDepth);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +			if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation) &&, +					(annotation.annotationType().getName().equals(annotationName) || metaDepth > 0)) {, +				T result = searchWithGetSemantics(, +						annotation.annotationType(), annotationName, processor, visited, metaDepth + 1);, +	 * {@link Processor#process process()} method of the {@link Processor} API., +		Assert.hasLength(annotationName, "annotationName must not be null or empty");, +							Method equivalentMethod = clazz.getDeclaredMethod(method.getName(), method.getParameterTypes());, +							result = searchWithFindSemantics(, +									resolvedEquivalentMethod, annotationName, processor, visited, metaDepth);, +, +	private interface Processor<T> {, +, +			// no-op, +, +		private final boolean classValuesAsString;, +, +		private final boolean nestedAnnotationsAsMap;, +, +			Object adaptedValue = AnnotationUtils.adaptValue(, +					element, value, this.classValuesAsString, this.nestedAnnotationsAsMap);, +++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ResponseBodyEmitter.java, + * where one or more objects are written to the response., + *, + * <p>While {@link org.springframework.web.context.request.async.DeferredResult}, + * {@link org.springframework.http.converter.HttpMessageConverter}., + * {@link org.springframework.http.ResponseEntity}., +	 * Invoked after the response is updated with the status code and headers,, +	 * if the ResponseBodyEmitter is wrapped in a ResponseEntity, but before the]