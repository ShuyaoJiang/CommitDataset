[+++ b/spring-web-reactive/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.function.Supplier;, +, +import reactor.rx.Stream;, +import org.springframework.util.Assert;, +, +	private AtomicReference<State> state = new AtomicReference<>(State.NEW);, +, +	private final List<Supplier<? extends Mono<Void>>> beforeCommitActions = new ArrayList<>(4);, +		if (State.COMITTED.equals(this.state.get())) {, +			return HttpHeaders.readOnlyHttpHeaders(this.headers);, +		}, +		return this.headers;, +		return Flux.from(publisher), +				.lift(new WriteWithOperator<>(writePublisher ->, +						applyBeforeCommit().after(() -> setBodyInternal(writePublisher)))), +				.after();, +	private Mono<Void> applyBeforeCommit() {, +		return Stream.defer(() -> {, +			Mono<Void> mono = Mono.empty();, +			if (this.state.compareAndSet(State.NEW, State.COMMITTING)) {, +				for (Supplier<? extends Mono<Void>> action : this.beforeCommitActions) {, +					mono = mono.after(() -> action.get());, +				}, +				mono = mono.otherwise(ex -> {, +					// Ignore errors from beforeCommit actions, +					return Mono.empty();, +				});, +				mono = mono.after(() -> {, +					this.state.set(State.COMITTED);, +					writeHeaders();, +					writeCookies();, +					return Mono.empty();, +				});, +			}, +			return mono;, +		}).after();, +	}, +, +	/**, +	 * Implement this method to apply header changes from {@link #getHeaders()}, +	 * to the underlying response. This method is called once only., +	 */, +	protected abstract void writeHeaders();, +, +	/**, +	 * Implement this method to add cookies from {@link #getHeaders()} to the, +	 * underlying response. This method is called once only., +	 */, +	protected abstract void writeCookies();, +, +	public void beforeCommit(Supplier<? extends Mono<Void>> action) {, +		Assert.notNull(action);, +		this.beforeCommitActions.add(action);, +	@Override, +	public Mono<Void> setComplete() {, +		return applyBeforeCommit();, +	}, +, +	private enum State { NEW, COMMITTING, COMITTED }, +++ b/spring-web-reactive/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.function.Supplier;, +, +import reactor.rx.Stream;, +import org.springframework.util.Assert;, +, +	private AtomicReference<State> state = new AtomicReference<>(State.NEW);, +, +	private final List<Supplier<? extends Mono<Void>>> beforeCommitActions = new ArrayList<>(4);, +		if (State.COMITTED.equals(this.state.get())) {, +			return HttpHeaders.readOnlyHttpHeaders(this.headers);, +		}, +		return this.headers;, +		return Flux.from(publisher), +				.lift(new WriteWithOperator<>(writePublisher ->, +						applyBeforeCommit().after(() -> setBodyInternal(writePublisher)))), +				.after();, +	private Mono<Void> applyBeforeCommit() {, +		return Stream.defer(() -> {, +			Mono<Void> mono = Mono.empty();, +			if (this.state.compareAndSet(State.NEW, State.COMMITTING)) {, +				for (Supplier<? extends Mono<Void>> action : this.beforeCommitActions) {, +					mono = mono.after(() -> action.get());, +				}, +				mono = mono.otherwise(ex -> {, +					// Ignore errors from beforeCommit actions, +					return Mono.empty();, +				});, +				mono = mono.after(() -> {, +					this.state.set(State.COMITTED);, +					writeHeaders();, +					writeCookies();, +					return Mono.empty();, +				});]