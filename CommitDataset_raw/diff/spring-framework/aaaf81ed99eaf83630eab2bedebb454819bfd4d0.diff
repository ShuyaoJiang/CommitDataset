[+++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}., +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}., +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferFactory.java, + * A factory for {@link DataBuffer DataBuffers}, allowing for allocation and, + * wrapping of data buffers., +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}., +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferFactory.java, + * A factory for {@link DataBuffer DataBuffers}, allowing for allocation and, + * wrapping of data buffers., +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}., +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferFactory.java, + * A factory for {@link DataBuffer DataBuffers}, allowing for allocation and, + * wrapping of data buffers., +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +			write(Arrays.stream(buffers).map(DataBuffer::asByteBuffer).toArray(ByteBuffer[]::new));, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}., +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferFactory.java, + * A factory for {@link DataBuffer DataBuffers}, allowing for allocation and, + * wrapping of data buffers., +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java, +	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DefaultDataBuffer.java, +			write(Arrays.stream(buffers).map(DataBuffer::asByteBuffer).toArray(ByteBuffer[]::new));, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DefaultDataBufferFactory.java, +		return DefaultDataBuffer.fromFilledByteBuffer(this, byteBuffer.slice());, +		return DefaultDataBuffer.fromFilledByteBuffer(this, ByteBuffer.wrap(bytes));, +	 * <p>This implementation creates a single {@link DefaultDataBuffer}, +	 * to contain the data in {@code dataBuffers}., +		Assert.notEmpty(dataBuffers, "DataBuffer List must not be empty");, +		int capacity = dataBuffers.stream().mapToInt(DataBuffer::readableByteCount).sum();, +, +++ b/spring-core/src/main/java/org/springframework/core/io/buffer/DataBuffer.java, + * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s, + * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}, + * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,, + * the following invariant holds for the read and write positions, and the capacity:, + * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but, + * can also be used on non-Netty platforms (i.e. Servlet containers)., +	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between, +	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though, +	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}, +	 * when the input stream is {@linkplain InputStream#close() closed}.]