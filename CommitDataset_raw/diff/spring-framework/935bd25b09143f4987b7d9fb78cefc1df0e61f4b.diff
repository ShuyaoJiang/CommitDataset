[+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	 * Return the configuration class that imported this class,, +	 * or {@code null} if this configuration was not imported., +		return Collections.unmodifiableSet(this.importBeanDefinitionRegistrars);, +		return "ConfigurationClass:beanName=" + this.beanName + ",resource=" + this.resource;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	 * Return the configuration class that imported this class,, +	 * or {@code null} if this configuration was not imported., +		return Collections.unmodifiableSet(this.importBeanDefinitionRegistrars);, +		return "ConfigurationClass:beanName=" + this.beanName + ",resource=" + this.resource;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +, +		// -> allow the current bean method to override, since both are at second-pass level., +		// However, if the bean method is an overloaded case on the same configuration class,, +		// preserve the existing bean definition., +			ConfigurationClassBeanDefinition ccbd = (ConfigurationClassBeanDefinition) existingBeanDef;, +			return (ccbd.getMetadata().getClassName().equals(beanMethod.getConfigurationClass().getMetadata().getClassName()));, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClass.java, +	 * Return the configuration class that imported this class,, +	 * or {@code null} if this configuration was not imported., +		return Collections.unmodifiableSet(this.importBeanDefinitionRegistrars);, +		return "ConfigurationClass:beanName=" + this.beanName + ",resource=" + this.resource;, +++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java, +, +		// -> allow the current bean method to override, since both are at second-pass level., +		// However, if the bean method is an overloaded case on the same configuration class,, +		// preserve the existing bean definition., +			ConfigurationClassBeanDefinition ccbd = (ConfigurationClassBeanDefinition) existingBeanDef;, +			return (ccbd.getMetadata().getClassName().equals(beanMethod.getConfigurationClass().getMetadata().getClassName()));, +++ b/spring-context/src/test/java/org/springframework/context/annotation/BeanMethodPolymorphismTests.java, + * @author Juergen Hoeller, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithOverloading.class);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertThat(ctx.getBean(String.class), equalTo("regular"));, +	@Test, +	public void beanMethodOverloadingWithoutInheritanceAndExtraDependency() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithOverloading.class);, +		ctx.getDefaultListableBeanFactory().registerSingleton("anInt", 5);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertThat(ctx.getBean(String.class), equalTo("overloaded5"));, +	}, +, +	@Test, +	public void beanMethodOverloadingWithAdditionalMetadata() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithOverloadingAndAdditionalMetadata.class);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertFalse(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +		assertThat(ctx.getBean(String.class), equalTo("regular"));, +		assertTrue(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +	}, +, +	@Test, +	public void beanMethodOverloadingWithAdditionalMetadataButOtherMethodExecuted() {, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(ConfigWithOverloadingAndAdditionalMetadata.class);, +		ctx.getDefaultListableBeanFactory().registerSingleton("anInt", 5);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertFalse(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +		assertThat(ctx.getBean(String.class), equalTo("overloaded5"));, +		assertTrue(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(SubConfig.class);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertFalse(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +		assertTrue(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +	// SPR-11025, +		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();, +		ctx.register(SubConfigWithList.class);, +		ctx.setAllowBeanDefinitionOverriding(false);, +		ctx.refresh();, +		assertFalse(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +		assertTrue(ctx.getDefaultListableBeanFactory().containsSingleton("aString"));, +	static class ConfigWithOverloading {, +, +		@Bean, +		String aString() {, +			return "regular";, +		}, +, +		@Bean, +		String aString(Integer dependency) {, +			return "overloaded" + dependency;, +		}, +	}, +, +, +	@Configuration, +	static class ConfigWithOverloadingAndAdditionalMetadata {, +, +		@Bean @Lazy, +		String aString() {, +			return "regular";]