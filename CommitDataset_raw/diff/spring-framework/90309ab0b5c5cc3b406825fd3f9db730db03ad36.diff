[+++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +			validateClassIfNecessary(proxySuperClass, classLoader);, +	private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {, +		if (logger.isInfoEnabled()) {, +					doValidateClass(proxySuperClass, proxyClassLoader);, +	 * Checks for final methods on the given {@code Class}, as well as package-visible, +	 * methods across ClassLoaders, and writes warnings to the log for each one found., +	private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {, +		if (!Object.class.equals(proxySuperClass)) {, +			Method[] methods = proxySuperClass.getDeclaredMethods();, +				int mod = method.getModifiers();, +				if (!Modifier.isStatic(mod)) {, +					if (Modifier.isFinal(mod)) {, +						logger.info("Unable to proxy method [" + method + "] because it is final: " +, +								"All calls to this method via a proxy will NOT be routed to the target instance.");, +					}, +					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&, +							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {, +						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +, +								"across different ClassLoaders: All calls to this method via a proxy will " +, +								"NOT be routed to the target instance.");, +			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader);, +		}, +		private final AdvisedSupport advised;, +				// May be null. Get as late as possible to minimize the time we, +				// "own" the target, in case it comes from a pool..., +		private final boolean publicMethod;, +			this.publicMethod = Modifier.isPublic(method.getModifiers());, +			if (this.publicMethod) {, +				return this.methodProxy.invoke(this.target, this.arguments);, +				return super.invokeJoinpoint();, +				// correct one is already configured. If the target is not static, then, +				// cannot use a dispatcher because the target cannot be released., +++ b/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java, +			validateClassIfNecessary(proxySuperClass, classLoader);, +	private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {, +		if (logger.isInfoEnabled()) {, +					doValidateClass(proxySuperClass, proxyClassLoader);, +	 * Checks for final methods on the given {@code Class}, as well as package-visible, +	 * methods across ClassLoaders, and writes warnings to the log for each one found., +	private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {, +		if (!Object.class.equals(proxySuperClass)) {, +			Method[] methods = proxySuperClass.getDeclaredMethods();, +				int mod = method.getModifiers();, +				if (!Modifier.isStatic(mod)) {, +					if (Modifier.isFinal(mod)) {, +						logger.info("Unable to proxy method [" + method + "] because it is final: " +, +								"All calls to this method via a proxy will NOT be routed to the target instance.");, +					}, +					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&, +							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {, +						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +, +								"across different ClassLoaders: All calls to this method via a proxy will " +, +								"NOT be routed to the target instance.");, +			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader);, +		}, +		private final AdvisedSupport advised;, +				// May be null. Get as late as possible to minimize the time we, +				// "own" the target, in case it comes from a pool..., +		private final boolean publicMethod;, +			this.publicMethod = Modifier.isPublic(method.getModifiers());, +			if (this.publicMethod) {, +				return this.methodProxy.invoke(this.target, this.arguments);, +				return super.invokeJoinpoint();, +				// correct one is already configured. If the target is not static, then, +				// cannot use a dispatcher because the target cannot be released., +++ b/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java, +		bean.value = "foo";, +		ProtectedMethodTestBean proxy = (ProtectedMethodTestBean) aop.getProxy();, +		assertEquals(proxy.getClass().getClassLoader(), bean.getClass().getClassLoader());, +		assertEquals("foo", proxy.getString());, +	}, +, +	@Test, +	public void testPackageMethodInvocation() {, +		PackageMethodTestBean bean = new PackageMethodTestBean();, +		bean.value = "foo";, +		mockTargetSource.setTarget(bean);, +, +		AdvisedSupport as = new AdvisedSupport(new Class<?>[]{});, +		as.setTargetSource(mockTargetSource);, +		as.addAdvice(new NopInterceptor());, +		AopProxy aop = new CglibAopProxy(as);, +, +		PackageMethodTestBean proxy = (PackageMethodTestBean) aop.getProxy();, +		assertTrue(AopUtils.isCglibProxy(proxy));, +		assertEquals(proxy.getClass().getClassLoader(), bean.getClass().getClassLoader());, +		assertEquals("foo", proxy.getString());, +	}, +, +	@Test, +	public void testPackageMethodInvocationWithDifferentClassLoader() {, +		ClassLoader child = new ClassLoader(getClass().getClassLoader()) {, +		};, +, +		PackageMethodTestBean bean = new PackageMethodTestBean();, +		bean.value = "foo";, +		mockTargetSource.setTarget(bean);, +, +		AdvisedSupport as = new AdvisedSupport(new Class<?>[]{});]