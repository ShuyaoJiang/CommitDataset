[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Autowired.java, + * Marks a constructor, field, setter method or config method as to be autowired, + * by Spring's dependency injection facilities., + * <p>Only one constructor (at max) of any given bean class may carry this annotation,, + * indicating the constructor to autowire when used as a Spring bean. Such a, + * constructor does not have to be public., + * <p>Fields are injected right after construction of a bean, before any config, + * methods are invoked. Such a config field does not have to be public., + * <p>Config methods may have an arbitrary name and any number of arguments; each of, + * those arguments will be autowired with a matching bean in the Spring container., + * Bean property setter methods are effectively just a special case of such a general, + * config method. Such config methods do not have to be public., + * <p>In the case of a multi-arg constructor or method, the 'required' parameter is, + * applicable to all arguments. Individual parameters may be declared as Java-8-style, + * {@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable}, + * or a not-null parameter type in Kotlin, overriding the base required semantics., + * <p>In case of a {@link java.util.Collection} or {@link java.util.Map} dependency type,, + * the container autowires all beans matching the declared value type. For such purposes,, + * the map keys must be declared as type String which will be resolved to the corresponding, + * bean names. Such a container-provided collection will be ordered, taking into account, + * {@link org.springframework.core.Ordered}/{@link org.springframework.core.annotation.Order}, + * values of the target components, otherwise following their registration order in the, + * container. Alternatively, a single matching target bean may also be a generally typed, + * {@code Collection} or {@code Map} itself, getting injected as such., +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Autowired.java, + * Marks a constructor, field, setter method or config method as to be autowired, + * by Spring's dependency injection facilities., + * <p>Only one constructor (at max) of any given bean class may carry this annotation,, + * indicating the constructor to autowire when used as a Spring bean. Such a, + * constructor does not have to be public., + * <p>Fields are injected right after construction of a bean, before any config, + * methods are invoked. Such a config field does not have to be public., + * <p>Config methods may have an arbitrary name and any number of arguments; each of, + * those arguments will be autowired with a matching bean in the Spring container., + * Bean property setter methods are effectively just a special case of such a general, + * config method. Such config methods do not have to be public., + * <p>In the case of a multi-arg constructor or method, the 'required' parameter is, + * applicable to all arguments. Individual parameters may be declared as Java-8-style, + * {@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable}, + * or a not-null parameter type in Kotlin, overriding the base required semantics., + * <p>In case of a {@link java.util.Collection} or {@link java.util.Map} dependency type,, + * the container autowires all beans matching the declared value type. For such purposes,, + * the map keys must be declared as type String which will be resolved to the corresponding, + * bean names. Such a container-provided collection will be ordered, taking into account, + * {@link org.springframework.core.Ordered}/{@link org.springframework.core.annotation.Order}, + * values of the target components, otherwise following their registration order in the, + * container. Alternatively, a single matching target bean may also be a generally typed, + * {@code Collection} or {@code Map} itself, getting injected as such., +++ b/spring-context/src/main/java/org/springframework/context/annotation/Bean.java, + * <h3>Profile, Scope, Lazy, DependsOn, Primary, Order</h3>, + * <p>Note that the {@code @Bean} annotation does not provide attributes for profile,, + * scope, lazy, depends-on or primary. Rather, it should be used in conjunction with, + * {@link Scope @Scope}, {@link Lazy @Lazy}, {@link DependsOn @DependsOn} and, + * {@link Primary @Primary} annotations to declare those semantics. For example:, + *     &#064;Profile("production"), + * The semantics of the above-mentioned annotations match their use at the component, + * class level: {@code Profile} allows for selective inclusion of certain beans., + * {@code @Scope} changes the bean's scope from singleton to the specified scope., + * {@code @Lazy} only has an actual effect in case of the default singleton scope., + * {@code @DependsOn} enforces the creation of specific other beans before this, + * bean will be created, in addition to any dependencies that the bean expressed, + * through direct references, which is typically helpful for singleton startup., + * {@code @Primary} is a mechanism to resolve ambiguity at the injection point level, + * if a single target component needs to be injected but several beans match by type., + *, + * <p>Additionally, {@code @Bean} methods may also declare qualifier annotations, + * and {@link org.springframework.core.annotation.Order @Order} values, to be, + * taken into account during injection point resolution just like corresponding, + * annotations on the corresponding component classes but potentially being very, + * individual per bean definition (in case of multiple definitions with the same, + * bean class). Qualifiers narrow the set of candidates after the initial type match;, + * order values determine the order of resolved elements in case of collection, + * injection points (with several target beans matching by type and qualifier)., + *, + * <p><b>NOTE:</b> {@code @Order} values may influence priorities at injection points, + * but please be aware that they do not influence singleton startup order which is an, + * orthogonal concern determined by dependency relationships and {@code @DependsOn}, + * declarations as mentioned above. Also, {@link javax.annotation.Priority} is not, + * available at this level since it cannot be declared on methods; its semantics can, + * be modelled through {@code @Order} values in combination with {@code @Primary} on, + * a single bean per type., + *, + * <p>See the @{@link Configuration} javadoc for further details including how to bootstrap, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Autowired.java, + * Marks a constructor, field, setter method or config method as to be autowired, + * by Spring's dependency injection facilities., + * <p>Only one constructor (at max) of any given bean class may carry this annotation,, + * indicating the constructor to autowire when used as a Spring bean. Such a, + * constructor does not have to be public., + * <p>Fields are injected right after construction of a bean, before any config, + * methods are invoked. Such a config field does not have to be public., + * <p>Config methods may have an arbitrary name and any number of arguments; each of, + * those arguments will be autowired with a matching bean in the Spring container., + * Bean property setter methods are effectively just a special case of such a general, + * config method. Such config methods do not have to be public., + * <p>In the case of a multi-arg constructor or method, the 'required' parameter is, + * applicable to all arguments. Individual parameters may be declared as Java-8-style, + * {@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable}, + * or a not-null parameter type in Kotlin, overriding the base required semantics., + * <p>In case of a {@link java.util.Collection} or {@link java.util.Map} dependency type,]