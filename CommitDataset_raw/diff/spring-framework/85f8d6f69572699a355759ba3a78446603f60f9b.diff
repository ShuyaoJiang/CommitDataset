[+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +	/** Map of singleton and non-singleton bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +	/** Map of singleton-only bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +		Map<Class<?>, String[]> cache =, +				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);, +		// Remove any assumptions about by-type mappings., +		clearByTypeCache();, +	@Override, +	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {, +		super.registerSingleton(beanName, singletonObject);, +		clearByTypeCache();, +	}, +, +	@Override, +	public void destroySingleton(String beanName) {, +		super.destroySingleton(beanName);, +		clearByTypeCache();, +	}, +, +	/**, +	 * Remove any assumptions about by-type mappings., +	 */, +	private void clearByTypeCache() {, +		this.allBeanNamesByType.clear();, +		this.singletonBeanNamesByType.clear();, +	}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +	/** Map of singleton and non-singleton bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +	/** Map of singleton-only bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +		Map<Class<?>, String[]> cache =, +				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);, +		// Remove any assumptions about by-type mappings., +		clearByTypeCache();, +	@Override, +	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {, +		super.registerSingleton(beanName, singletonObject);, +		clearByTypeCache();, +	}, +, +	@Override, +	public void destroySingleton(String beanName) {, +		super.destroySingleton(beanName);, +		clearByTypeCache();, +	}, +, +	/**, +	 * Remove any assumptions about by-type mappings., +	 */, +	private void clearByTypeCache() {, +		this.allBeanNamesByType.clear();, +		this.singletonBeanNamesByType.clear();, +	}, +, +++ b/spring-context/src/main/java/org/springframework/context/support/AbstractMessageSource.java, + * Copyright 2002-2013 the original author or authors., +import java.util.Properties;, +	private Properties commonMessages;, +, +	 * Specify locale-independent common messages, with the message code as key, +	 * and the full message String (may contain argument placeholders) as value., +	 * <p>May also link to an externally defined Properties object, e.g. defined, +	 * through a {@link org.springframework.beans.factory.config.PropertiesFactoryBean}., +	 */, +	public void setCommonMessages(Properties commonMessages) {, +		this.commonMessages = commonMessages;, +	}, +, +	/**, +	 * Return a Properties object defining locale-independent common messages, if any., +	 */, +	protected Properties getCommonMessages() {, +		return this.commonMessages;, +	}, +, +	/**, +		// Check locale-independent common messages for the given message code., +		Properties commonMessages = getCommonMessages();, +		if (commonMessages != null) {, +			String commonMessage = commonMessages.getProperty(code);, +			if (commonMessage != null) {, +				return formatMessage(commonMessage, args, locale);, +			}, +		}, +, +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java, +	/** Map of singleton and non-singleton bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +	/** Map of singleton-only bean names keyed by dependency type */, +	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);, +		Map<Class<?>, String[]> cache =, +				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);, +		// Remove any assumptions about by-type mappings., +		clearByTypeCache();, +	@Override, +	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {]