[+++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.util.concurrent.atomic.AtomicBoolean;, +		public void handleFailure(Throwable ex) {, +			if (this.tcpConnection == null) {, +				return;, +			}, +			handleTcpConnectionFailure("Closing connection after TCP failure", ex);, +		}, +, +		@Override, +		/**, +		 * Forward the given message to the STOMP broker., +		 *, +		 * <p>The method checks whether we have an active TCP connection and have, +		 * received the STOMP CONNECTED frame. For client messages this should be, +		 * false only if we lose the TCP connection around the same time when a, +		 * client message is being forwarded, so we simply log the ignored message, +		 * at trace level. For messages from within the application being sent on, +		 * the "system" connection an exception is raised so that components sending, +		 * the message have a chance to handle it -- by default the broker message, +		 * channel is synchronous., +		 *, +		 * <p>Note that if messages arrive concurrently around the same time a TCP, +		 * connection is lost, there is a brief period of time before the connection, +		 * is reset when one or more messages may sneak through and an attempt made, +		 * to forward them. Rather than synchronizing to guard against that, this, +		 * method simply lets them try and fail. For client sessions that may, +		 * result in an additional STOMP ERROR frame(s) being sent downstream but, +		 * code handling that downstream should be idempotent in such cases., +		 *, +		 * @param message the message to send, never {@code null}, +		 * @return a future to wait for the result, +		 */, +		@SuppressWarnings("unchecked"), +			TcpConnection<byte[]> conn = this.tcpConnection;, +, +					if (logger.isTraceEnabled()) {, +						logger.trace("Ignoring client message received " + message +, +								(conn != null ? "before CONNECTED frame" : "after TCP connection closed"));, +					return EMPTY_TASK;, +							(conn != null ? "before STOMP CONNECTED frame" : "while inactive") +, +			ListenableFuture<Void> future = conn.send((Message<byte[]>) message);, +					if (tcpConnection == null) {, +						// already reset, +					}, +					else {, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java, +import java.util.concurrent.atomic.AtomicBoolean;, +		public void handleFailure(Throwable ex) {, +			if (this.tcpConnection == null) {, +				return;, +			}, +			handleTcpConnectionFailure("Closing connection after TCP failure", ex);, +		}, +, +		@Override, +		/**, +		 * Forward the given message to the STOMP broker., +		 *, +		 * <p>The method checks whether we have an active TCP connection and have, +		 * received the STOMP CONNECTED frame. For client messages this should be, +		 * false only if we lose the TCP connection around the same time when a, +		 * client message is being forwarded, so we simply log the ignored message, +		 * at trace level. For messages from within the application being sent on, +		 * the "system" connection an exception is raised so that components sending, +		 * the message have a chance to handle it -- by default the broker message, +		 * channel is synchronous., +		 *, +		 * <p>Note that if messages arrive concurrently around the same time a TCP, +		 * connection is lost, there is a brief period of time before the connection, +		 * is reset when one or more messages may sneak through and an attempt made, +		 * to forward them. Rather than synchronizing to guard against that, this, +		 * method simply lets them try and fail. For client sessions that may, +		 * result in an additional STOMP ERROR frame(s) being sent downstream but, +		 * code handling that downstream should be idempotent in such cases., +		 *, +		 * @param message the message to send, never {@code null}, +		 * @return a future to wait for the result, +		 */, +		@SuppressWarnings("unchecked"), +			TcpConnection<byte[]> conn = this.tcpConnection;, +, +					if (logger.isTraceEnabled()) {, +						logger.trace("Ignoring client message received " + message +, +								(conn != null ? "before CONNECTED frame" : "after TCP connection closed"));, +					return EMPTY_TASK;, +							(conn != null ? "before STOMP CONNECTED frame" : "while inactive") +, +			ListenableFuture<Void> future = conn.send((Message<byte[]>) message);, +					if (tcpConnection == null) {, +						// already reset, +					}, +					else {, +				}, +++ b/spring-messaging/src/main/java/org/springframework/messaging/tcp/TcpConnectionHandler.java, +	 * Invoked on failure to connect., +	 * Handle a failure on the connection., +	 * @param ex the exception, +	 */, +	void handleFailure(Throwable ex);]