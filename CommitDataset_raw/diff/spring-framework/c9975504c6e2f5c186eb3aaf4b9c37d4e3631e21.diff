[+++ b/org.springframework.core/src/main/java/org/springframework/core/LocalVariableTableParameterNameDiscoverer.java, +import java.util.Collections;, + * instance caches the ASM discovered information for each introspected Class, in a, + * @author Costin Leau, +	// the cache uses a nested index (value is a map) to keep the top level cache relatively small in size, +	private final Map<Class<?>, Map<Member, String[]>> parameterNamesCache = new ConcurrentHashMap<Class<?>, Map<Member, String[]>>();, +	// marker object for members that have been visited yet no params have been discovered for it, +	private static final String[] EMPTY_NAMES_ARRAY = new String[0];, +	// marker object for classes that do not have any debug info, +	private static final Map<Member, String[]> EMPTY_MAP = Collections.emptyMap();, +		Class<?> declaringClass = method.getDeclaringClass();, +		Map<Member, String[]> map = parameterNamesCache.get(declaringClass);, +		if (map == null) {, +			// initialize cache, +			map = cacheClass(declaringClass);, +		if (map != EMPTY_MAP) {, +			String[] paramNames = map.get(method);, +			return (paramNames == EMPTY_NAMES_ARRAY ? null : paramNames);, +		return null;, +	@SuppressWarnings("unchecked"), +		Class<?> declaringClass = ctor.getDeclaringClass();, +		Map<Member, String[]> map = parameterNamesCache.get(declaringClass);, +		if (map == null) {, +			// initialize cache, +			map = cacheClass(declaringClass);, +		String[] paramNames = map.get(ctor);, +		return (paramNames == EMPTY_NAMES_ARRAY ? null : paramNames);, +	 * Caches the results of the introspected class. Exceptions will be logged and swallowed., +	 * , +	 * @param declaringClass class about to be inspected, +	 * @return cached value, +	private Map<Member, String[]> cacheClass(Class<?> clazz) {, +			// We couldn't load the class file, which is not fatal as it, +			// simply means this method of discovering parameter names won't work., +			if (logger.isDebugEnabled()) {, +				logger.debug("Cannot find '.class' file for class [" + clazz, +						+ "] - unable to determine constructors/methods parameter names");, +			return Collections.emptyMap();, +		}, +, +			ClassReader classReader = new ClassReader(is);, +			Map<Member, String[]> map = new ConcurrentHashMap<Member, String[]>();, +			classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), false);, +			return map;, +		} catch (IOException ex) {, +			if (logger.isDebugEnabled()) {, +				logger.debug("Exception thrown while reading '.class' file for class [" + clazz, +						+ "] - unable to determine constructors/methods parameter names", ex);, +		} finally {, +			try {, +			} catch (IOException ex) {, +				// ignore, +		return Collections.emptyMap();, +	}, +	 * Helper class that inspects all methods (constructor included) and then, +	private static class ParameterNameDiscoveringVisitor extends EmptyVisitor {, +		private final Class<?> clazz;, +		private final Map<Member, String[]> memberMap;, +		private static final String STATIC_CLASS_INIT = "<clinit>";, +		public ParameterNameDiscoveringVisitor(Class<?> clazz, Map<Member, String[]> memberMap) {, +			this.clazz = clazz;, +			this.memberMap = memberMap;, +		}, +		@Override, +		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {, +			// exclude synthetic + bridged && static class initialization, +			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {, +				return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));, +			}, +			return null;, +		}, +, +		private static boolean isSyntheticOrBridged(int access) {, +			return (((access & Opcodes.ACC_SYNTHETIC) | (access & Opcodes.ACC_BRIDGE)) > 0);, +		}, +, +		private static boolean isStatic(int access) {, +			return ((access & Opcodes.ACC_STATIC) > 0);, +		}, +	}, +, +	private static class LocalVariableTableVisitor extends EmptyVisitor {, +, +		private static final String CONSTRUCTOR = "<init>";, +, +		private final Class<?> clazz;, +		private final Map<Member, String[]> memberMap;, +		private final String name;, +		private final Type[] args;, +		private final boolean isStatic;, +, +		private String[] parameterNames;, +		private boolean hasLvtInfo = false;, +		private final int[] lvtSlotIndex;, +		public LocalVariableTableVisitor(Class<?> clazz, Map<Member, String[]> map, String name, String desc,, +				boolean isStatic) {, +			this.clazz = clazz;, +			this.memberMap = map;, +			this.name = name;, +			// determine args]