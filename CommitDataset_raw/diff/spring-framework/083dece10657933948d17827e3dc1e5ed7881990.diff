[+++ b/spring-web/src/main/java/org/springframework/http/client/Netty4ClientHttpRequest.java, +, +, +	protected ListenableFuture<ClientHttpResponse> executeInternal(final HttpHeaders headers) throws IOException {, +					channel.pipeline().addLast(new RequestExecuteHandler(responseFuture));, +					FullHttpRequest nettyRequest = createFullHttpRequest(headers);, +		this.bootstrap.connect(this.uri.getHost(), getPort(this.uri)).addListener(connectionListener);, +			}, +			else {, +				io.netty.handler.codec.http.HttpMethod.valueOf(this.method.name());, +				nettyMethod, this.uri.getRawPath(), this.body.buffer());, +		nettyRequest.headers().set(HttpHeaders.HOST, uri.getHost());, +		nettyRequest.headers().set(HttpHeaders.CONNECTION, io.netty.handler.codec.http.HttpHeaders.Values.CLOSE);, +	/**, +	 * A SimpleChannelInboundHandler to update the given SettableListenableFuture., +	 */, +	private static class RequestExecuteHandler extends SimpleChannelInboundHandler<FullHttpResponse> {, +, +		private final SettableListenableFuture<ClientHttpResponse> responseFuture;, +, +		public RequestExecuteHandler(SettableListenableFuture<ClientHttpResponse> responseFuture) {, +			this.responseFuture = responseFuture;, +		}, +, +		@Override, +		protected void channelRead0(ChannelHandlerContext context, FullHttpResponse response) throws Exception {, +			this.responseFuture.set(new Netty4ClientHttpResponse(context, response));, +		}, +, +		@Override, +		public void exceptionCaught(ChannelHandlerContext context, Throwable cause) throws Exception {, +			this.responseFuture.setException(cause);, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/client/Netty4ClientHttpRequest.java, +, +, +	protected ListenableFuture<ClientHttpResponse> executeInternal(final HttpHeaders headers) throws IOException {, +					channel.pipeline().addLast(new RequestExecuteHandler(responseFuture));, +					FullHttpRequest nettyRequest = createFullHttpRequest(headers);, +		this.bootstrap.connect(this.uri.getHost(), getPort(this.uri)).addListener(connectionListener);, +			}, +			else {, +				io.netty.handler.codec.http.HttpMethod.valueOf(this.method.name());, +				nettyMethod, this.uri.getRawPath(), this.body.buffer());, +		nettyRequest.headers().set(HttpHeaders.HOST, uri.getHost());, +		nettyRequest.headers().set(HttpHeaders.CONNECTION, io.netty.handler.codec.http.HttpHeaders.Values.CLOSE);, +	/**, +	 * A SimpleChannelInboundHandler to update the given SettableListenableFuture., +	 */, +	private static class RequestExecuteHandler extends SimpleChannelInboundHandler<FullHttpResponse> {, +, +		private final SettableListenableFuture<ClientHttpResponse> responseFuture;, +, +		public RequestExecuteHandler(SettableListenableFuture<ClientHttpResponse> responseFuture) {, +			this.responseFuture = responseFuture;, +		}, +, +		@Override, +		protected void channelRead0(ChannelHandlerContext context, FullHttpResponse response) throws Exception {, +			this.responseFuture.set(new Netty4ClientHttpResponse(context, response));, +		}, +, +		@Override, +		public void exceptionCaught(ChannelHandlerContext context, Throwable cause) throws Exception {, +			this.responseFuture.setException(cause);, +		}, +	}, +, +++ b/spring-web/src/main/java/org/springframework/http/client/Netty4ClientHttpRequestFactory.java, +public class Netty4ClientHttpRequestFactory implements ClientHttpRequestFactory,, +		AsyncClientHttpRequestFactory, InitializingBean, DisposableBean {, +, +, +	 * Create a new {@code Netty4ClientHttpRequestFactory} with a default, +		this.eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);, +		this.defaultEventLoopGroup = true;, +	 * Create a new {@code Netty4ClientHttpRequestFactory} with the given, +, +	 * Set the default maximum request size., +	 * <p>By default this is set to {@link #DEFAULT_MAX_REQUEST_SIZE}., +	 * Set the SSL context. When configured it is used to create and insert an, +	 * {@link io.netty.handler.ssl.SslHandler} in the channel pipeline., +	 * <p>By default this is not set., +			bootstrap.group(this.eventLoopGroup).channel(NioSocketChannel.class), +						protected void initChannel(SocketChannel channel) throws Exception {, +							ChannelPipeline pipeline = channel.pipeline();, +								pipeline.addLast(sslContext.newHandler(channel.alloc()));, +	@Override, +	public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {, +		return createRequestInternal(uri, httpMethod);, +	}, +, +	@Override, +	public AsyncClientHttpRequest createAsyncRequest(URI uri, HttpMethod httpMethod) throws IOException {, +		return createRequestInternal(uri, httpMethod);, +	}, +, +		return new Netty4ClientHttpRequest(getBootstrap(), uri, httpMethod, this.maxRequestSize);]