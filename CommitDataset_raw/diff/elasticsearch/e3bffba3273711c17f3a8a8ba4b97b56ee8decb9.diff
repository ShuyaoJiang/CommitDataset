[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +                String[] concreteIndices = clusterState.metaData().concreteIndices(searchRequest.indices());, +                GroupShardsIterator groupIt = clusterService.operationRouting().searchShards(clusterState, concreteIndices, searchRequest.queryHint(), searchRequest.routing(), searchRequest.preference());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +                String[] concreteIndices = clusterState.metaData().concreteIndices(searchRequest.indices());, +                GroupShardsIterator groupIt = clusterService.operationRouting().searchShards(clusterState, concreteIndices, searchRequest.queryHint(), searchRequest.routing(), searchRequest.preference());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchHelper.java, +    public static InternalSearchRequest internalSearchRequest(ShardRouting shardRouting, int numberOfShards, SearchRequest request, String[] filteringAliases) {, +        internalRequest.filteringAliases(filteringAliases);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +                String[] concreteIndices = clusterState.metaData().concreteIndices(searchRequest.indices());, +                GroupShardsIterator groupIt = clusterService.operationRouting().searchShards(clusterState, concreteIndices, searchRequest.queryHint(), searchRequest.routing(), searchRequest.preference());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchHelper.java, +    public static InternalSearchRequest internalSearchRequest(ShardRouting shardRouting, int numberOfShards, SearchRequest request, String[] filteringAliases) {, +        internalRequest.filteringAliases(filteringAliases);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +            String[] concreteIndices = clusterState.metaData().concreteIndices(request.indices());, +            for (String index : concreteIndices) {, +            shardsIts = clusterService.operationRouting().searchShards(clusterState, concreteIndices, request.queryHint(), request.routing(), request.preference());, +                    String[] filteringAliases = clusterService.state().metaData().filteringAliases(shard.index(), request.indices());, +                    sendExecuteFirstPhase(node, internalSearchRequest(shard, shardsIts.size(), request, filteringAliases), new SearchServiceListener<FirstResult>() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +                String[] concreteIndices = clusterState.metaData().concreteIndices(searchRequest.indices());, +                GroupShardsIterator groupIt = clusterService.operationRouting().searchShards(clusterState, concreteIndices, searchRequest.queryHint(), searchRequest.routing(), searchRequest.preference());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchHelper.java, +    public static InternalSearchRequest internalSearchRequest(ShardRouting shardRouting, int numberOfShards, SearchRequest request, String[] filteringAliases) {, +        internalRequest.filteringAliases(filteringAliases);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +            String[] concreteIndices = clusterState.metaData().concreteIndices(request.indices());, +            for (String index : concreteIndices) {, +            shardsIts = clusterService.operationRouting().searchShards(clusterState, concreteIndices, request.queryHint(), request.routing(), request.preference());, +                    String[] filteringAliases = clusterService.state().metaData().filteringAliases(shard.index(), request.indices());, +                    sendExecuteFirstPhase(node, internalSearchRequest(shard, shardsIts.size(), request, filteringAliases), new SearchServiceListener<FirstResult>() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import static org.elasticsearch.common.collect.Lists.newArrayList;, +    // This map indicates if an alias associated with an index is filtering alias, +    private final ImmutableMap<String, ImmutableMap<String, Boolean>> indexToAliasFilteringRequiredMap;, +, +        // build filtering required map, +        MapBuilder<String, ImmutableMap<String, Boolean>> filteringRequiredMap = newMapBuilder();, +        for (IndexMetaData indexMetaData : indices.values()) {, +            MapBuilder<String, Boolean> indexFilteringRequiredMap = newMapBuilder();, +            // Filtering is not required for the index itself, +            indexFilteringRequiredMap.put(indexMetaData.index(), false);, +            for (AliasMetaData aliasMetaData : indexMetaData.aliases().values()) {, +                if (aliasMetaData.filter() != null) {, +                    indexFilteringRequiredMap.put(aliasMetaData.alias(), true);, +                } else {, +                    indexFilteringRequiredMap.put(aliasMetaData.alias(), false);, +                }, +            }, +            filteringRequiredMap.put(indexMetaData.index(), indexFilteringRequiredMap.immutableMap());, +        }, +        indexToAliasFilteringRequiredMap = filteringRequiredMap.immutableMap();, +, +, +    /**, +     * Iterates through the list of indices and selects the effective list of filtering aliases for the, +     * given index., +     *, +     * <p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to, +     * the index itself - null is returned. Returns <tt>null</tt> if no filtering is required.</p>, +     */, +    public String[] filteringAliases(String index, String... indices) {, +        if (indices == null || indices.length == 0) {, +            return null;, +        }, +        // optimize for the most common single index/alias scenario, +        if (indices.length == 1) {, +            String alias = indices[0];, +            // This list contains "_all" - no filtering needed, +            if (alias.equals("_all")) {, +                return null;, +            }, +            ImmutableMap<String, Boolean> aliasToFilteringRequiredMap = indexToAliasFilteringRequiredMap.get(index);, +            if (aliasToFilteringRequiredMap == null) {, +                // Shouldn't happen, +                throw new IndexMissingException(new Index(index));, +            }, +            Boolean filteringRequired = aliasToFilteringRequiredMap.get(alias);, +            if (filteringRequired == null || !filteringRequired) {, +                return null;, +            }, +            return new String[]{alias};, +        }, +        List<String> filteringAliases = null;, +        for (String alias : indices) {, +            ImmutableMap<String, Boolean> aliasToFilteringRequiredMap = indexToAliasFilteringRequiredMap.get(index);, +            if (aliasToFilteringRequiredMap == null) {, +                // Shouldn't happen, +                throw new IndexMissingException(new Index(index));, +            }, +            Boolean filteringRequired = aliasToFilteringRequiredMap.get(alias);, +            // Check that this is an alias for the current index, +            // Otherwise - skip it, +            if (filteringRequired != null) {, +                if (filteringRequired) {, +                    // If filtering required - add it to the list of filters, +                    if (filteringAliases == null) {, +                        filteringAliases = newArrayList();]