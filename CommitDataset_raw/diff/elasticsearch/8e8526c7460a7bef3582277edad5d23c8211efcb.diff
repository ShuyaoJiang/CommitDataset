[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (generation == null || generation.translogUUID == null) {, +            } else if (generation.translogUUID == null) {, +                logger.debug("upgraded translog to pre 2.0 format, associating translog with index - writing translog UUID");, +            }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (generation == null || generation.translogUUID == null) {, +            } else if (generation.translogUUID == null) {, +                logger.debug("upgraded translog to pre 2.0 format, associating translog with index - writing translog UUID");, +            }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            if (Checkpoint.read(translogPath.resolve(CHECKPOINT_FILE_NAME)) != null) {, +                throw new IllegalStateException(CHECKPOINT_FILE_NAME + " file already present, translog is already upgraded");, +            }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (generation == null || generation.translogUUID == null) {, +            } else if (generation.translogUUID == null) {, +                logger.debug("upgraded translog to pre 2.0 format, associating translog with index - writing translog UUID");, +            }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            if (Checkpoint.read(translogPath.resolve(CHECKPOINT_FILE_NAME)) != null) {, +                throw new IllegalStateException(CHECKPOINT_FILE_NAME + " file already present, translog is already upgraded");, +            }, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +import org.apache.lucene.util.TestUtil;, +import org.elasticsearch.bwcompat.OldIndexBackwardsCompatibilityTests;, +import org.elasticsearch.common.io.FileSystemUtils;, +import java.io.InputStream;, +import java.nio.file.DirectoryStream;, +import java.nio.file.Files;, +import java.util.*;, +    public void testUpgradeOldIndex() throws IOException {, +        List<Path> indexes = new ArrayList<>();, +        Path dir = getDataPath("/" + OldIndexBackwardsCompatibilityTests.class.getPackage().getName().replace('.', '/')); // the files are in the same pkg as the OldIndexBackwardsCompatibilityTests test, +        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "index-*.zip")) {, +            for (Path path : stream) {, +                indexes.add(path);, +            }, +        }, +        Collections.shuffle(indexes, random());, +        for (Path indexFile : indexes.subList(0, scaledRandomIntBetween(1, indexes.size() / 2))) {, +            final String indexName = indexFile.getFileName().toString().replace(".zip", "").toLowerCase(Locale.ROOT);, +            Version version = Version.fromString(indexName.replace("index-", ""));, +            if (version.onOrAfter(Version.V_2_0_0)) {, +                continue;, +            }, +            Path unzipDir = createTempDir();, +            Path unzipDataDir = unzipDir.resolve("data");, +            // decompress the index, +            try (InputStream stream = Files.newInputStream(indexFile)) {, +                TestUtil.unzip(stream, unzipDir);, +            }, +            // check it is unique, +            assertTrue(Files.exists(unzipDataDir));, +            Path[] list = filterExtraFSFiles(FileSystemUtils.files(unzipDataDir));, +, +            if (list.length != 1) {, +                throw new IllegalStateException("Backwards index must contain exactly one cluster but was " + list.length + " " + Arrays.toString(list));, +            }, +            // the bwc scripts packs the indices under this path, +            Path src = list[0].resolve("nodes/0/indices/" + indexName);, +            Path translog = list[0].resolve("nodes/0/indices/" + indexName).resolve("0").resolve("translog");, +            assertTrue("[" + indexFile + "] missing index dir: " + src.toString(), Files.exists(src));, +            assertTrue("[" + indexFile + "] missing translog dir: " + translog.toString(), Files.exists(translog));, +            Path[] tlogFiles = filterExtraFSFiles(FileSystemUtils.files(translog));, +            assertEquals(Arrays.toString(tlogFiles), tlogFiles.length, 1);, +            final long size = Files.size(tlogFiles[0]);, +, +            final long generation = Translog.parseIdFromFileName(tlogFiles[0]);, +            assertTrue(generation >= 1);, +            logger.debug("upgrading index {} file: {} size: {}", indexName, tlogFiles[0].getFileName(), size);, +            Directory directory = newFSDirectory(src.resolve("0").resolve("index"));, +            Store store = createStore(directory);, +            final int iters = randomIntBetween(0, 2);, +            int numDocs = -1;, +            for (int i = 0; i < iters; i++) { // make sure we can restart on an upgraded index, +                try (InternalEngine engine = createEngine(store, translog)) {, +                    try (Searcher searcher = engine.acquireSearcher("test")) {, +                        if (i > 0) {, +                            assertEquals(numDocs, searcher.reader().numDocs());, +                        }, +                        TopDocs search = searcher.searcher().search(new MatchAllDocsQuery(), 1);, +                        numDocs = searcher.reader().numDocs();, +                        assertTrue(search.totalHits > 1);, +                    }, +                    CommitStats commitStats = engine.commitStats();, +                    Map<String, String> userData = commitStats.getUserData();, +                    assertTrue("userdata dosn't contain uuid",userData.containsKey(Translog.TRANSLOG_UUID_KEY));, +                    assertTrue("userdata doesn't contain generation key", userData.containsKey(Translog.TRANSLOG_GENERATION_KEY));, +                    assertFalse("userdata contains legacy marker", userData.containsKey("translog_id"));, +                }, +            }, +, +            try (InternalEngine engine = createEngine(store, translog)) {, +                if (numDocs == -1) {, +                    try (Searcher searcher = engine.acquireSearcher("test")) {, +                        numDocs = searcher.reader().numDocs();, +                    }, +                }, +                final int numExtraDocs = randomIntBetween(1, 10);]