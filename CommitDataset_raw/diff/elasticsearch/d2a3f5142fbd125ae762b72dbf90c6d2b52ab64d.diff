[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +    private volatile boolean closed = false;, +, +        synchronized (this) {, +            closed = true;, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("Can't create shard [" + index.name() + "][" + sShardId + "], closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +    private volatile boolean closed = false;, +, +        synchronized (this) {, +            closed = true;, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("Can't create shard [" + index.name() + "][" + sShardId + "], closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/InternalIndicesService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        if (!lifecycle.started()) {, +            throw new ElasticSearchIllegalStateException("Can't create an index [" + sIndexName + "] is closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +    private volatile boolean closed = false;, +, +        synchronized (this) {, +            closed = true;, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("Can't create shard [" + index.name() + "][" + sShardId + "], closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/InternalIndicesService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        if (!lifecycle.started()) {, +            throw new ElasticSearchIllegalStateException("Can't create an index [" + sIndexName + "] is closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        if (!lifecycle.started()) {, +            return;, +        }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +    private volatile boolean closed = false;, +, +        synchronized (this) {, +            closed = true;, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("Can't create shard [" + index.name() + "][" + sShardId + "], closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/InternalIndicesService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        if (!lifecycle.started()) {, +            throw new ElasticSearchIllegalStateException("Can't create an index [" + sIndexName + "] is closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        if (!lifecycle.started()) {, +            return;, +        }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/node/internal/InternalNode.java, +        // stop any changes happening as a result of cluster state changes, +        injector.getInstance(IndicesClusterStateService.class).stop();, +        // we close indices first, so operations won't be allowed on it, +        injector.getInstance(IndicesService.class).stop();, +        // sleep a bit to let operations finish with indices service, +//        try {, +//            Thread.sleep(500);, +//        } catch (InterruptedException e) {, +//            // ignore, +//        }, +        stopWatch.stop().start("indices_cluster");, +        injector.getInstance(IndicesClusterStateService.class).close();, +        stopWatch.stop().start("indices");, +        injector.getInstance(IndicesService.class).close();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +    private volatile boolean closed = false;, +, +        synchronized (this) {, +            closed = true;, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("Can't create shard [" + index.name() + "][" + sShardId + "], closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/InternalIndicesService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        if (!lifecycle.started()) {, +            throw new ElasticSearchIllegalStateException("Can't create an index [" + sIndexName + "] is closed");, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        if (!lifecycle.started()) {, +            return;, +        }, +]