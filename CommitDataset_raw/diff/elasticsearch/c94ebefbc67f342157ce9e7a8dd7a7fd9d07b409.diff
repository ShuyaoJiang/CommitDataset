[+++ b/server/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +++ b/server/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +++ b/server/src/main/java/org/elasticsearch/index/mapper/MapperMergeValidator.java, +import java.util.ArrayList;, +     * Validates the new mapping addition, checking whether duplicate entries are present and if the, +     * provided fields are compatible with the mappings that are already defined., +     * @param fieldTypes Any existing field and field alias mappers, collected into a lookup structure., +    public static void validateNewMappers(Collection<ObjectMapper> objectMappers,, +                                          Collection<FieldAliasMapper> fieldAliasMappers,, +                                          FieldTypeLookup fieldTypes) {, +        for (FieldMapper fieldMapper : fieldMappers) {, +            String name = fieldMapper.name();, +, +            validateFieldMapper(fieldMapper, fieldTypes);, +        Set<String> fieldAliasNames = new HashSet<>();, +        for (FieldAliasMapper fieldAliasMapper : fieldAliasMappers) {, +            String name = fieldAliasMapper.name();, +            if (objectFullNames.contains(name)) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined both as an object and a field.");, +            } else if (fieldNames.contains(name)) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined both as an alias and a concrete field.");, +            } else if (fieldAliasNames.add(name) == false) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined twice.");, +            }, +, +            validateFieldAliasMapper(name, fieldAliasMapper.path(), fieldNames, fieldAliasNames);, +        }, +    }, +, +    /**, +     * Checks that the new field mapper does not conflict with existing mappings., +     */, +    private static void validateFieldMapper(FieldMapper fieldMapper,, +                                            FieldTypeLookup fieldTypes) {, +        MappedFieldType newFieldType = fieldMapper.fieldType();, +        MappedFieldType existingFieldType = fieldTypes.get(newFieldType.name());, +, +        if (existingFieldType != null && Objects.equals(newFieldType, existingFieldType) == false) {, +            List<String> conflicts = new ArrayList<>();, +            existingFieldType.checkCompatibility(newFieldType, conflicts);, +            if (conflicts.isEmpty() == false) {, +                throw new IllegalArgumentException("Mapper for [" + newFieldType.name() +, +                    "] conflicts with existing mapping:\n" + conflicts.toString());, +            }, +        }, +    }, +, +    /**, +     * Checks that the new field alias is valid., +     *, +     * Note that this method assumes that new concrete fields have already been processed, so that it, +     * can verify that an alias refers to an existing concrete field., +     */, +    private static void validateFieldAliasMapper(String aliasName,, +                                                 String path,, +                                                 Set<String> fieldMappers,, +                                                 Set<String> fieldAliasMappers) {, +        if (path.equals(aliasName)) {, +            throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" +, +                aliasName + "]: an alias cannot refer to itself.");, +        }, +, +        if (fieldAliasMappers.contains(path)) {, +            throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" +, +                aliasName + "]: an alias cannot refer to another alias.");, +        }, +, +        if (fieldMappers.contains(path) == false) {, +            throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" +, +                aliasName + "]: an alias must refer to an existing field in the mappings.");, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +++ b/server/src/main/java/org/elasticsearch/index/mapper/MapperMergeValidator.java, +import java.util.ArrayList;, +     * Validates the new mapping addition, checking whether duplicate entries are present and if the, +     * provided fields are compatible with the mappings that are already defined., +     * @param fieldTypes Any existing field and field alias mappers, collected into a lookup structure., +    public static void validateNewMappers(Collection<ObjectMapper> objectMappers,, +                                          Collection<FieldAliasMapper> fieldAliasMappers,, +                                          FieldTypeLookup fieldTypes) {, +        for (FieldMapper fieldMapper : fieldMappers) {, +            String name = fieldMapper.name();, +, +            validateFieldMapper(fieldMapper, fieldTypes);, +        Set<String> fieldAliasNames = new HashSet<>();, +        for (FieldAliasMapper fieldAliasMapper : fieldAliasMappers) {, +            String name = fieldAliasMapper.name();, +            if (objectFullNames.contains(name)) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined both as an object and a field.");, +            } else if (fieldNames.contains(name)) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined both as an alias and a concrete field.");, +            } else if (fieldAliasNames.add(name) == false) {, +                throw new IllegalArgumentException("Field [" + name + "] is defined twice.");, +            }, +, +            validateFieldAliasMapper(name, fieldAliasMapper.path(), fieldNames, fieldAliasNames);, +        }, +    }, +]