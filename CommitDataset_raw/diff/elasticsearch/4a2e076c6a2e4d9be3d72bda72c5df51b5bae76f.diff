[+++ b/.idea/dictionaries/kimchy.xml, +      <w>prefetch</w>, +++ b/.idea/dictionaries/kimchy.xml, +      <w>prefetch</w>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.routing.strategy.PreferUnallocatedStrategy;, +        bind(PreferUnallocatedStrategy.class).to(PreferUnallocatedShardUnassignedStrategy.class).asEagerSingleton();, +++ b/.idea/dictionaries/kimchy.xml, +      <w>prefetch</w>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.routing.strategy.PreferUnallocatedStrategy;, +        bind(PreferUnallocatedStrategy.class).to(PreferUnallocatedShardUnassignedStrategy.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    final IndexMetaData.Builder indexMetaDataBuilder = newIndexMetaDataBuilder(request.index).settings(actualIndexSettings);, +                        indexMetaDataBuilder.putMapping(entry.getKey(), entry.getValue());, +                    final IndexMetaData indexMetaData = indexMetaDataBuilder.build();, +                        listener.onResponse(new Response(true, indexMetaData));, +                                        listener.onResponse(new Response(true, indexMetaData));, +                                listener.onResponse(new Response(false, indexMetaData));, +                // do prefetch here so we won't compute md5 and such on the cluster update state..., +                long prefetchTime = 0;, +                if (shardsRoutingStrategy.preferUnallocatedStrategy() != null) {, +                    long start = System.currentTimeMillis();, +                    shardsRoutingStrategy.preferUnallocatedStrategy().prefetch(response.indexMetaData(), clusterService.state().nodes());, +                    prefetchTime = System.currentTimeMillis() - start;, +                }, +                final long fPrefetchTime = prefetchTime;, +, +                        logger.info("[{}] created and added to cluster_state, prefetch_took [{}]", request.index, TimeValue.timeValueMillis(fPrefetchTime));, +        private final IndexMetaData indexMetaData;, +        public Response(boolean acknowledged, IndexMetaData indexMetaData) {, +            this.indexMetaData = indexMetaData;, +, +        public IndexMetaData indexMetaData() {, +            return indexMetaData;, +        }, +++ b/.idea/dictionaries/kimchy.xml, +      <w>prefetch</w>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.routing.strategy.PreferUnallocatedStrategy;, +        bind(PreferUnallocatedStrategy.class).to(PreferUnallocatedShardUnassignedStrategy.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    final IndexMetaData.Builder indexMetaDataBuilder = newIndexMetaDataBuilder(request.index).settings(actualIndexSettings);, +                        indexMetaDataBuilder.putMapping(entry.getKey(), entry.getValue());, +                    final IndexMetaData indexMetaData = indexMetaDataBuilder.build();, +                        listener.onResponse(new Response(true, indexMetaData));, +                                        listener.onResponse(new Response(true, indexMetaData));, +                                listener.onResponse(new Response(false, indexMetaData));, +                // do prefetch here so we won't compute md5 and such on the cluster update state..., +                long prefetchTime = 0;, +                if (shardsRoutingStrategy.preferUnallocatedStrategy() != null) {, +                    long start = System.currentTimeMillis();, +                    shardsRoutingStrategy.preferUnallocatedStrategy().prefetch(response.indexMetaData(), clusterService.state().nodes());, +                    prefetchTime = System.currentTimeMillis() - start;, +                }, +                final long fPrefetchTime = prefetchTime;, +, +                        logger.info("[{}] created and added to cluster_state, prefetch_took [{}]", request.index, TimeValue.timeValueMillis(fPrefetchTime));, +        private final IndexMetaData indexMetaData;, +        public Response(boolean acknowledged, IndexMetaData indexMetaData) {, +            this.indexMetaData = indexMetaData;, +, +        public IndexMetaData indexMetaData() {, +            return indexMetaData;, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/strategy/PreferUnallocatedShardUnassignedStrategy.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.CountDownLatch;, +public class PreferUnallocatedShardUnassignedStrategy extends AbstractComponent implements PreferUnallocatedStrategy {, +, +    private final ThreadPool threadPool;, +    @Inject public PreferUnallocatedShardUnassignedStrategy(Settings settings, ThreadPool threadPool, IndicesService indicesService,, +        this.threadPool = threadPool;, +    @Override public void prefetch(IndexMetaData index, DiscoveryNodes nodes) {, +        final CountDownLatch latch = new CountDownLatch(index.numberOfShards());, +        for (int shardId = 0; shardId < index.numberOfShards(); shardId++) {, +            transportNodesListShardStoreMetaData.list(new ShardId(index.index(), shardId), false, nodes.dataNodes().keySet(), new ActionListener<TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData>() {, +                @Override public void onResponse(TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData) {, +                    latch.countDown();, +                }, +, +                @Override public void onFailure(Throwable e) {, +                    latch.countDown();, +                }, +            });, +        }, +, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            // ignore, +        }, +    }, +, +        if (nodes.dataNodes().isEmpty()) {, +            TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData = transportNodesListShardStoreMetaData.list(shard.shardId(), false, nodes.dataNodes().keySet()).actionGet();, +++ b/.idea/dictionaries/kimchy.xml]