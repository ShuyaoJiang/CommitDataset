[+++ b/buildSrc/build.gradle, +++ b/buildSrc/build.gradle, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/get/TransportGetTaskAction.java, +                        // TODO look up the task's result from the .tasks index now that it is done, +                        listener.onResponse(, +                                new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +                listener.onResponse(new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +     * Send a {@link GetRequest} to the results index looking for the results of the task. It'll only be found only if the task's result was, +     * persisted. Called on the node that once had the task if that node is part of the cluster or on the coordinating node if the node, +     * wasn't part of the cluster., +++ b/buildSrc/build.gradle, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/get/TransportGetTaskAction.java, +                        // TODO look up the task's result from the .tasks index now that it is done, +                        listener.onResponse(, +                                new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +                listener.onResponse(new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +     * Send a {@link GetRequest} to the results index looking for the results of the task. It'll only be found only if the task's result was, +     * persisted. Called on the node that once had the task if that node is part of the cluster or on the coordinating node if the node, +     * wasn't part of the cluster., +++ b/core/src/main/java/org/elasticsearch/action/ingest/TrackingResultProcessor.java, +    public TrackingResultProcessor(Processor actualProcessor, List<SimulateProcessorResult> processorResultList) {, +        if (actualProcessor instanceof CompoundProcessor) {, +            CompoundProcessor trackedCompoundProcessor = decorate((CompoundProcessor) actualProcessor, processorResultList);, +            this.actualProcessor = trackedCompoundProcessor;, +        } else {, +    }, +                processors.add(new TrackingResultProcessor(processor, processorResultList));, +                onFailureProcessors.add(new TrackingResultProcessor(processor, processorResultList));, +        return new CompoundProcessor(false, processors, onFailureProcessors);, +++ b/buildSrc/build.gradle, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/get/TransportGetTaskAction.java, +                        // TODO look up the task's result from the .tasks index now that it is done, +                        listener.onResponse(, +                                new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +                listener.onResponse(new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +     * Send a {@link GetRequest} to the results index looking for the results of the task. It'll only be found only if the task's result was, +     * persisted. Called on the node that once had the task if that node is part of the cluster or on the coordinating node if the node, +     * wasn't part of the cluster., +++ b/core/src/main/java/org/elasticsearch/action/ingest/TrackingResultProcessor.java, +    public TrackingResultProcessor(Processor actualProcessor, List<SimulateProcessorResult> processorResultList) {, +        if (actualProcessor instanceof CompoundProcessor) {, +            CompoundProcessor trackedCompoundProcessor = decorate((CompoundProcessor) actualProcessor, processorResultList);, +            this.actualProcessor = trackedCompoundProcessor;, +        } else {, +    }, +                processors.add(new TrackingResultProcessor(processor, processorResultList));, +                onFailureProcessors.add(new TrackingResultProcessor(processor, processorResultList));, +        return new CompoundProcessor(false, processors, onFailureProcessors);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import java.util.concurrent.RejectedExecutionException;, +            } catch (RejectedExecutionException e) {, +++ b/buildSrc/build.gradle, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/get/TransportGetTaskAction.java, +                        // TODO look up the task's result from the .tasks index now that it is done, +                        listener.onResponse(, +                                new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +                listener.onResponse(new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +     * Send a {@link GetRequest} to the results index looking for the results of the task. It'll only be found only if the task's result was, +     * persisted. Called on the node that once had the task if that node is part of the cluster or on the coordinating node if the node, +     * wasn't part of the cluster., +++ b/core/src/main/java/org/elasticsearch/action/ingest/TrackingResultProcessor.java, +    public TrackingResultProcessor(Processor actualProcessor, List<SimulateProcessorResult> processorResultList) {, +        if (actualProcessor instanceof CompoundProcessor) {, +            CompoundProcessor trackedCompoundProcessor = decorate((CompoundProcessor) actualProcessor, processorResultList);, +            this.actualProcessor = trackedCompoundProcessor;, +        } else {, +    }, +                processors.add(new TrackingResultProcessor(processor, processorResultList));, +                onFailureProcessors.add(new TrackingResultProcessor(processor, processorResultList));, +        return new CompoundProcessor(false, processors, onFailureProcessors);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import java.util.concurrent.RejectedExecutionException;, +            } catch (RejectedExecutionException e) {, +++ /dev/null, +++ b/buildSrc/build.gradle, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/get/TransportGetTaskAction.java, +                        // TODO look up the task's result from the .tasks index now that it is done, +                        listener.onResponse(, +                                new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +                listener.onResponse(new GetTaskResponse(new PersistedTaskInfo(runningTask.taskInfo(clusterService.localNode(), true))));, +     * Send a {@link GetRequest} to the results index looking for the results of the task. It'll only be found only if the task's result was, +     * persisted. Called on the node that once had the task if that node is part of the cluster or on the coordinating node if the node, +     * wasn't part of the cluster., +++ b/core/src/main/java/org/elasticsearch/action/ingest/TrackingResultProcessor.java, +    public TrackingResultProcessor(Processor actualProcessor, List<SimulateProcessorResult> processorResultList) {, +        if (actualProcessor instanceof CompoundProcessor) {, +            CompoundProcessor trackedCompoundProcessor = decorate((CompoundProcessor) actualProcessor, processorResultList);, +            this.actualProcessor = trackedCompoundProcessor;, +        } else {, +    }, +                processors.add(new TrackingResultProcessor(processor, processorResultList));, +                onFailureProcessors.add(new TrackingResultProcessor(processor, processorResultList));, +        return new CompoundProcessor(false, processors, onFailureProcessors);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import java.util.concurrent.RejectedExecutionException;, +            } catch (RejectedExecutionException e) {, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    public static void write(Path checkpointFile, Checkpoint checkpoint, OpenOption... options) throws IOException {, +        try (FileChannel channel = FileChannel.open(checkpointFile, options)) {]