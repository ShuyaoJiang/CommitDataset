[+++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.common.logging.ESLogger;, +                final MetaData metaData = currentState.getMetaData();, +, +                for (ShardRoutingEntry entry : extractShardsToBeApplied(shardRoutingEntries, "failed", metaData, logger)) {, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(entry.shardRouting, entry.reason));, +                // mark all entries as processed, +                for (ShardRoutingEntry entry : shardRoutingEntries) {, +                    entry.processed = true;, +    static List<ShardRoutingEntry> extractShardsToBeApplied(List<ShardRoutingEntry> shardRoutingEntries, String type, MetaData metaData, ESLogger logger) {, +        List<ShardRoutingEntry> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +        for (int i = 0; i < shardRoutingEntries.size(); i++) {, +            ShardRoutingEntry shardRoutingEntry = shardRoutingEntries.get(i);, +            ShardRouting shardRouting = shardRoutingEntry.shardRouting;, +            IndexMetaData indexMetaData = metaData.index(shardRouting.index());, +            // if there is no metadata or the current index is not of the right uuid, the index has been deleted while it was being allocated, +            // which is fine, we should just ignore this, +            if (indexMetaData == null) {, +                logger.debug("{} ignoring shard {}, unknown index in {}", shardRouting.shardId(), type, shardRoutingEntry);, +                continue;, +            }, +            if (!indexMetaData.isSameUUID(shardRoutingEntry.indexUUID)) {, +                logger.debug("{} ignoring shard {}, different index uuid, current {}, got {}", shardRouting.shardId(), type, indexMetaData.getUUID(), shardRoutingEntry);, +                continue;, +            }, +, +            // more debug info will be logged by the allocation service, +            logger.trace("{} will apply shard {} {}", shardRouting.shardId(), type, shardRoutingEntry);, +            shardRoutingsToBeApplied.add(shardRoutingEntry);, +        }, +        return shardRoutingsToBeApplied;, +, +    }, +, +, +                        for (ShardRoutingEntry entry : extractShardsToBeApplied(shardRoutingEntries, "started", metaData, logger)) {, +                            shardRoutingToBeApplied.add(entry.shardRouting);, +                        // mark all entries as processed, +                        for (ShardRoutingEntry entry : shardRoutingEntries) {, +                            entry.processed = true;, +        ShardRouting shardRouting;, +        String indexUUID = IndexMetaData.INDEX_UUID_NA_VALUE;, +        String reason;, +        ShardRoutingEntry(ShardRouting shardRouting, String indexUUID, String reason) {, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.common.logging.ESLogger;, +                final MetaData metaData = currentState.getMetaData();, +, +                for (ShardRoutingEntry entry : extractShardsToBeApplied(shardRoutingEntries, "failed", metaData, logger)) {, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(entry.shardRouting, entry.reason));, +                // mark all entries as processed, +                for (ShardRoutingEntry entry : shardRoutingEntries) {, +                    entry.processed = true;, +    static List<ShardRoutingEntry> extractShardsToBeApplied(List<ShardRoutingEntry> shardRoutingEntries, String type, MetaData metaData, ESLogger logger) {, +        List<ShardRoutingEntry> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +        for (int i = 0; i < shardRoutingEntries.size(); i++) {, +            ShardRoutingEntry shardRoutingEntry = shardRoutingEntries.get(i);, +            ShardRouting shardRouting = shardRoutingEntry.shardRouting;, +            IndexMetaData indexMetaData = metaData.index(shardRouting.index());, +            // if there is no metadata or the current index is not of the right uuid, the index has been deleted while it was being allocated, +            // which is fine, we should just ignore this, +            if (indexMetaData == null) {, +                logger.debug("{} ignoring shard {}, unknown index in {}", shardRouting.shardId(), type, shardRoutingEntry);, +                continue;, +            }, +            if (!indexMetaData.isSameUUID(shardRoutingEntry.indexUUID)) {, +                logger.debug("{} ignoring shard {}, different index uuid, current {}, got {}", shardRouting.shardId(), type, indexMetaData.getUUID(), shardRoutingEntry);, +                continue;, +            }, +, +            // more debug info will be logged by the allocation service, +            logger.trace("{} will apply shard {} {}", shardRouting.shardId(), type, shardRoutingEntry);, +            shardRoutingsToBeApplied.add(shardRoutingEntry);, +        }, +        return shardRoutingsToBeApplied;, +, +    }, +, +, +                        for (ShardRoutingEntry entry : extractShardsToBeApplied(shardRoutingEntries, "started", metaData, logger)) {, +                            shardRoutingToBeApplied.add(entry.shardRouting);, +                        // mark all entries as processed, +                        for (ShardRoutingEntry entry : shardRoutingEntries) {, +                            entry.processed = true;, +        ShardRouting shardRouting;, +        String indexUUID = IndexMetaData.INDEX_UUID_NA_VALUE;, +        String reason;, +        ShardRoutingEntry(ShardRouting shardRouting, String indexUUID, String reason) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +                        if (shard.equals(startedShard)) {, +                            logger.trace("{} marked as started", shard);, +                        } else {, +                            logger.debug("failed to find shard [{}] in order to start it [no matching shard on node], ignoring", startedShard);, +            } else {, +                logger.debug("failed to find shard [{}] in order to start it [failed to find node], ignoring", startedShard);, +, +                    logger.debug("failed shard {} found in routingNodes, failing it", failedShard);, +                    logger.debug("failed shard {} found in routingNodes, failing it", failedShard);, +            if (dirty) {, +                logger.debug("failed shard {} found in routingNodes and failed", failedShard);]