[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.atomic.AtomicLong;, +    // we use flushNeeded here, since if there are no changes, then the commit won't write, +    // will not really happen, and then the commitUserData and the new translog will not be reflected, +    private volatile boolean flushNeeded = false;, +, +    private final AtomicLong translogIdGenerator = new AtomicLong();, +, +                if (IndexReader.indexExists(store.directory())) {, +                    Map<String, String> commitUserData = IndexReader.getCommitUserData(store.directory());, +                    if (commitUserData.containsKey(Translog.TRANSLOG_ID_KEY)) {, +                        translogIdGenerator.set(Long.parseLong(commitUserData.get(Translog.TRANSLOG_ID_KEY)));, +                    } else {, +                        translogIdGenerator.set(System.currentTimeMillis());, +                        indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogIdGenerator.get())).map());, +                    }, +                } else {, +                    translogIdGenerator.set(System.currentTimeMillis());, +                    indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogIdGenerator.get())).map());, +                }, +                translog.newTranslog(translogIdGenerator.get());, +                    indexingSearcher.get().release();, +            flushNeeded = true;, +            flushNeeded = true;, +            flushNeeded = true;, +            flushNeeded = true;, +, +                        if (flushNeeded) {, +                            flushNeeded = false;, +                            long translogId = translogIdGenerator.incrementAndGet();, +                            indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)).map());, +                            translog.newTranslog(translogId);, +                        }, +, +                    if (flushNeeded) {, +                        flushNeeded = false;, +                            long translogId = translogIdGenerator.incrementAndGet();, +                            indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)).map());, +                            translog.newTranslog(translogId);, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.atomic.AtomicLong;, +    // we use flushNeeded here, since if there are no changes, then the commit won't write, +    // will not really happen, and then the commitUserData and the new translog will not be reflected, +    private volatile boolean flushNeeded = false;, +, +    private final AtomicLong translogIdGenerator = new AtomicLong();, +, +                if (IndexReader.indexExists(store.directory())) {, +                    Map<String, String> commitUserData = IndexReader.getCommitUserData(store.directory());, +                    if (commitUserData.containsKey(Translog.TRANSLOG_ID_KEY)) {, +                        translogIdGenerator.set(Long.parseLong(commitUserData.get(Translog.TRANSLOG_ID_KEY)));, +                    } else {, +                        translogIdGenerator.set(System.currentTimeMillis());, +                        indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogIdGenerator.get())).map());, +                    }, +                } else {, +                    translogIdGenerator.set(System.currentTimeMillis());, +                    indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogIdGenerator.get())).map());, +                }, +                translog.newTranslog(translogIdGenerator.get());, +                    indexingSearcher.get().release();, +            flushNeeded = true;, +            flushNeeded = true;, +            flushNeeded = true;, +            flushNeeded = true;, +, +                        if (flushNeeded) {, +                            flushNeeded = false;, +                            long translogId = translogIdGenerator.incrementAndGet();, +                            indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)).map());, +                            translog.newTranslog(translogId);, +                        }, +, +                    if (flushNeeded) {, +                        flushNeeded = false;, +                            long translogId = translogIdGenerator.incrementAndGet();, +                            indexWriter.commit(MapBuilder.<String, String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)).map());, +                            translog.newTranslog(translogId);, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import java.util.Map;, +        long translogId = -1;, +                Map<String, String> commitUserData = IndexReader.getCommitUserData(indexShard.store().directory());, +                if (commitUserData.containsKey(Translog.TRANSLOG_ID_KEY)) {, +                    translogId = Long.parseLong(commitUserData.get(Translog.TRANSLOG_ID_KEY));, +                } else {, +                    translogId = version;, +                }, +        if (translogId == -1) {, +        File recoveringTranslogFile = new File(translog.location(), "translog-" + translogId + ".recovering");, +            File translogFile = new File(translog.location(), "translog-" + translogId);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.atomic.AtomicLong;, +    // we use flushNeeded here, since if there are no changes, then the commit won't write, +    // will not really happen, and then the commitUserData and the new translog will not be reflected, +    private volatile boolean flushNeeded = false;]