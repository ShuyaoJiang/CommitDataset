[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    protected long generateSeqNoForOperationOnPrimary(final Operation operation) {, +        assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO :, +            "ops should not have an assigned seq no. but was: " + operation.seqNo();, +    protected void advanceMaxSeqNoOfUpdatesOrDeletesOnPrimary(long seqNo) {, +        advanceMaxSeqNoOfUpdatesOrDeletes(seqNo);, +    }, +, +                } else {, +                    // generate or register sequence number, +                    if (index.origin() == Operation.Origin.PRIMARY) {, +                        index = new Index(index.uid(), index.parsedDoc(), generateSeqNoForOperationOnPrimary(index), index.primaryTerm(),, +                            index.version(), index.versionType(), index.origin(), index.startTime(), index.getAutoGeneratedIdTimestamp(),, +                            index.isRetry(), index.getIfSeqNo(), index.getIfPrimaryTerm());, +, +                        final boolean toAppend = plan.indexIntoLucene && plan.useLuceneUpdateDocument == false;, +                        if (toAppend == false) {, +                            advanceMaxSeqNoOfUpdatesOrDeletes(index.seqNo());, +                        }, +                    } else {, +                        markSeqNoAsSeen(index.seqNo());, +                    }, +, +                    assert index.seqNo() >= 0 : "ops should have an assigned seq no.; origin: " + index.origin();, +, +                    if (plan.indexIntoLucene || plan.addStaleOpToLucene) {, +                            plan.versionForIndexing, getPrimaryTerm(), index.seqNo(), plan.currentNotFoundOrDeleted);, +                    }, +                        new IndexVersionValue(translogLocation, plan.versionForIndexing, index.seqNo(), index.primaryTerm()));, +            plan = IndexingStrategy.optimizedAppendOnly(1L);, +                plan = IndexingStrategy.processButSkipLucene(false, index.version());, +                    plan = IndexingStrategy.processAsStaleOp(softDeleteEnabled, index.version());, +                        index.version());, +                plan = IndexingStrategy.overrideExistingAsIfNotThere(1L);, +                plan = IndexingStrategy.optimizedAppendOnly(1L);, +        assert index.seqNo() >= 0 : "ops should have an assigned seq no.; origin: " + index.origin();, +        index.parsedDoc().updateSeqID(index.seqNo(), index.primaryTerm());, +                assert assertMaxSeqNoOfUpdatesIsAdvanced(index.uid(), index.seqNo(), true, true);, +            return new IndexResult(plan.versionForIndexing, index.primaryTerm(), index.seqNo(), plan.currentNotFoundOrDeleted);, +                return new IndexResult(ex, Versions.MATCH_ANY, index.primaryTerm(), index.seqNo());, +                                 boolean indexIntoLucene, boolean addStaleOpToLucene,, +        public static IndexingStrategy optimizedAppendOnly(long versionForIndexing) {, +            return new IndexingStrategy(true, false, true, false, versionForIndexing, null);, +                Versions.NOT_FOUND, result);, +            return new IndexingStrategy(currentNotFoundOrDeleted, currentNotFoundOrDeleted == false,, +                true, false, versionForIndexing, null);, +        static IndexingStrategy overrideExistingAsIfNotThere(long versionForIndexing) {, +            return new IndexingStrategy(true, true, true,, +                false, versionForIndexing, null);, +        }, +, +        public static IndexingStrategy processButSkipLucene(boolean currentNotFoundOrDeleted, long versionForIndexing) {, +            return new IndexingStrategy(currentNotFoundOrDeleted, false, false,, +                false, versionForIndexing, null);, +        }, +, +        static IndexingStrategy processAsStaleOp(boolean addStaleOpToLucene, long versionForIndexing) {, +                addStaleOpToLucene, versionForIndexing, null);, +            } else {, +                // generate or register sequence number, +                if (delete.origin() == Operation.Origin.PRIMARY) {, +                    delete = new Delete(delete.type(), delete.id(), delete.uid(), generateSeqNoForOperationOnPrimary(delete),, +                        delete.primaryTerm(), delete.version(), delete.versionType(), delete.origin(), delete.startTime(),, +                        delete.getIfSeqNo(), delete.getIfPrimaryTerm());, +, +                    advanceMaxSeqNoOfUpdatesOrDeletesOnPrimary(delete.seqNo());, +                } else {, +                    markSeqNoAsSeen(delete.seqNo());, +                }, +, +                assert delete.seqNo() >= 0 : "ops should have an assigned seq no.; origin: " + delete.origin();, +, +                if (plan.deleteFromLucene || plan.addStaleOpToLucene) {, +                        plan.versionOfDeletion, getPrimaryTerm(), delete.seqNo(), plan.currentlyDeleted == false);, +                }, +            plan = DeletionStrategy.processButSkipLucene(false, delete.version());, +                plan = DeletionStrategy.processAsStaleOp(softDeleteEnabled, false, delete.version());, +                plan = DeletionStrategy.processNormally(opVsLucene == OpVsLuceneDocStatus.LUCENE_DOC_NOT_FOUND, delete.version());, +            plan = DeletionStrategy.processNormally(currentlyDeleted, delete.versionType().updateVersion(currentVersion, delete.version()));, +        assert assertMaxSeqNoOfUpdatesIsAdvanced(delete.uid(), delete.seqNo(), false, false);, +                tombstone.updateSeqID(delete.seqNo(), delete.primaryTerm());, +                    new DeleteVersionValue(plan.versionOfDeletion, delete.seqNo(), delete.primaryTerm(),, +                plan.versionOfDeletion, getPrimaryTerm(), delete.seqNo(), plan.currentlyDeleted == false);, +                        ex, plan.versionOfDeletion, delete.primaryTerm(), delete.seqNo(), plan.currentlyDeleted == false);, +                                 long versionOfDeletion, DeleteResult earlyResultOnPreflightError) {, +            return new DeletionStrategy(false, false, currentlyDeleted, Versions.NOT_FOUND, deleteResult);, +        static DeletionStrategy processNormally(boolean currentlyDeleted, long versionOfDeletion) {, +            return new DeletionStrategy(true, false, currentlyDeleted, versionOfDeletion, null);, +        public static DeletionStrategy processButSkipLucene(boolean currentlyDeleted, long versionOfDeletion) {, +            return new DeletionStrategy(false, false, currentlyDeleted, versionOfDeletion, null);, +        static DeletionStrategy processAsStaleOp(boolean addStaleOpToLucene, boolean currentlyDeleted, long versionOfDeletion) {, +            return new DeletionStrategy(false, addStaleOpToLucene, currentlyDeleted, versionOfDeletion, null);, +                markSeqNoAsSeen(noOp.seqNo());, +            localCheckpointTracker.markSeqNoAsCompleted(seqNo);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    protected long generateSeqNoForOperationOnPrimary(final Operation operation) {, +        assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO :, +            "ops should not have an assigned seq no. but was: " + operation.seqNo();, +    protected void advanceMaxSeqNoOfUpdatesOrDeletesOnPrimary(long seqNo) {, +        advanceMaxSeqNoOfUpdatesOrDeletes(seqNo);]