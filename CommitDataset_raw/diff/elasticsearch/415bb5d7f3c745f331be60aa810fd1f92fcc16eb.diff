[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import org.elasticsearch.action.admin.cluster.node.info.NodeInfo;, +public class TransportClientNodesService extends AbstractComponent {, +    private final Runnable nodesSampler;, +        this.nodesSamplerInterval = componentSettings.getAsTime("nodes_sampler_interval", timeValueSeconds(5));, +        if (componentSettings.getAsBoolean("sniff", false)) {, +            this.nodesSampler = new ScheduledSniffNodesSampler();, +        } else {, +            this.nodesSampler = new ScheduledConnectNodeSampler();, +        }, +            listedNodes = builder.addAll(listedNodes).add(new DiscoveryNode("#transport#-" + tempNodeIdGenerator.incrementAndGet(), transportAddress)).build();, +    private class ScheduledConnectNodeSampler implements Runnable {, +        @Override public synchronized void run() {, +            HashSet<DiscoveryNode> newNodes = new HashSet<DiscoveryNode>();, +            for (DiscoveryNode node : listedNodes) {, +                if (!transportService.nodeConnected(node)) {, +                        newNodes.add(node);, +                        logger.debug("Failed to connect to node " + node + ", removed from nodes list", e);, +                    }, +                } else {, +                    newNodes.add(node);, +    private class ScheduledSniffNodesSampler implements Runnable {, +                            transportService.sendRequest(listedNode, TransportActions.Admin.Cluster.Node.INFO, Requests.nodesInfoRequest("_all"), new BaseTransportResponseHandler<NodesInfoResponse>() {, +                for (NodeInfo nodeInfo : nodesInfoResponse) {, +                        logger.warn("Node {} not part of the cluster {}, ignoring...", nodeInfo.node(), clusterName);, +                        if (nodeInfo.node().dataNode()) { // only add data nodes to connect to, +                            newNodes.add(nodeInfo.node());, +                }, +                    newNodes.remove(node);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import org.elasticsearch.action.admin.cluster.node.info.NodeInfo;, +public class TransportClientNodesService extends AbstractComponent {, +    private final Runnable nodesSampler;, +        this.nodesSamplerInterval = componentSettings.getAsTime("nodes_sampler_interval", timeValueSeconds(5));, +        if (componentSettings.getAsBoolean("sniff", false)) {, +            this.nodesSampler = new ScheduledSniffNodesSampler();, +        } else {, +            this.nodesSampler = new ScheduledConnectNodeSampler();, +        }, +            listedNodes = builder.addAll(listedNodes).add(new DiscoveryNode("#transport#-" + tempNodeIdGenerator.incrementAndGet(), transportAddress)).build();, +    private class ScheduledConnectNodeSampler implements Runnable {, +        @Override public synchronized void run() {, +            HashSet<DiscoveryNode> newNodes = new HashSet<DiscoveryNode>();, +            for (DiscoveryNode node : listedNodes) {, +                if (!transportService.nodeConnected(node)) {, +                        newNodes.add(node);, +                        logger.debug("Failed to connect to node " + node + ", removed from nodes list", e);, +                    }, +                } else {, +                    newNodes.add(node);, +    private class ScheduledSniffNodesSampler implements Runnable {, +                            transportService.sendRequest(listedNode, TransportActions.Admin.Cluster.Node.INFO, Requests.nodesInfoRequest("_all"), new BaseTransportResponseHandler<NodesInfoResponse>() {, +                for (NodeInfo nodeInfo : nodesInfoResponse) {, +                        logger.warn("Node {} not part of the cluster {}, ignoring...", nodeInfo.node(), clusterName);, +                        if (nodeInfo.node().dataNode()) { // only add data nodes to connect to, +                            newNodes.add(nodeInfo.node());, +                }, +                    newNodes.remove(node);, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/client/transport/TransportClientDocumentActionsTests.java, +        TransportClient client = new TransportClient(settingsBuilder().put("client.transport.sniff", false).build());, +        TransportClient client = new TransportClient(settingsBuilder().put("client.transport.sniff", false).build());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import org.elasticsearch.action.admin.cluster.node.info.NodeInfo;, +public class TransportClientNodesService extends AbstractComponent {, +    private final Runnable nodesSampler;, +        this.nodesSamplerInterval = componentSettings.getAsTime("nodes_sampler_interval", timeValueSeconds(5));, +        if (componentSettings.getAsBoolean("sniff", false)) {, +            this.nodesSampler = new ScheduledSniffNodesSampler();, +        } else {, +            this.nodesSampler = new ScheduledConnectNodeSampler();, +        }, +            listedNodes = builder.addAll(listedNodes).add(new DiscoveryNode("#transport#-" + tempNodeIdGenerator.incrementAndGet(), transportAddress)).build();, +    private class ScheduledConnectNodeSampler implements Runnable {, +        @Override public synchronized void run() {, +            HashSet<DiscoveryNode> newNodes = new HashSet<DiscoveryNode>();, +            for (DiscoveryNode node : listedNodes) {, +                if (!transportService.nodeConnected(node)) {, +                        newNodes.add(node);, +                        logger.debug("Failed to connect to node " + node + ", removed from nodes list", e);, +                    }, +                } else {, +                    newNodes.add(node);, +    private class ScheduledSniffNodesSampler implements Runnable {, +                            transportService.sendRequest(listedNode, TransportActions.Admin.Cluster.Node.INFO, Requests.nodesInfoRequest("_all"), new BaseTransportResponseHandler<NodesInfoResponse>() {, +                for (NodeInfo nodeInfo : nodesInfoResponse) {, +                        logger.warn("Node {} not part of the cluster {}, ignoring...", nodeInfo.node(), clusterName);, +                        if (nodeInfo.node().dataNode()) { // only add data nodes to connect to, +                            newNodes.add(nodeInfo.node());, +                }, +                    newNodes.remove(node);, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/client/transport/TransportClientDocumentActionsTests.java]