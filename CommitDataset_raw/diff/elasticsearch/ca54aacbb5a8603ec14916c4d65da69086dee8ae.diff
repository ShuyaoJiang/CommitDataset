[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +    static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +    static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalAutoDateHistogram.java, +                bucketInfo.roundingInfos, targetBuckets);, +    static int getAppropriateRounding(long minKey, long maxKey, int roundingIdx,, +                                              RoundingInfo[] roundings, int targetBuckets) {, +        } while (requiredBuckets > (targetBuckets * roundings[currentRoundingIdx - 1].getMaximumInnerInterval()), +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +    static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalAutoDateHistogram.java, +                bucketInfo.roundingInfos, targetBuckets);, +    static int getAppropriateRounding(long minKey, long maxKey, int roundingIdx,, +                                              RoundingInfo[] roundings, int targetBuckets) {, +        } while (requiredBuckets > (targetBuckets * roundings[currentRoundingIdx - 1].getMaximumInnerInterval()), +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalAutoDateHistogramTests.java, +import org.elasticsearch.common.rounding.DateTimeUnit;, +import org.joda.time.DateTimeZone;, +import java.time.Instant;, +import java.time.OffsetDateTime;, +import java.time.ZoneOffset;, +import static org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder.createRounding;, +import static org.hamcrest.Matchers.equalTo;, +, +    /*, +    This test was added to reproduce a bug where getAppropriateRounding was only ever using the first innerIntervals, +    passed in, instead of using the interval associated with the loop., +     */, +    public void testGetAppropriateRoundingUsesCorrectIntervals() {, +        RoundingInfo[] roundings = new RoundingInfo[6];, +        DateTimeZone timeZone = DateTimeZone.UTC;, +        // Since we pass 0 as the starting index to getAppropriateRounding, we'll also use, +        // an innerInterval that is quite large, such that targetBuckets * roundings[i].getMaximumInnerInterval(), +        // will be larger than the estimate., +        roundings[0] = new RoundingInfo(createRounding(DateTimeUnit.SECOND_OF_MINUTE, timeZone),, +            1000L, 1000);, +        roundings[1] = new RoundingInfo(createRounding(DateTimeUnit.MINUTES_OF_HOUR, timeZone),, +            60 * 1000L, 1, 5, 10, 30);, +        roundings[2] = new RoundingInfo(createRounding(DateTimeUnit.HOUR_OF_DAY, timeZone),, +            60 * 60 * 1000L, 1, 3, 12);, +, +        OffsetDateTime timestamp = Instant.parse("2018-01-01T00:00:01.000Z").atOffset(ZoneOffset.UTC);, +        // We want to pass a roundingIdx of zero, because in order to reproduce this bug, we need the function, +        // to increment the rounding (because the bug was that the function would not use the innerIntervals, +        // from the new rounding., +        int result = InternalAutoDateHistogram.getAppropriateRounding(timestamp.toEpochSecond()*1000,, +            timestamp.plusDays(1).toEpochSecond()*1000, 0, roundings, 25);, +        assertThat(result, equalTo(2));, +    }, +, +, +, +        int roundingIndex = reduced.getBucketInfo().roundingIdx;, +        RoundingInfo roundingInfo = roundingInfos[roundingIndex];, +, +        long innerIntervalToUse = roundingInfo.innerIntervals[0];, +        int innerIntervalIndex = 0;, +, +        // First, try to calculate the correct innerInterval using the normalizedDuration., +        // This handles cases where highest and lowest are further apart than the interval being used., +        if (normalizedDuration != 0) {, +            for (int j = roundingInfo.innerIntervals.length-1; j >= 0; j--) {, +                int interval = roundingInfo.innerIntervals[j];, +                if (normalizedDuration / interval < reduced.getBuckets().size()) {, +                    innerIntervalIndex = j;, +        }, +, +        int bucketCount = getBucketCount(lowest, highest, roundingInfo, intervalInMillis);, +, +        //Next, if our bucketCount is still above what we need, we'll go back and determine the interval, +        // based on a size calculation., +        if (bucketCount > reduced.getBuckets().size()) {, +            for (int i = innerIntervalIndex; i < roundingInfo.innerIntervals.length; i++) {, +                long newIntervalMillis = roundingInfo.innerIntervals[i] * roundingInfo.getRoughEstimateDurationMillis();, +                if (getBucketCount(lowest, highest, roundingInfo, newIntervalMillis) <= reduced.getBuckets().size()) {, +                    innerIntervalToUse = roundingInfo.innerIntervals[i];, +                    intervalInMillis = innerIntervalToUse * roundingInfo.getRoughEstimateDurationMillis();, +                }, +            }, +        }, +, +        Map<Long, Long> expectedCounts = new TreeMap<>();, +             keyForBucket <= roundingInfo.rounding.round(highest);, +            // Iterate through the input buckets, and for each bucket, determine if it's inside, +            // the range of the bucket in the outer loop. if it is, add the doc count to the total, +            // for that bucket., +, +                    long roundedBucketKey = roundingInfo.rounding.round(((DateTime) bucket.getKey()).getMillis());, +                    long docCount = bucket.getDocCount();, +                            (key, oldValue) -> (oldValue == null ? 0 : oldValue) + docCount);, +        // If there is only a single bucket, and we haven't added it above, add a bucket with no documents., +        // this step is necessary because of the roundedBucketKey < keyForBucket + intervalInMillis above., +        if (roundingInfo.rounding.round(lowest) == roundingInfo.rounding.round(highest) && expectedCounts.isEmpty()) {, +            expectedCounts.put(roundingInfo.rounding.round(lowest), 0L);, +        }, +, +        // pick out the actual reduced values to the make the assertion more readable, +    private int getBucketCount(long lowest, long highest, RoundingInfo roundingInfo, long intervalInMillis) {, +        int bucketCount = 0;]