[+++ b/src/main/java/org/elasticsearch/river/cluster/RiverClusterService.java, +    /**, +     * The current state., +     */, +    public ClusterState state() {, +        return clusterService.state();, +    }, +, +++ b/src/main/java/org/elasticsearch/river/cluster/RiverClusterService.java, +    /**, +     * The current state., +     */, +    public ClusterState state() {, +        return clusterService.state();, +    }, +, +++ b/src/main/java/org/elasticsearch/river/routing/RiversRouter.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;, +import org.elasticsearch.threadpool.ThreadPool;, +    private static final TimeValue RIVER_START_RETRY_INTERVAL = TimeValue.timeValueMillis(1000);, +    private static final int RIVER_START_MAX_RETRIES = 5;, +, +    private final ThreadPool threadPool;, +, +    public RiversRouter(Settings settings, Client client, ClusterService clusterService, RiverClusterService riverClusterService, ThreadPool threadPool) {, +        this.threadPool = threadPool;, +        final String source = "reroute_rivers_node_changed";, +        //we'll try again a few times if we don't find the river _meta document while the type is there, +        final CountDown countDown = new CountDown(RIVER_START_MAX_RETRIES);, +        riverClusterService.submitStateUpdateTask(source, new RiverClusterStateUpdateTask() {, +                return updateRiverClusterState(source, currentState, event.state(), countDown);, +            }, +        });, +    }, +, +    protected RiverClusterState updateRiverClusterState(final String source, final RiverClusterState currentState,, +                                          ClusterState newClusterState, final CountDown countDown) {, +        if (!newClusterState.metaData().hasIndex(riverIndexName)) {, +        IndexMetaData indexMetaData = newClusterState.metaData().index(riverIndexName);, +                    GetResponse getResponse = client.prepareGet(riverIndexName, mappingType, "_meta").setPreference("_primary").get();, +                    if (!getResponse.isExists()) {, +                        if (countDown.countDown()) {, +                            logger.warn("no river _meta document found after {} attempts", RIVER_START_MAX_RETRIES);, +                        } else {, +                            logger.info("no river _meta document found, retrying in {} ms", RIVER_START_RETRY_INTERVAL.millis());, +                            try {, +                                threadPool.schedule(RIVER_START_RETRY_INTERVAL, ThreadPool.Names.GENERIC, new Runnable() {, +                                    @Override, +                                    public void run() {, +                                        riverClusterService.submitStateUpdateTask(source, new RiverClusterStateUpdateTask() {, +                                            @Override, +                                            public RiverClusterState execute(RiverClusterState currentState) {, +                                                return updateRiverClusterState(source, currentState, riverClusterService.state(), countDown);, +                                            }, +                                        });, +                                    }, +                                });, +                            } catch(EsRejectedExecutionException ex) {, +                                logger.debug("Couldn't schedule river start retry, node might be shutting down", ex);, +                            }, +                        }, +                        return currentState;, +                    }, +            } else if (routing.node() != null && !newClusterState.nodes().nodeExists(routing.node().id())) {, +        for (DiscoveryNode node : newClusterState.nodes()) {]