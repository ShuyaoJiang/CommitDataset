[+++ b/src/main/java/org/elasticsearch/index/fielddata/plain/ParentChildIndexFieldData.java, +, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.lease.Releasables;, +    private static OrdinalMap buildOrdinalMap(AtomicParentChildFieldData[] atomicFD, String parentType) throws IOException {, +        final SortedDocValues[] ordinals = new SortedDocValues[atomicFD.length];, +        for (int i = 0; i < ordinals.length; ++i) {, +            ordinals[i] = atomicFD[i].getOrdinalsValues(parentType);, +        }, +        return OrdinalMap.build(null, ordinals, PackedInts.DEFAULT);, +    }, +, +    private static class OrdinalMapAndAtomicFieldData {, +        final OrdinalMap ordMap;, +        final AtomicParentChildFieldData[] fieldData;, +, +        public OrdinalMapAndAtomicFieldData(OrdinalMap ordMap, AtomicParentChildFieldData[] fieldData) {, +            this.ordMap = ordMap;, +            this.fieldData = fieldData;, +    @Override, +    public IndexParentChildFieldData localGlobalDirect(IndexReader indexReader) throws Exception {, +        final long startTime = System.nanoTime();, +        final Set<String> parentTypes = new HashSet<>();, +        synchronized (lock) {, +            for (BytesRef type : this.parentTypes) {, +                parentTypes.add(type.utf8ToString());, +        final Map<String, OrdinalMapAndAtomicFieldData> perType = new HashMap<>();, +        for (String type : parentTypes) {, +            final AtomicParentChildFieldData[] fieldData = new AtomicParentChildFieldData[indexReader.leaves().size()];, +            for (LeafReaderContext context : indexReader.leaves()) {, +                fieldData[context.ord] = load(context);, +            }, +            final OrdinalMap ordMap = buildOrdinalMap(fieldData, type);, +            ramBytesUsed += ordMap.ramBytesUsed();, +            perType.put(type, new OrdinalMapAndAtomicFieldData(ordMap, fieldData));, +        }, +, +        final AtomicParentChildFieldData[] fielddata = new AtomicParentChildFieldData[indexReader.leaves().size()];, +        for (int i = 0; i < fielddata.length; ++i) {, +            fielddata[i] = new GlobalAtomicFieldData(parentTypes, perType, i);, +        }, +, +        breakerService.getBreaker(CircuitBreaker.Name.FIELDDATA).addWithoutBreaking(ramBytesUsed);, +        if (logger.isDebugEnabled()) {, +            logger.debug(, +                    "Global-ordinals[_parent] took {}",, +                    new TimeValue(System.nanoTime() - startTime, TimeUnit.NANOSECONDS), +            );, +        }, +, +        return new GlobalFieldData(indexReader, fielddata, ramBytesUsed);, +    }, +, +    private static class GlobalAtomicFieldData extends AbstractAtomicParentChildFieldData {, +, +        private final Set<String> types;, +        private final Map<String, OrdinalMapAndAtomicFieldData> atomicFD;, +        private final int segmentIndex;, +, +        public GlobalAtomicFieldData(Set<String> types, Map<String, OrdinalMapAndAtomicFieldData> atomicFD, int segmentIndex) {, +            this.types = types;, +            this.atomicFD = atomicFD;, +            this.segmentIndex = segmentIndex;, +        }, +, +        @Override, +        public Set<String> types() {, +            return types;, +        }, +, +        @Override, +        public SortedDocValues getOrdinalsValues(String type) {, +            final OrdinalMapAndAtomicFieldData atomicFD = this.atomicFD.get(type);, +            final OrdinalMap ordMap = atomicFD.ordMap;, +            final SortedDocValues[] allSegmentValues = new SortedDocValues[atomicFD.fieldData.length];, +            for (int i = 0; i < allSegmentValues.length; ++i) {, +                allSegmentValues[i] = atomicFD.fieldData[i].getOrdinalsValues(type);, +            }, +            final SortedDocValues segmentValues = allSegmentValues[segmentIndex];, +            if (segmentValues.getValueCount() == ordMap.getValueCount()) {, +                // ords are already global, +                return segmentValues;, +            }, +            final LongValues globalOrds = ordMap.getGlobalOrds(segmentIndex);, +            return new SortedDocValues() {, +, +                    final int segmentIndex = ordMap.getFirstSegmentNumber(ord);, +                    final int segmentOrd = (int) ordMap.getFirstSegmentOrd(ord);, +                    return allSegmentValues[segmentIndex].lookupOrd(segmentOrd);, +                    return (int) ordMap.getValueCount();, +            // this class does not take memory on its own, the index-level field data does, +            // it through the use of ordinal maps, +        public void close() throws ElasticsearchException {, +            List<Releasable> closeables = new ArrayList<>();, +            for (OrdinalMapAndAtomicFieldData fds : atomicFD.values()) {, +                closeables.addAll(Arrays.asList(fds.fieldData));, +            }, +            Releasables.close(closeables);, +    private class GlobalFieldData implements IndexParentChildFieldData, Accountable {, +        private final AtomicParentChildFieldData[] fielddata;]