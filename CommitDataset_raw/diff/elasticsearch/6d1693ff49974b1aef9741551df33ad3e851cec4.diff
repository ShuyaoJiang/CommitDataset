[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/AutodetectProcessManager.java, +import java.util.ArrayList;, +        public synchronized void execute(Runnable command) {, +            if (isShutdown()) {, +                EsRejectedExecutionException rejected = new EsRejectedExecutionException("autodetect worker service has shutdown", true);, +                if (command instanceof AbstractRunnable) {, +                    ((AbstractRunnable) command).onRejection(rejected);, +                } else {, +                    throw rejected;, +                }, +            }, +, +, +                synchronized (this) {, +                    // if shutdown with tasks pending notify the handlers, +                    if (queue.isEmpty() == false) {, +                        List<Runnable> notExecuted = new ArrayList<>();, +                        queue.drainTo(notExecuted);, +, +                        for (Runnable runnable : notExecuted) {, +                            if (runnable instanceof AbstractRunnable) {, +                                ((AbstractRunnable) runnable).onRejection(, +                                    new EsRejectedExecutionException("unable to process as autodetect worker service has shutdown", true));, +                            }, +                        }, +                    }, +                }, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/AutodetectProcessManager.java, +import java.util.ArrayList;, +        public synchronized void execute(Runnable command) {, +            if (isShutdown()) {, +                EsRejectedExecutionException rejected = new EsRejectedExecutionException("autodetect worker service has shutdown", true);, +                if (command instanceof AbstractRunnable) {, +                    ((AbstractRunnable) command).onRejection(rejected);, +                } else {, +                    throw rejected;, +                }, +            }, +, +, +                synchronized (this) {, +                    // if shutdown with tasks pending notify the handlers, +                    if (queue.isEmpty() == false) {, +                        List<Runnable> notExecuted = new ArrayList<>();, +                        queue.drainTo(notExecuted);, +, +                        for (Runnable runnable : notExecuted) {, +                            if (runnable instanceof AbstractRunnable) {, +                                ((AbstractRunnable) runnable).onRejection(, +                                    new EsRejectedExecutionException("unable to process as autodetect worker service has shutdown", true));, +                            }, +                        }, +                    }, +                }, +++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/job/process/autodetect/AutodetectProcessManagerTests.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.junit.After;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private ThreadPool threadPool;, +, +, +        threadPool = new TestThreadPool("AutodetectProcessManagerTests");, +    @After, +    public void stopThreadPool() throws InterruptedException {, +        terminate(threadPool);, +    }, +, +, +    public void testAutodetectWorkerExecutorService_SubmitAfterShutdown() {, +        AutodetectProcessManager.AutodetectWorkerExecutorService executor =, +                new AutodetectWorkerExecutorService(new ThreadContext(Settings.EMPTY));, +, +        threadPool.generic().execute(() -> executor.start());, +        executor.shutdown();, +        expectThrows(EsRejectedExecutionException.class, () -> executor.execute(() -> {}));, +    }, +, +    public void testAutodetectWorkerExecutorService_TasksNotExecutedCallHandlerOnShutdown(), +            throws InterruptedException, ExecutionException {, +        AutodetectProcessManager.AutodetectWorkerExecutorService executor =, +                new AutodetectWorkerExecutorService(new ThreadContext(Settings.EMPTY));, +, +        CountDownLatch latch = new CountDownLatch(1);, +, +        Future<?> executorFinished = threadPool.generic().submit(() -> executor.start());, +, +        // run a task that will block while the others are queued up, +        executor.execute(() -> {, +            try {, +                latch.await();, +            } catch (InterruptedException e) {, +            }, +        });, +, +        AtomicBoolean runnableShouldNotBeCalled = new AtomicBoolean(false);, +        executor.execute(() -> runnableShouldNotBeCalled.set(true));, +, +        AtomicInteger onFailureCallCount = new AtomicInteger();, +        AtomicInteger doRunCallCount = new AtomicInteger();]