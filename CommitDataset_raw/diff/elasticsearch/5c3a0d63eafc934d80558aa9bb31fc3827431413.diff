[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +import org.gradle.internal.jvm.Jvm, +, +import java.nio.file.Paths, +, +            File jps = Paths.get(Jvm.current().javaHome.toString(), "bin/jps").toFile(), +            if (!jps.exists()) {, +                throw new GradleException("jps executable not found; ensure that you're running Gradle with the JDK rather than the JRE"), +            }, +            commandLine jps, '-l', +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +import org.gradle.internal.jvm.Jvm, +, +import java.nio.file.Paths, +, +            File jps = Paths.get(Jvm.current().javaHome.toString(), "bin/jps").toFile(), +            if (!jps.exists()) {, +                throw new GradleException("jps executable not found; ensure that you're running Gradle with the JDK rather than the JRE"), +            }, +            commandLine jps, '-l', +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.transport.BaseTransportResponseHandler;, +    protected void processBeforeDelegationToMaster(Request request, ClusterState state) {, +, +    }, +, +        innerExecute(request, listener, new ClusterStateObserver(clusterService, request.masterNodeTimeout(), logger), false);, +    private void innerExecute(final Request request, final ActionListener<Response> listener, final ClusterStateObserver observer, final boolean retrying) {, +                    return;, +                logger.trace("can't execute due to a cluster block, retrying", blockException);, +                observer.waitForNextChange(, +                        new ClusterStateObserver.Listener() {, +                            public void onNewClusterState(ClusterState state) {, +                                innerExecute(request, listener, observer, false);, +                            public void onClusterServiceClose() {, +                                listener.onFailure(blockException);, +                            }, +, +                            @Override, +                            public void onTimeout(TimeValue timeout) {, +                                listener.onFailure(blockException);, +                            }, +                        }, new ClusterStateObserver.ValidationPredicate() {, +                            @Override, +                            protected boolean validate(ClusterState newState) {, +                                ClusterBlockException blockException = checkBlock(request, newState);, +                                return (blockException == null || !blockException.retryable());, +                            }, +                        }, +                );, +, +                threadPool.executor(executor).execute(new ActionRunnable(listener) {, +                        masterOperation(request, clusterService.state(), listener);, +                if (retrying) {, +                    listener.onFailure(new MasterNotDiscoveredException());, +                } else {, +                                    innerExecute(request, listener, observer, true);, +                                    listener.onFailure(new MasterNotDiscoveredException("waited for [" + timeout + "]"));, +                            }, new ClusterStateObserver.ChangePredicate() {, +                                @Override, +                                public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                                                     ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +                                    return newState.nodes().masterNodeId() != null;, +                                }, +, +                                @Override, +                                public boolean apply(ClusterChangedEvent event) {, +                                    return event.nodesDelta().masterNodeChanged();, +                                }, +                            }, +                return;, +            }, +            processBeforeDelegationToMaster(request, clusterState);, +            transportService.sendRequest(nodes.masterNode(), actionName, request, new BaseTransportResponseHandler<Response>() {, +                @Override, +                public Response newInstance() {, +                    return newResponse();, +                }, +, +                @Override, +                public void handleResponse(Response response) {, +                    listener.onResponse(response);, +                }, +, +                @Override, +                public String executor() {, +                    return ThreadPool.Names.SAME;, +                }, +, +                @Override, +                public void handleException(final TransportException exp) {, +                    if (exp.unwrapCause() instanceof ConnectTransportException) {, +                        // we want to retry here a bit to see if a new master is elected, +                        logger.debug("connection exception while trying to forward request to master node [{}], scheduling a retry. Error: [{}]",, +                                nodes.masterNode(), exp.getDetailedMessage());, +                        observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                                                       @Override, +                                                       public void onNewClusterState(ClusterState state) {, +                                                           innerExecute(request, listener, observer, false);, +                                                       }]