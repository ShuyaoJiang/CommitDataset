[+++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/ExecuteStepsUpdateTask.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +        IndexMetaData indexMetaData = currentState.metaData().index(index);, +        if (indexMetaData == null) {, +            // This index doesn't exist any more, there's nothing to execute currently, +            return currentState;, +        }, +        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,, +            indexMetaData.getSettings());, +                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey());, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/ExecuteStepsUpdateTask.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +        IndexMetaData indexMetaData = currentState.metaData().index(index);, +        if (indexMetaData == null) {, +            // This index doesn't exist any more, there's nothing to execute currently, +            return currentState;, +        }, +        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,, +            indexMetaData.getSettings());, +                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey());, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleRunner.java, +        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData.getIndex(), indexSettings);, +    static Step getCurrentStep(PolicyStepsRegistry stepRegistry, String policy, Index index, Settings indexSettings) {, +            return stepRegistry.getStep(index, currentStepKey);, +        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {, +            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +, +                "] with policy [" + indexPolicySetting + "] does not exist");, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/ExecuteStepsUpdateTask.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +        IndexMetaData indexMetaData = currentState.metaData().index(index);, +        if (indexMetaData == null) {, +            // This index doesn't exist any more, there's nothing to execute currently, +            return currentState;, +        }, +        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,, +            indexMetaData.getSettings());, +                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey());, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleRunner.java, +        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData.getIndex(), indexSettings);, +    static Step getCurrentStep(PolicyStepsRegistry stepRegistry, String policy, Index index, Settings indexSettings) {, +            return stepRegistry.getStep(index, currentStepKey);, +        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {, +            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +, +                "] with policy [" + indexPolicySetting + "] does not exist");, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +            // Since indices keep their current phase's details even if the policy changes, it's possible for a deleted index to have a, +            // policy, and then be re-created with the same name, so here we remove indices that have been delete so they don't waste memory, +            if (event.indicesDeleted().isEmpty() == false) {, +                policyRegistry.removeIndices(event.indicesDeleted());, +            }, +            if (event.state().metaData().custom(IndexLifecycleMetadata.TYPE) != null) {, +                policyRegistry.update(event.state(), client, nowSupplier);, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/ExecuteStepsUpdateTask.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +        IndexMetaData indexMetaData = currentState.metaData().index(index);, +        if (indexMetaData == null) {, +            // This index doesn't exist any more, there's nothing to execute currently, +            return currentState;, +        }, +        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,, +            indexMetaData.getSettings());, +                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",, +                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey());, +                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey());, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleRunner.java, +        Step currentStep = getCurrentStep(stepRegistry, policy, indexMetaData.getIndex(), indexSettings);, +    static Step getCurrentStep(PolicyStepsRegistry stepRegistry, String policy, Index index, Settings indexSettings) {, +            return stepRegistry.getStep(index, currentStepKey);, +        if (stepRegistry.stepExists(indexPolicySetting, nextStepKey) == false) {, +            throw new IllegalArgumentException("step [" + nextStepKey + "] for index [" + idxMeta.getIndex().getName() +, +                "] with policy [" + indexPolicySetting + "] does not exist");, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +            // Since indices keep their current phase's details even if the policy changes, it's possible for a deleted index to have a, +            // policy, and then be re-created with the same name, so here we remove indices that have been delete so they don't waste memory, +            if (event.indicesDeleted().isEmpty() == false) {, +                policyRegistry.removeIndices(event.indicesDeleted());, +            }, +            if (event.state().metaData().custom(IndexLifecycleMetadata.TYPE) != null) {, +                policyRegistry.update(event.state(), client, nowSupplier);, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/PolicyStepsRegistry.java, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.index.Index;]