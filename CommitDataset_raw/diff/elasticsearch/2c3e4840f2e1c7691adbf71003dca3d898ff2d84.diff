[+++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.apache.lucene.search.Explanation;, +import org.apache.lucene.util.SmallFloat;, +        assertAllSearchWorks(indexName);, +    boolean findPayloadBoostInExplanation(Explanation expl) {, +        if (expl.getDescription().startsWith("payloadBoost=") && expl.getValue() != 1f) {, +            return true;, +        } else {, +            boolean found = false;, +            for (Explanation sub : expl.getDetails()) {, +                found |= findPayloadBoostInExplanation(sub);, +            }, +            return found;, +        }, +    }, +, +    void assertAllSearchWorks(String indexName) {, +        logger.info("--> testing _all search");, +        SearchResponse searchRsp = client().prepareSearch(indexName).get();, +        ElasticsearchAssertions.assertNoFailures(searchRsp);, +        assertThat(searchRsp.getHits().getTotalHits(), greaterThanOrEqualTo(1L));, +        SearchHit bestHit = searchRsp.getHits().getAt(0);, +, +        // Make sure there are payloads and they are taken into account for the score, +        // the 'string' field has a boost of 4 in the mappings so it should get a payload boost, +        String stringValue = (String) bestHit.sourceAsMap().get("string");, +        assertNotNull(stringValue);, +        Explanation explanation = client().prepareExplain(indexName, bestHit.getType(), bestHit.getId()), +                .setQuery(QueryBuilders.matchQuery("_all", stringValue)).get().getExplanation();, +        assertTrue("Could not find payload boost in explanation\n" + explanation, findPayloadBoostInExplanation(explanation));, +, +        // Make sure the query can run on the whole index, +        searchRsp = client().prepareSearch(indexName).setQuery(QueryBuilders.matchQuery("_all", stringValue)).setExplain(true).get();, +        ElasticsearchAssertions.assertNoFailures(searchRsp);, +        assertThat(searchRsp.getHits().getTotalHits(), greaterThanOrEqualTo(1L));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.apache.lucene.search.Explanation;, +import org.apache.lucene.util.SmallFloat;, +        assertAllSearchWorks(indexName);, +    boolean findPayloadBoostInExplanation(Explanation expl) {, +        if (expl.getDescription().startsWith("payloadBoost=") && expl.getValue() != 1f) {, +            return true;, +        } else {, +            boolean found = false;, +            for (Explanation sub : expl.getDetails()) {, +                found |= findPayloadBoostInExplanation(sub);, +            }, +            return found;, +        }, +    }, +, +    void assertAllSearchWorks(String indexName) {, +        logger.info("--> testing _all search");, +        SearchResponse searchRsp = client().prepareSearch(indexName).get();]