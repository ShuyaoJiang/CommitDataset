[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;, +import org.apache.lucene.search.SynonymQuery;, +     * We override this one so we can get the fuzzy part to be treated as string,, +     * so people can do: "age:10~5" or "timestamp:2012-10-10~5d", +    protected Query getRangeQuery(String field, String part1, String part2,, +                                  boolean startInclusive, boolean endInclusive) throws ParseException {, +    private Query getRangeQuerySingle(String field, String part1, String part2,, +                                      boolean startInclusive, boolean endInclusive) {, +                    DateFieldMapper.DateFieldType dateFieldType =, +                        (DateFieldMapper.DateFieldType) this.currentFieldType;, +                    rangeQuery = dateFieldType.rangeQuery(part1, part2, startInclusive, endInclusive,, +                        settings.timeZone(), null);, +                return currentFieldType.fuzzyQuery(termStr, Fuzziness.build(minSimilarity),, +                    fuzzyPrefixLength, settings.fuzzyMaxExpansions(), FuzzyQuery.defaultTranspositions);, +        FuzzyQuery query = new FuzzyQuery(term, numEdits, prefixLength,, +            settings.fuzzyMaxExpansions(), FuzzyQuery.defaultTranspositions);, +        List<List<String> > tlist;, +            List<String> currentPos = new ArrayList<>();, +            PositionIncrementAttribute posAtt = source.addAttribute(PositionIncrementAttribute.class);, +                if (currentPos.isEmpty() == false && posAtt.getPositionIncrement() > 0) {, +                    tlist.add(currentPos);, +                    currentPos = new ArrayList<>();, +                }, +                currentPos.add(termAtt.toString());, +            }, +            if (currentPos.isEmpty() == false) {, +                tlist.add(currentPos);, +, +        if (tlist.size() == 1 && tlist.get(0).size() == 1) {, +            return super.getPrefixQuery(field, tlist.get(0).get(0));, +            // build a boolean query with prefix on the last position only., +            for (int pos = 0; pos < tlist.size(); pos++) {, +                List<String> plist = tlist.get(pos);, +                boolean isLastPos = (pos == tlist.size()-1);, +                Query posQuery;, +                if (plist.size() == 1) {, +                    if (isLastPos) {, +                        posQuery = getPrefixQuery(field, plist.get(0));, +                    } else {, +                        posQuery = newTermQuery(new Term(field, plist.get(0)));, +                } else if (isLastPos == false) {, +                    // build a synonym query for terms in the same position., +                    Term[] terms = new Term[plist.size()];, +                    for (int i = 0; i < plist.size(); i++) {, +                        terms[i] = new Term(field, plist.get(i));, +                    }, +                    posQuery = new SynonymQuery(terms);, +                } else {, +                    List<BooleanClause> innerClauses = new ArrayList<>();, +                    for (String token : plist) {, +                        innerClauses.add(new BooleanClause(getPrefixQuery(field, token),, +                            BooleanClause.Occur.SHOULD));, +                    }, +                    posQuery = getBooleanQueryCoordDisabled(innerClauses);, +                }, +                clauses.add(new BooleanClause(posQuery,, +                    getDefaultOperator() == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD));, +            }, +            return getBooleanQuery(clauses);, +                    query = currentFieldType.regexpQuery(termStr, RegExp.ALL,, +                        maxDeterminizedStates, multiTermRewriteMethod, context);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;, +import org.apache.lucene.search.SynonymQuery;, +     * We override this one so we can get the fuzzy part to be treated as string,, +     * so people can do: "age:10~5" or "timestamp:2012-10-10~5d", +    protected Query getRangeQuery(String field, String part1, String part2,, +                                  boolean startInclusive, boolean endInclusive) throws ParseException {, +    private Query getRangeQuerySingle(String field, String part1, String part2,, +                                      boolean startInclusive, boolean endInclusive) {, +                    DateFieldMapper.DateFieldType dateFieldType =, +                        (DateFieldMapper.DateFieldType) this.currentFieldType;, +                    rangeQuery = dateFieldType.rangeQuery(part1, part2, startInclusive, endInclusive,, +                        settings.timeZone(), null);, +                return currentFieldType.fuzzyQuery(termStr, Fuzziness.build(minSimilarity),, +                    fuzzyPrefixLength, settings.fuzzyMaxExpansions(), FuzzyQuery.defaultTranspositions);, +        FuzzyQuery query = new FuzzyQuery(term, numEdits, prefixLength,, +            settings.fuzzyMaxExpansions(), FuzzyQuery.defaultTranspositions);, +        List<List<String> > tlist;, +            List<String> currentPos = new ArrayList<>();, +            PositionIncrementAttribute posAtt = source.addAttribute(PositionIncrementAttribute.class);, +                if (currentPos.isEmpty() == false && posAtt.getPositionIncrement() > 0) {, +                    tlist.add(currentPos);, +                    currentPos = new ArrayList<>();, +                }, +                currentPos.add(termAtt.toString());, +            }, +            if (currentPos.isEmpty() == false) {, +                tlist.add(currentPos);, +, +        if (tlist.size() == 1 && tlist.get(0).size() == 1) {, +            return super.getPrefixQuery(field, tlist.get(0).get(0));, +            // build a boolean query with prefix on the last position only., +            for (int pos = 0; pos < tlist.size(); pos++) {, +                List<String> plist = tlist.get(pos);, +                boolean isLastPos = (pos == tlist.size()-1);]