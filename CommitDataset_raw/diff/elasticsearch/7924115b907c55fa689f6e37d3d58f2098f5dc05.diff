[+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                                .addAsNew(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                                .addAsNew(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataStateIndexService.java, +                        .addAsRecovery(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                                .addAsNew(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataStateIndexService.java, +                        .addAsRecovery(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +import org.elasticsearch.index.shard.ShardId;, +        public Builder initializeAsNew(IndexMetaData indexMetaData) {, +         * Initializes a new empty index, as if it was created from an API., +         */, +        public Builder initializeAsRecovery(IndexMetaData indexMetaData) {, +            return initializeEmpty(indexMetaData, false);, +        }, +, +        /**, +        private Builder initializeEmpty(IndexMetaData indexMetaData, boolean asNew) {, +            if (!shards.isEmpty()) {, +                throw new ElasticSearchIllegalStateException("trying to initialize an index with fresh shards, but already has shards created");, +            for (int shardId = 0; shardId < indexMetaData.numberOfShards(); shardId++) {, +                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(new ShardId(indexMetaData.index(), shardId), asNew ? false : true);, +                for (int i = 0; i <= indexMetaData.numberOfReplicas(); i++) {, +                    indexShardRoutingBuilder.addShard(new ImmutableShardRouting(index, shardId, null, i == 0, ShardRoutingState.UNASSIGNED, 0));, +                }, +                shards.put(shardId, indexShardRoutingBuilder.build());, +                ImmutableShardRouting shard = new ImmutableShardRouting(index, shardId, null, false, ShardRoutingState.UNASSIGNED, 0);, +                shards.put(shardId,, +                        new IndexShardRoutingTable.Builder(shards.get(shard.id())).addShard(shard).build(), +                );, +                IndexShardRoutingTable.Builder builder = new IndexShardRoutingTable.Builder(indexShard.shardId(), indexShard.primaryAllocatedPostApi());, +        /**, +         * Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table, +         * if it needs to be created., +         */, +        public Builder addShard(IndexShardRoutingTable refData, ShardRouting shard) {, +                indexShard = new IndexShardRoutingTable.Builder(refData.shardId(), refData.primaryAllocatedPostApi()).addShard(new ImmutableShardRouting(shard)).build();, +                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(new ImmutableShardRouting(shard)).build();, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                                .addAsNew(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataStateIndexService.java, +                        .addAsRecovery(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +import org.elasticsearch.index.shard.ShardId;, +        public Builder initializeAsNew(IndexMetaData indexMetaData) {, +         * Initializes a new empty index, as if it was created from an API., +         */, +        public Builder initializeAsRecovery(IndexMetaData indexMetaData) {, +            return initializeEmpty(indexMetaData, false);, +        }, +, +        /**, +        private Builder initializeEmpty(IndexMetaData indexMetaData, boolean asNew) {, +            if (!shards.isEmpty()) {, +                throw new ElasticSearchIllegalStateException("trying to initialize an index with fresh shards, but already has shards created");, +            for (int shardId = 0; shardId < indexMetaData.numberOfShards(); shardId++) {, +                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(new ShardId(indexMetaData.index(), shardId), asNew ? false : true);, +                for (int i = 0; i <= indexMetaData.numberOfReplicas(); i++) {, +                    indexShardRoutingBuilder.addShard(new ImmutableShardRouting(index, shardId, null, i == 0, ShardRoutingState.UNASSIGNED, 0));, +                }, +                shards.put(shardId, indexShardRoutingBuilder.build());, +                ImmutableShardRouting shard = new ImmutableShardRouting(index, shardId, null, false, ShardRoutingState.UNASSIGNED, 0);, +                shards.put(shardId,, +                        new IndexShardRoutingTable.Builder(shards.get(shard.id())).addShard(shard).build(), +                );, +                IndexShardRoutingTable.Builder builder = new IndexShardRoutingTable.Builder(indexShard.shardId(), indexShard.primaryAllocatedPostApi());, +        /**, +         * Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table, +         * if it needs to be created., +         */, +        public Builder addShard(IndexShardRoutingTable refData, ShardRouting shard) {, +                indexShard = new IndexShardRoutingTable.Builder(refData.shardId(), refData.primaryAllocatedPostApi()).addShard(new ImmutableShardRouting(shard)).build();, +                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(new ImmutableShardRouting(shard)).build();, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    final boolean primaryAllocatedPostApi;, +    IndexShardRoutingTable(ShardId shardId, ImmutableList<ShardRouting> shards, boolean primaryAllocatedPostApi) {, +        this.primaryAllocatedPostApi = primaryAllocatedPostApi;, +        return new IndexShardRoutingTable(shardId, ImmutableList.copyOf(shardRoutings), primaryAllocatedPostApi);, +    public boolean primaryAllocatedPostApi() {, +        return primaryAllocatedPostApi;, +        private boolean primaryAllocatedPostApi;, +            this.primaryAllocatedPostApi = indexShard.primaryAllocatedPostApi();, +        public Builder(ShardId shardId, boolean primaryAllocatedPostApi) {, +            this.primaryAllocatedPostApi = primaryAllocatedPostApi;, +            if (!primaryAllocatedPostApi) {, +                        primaryAllocatedPostApi = true;, +            return new IndexShardRoutingTable(shardId, ImmutableList.copyOf(shards), primaryAllocatedPostApi);, +            out.writeBoolean(indexShard.primaryAllocatedPostApi());, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                                .addAsNew(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataStateIndexService.java, +                        .addAsRecovery(updatedState.metaData().index(request.index));, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +import org.elasticsearch.index.shard.ShardId;]