[+++ b/src/test/java/org/elasticsearch/cluster/allocation/ClusterRerouteTests.java, +import java.util.Arrays;, +        File[] shardLocation = cluster().getInstance(NodeEnvironment.class, node_1).shardLocations(new ShardId("test", 0));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // make sure the data is there!, +        cluster().closeNonSharedNodes(false); // don't wipe data directories the index needs to be there!, +        logger.info("--> deleting the shard data [{}] ", Arrays.toString(shardLocation));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // verify again after cluster was shut down, +        assertThat(FileSystemUtils.deleteRecursively(shardLocation), equalTo(true));, +++ b/src/test/java/org/elasticsearch/cluster/allocation/ClusterRerouteTests.java, +import java.util.Arrays;, +        File[] shardLocation = cluster().getInstance(NodeEnvironment.class, node_1).shardLocations(new ShardId("test", 0));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // make sure the data is there!, +        cluster().closeNonSharedNodes(false); // don't wipe data directories the index needs to be there!, +        logger.info("--> deleting the shard data [{}] ", Arrays.toString(shardLocation));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // verify again after cluster was shut down, +        assertThat(FileSystemUtils.deleteRecursively(shardLocation), equalTo(true));, +++ b/src/test/java/org/elasticsearch/search/preference/SearchPreferenceTests.java, +        final Client client = cluster().smartClient();, +++ b/src/test/java/org/elasticsearch/cluster/allocation/ClusterRerouteTests.java, +import java.util.Arrays;, +        File[] shardLocation = cluster().getInstance(NodeEnvironment.class, node_1).shardLocations(new ShardId("test", 0));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // make sure the data is there!, +        cluster().closeNonSharedNodes(false); // don't wipe data directories the index needs to be there!, +        logger.info("--> deleting the shard data [{}] ", Arrays.toString(shardLocation));, +        assertThat(FileSystemUtils.exists(shardLocation), equalTo(true)); // verify again after cluster was shut down, +        assertThat(FileSystemUtils.deleteRecursively(shardLocation), equalTo(true));, +++ b/src/test/java/org/elasticsearch/search/preference/SearchPreferenceTests.java, +        final Client client = cluster().smartClient();, +++ b/src/test/java/org/elasticsearch/test/TestCluster.java, +import org.junit.Assert;, +        Assert.fail("No master client found");, +        return null; // can't happen, +        Assert.fail("No non-master client found");, +        return null; // can't happen, +        startNodeClient(ImmutableSettings.EMPTY);, +        return getRandomNodeAndClient(new ClientNodePredicate()).client(random);, +    }, +    , +    public synchronized Client smartClient() {, +        NodeAndClient randomNodeAndClient = getRandomNodeAndClient();, +        if (randomNodeAndClient != null) {, +            return randomNodeAndClient.nodeClient();, +        }, +        Assert.fail("No smart client found");, +        return null; // can't happen, +            if (nodeClient != null) {, +                nodeClient.close();, +                nodeClient = null;, +            }, +                    .put("name", "transport_client_" + node.settings().get("name")), +    public class RandomClientFactory extends ClientFactory {, +//                    if (logger.isDebugEnabled()) {, +//                        logger.debug("Using transport client for node [{}] sniff: [{}]", node.settings().get("name"), false);, +//                    }, +//                    if (logger.isDebugEnabled()) {, +//                        logger.debug("Using transport client for node [{}] sniff: [{}]", node.settings().get("name"), true);, +//                    }, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("Using node client for node [{}]", node.settings().get("name"));, +                    }, +        reset(random, true);, +    }, +, +    private synchronized void reset(Random random, boolean wipeData) {, +        if (wipeData) {, +        }, +        resetClients(); /* reset all clients - each test gets it's own client based on the Random instance created above. */, +, +    public void closeNonSharedNodes(boolean wipeData) {, +        reset(random, wipeData);]