[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +                modules.add(new SearchModule(settings, namedWriteableRegistry, true));, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +                modules.add(new SearchModule(settings, namedWriteableRegistry, true));, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new SearchModule(settings, namedWriteableRegistry, false));, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +                modules.add(new SearchModule(settings, namedWriteableRegistry, true));, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new SearchModule(settings, namedWriteableRegistry, false));, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.InternalAggregation;, +    private final boolean transportClient;, +    public SearchModule(Settings settings, NamedWriteableRegistry namedWriteableRegistry, boolean transportClient) {, +        this.transportClient = transportClient;, +        registerBuiltinAggregations();, +     * @param builderReader reads the {@link AggregationBuilder} from a stream, +     * @param internalReader reads the {@link InternalAggregation} from a stream, +    public void registerAggregation(Writeable.Reader<? extends AggregationBuilder> builderReader,, +            Writeable.Reader<? extends InternalAggregation> internalReader, Aggregator.Parser aggregationParser,, +        if (false == transportClient) {, +            namedWriteableRegistry.register(AggregationBuilder.class, aggregationName.getPreferredName(), builderReader);, +        }, +        namedWriteableRegistry.register(InternalAggregation.class, aggregationName.getPreferredName(), internalReader);, +    }, +, +    public void registerAggregation(Writeable.Reader<? extends AggregationBuilder> builderReader, Aggregator.Parser aggregationParser,, +            ParseField aggregationName) {, +        // NORELEASE remove me in favor of the above method, +        namedWriteableRegistry.register(AggregationBuilder.class, aggregationName.getPreferredName(), builderReader);, +        aggregationParserRegistry.register(aggregationParser, aggregationName);, +        if (false == transportClient) {, +            /*, +             * Nothing is bound for transport client *but* SearchModule is still responsible for settings up the things like the, +             * NamedWriteableRegistry., +             */, +            bind(AggregatorParsers.class).toInstance(aggregatorParsers);, +        }, +    private void registerBuiltinAggregations() {, +        registerAggregation(AvgAggregationBuilder::new, InternalAvg::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +                modules.add(new SearchModule(settings, namedWriteableRegistry, true));, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new SearchModule(settings, namedWriteableRegistry, false));, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.InternalAggregation;, +    private final boolean transportClient;, +    public SearchModule(Settings settings, NamedWriteableRegistry namedWriteableRegistry, boolean transportClient) {, +        this.transportClient = transportClient;, +        registerBuiltinAggregations();, +     * @param builderReader reads the {@link AggregationBuilder} from a stream, +     * @param internalReader reads the {@link InternalAggregation} from a stream, +    public void registerAggregation(Writeable.Reader<? extends AggregationBuilder> builderReader,, +            Writeable.Reader<? extends InternalAggregation> internalReader, Aggregator.Parser aggregationParser,, +        if (false == transportClient) {, +            namedWriteableRegistry.register(AggregationBuilder.class, aggregationName.getPreferredName(), builderReader);, +        }, +        namedWriteableRegistry.register(InternalAggregation.class, aggregationName.getPreferredName(), internalReader);, +    }, +, +    public void registerAggregation(Writeable.Reader<? extends AggregationBuilder> builderReader, Aggregator.Parser aggregationParser,, +            ParseField aggregationName) {, +        // NORELEASE remove me in favor of the above method, +        namedWriteableRegistry.register(AggregationBuilder.class, aggregationName.getPreferredName(), builderReader);, +        aggregationParserRegistry.register(aggregationParser, aggregationName);, +        if (false == transportClient) {, +            /*, +             * Nothing is bound for transport client *but* SearchModule is still responsible for settings up the things like the, +             * NamedWriteableRegistry., +             */, +            bind(AggregatorParsers.class).toInstance(aggregatorParsers);, +        }, +    private void registerBuiltinAggregations() {, +        registerAggregation(AvgAggregationBuilder::new, InternalAvg::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +import org.elasticsearch.common.io.stream.NamedWriteable;, +public abstract class InternalAggregation implements Aggregation, ToXContent, Streamable, NamedWriteable {, +    // NORELEASE remove Streamable, +    /**, +     * Read from a stream., +     */, +    protected InternalAggregation(StreamInput in) throws IOException {, +        name = in.readString();, +        metaData = in.readMap();, +        int size = in.readVInt();, +        if (size == 0) {, +            pipelineAggregators = Collections.emptyList();, +        } else {, +            pipelineAggregators = new ArrayList<>(size);, +            for (int i = 0; i < size; i++) {, +                BytesReference type = in.readBytesReference();, +                PipelineAggregator pipelineAggregator = PipelineAggregatorStreams.stream(type).readResult(in);, +                pipelineAggregators.add(pipelineAggregator);, +            }, +        }, +    }, +, +    @Override, +    public final void readFrom(StreamInput in) throws IOException {, +        try {]