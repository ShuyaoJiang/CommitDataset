[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AllocateAction.java, +        AllocationRoutedStep routedCheckStep = new AllocationRoutedStep(allocationRoutedKey, nextStepKey);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AllocateAction.java, +        AllocationRoutedStep routedCheckStep = new AllocationRoutedStep(allocationRoutedKey, nextStepKey);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AllocationRoutedStep.java, +    AllocationRoutedStep(StepKey key, StepKey nextStepKey) {, +, +        }, +, +            logger.debug("{} lifecycle action [{}] waiting for [{}] shards to be allocated to nodes matching the given filters",, +                index, getKey().getAction(), allocationPendingAllShards);, +            logger.debug("{} lifecycle action for [{}] complete", index, getKey().getAction());, +        return 611;, +        return super.equals(obj);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AllocateAction.java, +        AllocationRoutedStep routedCheckStep = new AllocationRoutedStep(allocationRoutedKey, nextStepKey);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AllocationRoutedStep.java, +    AllocationRoutedStep(StepKey key, StepKey nextStepKey) {, +, +        }, +, +            logger.debug("{} lifecycle action [{}] waiting for [{}] shards to be allocated to nodes matching the given filters",, +                index, getKey().getAction(), allocationPendingAllShards);, +            logger.debug("{} lifecycle action for [{}] complete", index, getKey().getAction());, +        return 611;, +        return super.equals(obj);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/CheckShrinkReadyStep.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +, +package org.elasticsearch.xpack.core.indexlifecycle;, +, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.action.support.ActiveShardCount;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.index.Index;, +, +import java.io.IOException;, +import java.util.Locale;, +import java.util.Objects;, +, +/**, + * This step is used prior to running a shrink step in order to ensure that the index being shrunk, + * has a copy of each shard allocated on one particular node (the node used by the require, + * parameter) and that the shards are not relocating., + */, +public class CheckShrinkReadyStep extends ClusterStateWaitStep {, +    public static final String NAME = "check-shrink-allocation";, +, +    private static final Logger logger = LogManager.getLogger(CheckShrinkReadyStep.class);, +, +    CheckShrinkReadyStep(StepKey key, StepKey nextStepKey) {, +        super(key, nextStepKey);, +    }, +, +    @Override, +    public Result isConditionMet(Index index, ClusterState clusterState) {, +        IndexMetaData idxMeta = clusterState.metaData().index(index);, +, +        if (idxMeta == null) {, +            // Index must have been since deleted, ignore it, +            logger.debug("[{}] lifecycle action for index [{}] executed but index no longer exists",, +                getKey().getAction(), index.getName());, +            return new Result(false, null);, +        }, +, +        // How many shards the node should have, +        int expectedShardCount = idxMeta.getNumberOfShards();, +, +        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {, +            logger.debug("[{}] shrink action for [{}] cannot make progress because not all shards are active",, +                getKey().getAction(), index.getName());, +            return new Result(false, new CheckShrinkReadyStep.Info("", expectedShardCount, -1));, +        }, +, +        // The id of the node the shards should be on, +        final String idShardsShouldBeOn = idxMeta.getSettings().get(IndexMetaData.INDEX_ROUTING_REQUIRE_GROUP_PREFIX + "._id");, +        if (idShardsShouldBeOn == null) {, +            throw new IllegalStateException("Cannot check shrink allocation as there are no allocation rules by _id");, +        }, +, +        final IndexRoutingTable routingTable = clusterState.getRoutingTable().index(index);, +        int foundShards = 0;, +        for (ShardRouting shard : routingTable.shardsWithState(ShardRoutingState.STARTED)) {, +            final String currentNodeId = shard.currentNodeId();, +            if (idShardsShouldBeOn.equals(currentNodeId) && shard.relocating() == false) {, +                foundShards++;]