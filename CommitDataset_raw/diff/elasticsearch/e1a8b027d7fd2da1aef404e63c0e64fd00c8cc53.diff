[+++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +import org.elasticsearch.*;, +import org.elasticsearch.cluster.routing.*;, +        protected void doStart() throws ElasticsearchException {, +                        return;, +                    return;, +                        return;, +                return;, +                retryBecauseUnavailable(shardIt.shardId(), "No active shards.");, +                return;, +                    retryBecauseUnavailable(shardIt.shardId(), "Primary shard is not active or isn't assigned is a known node.");, +                    return;, +                    return;, +                                        performOnPrimary(shard.id(), shard);, +                            performOnPrimary(shard.id(), shard);, +                                retry(exp);, +                retryBecauseUnavailable(shardIt.shardId(), "No active shards.");, +        void retry(Throwable failure) {, +            assert failure != null;, +                listener.onFailure(failure);, +                    // Try one more time..., +                    doStart();, +        void performOnPrimary(int primaryShardId, final ShardRouting shard) {, +            ClusterState clusterState = observer.observedState();, +            if (raiseFailureIfHaveNotEnoughActiveShardCopies(shard, clusterState)) {, +                return;, +                            public void onFailure(Throwable t) {, +                            }, +        boolean raiseFailureIfHaveNotEnoughActiveShardCopies(ShardRouting shard, ClusterState state) {, +            if (!checkWriteConsistency) {, +                return false;, +            }, +, +            final WriteConsistencyLevel consistencyLevel;, +            if (internalRequest.request().consistencyLevel() != WriteConsistencyLevel.DEFAULT) {, +                consistencyLevel = internalRequest.request().consistencyLevel();, +            } else {, +                consistencyLevel = defaultWriteConsistencyLevel;, +            }, +            final int sizeActive;, +            final int requiredNumber;, +            IndexRoutingTable indexRoutingTable =  state.getRoutingTable().index(shard.index());, +            if (indexRoutingTable != null) {, +                IndexShardRoutingTable shardRoutingTable = indexRoutingTable.shard(shard.getId());, +                if (shardRoutingTable != null) {, +                    sizeActive =  shardRoutingTable.activeShards().size();, +                    if (consistencyLevel == WriteConsistencyLevel.QUORUM && shardRoutingTable.getSize() > 2) {, +                        // only for more than 2 in the number of shardIt it makes sense, otherwise its 1 shard with 1 replica, quorum is 1 (which is what it is initialized to), +                        requiredNumber = (shardRoutingTable.getSize() / 2) + 1;, +                    } else if (consistencyLevel == WriteConsistencyLevel.ALL) {, +                        requiredNumber = shardRoutingTable.getSize();, +                    } else {, +                        requiredNumber = 1;, +                    }, +                } else {, +                    sizeActive = 0;, +                    requiredNumber = 1;, +                }, +            } else {, +                sizeActive = 0;, +                requiredNumber = 1;, +            }, +, +            if (sizeActive < requiredNumber) {, +                logger.trace("not enough active copies of shard [{}] to meet write consistency of [{}] (have {}, needed {}), scheduling a retry.",, +                        shard.shardId(), consistencyLevel, sizeActive, requiredNumber);, +                primaryOperationStarted.set(false);, +                // A dedicated exception would be nice..., +                retryBecauseUnavailable(shard.shardId(), "Not enough active copies to meet write consistency of [" + consistencyLevel + "] (have " + sizeActive + ", needed " + requiredNumber + ").");, +                return true;, +            } else {, +                return false;, +            }, +        }, +, +        void retryBecauseUnavailable(ShardId shardId, String message) {, +            retry(new UnavailableShardsException(shardId, message + " Timeout: [" + internalRequest.request().timeout() +"], request: " +  internalRequest.request().toString()));, +        }, +, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +import org.elasticsearch.*;, +import org.elasticsearch.cluster.routing.*;, +        protected void doStart() throws ElasticsearchException {, +                        return;, +                    return;, +                        return;, +                return;, +                retryBecauseUnavailable(shardIt.shardId(), "No active shards.");, +                return;, +                    retryBecauseUnavailable(shardIt.shardId(), "Primary shard is not active or isn't assigned is a known node.");, +                    return;, +                    return;, +                                        performOnPrimary(shard.id(), shard);, +                            performOnPrimary(shard.id(), shard);, +                                retry(exp);, +                retryBecauseUnavailable(shardIt.shardId(), "No active shards.");, +        void retry(Throwable failure) {, +            assert failure != null;, +                listener.onFailure(failure);, +                    // Try one more time...]