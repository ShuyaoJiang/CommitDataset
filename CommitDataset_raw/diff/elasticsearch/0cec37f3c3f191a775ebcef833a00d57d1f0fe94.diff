[+++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGateway.java, +import org.elasticsearch.action.admin.indices.flush.FlushRequest;, +import org.elasticsearch.index.engine.FlushNotAllowedEngineException;, +        indexShard.prepareForIndexRecovery();, +            Path recoveringTranslogFile = null;, +                logger.trace("no translog id set (indexShouldExist [{}])", indexShouldExists);, +            } else {, +            }, +            // we must do this *after* we capture translog name so the engine creation will not make a new one., +            // also we have to do this regardless of whether we have a translog, to follow the recovery stages., +            indexShard.prepareForTranslogRecovery();, +                indexShard.finalizeRecovery();, +            // we flush to trim the translog, in case it was big., +            try {, +                FlushRequest flushRequest = new FlushRequest();, +                flushRequest.force(false);, +                flushRequest.waitIfOngoing(false);, +                indexShard.flush(flushRequest);, +            } catch (FlushNotAllowedEngineException e) {, +                // to be safe we catch the FNAEX , at this point no one can recover, +                logger.debug("skipping flush at end of recovery (not allowed)", e);, +            }, +            indexShard.finalizeRecovery();, +            indexShard.postRecovery("post recovery from gateway");, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGateway.java, +import org.elasticsearch.action.admin.indices.flush.FlushRequest;, +import org.elasticsearch.index.engine.FlushNotAllowedEngineException;, +        indexShard.prepareForIndexRecovery();, +            Path recoveringTranslogFile = null;, +                logger.trace("no translog id set (indexShouldExist [{}])", indexShouldExists);, +            } else {, +            }, +            // we must do this *after* we capture translog name so the engine creation will not make a new one., +            // also we have to do this regardless of whether we have a translog, to follow the recovery stages., +            indexShard.prepareForTranslogRecovery();, +                indexShard.finalizeRecovery();, +            // we flush to trim the translog, in case it was big., +            try {, +                FlushRequest flushRequest = new FlushRequest();, +                flushRequest.force(false);, +                flushRequest.waitIfOngoing(false);, +                indexShard.flush(flushRequest);, +            } catch (FlushNotAllowedEngineException e) {, +                // to be safe we catch the FNAEX , at this point no one can recover, +                logger.debug("skipping flush at end of recovery (not allowed)", e);, +            }, +            indexShard.finalizeRecovery();, +            indexShard.postRecovery("post recovery from gateway");, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    final RecoveryState recoveryState = indexShard.recoveryState();, +                    // Check that the gateway have set the shard to POST_RECOVERY. Note that if a shard, +                    // is in POST_RECOVERY, it may have been started as well if:, +                    assert shardState == IndexShardState.POST_RECOVERY || shardState == IndexShardState.STARTED : "recovery process didn't call post_recovery. shardState [" + shardState + "]";, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGateway.java, +import org.elasticsearch.action.admin.indices.flush.FlushRequest;, +import org.elasticsearch.index.engine.FlushNotAllowedEngineException;, +        indexShard.prepareForIndexRecovery();, +            Path recoveringTranslogFile = null;, +                logger.trace("no translog id set (indexShouldExist [{}])", indexShouldExists);, +            } else {, +            }, +            // we must do this *after* we capture translog name so the engine creation will not make a new one., +            // also we have to do this regardless of whether we have a translog, to follow the recovery stages., +            indexShard.prepareForTranslogRecovery();, +                indexShard.finalizeRecovery();, +            // we flush to trim the translog, in case it was big., +            try {, +                FlushRequest flushRequest = new FlushRequest();, +                flushRequest.force(false);, +                flushRequest.waitIfOngoing(false);, +                indexShard.flush(flushRequest);, +            } catch (FlushNotAllowedEngineException e) {, +                // to be safe we catch the FNAEX , at this point no one can recover, +                logger.debug("skipping flush at end of recovery (not allowed)", e);, +            }, +            indexShard.finalizeRecovery();, +            indexShard.postRecovery("post recovery from gateway");, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    final RecoveryState recoveryState = indexShard.recoveryState();, +                    // Check that the gateway have set the shard to POST_RECOVERY. Note that if a shard, +                    // is in POST_RECOVERY, it may have been started as well if:, +                    assert shardState == IndexShardState.POST_RECOVERY || shardState == IndexShardState.STARTED : "recovery process didn't call post_recovery. shardState [" + shardState + "]";, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            recoveryState.setStage(RecoveryState.Stage.DONE);, +    /** called before starting to copy index files over */, +    public void prepareForIndexRecovery() throws ElasticsearchException {, +        recoveryState.setStage(RecoveryState.Stage.INDEX);, +        assert currentEngineReference.get() == null;, +    }, +, +    /**, +     * After the store has been recovered, we need to start the engine in order to apply operations, +     */, +    public void prepareForTranslogRecovery() throws ElasticsearchException {, +        if (state != IndexShardState.RECOVERING) {, +            throw new IndexShardNotRecoveringException(shardId, state);, +        }, +        recoveryState.setStage(RecoveryState.Stage.START);, +        recoveryState.setStage(RecoveryState.Stage.TRANSLOG);, +            recoveryState().setStage(RecoveryState.Stage.INIT);]