[+++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +++ b/core/src/main/java/org/elasticsearch/rest/action/admin/indices/RestGetMappingAction.java, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.rest.RestStatus;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Locale;, +import java.util.Set;, +import java.util.SortedSet;, +import java.util.stream.Collectors;, +import static org.elasticsearch.rest.RestRequest.Method.HEAD;, +, +    public RestGetMappingAction(final Settings settings, final RestController controller) {, +        controller.registerHandler(HEAD, "/{index}/_mapping/{type}", this);, +        final GetMappingsRequest getMappingsRequest = new GetMappingsRequest();, +            public RestResponse buildResponse(final GetMappingsResponse response, final XContentBuilder builder) throws Exception {, +                final ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsByIndex = response.getMappings();, +                if (mappingsByIndex.isEmpty() && (indices.length != 0 || types.length != 0)) {, +                    if (indices.length != 0 && types.length == 0) {, +                        return new BytesRestResponse(channel, new IndexNotFoundException(String.join(",", indices)));, +                        builder.close();, +                        return new BytesRestResponse(channel, new TypeMissingException("_all", String.join(",", types)));, +                final Set<String> typeNames = new HashSet<>();, +                for (final ObjectCursor<ImmutableOpenMap<String, MappingMetaData>> cursor : mappingsByIndex.values()) {, +                    for (final ObjectCursor<String> inner : cursor.value.keys()) {, +                        typeNames.add(inner.value);, +                    }, +                }, +, +                final SortedSet<String> difference = Sets.sortedDifference(Arrays.stream(types).collect(Collectors.toSet()), typeNames);, +, +                // now remove requested aliases that contain wildcards that are simple matches, +                final List<String> matches = new ArrayList<>();, +                outer:, +                for (final String pattern : difference) {, +                    if (pattern.contains("*")) {, +                        for (final String typeName : typeNames) {, +                            if (Regex.simpleMatch(pattern, typeName)) {, +                                matches.add(pattern);, +                                continue outer;, +                            }, +                        }, +                    }, +                }, +                difference.removeAll(matches);, +, +                final RestStatus status;, +                {, +                    if (difference.isEmpty()) {, +                        status = RestStatus.OK;, +                    } else {, +                        status = RestStatus.NOT_FOUND;, +                        final String message;, +                        if (difference.size() == 1) {, +                            message = String.format(Locale.ROOT, "type [%s] missing", toNamesString(difference.iterator().next()));, +                        } else {, +                            message = String.format(Locale.ROOT, "types [%s] missing", toNamesString(difference.toArray(new String[0])));, +                        builder.field("error", message);, +                        builder.field("status", status.getStatus());, +                    for (final ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappingsByIndex) {, +                        builder.startObject(indexEntry.key);, +                        {, +                            builder.startObject("mappings");, +                            {, +                                for (final ObjectObjectCursor<String, MappingMetaData> typeEntry : indexEntry.value) {, +                                    builder.field(typeEntry.key, typeEntry.value.sourceAsMap());, +                                }, +                            }, +                        }, +                        builder.endObject();, +                    }, +                }, +                builder.endObject();, +                return new BytesRestResponse(status, builder);, +    private static String toNamesString(final String... names) {, +        return Arrays.stream(names).collect(Collectors.joining(","));, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +++ b/core/src/main/java/org/elasticsearch/rest/action/admin/indices/RestGetMappingAction.java, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.rest.RestStatus;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Locale;, +import java.util.Set;, +import java.util.SortedSet;, +import java.util.stream.Collectors;, +import static org.elasticsearch.rest.RestRequest.Method.HEAD;, +, +    public RestGetMappingAction(final Settings settings, final RestController controller) {, +        controller.registerHandler(HEAD, "/{index}/_mapping/{type}", this);]