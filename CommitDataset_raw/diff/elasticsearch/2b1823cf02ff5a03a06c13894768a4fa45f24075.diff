[+++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import com.google.common.collect.Maps;, +import org.elasticsearch.common.Nullable;, +import java.util.*;, +        updateMappingOnMaster(index, documentMapper, indexUUID, null);, +    }, +, +    public void updateMappingOnMaster(String index, DocumentMapper documentMapper, String indexUUID, MappingUpdateListener listener) {, +        masterMappingUpdater.add(new MappingChange(documentMapper, index, indexUUID, listener));, +        public final MappingUpdateListener listener;, +        MappingChange(DocumentMapper documentMapper, String index, String indexUUID, MappingUpdateListener listener) {, +            this.listener = listener;, +     * A listener to be notified when the mappings were updated, +     */, +    public static interface MappingUpdateListener {, +, +        void onMappingUpdate();, +, +        void onFailure(Throwable t);, +    }, +, +    /**, +        class UpdateKey {, +            public final String indexUUID;, +            public final String type;, +, +            UpdateKey(String indexUUID, String type) {, +                this.indexUUID = indexUUID;, +                this.type = type;, +            }, +, +            @Override, +            public boolean equals(Object o) {, +                if (this == o) return true;, +                if (o == null || getClass() != o.getClass()) return false;, +, +                UpdateKey updateKey = (UpdateKey) o;, +, +                if (!indexUUID.equals(updateKey.indexUUID)) return false;, +                if (!type.equals(updateKey.type)) return false;, +, +                return true;, +            }, +, +            @Override, +            public int hashCode() {, +                int result = indexUUID.hashCode();, +                result = 31 * result + type.hashCode();, +                return result;, +            }, +        }, +, +        class UpdateValue {, +            public final MappingChange mainChange;, +            public final List<MappingUpdateListener> listeners = Lists.newArrayList();, +, +            UpdateValue(MappingChange mainChange) {, +                this.mainChange = mainChange;, +            }, +, +            public void notifyListeners(@Nullable Throwable t) {, +                for (MappingUpdateListener listener : listeners) {, +                    try {, +                        if (t == null) {, +                            listener.onMappingUpdate();, +                        } else {, +                            listener.onFailure(t);, +                        }, +                    } catch (Throwable lisFailure) {, +                        logger.warn("unexpected failure on mapping update listener callback [{}]", lisFailure, listener);, +                    }, +                }, +            }, +        }, +, +            Map<UpdateKey, UpdateValue> pendingUpdates = Maps.newHashMap();, +                    // go over and add to pending updates map, +                        UpdateKey key = new UpdateKey(change.indexUUID, change.documentMapper.type());, +                        UpdateValue updateValue = pendingUpdates.get(key);, +                        if (updateValue == null) {, +                            updateValue = new UpdateValue(change);, +                            pendingUpdates.put(key, updateValue);, +                        if (change.listener != null) {, +                            updateValue.listeners.add(change.listener);, +                        }, +                    }, +, +                    for (Iterator<UpdateValue> iterator = pendingUpdates.values().iterator(); iterator.hasNext(); ) {, +                        final UpdateValue updateValue = iterator.next();, +                        iterator.remove();, +                        MappingChange change = updateValue.mainChange;, +                            updateValue.notifyListeners(t);, +                                updateValue.notifyListeners(null);, +                                updateValue.notifyListeners(e);, +                    if (t instanceof InterruptedException && !running) {, +                        // all is well, we are shutting down, +                    } else {, +                    // cleanup all pending update callbacks that were not processed due to a global failure..., +                    for (Iterator<Map.Entry<UpdateKey, UpdateValue>> iterator = pendingUpdates.entrySet().iterator(); iterator.hasNext(); ) {, +                        Map.Entry<UpdateKey, UpdateValue> entry = iterator.next();]