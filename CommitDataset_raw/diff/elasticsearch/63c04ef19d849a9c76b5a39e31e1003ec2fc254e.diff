[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.action.support.tasks.BaseTasksRequest;, +import org.elasticsearch.action.support.tasks.TransportTasksAction;, +import org.elasticsearch.xpack.ml.job.JobManager;, +import org.elasticsearch.xpack.ml.utils.ExceptionsHelper;, +import java.util.HashSet;, +    public static class Request extends BaseTasksRequest<Request> implements ToXContent {, +                request.setJobId(jobId);, +        private String jobId;, +        private TimeValue timeout = TimeValue.timeValueMinutes(20);, +, +        String[] resolvedJobIds;, +            this.jobId = jobId;, +            // the default implementation just returns 1 jobId, +            this.resolvedJobIds = new String[] { jobId };, +        }, +, +        public String getJobId() {, +            return jobId;, +            this.resolvedJobIds = new String[] { jobId };, +            jobId = in.readString();, +            resolvedJobIds = in.readStringArray();, +            out.writeString(jobId);, +            out.writeStringArray(resolvedJobIds);, +        }, +, +        @Override, +        public boolean match(Task task) {, +            for (String id : resolvedJobIds) {, +                if (OpenJobAction.JobTask.match(task, id)) {, +                    return true;, +                }, +            }, +            return false;, +    public static class TransportAction extends TransportTasksAction<OpenJobAction.JobTask, Request, Response, Response> {, +                               ClusterService clusterService, InternalClient client,, +                    indexNameExpressionResolver, Request::new, Response::new, ThreadPool.Names.MANAGEMENT);, +            ClusterState state = clusterService.state();, +            request.resolvedJobIds = resolveAndValidateJobId(request.getJobId(), state).toArray(new String[0]);, +            Set<String> executorNodes = new HashSet<>();, +            for (String resolvedJobId : request.resolvedJobIds) {, +                JobManager.getJobOrThrowIfUnknown(state, resolvedJobId);, +                PersistentTasksCustomMetaData tasks = state.metaData().custom(PersistentTasksCustomMetaData.TYPE);, +                PersistentTasksCustomMetaData.PersistentTask<?> jobTask = MlMetadata.getJobTask(resolvedJobId, tasks);, +                if (jobTask == null || jobTask.isAssigned() == false) {, +                    String message = "Cannot perform requested action because job [" + resolvedJobId, +                            + "] is not open";, +                    listener.onFailure(ExceptionsHelper.conflictStatusException(message));, +                    return;, +                } else {, +                    executorNodes.add(jobTask.getExecutorNode());, +                }, +            }, +            request.setNodes(executorNodes.toArray(new String[executorNodes.size()]));, +            if (request.resolvedJobIds.length == 0) {, +                forceCloseJob(state, request, listener);, +                normalCloseJob(state, task, request, listener);, +        protected void taskOperation(Request request, OpenJobAction.JobTask task, ActionListener<Response> listener) {, +        protected boolean accumulateExceptions() {, +            return true;, +        }, +, +        @Override, +            if (request.resolvedJobIds.length != tasks.size()) {, +                            "Expected [" + request.resolvedJobIds.length, +            final int numberOfJobs = request.resolvedJobIds.length;, +            final AtomicArray<Exception> failures = new AtomicArray<>(numberOfJobs);, +            for (String jobId : request.resolvedJobIds) {, +            for (String jobId : request.resolvedJobIds) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.action.support.tasks.BaseTasksRequest;, +import org.elasticsearch.action.support.tasks.TransportTasksAction;, +import org.elasticsearch.xpack.ml.job.JobManager;, +import org.elasticsearch.xpack.ml.utils.ExceptionsHelper;, +import java.util.HashSet;, +    public static class Request extends BaseTasksRequest<Request> implements ToXContent {, +                request.setJobId(jobId);, +        private String jobId;, +        private TimeValue timeout = TimeValue.timeValueMinutes(20);, +, +        String[] resolvedJobIds;, +            this.jobId = jobId;, +            // the default implementation just returns 1 jobId, +            this.resolvedJobIds = new String[] { jobId };, +        }, +, +        public String getJobId() {, +            return jobId;, +            this.resolvedJobIds = new String[] { jobId };, +            jobId = in.readString();, +            resolvedJobIds = in.readStringArray();, +            out.writeString(jobId);, +            out.writeStringArray(resolvedJobIds);, +        }, +, +        @Override, +        public boolean match(Task task) {, +            for (String id : resolvedJobIds) {, +                if (OpenJobAction.JobTask.match(task, id)) {, +                    return true;]