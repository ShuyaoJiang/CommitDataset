[+++ b/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +    private final String prefix;, +    private final Pattern stateFilePattern;, +, +    protected MetaDataStateFormat(XContentType format, String prefix) {, +        this.prefix = prefix;, +        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?");, +, +    public final void write(final T state, final long version, final Path... locations) throws IOException {, +        final long maxStateId = findMaxStateId(prefix, locations)+1;, +        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]";, +        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION;, +    public final T read(Path file) throws IOException {, +                indexInput.readLong(); // version currently unused, +    long findMaxStateId(final String prefix, Path... locations) throws IOException {, +        long maxId = -1;, +        for (Path dataLocation : locations) {, +            final Path resolve = dataLocation.resolve(STATE_DIR_NAME);, +            if (Files.exists(resolve)) {, +                try (DirectoryStream<Path> stream = Files.newDirectoryStream(resolve, prefix + "*")) {, +                    for (Path stateFile : stream) {, +                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString());, +                        if (matcher.matches()) {, +                            final long id = Long.parseLong(matcher.group(1));, +                            maxId = Math.max(maxId, id);, +                        }, +                    }, +                }, +            }, +        }, +        return maxId;, +    }, +, +    public  T loadLatestState(ESLogger logger, Path... dataLocations) throws IOException {, +        List<PathAndStateId> files = new ArrayList<>();, +        long maxStateId = -1;, +        boolean maxStateIdIsLegacy = true;, +                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString());, +                            final long stateId = Long.parseLong(matcher.group(1));, +                            maxStateId = Math.max(maxStateId, stateId);, +                            maxStateIdIsLegacy &= legacy; // on purpose, see NOTE below, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId, legacy);, +        for (PathAndStateId pathAndStateId : Collections2.filter(files, new StateIdAndLegacyPredicate(maxStateId, maxStateIdIsLegacy))) {, +                final Path stateFile = pathAndStateId.file;, +                final long id = pathAndStateId.id;, +                if (pathAndStateId.legacy) { // read the legacy format -- plain XContent, +                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath());, +                    state = fromXContent(parser);, +                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath());, +                    state = read(stateFile);, +                    logger.trace("state id [{}] read from [{}]", id, stateFile.getFileName());, +                logger.debug("{}: failed to read [{}], ignoring...", e, pathAndStateId.file.toAbsolutePath(), prefix);, +     * Filters out all {@link org.elasticsearch.gateway.MetaDataStateFormat.PathAndStateId} instances with a different id than, +    private static final class StateIdAndLegacyPredicate implements Predicate<PathAndStateId> {, +        private final long id;, +        StateIdAndLegacyPredicate(long id, boolean legacy) {, +            this.id = id;, +        public boolean apply(PathAndStateId input) {, +            return input.id == id && input.legacy == legacy;, +     * Internal struct-like class that holds the parsed state id, the file, +    private static class PathAndStateId {, +        final long id;, +        private PathAndStateId(Path file, long id, boolean legacy) {, +            this.id = id;, +            return "[id:" + id + ", legacy:" + legacy + ", file:" + file.toAbsolutePath() + "]";, +++ b/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +    private final String prefix;, +    private final Pattern stateFilePattern;, +, +    protected MetaDataStateFormat(XContentType format, String prefix) {, +        this.prefix = prefix;, +        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?");, +, +    public final void write(final T state, final long version, final Path... locations) throws IOException {, +        final long maxStateId = findMaxStateId(prefix, locations)+1;, +        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]";, +        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION;, +    public final T read(Path file) throws IOException {, +                indexInput.readLong(); // version currently unused, +    long findMaxStateId(final String prefix, Path... locations) throws IOException {, +        long maxId = -1;, +        for (Path dataLocation : locations) {, +            final Path resolve = dataLocation.resolve(STATE_DIR_NAME);, +            if (Files.exists(resolve)) {, +                try (DirectoryStream<Path> stream = Files.newDirectoryStream(resolve, prefix + "*")) {, +                    for (Path stateFile : stream) {, +                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString());, +                        if (matcher.matches()) {, +                            final long id = Long.parseLong(matcher.group(1));, +                            maxId = Math.max(maxId, id);, +                        }, +                    }, +                }, +            }, +        }, +        return maxId;, +    }, +, +    public  T loadLatestState(ESLogger logger, Path... dataLocations) throws IOException {, +        List<PathAndStateId> files = new ArrayList<>();]