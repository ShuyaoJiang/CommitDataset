[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +import java.util.HashSet;, +import java.util.Set;, +    private Map<ShardId, Set<String>> ignoredShardToNodes = null;, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        if (nodes == null) {, +            nodes = new HashSet<>();, +            ignoredShardToNodes.put(shardId, nodes);, +        }, +        nodes.add(nodeId);, +        if (ignoredShardToNodes == null) {, +            return false;, +        }, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        return nodes != null && nodes.contains(nodeId);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +import java.util.HashSet;, +import java.util.Set;, +    private Map<ShardId, Set<String>> ignoredShardToNodes = null;, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        if (nodes == null) {, +            nodes = new HashSet<>();, +            ignoredShardToNodes.put(shardId, nodes);, +        }, +        nodes.add(nodeId);, +        if (ignoredShardToNodes == null) {, +            return false;, +        }, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        return nodes != null && nodes.contains(nodeId);, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.*;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +import java.util.HashSet;, +import java.util.Set;, +    private Map<ShardId, Set<String>> ignoredShardToNodes = null;, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        if (nodes == null) {, +            nodes = new HashSet<>();, +            ignoredShardToNodes.put(shardId, nodes);, +        }, +        nodes.add(nodeId);, +        if (ignoredShardToNodes == null) {, +            return false;, +        }, +        Set<String> nodes = ignoredShardToNodes.get(shardId);, +        return nodes != null && nodes.contains(nodeId);, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.*;, +++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java, +import org.elasticsearch.cluster.routing.*;, +import java.util.ArrayList;, +, +    public void singleShardMultipleAllocationFailures() {, +        AllocationService strategy = createAllocationService(settingsBuilder(), +                .put("cluster.routing.allocation.concurrent_recoveries", 10), +                .put("cluster.routing.allocation.allow_rebalance", "always"), +                .build());, +, +        logger.info("Building initial routing table");, +        int numberOfReplicas = scaledRandomIntBetween(2, 10);, +        MetaData metaData = MetaData.builder(), +                .put(IndexMetaData.builder("test").numberOfShards(1).numberOfReplicas(numberOfReplicas)), +                .build();, +, +        RoutingTable routingTable = RoutingTable.builder(), +                .addAsNew(metaData.index("test")), +                .build();, +, +        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();, +, +        logger.info("Adding {} nodes and performing rerouting", numberOfReplicas + 1);, +        DiscoveryNodes.Builder nodeBuilder = DiscoveryNodes.builder();, +        for (int i = 0; i < numberOfReplicas + 1; i++) {, +            nodeBuilder.put(newNode("node" + Integer.toString(i)));, +        }, +        clusterState = ClusterState.builder(clusterState).nodes(nodeBuilder).build();, +        while (!clusterState.routingTable().shardsWithState(UNASSIGNED).isEmpty()) {, +            // start all initializing, +            clusterState = ClusterState.builder(clusterState), +                    .routingTable(strategy, +                                    .applyStartedShards(clusterState, clusterState.routingTable().shardsWithState(INITIALIZING)).routingTable(), +                    ), +                    .build();, +            // and assign more unassigned, +            clusterState = ClusterState.builder(clusterState).routingTable(strategy.reroute(clusterState).routingTable()).build();, +        }, +, +        int shardsToFail = randomIntBetween(1, numberOfReplicas);, +        ArrayList<ShardRouting> failedShards = new ArrayList<>();, +        RoutingNodes routingNodes = clusterState.routingNodes();, +        for (int i = 0; i < shardsToFail; i++) {, +            String n = "node" + Integer.toString(randomInt(numberOfReplicas));, +            logger.info("failing shard on node [{}]", n);, +            ShardRouting shardToFail = routingNodes.node(n).get(0);, +            failedShards.add(new MutableShardRouting(shardToFail));, +        }, +, +        routingTable = strategy.applyFailedShards(clusterState, failedShards).routingTable();, +]