[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java, +        return classesToPainlessClasses.values();, +    private final Map<String, Class<?>> canonicalClassNamesToClasses;, +    private final Map<Class<?>, PainlessClass> classesToPainlessClasses;, +    PainlessLookup(Map<String, Class<?>> canonicalClassNamesToClasses, Map<Class<?>, PainlessClass> classesToPainlessClasses) {, +        this.canonicalClassNamesToClasses = Collections.unmodifiableMap(canonicalClassNamesToClasses);, +        this.classesToPainlessClasses = Collections.unmodifiableMap(classesToPainlessClasses);, +        return canonicalClassNamesToClasses.get(painlessType.replace('$', '.'));, +        return canonicalClassNamesToClasses.containsKey(painlessType);, +        return classesToPainlessClasses.get(clazz);, +        return PainlessLookupUtility.canonicalTypeNameToType(painlessType, canonicalClassNamesToClasses);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java, +        return classesToPainlessClasses.values();, +    private final Map<String, Class<?>> canonicalClassNamesToClasses;, +    private final Map<Class<?>, PainlessClass> classesToPainlessClasses;, +    PainlessLookup(Map<String, Class<?>> canonicalClassNamesToClasses, Map<Class<?>, PainlessClass> classesToPainlessClasses) {, +        this.canonicalClassNamesToClasses = Collections.unmodifiableMap(canonicalClassNamesToClasses);, +        this.classesToPainlessClasses = Collections.unmodifiableMap(classesToPainlessClasses);, +        return canonicalClassNamesToClasses.get(painlessType.replace('$', '.'));, +        return canonicalClassNamesToClasses.containsKey(painlessType);, +        return classesToPainlessClasses.get(clazz);, +        return PainlessLookupUtility.canonicalTypeNameToType(painlessType, canonicalClassNamesToClasses);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +        copyPainlessClassMembers();, +        cacheRuntimeHandles();, +        setFunctionalInterfaceMethods();, +, +        Map<Class<?>, PainlessClass> classesToPainlessClasses = new HashMap<>(classesToPainlessClassBuilders.size());, +, +        for (Map.Entry<Class<?>, PainlessClassBuilder> painlessClassBuilderEntry : classesToPainlessClassBuilders.entrySet()) {, +            classesToPainlessClasses.put(painlessClassBuilderEntry.getKey(), painlessClassBuilderEntry.getValue().build());, +        }, +, +        return new PainlessLookup(canonicalClassNamesToClasses, classesToPainlessClasses);, +    }, +, +    private void copyPainlessClassMembers() {, +        for (Class<?> parentClass : classesToPainlessClassBuilders.keySet()) {, +            copyPainlessInterfaceMembers(parentClass, parentClass);, +, +            Class<?> childClass = parentClass.getSuperclass();, +, +            while (childClass != null) {, +                if (classesToPainlessClassBuilders.containsKey(childClass)) {, +                    copyPainlessClassMembers(childClass, parentClass);, +                }, +, +                copyPainlessInterfaceMembers(childClass, parentClass);, +                childClass = childClass.getSuperclass();, +            }, +        }, +, +            if (javaClass.isInterface()) {, +                copyPainlessClassMembers(Object.class, javaClass);, +    private void copyPainlessInterfaceMembers(Class<?> parentClass, Class<?> targetClass) {, +        for (Class<?> childClass : parentClass.getInterfaces()) {, +            if (classesToPainlessClassBuilders.containsKey(childClass)) {, +                copyPainlessClassMembers(childClass, targetClass);, +            copyPainlessInterfaceMembers(childClass, targetClass);, +        }, +    private void copyPainlessClassMembers(Class<?> originalClass, Class<?> targetClass) {, +        PainlessClassBuilder originalPainlessClassBuilder = classesToPainlessClassBuilders.get(originalClass);, +        PainlessClassBuilder targetPainlessClassBuilder = classesToPainlessClassBuilders.get(targetClass);, +, +        Objects.requireNonNull(originalPainlessClassBuilder);, +        Objects.requireNonNull(targetPainlessClassBuilder);, +, +        for (Map.Entry<String, PainlessMethod> painlessMethodEntry : originalPainlessClassBuilder.methods.entrySet()) {, +            String painlessMethodKey = painlessMethodEntry.getKey();, +            PainlessMethod newPainlessMethod = painlessMethodEntry.getValue();, +            PainlessMethod existingPainlessMethod = targetPainlessClassBuilder.methods.get(painlessMethodKey);, +, +            if (existingPainlessMethod == null || existingPainlessMethod.target != newPainlessMethod.target &&, +                    existingPainlessMethod.target.isAssignableFrom(newPainlessMethod.target)) {, +                targetPainlessClassBuilder.methods.put(painlessMethodKey, newPainlessMethod);, +            }, +        }, +, +        for (Map.Entry<String, PainlessField> painlessFieldEntry : originalPainlessClassBuilder.members.entrySet()) {, +            String painlessFieldKey = painlessFieldEntry.getKey();, +            PainlessField newPainlessField = painlessFieldEntry.getValue();, +            PainlessField existingPainlessField = targetPainlessClassBuilder.members.get(painlessFieldKey);, +, +            if (existingPainlessField == null || existingPainlessField.target != newPainlessField.target &&, +                    existingPainlessField.target.isAssignableFrom(newPainlessField.target)) {, +                targetPainlessClassBuilder.members.put(painlessFieldKey, newPainlessField);, +            }, +        }, +    }, +, +    private void cacheRuntimeHandles() {, +        for (PainlessClassBuilder painlessClassBuilder : classesToPainlessClassBuilders.values()) {, +            cacheRuntimeHandles(painlessClassBuilder);, +        }, +    }, +, +    private void cacheRuntimeHandles(PainlessClassBuilder painlessClassBuilder) {, +        for (PainlessMethod painlessMethod : painlessClassBuilder.methods.values()) {, +            String methodName = painlessMethod.name;, +            int typeParametersSize = painlessMethod.arguments.size();]