[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                localCheckpoint = SequenceNumbersService.PRE_60_NODE_LOCAL_CHECKPOINT;, +            } else {, +                globalCheckpoint = SequenceNumbersService.UNASSIGNED_SEQ_NO;, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                localCheckpoint = SequenceNumbersService.PRE_60_NODE_LOCAL_CHECKPOINT;, +            } else {, +                globalCheckpoint = SequenceNumbersService.UNASSIGNED_SEQ_NO;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/GlobalCheckpointTracker.java, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import java.io.IOException;, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.Map;, +    /**, +     * The global checkpoint tracker can operate in two modes:, +     * - primary: this shard is in charge of collecting local checkpoint information from all shard copies and computing the global, +     *            checkpoint based on the local checkpoints of all in-sync shard copies., +     * - replica: this shard receives global checkpoint information from the primary (see {@link #updateGlobalCheckpointOnReplica})., +     *, +     * When a shard is initialized (be it a primary or replica), it initially operates in replica mode. The global checkpoint tracker is, +     * then switched to primary mode in the following three scenarios:, +     *, +     * - An initializing primary shard that is not a relocation target is moved to primary mode (using {@link #activatePrimaryMode}) once, +     *   the shard becomes active., +     * - An active replica shard is moved to primary mode (using {@link #activatePrimaryMode}) once it is promoted to primary., +     * - A primary relocation target is moved to primary mode (using {@link #activateWithPrimaryContext}) during the primary relocation, +     *   handoff. If the target shard is successfully initialized in primary mode, the source shard of a primary relocation is then moved, +     *   to replica mode (using {@link #completeRelocationHandoff}), as the relocation target will be in charge of the global checkpoint, +     *   computation from that point on., +     */, +    boolean primaryMode;, +    /**, +     * Boolean flag that indicates if a relocation handoff is in progress. A handoff is started by calling {@link #startRelocationHandoff}, +     * and is finished by either calling {@link #completeRelocationHandoff} or {@link #abortRelocationHandoff}, depending on whether the, +     * handoff was successful or not. During the handoff, which has as main objective to transfer the internal state of the global, +     * checkpoint tracker from the relocation source to the target, the list of in-sync shard copies cannot grow, otherwise the relocation, +     * target might miss this information and increase the global checkpoint to eagerly. As consequence, some of the methods in this class, +     * are not allowed to be called while a handoff is in progress, in particular {@link #markAllocationIdAsInSync}., +     *, +     * A notable exception to this is the method {@link #updateFromMaster}, which is still allowed to be called during a relocation handoff., +     * The reason for this is that the handoff might fail and can be aborted (using {@link #abortRelocationHandoff}), in which case, +     * it is important that the global checkpoint tracker does not miss any state updates that might happened during the handoff attempt., +     * This means, however, that the global checkpoint can still advance after the primary relocation handoff has been initiated, but only, +     * because the master could have failed some of the in-sync shard copies and marked them as stale. That is ok though, as this, +     * information is conveyed through cluster state updates, and the new primary relocation target will also eventually learn about those., +     */, +    boolean handoffInProgress;, +, +    /**, +     * The global checkpoint tracker relies on the property that cluster state updates are applied in-order. After transferring a primary, +     * context from the primary relocation source to the target and initializing the target, it is possible for the target to apply a, +     * cluster state that is older than the one upon which the primary context was based. If we allowed this old cluster state, +     * to influence the list of in-sync shard copies here, this could possibly remove such an in-sync copy from the internal structures, +     * until the newer cluster state were to be applied, which would unsafely advance the global checkpoint. This field thus captures, +     * the version of the last applied cluster state to ensure in-order updates., +     */, +    /**, +     * Local checkpoint information for all shard copies that are tracked. Has an entry for all shard copies that are either initializing, +     * and / or in-sync, possibly also containing information about unassigned in-sync shard copies. The information that is tracked for, +     * each shard copy is explained in the docs for the {@link LocalCheckpointState} class., +    final Map<String, LocalCheckpointState> localCheckpoints;, +    /**, +    /**, +     * The global checkpoint:, +     * - computed based on local checkpoints, if the tracker is in primary mode, +     * - received from the primary, if the tracker is in replica mode, +    long globalCheckpoint;, +    public static class LocalCheckpointState implements Writeable {, +, +        /**, +         * the last local checkpoint information that we have for this shard, +        long localCheckpoint;, +        /**, +         * whether this shard is treated as in-sync and thus contributes to the global checkpoint calculation, +         */, +        boolean inSync;, +, +        public LocalCheckpointState(long localCheckpoint, boolean inSync) {, +            this.localCheckpoint = localCheckpoint;, +            this.inSync = inSync;, +        }, +, +        public LocalCheckpointState(StreamInput in) throws IOException {, +            this.localCheckpoint = in.readZLong();, +            this.inSync = in.readBoolean();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeZLong(localCheckpoint);, +            out.writeBoolean(inSync);, +        }, +, +        /**, +         * Returns a full copy of this object, +         */, +        public LocalCheckpointState copy() {]