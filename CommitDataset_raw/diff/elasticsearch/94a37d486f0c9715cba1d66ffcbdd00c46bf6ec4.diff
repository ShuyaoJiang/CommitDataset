[+++ b/core/src/main/java/org/elasticsearch/index/query/GeoShapeQueryParser.java, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.geo.ShapesAvailability;, +import org.elasticsearch.common.xcontent.XContentHelper;, +                            shape = fetch(context.getClient(), getRequest, shapePath);, +, +    /**, +     * Fetches the Shape with the given ID in the given type and index., +     *, +     * @param getRequest GetRequest containing index, type and id, +     * @param path      Name or path of the field in the Shape Document where the Shape itself is located, +     * @return Shape with the given ID, +     * @throws IOException Can be thrown while parsing the Shape Document and extracting the Shape, +     */, +    private ShapeBuilder fetch(Client client, GetRequest getRequest, String path) throws IOException {, +        if (ShapesAvailability.JTS_AVAILABLE == false) {, +            throw new IllegalStateException("JTS not available");, +        }, +        getRequest.preference("_local");, +        getRequest.operationThreaded(false);, +        GetResponse response = client.get(getRequest).actionGet();, +        if (!response.isExists()) {, +            throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] not found");, +        }, +, +        String[] pathElements = Strings.splitStringToArray(path, '.');, +        int currentPathSlot = 0;, +, +        XContentParser parser = null;, +        try {, +            parser = XContentHelper.createParser(response.getSourceAsBytesRef());, +            XContentParser.Token currentToken;, +            while ((currentToken = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                if (currentToken == XContentParser.Token.FIELD_NAME) {, +                    if (pathElements[currentPathSlot].equals(parser.currentName())) {, +                        parser.nextToken();, +                        if (++currentPathSlot == pathElements.length) {, +                            return ShapeBuilder.parse(parser);, +                        }, +                    } else {, +                        parser.nextToken();, +                        parser.skipChildren();, +                    }, +                }, +            }, +            throw new IllegalStateException("Shape with name [" + getRequest.id() + "] found but missing " + path + " field");, +        } finally {, +            if (parser != null) {, +                parser.close();, +            }, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/index/query/GeoShapeQueryParser.java, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.geo.ShapesAvailability;, +import org.elasticsearch.common.xcontent.XContentHelper;, +                            shape = fetch(context.getClient(), getRequest, shapePath);, +, +    /**, +     * Fetches the Shape with the given ID in the given type and index., +     *, +     * @param getRequest GetRequest containing index, type and id, +     * @param path      Name or path of the field in the Shape Document where the Shape itself is located, +     * @return Shape with the given ID, +     * @throws IOException Can be thrown while parsing the Shape Document and extracting the Shape, +     */, +    private ShapeBuilder fetch(Client client, GetRequest getRequest, String path) throws IOException {, +        if (ShapesAvailability.JTS_AVAILABLE == false) {, +            throw new IllegalStateException("JTS not available");, +        }, +        getRequest.preference("_local");, +        getRequest.operationThreaded(false);, +        GetResponse response = client.get(getRequest).actionGet();, +        if (!response.isExists()) {, +            throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] not found");, +        }, +, +        String[] pathElements = Strings.splitStringToArray(path, '.');, +        int currentPathSlot = 0;, +, +        XContentParser parser = null;, +        try {, +            parser = XContentHelper.createParser(response.getSourceAsBytesRef());, +            XContentParser.Token currentToken;, +            while ((currentToken = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                if (currentToken == XContentParser.Token.FIELD_NAME) {, +                    if (pathElements[currentPathSlot].equals(parser.currentName())) {, +                        parser.nextToken();, +                        if (++currentPathSlot == pathElements.length) {, +                            return ShapeBuilder.parse(parser);, +                        }, +                    } else {, +                        parser.nextToken();, +                        parser.skipChildren();, +                    }, +                }, +            }, +            throw new IllegalStateException("Shape with name [" + getRequest.id() + "] found but missing " + path + " field");]