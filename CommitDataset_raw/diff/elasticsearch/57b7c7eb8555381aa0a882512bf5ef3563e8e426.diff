[+++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.cleaner.CleanerService;, +        return Arrays.<Class<? extends LifecycleComponent>>asList(MarvelLicensee.class,, +                AgentService.class,, +                CleanerService.class);, +        module.registerSetting(CleanerService.HISTORY_SETTING);, +++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.cleaner.CleanerService;, +        return Arrays.<Class<? extends LifecycleComponent>>asList(MarvelLicensee.class,, +                AgentService.class,, +                CleanerService.class);, +        module.registerSetting(CleanerService.HISTORY_SETTING);, +++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/agent/exporter/MarvelTemplateUtils.java, +            throw new IllegalArgumentException("no marvel template version found");, +++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.cleaner.CleanerService;, +        return Arrays.<Class<? extends LifecycleComponent>>asList(MarvelLicensee.class,, +                AgentService.class,, +                CleanerService.class);, +        module.registerSetting(CleanerService.HISTORY_SETTING);, +++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/agent/exporter/MarvelTemplateUtils.java, +            throw new IllegalArgumentException("no marvel template version found");, +++ b/elasticsearch/x-pack/marvel/src/main/java/org/elasticsearch/marvel/agent/exporter/http/HttpExporter.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.marvel.cleaner.CleanerService;, +import org.joda.time.DateTime;, +import org.joda.time.DateTimeZone;, +import java.util.HashSet;, +import java.util.Set;, +public class HttpExporter extends Exporter implements CleanerService.Listener {, +    final CleanerService cleanerService;, +    public HttpExporter(Exporter.Config config, Environment env, RendererRegistry rendererRegistry, CleanerService cleanerService) {, +        this.cleanerService = cleanerService;, +        cleanerService.add(this);, +        cleanerService.remove(this);, +    @Override, +    public void onCleanUpIndices(TimeValue retention) {, +, +        // Retention duration can be overridden at exporter level, +        TimeValue exporterRetention = config.settings().getAsTime(CleanerService.HISTORY_DURATION, null);, +        if (exporterRetention != null) {, +            try {, +                cleanerService.validateRetention(exporterRetention);, +                retention = exporterRetention;, +            } catch (IllegalArgumentException e) {, +                logger.warn("http exporter [{}] - unable to use custom history duration [{}]: {}", name(), exporterRetention, e.getMessage());, +            }, +        }, +, +        // Reference date time will be compared to index.creation_date settings,, +        // that's why it must be in UTC, +        DateTime expiration = new DateTime(DateTimeZone.UTC).minus(retention.millis());, +        logger.debug("http exporter [{}] - cleaning indices [expiration={}, retention={}]", name(), expiration, retention);, +, +        Set<String> indices = new HashSet<>();, +        String host = hosts[0];, +        HttpURLConnection connection = null;, +        try {, +            String url = String.format("/%s*/_settings/%s", MarvelSettings.MARVEL_INDICES_PREFIX, IndexMetaData.SETTING_CREATION_DATE);, +            connection = openConnection(host, "GET", url, null);, +            if (connection == null) {, +                throw new ElasticsearchException("unable to clean indices: no available connection for host [" + host + "]");, +            }, +, +            long expirationTime = expiration.getMillis();, +            try (InputStream is = connection.getInputStream()) {, +                try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {, +                    Streams.copy(is, out);, +, +                    try (XContentParser parser = XContentHelper.createParser(new BytesArray(out.toByteArray()))) {, +                        XContentParser.Token token;, +                        String indexName = null;, +, +                        while ((token = parser.nextToken()) != null) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                if ("settings".equals(parser.currentName()) || ("index".equals(parser.currentName())) || ("creation_date".equals(parser.currentName()))) {, +                                    continue;, +                                }, +                                indexName = parser.currentName();, +                            } else if (token.isValue()) {, +                                if ("creation_date".equals(parser.currentName())) {, +                                    if (Regex.simpleMatch(MarvelSettings.MARVEL_INDICES_PREFIX + "*", indexName)) {, +                                        // Never delete the data indices, +                                        if (indexName.startsWith(MarvelSettings.MARVEL_DATA_INDEX_PREFIX)) {, +                                            continue;, +                                        }, +, +                                        // Never delete the current timestamped index, +                                        if (indexName.equals(indexNameResolver().resolve(System.currentTimeMillis()))) {, +                                            continue;, +                                        }, +, +                                        long creationDate = parser.longValue();, +                                        if (creationDate <= expirationTime) {, +                                            if (logger.isDebugEnabled()) {, +                                                logger.debug("http exporter [{}] - detected expired index [name={}, created={}, expired={}]", name(),, +                                                        indexName, new DateTime(creationDate, DateTimeZone.UTC), expiration);]