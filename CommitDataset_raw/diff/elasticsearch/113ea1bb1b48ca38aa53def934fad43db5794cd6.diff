[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                while (!recoveryThrottler.tryGatewayRecovery(shardId, "gateway")) {, +                    recoveryThrottler.recoveryGatewayDone(shardId, "gateway");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                while (!recoveryThrottler.tryGatewayRecovery(shardId, "gateway")) {, +                    recoveryThrottler.recoveryGatewayDone(shardId, "gateway");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +        if (!recoveryThrottler.tryPeerRecovery(request.shardId(), "peer recovery source")) {, +            recoveryThrottler.recoveryPeerDone(request.shardId(), "peer recovery source");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                while (!recoveryThrottler.tryGatewayRecovery(shardId, "gateway")) {, +                    recoveryThrottler.recoveryGatewayDone(shardId, "gateway");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +        if (!recoveryThrottler.tryPeerRecovery(request.shardId(), "peer recovery source")) {, +            recoveryThrottler.recoveryPeerDone(request.shardId(), "peer recovery source");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +        if (!recoveryThrottler.tryPeerRecovery(shard.shardId(), "peer recovery target")) {, +            recoveryThrottler.recoveryPeerDone(shard.shardId(), "peer recovery target");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                while (!recoveryThrottler.tryGatewayRecovery(shardId, "gateway")) {, +                    recoveryThrottler.recoveryGatewayDone(shardId, "gateway");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +        if (!recoveryThrottler.tryPeerRecovery(request.shardId(), "peer recovery source")) {, +            recoveryThrottler.recoveryPeerDone(request.shardId(), "peer recovery source");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +        if (!recoveryThrottler.tryPeerRecovery(shard.shardId(), "peer recovery target")) {, +            recoveryThrottler.recoveryPeerDone(shard.shardId(), "peer recovery target");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/recovery/throttler/RecoveryThrottler.java, + * Recovery Throttler allows to throttle recoveries (both gateway and peer)., + *, +    private volatile int onGoingGatewayRecoveries = 0;, +, +    private volatile int onGoingPeerRecoveries = 0;, +        int defaultConcurrentRecoveries = Runtime.getRuntime().availableProcessors() + 1;, +        if (defaultConcurrentRecoveries > 10) {, +            defaultConcurrentRecoveries = 10;, +        } else if (defaultConcurrentRecoveries < 3) {, +            defaultConcurrentRecoveries = 3;, +        concurrentRecoveries = componentSettings.getAsInt("concurrent_recoveries", defaultConcurrentRecoveries);, +        concurrentStreams = componentSettings.getAsInt("concurrent_streams", defaultConcurrentRecoveries * 2);, +    /**, +     * Try and check if gateway recovery is allowed. Only takes the on going gateway recoveries into account. Ignore, +     * on going peer recoveries so peer recovery will not block a much more important gateway recovery., +     */, +    public boolean tryGatewayRecovery(ShardId shardId, String reason) {, +            if ((onGoingGatewayRecoveries + 1) > concurrentRecoveries) {, +            onGoingGatewayRecoveries++;, +            logger.trace("Recovery (gateway) allowed for [{}], on_going (gateway [{}], peer [{}]), allowed [{}], reason [{}]", shardId, onGoingGatewayRecoveries, onGoingPeerRecoveries, concurrentRecoveries, reason);, +    /**, +     * Mark gateway recvoery as done., +     */, +    public void recoveryGatewayDone(ShardId shardId, String reason) {, +            --onGoingGatewayRecoveries;, +            logger.trace("Recovery (gateway) done for [{}], on_going (gateway [{}], peer [{}]), allowed [{}], reason [{}]", shardId, onGoingGatewayRecoveries, onGoingPeerRecoveries, concurrentRecoveries, reason);, +        }, +    }, +, +    /**, +     * Try and check if peer recovery is allowed. Takes into account both on going gateway recovery and peer recovery., +     */, +    public boolean tryPeerRecovery(ShardId shardId, String reason) {, +        synchronized (concurrentRecoveryMutex) {, +            if ((onGoingGatewayRecoveries + onGoingPeerRecoveries + 1) > concurrentRecoveries) {, +                return false;, +            }, +            onGoingPeerRecoveries++;, +            logger.trace("Recovery (peer) allowed for [{}], on_going (gateway [{}], peer [{}]), allowed [{}], reason [{}]", shardId, onGoingGatewayRecoveries, onGoingPeerRecoveries, concurrentRecoveries, reason);, +            return true;, +        }, +    }, +, +    /**, +     * Mark peer recovery as done., +     */, +    public void recoveryPeerDone(ShardId shardId, String reason) {, +        synchronized (concurrentRecoveryMutex) {, +            --onGoingPeerRecoveries;, +            logger.trace("Recovery (peer) done for [{}], on_going (gateway [{}], peer [{}]), allowed [{}], reason [{}]", shardId, onGoingGatewayRecoveries, onGoingPeerRecoveries, concurrentRecoveries, reason);, +        return onGoingGatewayRecoveries + onGoingPeerRecoveries;]