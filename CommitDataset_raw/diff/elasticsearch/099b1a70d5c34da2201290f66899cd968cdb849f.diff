[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +     *, +     * If subtractShardsMovingAway is set then the size of shards moving away is subtracted from the total size, +     * of all shards, +    public long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation, Map<String, Long> shardSizes, boolean subtractShardsMovingAway) {, +                totalSize += getShardSize(routing, shardSizes);, +            } else if (subtractShardsMovingAway && routing.currentNodeId().equals(node.nodeId())) {, +                totalSize -= getShardSize(routing, shardSizes);, +    private long getShardSize(ShardRouting routing, Map<String, Long> shardSizes) {, +        Long shardSize = shardSizes.get(shardIdentifierFromRouting(routing));, +        return shardSize == null ? 0 : shardSize;, +    }, +, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes, false);, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes, true);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +     *, +     * If subtractShardsMovingAway is set then the size of shards moving away is subtracted from the total size, +     * of all shards, +    public long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation, Map<String, Long> shardSizes, boolean subtractShardsMovingAway) {, +                totalSize += getShardSize(routing, shardSizes);, +            } else if (subtractShardsMovingAway && routing.currentNodeId().equals(node.nodeId())) {, +                totalSize -= getShardSize(routing, shardSizes);, +    private long getShardSize(ShardRouting routing, Map<String, Long> shardSizes) {, +        Long shardSize = shardSizes.get(shardIdentifierFromRouting(routing));, +        return shardSize == null ? 0 : shardSize;, +    }, +, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes, false);, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes, true);, +++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderTests.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;, +import org.elasticsearch.common.transport.LocalTransportAddress;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.nullValue;, +    @Test, +    public void testCanRemainWithShardRelocatingAway() {, +        Settings diskSettings = settingsBuilder(), +                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true), +                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true), +                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, "60%"), +                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, "70%").build();, +, +        // We have an index with 2 primary shards each taking 40 bytes. Each node has 100 bytes available, +        Map<String, DiskUsage> usages = new HashMap<>();, +        usages.put("node1", new DiskUsage("node1", "n1", 100, 20)); // 80% used, +        usages.put("node2", new DiskUsage("node2", "n2", 100, 100)); // 0% used, +, +        Map<String, Long> shardSizes = new HashMap<>();, +        shardSizes.put("[test][0][p]", 40L);, +        shardSizes.put("[test][1][p]", 40L);, +        final ClusterInfo clusterInfo = new ClusterInfo(ImmutableMap.copyOf(usages), ImmutableMap.copyOf(shardSizes));, +, +        DiskThresholdDecider diskThresholdDecider = new DiskThresholdDecider(diskSettings);, +        MetaData metaData = MetaData.builder(), +                .put(IndexMetaData.builder("test").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0)), +                .build();, +, +        RoutingTable routingTable = RoutingTable.builder(), +                .addAsNew(metaData.index("test")), +                .build();, +, +        DiscoveryNode discoveryNode1 = new DiscoveryNode("node1", new LocalTransportAddress("1"), Version.CURRENT);, +        DiscoveryNode discoveryNode2 = new DiscoveryNode("node2", new LocalTransportAddress("2"), Version.CURRENT);, +        DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().put(discoveryNode1).put(discoveryNode2).build();, +, +        ClusterState baseClusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT), +                .metaData(metaData), +                .routingTable(routingTable), +                .nodes(discoveryNodes), +                .build();, +, +        // Two shards consuming each 80% of disk space while 70% is allowed, so shard 0 isn't allowed here, +        MutableShardRouting firstRouting = new MutableShardRouting("test", 0, "node1", true, ShardRoutingState.STARTED, 1);, +        MutableShardRouting secondRouting = new MutableShardRouting("test", 1, "node1", true, ShardRoutingState.STARTED, 1);, +        RoutingNode firstRoutingNode = new RoutingNode("node1", discoveryNode1, Arrays.asList(firstRouting, secondRouting));, +        RoutingTable.Builder builder = RoutingTable.builder().add(, +                IndexRoutingTable.builder("test"), +                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId("test", 0), false), +                                        .addShard(firstRouting), +                                        .build(), +                        ), +                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId("test", 1), false), +                                        .addShard(secondRouting), +                                        .build(), +                        ), +        );, +        ClusterState clusterState = ClusterState.builder(baseClusterState).routingTable(builder).build();, +        RoutingAllocation routingAllocation = new RoutingAllocation(null, new RoutingNodes(clusterState), discoveryNodes, clusterInfo);, +        Decision decision = diskThresholdDecider.canRemain(firstRouting, firstRoutingNode, routingAllocation);, +        assertThat(decision.type(), equalTo(Decision.Type.NO));, +, +        // Two shards consuming each 80% of disk space while 70% is allowed, but one is relocating, so shard 0 can stay, +        firstRouting = new MutableShardRouting("test", 0, "node1", true, ShardRoutingState.STARTED, 1);, +        secondRouting = new MutableShardRouting("test", 1, "node1", "node2", true, ShardRoutingState.RELOCATING, 1);, +        firstRoutingNode = new RoutingNode("node1", discoveryNode1, Arrays.asList(firstRouting, secondRouting));, +        builder = RoutingTable.builder().add(, +                IndexRoutingTable.builder("test"), +                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId("test", 0), false)]