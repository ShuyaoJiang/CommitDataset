[+++ b/src/main/java/org/elasticsearch/watcher/trigger/schedule/IntervalSchedule.java, +            if (unit.millis(duration) != interval.unit.millis(interval.duration)) return false;, +++ b/src/main/java/org/elasticsearch/watcher/trigger/schedule/IntervalSchedule.java, +            if (unit.millis(duration) != interval.unit.millis(interval.duration)) return false;, +++ b/src/main/java/org/elasticsearch/watcher/trigger/schedule/engine/SchedulerScheduleTriggerEngine.java, +                final ActiveSchedule sched;, +                if (schedules[i].name.equals(schedule.name)) {, +                    sched = schedule;, +                    schedules[i].cancel();, +                } else {, +                    sched = schedules[i];, +                }, +++ b/src/main/java/org/elasticsearch/watcher/trigger/schedule/IntervalSchedule.java, +            if (unit.millis(duration) != interval.unit.millis(interval.duration)) return false;, +++ b/src/main/java/org/elasticsearch/watcher/trigger/schedule/engine/SchedulerScheduleTriggerEngine.java, +                final ActiveSchedule sched;, +                if (schedules[i].name.equals(schedule.name)) {, +                    sched = schedule;, +                    schedules[i].cancel();, +                } else {, +                    sched = schedules[i];, +                }, +++ b/src/test/java/org/elasticsearch/watcher/test/integration/BasicWatcherTests.java, +import org.apache.lucene.util.LuceneTestCase;, +import org.elasticsearch.common.unit.TimeValue;, +    @LuceneTestCase.Slow, +    public void testModifyWatchWithSameUnit() throws Exception {, +        if (timeWarped()) {, +            logger.info("Skipping testModifyWatches_ because timewarp is enabled");, +            return;, +        }, +, +        WatchSourceBuilder source = watchBuilder(), +                .trigger(schedule(interval("1s"))), +                .input(simpleInput("key", "value")), +                .throttlePeriod(TimeValue.timeValueSeconds(0)), +                .addAction("_id", loggingAction("hello {{ctx.watcher_id}}!"));, +        watcherClient().preparePutWatch("_name"), +                .setSource(source), +                .get();, +, +        Thread.sleep(5000);, +        assertWatchWithMinimumPerformedActionsCount("_name", 5, false);, +, +        source = watchBuilder(), +                .trigger(schedule(interval("100s"))), +                .throttlePeriod(TimeValue.timeValueSeconds(0)), +                .input(simpleInput("key", "value")), +                .addAction("_id", loggingAction("hello {{ctx.watcher_id}}!"));, +        watcherClient().preparePutWatch("_name"), +                .setSource(source), +                .get();, +, +        // Wait one second to be sure that the scheduler engine has executed any previous job instance of the watch, +        Thread.sleep(1000);, +        long before = historyRecordsCount("_name");, +        Thread.sleep(5000);, +        assertThat("Watch has been updated to 100s interval, so no new records should have been added.", historyRecordsCount("_name"), equalTo(before));, +    }, +, +    @Test]