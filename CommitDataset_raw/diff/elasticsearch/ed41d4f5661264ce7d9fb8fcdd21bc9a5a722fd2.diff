[+++ b/x-pack/qa/smoke-test-plugins-ssl/src/test/java/org/elasticsearch/smoketest/SmokeTestMonitoringWithSecurityIT.java, +import io.netty.util.ThreadDeathWatcher;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import org.junit.ClassRule;, +import org.junit.rules.ExternalResource;, +import java.util.concurrent.TimeUnit;, +, +    /**, +     * A JUnit class level rule that runs after the AfterClass method in {@link ESIntegTestCase},, +     * which stops the cluster. After the cluster is stopped, there are a few netty threads that, +     * can linger, so we wait for them to finish otherwise these lingering threads can intermittently, +     * trigger the thread leak detector, +     */, +    @ClassRule, +    public static final ExternalResource STOP_NETTY_RESOURCE = new ExternalResource() {, +        @Override, +        protected void after() {, +            try {, +                GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            } catch (IllegalStateException e) {, +                if (e.getMessage().equals("thread was not started") == false) {, +                    throw e;, +                }, +                // ignore since the thread was never started, +            }, +, +            try {, +                ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            }, +        }, +    };, +]