[+++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +        Setting.prefixKeySetting("logger.", (key) -> new Setting<>(key, Level.INFO.name(), Level::valueOf, Property.Dynamic,, +            Property.NodeScope));, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +        Setting.prefixKeySetting("logger.", (key) -> new Setting<>(key, Level.INFO.name(), Level::valueOf, Property.Dynamic,, +            Property.NodeScope));, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +import java.util.HashSet;, +import java.util.Set;, +import java.util.regex.Matcher;, +    public static <T> Setting<T> prefixKeySetting(String prefix, Function<String, Setting<T>> delegateFactory) {, +        return affixKeySetting(new AffixKey(prefix), delegateFactory);, +     * storage.${backend}.enable=[true|false] can easily be added with this setting. Yet, affix key settings don't support updaters, +    public static <T> Setting<T> affixKeySetting(String prefix, String suffix, Function<String, Setting<T>> delegateFactory) {, +        return affixKeySetting(new AffixKey(prefix, suffix), delegateFactory);, +    private static <T> Setting<T> affixKeySetting(AffixKey key, Function<String, Setting<T>> delegateFactory) {, +        Setting<T> delegate = delegateFactory.apply("_na_");, +        return new Setting<T>(key, delegate.defaultValue, delegate.parser, delegate.properties.toArray(new Property[0])) {, +                    return delegateFactory.apply(key);, +                final Set<String> concreteSettings = new HashSet<>();, +                for (String settingKey : defaultSettings.getAsMap().keySet()) {, +                    if (match(settingKey)) {, +                        concreteSettings.add(key.getConcreteString(settingKey));, +                for (String key : concreteSettings) {, +                    getConcreteSetting(key).diff(builder, source, defaultSettings);, +                }, +    };, +, +        private final Pattern pattern;, +        AffixKey(String prefix) {, +            this(prefix, null);, +        }, +, +        AffixKey(String prefix, String suffix) {, +, +            if (suffix == null) {, +                pattern = Pattern.compile("(" + Pattern.quote(prefix) + "((?:[-\\w]+[.])*[-\\w]+$))");, +            } else {, +                // the last part of this regexp is for lists since they are represented as x.${namespace}.y.1, x.${namespace}.y.2, +                pattern = Pattern.compile("(" + Pattern.quote(prefix) + "\\w+\\." + Pattern.quote(suffix) + ")(?:\\.\\d+)?");, +            }, +            return pattern.matcher(key).matches();, +, +        /**, +         * Returns a string representation of the concrete setting key, +         */, +        String getConcreteString(String key) {, +            Matcher matcher = pattern.matcher(key);, +            if (matcher.matches() == false) {, +                throw new IllegalStateException("can't get concrete string for key " + key + " key doesn't match");, +            return matcher.group(1);, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +        Setting.prefixKeySetting("logger.", (key) -> new Setting<>(key, Level.INFO.name(), Level::valueOf, Property.Dynamic,, +            Property.NodeScope));, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +import java.util.HashSet;, +import java.util.Set;, +import java.util.regex.Matcher;, +    public static <T> Setting<T> prefixKeySetting(String prefix, Function<String, Setting<T>> delegateFactory) {, +        return affixKeySetting(new AffixKey(prefix), delegateFactory);, +     * storage.${backend}.enable=[true|false] can easily be added with this setting. Yet, affix key settings don't support updaters, +    public static <T> Setting<T> affixKeySetting(String prefix, String suffix, Function<String, Setting<T>> delegateFactory) {, +        return affixKeySetting(new AffixKey(prefix, suffix), delegateFactory);, +    private static <T> Setting<T> affixKeySetting(AffixKey key, Function<String, Setting<T>> delegateFactory) {, +        Setting<T> delegate = delegateFactory.apply("_na_");, +        return new Setting<T>(key, delegate.defaultValue, delegate.parser, delegate.properties.toArray(new Property[0])) {, +                    return delegateFactory.apply(key);, +                final Set<String> concreteSettings = new HashSet<>();, +                for (String settingKey : defaultSettings.getAsMap().keySet()) {, +                    if (match(settingKey)) {, +                        concreteSettings.add(key.getConcreteString(settingKey));, +                for (String key : concreteSettings) {, +                    getConcreteSetting(key).diff(builder, source, defaultSettings);, +                }, +    };, +, +        private final Pattern pattern;, +        AffixKey(String prefix) {, +            this(prefix, null);, +        }, +, +        AffixKey(String prefix, String suffix) {, +, +            if (suffix == null) {, +                pattern = Pattern.compile("(" + Pattern.quote(prefix) + "((?:[-\\w]+[.])*[-\\w]+$))");, +            } else {, +                // the last part of this regexp is for lists since they are represented as x.${namespace}.y.1, x.${namespace}.y.2, +                pattern = Pattern.compile("(" + Pattern.quote(prefix) + "\\w+\\." + Pattern.quote(suffix) + ")(?:\\.\\d+)?");, +            }, +            return pattern.matcher(key).matches();, +, +        /**, +         * Returns a string representation of the concrete setting key, +         */, +        String getConcreteString(String key) {, +            Matcher matcher = pattern.matcher(key);, +            if (matcher.matches() == false) {, +                throw new IllegalStateException("can't get concrete string for key " + key + " key doesn't match");, +            return matcher.group(1);, +++ b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java]