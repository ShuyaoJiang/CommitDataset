[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/SSLExceptionHelper.java, +import io.netty.handler.codec.DecoderException;, +, +    public static boolean isReceivedCertificateUnknownException(Throwable e) {, +        return e instanceof DecoderException, +                && e.getCause() instanceof SSLException, +                && "Received fatal alert: certificate_unknown".equals(e.getCause().getMessage());, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/SSLExceptionHelper.java, +import io.netty.handler.codec.DecoderException;, +, +    public static boolean isReceivedCertificateUnknownException(Throwable e) {, +        return e instanceof DecoderException, +                && e.getCause() instanceof SSLException, +                && "Received fatal alert: certificate_unknown".equals(e.getCause().getMessage());, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/netty4/SecurityNetty4HttpServerTransport.java, +import static org.elasticsearch.xpack.security.transport.SSLExceptionHelper.isReceivedCertificateUnknownException;, +                logger.trace(new ParameterizedMessage("received plaintext http traffic on a https channel, closing connection {}",, +                                ctx.channel()), cause);, +                logger.trace(new ParameterizedMessage("connection {} closed during ssl handshake", ctx.channel()), cause);, +                logger.warn("connection {} closed during ssl handshake", ctx.channel());, +            }, +            ctx.channel().close();, +        } else if (isReceivedCertificateUnknownException(cause)) {, +            if (logger.isTraceEnabled()) {, +                logger.trace(new ParameterizedMessage("http client did not trust server's certificate, closing connection {}",, +                                ctx.channel()), cause);, +            } else {, +                logger.warn("http client did not trust this server's certificate, closing connection {}", ctx.channel());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/SSLExceptionHelper.java, +import io.netty.handler.codec.DecoderException;, +, +    public static boolean isReceivedCertificateUnknownException(Throwable e) {, +        return e instanceof DecoderException, +                && e.getCause() instanceof SSLException, +                && "Received fatal alert: certificate_unknown".equals(e.getCause().getMessage());, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/netty4/SecurityNetty4HttpServerTransport.java, +import static org.elasticsearch.xpack.security.transport.SSLExceptionHelper.isReceivedCertificateUnknownException;, +                logger.trace(new ParameterizedMessage("received plaintext http traffic on a https channel, closing connection {}",, +                                ctx.channel()), cause);, +                logger.trace(new ParameterizedMessage("connection {} closed during ssl handshake", ctx.channel()), cause);, +                logger.warn("connection {} closed during ssl handshake", ctx.channel());, +            }, +            ctx.channel().close();, +        } else if (isReceivedCertificateUnknownException(cause)) {, +            if (logger.isTraceEnabled()) {, +                logger.trace(new ParameterizedMessage("http client did not trust server's certificate, closing connection {}",, +                                ctx.channel()), cause);, +            } else {, +                logger.warn("http client did not trust this server's certificate, closing connection {}", ctx.channel());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/transport/netty4/SecurityNetty4Transport.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import static org.elasticsearch.xpack.security.transport.SSLExceptionHelper.isCloseDuringHandshakeException;, +import static org.elasticsearch.xpack.security.transport.SSLExceptionHelper.isNotSslRecordException;, +import static org.elasticsearch.xpack.security.transport.SSLExceptionHelper.isReceivedCertificateUnknownException;, +    @Override, +    protected void onException(Channel channel, Exception e) {, +        if (!lifecycle.started()) {, +            // just close and ignore - we are already stopped and just need to make sure we release all resources, +            disconnectFromNodeChannel(channel, e);, +        } else if (isNotSslRecordException(e)) {, +            if (logger.isTraceEnabled()) {, +                logger.trace(, +                        new ParameterizedMessage("received plaintext traffic on an encrypted channel, closing connection {}", channel), e);, +            } else {, +                logger.warn("received plaintext traffic on an encrypted channel, closing connection {}", channel);, +            }, +            disconnectFromNodeChannel(channel, e);, +        } else if (isCloseDuringHandshakeException(e)) {, +            if (logger.isTraceEnabled()) {, +                logger.trace(new ParameterizedMessage("connection {} closed during ssl handshake", channel), e);, +            } else {, +                logger.warn("connection {} closed during handshake", channel);, +            }, +            disconnectFromNodeChannel(channel, e);, +        } else if (isReceivedCertificateUnknownException(e)) {, +            if (logger.isTraceEnabled()) {, +                logger.trace(new ParameterizedMessage("client did not trust server's certificate, closing connection {}", channel), e);, +            } else {, +                logger.warn("client did not trust this server's certificate, closing connection {}", channel);, +            }, +            disconnectFromNodeChannel(channel, e);, +        } else {, +            super.onException(channel, e);, +        }, +, +    }, +]