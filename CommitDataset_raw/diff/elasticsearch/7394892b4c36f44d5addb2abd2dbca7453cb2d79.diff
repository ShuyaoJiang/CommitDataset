[+++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        public void messageReceived(RecoveryPrepareForTranslogOperationsRequest request, TransportChannel channel, Task task) {, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.PREPARE_TRANSLOG, request);, +                recoveryRef.target().prepareForTranslogOperations(request.isFileBasedRecovery(), request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        public void messageReceived(RecoveryPrepareForTranslogOperationsRequest request, TransportChannel channel, Task task) {, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.PREPARE_TRANSLOG, request);, +                recoveryRef.target().prepareForTranslogOperations(request.isFileBasedRecovery(), request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final StepListener<TimeValue> prepareEngineStep = new StepListener<>();, +            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,, +                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep);, +            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>();, +            prepareEngineStep.whenComplete(prepareEngineTime -> {, +                retentionLock.close();, +                    e -> {, +                        IOUtils.closeWhileHandlingException(phase2Snapshot);, +                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e));, +                    });, +, +            }, onFailure);, +, +                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis());, +    void prepareTargetForTranslog(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<TimeValue> listener) {, +        final ActionListener<Void> wrappedListener = ActionListener.wrap(, +            nullVal -> {, +                listener.onResponse(tookTime);, +            },, +            e -> listener.onFailure(new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)));, +        // Send a request preparing the new shard's translog to receive operations. This ensures the shard engine is started and disables, +        // garbage collection (not the JVM's GC!) of tombstone deletes., +        logger.trace("recovery [phase1]: prepare remote engine for translog");, +        cancellableThreads.execute(() ->, +            recoveryTarget.prepareForTranslogOperations(fileBasedRecovery, totalTranslogOps, wrappedListener));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        public void messageReceived(RecoveryPrepareForTranslogOperationsRequest request, TransportChannel channel, Task task) {, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.PREPARE_TRANSLOG, request);, +                recoveryRef.target().prepareForTranslogOperations(request.isFileBasedRecovery(), request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final StepListener<TimeValue> prepareEngineStep = new StepListener<>();, +            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,, +                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep);, +            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>();, +            prepareEngineStep.whenComplete(prepareEngineTime -> {, +                retentionLock.close();, +                    e -> {, +                        IOUtils.closeWhileHandlingException(phase2Snapshot);, +                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e));, +                    });, +, +            }, onFailure);, +, +                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis());, +    void prepareTargetForTranslog(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<TimeValue> listener) {, +        final ActionListener<Void> wrappedListener = ActionListener.wrap(, +            nullVal -> {, +                listener.onResponse(tookTime);, +            },, +            e -> listener.onFailure(new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)));, +        // Send a request preparing the new shard's translog to receive operations. This ensures the shard engine is started and disables, +        // garbage collection (not the JVM's GC!) of tombstone deletes., +        logger.trace("recovery [phase1]: prepare remote engine for translog");, +        cancellableThreads.execute(() ->, +            recoveryTarget.prepareForTranslogOperations(fileBasedRecovery, totalTranslogOps, wrappedListener));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {, +        ActionListener.completeWith(listener, () -> {, +            return null;, +        });, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        public void messageReceived(RecoveryPrepareForTranslogOperationsRequest request, TransportChannel channel, Task task) {, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.PREPARE_TRANSLOG, request);, +                recoveryRef.target().prepareForTranslogOperations(request.isFileBasedRecovery(), request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final StepListener<TimeValue> prepareEngineStep = new StepListener<>();, +            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,, +                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep);, +            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>();, +            prepareEngineStep.whenComplete(prepareEngineTime -> {, +                retentionLock.close();, +                    e -> {, +                        IOUtils.closeWhileHandlingException(phase2Snapshot);, +                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e));, +                    });, +, +            }, onFailure);, +, +                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis());]