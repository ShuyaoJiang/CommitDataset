[+++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +                threadPool.generic().execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.warn("Recovery failed", t);, +                        // we reset `recovered` in the listener don't reset it here otherwise there might be a race, +                        // that resets it to false while a new recover is already running?, +                        recoveryListener.onFailure("state recovery failed: " + t.getMessage());, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        gateway.performStateRecovery(recoveryListener);, +                    }, +                });, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +                threadPool.generic().execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.warn("Recovery failed", t);, +                        // we reset `recovered` in the listener don't reset it here otherwise there might be a race, +                        // that resets it to false while a new recover is already running?, +                        recoveryListener.onFailure("state recovery failed: " + t.getMessage());, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        gateway.performStateRecovery(recoveryListener);, +                    }, +                });, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +            // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +            /*if (parserContext.indexVersionCreated().onOrAfter(Version.V_5_0_0)) {, +            }*/, +        // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +        /*if (Version.indexCreated(indexSettings).onOrAfter(Version.V_5_0_0)) {, +        }*/, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +                threadPool.generic().execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.warn("Recovery failed", t);, +                        // we reset `recovered` in the listener don't reset it here otherwise there might be a race, +                        // that resets it to false while a new recover is already running?, +                        recoveryListener.onFailure("state recovery failed: " + t.getMessage());, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        gateway.performStateRecovery(recoveryListener);, +                    }, +                });, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +            // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +            /*if (parserContext.indexVersionCreated().onOrAfter(Version.V_5_0_0)) {, +            }*/, +        // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +        /*if (Version.indexCreated(indexSettings).onOrAfter(Version.V_5_0_0)) {, +        }*/, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +                final CountDownLatch latch = new CountDownLatch(1);, +                    public void onNewClusterState(ClusterState state) { latch.countDown(); }, +                        logger.warn("timed out while waiting for initial discovery state - timeout: {}",, +                            DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.get(settings));, +                        latch.countDown();, +                }, MasterNodeChangePredicate.INSTANCE, DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.get(settings));, +                    latch.await();, +        }, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +                threadPool.generic().execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.warn("Recovery failed", t);, +                        // we reset `recovered` in the listener don't reset it here otherwise there might be a race, +                        // that resets it to false while a new recover is already running?, +                        recoveryListener.onFailure("state recovery failed: " + t.getMessage());, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        gateway.performStateRecovery(recoveryListener);, +                    }, +                });, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +            // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +            /*if (parserContext.indexVersionCreated().onOrAfter(Version.V_5_0_0)) {, +            }*/, +        // TODO: temporarily disabled to give Kibana time to upgrade to text/keyword mappings, +        /*if (Version.indexCreated(indexSettings).onOrAfter(Version.V_5_0_0)) {, +        }*/, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +                final CountDownLatch latch = new CountDownLatch(1);, +                    public void onNewClusterState(ClusterState state) { latch.countDown(); }, +                        logger.warn("timed out while waiting for initial discovery state - timeout: {}",, +                            DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.get(settings));, +                        latch.countDown();]