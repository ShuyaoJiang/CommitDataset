[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.cluster.routing.allocation.FailedRerouteAllocation;, +import org.elasticsearch.cluster.routing.allocation.NodeAllocation;, +import org.elasticsearch.cluster.routing.allocation.NodeAllocations;, +import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;, +import org.elasticsearch.cluster.routing.allocation.StartedRerouteAllocation;, +            Set<DiscoveryNode> nodesWithHighestVersion = Sets.newHashSet();, +                        nodesWithHighestVersion.add(node);, +                            nodesWithHighestVersion.clear();, +                            nodesWithHighestVersion.add(node);, +                        } else if (version == highestVersion) {, +                            nodesWithHighestVersion.add(node);, +            Set<DiscoveryNode> throttledNodes = Sets.newHashSet();, +            Set<DiscoveryNode> noNodes = Sets.newHashSet();, +            for (DiscoveryNode discoNode : nodesWithHighestVersion) {, +                RoutingNode node = routingNodes.node(discoNode.id());, +                Decision decision = nodeAllocations.canAllocate(shard, node, allocation);, +                if (decision == NodeAllocation.Decision.THROTTLE) {, +                    throttledNodes.add(discoNode);, +                } else if (decision == Decision.NO) {, +                    noNodes.add(discoNode);, +                        logger.debug("[{}][{}]: allocating [{}] to [{}] on primary allocation", shard.index(), shard.id(), shard, discoNode);, +, +                    // found a node, so no throttling, no "no", and break out of the loop, +                    throttledNodes.clear();, +                    noNodes.clear();, +                    break;, +                }, +            }, +            if (throttledNodes.isEmpty()) {, +                // if we have a node that we "can't" allocate to, force allocation, since this is our master data!, +                if (!noNodes.isEmpty()) {, +                    DiscoveryNode discoNode = noNodes.iterator().next();, +                    RoutingNode node = routingNodes.node(discoNode.id());, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("[{}][{}]: forcing allocating [{}] to [{}] on primary allocation", shard.index(), shard.id(), shard, discoNode);, +                    }, +                    // we found a match, +                    changed = true;, +                    node.add(shard);, +                    unassignedIterator.remove();, +                }, +            } else {, +                if (logger.isDebugEnabled()) {, +                    logger.debug("[{}][{}]: throttling allocation [{}] to [{}] on primary allocation", shard.index(), shard.id(), shard, throttledNodes);, +                }, +                // we are throttling this, but we have enough to allocate to this node, ignore it for now, +                unassignedIterator.remove();, +                routingNodes.ignoredUnassigned().add(shard);]