[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.index.query.QueryBuilder;, +import java.util.Objects;, +    public static final ParseField FILTERS_FIELD = new ParseField("filters");, +    public static final ParseField OTHER_BUCKET_FIELD = new ParseField("other_bucket");, +    public static final ParseField OTHER_BUCKET_KEY_FIELD = new ParseField("other_bucket_key");, +    public static class KeyedFilter implements Writeable<KeyedFilter>, ToXContent {, +        static final KeyedFilter PROTOTYPE = new KeyedFilter(null, null);, +        private final String key;, +        private final QueryBuilder<?> filter;, +, +        public KeyedFilter(String key, QueryBuilder<?> filter) {, +, +        public String key() {, +            return key;, +        }, +, +        public QueryBuilder<?> filter() {, +            return filter;, +        }, +, +        @Override, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.field(key, filter);, +            return builder;, +        }, +, +        @Override, +        public KeyedFilter readFrom(StreamInput in) throws IOException {, +            String key = in.readString();, +            QueryBuilder<?> filter = in.readQuery();, +            return new KeyedFilter(key, filter);, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeString(key);, +            out.writeQuery(filter);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(key, filter);, +        }, +, +        @Override, +        public boolean equals(Object obj) {, +            if (obj == null) {, +                return false;, +            }, +            if (getClass() != obj.getClass()) {, +                return false;, +            }, +            KeyedFilter other = (KeyedFilter) obj;, +            return Objects.equals(key, other.key), +                    && Objects.equals(filter, other.filter);, +        }, +            Query filter = keyedFilter.filter.toFilter(context.searchContext().indexShard().getQueryShardContext());, +            this.filters[i] = aggregationContext.searchContext().searcher().createNormalizedWeight(filter, false);, +        private final boolean keyed;, +        private boolean otherBucket = false;, +        private String otherBucketKey = "_other_";, +        public Factory(String name, List<KeyedFilter> filters) {, +            this.keyed = true;, +        }, +, +        public Factory(String name, QueryBuilder<?>... filters) {, +            super(name, InternalFilters.TYPE);, +            List<KeyedFilter> keyedFilters = new ArrayList<>(filters.length);, +            for (int i = 0; i < filters.length; i++) {, +                keyedFilters.add(new KeyedFilter(String.valueOf(i), filters[i]));, +            }, +            this.filters = keyedFilters;, +            this.keyed = false;, +        }, +, +        /**, +         * Set whether to include a bucket for documents not matching any filter, +         */, +        public void otherBucket(boolean otherBucket) {, +            this.otherBucket = otherBucket;, +        }, +, +        /**, +         * Get whether to include a bucket for documents not matching any filter, +         */, +        public boolean otherBucket() {, +            return otherBucket;, +        }, +, +        /**, +         * Set the key to use for the bucket for documents not matching any, +         * filter., +         */]