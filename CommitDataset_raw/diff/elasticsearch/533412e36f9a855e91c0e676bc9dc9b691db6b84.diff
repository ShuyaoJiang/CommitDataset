[+++ b/core/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java, +import org.elasticsearch.common.regex.Regex;, +import java.util.HashSet;, +import java.util.TreeMap;, +        controller.registerHandler(GET, "/_cat/thread_pool/{thread_pool_patterns}", this);, +        sb.append("/_cat/thread_pool/{thread_pools}");, +        final Table table = new Table();, +        table.addCell("node_name", "default:true;alias:nn;desc:node name");, +        table.addCell("node_id", "default:false;alias:id;desc:persistent node id");, +        table.addCell("ephemeral_node_id", "default:false;alias:eid;desc:ephemeral node id");, +        table.addCell("host", "default:false;alias:h;desc:host name");, +        table.addCell("ip", "default:false;alias:i;desc:ip address");, +        table.addCell("name", "default:true;alias:n;desc:thread pool name");, +        table.addCell("type", "alias:t;default:false;desc:thread pool type");, +        table.addCell("active", "alias:a;default:true;text-align:right;desc:number of active threads");, +        table.addCell("size", "alias:s;default:false;text-align:right;desc:number of threads");, +        table.addCell("queue", "alias:q;default:true;text-align:right;desc:number of tasks currently in queue");, +        table.addCell("queue_size", "alias:qs;default:false;text-align:right;desc:maximum number of tasks permitted in queue");, +        table.addCell("rejected", "alias:r;default:true;text-align:right;desc:number of rejected tasks");, +        table.addCell("largest", "alias:l;default:false;text-align:right;desc:highest number of seen active threads");, +        table.addCell("completed", "alias:c;default:false;text-align:right;desc:number of completed tasks");, +        table.addCell("min", "alias:mi;default:false;text-align:right;desc:minimum number of threads");, +        table.addCell("max", "alias:ma;default:false;text-align:right;desc:maximum number of threads");, +        table.addCell("keep_alive", "alias:ka;default:false;text-align:right;desc:thread keep alive time");, +        final String[] threadPools = req.paramAsStringArray("thread_pool_patterns", new String[] { "*" });, +        final DiscoveryNodes nodes = state.getState().nodes();, +        final Table table = getTableWithHeader(req);, +        // collect all thread pool names that we see across the nodes, +        final Set<String> candidates = new HashSet<>();, +        for (final NodeStats nodeStats : nodesStats.getNodes()) {, +            for (final ThreadPoolStats.Stats threadPoolStats : nodeStats.getThreadPool()) {, +                candidates.add(threadPoolStats.getName());, +        }, +, +        // collect all thread pool names that match the specified thread pool patterns, +        final Set<String> included = new HashSet<>();, +        for (final String candidate : candidates) {, +            if (Regex.simpleMatch(threadPools, candidate)) {, +                included.add(candidate);, +            }, +        }, +, +        for (final DiscoveryNode node : nodes) {, +            final NodeInfo info = nodesInfo.getNodesMap().get(node.getId());, +            final NodeStats stats = nodesStats.getNodesMap().get(node.getId());, +                // we use a sorted map to ensure that thread pools are sorted by name, +                poolThreadStats = new TreeMap<>();, +                poolThreadInfo = new HashMap<>();, +            for (Map.Entry<String, ThreadPoolStats.Stats> entry : poolThreadStats.entrySet()) {, +, +                if (!included.contains(entry.getKey())) continue;, +, +                table.startRow();, +, +                table.addCell(node.getName());, +                table.addCell(node.getId());, +                table.addCell(node.getEphemeralId());, +                table.addCell(info == null ? null : info.getProcess().getId());, +                table.addCell(node.getHostName());, +                table.addCell(node.getHostAddress());, +                if (node.getAddress() instanceof InetSocketTransportAddress) {, +                    table.addCell(((InetSocketTransportAddress) node.getAddress()).address().getPort());, +                } else {, +                    table.addCell("-");, +                }, +                final ThreadPoolStats.Stats poolStats = entry.getValue();, +                final ThreadPool.Info poolInfo = poolThreadInfo.get(entry.getKey());, +                table.addCell(entry.getKey());, +        }, +++ b/core/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java, +import org.elasticsearch.common.regex.Regex;, +import java.util.HashSet;, +import java.util.TreeMap;, +        controller.registerHandler(GET, "/_cat/thread_pool/{thread_pool_patterns}", this);, +        sb.append("/_cat/thread_pool/{thread_pools}");, +        final Table table = new Table();, +        table.addCell("node_name", "default:true;alias:nn;desc:node name");, +        table.addCell("node_id", "default:false;alias:id;desc:persistent node id");, +        table.addCell("ephemeral_node_id", "default:false;alias:eid;desc:ephemeral node id");, +        table.addCell("host", "default:false;alias:h;desc:host name");, +        table.addCell("ip", "default:false;alias:i;desc:ip address");, +        table.addCell("name", "default:true;alias:n;desc:thread pool name");, +        table.addCell("type", "alias:t;default:false;desc:thread pool type");, +        table.addCell("active", "alias:a;default:true;text-align:right;desc:number of active threads");, +        table.addCell("size", "alias:s;default:false;text-align:right;desc:number of threads");, +        table.addCell("queue", "alias:q;default:true;text-align:right;desc:number of tasks currently in queue");, +        table.addCell("queue_size", "alias:qs;default:false;text-align:right;desc:maximum number of tasks permitted in queue");, +        table.addCell("rejected", "alias:r;default:true;text-align:right;desc:number of rejected tasks");, +        table.addCell("largest", "alias:l;default:false;text-align:right;desc:highest number of seen active threads");, +        table.addCell("completed", "alias:c;default:false;text-align:right;desc:number of completed tasks");, +        table.addCell("min", "alias:mi;default:false;text-align:right;desc:minimum number of threads");, +        table.addCell("max", "alias:ma;default:false;text-align:right;desc:maximum number of threads");, +        table.addCell("keep_alive", "alias:ka;default:false;text-align:right;desc:thread keep alive time");, +        final String[] threadPools = req.paramAsStringArray("thread_pool_patterns", new String[] { "*" });, +        final DiscoveryNodes nodes = state.getState().nodes();, +        final Table table = getTableWithHeader(req);, +        // collect all thread pool names that we see across the nodes, +        final Set<String> candidates = new HashSet<>();, +        for (final NodeStats nodeStats : nodesStats.getNodes()) {, +            for (final ThreadPoolStats.Stats threadPoolStats : nodeStats.getThreadPool()) {]