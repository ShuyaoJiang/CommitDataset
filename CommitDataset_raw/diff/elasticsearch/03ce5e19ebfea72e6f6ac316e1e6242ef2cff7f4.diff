[+++ b/core/src/main/java/org/elasticsearch/index/query/CommonTermsQueryBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +    public static final ParseField QUERY_NAME_FIELD = new ParseField(NAME);, +    public static final CommonTermsQueryBuilder PROTOTYPE = new CommonTermsQueryBuilder("field", "text");, +    private static final ParseField CUTOFF_FREQUENCY_FIELD = new ParseField("cutoff_frequency");, +    private static final ParseField MINIMUM_SHOULD_MATCH_FIELD = new ParseField("minimum_should_match");, +    private static final ParseField LOW_FREQ_OPERATOR_FIELD = new ParseField("low_freq_operator");, +    private static final ParseField HIGH_FREQ_OPERATOR_FIELD = new ParseField("high_freq_operator");, +    private static final ParseField DISABLE_COORD_FIELD = new ParseField("disable_coord");, +    private static final ParseField ANALYZER_FIELD = new ParseField("analyzer");, +    private static final ParseField QUERY_FIELD = new ParseField("query");, +    private static final ParseField HIGH_FREQ_FIELD = new ParseField("high_freq");, +    private static final ParseField LOW_FREQ_FIELD = new ParseField("low_freq");, +, +        builder.field(QUERY_FIELD.getPreferredName(), text);, +        builder.field(DISABLE_COORD_FIELD.getPreferredName(), disableCoord);, +        builder.field(HIGH_FREQ_OPERATOR_FIELD.getPreferredName(), highFreqOperator.toString());, +        builder.field(LOW_FREQ_OPERATOR_FIELD.getPreferredName(), lowFreqOperator.toString());, +            builder.field(ANALYZER_FIELD.getPreferredName(), analyzer);, +        builder.field(CUTOFF_FREQUENCY_FIELD.getPreferredName(), cutoffFrequency);, +            builder.startObject(MINIMUM_SHOULD_MATCH_FIELD.getPreferredName());, +                builder.field(LOW_FREQ_FIELD.getPreferredName(), lowFreqMinimumShouldMatch);, +                builder.field(HIGH_FREQ_FIELD.getPreferredName(), highFreqMinimumShouldMatch);, +    public static CommonTermsQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException {, +        XContentParser parser = parseContext.parser();, +        XContentParser.Token token = parser.nextToken();, +        if (token != XContentParser.Token.FIELD_NAME) {, +            throw new ParsingException(parser.getTokenLocation(), "[" + CommonTermsQueryBuilder.NAME + "] query malformed, no field");, +        }, +        String fieldName = parser.currentName();, +        Object text = null;, +        float boost = AbstractQueryBuilder.DEFAULT_BOOST;, +        String analyzer = null;, +        String lowFreqMinimumShouldMatch = null;, +        String highFreqMinimumShouldMatch = null;, +        boolean disableCoord = CommonTermsQueryBuilder.DEFAULT_DISABLE_COORD;, +        Operator highFreqOperator = CommonTermsQueryBuilder.DEFAULT_HIGH_FREQ_OCCUR;, +        Operator lowFreqOperator = CommonTermsQueryBuilder.DEFAULT_LOW_FREQ_OCCUR;, +        float cutoffFrequency = CommonTermsQueryBuilder.DEFAULT_CUTOFF_FREQ;, +        String queryName = null;, +        token = parser.nextToken();, +        if (token == XContentParser.Token.START_OBJECT) {, +            String currentFieldName = null;, +            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                if (token == XContentParser.Token.FIELD_NAME) {, +                    currentFieldName = parser.currentName();, +                } else if (token == XContentParser.Token.START_OBJECT) {, +                    if (parseContext.parseFieldMatcher().match(currentFieldName, MINIMUM_SHOULD_MATCH_FIELD)) {, +                        String innerFieldName = null;, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                innerFieldName = parser.currentName();, +                            } else if (token.isValue()) {, +                                if (parseContext.parseFieldMatcher().match(innerFieldName, LOW_FREQ_FIELD)) {, +                                    lowFreqMinimumShouldMatch = parser.text();, +                                } else if (parseContext.parseFieldMatcher().match(innerFieldName, HIGH_FREQ_FIELD)) {, +                                    highFreqMinimumShouldMatch = parser.text();, +                                } else {, +                                    throw new ParsingException(parser.getTokenLocation(), "[" + CommonTermsQueryBuilder.NAME +, +                                            "] query does not support [" + innerFieldName, +                                            + "] for [" + currentFieldName + "]");, +                                }, +                            } else {, +                                throw new ParsingException(parser.getTokenLocation(), "[" + CommonTermsQueryBuilder.NAME +, +                                        "] unexpected token type [" + token, +                                        + "] after [" + innerFieldName + "]");, +                            }, +                        }, +                    } else {, +                        throw new ParsingException(parser.getTokenLocation(), "[" + CommonTermsQueryBuilder.NAME +, +                                "] query does not support [" + currentFieldName + "]");, +                    }, +                } else if (token.isValue()) {, +                    if (parseContext.parseFieldMatcher().match(currentFieldName, QUERY_FIELD)) {, +                        text = parser.objectText();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, ANALYZER_FIELD)) {, +                        analyzer = parser.text();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, DISABLE_COORD_FIELD)) {, +                        disableCoord = parser.booleanValue();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, AbstractQueryBuilder.BOOST_FIELD)) {, +                        boost = parser.floatValue();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, HIGH_FREQ_OPERATOR_FIELD)) {, +                        highFreqOperator = Operator.fromString(parser.text());, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, LOW_FREQ_OPERATOR_FIELD)) {, +                        lowFreqOperator = Operator.fromString(parser.text());, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, MINIMUM_SHOULD_MATCH_FIELD)) {, +                        lowFreqMinimumShouldMatch = parser.text();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, CUTOFF_FREQUENCY_FIELD)) {, +                        cutoffFrequency = parser.floatValue();, +                    } else if (parseContext.parseFieldMatcher().match(currentFieldName, AbstractQueryBuilder.NAME_FIELD)) {, +                        queryName = parser.text();, +                    } else {, +                        throw new ParsingException(parser.getTokenLocation(), "[" + CommonTermsQueryBuilder.NAME +, +                                "] query does not support [" + currentFieldName + "]");, +                    }, +                }, +            }, +            parser.nextToken();]