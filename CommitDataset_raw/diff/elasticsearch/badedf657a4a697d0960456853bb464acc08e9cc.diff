[+++ b/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.elasticsearch.common.util.UnsafeUtils;, +, +            if (a.hasArray() && b.hasArray()) {, +                // court-circuit to compare several bytes at once, +                return UnsafeUtils.equals(a.array(), a.arrayOffset(), b.array(), b.arrayOffset(), a.length());, +            } else {, +                return slowBytesEquals(a, b);, +, +        // pkg-private for testing, +        static boolean slowBytesEquals(BytesReference a, BytesReference b) {, +            assert a.length() == b.length();, +            for (int i = 0, end = a.length(); i < end; ++i) {, +                if (a.get(i) != b.get(i)) {, +, +            if (a.hasArray()) {, +                return hashCode(a.array(), a.arrayOffset(), a.length());, +            } else {, +                return slowHashCode(a);, +        }, +, +        // pkg-private for testing, +        static int hashCode(byte[] array, int offset, int length) {, +            int result = 1;, +            for (int i = offset, end = offset + length; i < end; ++i) {, +                result = 31 * result + array[i];, +            }, +            return result;, +        }, +, +        // pkg-private for testing, +        static int slowHashCode(BytesReference a) {, +            int result = 1;, +            for (int i = 0, end = a.length(); i < end; ++i) {, +                result = 31 * result + a.get(i);, +++ b/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.elasticsearch.common.util.UnsafeUtils;, +, +            if (a.hasArray() && b.hasArray()) {, +                // court-circuit to compare several bytes at once, +                return UnsafeUtils.equals(a.array(), a.arrayOffset(), b.array(), b.arrayOffset(), a.length());, +            } else {, +                return slowBytesEquals(a, b);, +, +        // pkg-private for testing, +        static boolean slowBytesEquals(BytesReference a, BytesReference b) {, +            assert a.length() == b.length();, +            for (int i = 0, end = a.length(); i < end; ++i) {, +                if (a.get(i) != b.get(i)) {, +, +            if (a.hasArray()) {, +                return hashCode(a.array(), a.arrayOffset(), a.length());, +            } else {, +                return slowHashCode(a);, +        }, +, +        // pkg-private for testing, +        static int hashCode(byte[] array, int offset, int length) {, +            int result = 1;, +            for (int i = offset, end = offset + length; i < end; ++i) {, +                result = 31 * result + array[i];, +            }, +            return result;, +        }, +, +        // pkg-private for testing, +        static int slowHashCode(BytesReference a) {, +            int result = 1;, +            for (int i = 0, end = a.length(); i < end; ++i) {, +                result = 31 * result + a.get(i);, +++ b/src/main/java/org/elasticsearch/common/util/UnsafeUtils.java, +        if (b1.length != b2.length) {, +        return equals(b1.bytes, b1.offset, b2.bytes, b2.offset, b1.length);, +    }, +, +    /**, +     * Compare <code>b1[o1:o1+len)</code>against <code>b1[o2:o2+len)</code>., +     */, +    public static boolean equals(byte[] b1, int o1, byte[] b2, int o2, int len) {, +            if (readLong(b1, o1) != readLong(b2, o2)) {, +            if (readInt(b1, o1) != readInt(b2, o2)) {, +            if (readShort(b1, o1) != readShort(b2, o2)) {, +            if (readByte(b1, o1) != readByte(b2, o2)) {, +++ b/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.elasticsearch.common.util.UnsafeUtils;, +, +            if (a.hasArray() && b.hasArray()) {, +                // court-circuit to compare several bytes at once, +                return UnsafeUtils.equals(a.array(), a.arrayOffset(), b.array(), b.arrayOffset(), a.length());, +            } else {, +                return slowBytesEquals(a, b);, +, +        // pkg-private for testing, +        static boolean slowBytesEquals(BytesReference a, BytesReference b) {, +            assert a.length() == b.length();, +            for (int i = 0, end = a.length(); i < end; ++i) {, +                if (a.get(i) != b.get(i)) {, +, +            if (a.hasArray()) {, +                return hashCode(a.array(), a.arrayOffset(), a.length());]