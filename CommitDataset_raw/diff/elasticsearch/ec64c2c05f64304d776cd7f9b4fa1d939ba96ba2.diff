[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +import org.elasticsearch.common.collect.Tuple;, +            Tuple<String, TokenizerFactory> tokenizerFactory = parseTokenizerFactory(request, indexAnalyzers,, +                        analysisRegistry, environment);, +            analyzer = new CustomAnalyzer(tokenizerFactory.v1(), tokenizerFactory.v2(), charFilterFactories, tokenFilterFactories);, +            detailResponse = new DetailAnalyzeResponse(charFilteredLists, new DetailAnalyzeResponse.AnalyzeTokenList(, +                    customAnalyzer.getTokenizerName(), tokenizerTokenListCreator.getArrayTokens()), tokenFilterLists);, +    private static Tuple<String, TokenizerFactory> parseTokenizerFactory(AnalyzeRequest request, IndexAnalyzers indexAnalzyers,, +        String name;, +            name = "_anonymous_tokenizer";, +                name = tokenizer.name;, +                name = tokenizer.name;, +        return new Tuple<>(name, tokenizerFactory);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +import org.elasticsearch.common.collect.Tuple;, +            Tuple<String, TokenizerFactory> tokenizerFactory = parseTokenizerFactory(request, indexAnalyzers,, +                        analysisRegistry, environment);, +            analyzer = new CustomAnalyzer(tokenizerFactory.v1(), tokenizerFactory.v2(), charFilterFactories, tokenFilterFactories);, +            detailResponse = new DetailAnalyzeResponse(charFilteredLists, new DetailAnalyzeResponse.AnalyzeTokenList(, +                    customAnalyzer.getTokenizerName(), tokenizerTokenListCreator.getArrayTokens()), tokenFilterLists);, +    private static Tuple<String, TokenizerFactory> parseTokenizerFactory(AnalyzeRequest request, IndexAnalyzers indexAnalzyers,, +        String name;, +            name = "_anonymous_tokenizer";, +                name = tokenizer.name;, +                name = tokenizer.name;, +        return new Tuple<>(name, tokenizerFactory);, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteRequest.java, +import org.elasticsearch.index.shard.ShardId;, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override, +    public long primaryTerm() {, +        throw new UnsupportedOperationException("primary term should never be set on DeleteRequest");, +    }, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override, +    public void primaryTerm(long term) {, +        throw new UnsupportedOperationException("primary term should never be set on DeleteRequest");, +    }, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override, +    public DeleteRequest setShardId(ShardId shardId) {, +        throw new UnsupportedOperationException("shard id should never be set on DeleteRequest");, +    }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +import org.elasticsearch.common.collect.Tuple;, +            Tuple<String, TokenizerFactory> tokenizerFactory = parseTokenizerFactory(request, indexAnalyzers,, +                        analysisRegistry, environment);, +            analyzer = new CustomAnalyzer(tokenizerFactory.v1(), tokenizerFactory.v2(), charFilterFactories, tokenFilterFactories);, +            detailResponse = new DetailAnalyzeResponse(charFilteredLists, new DetailAnalyzeResponse.AnalyzeTokenList(, +                    customAnalyzer.getTokenizerName(), tokenizerTokenListCreator.getArrayTokens()), tokenFilterLists);, +    private static Tuple<String, TokenizerFactory> parseTokenizerFactory(AnalyzeRequest request, IndexAnalyzers indexAnalzyers,, +        String name;, +            name = "_anonymous_tokenizer";, +                name = tokenizer.name;, +                name = tokenizer.name;, +        return new Tuple<>(name, tokenizerFactory);, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteRequest.java, +import org.elasticsearch.index.shard.ShardId;, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override, +    public long primaryTerm() {, +        throw new UnsupportedOperationException("primary term should never be set on DeleteRequest");, +    }, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override, +    public void primaryTerm(long term) {, +        throw new UnsupportedOperationException("primary term should never be set on DeleteRequest");, +    }, +, +    /**, +     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't, +     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or, +     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set., +     */, +    @Override]