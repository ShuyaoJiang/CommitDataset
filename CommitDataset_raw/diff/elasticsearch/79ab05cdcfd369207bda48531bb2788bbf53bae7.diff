[+++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java, +    private long hashVersion = version-1;, +    private int hashCode = 0;, +, +    @Override, +    public int hashCode() {, +        hashCode = (hashVersion != version ? super.hashCode() : hashCode);, +        hashVersion = version;, +        return hashCode;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java, +    private long hashVersion = version-1;, +    private int hashCode = 0;, +, +    @Override, +    public int hashCode() {, +        hashCode = (hashVersion != version ? super.hashCode() : hashCode);, +        hashVersion = version;, +        return hashCode;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +, +        public MutableShardRouting[] drain() {, +            MutableShardRouting[] mutableShardRoutings = unassigned.toArray(new MutableShardRouting[unassigned.size()]);, +            unassigned.clear();, +            primaries = 0;, +            transactionId++;, +            return mutableShardRoutings;, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java, +    private long hashVersion = version-1;, +    private int hashCode = 0;, +, +    @Override, +    public int hashCode() {, +        hashCode = (hashVersion != version ? super.hashCode() : hashCode);, +        hashVersion = version;, +        return hashCode;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +, +        public MutableShardRouting[] drain() {, +            MutableShardRouting[] mutableShardRoutings = unassigned.toArray(new MutableShardRouting[unassigned.size()]);, +            unassigned.clear();, +            primaries = 0;, +            transactionId++;, +            return mutableShardRoutings;, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.apache.lucene.util.ArrayUtil;, +import org.elasticsearch.common.collect.IdentityHashSet;, +            if (!changed) {, +            }, +            if (!changed) {, +            }, +            final Comparator<MutableShardRouting> comparator = new Comparator<MutableShardRouting>() {, +                    if (o1.primary() ^ o2.primary()) {, +                    final int indexCmp;, +                    if ((indexCmp = o1.index().compareTo(o2.index())) == 0) {, +            };, +            /*, +             * we use 2 arrays and move replicas to the second array once we allocated an identical, +             * replica in the current iteration to make sure all indices get allocated in the same manner., +             * The arrays are sorted by primaries first and then by index and shard ID so a 2 indices with 2 replica and 1 shard would look like:, +             * [(0,P,IDX1), (0,P,IDX2), (0,R,IDX1), (0,R,IDX1), (0,R,IDX2), (0,R,IDX2)], +             * if we allocate for instance (0, R, IDX1) we move the second replica to the secondary array and proceed with, +             * the next replica. If we could not find a node to allocate (0,R,IDX1) we move all it's replicas to ingoreUnassigned., +             */, +            MutableShardRouting[] primary = unassigned.drain();, +            MutableShardRouting[] secondary = new MutableShardRouting[primary.length];, +            int secondaryLength = 0;, +            int primaryLength = primary.length;, +            ArrayUtil.timSort(primary, comparator);, +            final Set<ModelNode> values = new IdentityHashSet<ModelNode>(nodes.values());, +                for (int i = 0; i < primaryLength; i++) {, +                    MutableShardRouting shard = primary[i];, +                    if (!shard.primary()) {, +                        boolean drop = deciders.canAllocate(shard, allocation).type() == Type.NO;, +                        if (drop) {, +                            ignoredUnassigned.add(shard);, +                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {, +                                ignoredUnassigned.add(primary[++i]);, +                            }, +                            continue;, +                        } else {, +                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {, +                                secondary[secondaryLength++] = primary[++i];, +                    }, +                    assert !shard.assignedToNode() : shard;, +                    for (ModelNode node : values) {, +                        } else {, +                            final RoutingNode node = routingNodes.node(minNode.getNodeId());, +                            if (deciders.canAllocate(node, allocation).type() != Type.YES) {, +                                if (logger.isTraceEnabled()) {, +                                    logger.trace("Can not allocate on node [{}] remove from round decisin [{}]", node, decision.type());, +                                }, +                                values.remove(minNode);, +                            }, +                    if (!shard.primary()) { // we could not allocate it and we are a replica - check if we can ignore the other replicas, +                        while(secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength-1]) == 0) {]