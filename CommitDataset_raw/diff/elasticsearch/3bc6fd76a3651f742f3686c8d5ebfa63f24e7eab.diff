[+++ b/plugin/core/src/main/java/org/elasticsearch/license/LicenseService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +                    && isProductionMode(settings, clusterService.localNode())) {, +, +    private static boolean isProductionMode(Settings settings, DiscoveryNode localNode) {, +        final boolean singleNodeDisco = "single-node".equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings));, +        return singleNodeDisco == false && isBoundToLoopback(localNode) == false;, +    }, +, +    private static boolean isBoundToLoopback(DiscoveryNode localNode) {, +        return localNode.getAddress().address().getAddress().isLoopbackAddress();, +    }, +++ b/plugin/core/src/main/java/org/elasticsearch/license/LicenseService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +                    && isProductionMode(settings, clusterService.localNode())) {, +, +    private static boolean isProductionMode(Settings settings, DiscoveryNode localNode) {, +        final boolean singleNodeDisco = "single-node".equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings));, +        return singleNodeDisco == false && isBoundToLoopback(localNode) == false;, +    }, +, +    private static boolean isBoundToLoopback(DiscoveryNode localNode) {, +        return localNode.getAddress().address().getAddress().isLoopbackAddress();, +    }, +++ b/plugin/core/src/test/java/org/elasticsearch/license/AbstractLicenseServiceTestCase.java, +        final DiscoveryNode mockNode = getLocalNode();, +        when(clusterService.localNode()).thenReturn(mockNode);, +    }, +, +    protected DiscoveryNode getLocalNode() {, +        return new DiscoveryNode("b", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);, +++ b/plugin/core/src/main/java/org/elasticsearch/license/LicenseService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +                    && isProductionMode(settings, clusterService.localNode())) {, +, +    private static boolean isProductionMode(Settings settings, DiscoveryNode localNode) {, +        final boolean singleNodeDisco = "single-node".equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings));, +        return singleNodeDisco == false && isBoundToLoopback(localNode) == false;, +    }, +, +    private static boolean isBoundToLoopback(DiscoveryNode localNode) {, +        return localNode.getAddress().address().getAddress().isLoopbackAddress();, +    }, +++ b/plugin/core/src/test/java/org/elasticsearch/license/AbstractLicenseServiceTestCase.java, +        final DiscoveryNode mockNode = getLocalNode();, +        when(clusterService.localNode()).thenReturn(mockNode);, +    }, +, +    protected DiscoveryNode getLocalNode() {, +        return new DiscoveryNode("b", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);, +++ b/plugin/core/src/test/java/org/elasticsearch/license/LicenseTLSTests.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.license;, +, +import org.elasticsearch.Version;, +import org.elasticsearch.action.support.PlainActionFuture;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.unit.TimeValue;, +, +import java.net.InetAddress;, +, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.emptySet;, +import static org.hamcrest.Matchers.containsString;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +, +public class LicenseTLSTests extends AbstractLicenseServiceTestCase {, +, +    private InetAddress inetAddress;, +, +    public void testApplyLicenseInDevMode() throws Exception {, +        License newLicense = TestUtils.generateSignedLicense(randomFrom("gold", "platinum"), TimeValue.timeValueHours(24L));, +        PutLicenseRequest request = new PutLicenseRequest();, +        request.acknowledge(true);, +        request.license(newLicense);, +        Settings settings = Settings.builder().put("xpack.security.enabled", true).build();, +        XPackLicenseState licenseState = new XPackLicenseState(settings);, +        inetAddress = InetAddress.getLoopbackAddress();, +, +        setInitialState(null, licenseState, settings);, +        licenseService.start();, +        PlainActionFuture<PutLicenseResponse> responseFuture = new PlainActionFuture<>();, +        licenseService.registerLicense(request, responseFuture);, +        verify(clusterService).submitStateUpdateTask(any(String.class), any(ClusterStateUpdateTask.class));, +, +        inetAddress = TransportAddress.META_ADDRESS;, +        settings = Settings.builder(), +                .put("xpack.security.enabled", true), +                .put("discovery.type", "single-node"), +                .build();, +        licenseService.stop();]