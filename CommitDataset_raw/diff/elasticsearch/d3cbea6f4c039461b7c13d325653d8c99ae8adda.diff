[+++ b/shield/src/main/java/org/elasticsearch/shield/audit/index/IndexAuditTrail.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +    private final boolean indexToRemoteCluster;, +        this.indexToRemoteCluster = settings.getByPrefix("shield.audit.index.client.").names().size() > 0;, +, +     * if the node is the master or not. When using remote indexing, a call to the remote cluster will be made to retrieve, +     * the state and the same rules will be applied. In order for the service to start, the following must be true:, +    public synchronized boolean canStart(ClusterChangedEvent event, boolean master) {, +        if (indexToRemoteCluster) {, +            try {, +                if (client == null) {, +                    initializeClient();, +                }, +            } catch (Exception e) {, +                logger.error("failed to initialize client for remote indexing. index based output is disabled", e);, +                state.set(State.FAILED);, +                return false;, +            }, +, +            ClusterStateResponse response = client.admin().cluster().prepareState().execute().actionGet();, +            return canStart(response.getState(), master);, +        }, +        return canStart(event.state(), master);, +    }, +, +    private boolean canStart(ClusterState clusterState, boolean master) {, +        if (clusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +            if (client == null) {, +            }, +, +                enqueue(message("anonymous_access_denied", action, null, null, indices(message), message), "anonymous_access_denied");, +                enqueue(message("anonymous_access_denied", null, null, null, null, request), "anonymous_access_denied");, +                enqueue(message("authentication_failed", action, null, null, indices(message), message), "authentication_failed");, +                enqueue(message("authentication_failed", null, null, null, null, request), "authentication_failed");, +                    enqueue(message("authentication_failed", action, token.principal(), null, indices(message), message), "authentication_failed");, +                    enqueue(message("authentication_failed", null, token.principal(), null, null, request), "authentication_failed");, +                    enqueue(message("authentication_failed", action, token.principal(), realm, indices(message), message), "authentication_failed");, +                    enqueue(message("authentication_failed", null, token.principal(), realm, null, request), "authentication_failed");, +                        enqueue(message("access_granted", action, user.principal(), null, indices(message), message), "access_granted");, +                    enqueue(message("access_granted", action, user.principal(), null, indices(message), message), "access_granted");, +                    enqueue(message("access_denied", action, user.principal(), null, indices(message), message), "access_denied");, +                    enqueue(message("tampered_request", action, user.principal(), null, indices(request), request), "tampered_request");, +                enqueue(message("ip_filter", "connection_granted", inetAddress, profile, rule), "connection_granted");, +                enqueue(message("ip_filter", "connection_denied", inetAddress, profile, rule), "connection_denied");, +    void enqueue(Message message, String type) {, +                logger.warn("failed to index audit event: [{}]. queue is full; bulk processor may not be able to keep up or has stopped indexing.", type);, +        if (indexToRemoteCluster == false) {, +            Settings clientSettings = settings.getByPrefix("shield.audit.index.client.");, +                            .put("name", DEFAULT_CLIENT_NAME + "-" + settings.get("name")), +        STOPPED,, +        FAILED, +++ b/shield/src/main/java/org/elasticsearch/shield/audit/index/IndexAuditTrail.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +    private final boolean indexToRemoteCluster;, +        this.indexToRemoteCluster = settings.getByPrefix("shield.audit.index.client.").names().size() > 0;, +, +     * if the node is the master or not. When using remote indexing, a call to the remote cluster will be made to retrieve, +     * the state and the same rules will be applied. In order for the service to start, the following must be true:, +    public synchronized boolean canStart(ClusterChangedEvent event, boolean master) {, +        if (indexToRemoteCluster) {, +            try {, +                if (client == null) {, +                    initializeClient();, +                }, +            } catch (Exception e) {, +                logger.error("failed to initialize client for remote indexing. index based output is disabled", e);, +                state.set(State.FAILED);, +                return false;, +            }, +, +            ClusterStateResponse response = client.admin().cluster().prepareState().execute().actionGet();, +            return canStart(response.getState(), master);, +        }, +        return canStart(event.state(), master);, +    }, +, +    private boolean canStart(ClusterState clusterState, boolean master) {, +        if (clusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +            if (client == null) {, +            }, +, +                enqueue(message("anonymous_access_denied", action, null, null, indices(message), message), "anonymous_access_denied");, +                enqueue(message("anonymous_access_denied", null, null, null, null, request), "anonymous_access_denied");, +                enqueue(message("authentication_failed", action, null, null, indices(message), message), "authentication_failed");, +                enqueue(message("authentication_failed", null, null, null, null, request), "authentication_failed");, +                    enqueue(message("authentication_failed", action, token.principal(), null, indices(message), message), "authentication_failed");, +                    enqueue(message("authentication_failed", null, token.principal(), null, null, request), "authentication_failed");, +                    enqueue(message("authentication_failed", action, token.principal(), realm, indices(message), message), "authentication_failed");, +                    enqueue(message("authentication_failed", null, token.principal(), realm, null, request), "authentication_failed");, +                        enqueue(message("access_granted", action, user.principal(), null, indices(message), message), "access_granted");, +                    enqueue(message("access_granted", action, user.principal(), null, indices(message), message), "access_granted");, +                    enqueue(message("access_denied", action, user.principal(), null, indices(message), message), "access_denied");, +                    enqueue(message("tampered_request", action, user.principal(), null, indices(request), request), "tampered_request");, +                enqueue(message("ip_filter", "connection_granted", inetAddress, profile, rule), "connection_granted");, +                enqueue(message("ip_filter", "connection_denied", inetAddress, profile, rule), "connection_denied");, +    void enqueue(Message message, String type) {, +                logger.warn("failed to index audit event: [{}]. queue is full; bulk processor may not be able to keep up or has stopped indexing.", type);, +        if (indexToRemoteCluster == false) {, +            Settings clientSettings = settings.getByPrefix("shield.audit.index.client.");, +                            .put("name", DEFAULT_CLIENT_NAME + "-" + settings.get("name"))]