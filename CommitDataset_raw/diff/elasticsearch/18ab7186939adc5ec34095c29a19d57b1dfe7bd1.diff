[+++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/AbstractRefCounted.java, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/AbstractRefCounted.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/ReleasableLock.java, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/AbstractRefCounted.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/ReleasableLock.java, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +    /**, +     * Build a map of DiscoveryNodes to shard state number for the given shard., +     * A state of -1 means the shard does not exist on the node, where any, +     * shard state >= 0 is the state version of the shard on that node's disk., +     *, +     * A shard on shared storage will return at least shard state 0 for all, +     * nodes, indicating that the shard can be allocated to any node., +     */, +            long version = nodeShardState.version();, +            Settings idxSettings = indexMetaData.settings();, +            if (IndexMetaData.isOnSharedFilesystem(idxSettings) &&, +                    idxSettings.getAsBoolean(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, false)) {, +                // Shared filesystems use 0 as a minimum shard state, which, +                // means that the shard can be allocated to any node, +                version = Math.max(0, version);, +            }, +                    shard, nodeShardState.getNode(), version);, +            shardStates.put(nodeShardState.getNode(), version);, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.gateway.local.sync`::, +++ b/docs/reference/query-dsl/filters/geo-distance-range-filter.asciidoc, +                "to" : "400km",, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE = "index.shared_filesystem.recover_on_any_node";, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/AbstractRefCounted.java, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/ReleasableLock.java, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +    /**, +     * Build a map of DiscoveryNodes to shard state number for the given shard., +     * A state of -1 means the shard does not exist on the node, where any, +     * shard state >= 0 is the state version of the shard on that node's disk., +     *, +     * A shard on shared storage will return at least shard state 0 for all, +     * nodes, indicating that the shard can be allocated to any node., +     */, +            long version = nodeShardState.version();, +            Settings idxSettings = indexMetaData.settings();, +            if (IndexMetaData.isOnSharedFilesystem(idxSettings) &&, +                    idxSettings.getAsBoolean(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, false)) {, +                // Shared filesystems use 0 as a minimum shard state, which, +                // means that the shard can be allocated to any node, +                version = Math.max(0, version);, +            }, +                    shard, nodeShardState.getNode(), version);, +            shardStates.put(nodeShardState.getNode(), version);, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.translog.Translog;, +import org.elasticsearch.index.translog.TranslogModule;, +            modules.add(new TranslogModule(indexSettings));, +                closeInjectorResource(sId, shardInjector, TranslogService.class);, +                        Translog.class,, +                final Closeable instance = shardInjector.getInstance(closeable);, +                    throw new NullPointerException("No instance available for " + closeable.getName());]