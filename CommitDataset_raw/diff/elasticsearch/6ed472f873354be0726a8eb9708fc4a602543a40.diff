[+++ b/src/main/java/org/elasticsearch/indices/SyncedFlushService.java, +import java.util.concurrent.ConcurrentMap;, +    * 1. Flush all shard copies and gather the commit ids for each copy after the flush, +            assert inflight >= -1;, +            if (inflight != 1) { // 1 means that there are no write operations are in flight (>1) and the shard is not closed (0)., +            Thread.currentThread().interrupt();, +    void sendSyncRequests(final String syncId, final List<ShardRouting> shards, ClusterState state, Map<String, Engine.CommitId> expectedCommitIds, final ShardId shardId, final ActionListener<SyncedFlushResult> listener) {, +        final CountDown countDown = new CountDown(shards.size());, +                contDownAndSendResponseIfDone(syncId, shards, shardId, listener, countDown, results);, +                contDownAndSendResponseIfDone(syncId, shards, shardId, listener, countDown, results);, +                            contDownAndSendResponseIfDone(syncId, shards, shardId, listener, countDown, results);, +                            contDownAndSendResponseIfDone(syncId, shards, shardId, listener, countDown, results);, +    private void contDownAndSendResponseIfDone(String syncId, List<ShardRouting> shards, ShardId shardId, ActionListener<SyncedFlushResult> listener, CountDown countDown, Map<ShardRouting, SyncedFlushResponse> results) {, +        if (countDown.countDown()) {, +            assert results.size() == shards.size();, +            listener.onResponse(new SyncedFlushResult(shardId, syncId, results));, +        }, +    }, +, +        final ConcurrentMap<String, Engine.CommitId> commitIds = ConcurrentCollections.newConcurrentMap();, +                    Engine.CommitId existing = commitIds.putIfAbsent(node.id(), response.commitId());, +            Thread.currentThread().interrupt();]