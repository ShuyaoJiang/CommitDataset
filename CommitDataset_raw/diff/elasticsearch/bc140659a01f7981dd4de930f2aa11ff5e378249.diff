[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +        patterns.put('wildcard imports', /^\s*import.*\.\*/), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +        patterns.put('wildcard imports', /^\s*import.*\.\*/), +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.unit.ByteSizeValue;, +        private long compressThreshold = Defaults.COMPRESS_THRESHOLD;, +, +        private Boolean compress = null;, +, +        public Builder compress(boolean compress) {, +            this.compress = compress;, +            return this;, +        }, +, +        public Builder compressThreshold(long compressThreshold) {, +            this.compressThreshold = compressThreshold;, +            return this;, +        }, +, +            return new SourceFieldMapper(enabled, format, compress, compressThreshold, includes, excludes, context.indexSettings());, +                } else if (fieldName.equals("compress") && parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {, +                    if (fieldNode != null) {, +                        builder.compress(nodeBooleanValue(fieldNode));, +                    }, +                    iterator.remove();, +                } else if (fieldName.equals("compress_threshold") && parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {, +                    if (fieldNode != null) {, +                        if (fieldNode instanceof Number) {, +                            builder.compressThreshold(((Number) fieldNode).longValue());, +                            builder.compress(true);, +                        } else {, +                            builder.compressThreshold(ByteSizeValue.parseBytesSizeValue(fieldNode.toString(), "compress_threshold").bytes());, +                            builder.compress(true);, +                        }, +                    }, +                    iterator.remove();, +    private Boolean compress;, +    private long compressThreshold;, +, +        this(Defaults.ENABLED, Defaults.FORMAT, null, -1, null, null, indexSettings);, +    private SourceFieldMapper(boolean enabled, String format, Boolean compress, long compressThreshold,, +        this.compress = compress;, +        this.compressThreshold = compressThreshold;, +            StreamOutput streamOutput = bStream;, +            if (compress != null && compress && (compressThreshold == -1 || source.length() > compressThreshold)) {, +                streamOutput = CompressorFactory.defaultCompressor().streamOutput(bStream);, +            }, +            XContentBuilder builder = XContentFactory.contentBuilder(contentType, streamOutput).map(filteredSource);, +        } else if (compress != null && compress && !CompressorFactory.isCompressed(source)) {, +            if (compressThreshold == -1 || source.length() > compressThreshold) {, +                BytesStreamOutput bStream = new BytesStreamOutput();, +                XContentType contentType = XContentFactory.xContentType(source);, +                if (formatContentType != null && formatContentType != contentType) {, +                    XContentBuilder builder = XContentFactory.contentBuilder(formatContentType, CompressorFactory.defaultCompressor().streamOutput(bStream));, +                    builder.copyCurrentStructure(XContentFactory.xContent(contentType).createParser(source));, +                    builder.close();, +                } else {, +                    StreamOutput streamOutput = CompressorFactory.defaultCompressor().streamOutput(bStream);, +                    source.writeTo(streamOutput);, +                    streamOutput.close();, +                }, +                source = bStream.bytes();, +                // update the data in the context, so it can be compressed and stored compressed outside..., +                context.source(source);, +            }, +        if (!includeDefaults && enabled == Defaults.ENABLED && compress == null && compressThreshold == -1 && includes == null && excludes == null) {, +        if (compress != null) {, +            builder.field("compress", compress);, +        } else if (includeDefaults) {, +            builder.field("compress", false);, +        }, +        if (compressThreshold != -1) {, +            builder.field("compress_threshold", new ByteSizeValue(compressThreshold).toString());, +        } else if (includeDefaults) {, +            builder.field("compress_threshold", -1);, +        }, +        } else {, +            if (sourceMergeWith.compress != null) {, +                this.compress = sourceMergeWith.compress;, +            }, +            if (sourceMergeWith.compressThreshold != -1) {, +                this.compressThreshold = sourceMergeWith.compressThreshold;, +            }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +        patterns.put('wildcard imports', /^\s*import.*\.\*/), +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.unit.ByteSizeValue;, +        private long compressThreshold = Defaults.COMPRESS_THRESHOLD;, +, +        private Boolean compress = null;, +, +        public Builder compress(boolean compress) {, +            this.compress = compress;, +            return this;, +        }, +, +        public Builder compressThreshold(long compressThreshold) {]