[+++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +        getDirectory(name, true).deleteFile(name);, +        return getDirectory(name, false).createOutput(name, context);, +        return getDirectory(name, true);, +    private Directory getDirectory(String name, boolean failIfNotAssociated) throws IOException {, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +        getDirectory(name, true).deleteFile(name);, +        return getDirectory(name, false).createOutput(name, context);, +        return getDirectory(name, true);, +    private Directory getDirectory(String name, boolean failIfNotAssociated) throws IOException {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +import org.elasticsearch.common.collect.Tuple;, +            Map<String, String> checksumMap = readLegacyChecksums(directory).v1();, +        static Tuple<Map<String, String>, Long> readLegacyChecksums(Directory directory) throws IOException {, +                        return new Tuple(indexInput.readStringStringMap(), lastFound);, +                return new Tuple(new HashMap<>(), -1l);, +                Tuple<Map<String, String>, Long> tuple = MetadataSnapshot.readLegacyChecksums(store.distributorDirectory);, +                tuple.v1().putAll(legacyChecksums);, +                if (!tuple.v1().isEmpty()) {, +                    writeChecksums(store.directory, tuple.v1(), tuple.v2());, +        synchronized void writeChecksums(Directory directory, Map<String, String> checksums, long lastVersion) throws IOException {, +            long nextVersion = System.currentTimeMillis();, +            while (nextVersion <= lastVersion) {, +                nextVersion = System.currentTimeMillis();, +            final String checksumName = CHECKSUMS_PREFIX + nextVersion;, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +        getDirectory(name, true).deleteFile(name);, +        return getDirectory(name, false).createOutput(name, context);, +        return getDirectory(name, true);, +    private Directory getDirectory(String name, boolean failIfNotAssociated) throws IOException {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +import org.elasticsearch.common.collect.Tuple;, +            Map<String, String> checksumMap = readLegacyChecksums(directory).v1();, +        static Tuple<Map<String, String>, Long> readLegacyChecksums(Directory directory) throws IOException {, +                        return new Tuple(indexInput.readStringStringMap(), lastFound);, +                return new Tuple(new HashMap<>(), -1l);, +                Tuple<Map<String, String>, Long> tuple = MetadataSnapshot.readLegacyChecksums(store.distributorDirectory);, +                tuple.v1().putAll(legacyChecksums);, +                if (!tuple.v1().isEmpty()) {, +                    writeChecksums(store.directory, tuple.v1(), tuple.v2());, +        synchronized void writeChecksums(Directory directory, Map<String, String> checksums, long lastVersion) throws IOException {, +            long nextVersion = System.currentTimeMillis();, +            while (nextVersion <= lastVersion) {, +                nextVersion = System.currentTimeMillis();, +            final String checksumName = CHECKSUMS_PREFIX + nextVersion;, +++ b/src/test/java/org/elasticsearch/index/deletionpolicy/SnapshotIndexCommitExistsMatcher.java, +import com.google.common.collect.Sets;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +            HashSet<String> files = Sets.newHashSet(snapshotIndexCommit.getDirectory().listAll());, +            for (String fileName : snapshotIndexCommit.getFiles()) {, +                if (files.contains(fileName) == false) {, +        } catch (IOException ex) {, +            throw new RuntimeException(ex);]