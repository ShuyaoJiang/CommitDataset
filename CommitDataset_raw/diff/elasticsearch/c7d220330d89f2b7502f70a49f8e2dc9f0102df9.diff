[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        QUERY_SHARD_EXCEPTION(org.elasticsearch.index.query.QueryShardException.class, org.elasticsearch.index.query.QueryShardException::new, 141),, +        PIPELINE_MISSING_EXCEPTION(org.elasticsearch.ingest.PipelineMissingException.class, org.elasticsearch.ingest.PipelineMissingException::new, 142);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        QUERY_SHARD_EXCEPTION(org.elasticsearch.index.query.QueryShardException.class, org.elasticsearch.index.query.QueryShardException::new, 141),, +        PIPELINE_MISSING_EXCEPTION(org.elasticsearch.ingest.PipelineMissingException.class, org.elasticsearch.ingest.PipelineMissingException::new, 142);, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +import org.elasticsearch.action.ingest.IngestActionFilter;, +import org.elasticsearch.action.ingest.IngestProxyActionFilter;, +import org.elasticsearch.action.ingest.DeletePipelineAction;, +import org.elasticsearch.action.ingest.DeletePipelineTransportAction;, +import org.elasticsearch.action.ingest.GetPipelineAction;, +import org.elasticsearch.action.ingest.GetPipelineTransportAction;, +import org.elasticsearch.action.ingest.PutPipelineAction;, +import org.elasticsearch.action.ingest.PutPipelineTransportAction;, +import org.elasticsearch.action.ingest.SimulatePipelineAction;, +import org.elasticsearch.action.ingest.SimulatePipelineTransportAction;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.node.NodeModule;, +    private final boolean ingestEnabled;, +    public ActionModule(Settings settings, boolean proxy) {, +        this.ingestEnabled = NodeModule.isNodeIngestEnabled(settings);, +        if (proxy == false) {, +            if (ingestEnabled) {, +                registerFilter(IngestActionFilter.class);, +            } else {, +                registerFilter(IngestProxyActionFilter.class);, +            }, +        }, +        registerAction(PutPipelineAction.INSTANCE, PutPipelineTransportAction.class);, +        registerAction(GetPipelineAction.INSTANCE, GetPipelineTransportAction.class);, +        registerAction(DeletePipelineAction.INSTANCE, DeletePipelineTransportAction.class);, +        registerAction(SimulatePipelineAction.INSTANCE, SimulatePipelineTransportAction.class);, +, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        QUERY_SHARD_EXCEPTION(org.elasticsearch.index.query.QueryShardException.class, org.elasticsearch.index.query.QueryShardException::new, 141),, +        PIPELINE_MISSING_EXCEPTION(org.elasticsearch.ingest.PipelineMissingException.class, org.elasticsearch.ingest.PipelineMissingException::new, 142);, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +import org.elasticsearch.action.ingest.IngestActionFilter;, +import org.elasticsearch.action.ingest.IngestProxyActionFilter;, +import org.elasticsearch.action.ingest.DeletePipelineAction;, +import org.elasticsearch.action.ingest.DeletePipelineTransportAction;, +import org.elasticsearch.action.ingest.GetPipelineAction;, +import org.elasticsearch.action.ingest.GetPipelineTransportAction;, +import org.elasticsearch.action.ingest.PutPipelineAction;, +import org.elasticsearch.action.ingest.PutPipelineTransportAction;, +import org.elasticsearch.action.ingest.SimulatePipelineAction;, +import org.elasticsearch.action.ingest.SimulatePipelineTransportAction;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.node.NodeModule;, +    private final boolean ingestEnabled;, +    public ActionModule(Settings settings, boolean proxy) {, +        this.ingestEnabled = NodeModule.isNodeIngestEnabled(settings);, +        if (proxy == false) {, +            if (ingestEnabled) {, +                registerFilter(IngestActionFilter.class);, +            } else {, +                registerFilter(IngestProxyActionFilter.class);, +            }, +        }, +        registerAction(PutPipelineAction.INSTANCE, PutPipelineTransportAction.class);, +        registerAction(GetPipelineAction.INSTANCE, GetPipelineTransportAction.class);, +        registerAction(DeletePipelineAction.INSTANCE, DeletePipelineTransportAction.class);, +        registerAction(SimulatePipelineAction.INSTANCE, SimulatePipelineTransportAction.class);, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/settings/SettingsUpdater.java, +import org.elasticsearch.common.regex.Regex;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.Set;, +, +        changed |= apply(transientToApply, transientSettings, transientUpdates, "transient");, +        changed |= apply(persistentToApply, persistentSettings, persistentUpdates, "persistent");, +    private boolean apply(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {, +        boolean changed = false;, +        final Set<String> toRemove = new HashSet<>();, +        Settings.Builder settingsBuilder = Settings.settingsBuilder();, +        for (Map.Entry<String, String> entry : toApply.getAsMap().entrySet()) {, +            if (entry.getValue() == null) {, +                toRemove.add(entry.getKey());, +            } else if (clusterSettings.isLoggerSetting(entry.getKey()) || clusterSettings.hasDynamicSetting(entry.getKey())) {, +                settingsBuilder.put(entry.getKey(), entry.getValue());, +                updates.put(entry.getKey(), entry.getValue());, +                changed = true;, +            } else {, +                throw new IllegalArgumentException(type + " setting [" + entry.getKey() + "], not dynamically updateable");, +            }, +        changed |= applyDeletes(toRemove, target);, +        target.put(settingsBuilder.build());, +        return changed;, +    }, +, +    private final boolean applyDeletes(Set<String> deletes, Settings.Builder builder) {, +        boolean changed = false;, +        for (String entry : deletes) {, +            Set<String> keysToRemove = new HashSet<>();, +            Set<String> keySet = builder.internalMap().keySet();, +            for (String key : keySet) {, +                if (Regex.simpleMatch(entry, key)) {, +                    keysToRemove.add(key);]