[+++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.Future;, +import java.util.concurrent.FutureTask;, +        Map<K, Future<Entry<K, V>>> map = new HashMap<>();, +, +            Future<Entry<K, V>> future;, +            Entry<K, V> entry = null;, +                future = map.get(key);, +            if (future != null) {, +                try {, +                    entry = future.get();, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +                try {, +                    Future<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry));, +                    existing = future != null ? future.get() : null;, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +            Future<Entry<K, V>> future;, +            Entry<K, V> entry = null;, +                future = map.remove(key);, +            if (future != null) {, +                try {, +                    entry = future.get();, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +     * value using the given mapping function and enters it into this map unless null. The load method for a given key, +     * will be invoked at most once., +            // we need to synchronize loading of a value for a given key; however, holding the segment lock while, +            // invoking load can lead to deadlock against another thread due to dependent key loading; therefore, we, +            // need a mechanism to ensure that load is invoked at most once, but we are not invoking load while holding, +            // the segment lock; to do this, we atomically put a future in the map that can load the value, and then, +            // get the value from this future on the thread that won the race to place the future into the segment map, +            Future<Entry<K, V>> future;, +            FutureTask<Entry<K, V>> task = new FutureTask<>(() -> new Entry<>(key, loader.load(key), now));, +                future = segment.map.putIfAbsent(key, task);, +            if (future == null) {, +                future = task;, +                task.run();, +            }, +, +            Entry<K, V> entry;, +            try {, +                entry = future.get();, +            } catch (ExecutionException | InterruptedException e) {, +                // if the future ended exceptionally, we do not want to pollute the cache, +                // however, we have to take care to ensure that the polluted entry has not already been replaced, +                try (ReleasableLock ignored = segment.writeLock.acquire()) {, +                    Future<Entry<K, V>> sanity = segment.map.get(key);, +                    try {, +                        sanity.get();, +                    } catch (ExecutionException | InterruptedException gotcha) {, +                        segment.map.remove(key);, +                    }, +                }, +                throw (e instanceof ExecutionException) ? (ExecutionException)e : new ExecutionException(e);, +            }, +            if (entry.value == null) {, +            try (ReleasableLock ignored = lruLock.acquire()) {, +                promote(entry, now);, +            value = entry.value;, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.Future;, +import java.util.concurrent.FutureTask;, +        Map<K, Future<Entry<K, V>>> map = new HashMap<>();, +, +            Future<Entry<K, V>> future;, +            Entry<K, V> entry = null;, +                future = map.get(key);, +            if (future != null) {, +                try {, +                    entry = future.get();, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +                try {, +                    Future<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry));, +                    existing = future != null ? future.get() : null;, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +            Future<Entry<K, V>> future;, +            Entry<K, V> entry = null;, +                future = map.remove(key);, +            if (future != null) {, +                try {, +                    entry = future.get();, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +     * value using the given mapping function and enters it into this map unless null. The load method for a given key, +     * will be invoked at most once., +            // we need to synchronize loading of a value for a given key; however, holding the segment lock while, +            // invoking load can lead to deadlock against another thread due to dependent key loading; therefore, we, +            // need a mechanism to ensure that load is invoked at most once, but we are not invoking load while holding]