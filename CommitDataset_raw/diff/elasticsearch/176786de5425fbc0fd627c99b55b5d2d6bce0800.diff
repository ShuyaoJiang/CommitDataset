[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +                if (e instanceof IllegalArgumentException) {, +                    // the underlying error differs depending on which way around the clashing fields are seen, +                    Matcher matcher = Pattern.compile("(?:mapper|Can't merge a non object mapping) \\[(.*)\\] (?:of different type, " +, +                            "current_type \\[.*\\], merged_type|with an object mapping) \\[.*\\]").matcher(e.getMessage());, +                    if (matcher.matches()) {, +                        String msg = Messages.getMessage(Messages.JOB_CONFIG_MAPPING_TYPE_CLASH, matcher.group(1));, +                        actionListener.onFailure(ExceptionsHelper.badRequestException(msg, e));, +                        return;, +                }, +                actionListener.onFailure(e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +                if (e instanceof IllegalArgumentException) {, +                    // the underlying error differs depending on which way around the clashing fields are seen, +                    Matcher matcher = Pattern.compile("(?:mapper|Can't merge a non object mapping) \\[(.*)\\] (?:of different type, " +, +                            "current_type \\[.*\\], merged_type|with an object mapping) \\[.*\\]").matcher(e.getMessage());, +                    if (matcher.matches()) {, +                        String msg = Messages.getMessage(Messages.JOB_CONFIG_MAPPING_TYPE_CLASH, matcher.group(1));, +                        actionListener.onFailure(ExceptionsHelper.badRequestException(msg, e));, +                        return;, +                }, +                actionListener.onFailure(e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/AnalysisConfig.java, +                    throw ExceptionsHelper.badRequestException("Fields [" + prevTermField + "] and [" + termField +, +                            "] cannot both be used in the same analysis_config");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +                if (e instanceof IllegalArgumentException) {, +                    // the underlying error differs depending on which way around the clashing fields are seen, +                    Matcher matcher = Pattern.compile("(?:mapper|Can't merge a non object mapping) \\[(.*)\\] (?:of different type, " +, +                            "current_type \\[.*\\], merged_type|with an object mapping) \\[.*\\]").matcher(e.getMessage());, +                    if (matcher.matches()) {, +                        String msg = Messages.getMessage(Messages.JOB_CONFIG_MAPPING_TYPE_CLASH, matcher.group(1));, +                        actionListener.onFailure(ExceptionsHelper.badRequestException(msg, e));, +                        return;, +                }, +                actionListener.onFailure(e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/AnalysisConfig.java, +                    throw ExceptionsHelper.badRequestException("Fields [" + prevTermField + "] and [" + termField +, +                            "] cannot both be used in the same analysis_config");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/messages/Messages.java, +            "This job would cause a mapping clash with existing field [{0}] - avoid the clash by assigning a dedicated results index";, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +                if (e instanceof IllegalArgumentException) {, +                    // the underlying error differs depending on which way around the clashing fields are seen, +                    Matcher matcher = Pattern.compile("(?:mapper|Can't merge a non object mapping) \\[(.*)\\] (?:of different type, " +, +                            "current_type \\[.*\\], merged_type|with an object mapping) \\[.*\\]").matcher(e.getMessage());, +                    if (matcher.matches()) {, +                        String msg = Messages.getMessage(Messages.JOB_CONFIG_MAPPING_TYPE_CLASH, matcher.group(1));, +                        actionListener.onFailure(ExceptionsHelper.badRequestException(msg, e));, +                        return;, +                }, +                actionListener.onFailure(e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/AnalysisConfig.java, +                    throw ExceptionsHelper.badRequestException("Fields [" + prevTermField + "] and [" + termField +, +                            "] cannot both be used in the same analysis_config");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/messages/Messages.java, +            "This job would cause a mapping clash with existing field [{0}] - avoid the clash by assigning a dedicated results index";, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/MlJobIT.java, +        String byFieldName1;, +        String byFieldName2;, +        // we should get the friendly advice nomatter which way around the clashing fields are seen, +        if (randomBoolean()) {, +            byFieldName1 = "response";, +            byFieldName2 = "response.time";, +        } else {, +            byFieldName1 = "response.time";, +            byFieldName2 = "response";, +        }, +                containsString("This job would cause a mapping clash with existing field [response] - " +, +                        "avoid the clash by assigning a dedicated results index"));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +                if (e instanceof IllegalArgumentException) {, +                    // the underlying error differs depending on which way around the clashing fields are seen, +                    Matcher matcher = Pattern.compile("(?:mapper|Can't merge a non object mapping) \\[(.*)\\] (?:of different type, " +, +                            "current_type \\[.*\\], merged_type|with an object mapping) \\[.*\\]").matcher(e.getMessage());, +                    if (matcher.matches()) {, +                        String msg = Messages.getMessage(Messages.JOB_CONFIG_MAPPING_TYPE_CLASH, matcher.group(1));, +                        actionListener.onFailure(ExceptionsHelper.badRequestException(msg, e));, +                        return;, +                }, +                actionListener.onFailure(e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/AnalysisConfig.java, +                    throw ExceptionsHelper.badRequestException("Fields [" + prevTermField + "] and [" + termField +, +                            "] cannot both be used in the same analysis_config");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/messages/Messages.java, +            "This job would cause a mapping clash with existing field [{0}] - avoid the clash by assigning a dedicated results index";, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/MlJobIT.java, +        String byFieldName1;, +        String byFieldName2;, +        // we should get the friendly advice nomatter which way around the clashing fields are seen]