[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +        QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(queryParseContext.parseInnerQueryBuilder(), queryShardContext);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +        QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(queryParseContext.parseInnerQueryBuilder(), queryShardContext);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRouting;, +    public static final Setting<Settings> INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING =, +        Setting.groupSetting("index.routing.allocation.initial_recovery."); // this is only setable internally not a registered setting!!, +    private final DiscoveryNodeFilters initialRecoveryFilters;, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters initialRecoveryFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +        this.initialRecoveryFilters = initialRecoveryFilters;, +    public DiscoveryNodeFilters getInitialRecoveryFilters() {, +        return initialRecoveryFilters;, +    }, +, +    @Nullable, +            Map<String, String> initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.get(settings).getAsMap();, +            final DiscoveryNodeFilters initialRecoveryFilters;, +            if (initialRecoveryMap.isEmpty()) {, +                initialRecoveryFilters = null;, +            } else {, +                initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap);, +            }, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, initialRecoveryFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +        QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(queryParseContext.parseInnerQueryBuilder(), queryShardContext);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRouting;, +    public static final Setting<Settings> INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING =, +        Setting.groupSetting("index.routing.allocation.initial_recovery."); // this is only setable internally not a registered setting!!, +    private final DiscoveryNodeFilters initialRecoveryFilters;, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters initialRecoveryFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +        this.initialRecoveryFilters = initialRecoveryFilters;, +    public DiscoveryNodeFilters getInitialRecoveryFilters() {, +        return initialRecoveryFilters;, +    }, +, +    @Nullable, +            Map<String, String> initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.get(settings).getAsMap();, +            final DiscoveryNodeFilters initialRecoveryFilters;, +            if (initialRecoveryMap.isEmpty()) {, +                initialRecoveryFilters = null;, +            } else {, +                initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap);, +            }, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, initialRecoveryFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 shard so far!, +            // we use "i.r.a.initial_recovery" rather than "i.r.a.require|include" since we want the replica to allocate right away, +            // once we are allocated., +            .put("index.routing.allocation.initial_recovery._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +        QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(queryParseContext.parseInnerQueryBuilder(), queryShardContext);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRouting;, +    public static final Setting<Settings> INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING =, +        Setting.groupSetting("index.routing.allocation.initial_recovery."); // this is only setable internally not a registered setting!!, +    private final DiscoveryNodeFilters initialRecoveryFilters;, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters initialRecoveryFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +        this.initialRecoveryFilters = initialRecoveryFilters;, +    public DiscoveryNodeFilters getInitialRecoveryFilters() {, +        return initialRecoveryFilters;, +    }, +, +    @Nullable, +            Map<String, String> initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.get(settings).getAsMap();, +            final DiscoveryNodeFilters initialRecoveryFilters;, +            if (initialRecoveryMap.isEmpty()) {, +                initialRecoveryFilters = null;, +            } else {, +                initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap);, +            }, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, initialRecoveryFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 shard so far!, +            // we use "i.r.a.initial_recovery" rather than "i.r.a.require|include" since we want the replica to allocate right away, +            // once we are allocated., +            .put("index.routing.allocation.initial_recovery._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +        if (shardRouting.unassigned()) {, +            // only for unassigned - we filter allocation right after the index creation ie. for shard shrinking etc. to ensure, +            // that once it has been allocated post API the replicas can be allocated elsewhere without user interaction, +            // this is a setting that can only be set within the system!, +            IndexMetaData indexMd = allocation.metaData().getIndexSafe(shardRouting.index());, +            DiscoveryNodeFilters initialRecoveryFilters = indexMd.getInitialRecoveryFilters();, +            if (shardRouting.allocatedPostIndexCreate(indexMd) == false &&, +                initialRecoveryFilters != null &&, +                initialRecoveryFilters.match(node.node()) == false) {, +                return allocation.decision(Decision.NO, NAME, "node does not match index initial recovery filters [%s]",, +                    indexMd.includeFilters());, +            }, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +        QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(queryParseContext.parseInnerQueryBuilder(), queryShardContext);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRouting;]