[+++ b/core/src/test/java/org/elasticsearch/bootstrap/MaxMapCountCheckTests.java, +import org.apache.logging.log4j.Level;, +import org.apache.logging.log4j.core.LogEvent;, +import org.elasticsearch.common.logging.ESLoggerFactory;, +import org.elasticsearch.common.logging.TestLoggers;, +import org.elasticsearch.test.MockLogAppender;, +import java.util.Arrays;, +import java.util.function.Predicate;, +    public void testGetMaxMapCount() throws IOException, IllegalAccessException {, +        {, +            final Logger logger = ESLoggerFactory.getLogger("testGetMaxMapCountIOException");, +            final MockLogAppender appender = new MockLogAppender();, +            appender.addExpectation(, +                    new ParameterizedMessageLoggingExpectation(, +                            "expected logged I/O exception",, +                            "testGetMaxMapCountIOException",, +                            Level.WARN,, +                            "I/O exception while trying to read [{}]",, +                            new Object[] { procSysVmMaxMapCountPath },, +                            e -> ioException == e));, +            TestLoggers.addAppender(logger, appender);, +            appender.assertAllExpectationsMatched();, +            TestLoggers.removeAppender(logger, appender);, +        }, +        {, +            final Logger logger = ESLoggerFactory.getLogger("testGetMaxMapCountNumberFormatException");, +            final MockLogAppender appender = new MockLogAppender();, +            appender.addExpectation(, +                    new ParameterizedMessageLoggingExpectation(, +                            "expected logged number format exception",, +                            "testGetMaxMapCountNumberFormatException",, +                            Level.WARN,, +                            "unable to parse vm.max_map_count [{}]",, +                            new Object[] { "eof" },, +                            e -> e instanceof NumberFormatException && e.getMessage().equals("For input string: \"eof\"")));, +            TestLoggers.addAppender(logger, appender);, +            appender.assertAllExpectationsMatched();, +            TestLoggers.removeAppender(logger, appender);, +, +    private static class ParameterizedMessageLoggingExpectation implements MockLogAppender.LoggingExpectation {, +, +        private boolean saw = false;, +, +        private final String name;, +        private final String loggerName;, +        private final Level level;, +        private final String messagePattern;, +        private final Object[] arguments;, +        private final Predicate<Throwable> throwablePredicate;, +, +        private ParameterizedMessageLoggingExpectation(, +                final String name,, +                final String loggerName,, +                final Level level,, +                final String messagePattern,, +                final Object[] arguments,, +                final Predicate<Throwable> throwablePredicate) {, +            this.name = name;, +            this.loggerName = loggerName;, +            this.level = level;, +            this.messagePattern = messagePattern;, +            this.arguments = arguments;, +            this.throwablePredicate = throwablePredicate;, +        }, +, +        @Override, +        public void match(LogEvent event) {, +            if (event.getLevel().equals(level) &&, +                    event.getLoggerName().equals(loggerName) &&, +                    event.getMessage() instanceof ParameterizedMessage) {, +                final ParameterizedMessage message = (ParameterizedMessage)event.getMessage();, +                saw = message.getFormat().equals(messagePattern) &&, +                        Arrays.deepEquals(arguments, message.getParameters()) &&, +                        throwablePredicate.test(event.getThrown());, +            }, +        }, +, +        @Override, +        public void assertMatched() {, +            assertTrue(name, saw);, +        }, +]