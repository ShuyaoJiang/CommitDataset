[+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                    typesToRefresh.toArray(new String[typesToRefresh.size()]), event.state().nodes().localNodeId()), +                    );, +        RoutingNodes.RoutingNodeIterator routingNode = event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());, +, +        RoutingNodes.RoutingNodeIterator routingNode = event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());, +, +                    logger.trace("ignoring recovery instruction for an existing shard {} (shard state: [{}])", indexShard.shardId(), indexShard.state());, +, +        // figure out where to recover from (node or disk, in which case sourceNode is null), +        DiscoveryNode sourceNode = null;, +        if (!shardRouting.primary()) {, +            IndexShardRoutingTable shardRoutingTable = routingTable.index(shardRouting.index()).shard(shardRouting.id());, +            for (ShardRouting entry : shardRoutingTable) {, +                if (entry.primary() && entry.started()) {, +                    // only recover from started primary, if we can't find one, we will do it next round, +                    sourceNode = nodes.get(entry.currentNodeId());, +                    if (sourceNode == null) {, +                        logger.trace("can't recover replica because primary shard {} is assigned to an unknown node. ignoring.", entry);, +                        return;, +                    }, +                    break;, +                }, +            }, +, +            if (sourceNode == null) {, +                logger.trace("can't recover replica for {} because a primary shard can not be found. ignoring.", shardRouting.shardId());, +                return;, +            }, +, +        } else if (shardRouting.relocatingNodeId() != null) {, +            sourceNode = nodes.get(shardRouting.relocatingNodeId());, +            if (sourceNode == null) {, +                logger.trace("can't recover from remote primary shard {} because it is assigned to an unknown node [{}]. ignoring.", shardRouting.shardId(), shardRouting.relocatingNodeId());, +                return;, +            }, +        }, +, +, +            logger.trace("ignoring recovery instruction for shard {} (shard state: [{}])", indexShard.shardId(), indexShard.state());, +        if (sourceNode != null) {, +                // we don't mark this one as relocated at the end., +                // For primaries: requests in any case are routed to both when its relocating and that way we handle, +                //    the edge case where its mark as relocated, and we might need to roll it back..., +                // For replicas: we are recovering a backup from a primary, +, +                RecoveryState.Type type = shardRouting.primary() ? RecoveryState.Type.RELOCATION : RecoveryState.Type.REPLICA;, +                        false, indexShard.store().list(), type);, +, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                    typesToRefresh.toArray(new String[typesToRefresh.size()]), event.state().nodes().localNodeId()), +                    );, +        RoutingNodes.RoutingNodeIterator routingNode = event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());, +, +        RoutingNodes.RoutingNodeIterator routingNode = event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());, +, +                    logger.trace("ignoring recovery instruction for an existing shard {} (shard state: [{}])", indexShard.shardId(), indexShard.state());, +, +        // figure out where to recover from (node or disk, in which case sourceNode is null), +        DiscoveryNode sourceNode = null;, +        if (!shardRouting.primary()) {, +            IndexShardRoutingTable shardRoutingTable = routingTable.index(shardRouting.index()).shard(shardRouting.id());, +            for (ShardRouting entry : shardRoutingTable) {, +                if (entry.primary() && entry.started()) {, +                    // only recover from started primary, if we can't find one, we will do it next round, +                    sourceNode = nodes.get(entry.currentNodeId());, +                    if (sourceNode == null) {, +                        logger.trace("can't recover replica because primary shard {} is assigned to an unknown node. ignoring.", entry);, +                        return;, +                    }, +                    break;, +                }, +            }, +, +            if (sourceNode == null) {, +                logger.trace("can't recover replica for {} because a primary shard can not be found. ignoring.", shardRouting.shardId());, +                return;, +            }, +, +        } else if (shardRouting.relocatingNodeId() != null) {, +            sourceNode = nodes.get(shardRouting.relocatingNodeId());, +            if (sourceNode == null) {, +                logger.trace("can't recover from remote primary shard {} because it is assigned to an unknown node [{}]. ignoring.", shardRouting.shardId(), shardRouting.relocatingNodeId());, +                return;, +            }, +        }, +, +, +            logger.trace("ignoring recovery instruction for shard {} (shard state: [{}])", indexShard.shardId(), indexShard.state());, +        if (sourceNode != null) {, +                // we don't mark this one as relocated at the end., +                // For primaries: requests in any case are routed to both when its relocating and that way we handle, +                //    the edge case where its mark as relocated, and we might need to roll it back..., +                // For replicas: we are recovering a backup from a primary, +, +                RecoveryState.Type type = shardRouting.primary() ? RecoveryState.Type.RELOCATION : RecoveryState.Type.REPLICA;, +                        false, indexShard.store().list(), type);, +, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +]