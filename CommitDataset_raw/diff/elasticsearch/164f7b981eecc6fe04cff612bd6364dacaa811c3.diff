[+++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +                    // if estimated count is zero, we at least create a single aggregator., +                    // The estimated count is just an estimation and we can't rely on how it's estimated (that is, an, +                    // estimation of 0 should not imply that we'll end up without any buckets), +                    long arraySize = estimatedBucketsCount > 0 ?  estimatedBucketsCount : 1;, +                    aggregators = BigArrays.newObjectArray(arraySize , context.pageCacheRecycler());, +                    for (long i = 1; i < arraySize; ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +                    // if estimated count is zero, we at least create a single aggregator., +                    // The estimated count is just an estimation and we can't rely on how it's estimated (that is, an, +                    // estimation of 0 should not imply that we'll end up without any buckets), +                    long arraySize = estimatedBucketsCount > 0 ?  estimatedBucketsCount : 1;, +                    aggregators = BigArrays.newObjectArray(arraySize , context.pageCacheRecycler());, +                    for (long i = 1; i < arraySize; ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +                    // if estimated count is zero, we at least create a single aggregator., +                    // The estimated count is just an estimation and we can't rely on how it's estimated (that is, an, +                    // estimation of 0 should not imply that we'll end up without any buckets), +                    long arraySize = estimatedBucketsCount > 0 ?  estimatedBucketsCount : 1;, +                    aggregators = BigArrays.newObjectArray(arraySize , context.pageCacheRecycler());, +                    for (long i = 1; i < arraySize; ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +++ b/src/test/java/org/elasticsearch/search/aggregations/CombiTests.java, +import org.elasticsearch.search.aggregations.bucket.histogram.Histogram;, +import org.hamcrest.Matchers;, +import static org.elasticsearch.search.aggregations.AggregationBuilders.*;, +import static org.hamcrest.CoreMatchers.is;, +import static org.hamcrest.core.IsNull.notNullValue;, +, +, +    /**, +     * Some top aggs (eg. date_/histogram) that are executed on unmapped fields, will generate an estimate count of buckets - zero., +     * when the sub aggregator is then created, it will take this estimation into account. This used to cause, +     * and an ArrayIndexOutOfBoundsException..., +     */, +    @Test, +    public void subAggregationForTopAggregationOnUnmappedField() throws Exception {, +, +        prepareCreate("idx").addMapping("type", jsonBuilder(), +                .startObject(), +                .startObject("type").startObject("properties"), +                    .startObject("name").field("type", "string").endObject(), +                    .startObject("value").field("type", "integer").endObject(), +                .endObject().endObject(), +                .endObject()).execute().actionGet();, +, +        ensureSearchable("idx");, +, +        SearchResponse searchResponse = client().prepareSearch("idx"), +                .addAggregation(histogram("values").field("value1").interval(1), +                        .subAggregation(terms("names").field("name"))), +                .execute().actionGet();, +, +        assertThat(searchResponse.getHits().getTotalHits(), Matchers.equalTo(0l));, +        Histogram values = searchResponse.getAggregations().get("values");, +        assertThat(values, notNullValue());, +        assertThat(values.getBuckets().isEmpty(), is(true));, +    }]