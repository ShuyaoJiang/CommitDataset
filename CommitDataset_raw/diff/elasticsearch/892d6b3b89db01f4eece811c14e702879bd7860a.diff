[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, Set<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, Set<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlockException.java, +import java.util.HashSet;, +import static java.util.Collections.unmodifiableSet;, +, +    private final Set<ClusterBlock> blocks;, +    public ClusterBlockException(Set<ClusterBlock> blocks) {, +        int totalBlocks = in.readVInt();, +        Set<ClusterBlock> blocks = new HashSet<>(totalBlocks);, +        for (int i = 0; i < totalBlocks;i++) {, +            blocks.add(ClusterBlock.readClusterBlock(in));, +        this.blocks = unmodifiableSet(blocks);, +    public Set<ClusterBlock> blocks() {, +    private static String buildMessage(Set<ClusterBlock> blocks) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, Set<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlockException.java, +import java.util.HashSet;, +import static java.util.Collections.unmodifiableSet;, +, +    private final Set<ClusterBlock> blocks;, +    public ClusterBlockException(Set<ClusterBlock> blocks) {, +        int totalBlocks = in.readVInt();, +        Set<ClusterBlock> blocks = new HashSet<>(totalBlocks);, +        for (int i = 0; i < totalBlocks;i++) {, +            blocks.add(ClusterBlock.readClusterBlock(in));, +        this.blocks = unmodifiableSet(blocks);, +    public Set<ClusterBlock> blocks() {, +    private static String buildMessage(Set<ClusterBlock> blocks) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +, +import java.util.function.Function;, +import java.util.function.Predicate;, +import java.util.stream.Stream;, +, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.emptySet;, +import static java.util.Collections.unmodifiableSet;, +import static java.util.stream.Collectors.toSet;, +import static java.util.stream.Stream.concat;, +    public static final ClusterBlocks EMPTY_CLUSTER_BLOCK = new ClusterBlocks(emptySet(), emptyMap());, +    private final Set<ClusterBlock> global;, +    private final Map<String, Set<ClusterBlock>> indicesBlocks;, +    ClusterBlocks(Set<ClusterBlock> global, Map<String, Set<ClusterBlock>> indicesBlocks) {, +        for (final ClusterBlockLevel level : ClusterBlockLevel.values()) {, +            Predicate<ClusterBlock> containsLevel = block -> block.contains(level);, +            Set<ClusterBlock> newGlobal = unmodifiableSet(global.stream(), +                    .filter(containsLevel), +                    .collect(toSet()));, +, +            ImmutableMap.Builder<String, Set<ClusterBlock>> indicesBuilder = ImmutableMap.builder();, +            for (Map.Entry<String, Set<ClusterBlock>> entry : indicesBlocks.entrySet()) {, +                indicesBuilder.put(entry.getKey(), unmodifiableSet(entry.getValue().stream(), +                        .filter(containsLevel), +                        .collect(toSet())));, +            }, +, +            levelHolders[level.id()] = new ImmutableLevelHolder(newGlobal, indicesBuilder.build());, +    public Set<ClusterBlock> global() {, +    public Map<String, Set<ClusterBlock>> indices() {, +    public Set<ClusterBlock> global(ClusterBlockLevel level) {, +    public Map<String, Set<ClusterBlock>> indices(ClusterBlockLevel level) {, +    private Set<ClusterBlock> blocksForIndex(ClusterBlockLevel level, String index) {, +        return indices(level).getOrDefault(index, emptySet());, +    }, +, +        return new ClusterBlockException(global(level));, +        Stream<ClusterBlock> blocks = concat(, +                global(level).stream(),, +                blocksForIndex(level, index).stream());, +        return new ClusterBlockException(unmodifiableSet(blocks.collect(toSet())));, +        return !blocksForIndex(level, index).isEmpty();, +        Function<String, Stream<ClusterBlock>> blocksForIndexAtLevel = index -> blocksForIndex(level, index).stream();, +        Stream<ClusterBlock> blocks = concat(, +                global(level).stream(),, +                Stream.of(indices).flatMap(blocksForIndexAtLevel));, +        return new ClusterBlockException(unmodifiableSet(blocks.collect(toSet())));, +        for (Map.Entry<String, Set<ClusterBlock>> entry : indicesBlocks.entrySet()) {, +    private static void writeBlockSet(Set<ClusterBlock> blocks, StreamOutput out) throws IOException {, +        Set<ClusterBlock> global = readBlockSet(in);, +        ImmutableMap.Builder<String, Set<ClusterBlock>> indicesBuilder = ImmutableMap.builder();, +    private static Set<ClusterBlock> readBlockSet(StreamInput in) throws IOException {, +        int totalBlocks = in.readVInt();, +        Set<ClusterBlock> blocks = new HashSet<>(totalBlocks);, +        for (int i = 0; i < totalBlocks;i++) {, +            blocks.add(ClusterBlock.readClusterBlock(in));, +        return unmodifiableSet(blocks);, +        static final ImmutableLevelHolder EMPTY = new ImmutableLevelHolder(emptySet(), ImmutableMap.of());, +        private final Set<ClusterBlock> global;, +        private final ImmutableMap<String, Set<ClusterBlock>> indices;, +        ImmutableLevelHolder(Set<ClusterBlock> global, ImmutableMap<String, Set<ClusterBlock>> indices) {, +        public Set<ClusterBlock> global() {, +        public ImmutableMap<String, Set<ClusterBlock>> indices() {, +            for (Map.Entry<String, Set<ClusterBlock>> entry : blocks.indices().entrySet()) {, +            // We copy the block sets here in case of the builder is modified after build is called, +            ImmutableMap.Builder<String, Set<ClusterBlock>> indicesBuilder = ImmutableMap.builder();, +                indicesBuilder.put(entry.getKey(), unmodifiableSet(new HashSet<>(entry.getValue())));]