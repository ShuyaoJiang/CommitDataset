[+++ b/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedEsThreadPoolExecutor.java, +        if (command instanceof PrioritizedRunnable) {, +            super.execute(new TieBreakingPrioritizedRunnable((PrioritizedRunnable) command, tieBreaker.incrementAndGet()));, +            return;, +        }, +            command = new TieBreakingPrioritizedRunnable(command, Priority.NORMAL, tieBreaker.incrementAndGet());, +    static class TieBreakingPrioritizedRunnable extends PrioritizedRunnable {, +, +        private final Runnable runnable;, +        private final long tieBreaker;, +, +        TieBreakingPrioritizedRunnable(PrioritizedRunnable runnable, long tieBreaker) {, +            this(runnable, runnable.priority(), tieBreaker);, +        }, +, +        TieBreakingPrioritizedRunnable(Runnable runnable, Priority priority, long tieBreaker) {, +            super(priority);, +            this.runnable = runnable;, +            this.tieBreaker = tieBreaker;, +        }, +, +        @Override, +        public void run() {, +            runnable.run();, +        }, +, +        @Override, +        public int compareTo(PrioritizedRunnable pr) {, +            int res = super.compareTo(pr);, +            if (res != 0 || !(pr instanceof TieBreakingPrioritizedRunnable)) {, +                return res;, +            }, +            return tieBreaker < ((TieBreakingPrioritizedRunnable)pr).tieBreaker ? -1 : 1;, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedEsThreadPoolExecutor.java, +        if (command instanceof PrioritizedRunnable) {, +            super.execute(new TieBreakingPrioritizedRunnable((PrioritizedRunnable) command, tieBreaker.incrementAndGet()));, +            return;, +        }, +            command = new TieBreakingPrioritizedRunnable(command, Priority.NORMAL, tieBreaker.incrementAndGet());, +    static class TieBreakingPrioritizedRunnable extends PrioritizedRunnable {, +, +        private final Runnable runnable;, +        private final long tieBreaker;, +, +        TieBreakingPrioritizedRunnable(PrioritizedRunnable runnable, long tieBreaker) {, +            this(runnable, runnable.priority(), tieBreaker);, +        }, +, +        TieBreakingPrioritizedRunnable(Runnable runnable, Priority priority, long tieBreaker) {, +            super(priority);, +            this.runnable = runnable;, +            this.tieBreaker = tieBreaker;, +        }, +, +        @Override, +        public void run() {, +            runnable.run();, +        }, +, +        @Override, +        public int compareTo(PrioritizedRunnable pr) {, +            int res = super.compareTo(pr);, +            if (res != 0 || !(pr instanceof TieBreakingPrioritizedRunnable)) {, +                return res;, +            }, +            return tieBreaker < ((TieBreakingPrioritizedRunnable)pr).tieBreaker ? -1 : 1;, +        }, +    }, +, +++ b/src/test/java/org/elasticsearch/test/unit/common/util/concurrent/PrioritizedExecutorsTests.java, +    public void testSubmitPrioritizedExecutorWithRunnables() throws Exception {, +    public void testExecutePrioritizedExecutorWithRunnables() throws Exception {, +        ExecutorService executor = EsExecutors.newSinglePrioritizingThreadExecutor(Executors.defaultThreadFactory());, +        List<Integer> results = new ArrayList<Integer>(7);, +        CountDownLatch awaitingLatch = new CountDownLatch(1);, +        CountDownLatch finishedLatch = new  CountDownLatch(7);, +        executor.execute(new AwaitingJob(awaitingLatch));, +        executor.execute(new Job(6, Priority.LANGUID, results, finishedLatch));, +        executor.execute(new Job(4, Priority.LOW, results, finishedLatch));, +        executor.execute(new Job(1, Priority.HIGH, results, finishedLatch));, +        executor.execute(new Job(5, Priority.LOW, results, finishedLatch)); // will execute after the first LOW (fifo), +        executor.execute(new Job(0, Priority.URGENT, results, finishedLatch));, +        executor.execute(new Job(3, Priority.NORMAL, results, finishedLatch));, +        executor.execute(new Job(2, Priority.HIGH, results, finishedLatch)); // will execute after the first HIGH (fifo), +        awaitingLatch.countDown();, +        finishedLatch.await();, +, +        assertThat(results.size(), equalTo(7));, +        assertThat(results.get(0), equalTo(0));, +        assertThat(results.get(1), equalTo(1));, +        assertThat(results.get(2), equalTo(2));, +        assertThat(results.get(3), equalTo(3));, +        assertThat(results.get(4), equalTo(4));, +        assertThat(results.get(5), equalTo(5));, +        assertThat(results.get(6), equalTo(6));, +    }, +]