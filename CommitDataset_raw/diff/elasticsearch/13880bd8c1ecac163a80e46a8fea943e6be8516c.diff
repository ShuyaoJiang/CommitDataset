[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.index.shard.ShardId;, +import java.util.Comparator;, +import java.util.Set;, +    private final AtomicReference<List<ShardRouting>> previousShardRoutings = new AtomicReference<>(Collections.emptyList());, +        // also check if non local shards have changed, as loosing a shard on a, +        // remote node or adding a replica on a remote node needs to trigger a reload too, +        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet());, +        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED);, +        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING));, +        List<ShardRouting> localAffectedShardRoutings = allShards.stream(), +            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId())), +            // shardrouting is not comparable, so we need some order mechanism, +            .sorted(Comparator.comparing(ShardRouting::hashCode)), +        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {, +                previousShardRoutings.set(localAffectedShardRoutings);, +        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList());, +        return previousIds.isEmpty() == false;, +    List<ShardRouting> shardRoutings() {, +        return previousShardRoutings.get();, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.index.shard.ShardId;, +import java.util.Comparator;, +import java.util.Set;, +    private final AtomicReference<List<ShardRouting>> previousShardRoutings = new AtomicReference<>(Collections.emptyList());, +        // also check if non local shards have changed, as loosing a shard on a, +        // remote node or adding a replica on a remote node needs to trigger a reload too, +        Set<ShardId> localShardIds = localShards.stream().map(ShardRouting::shardId).collect(Collectors.toSet());, +        List<ShardRouting> allShards = event.state().routingTable().index(watchIndex).shardsWithState(STARTED);, +        allShards.addAll(event.state().routingTable().index(watchIndex).shardsWithState(RELOCATING));, +        List<ShardRouting> localAffectedShardRoutings = allShards.stream(), +            .filter(shardRouting -> localShardIds.contains(shardRouting.shardId())), +            // shardrouting is not comparable, so we need some order mechanism, +            .sorted(Comparator.comparing(ShardRouting::hashCode)), +        if (previousShardRoutings.get().equals(localAffectedShardRoutings) == false) {, +                previousShardRoutings.set(localAffectedShardRoutings);, +        List<ShardRouting> previousIds = previousShardRoutings.getAndSet(Collections.emptyList());, +        return previousIds.isEmpty() == false;, +    List<ShardRouting> shardRoutings() {, +        return previousShardRoutings.get();, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleServiceTests.java, +        ShardRouting firstShardOnSecondNode = TestShardRouting.newShardRouting(shardId, "node_2", true, STARTED);, +        ShardRouting secondShardOnFirstNode = TestShardRouting.newShardRouting(secondShardId, "node_1", true, STARTED);, +, +            .addShard(secondShardOnFirstNode), +            .addShard(firstShardOnSecondNode), +        // add a replica in the local node, +        boolean addShardOnLocalNode = randomBoolean();, +        final ShardRouting addedShardRouting;, +        if (addShardOnLocalNode) {, +            addedShardRouting = TestShardRouting.newShardRouting(shardId, "node_1", false, STARTED);, +        } else {, +            addedShardRouting = TestShardRouting.newShardRouting(secondShardId, "node_2", false, STARTED);, +        }, +, +            .addShard(secondShardOnFirstNode), +            .addShard(firstShardOnSecondNode), +            .addShard(addedShardRouting), +    // this emulates a node outage somewhere in the cluster that carried a watcher shard, +    // the number of shards remains the same, but we need to ensure that watcher properly reloads, +    // previously we only checked the local shard allocations, but we also need to check if shards in the cluster have changed, +    public void testWatcherReloadsOnNodeOutageWithWatcherShard() {, +        Index watchIndex = new Index(Watch.INDEX, "foo");, +        ShardId shardId = new ShardId(watchIndex, 0);, +        String localNodeId = randomFrom("node_1", "node_2");, +        String outageNodeId = localNodeId.equals("node_1") ? "node_2" : "node_1";, +        DiscoveryNodes previousDiscoveryNodes = new DiscoveryNodes.Builder().masterNodeId(localNodeId).localNodeId(localNodeId), +            .add(newNode(localNodeId)), +            .add(newNode(outageNodeId)), +            .build();, +, +        ShardRouting replicaShardRouting = TestShardRouting.newShardRouting(shardId, localNodeId, false, STARTED);, +        ShardRouting primartShardRouting = TestShardRouting.newShardRouting(shardId, outageNodeId, true, STARTED);, +        IndexRoutingTable previousWatchRoutingTable = IndexRoutingTable.builder(watchIndex), +            .addShard(replicaShardRouting), +            .addShard(primartShardRouting), +            .build();, +, +        IndexMetaData indexMetaData = IndexMetaData.builder(Watch.INDEX), +            .settings(Settings.builder(), +                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0), +                .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +                .put(IndexMetaData.INDEX_FORMAT_SETTING.getKey(), 6), +            ).build();, +, +        ClusterState previousState = ClusterState.builder(new ClusterName("my-cluster")), +            .nodes(previousDiscoveryNodes), +            .routingTable(RoutingTable.builder().add(previousWatchRoutingTable).build()), +            .metaData(MetaData.builder().put(indexMetaData, false)), +            .build();, +, +        ShardRouting nowPrimaryShardRouting = replicaShardRouting.moveActiveReplicaToPrimary();, +        IndexRoutingTable currentWatchRoutingTable = IndexRoutingTable.builder(watchIndex), +            .addShard(nowPrimaryShardRouting), +            .build();, +, +        DiscoveryNodes currentDiscoveryNodes = new DiscoveryNodes.Builder().masterNodeId(localNodeId).localNodeId(localNodeId), +            .add(newNode(localNodeId)), +            .build();]