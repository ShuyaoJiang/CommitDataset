[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationDecider.java, + * {@link #CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} and the per index setting {@link #INDEX_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link #INDEX_ROUTING_REBALANCE_ENABLE_SETTING}., +    public static final Setting<Allocation> INDEX_ROUTING_ALLOCATION_ENABLE_SETTING = new Setting<>("index.routing.allocation.enable", Allocation.ALL.name(), Allocation::parse, true, Setting.Scope.INDEX);, +    public static final Setting<Rebalance> INDEX_ROUTING_REBALANCE_ENABLE_SETTING = new Setting<>("index.routing.rebalance.enable", Rebalance.ALL.name(), Rebalance::parse, true, Setting.Scope.INDEX);, +        final IndexMetaData indexMetaData = allocation.metaData().index(shardRouting.getIndex());, +        if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {, +            enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings());, +        if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {, +            enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings);, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationDecider.java, + * {@link #CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} and the per index setting {@link #INDEX_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link #INDEX_ROUTING_REBALANCE_ENABLE_SETTING}., +    public static final Setting<Allocation> INDEX_ROUTING_ALLOCATION_ENABLE_SETTING = new Setting<>("index.routing.allocation.enable", Allocation.ALL.name(), Allocation::parse, true, Setting.Scope.INDEX);, +    public static final Setting<Rebalance> INDEX_ROUTING_REBALANCE_ENABLE_SETTING = new Setting<>("index.routing.rebalance.enable", Rebalance.ALL.name(), Rebalance::parse, true, Setting.Scope.INDEX);, +        final IndexMetaData indexMetaData = allocation.metaData().index(shardRouting.getIndex());, +        if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {, +            enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings());, +        if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {, +            enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings);, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +        UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationDecider.java, + * {@link #CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} and the per index setting {@link #INDEX_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link #INDEX_ROUTING_REBALANCE_ENABLE_SETTING}., +    public static final Setting<Allocation> INDEX_ROUTING_ALLOCATION_ENABLE_SETTING = new Setting<>("index.routing.allocation.enable", Allocation.ALL.name(), Allocation::parse, true, Setting.Scope.INDEX);, +    public static final Setting<Rebalance> INDEX_ROUTING_REBALANCE_ENABLE_SETTING = new Setting<>("index.routing.rebalance.enable", Rebalance.ALL.name(), Rebalance::parse, true, Setting.Scope.INDEX);, +        final IndexMetaData indexMetaData = allocation.metaData().index(shardRouting.getIndex());, +        if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {, +            enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings());, +        if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {, +            enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings);, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +        UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterInfoServiceIT.java, +                .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE).build()));, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationDecider.java, + * {@link #CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} and the per index setting {@link #INDEX_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link #INDEX_ROUTING_REBALANCE_ENABLE_SETTING}., +    public static final Setting<Allocation> INDEX_ROUTING_ALLOCATION_ENABLE_SETTING = new Setting<>("index.routing.allocation.enable", Allocation.ALL.name(), Allocation::parse, true, Setting.Scope.INDEX);, +    public static final Setting<Rebalance> INDEX_ROUTING_REBALANCE_ENABLE_SETTING = new Setting<>("index.routing.rebalance.enable", Rebalance.ALL.name(), Rebalance::parse, true, Setting.Scope.INDEX);, +        final IndexMetaData indexMetaData = allocation.metaData().index(shardRouting.getIndex());, +        if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {, +            enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings());, +        if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {, +            enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings);, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +        UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterInfoServiceIT.java, +                .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE).build()));, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterModuleTests.java, +            module.registerIndexDynamicSetting(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), Validator.EMPTY);, +            assertEquals(e.getMessage(), "Cannot register setting [" + EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey() + "] twice");, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.unassigned.node_left.delayed_timeout"));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/EnableAllocationDecider.java, + * {@link #CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} and the per index setting {@link #INDEX_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link #INDEX_ROUTING_REBALANCE_ENABLE_SETTING}., +    public static final Setting<Allocation> INDEX_ROUTING_ALLOCATION_ENABLE_SETTING = new Setting<>("index.routing.allocation.enable", Allocation.ALL.name(), Allocation::parse, true, Setting.Scope.INDEX);, +    public static final Setting<Rebalance> INDEX_ROUTING_REBALANCE_ENABLE_SETTING = new Setting<>("index.routing.rebalance.enable", Rebalance.ALL.name(), Rebalance::parse, true, Setting.Scope.INDEX);, +        final IndexMetaData indexMetaData = allocation.metaData().index(shardRouting.getIndex());, +        if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {, +            enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings());, +        if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {, +            enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings);, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}, +     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} / {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +        UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING,, +        EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING,]