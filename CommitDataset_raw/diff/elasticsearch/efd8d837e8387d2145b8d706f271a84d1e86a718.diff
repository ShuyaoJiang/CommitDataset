[+++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +        this.enabled = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING, this::setEnabled);, +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +        this.enabled = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING, this::setEnabled);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.allocation.AllocationService;, +     * that can be indexed into) is larger than 0., +     * See {@link AllocationService#updateMetaDataWithRoutingTable(MetaData, RoutingTable, RoutingTable)}., +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +        this.enabled = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING, this::setEnabled);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.allocation.AllocationService;, +     * that can be indexed into) is larger than 0., +     * See {@link AllocationService#updateMetaDataWithRoutingTable(MetaData, RoutingTable, RoutingTable)}., +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +                                    DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(),, +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +        this.enabled = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING, this::setEnabled);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.allocation.AllocationService;, +     * that can be indexed into) is larger than 0., +     * See {@link AllocationService#updateMetaDataWithRoutingTable(MetaData, RoutingTable, RoutingTable)}., +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +                                    DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(),, +++ /dev/null, +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +        this.enabled = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING, this::setEnabled);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.allocation.AllocationService;, +     * that can be indexed into) is larger than 0., +     * See {@link AllocationService#updateMetaDataWithRoutingTable(MetaData, RoutingTable, RoutingTable)}., +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;, +                                    DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(),, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                                        long expectedSize) {, +    public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize) {, +    public ShardRouting startShard(ESLogger logger, ShardRouting initializingShard) {, +    public void failShard(ESLogger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData) {, +                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData);, +                        reinitShadowPrimary(primarySwappedCandidate);, +         * @see UnassignedIterator#removeAndIgnore(AllocationStatus), +         * @return true iff the decision caused a change to the unassigned info, +        public boolean ignoreShard(ShardRouting shard, AllocationStatus allocationStatus) {, +            boolean changed = false;, +                    shard = shard.updateUnassignedInfo(newInfo);, +                    changed = true;, +            return changed;, +            public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize) {, +                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize);, +             * @return true iff the decision caused an update to the unassigned info, +            public boolean removeAndIgnore(AllocationStatus attempt) {, +                return ignoreShard(current, attempt);, +            public ShardRouting updateUnassignedInfo(UnassignedInfo unassignedInfo) {, +             * Unsupported operation, just there for the interface. Use {@link #removeAndIgnore(AllocationStatus)} or, +             * {@link #initialize(String, String, long)}., +         * @see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus), +         * @see UnassignedIterator#removeAndIgnore(AllocationStatus), +++ b/benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java, +        public boolean allocateUnassigned(RoutingAllocation allocation) {, +            return false;]