[+++ b/build.gradle, +++ b/build.gradle, +++ b/core/src/main/java/org/elasticsearch/index/store/IndexStoreConfig.java, +        this.rateLimitingThrottle = settings.getAsBytesSize("indices.store.throttle.max_bytes_per_sec", new ByteSizeValue(0));, +++ b/build.gradle, +++ b/core/src/main/java/org/elasticsearch/index/store/IndexStoreConfig.java, +        this.rateLimitingThrottle = settings.getAsBytesSize("indices.store.throttle.max_bytes_per_sec", new ByteSizeValue(0));, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +, +        Checkpoint that = (Checkpoint) o;, +, +        if (offset != that.offset) return false;, +        if (numOps != that.numOps) return false;, +        return generation == that.generation;, +, +    }, +, +    @Override, +    public int hashCode() {, +        int result = Long.hashCode(offset);, +        result = 31 * result + numOps;, +        result = 31 * result + Long.hashCode(generation);, +        return result;, +    }, +++ b/build.gradle, +++ b/core/src/main/java/org/elasticsearch/index/store/IndexStoreConfig.java, +        this.rateLimitingThrottle = settings.getAsBytesSize("indices.store.throttle.max_bytes_per_sec", new ByteSizeValue(0));, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +, +        Checkpoint that = (Checkpoint) o;, +, +        if (offset != that.offset) return false;, +        if (numOps != that.numOps) return false;, +        return generation == that.generation;, +, +    }, +, +    @Override, +    public int hashCode() {, +        int result = Long.hashCode(offset);, +        result = 31 * result + numOps;, +        result = 31 * result + Long.hashCode(generation);, +        return result;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private final ArrayList<ImmutableTranslogReader> recoverFromFiles(TranslogGeneration translogGeneration, Checkpoint checkpoint) throws IOException {, +        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX); // a temp file to copy checkpoint to - note it must be in on the same FS otherwise atomic move won't work, +            if (Files.exists(commitCheckpoint)) {, +                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint);, +                if (checkpoint.equals(checkpointFromDisk) == false) {, +                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk);, +                }, +            } else {, +                // we first copy this into the temp-file and then fsync it followed by an atomic move into the target file, +                // that way if we hit a disk-full here we are still in an consistent state., +                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING);, +                IOUtils.fsync(tempFile, false);, +                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE);, +                // we only fsync the directory the tempFile was already fsynced, +            }, +            try {, +                Files.delete(tempFile);, +            } catch (IOException ex) {, +                logger.warn("failed to delete temp file {}", ex, tempFile);, +            }, +++ b/build.gradle, +++ b/core/src/main/java/org/elasticsearch/index/store/IndexStoreConfig.java, +        this.rateLimitingThrottle = settings.getAsBytesSize("indices.store.throttle.max_bytes_per_sec", new ByteSizeValue(0));, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +, +        Checkpoint that = (Checkpoint) o;, +, +        if (offset != that.offset) return false;, +        if (numOps != that.numOps) return false;, +        return generation == that.generation;, +, +    }, +, +    @Override, +    public int hashCode() {, +        int result = Long.hashCode(offset);, +        result = 31 * result + numOps;, +        result = 31 * result + Long.hashCode(generation);, +        return result;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private final ArrayList<ImmutableTranslogReader> recoverFromFiles(TranslogGeneration translogGeneration, Checkpoint checkpoint) throws IOException {, +        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX); // a temp file to copy checkpoint to - note it must be in on the same FS otherwise atomic move won't work]