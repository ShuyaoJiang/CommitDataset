[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                        aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                        aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null),, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            () -> newQueryShardContext(0, null, System::currentTimeMillis, null));, +    public QueryShardContext newQueryShardContext(int shardId, IndexReader indexReader, LongSupplier nowInMillis, String clusterAlias) {, +        return new QueryShardContext(shardId, indexSettings, indexCache.bitsetFilterCache(), indexFieldData::getForField, mapperService(),, +            similarityService(), scriptService, xContentRegistry, client, indexReader, nowInMillis, clusterAlias);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                        aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null),, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            () -> newQueryShardContext(0, null, System::currentTimeMillis, null));, +    public QueryShardContext newQueryShardContext(int shardId, IndexReader indexReader, LongSupplier nowInMillis, String clusterAlias) {, +        return new QueryShardContext(shardId, indexSettings, indexCache.bitsetFilterCache(), indexFieldData::getForField, mapperService(),, +            similarityService(), scriptService, xContentRegistry, client, indexReader, nowInMillis, clusterAlias);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/ConstantIndexFieldData.java, +, +    private final ConstantAtomicFieldData atomicFieldData;, +    public String getValue() {, +        return atomicFieldData.value;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                        aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null),, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            () -> newQueryShardContext(0, null, System::currentTimeMillis, null));, +    public QueryShardContext newQueryShardContext(int shardId, IndexReader indexReader, LongSupplier nowInMillis, String clusterAlias) {, +        return new QueryShardContext(shardId, indexSettings, indexCache.bitsetFilterCache(), indexFieldData::getForField, mapperService(),, +            similarityService(), scriptService, xContentRegistry, client, indexReader, nowInMillis, clusterAlias);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/ConstantIndexFieldData.java, +, +    private final ConstantAtomicFieldData atomicFieldData;, +    public String getValue() {, +        return atomicFieldData.value;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java, +            if (isSameIndex(value, context.getFullyQualifiedIndexName())) {, +                if (isSameIndex(value, context.getFullyQualifiedIndexName())) {, +            return Queries.newMatchNoDocsQuery("Index didn't match. Index queried: " + context.getFullyQualifiedIndexName(), +                + " vs. " + values);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            final QueryShardContext queryShardContext = indexService.newQueryShardContext(0, null, () -> 0L, null);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                        aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null),, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            () -> newQueryShardContext(0, null, System::currentTimeMillis, null));, +    public QueryShardContext newQueryShardContext(int shardId, IndexReader indexReader, LongSupplier nowInMillis, String clusterAlias) {, +        return new QueryShardContext(shardId, indexSettings, indexCache.bitsetFilterCache(), indexFieldData::getForField, mapperService(),, +            similarityService(), scriptService, xContentRegistry, client, indexReader, nowInMillis, clusterAlias);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/ConstantIndexFieldData.java, +, +    private final ConstantAtomicFieldData atomicFieldData;, +    public String getValue() {, +        return atomicFieldData.value;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java, +            if (isSameIndex(value, context.getFullyQualifiedIndexName())) {, +                if (isSameIndex(value, context.getFullyQualifiedIndexName())) {, +            return Queries.newMatchNoDocsQuery("Index didn't match. Index queried: " + context.getFullyQualifiedIndexName(), +                + " vs. " + values);, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryShardContext.java, +import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;, +import org.elasticsearch.index.mapper.IndexFieldMapper;, +import org.elasticsearch.index.mapper.MetadataFieldMapper;, +import org.elasticsearch.transport.RemoteClusterAware;, +import java.util.function.Function;, +    private final Function<MappedFieldType, IndexFieldData<?>> indexFieldDataService;, +    private final String clusterAlias;, +    private final String fullyQualifiedIndexName;, +                             Function<MappedFieldType, IndexFieldData<?>> indexFieldDataLookup, MapperService mapperService,, +                             SimilarityService similarityService, ScriptService scriptService, NamedXContentRegistry xContentRegistry,, +                             Client client, IndexReader reader, LongSupplier nowInMillis, String clusterAlias) {, +        this.indexFieldDataService = indexFieldDataLookup;, +        this.clusterAlias = clusterAlias;, +        this.fullyQualifiedIndexName = RemoteClusterAware.buildRemoteIndexName(clusterAlias, indexSettings.getIndex().getName());, +                source.reader, source.nowInMillis, source.clusterAlias);, +    public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {, +        if (clusterAlias != null && IndexFieldMapper.NAME.equals(fieldType.name())) {, +            // this is a "hack" to make the _index field data aware of cross cluster search cluster aliases., +            ConstantIndexFieldData ifd = (ConstantIndexFieldData) indexFieldDataService.apply(fieldType);, +            return (IFD) new ConstantIndexFieldData.Builder(m -> fullyQualifiedIndexName), +                .build(indexSettings, fieldType, null, null, mapperService);, +        }, +        return (IFD) indexFieldDataService.apply(fieldType);, +    /**, +     * Returns the fully qualified index name including a remote cluster alias if applicable, +     */]