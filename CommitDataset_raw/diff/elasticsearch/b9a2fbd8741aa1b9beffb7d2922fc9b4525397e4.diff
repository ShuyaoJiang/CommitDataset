[+++ b/src/main/java/org/apache/lucene/analysis/CustomAnalyzerWrapper.java, + * Similar to Lucene {@link AnalyzerWrapper} but actually allows to set the reuse strategy...., + * //TODO add to lucene the ability to set it..., +    protected CustomAnalyzerWrapper(ReuseStrategy reuseStrategy) {, +        super(reuseStrategy);, +++ b/src/main/java/org/apache/lucene/analysis/CustomAnalyzerWrapper.java, + * Similar to Lucene {@link AnalyzerWrapper} but actually allows to set the reuse strategy...., + * //TODO add to lucene the ability to set it..., +    protected CustomAnalyzerWrapper(ReuseStrategy reuseStrategy) {, +        super(reuseStrategy);, +++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            NamedAnalyzer analyzer;, +            // if we got a named analyzer back, use it..., +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = (NamedAnalyzer) analyzerF;, +            } else {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +            }, +++ b/src/main/java/org/apache/lucene/analysis/CustomAnalyzerWrapper.java, + * Similar to Lucene {@link AnalyzerWrapper} but actually allows to set the reuse strategy...., + * //TODO add to lucene the ability to set it..., +    protected CustomAnalyzerWrapper(ReuseStrategy reuseStrategy) {, +        super(reuseStrategy);, +++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            NamedAnalyzer analyzer;, +            // if we got a named analyzer back, use it..., +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = (NamedAnalyzer) analyzerF;, +            } else {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +            }, +++ b/src/main/java/org/elasticsearch/index/analysis/NamedAnalyzer.java, +import org.apache.lucene.analysis.AnalyzerWrapper;, +    private final int positionOffsetGap;, +, +    public NamedAnalyzer(NamedAnalyzer analyzer, int positionOffsetGap) {, +        this(analyzer.name(), analyzer.scope(), analyzer.analyzer(), positionOffsetGap);, +    }, +        this(name, scope, analyzer, Integer.MIN_VALUE);, +    }, +, +    public NamedAnalyzer(String name, AnalyzerScope scope, Analyzer analyzer, int positionOffsetGap) {, +        // our named analyzer always wrap a non per field analyzer, so no need to have per field analyzer, +        super(new GlobalReuseStrategy());, +        // TODO would be nice to pick the reuse start based on the analyzer..., +        assert !(analyzer instanceof AnalyzerWrapper); // this is the only one in Lucene currently that uses PerFieldStrategy, make sure we don't wrap it, +        this.positionOffsetGap = positionOffsetGap;, +    public int getPositionIncrementGap(String fieldName) {, +        if (positionOffsetGap != Integer.MIN_VALUE) {, +            return positionOffsetGap;, +        }, +        return super.getPositionIncrementGap(fieldName);, +    }, +, +    @Override, +++ b/src/main/java/org/apache/lucene/analysis/CustomAnalyzerWrapper.java, + * Similar to Lucene {@link AnalyzerWrapper} but actually allows to set the reuse strategy...., + * //TODO add to lucene the ability to set it..., +    protected CustomAnalyzerWrapper(ReuseStrategy reuseStrategy) {, +        super(reuseStrategy);, +++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            NamedAnalyzer analyzer;, +            // if we got a named analyzer back, use it..., +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = (NamedAnalyzer) analyzerF;, +            } else {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +            }, +++ b/src/main/java/org/elasticsearch/index/analysis/NamedAnalyzer.java, +import org.apache.lucene.analysis.AnalyzerWrapper;, +    private final int positionOffsetGap;, +, +    public NamedAnalyzer(NamedAnalyzer analyzer, int positionOffsetGap) {, +        this(analyzer.name(), analyzer.scope(), analyzer.analyzer(), positionOffsetGap);, +    }, +        this(name, scope, analyzer, Integer.MIN_VALUE);, +    }, +, +    public NamedAnalyzer(String name, AnalyzerScope scope, Analyzer analyzer, int positionOffsetGap) {, +        // our named analyzer always wrap a non per field analyzer, so no need to have per field analyzer, +        super(new GlobalReuseStrategy());, +        // TODO would be nice to pick the reuse start based on the analyzer..., +        assert !(analyzer instanceof AnalyzerWrapper); // this is the only one in Lucene currently that uses PerFieldStrategy, make sure we don't wrap it, +        this.positionOffsetGap = positionOffsetGap;, +    public int getPositionIncrementGap(String fieldName) {, +        if (positionOffsetGap != Integer.MIN_VALUE) {, +            return positionOffsetGap;, +        }, +        return super.getPositionIncrementGap(fieldName);, +    }, +, +    @Override, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/analysis/CustomAnalyzerWrapper.java, + * Similar to Lucene {@link AnalyzerWrapper} but actually allows to set the reuse strategy...., + * //TODO add to lucene the ability to set it..., +    protected CustomAnalyzerWrapper(ReuseStrategy reuseStrategy) {, +        super(reuseStrategy);, +++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            NamedAnalyzer analyzer;]