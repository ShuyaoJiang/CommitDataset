[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs recovery from the transaction log up to {@code recoverUpToSeqNo} (inclusive)., +     *, +     * @param recoverUpToSeqNo the upper bound, inclusive, of sequence number to be recovered, +    public abstract Engine recoverFromTranslog(long recoverUpToSeqNo) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs recovery from the transaction log up to {@code recoverUpToSeqNo} (inclusive)., +     *, +     * @param recoverUpToSeqNo the upper bound, inclusive, of sequence number to be recovered, +    public abstract Engine recoverFromTranslog(long recoverUpToSeqNo) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public InternalEngine recoverFromTranslog(long recoverUpToSeqNo) throws IOException {, +                recoverFromTranslogInternal(recoverUpToSeqNo);, +    private void recoverFromTranslogInternal(long recoverUpToSeqNo) throws IOException {, +        final long translogFileGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +        try (Translog.Snapshot snapshot = translog.newSnapshotFromGen(, +            new Translog.TranslogGeneration(translog.getTranslogUUID(), translogFileGen), recoverUpToSeqNo)) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs recovery from the transaction log up to {@code recoverUpToSeqNo} (inclusive)., +     *, +     * @param recoverUpToSeqNo the upper bound, inclusive, of sequence number to be recovered, +    public abstract Engine recoverFromTranslog(long recoverUpToSeqNo) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public InternalEngine recoverFromTranslog(long recoverUpToSeqNo) throws IOException {, +                recoverFromTranslogInternal(recoverUpToSeqNo);, +    private void recoverFromTranslogInternal(long recoverUpToSeqNo) throws IOException {, +        final long translogFileGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +        try (Translog.Snapshot snapshot = translog.newSnapshotFromGen(, +            new Translog.TranslogGeneration(translog.getTranslogUUID(), translogFileGen), recoverUpToSeqNo)) {, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        getEngine().recoverFromTranslog(Long.MAX_VALUE);, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs recovery from the transaction log up to {@code recoverUpToSeqNo} (inclusive)., +     *, +     * @param recoverUpToSeqNo the upper bound, inclusive, of sequence number to be recovered, +    public abstract Engine recoverFromTranslog(long recoverUpToSeqNo) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public InternalEngine recoverFromTranslog(long recoverUpToSeqNo) throws IOException {, +                recoverFromTranslogInternal(recoverUpToSeqNo);, +    private void recoverFromTranslogInternal(long recoverUpToSeqNo) throws IOException {, +        final long translogFileGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +        try (Translog.Snapshot snapshot = translog.newSnapshotFromGen(, +            new Translog.TranslogGeneration(translog.getTranslogUUID(), translogFileGen), recoverUpToSeqNo)) {, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        getEngine().recoverFromTranslog(Long.MAX_VALUE);, +++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE);, +    public Snapshot newSnapshotFromGen(TranslogGeneration fromGeneration, long upToSeqNo) throws IOException {, +            final long fromFileGen = fromGeneration.translogFileGeneration;, +            if (fromFileGen < getMinFileGeneration()) {, +                throw new IllegalArgumentException("requested snapshot generation [" + fromFileGen + "] is not available. " +, +                .filter(reader -> reader.getGeneration() >= fromFileGen && reader.getCheckpoint().minSeqNo <= upToSeqNo), +            final Snapshot snapshot = newMultiSnapshot(snapshots);, +            if (upToSeqNo == Long.MAX_VALUE) {, +                return snapshot;, +            } else {, +                return new SeqNoFilterSnapshot(snapshot, Long.MIN_VALUE, upToSeqNo);, +            }, +    }, +    /**, +     * A filtered snapshot consisting of only operations whose sequence numbers are in the given range, +     * between {@code fromSeqNo} (inclusive) and {@code toSeqNo} (inclusive). This filtered snapshot, +     * shares the same underlying resources with the {@code delegate} snapshot, therefore we should not, +     * use the {@code delegate} after passing it to this filtered snapshot., +     */, +    static final class SeqNoFilterSnapshot implements Snapshot {, +        private final Snapshot delegate;, +        private int filteredOpsCount;, +        private final long fromSeqNo; // inclusive, +        private final long toSeqNo;   // inclusive, +, +        SeqNoFilterSnapshot(Snapshot delegate, long fromSeqNo, long toSeqNo) {, +            assert fromSeqNo <= toSeqNo : "from_seq_no[" + fromSeqNo + "] > to_seq_no[" + toSeqNo + "]";, +            this.delegate = delegate;, +            this.fromSeqNo = fromSeqNo;, +            this.toSeqNo = toSeqNo;, +        }, +, +        @Override, +        public int totalOperations() {, +            return delegate.totalOperations();, +        }, +, +        @Override, +        public int skippedOperations() {, +            return filteredOpsCount + delegate.skippedOperations();, +        }, +, +        @Override, +        public int overriddenOperations() {, +            return delegate.overriddenOperations();, +        }, +, +        @Override, +        public Operation next() throws IOException {, +            Translog.Operation op;, +            while ((op = delegate.next()) != null) {, +                if (fromSeqNo <= op.seqNo() && op.seqNo() <= toSeqNo) {, +                    return op;, +                } else {]