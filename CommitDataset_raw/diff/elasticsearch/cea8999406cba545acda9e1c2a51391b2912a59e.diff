[+++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +                if (indices.containsKey(indexName)) {, +                    String localUUid = indices.get(indexName).v1().indexUUID();, +                    throw new ElasticsearchIllegalStateException("Can't delete index store for [" + indexName + "] - it's still part of the indices service [" + localUUid+ "] [" + metaData.getUUID() + "]");, +                if (clusterState.metaData().hasIndex(indexName) && (clusterState.nodes().localNode().masterNode() == true)) {, +                    // we do not delete the store if it is a master eligible node and the index is still in the cluster state, +                    // because we want to keep the meta data for indices around even if no shards are left here, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +                if (indices.containsKey(indexName)) {, +                    String localUUid = indices.get(indexName).v1().indexUUID();, +                    throw new ElasticsearchIllegalStateException("Can't delete index store for [" + indexName + "] - it's still part of the indices service [" + localUUid+ "] [" + metaData.getUUID() + "]");, +                if (clusterState.metaData().hasIndex(indexName) && (clusterState.nodes().localNode().masterNode() == true)) {, +                    // we do not delete the store if it is a master eligible node and the index is still in the cluster state, +                    // because we want to keep the meta data for indices around even if no shards are left here, +++ b/src/main/java/org/elasticsearch/indices/store/IndicesStore.java, +                    } catch (Throwable ex) {, +                    // if the index doesn't exists anymore, delete its store as well, but only if its a non master node, since master, +                    // nodes keep the index metadata around , +                    if (indicesService.hasIndex(shardId.getIndex()) == false && currentState.nodes().localNode().masterNode() == false) {, +                        try {, +                            indicesService.deleteIndexStore("no longer used", indexMeta);, +                        } catch (Throwable ex) {, +                            logger.debug("{} failed to delete unallocated index, ignoring", ex, shardId.getIndex());, +                        }, +                    }, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +                if (indices.containsKey(indexName)) {, +                    String localUUid = indices.get(indexName).v1().indexUUID();, +                    throw new ElasticsearchIllegalStateException("Can't delete index store for [" + indexName + "] - it's still part of the indices service [" + localUUid+ "] [" + metaData.getUUID() + "]");, +                if (clusterState.metaData().hasIndex(indexName) && (clusterState.nodes().localNode().masterNode() == true)) {, +                    // we do not delete the store if it is a master eligible node and the index is still in the cluster state, +                    // because we want to keep the meta data for indices around even if no shards are left here, +++ b/src/main/java/org/elasticsearch/indices/store/IndicesStore.java, +                    } catch (Throwable ex) {, +                    // if the index doesn't exists anymore, delete its store as well, but only if its a non master node, since master, +                    // nodes keep the index metadata around , +                    if (indicesService.hasIndex(shardId.getIndex()) == false && currentState.nodes().localNode().masterNode() == false) {, +                        try {, +                            indicesService.deleteIndexStore("no longer used", indexMeta);, +                        } catch (Throwable ex) {, +                            logger.debug("{} failed to delete unallocated index, ignoring", ex, shardId.getIndex());, +                        }, +                    }, +++ b/src/test/java/org/elasticsearch/indices/store/IndicesStoreIntegrationTests.java, +import org.elasticsearch.cluster.routing.allocation.command.MoveAllocationCommand;, +import org.elasticsearch.index.Index;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +    public void indexCleanup() throws Exception {, +        final String masterNode = internalCluster().startNode(ImmutableSettings.builder().put("node.data", false));, +        final String node_1 = internalCluster().startNode(ImmutableSettings.builder().put("node.master", false));, +        final String node_2 = internalCluster().startNode(ImmutableSettings.builder().put("node.master", false));, +        logger.info("--> creating index [test] with one shard and on replica");, +        assertAcked(prepareCreate("test").setSettings(, +                        ImmutableSettings.builder().put(indexSettings()), +                                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)), +        );, +        ensureGreen("test");, +, +        logger.info("--> making sure that shard and its replica are allocated on node_1 and node_2");, +        assertThat(Files.exists(shardDirectory(node_1, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_1, "test")), equalTo(true));, +        assertThat(Files.exists(shardDirectory(node_2, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_2, "test")), equalTo(true));, +, +        logger.info("--> starting node server3");, +        final String node_3 = internalCluster().startNode(ImmutableSettings.builder().put("node.master", false));, +        logger.info("--> running cluster_health");, +        ClusterHealthResponse clusterHealth = client().admin().cluster().prepareHealth(), +                .setWaitForNodes("4"), +                .setWaitForRelocatingShards(0), +                .get();, +        assertThat(clusterHealth.isTimedOut(), equalTo(false));, +, +        assertThat(Files.exists(shardDirectory(node_1, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_1, "test")), equalTo(true));, +        assertThat(Files.exists(shardDirectory(node_2, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_2, "test")), equalTo(true));, +        assertThat(Files.exists(shardDirectory(node_3, "test", 0)), equalTo(false));, +        assertThat(Files.exists(indexDirectory(node_3, "test")), equalTo(false));, +, +        logger.info("--> move shard from node_1 to node_3, and wait for relocation to finish");, +        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(new ShardId("test", 0), node_1, node_3)).get();, +        clusterHealth = client().admin().cluster().prepareHealth(), +                .setWaitForNodes("4"), +                .setWaitForRelocatingShards(0), +                .get();, +        assertThat(clusterHealth.isTimedOut(), equalTo(false));, +, +        assertThat(waitForShardDeletion(node_1, "test", 0), equalTo(false));, +        assertThat(waitForIndexDeletion(node_1, "test"), equalTo(false));, +        assertThat(Files.exists(shardDirectory(node_2, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_2, "test")), equalTo(true));, +        assertThat(Files.exists(shardDirectory(node_3, "test", 0)), equalTo(true));, +        assertThat(Files.exists(indexDirectory(node_3, "test")), equalTo(true));, +    }, +, +    @Test, +        boolean node1IsMasterEligible = randomBoolean();]