[+++ b/core/src/main/java/org/elasticsearch/bootstrap/JNACLibrary.java, +import com.sun.jna.NativeLong;, +        public NativeLong rlim_cur = new NativeLong(0);, +        public NativeLong rlim_max = new NativeLong(0);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNACLibrary.java, +import com.sun.jna.NativeLong;, +        public NativeLong rlim_cur = new NativeLong(0);, +        public NativeLong rlim_max = new NativeLong(0);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                    softLimit = rlimit.rlim_cur.longValue();, +                    hardLimit = rlimit.rlim_max.longValue();, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNACLibrary.java, +import com.sun.jna.NativeLong;, +        public NativeLong rlim_cur = new NativeLong(0);, +        public NativeLong rlim_max = new NativeLong(0);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                    softLimit = rlimit.rlim_cur.longValue();, +                    hardLimit = rlimit.rlim_max.longValue();, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Seccomp.java, +import com.sun.jna.NativeLong;, +import java.util.HashMap;, +import java.util.Map;, + * On Linux it currently supports amd64 and i386 architectures, requires Linux kernel 3.5 or above, and requires, +        int prctl(int option, NativeLong arg2, NativeLong arg3, NativeLong arg4, NativeLong arg5);, +        NativeLong syscall(NativeLong number, Object... args);, +    // offsets that our BPF checks, +    // check with offsetof() when adding a new arch, move to Arch if different., +    static class Arch {, +        /** AUDIT_ARCH_XXX constant from linux/audit.h */, +        final int audit;, +        /** syscall limit (necessary for blacklisting on amd64, to ban 32-bit syscalls) */, +        final int limit;, +        /** __NR_fork */, +        final int fork;, +        /** __NR_vfork */, +        final int vfork;, +        /** __NR_execve */, +        final int execve;, +        /**  __NR_execveat */, +        final int execveat;, +        /** __NR_seccomp */, +        final int seccomp;, +, +        Arch(int audit, int limit, int fork, int vfork, int execve, int execveat, int seccomp) {, +            this.audit = audit;, +            this.limit = limit;, +            this.fork = fork;, +            this.vfork = vfork;, +            this.execve = execve;, +            this.execveat = execveat;, +            this.seccomp = seccomp;, +        }, +    }, +, +    /** supported architectures map keyed by os.arch */, +    private static final Map<String,Arch> ARCHITECTURES;, +    static {, +        Map<String,Arch> m = new HashMap<>();, +        m.put("amd64", new Arch(0xC000003E, 0x3FFFFFFF, 57, 58, 59, 322, 317));, +        m.put("i386",  new Arch(0x40000003, 0xFFFFFFFF, 2, 190, 11, 358, 354));, +        ARCHITECTURES = Collections.unmodifiableMap(m);, +    }, +, +    /** invokes prctl() from linux libc library */, +    private static int linux_prctl(int option, long arg2, long arg3, long arg4, long arg5) {, +        return linux_libc.prctl(option, new NativeLong(arg2), new NativeLong(arg3), new NativeLong(arg4), new NativeLong(arg5));, +    }, +, +    /** invokes syscall() from linux libc library */, +    private static long linux_syscall(long number, Object... args) {, +        return linux_libc.syscall(new NativeLong(number), args).longValue();, +    }, +        final Arch arch = ARCHITECTURES.get(Constants.OS_ARCH);, +        boolean supported = Constants.LINUX && arch != null;, +        if (linux_syscall(999) >= 0 || Native.getLastError() != ENOSYS) {, +        long ret = linux_syscall(arch.seccomp, bogusArg);, +        ret = linux_syscall(arch.seccomp, SECCOMP_SET_MODE_FILTER, bogusArg);, +        ret = linux_prctl(bogusArg, 0, 0, 0, 0);, +        switch (linux_prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0)) {, +        switch (linux_prctl(PR_GET_SECCOMP, 0, 0, 0, 0)) {, +        if (linux_prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, 0, 0, 0) != 0) {, +        if (linux_prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) != 0) {, +        if (linux_prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {, +        // BPF installed to check arch, limit, then syscall. See https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt for details., +          /* 2  */ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,   arch.audit,     0, 7),                 // if (arch != audit) goto fail;, +          /* 4  */ BPF_JUMP(BPF_JMP + BPF_JGT + BPF_K,   arch.limit,     5, 0),                 // if (syscall > LIMIT) goto fail;, +          /* 5  */ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,   arch.fork,      4, 0),                 // if (syscall == FORK) goto fail;, +          /* 6  */ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,   arch.vfork,     3, 0),                 // if (syscall == VFORK) goto fail;, +          /* 7  */ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,   arch.execve,    2, 0),                 // if (syscall == EXECVE) goto fail;, +          /* 8  */ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,   arch.execveat,  1, 0),                 // if (syscall == EXECVEAT) goto fail;, +          /* 9  */ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),                                // pass: return OK;, +          /* 10 */ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (EACCES & SECCOMP_RET_DATA)),  // fail: return EACCES;, +        if (linux_syscall(arch.seccomp, SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC, new NativeLong(pointer)) != 0) {, +            if (linux_prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, pointer, 0, 0) != 0) {, +        if (linux_prctl(PR_GET_SECCOMP, 0, 0, 0, 0) != 2) {, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNACLibrary.java, +import com.sun.jna.NativeLong;, +        public NativeLong rlim_cur = new NativeLong(0);, +        public NativeLong rlim_max = new NativeLong(0);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java]