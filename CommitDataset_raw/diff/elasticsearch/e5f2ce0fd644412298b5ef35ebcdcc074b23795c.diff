[+++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public float factor(int docId) {, +        return boost;, +    }, +, +    @Override, +    public Explanation explainScore(int docId, Explanation subQueryExpl) {, +    public Explanation explainFactor(int docId) {, +        return new Explanation(boost, "boostFactor");, +    }, +, +    @Override, +, +    @Override, +    public String toString() {, +        return "boost[" + boost + "]";, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public float factor(int docId) {, +        return boost;, +    }, +, +    @Override, +    public Explanation explainScore(int docId, Explanation subQueryExpl) {, +    public Explanation explainFactor(int docId) {, +        return new Explanation(boost, "boostFactor");, +    }, +, +    @Override, +, +    @Override, +    public String toString() {, +        return "boost[" + boost + "]";, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +                        Explanation functionExplanation = filterFunction.function.explainFactor(doc);, +                        Explanation functionExplanation = filterFunction.function.explainFactor(doc);, +                    res.addDetail(subQueryExpl);, +            float factor = 1.0f;, +                        factor = filterFunctions[i].function.factor(docId);, +                        break;, +                float maxFactor = Float.NEGATIVE_INFINITY;, +                        maxFactor = Math.max(filterFunctions[i].function.factor(docId), maxFactor);, +                if (maxFactor != Float.NEGATIVE_INFINITY) {, +                    factor = maxFactor;, +                float minFactor = Float.POSITIVE_INFINITY;, +                        minFactor = Math.min(filterFunctions[i].function.factor(docId), minFactor);, +                if (minFactor != Float.POSITIVE_INFINITY) {, +                    factor = minFactor;, +                }, +            } else if (scoreMode == ScoreMode.Multiply) {, +                for (int i = 0; i < filterFunctions.length; i++) {, +                    if (docSets[i].get(docId)) {, +                        factor *= filterFunctions[i].function.factor(docId);, +                    }, +                float totalFactor = 0.0f;, +                        totalFactor += filterFunctions[i].function.factor(docId);, +                    factor = totalFactor;, +                        factor /= count;, +            float score = scorer.score();, +            return subQueryWeight * score * factor;, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public float factor(int docId) {, +        return boost;, +    }, +, +    @Override, +    public Explanation explainScore(int docId, Explanation subQueryExpl) {, +    public Explanation explainFactor(int docId) {, +        return new Explanation(boost, "boostFactor");, +    }, +, +    @Override, +, +    @Override, +    public String toString() {, +        return "boost[" + boost + "]";, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +                        Explanation functionExplanation = filterFunction.function.explainFactor(doc);, +                        Explanation functionExplanation = filterFunction.function.explainFactor(doc);, +                    res.addDetail(subQueryExpl);, +            float factor = 1.0f;, +                        factor = filterFunctions[i].function.factor(docId);, +                        break;, +                float maxFactor = Float.NEGATIVE_INFINITY;, +                        maxFactor = Math.max(filterFunctions[i].function.factor(docId), maxFactor);, +                if (maxFactor != Float.NEGATIVE_INFINITY) {, +                    factor = maxFactor;, +                float minFactor = Float.POSITIVE_INFINITY;, +                        minFactor = Math.min(filterFunctions[i].function.factor(docId), minFactor);, +                if (minFactor != Float.POSITIVE_INFINITY) {, +                    factor = minFactor;, +                }, +            } else if (scoreMode == ScoreMode.Multiply) {, +                for (int i = 0; i < filterFunctions.length; i++) {, +                    if (docSets[i].get(docId)) {, +                        factor *= filterFunctions[i].function.factor(docId);, +                    }, +                float totalFactor = 0.0f;]