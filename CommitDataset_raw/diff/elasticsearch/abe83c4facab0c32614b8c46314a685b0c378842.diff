[+++ b/core/src/main/java/org/elasticsearch/search/DefaultSearchContext.java, +            if (sort != null) {, +                throw new QueryPhaseExecutionException(this, "Cannot use [sort] option in conjunction with [rescore].");, +            }, +++ b/core/src/main/java/org/elasticsearch/search/DefaultSearchContext.java, +            if (sort != null) {, +                throw new QueryPhaseExecutionException(this, "Cannot use [sort] option in conjunction with [rescore].");, +            }, +++ b/core/src/main/java/org/elasticsearch/search/query/TopDocsCollectorContext.java, +            if (rescore) {, +                assert searchContext.sort() == null;, +            }, +++ b/core/src/main/java/org/elasticsearch/search/DefaultSearchContext.java, +            if (sort != null) {, +                throw new QueryPhaseExecutionException(this, "Cannot use [sort] option in conjunction with [rescore].");, +            }, +++ b/core/src/main/java/org/elasticsearch/search/query/TopDocsCollectorContext.java, +            if (rescore) {, +                assert searchContext.sort() == null;, +            }, +++ b/core/src/main/java/org/elasticsearch/search/rescore/RescorePhase.java, +import org.apache.lucene.search.ScoreDoc;, +import org.apache.lucene.search.Sort;, +import org.apache.lucene.search.SortField;, +                // It is the responsibility of the rescorer to sort the resulted top docs,, +                // here we only assert that this condition is met., +                assert context.sort() == null && topDocsSortedByScore(topDocs): "topdocs should be sorted after rescore";, +, +    /**, +     * Returns true if the provided docs are sorted by score., +     */, +    private boolean topDocsSortedByScore(TopDocs topDocs) {, +        if (topDocs == null || topDocs.scoreDocs == null || topDocs.scoreDocs.length < 2) {, +            return true;, +        }, +        float lastScore = topDocs.scoreDocs[0].score;, +        for (int i = 1; i < topDocs.scoreDocs.length; i++) {, +            ScoreDoc doc = topDocs.scoreDocs[i];, +            if (Float.compare(doc.score, lastScore) > 0) {, +                return false;, +            }, +            lastScore = doc.score;, +        }, +        return true;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/DefaultSearchContext.java, +            if (sort != null) {, +                throw new QueryPhaseExecutionException(this, "Cannot use [sort] option in conjunction with [rescore].");, +            }, +++ b/core/src/main/java/org/elasticsearch/search/query/TopDocsCollectorContext.java, +            if (rescore) {, +                assert searchContext.sort() == null;, +            }, +++ b/core/src/main/java/org/elasticsearch/search/rescore/RescorePhase.java, +import org.apache.lucene.search.ScoreDoc;, +import org.apache.lucene.search.Sort;, +import org.apache.lucene.search.SortField;, +                // It is the responsibility of the rescorer to sort the resulted top docs,, +                // here we only assert that this condition is met., +                assert context.sort() == null && topDocsSortedByScore(topDocs): "topdocs should be sorted after rescore";, +, +    /**, +     * Returns true if the provided docs are sorted by score., +     */, +    private boolean topDocsSortedByScore(TopDocs topDocs) {, +        if (topDocs == null || topDocs.scoreDocs == null || topDocs.scoreDocs.length < 2) {, +            return true;, +        }, +        float lastScore = topDocs.scoreDocs[0].score;, +        for (int i = 1; i < topDocs.scoreDocs.length; i++) {, +            ScoreDoc doc = topDocs.scoreDocs[i];, +            if (Float.compare(doc.score, lastScore) > 0) {, +                return false;, +            }, +            lastScore = doc.score;, +        }, +        return true;, +    }, +++ b/core/src/test/java/org/elasticsearch/search/functionscore/QueryRescorerIT.java, +import org.elasticsearch.search.sort.SortBuilder;, +import org.elasticsearch.search.sort.SortBuilders;, +import org.elasticsearch.search.sort.SortOrder;, +import static org.hamcrest.Matchers.containsString;, +, +    public void testRescorePhaseWithInvalidSort() throws Exception {, +        assertAcked(prepareCreate("test"));, +        for(int i=0;i<5;i++) {, +            client().prepareIndex("test", "type", ""+i).setSource("number", 0).get();, +        }, +        refresh();, +, +        Exception exc = expectThrows(Exception.class,, +            () -> client().prepareSearch(), +                .addSort(SortBuilders.fieldSort("number")), +                .setTrackScores(true), +                .addRescorer(new QueryRescorerBuilder(matchAllQuery()), 50), +                .get(), +        );, +        assertNotNull(exc.getCause());, +        assertThat(exc.getCause().getMessage(),]