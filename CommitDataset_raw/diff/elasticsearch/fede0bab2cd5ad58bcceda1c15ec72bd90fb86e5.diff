[+++ b/buildSrc/build.gradle, +++ b/buildSrc/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/NamingConventionsTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/namingConventions'), +, +    /**, +     * The classpath to run the naming conventions checks against. Must contain the files in the test, +     * output directory and everything required to load those classes., +     *, +     * We don't declare the actual test files as a dependency or input because if they change then, +     * this will change., +     */, +    @InputFiles, +    FileCollection classpath = project.sourceSets.test.runtimeClasspath, +        description = "Runs NamingConventionsCheck on ${classpath}", +                args('--', project.sourceSets.test.output.classesDir.absolutePath), +++ b/buildSrc/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/NamingConventionsTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/namingConventions'), +, +    /**, +     * The classpath to run the naming conventions checks against. Must contain the files in the test, +     * output directory and everything required to load those classes., +     *, +     * We don't declare the actual test files as a dependency or input because if they change then, +     * this will change., +     */, +    @InputFiles, +    FileCollection classpath = project.sourceSets.test.runtimeClasspath, +        description = "Runs NamingConventionsCheck on ${classpath}", +                args('--', project.sourceSets.test.output.classesDir.absolutePath), +++ b/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java, +        check.check(rootPath, skipIntegTestsInDisguise);, +        assertNoViolations("Not all subclasses of " + check.testClass.getSimpleName(), +                + " match the naming convention. Concrete classes must end with [Tests]", check.missingSuffix);, +            assertNoViolations("Subclasses of " + check.integTestClass.getSimpleName() +, +                    " should end with IT as they are integration tests", check.integTestsInDisguise);, +        this.testClass = testClass;, +    public void check(Path rootPath, boolean skipTestsInDisguised) throws IOException {, +        Files.walkFileTree(rootPath, new FileVisitor<Path>() {, +            /**, +             * The package name of the directory we are currently visiting. Kept as a string rather than something fancy because we load, +             * just about every class and doing so requires building a string out of it anyway. At least this way we don't need to build the, +             * first part of the string over and over and over again., +             */, +            private String packageName;, +, +            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {, +                // First we visit the root directory, +                if (packageName == null) {, +                    // And it package is empty string regardless of the directory name, +                    packageName = "";, +                } else {, +                    packageName += dir.getFileName() + ".";, +                }, +                return FileVisitResult.CONTINUE;, +            }, +, +            @Override, +            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                // Go up one package by jumping back to the second to last '.', +                packageName = packageName.substring(0, 1 + packageName.lastIndexOf('.', packageName.length() - 2));, +                return FileVisitResult.CONTINUE;, +            }, +, +            @Override, +            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {, +                String filename = file.getFileName().toString();, +                if (filename.endsWith(".class")) {, +                    String className = filename.substring(0, filename.length() - ".class".length());, +                    Class<?> clazz = loadClassWithoutInitializing(packageName + className);, +                    if (clazz.getName().endsWith("Tests")) {, +                    } else if (clazz.getName().endsWith("IT")) {, +                    } else if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) {, +                }, +                return FileVisitResult.CONTINUE;, +            private boolean isTestCase(Class<?> clazz) {, +                return testClass.isAssignableFrom(clazz);, +            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {, +                throw exc;, +        className = "org.elasticsearch.test.NamingConventionsCheckBadClasses$" + className;, +++ b/buildSrc/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/NamingConventionsTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/namingConventions'), +, +    /**, +     * The classpath to run the naming conventions checks against. Must contain the files in the test, +     * output directory and everything required to load those classes., +     *, +     * We don't declare the actual test files as a dependency or input because if they change then, +     * this will change., +     */, +    @InputFiles, +    FileCollection classpath = project.sourceSets.test.runtimeClasspath, +        description = "Runs NamingConventionsCheck on ${classpath}", +                args('--', project.sourceSets.test.output.classesDir.absolutePath), +++ b/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java, +        check.check(rootPath, skipIntegTestsInDisguise);, +        assertNoViolations("Not all subclasses of " + check.testClass.getSimpleName(), +                + " match the naming convention. Concrete classes must end with [Tests]", check.missingSuffix);]