[+++ b/docs/reference/search/request/rescore.asciidoc, +NOTE: the `rescore` phase is not executed when, +NOTE: when exposing pagination to your users, you should not change, +`window_size` as you step through each page (by passing different, +`from` values) since that can alter the top hits causing results to, +confusingly shift as the user steps through pages., +, +++ b/docs/reference/search/request/rescore.asciidoc, +NOTE: the `rescore` phase is not executed when, +NOTE: when exposing pagination to your users, you should not change, +`window_size` as you step through each page (by passing different, +`from` values) since that can alter the top hits causing results to, +confusingly shift as the user steps through pages., +, +++ b/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java, +import java.util.Comparator;, +    public TopDocs rescore(TopDocs topDocs, SearchContext context, RescoreSearchContext rescoreContext) throws IOException {, +, +            return topDocs;, +        final QueryRescoreContext rescore = (QueryRescoreContext) rescoreContext;, +, +        org.apache.lucene.search.Rescorer rescorer = new org.apache.lucene.search.QueryRescorer(rescore.query()) {, +, +            @Override, +            protected float combine(float firstPassScore, boolean secondPassMatches, float secondPassScore) {, +                if (secondPassMatches) {, +                    return rescore.scoreMode.combine(firstPassScore * rescore.queryWeight(), secondPassScore * rescore.rescoreQueryWeight());, +                }, +                // TODO: shouldn't this be up to the ScoreMode?  I.e., we should just invoke ScoreMode.combine, passing 0.0f for the, +                // secondary score?, +                return firstPassScore * rescore.queryWeight();, +            }, +        };, +, +        // First take top slice of incoming docs, to be rescored:, +        TopDocs topNFirstPass = topN(topDocs, rescoreContext.window());, +, +        // Rescore them:, +        TopDocs rescored = rescorer.rescore(context.searcher(), topNFirstPass, rescoreContext.window());, +, +        // Splice back to non-topN hits and resort all of them:, +        return combine(topDocs, rescored, (QueryRescoreContext) rescoreContext);, +        QueryRescoreContext rescore = (QueryRescoreContext) rescoreContext;, +        // TODO: this isn't right?  I.e., we are incorrectly pretending all first pass hits were rescored?  If the requested docID was, +        // beyond the top rescoreContext.window() in the first pass hits, we don't rescore it now?, +, +        // NOTE: we don't use Lucene's Rescorer.explain because we want to insert our own description with which ScoreMode was used.  Maybe, +        // we should add QueryRescorer.explainCombine to Lucene?, +    private final static Comparator<ScoreDoc> SCORE_DOC_COMPARATOR = new Comparator<ScoreDoc>() {, +        @Override, +        public int compare(ScoreDoc o1, ScoreDoc o2) {, +            int cmp = Float.compare(o2.score, o1.score);, +            return cmp == 0 ?  Integer.compare(o1.doc, o2.doc) : cmp;, +        }, +    };, +, +    /** Returns a new {@link TopDocs} with the topN from the incoming one, or the same TopDocs if the number of hits is already <=, +     *  topN. */, +    private TopDocs topN(TopDocs in, int topN) {, +        if (in.totalHits < topN) {, +            assert in.scoreDocs.length == in.totalHits;, +            return in;, +        }, +, +        ScoreDoc[] subset = new ScoreDoc[topN];, +        System.arraycopy(in.scoreDocs, 0, subset, 0, topN);, +, +        return new TopDocs(in.totalHits, subset, in.getMaxScore());, +    }, +, +    /** Modifies incoming TopDocs (in) by replacing the top hits with resorted's hits, and then resorting all hits. */, +    private TopDocs combine(TopDocs in, TopDocs resorted, QueryRescoreContext ctx) {, +, +        System.arraycopy(resorted.scoreDocs, 0, in.scoreDocs, 0, resorted.scoreDocs.length);, +        if (in.scoreDocs.length > resorted.scoreDocs.length) {, +            // These hits were not rescored (beyond the rescore window), so we treat them the same as a hit that did get rescored but did, +            // not match the 2nd pass query:, +            for(int i=resorted.scoreDocs.length;i<in.scoreDocs.length;i++) {, +                // TODO: shouldn't this be up to the ScoreMode?  I.e., we should just invoke ScoreMode.combine, passing 0.0f for the, +                // secondary score?, +                in.scoreDocs[i].score *= ctx.queryWeight();, +            }, +            , +            // TODO: this is wrong, i.e. we are comparing apples and oranges at this point.  It would be better if we always rescored all, +            // incoming first pass hits, instead of allowing recoring of just the top subset:, +            Arrays.sort(in.scoreDocs, SCORE_DOC_COMPARATOR);, +        }, +        return in;, +    }, +, +++ b/docs/reference/search/request/rescore.asciidoc, +NOTE: the `rescore` phase is not executed when, +NOTE: when exposing pagination to your users, you should not change, +`window_size` as you step through each page (by passing different, +`from` values) since that can alter the top hits causing results to, +confusingly shift as the user steps through pages., +, +++ b/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java, +import java.util.Comparator;, +    public TopDocs rescore(TopDocs topDocs, SearchContext context, RescoreSearchContext rescoreContext) throws IOException {]