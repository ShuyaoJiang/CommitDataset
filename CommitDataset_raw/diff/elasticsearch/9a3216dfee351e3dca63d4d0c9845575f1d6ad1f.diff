[+++ b/core/src/main/java/org/elasticsearch/common/Numbers.java, +    private static final BigInteger MAX_LONG_VALUE = BigInteger.valueOf(Long.MAX_VALUE);, +    private static final BigInteger MIN_LONG_VALUE = BigInteger.valueOf(Long.MIN_VALUE);, +, +    /** Return the long that {@code stringValue} stores or throws an exception if the, +     *  stored value cannot be converted to a long that stores the exact same, +     *  value and {@code coerce} is false. */, +    public static long toLong(String stringValue, boolean coerce) {, +        try {, +            return Long.parseLong(stringValue);, +        } catch (NumberFormatException e) {, +            // we will try again with BigDecimal, +        }, +, +        final BigInteger bigIntegerValue;, +        try {, +            BigDecimal bigDecimalValue = new BigDecimal(stringValue);, +            bigIntegerValue = coerce ? bigDecimalValue.toBigInteger() : bigDecimalValue.toBigIntegerExact();, +        } catch (ArithmeticException e) {, +            throw new IllegalArgumentException("Value [" + stringValue + "] has a decimal part");, +        } catch (NumberFormatException e) {, +            throw new IllegalArgumentException("For input string: \"" + stringValue + "\"");, +        }, +, +        if (bigIntegerValue.compareTo(MAX_LONG_VALUE) > 0 || bigIntegerValue.compareTo(MIN_LONG_VALUE) < 0) {, +            throw new IllegalArgumentException("Value [" + stringValue + "] is out of range for a long");, +        }, +, +        return bigIntegerValue.longValue();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/Numbers.java, +    private static final BigInteger MAX_LONG_VALUE = BigInteger.valueOf(Long.MAX_VALUE);, +    private static final BigInteger MIN_LONG_VALUE = BigInteger.valueOf(Long.MIN_VALUE);, +, +    /** Return the long that {@code stringValue} stores or throws an exception if the, +     *  stored value cannot be converted to a long that stores the exact same, +     *  value and {@code coerce} is false. */, +    public static long toLong(String stringValue, boolean coerce) {, +        try {, +            return Long.parseLong(stringValue);, +        } catch (NumberFormatException e) {, +            // we will try again with BigDecimal, +        }, +, +        final BigInteger bigIntegerValue;, +        try {, +            BigDecimal bigDecimalValue = new BigDecimal(stringValue);, +            bigIntegerValue = coerce ? bigDecimalValue.toBigInteger() : bigDecimalValue.toBigIntegerExact();, +        } catch (ArithmeticException e) {, +            throw new IllegalArgumentException("Value [" + stringValue + "] has a decimal part");, +        } catch (NumberFormatException e) {, +            throw new IllegalArgumentException("For input string: \"" + stringValue + "\"");, +        }, +, +        if (bigIntegerValue.compareTo(MAX_LONG_VALUE) > 0 || bigIntegerValue.compareTo(MIN_LONG_VALUE) < 0) {, +            throw new IllegalArgumentException("Value [" + stringValue + "] is out of range for a long");, +        }, +, +        return bigIntegerValue.longValue();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java, +import org.elasticsearch.common.Numbers;, +, +            double doubleValue = Double.parseDouble(text());, +, +            if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {, +                throw new IllegalArgumentException("Value [" + text() + "] is out of range for a short");, +            }, +, +            return (short) doubleValue;, +            double doubleValue = Double.parseDouble(text());, +, +            if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {, +                throw new IllegalArgumentException("Value [" + text() + "] is out of range for an integer");, +            }, +, +            return (int) doubleValue;, +            return Numbers.toLong(text(), coerce);, +++ b/core/src/main/java/org/elasticsearch/common/Numbers.java, +    private static final BigInteger MAX_LONG_VALUE = BigInteger.valueOf(Long.MAX_VALUE);, +    private static final BigInteger MIN_LONG_VALUE = BigInteger.valueOf(Long.MIN_VALUE);, +, +    /** Return the long that {@code stringValue} stores or throws an exception if the, +     *  stored value cannot be converted to a long that stores the exact same, +     *  value and {@code coerce} is false. */, +    public static long toLong(String stringValue, boolean coerce) {, +        try {, +            return Long.parseLong(stringValue);, +        } catch (NumberFormatException e) {, +            // we will try again with BigDecimal, +        }, +, +        final BigInteger bigIntegerValue;, +        try {, +            BigDecimal bigDecimalValue = new BigDecimal(stringValue);, +            bigIntegerValue = coerce ? bigDecimalValue.toBigInteger() : bigDecimalValue.toBigIntegerExact();, +        } catch (ArithmeticException e) {, +            throw new IllegalArgumentException("Value [" + stringValue + "] has a decimal part");]