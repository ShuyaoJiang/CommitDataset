[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShardOperationsLock.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext.StoredContext;, +import java.util.function.Supplier;, +                    final Supplier<StoredContext> contextSupplier = threadPool.getThreadContext().newRestorableContext(false);, +                            new ThreadedActionListener<>(logger, threadPool, executorOnDelay,, +                                new ContextPreservingActionListener<>(contextSupplier, onAcquired), forceExecution));, +                        delayedOperations.add(new ContextPreservingActionListener<>(contextSupplier, onAcquired));, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShardOperationsLock.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext.StoredContext;, +import java.util.function.Supplier;, +                    final Supplier<StoredContext> contextSupplier = threadPool.getThreadContext().newRestorableContext(false);, +                            new ThreadedActionListener<>(logger, threadPool, executorOnDelay,, +                                new ContextPreservingActionListener<>(contextSupplier, onAcquired), forceExecution));, +                        delayedOperations.add(new ContextPreservingActionListener<>(contextSupplier, onAcquired));, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardOperationsLockTests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import java.util.function.Function;, +import java.util.function.Supplier;, +        future.get(1, TimeUnit.HOURS).close();, +    }, +, +    /**, +     * Tests that the ThreadContext is restored when a operation is executed after it has been delayed due to a block, +     */, +    public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException {, +        final ThreadContext context = threadPool.getThreadContext();, +        final Function<ActionListener<Releasable>, Boolean> contextChecker = (listener) -> {, +            if ("bar".equals(context.getHeader("foo")) == false) {, +                listener.onFailure(new IllegalStateException("context did not have value [bar] for header [foo]. Actual value [" +, +                    context.getHeader("foo") + "]"));, +            } else if ("baz".equals(context.getTransient("bar")) == false) {, +                listener.onFailure(new IllegalStateException("context did not have value [baz] for transient [bar]. Actual value [" +, +                    context.getTransient("bar") + "]"));, +            } else {, +                return true;, +            }, +            return false;, +        };, +        PlainActionFuture<Releasable> future = new PlainActionFuture<Releasable>() {, +            @Override, +            public void onResponse(Releasable releasable) {, +                if (contextChecker.apply(this)) {, +                    super.onResponse(releasable);, +                }, +            }, +        };, +        PlainActionFuture<Releasable> future2 = new PlainActionFuture<Releasable>() {, +            @Override, +            public void onResponse(Releasable releasable) {, +                if (contextChecker.apply(this)) {, +                    super.onResponse(releasable);, +                }, +            }, +        };, +, +        try (Releasable releasable = blockAndWait()) {, +            // we preserve the thread context here so that we have a different context in the call to acquire than the context present, +            // when the releasable is closed, +            try (ThreadContext.StoredContext ignore = context.newStoredContext(false)) {, +                context.putHeader("foo", "bar");, +                context.putTransient("bar", "baz");, +                // test both with and without a executor name, +                block.acquire(future, ThreadPool.Names.GENERIC, true);, +                block.acquire(future2, null, true);, +            }, +            assertFalse(future.isDone());, +        }, +        future.get(1, TimeUnit.HOURS).close();, +        future2.get(1, TimeUnit.HOURS).close();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShardOperationsLock.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext.StoredContext;, +import java.util.function.Supplier;, +                    final Supplier<StoredContext> contextSupplier = threadPool.getThreadContext().newRestorableContext(false);, +                            new ThreadedActionListener<>(logger, threadPool, executorOnDelay,, +                                new ContextPreservingActionListener<>(contextSupplier, onAcquired), forceExecution));, +                        delayedOperations.add(new ContextPreservingActionListener<>(contextSupplier, onAcquired));, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardOperationsLockTests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import java.util.function.Function;, +import java.util.function.Supplier;, +        future.get(1, TimeUnit.HOURS).close();, +    }, +, +    /**, +     * Tests that the ThreadContext is restored when a operation is executed after it has been delayed due to a block, +     */, +    public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException {, +        final ThreadContext context = threadPool.getThreadContext();, +        final Function<ActionListener<Releasable>, Boolean> contextChecker = (listener) -> {, +            if ("bar".equals(context.getHeader("foo")) == false) {, +                listener.onFailure(new IllegalStateException("context did not have value [bar] for header [foo]. Actual value [" +, +                    context.getHeader("foo") + "]"));, +            } else if ("baz".equals(context.getTransient("bar")) == false) {, +                listener.onFailure(new IllegalStateException("context did not have value [baz] for transient [bar]. Actual value [" +, +                    context.getTransient("bar") + "]"));]