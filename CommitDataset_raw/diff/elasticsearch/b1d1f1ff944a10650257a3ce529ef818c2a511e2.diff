[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +    public void startRecovery(final StartRecoveryRequest request, boolean fromRetry, final RecoveryListener listener) {, +        if (!fromRetry) {, +                shard.recovering();, +        threadPool.cached().execute(new Runnable() {, +            @Override public void run() {, +                doRecovery(shard, request, listener);, +            }, +        });, +    }, +, +    private void doRecovery(final InternalIndexShard shard, final StartRecoveryRequest request, final RecoveryListener listener) {, +        if (shard.state() == IndexShardState.CLOSED) {, +            listener.onIgnoreRecovery(false, "shard closed, stop recovery");, +            return;, +        }, +, +        if (!recoveryThrottler.tryRecovery(shard.shardId(), "peer recovery target")) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +    public void startRecovery(final StartRecoveryRequest request, boolean fromRetry, final RecoveryListener listener) {, +        if (!fromRetry) {, +                shard.recovering();, +        threadPool.cached().execute(new Runnable() {, +            @Override public void run() {, +                doRecovery(shard, request, listener);, +            }, +        });, +    }, +, +    private void doRecovery(final InternalIndexShard shard, final StartRecoveryRequest request, final RecoveryListener listener) {, +        if (shard.state() == IndexShardState.CLOSED) {, +            listener.onIgnoreRecovery(false, "shard closed, stop recovery");, +            return;, +        }, +, +        if (!recoveryThrottler.tryRecovery(shard.shardId(), "peer recovery target")) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +    public void startRecovery(final StartRecoveryRequest request, boolean fromRetry, final RecoveryListener listener) {, +        if (!fromRetry) {, +                shard.recovering();, +        threadPool.cached().execute(new Runnable() {, +            @Override public void run() {, +                doRecovery(shard, request, listener);, +            }, +        });, +    }, +, +    private void doRecovery(final InternalIndexShard shard, final StartRecoveryRequest request, final RecoveryListener listener) {, +        if (shard.state() == IndexShardState.CLOSED) {, +            listener.onIgnoreRecovery(false, "shard closed, stop recovery");, +            return;, +        }, +, +        if (!recoveryThrottler.tryRecovery(shard.shardId(), "peer recovery target")) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                        recoveryTarget.startRecovery(request, false, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, false, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, true, PeerRecoveryListener.this);]