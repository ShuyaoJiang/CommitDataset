[+++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5));, +            ShardPath path;, +            try {, +                path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +            } catch (IllegalStateException ex) {, +                logger.warn("{} failed to load shard path, trying to archive leftover", shardId);, +                try {, +                    ShardPath.deleteLeftoverShardDirectory(logger, nodeEnv, lock, indexSettings);, +                    path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +                } catch (Throwable t) {, +                    t.addSuppressed(ex);, +                    throw t;, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5));, +            ShardPath path;, +            try {, +                path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +            } catch (IllegalStateException ex) {, +                logger.warn("{} failed to load shard path, trying to archive leftover", shardId);, +                try {, +                    ShardPath.deleteLeftoverShardDirectory(logger, nodeEnv, lock, indexSettings);, +                    path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +                } catch (Throwable t) {, +                    t.addSuppressed(ex);, +                    throw t;, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/index/shard/ShardPath.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.env.ShardLock;, +                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {, +    /**, +     * This method tries to delete left-over shards where the index name has been reused but the UUID is different, +     * to allow the new shard to be allocated., +     */, +    public static void deleteLeftoverShardDirectory(ESLogger logger, NodeEnvironment env, ShardLock lock, @IndexSettings Settings indexSettings) throws IOException {, +        final String indexUUID = indexSettings.get(IndexMetaData.SETTING_INDEX_UUID, IndexMetaData.INDEX_UUID_NA_VALUE);, +        final Path[] paths = env.availableShardPaths(lock.getShardId());, +        for (Path path : paths) {, +            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, path);, +            if (load != null) {, +                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {, +                    logger.warn("{} deleting leftover shard on path: [{}] with a different index UUID", lock.getShardId(), path);, +                    assert Files.isDirectory(path) : path + " is not a directory";, +                    NodeEnvironment.acquireFSLockForPaths(indexSettings, paths);, +                    IOUtils.rm(path);, +                }, +            }, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +            lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5));, +            ShardPath path;, +            try {, +                path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +            } catch (IllegalStateException ex) {, +                logger.warn("{} failed to load shard path, trying to archive leftover", shardId);, +                try {, +                    ShardPath.deleteLeftoverShardDirectory(logger, nodeEnv, lock, indexSettings);, +                    path = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);, +                } catch (Throwable t) {, +                    t.addSuppressed(ex);, +                    throw t;, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/index/shard/ShardPath.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.env.ShardLock;, +                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {, +    /**, +     * This method tries to delete left-over shards where the index name has been reused but the UUID is different, +     * to allow the new shard to be allocated., +     */, +    public static void deleteLeftoverShardDirectory(ESLogger logger, NodeEnvironment env, ShardLock lock, @IndexSettings Settings indexSettings) throws IOException {, +        final String indexUUID = indexSettings.get(IndexMetaData.SETTING_INDEX_UUID, IndexMetaData.INDEX_UUID_NA_VALUE);, +        final Path[] paths = env.availableShardPaths(lock.getShardId());, +        for (Path path : paths) {, +            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, path);, +            if (load != null) {, +                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {, +                    logger.warn("{} deleting leftover shard on path: [{}] with a different index UUID", lock.getShardId(), path);, +                    assert Files.isDirectory(path) : path + " is not a directory";, +                    NodeEnvironment.acquireFSLockForPaths(indexSettings, paths);, +                    IOUtils.rm(path);, +                }, +            }, +        }, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.common.io.FileSystemUtils;, +import java.nio.file.Files;, +import java.nio.file.StandardCopyOption;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +]