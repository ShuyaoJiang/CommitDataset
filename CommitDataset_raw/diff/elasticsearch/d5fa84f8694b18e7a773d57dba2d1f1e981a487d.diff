[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +            // just close and ignore - we are already stopped and just need to make sure we release all resources, +            disconnectFromNodeChannel(channel, e);, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +            // just close and ignore - we are already stopped and just need to make sure we release all resources, +            disconnectFromNodeChannel(channel, e);, +++ b/test/framework/src/main/java/org/elasticsearch/transport/MockTcpTransport.java, +import java.util.Collections;, +        private final Set<MockChannel> workerChannels = Collections.newSetFromMap(new ConcurrentHashMap<>());, +                            workerChannels.add(incomingChannel);, +, +                        } catch (Exception ex) {, +                            IOUtils.closeWhileHandlingException(MockChannel.this); // pure paranoia, +        public synchronized void close() throws IOException {, +            // establish a happens-before edge between closing and accepting a new connection, +            // we have to sync this entire block to ensure that our openChannels checks work correctly., +            // The close block below will close all worker channels but if one of the worker channels runs into an exception, +            // for instance due to a disconnect the handling of this exception might be executed concurrently., +            // now if we are in-turn concurrently call close we might not wait for the actual close to happen and that will, down the road, +            // make the assertion trip that not all channels are closed., +                IOUtils.close(serverSocket, activeChannel, () -> IOUtils.close(workerChannels),]