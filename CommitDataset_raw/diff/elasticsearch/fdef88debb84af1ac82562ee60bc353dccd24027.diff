[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +        IndexShard indexShard = indexShard(shardRequest);, +, +, +, +        BulkItemResponse[] responses = new BulkItemResponse[request.items().length];, +        for (int i = 0; i < request.items().length; i++) {, +                    long version;, +                    ParsedDocument doc;, +                    Engine.Operation op;, +                        Engine.Index index = indexShard.prepareIndex(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.PRIMARY);, +                        doc = indexShard.index(index);, +                        version = index.version();, +                        op = index;, +                        Engine.Create create = indexShard.prepareCreate(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.PRIMARY);, +                        doc = indexShard.create(create);, +                        version = create.version();, +                        op = create;, +                    // update the version on request so it will happen on the replicas, +                    indexRequest.version(version);, +, +                    // update mapping on master if needed, we won't update changes to the same type, since once its changed, it won't have mappers added, +                    if (doc.mappersAdded()) {, +                        updateMappingOnMaster(indexRequest);, +                    }, +, +                    // if we are going to percolate, then we need to keep this op for the postPrimary operation, +                    if (Strings.hasLength(indexRequest.percolate())) {, +                        if (ops == null) {, +                            ops = new Engine.Operation[request.items().length];, +                        }, +                        ops[i] = op;, +                    }, +, +                    // add the response, +                    responses[i] = new BulkItemResponse(item.id(), indexRequest.opType().toString().toLowerCase(),, +                            new IndexResponse(indexRequest.index(), indexRequest.type(), indexRequest.id(), version));, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version()).origin(Engine.Operation.Origin.PRIMARY);, +                    indexShard.delete(delete);, +                    // update the request with teh version so it will go to the replicas, +                    deleteRequest.version(delete.version());, +, +                    // add the response, +                    responses[i] = new BulkItemResponse(item.id(), "delete",, +                            new DeleteResponse(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), delete.version(), delete.notFound()));, +        if (request.refresh()) {, +            try {, +                indexShard.refresh(new Engine.Refresh(false));, +            } catch (Exception e) {, +                // ignore, +            if (ops[i] == null) {, +                continue; // failed, +            }, +        for (int i = 0; i < request.items().length; i++) {, +                        Engine.Index index = indexShard.prepareIndex(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.REPLICA);, +                        indexShard.index(index);, +                        Engine.Create create = indexShard.prepareCreate(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.REPLICA);, +                        indexShard.create(create);, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version()).origin(Engine.Operation.Origin.REPLICA);, +                    indexShard.delete(delete);, +        if (request.refresh()) {, +            try {, +                indexShard.refresh(new Engine.Refresh(false));, +            } catch (Exception e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +        IndexShard indexShard = indexShard(shardRequest);, +, +, +, +        BulkItemResponse[] responses = new BulkItemResponse[request.items().length];, +        for (int i = 0; i < request.items().length; i++) {, +                    long version;, +                    ParsedDocument doc;, +                    Engine.Operation op;, +                        Engine.Index index = indexShard.prepareIndex(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.PRIMARY);, +                        doc = indexShard.index(index);, +                        version = index.version();, +                        op = index;, +                        Engine.Create create = indexShard.prepareCreate(sourceToParse).version(indexRequest.version()).origin(Engine.Operation.Origin.PRIMARY);, +                        doc = indexShard.create(create);, +                        version = create.version();, +                        op = create;, +                    // update the version on request so it will happen on the replicas, +                    indexRequest.version(version);, +, +                    // update mapping on master if needed, we won't update changes to the same type, since once its changed, it won't have mappers added, +                    if (doc.mappersAdded()) {, +                        updateMappingOnMaster(indexRequest);, +                    }, +, +                    // if we are going to percolate, then we need to keep this op for the postPrimary operation, +                    if (Strings.hasLength(indexRequest.percolate())) {, +                        if (ops == null) {, +                            ops = new Engine.Operation[request.items().length];, +                        }, +                        ops[i] = op;, +                    }]