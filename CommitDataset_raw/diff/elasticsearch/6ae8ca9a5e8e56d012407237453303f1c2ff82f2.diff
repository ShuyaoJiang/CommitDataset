[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** True if this shard is still indexing (recently) and false if we've been idle for long enough (as periodically checked by {@link, +     *  IndexingMemoryController}). */, +    private final AtomicBoolean active = new AtomicBoolean();, +, +    private volatile long lastWriteNS;, +        markLastWrite(index);, +        markLastWrite(delete);, +    /** Returns timestamp of last indexing operation */, +    public long getLastWriteNS() {, +        return lastWriteNS;, +    }, +, +    /** Records timestamp of the last write operation, possibly switching {@code active} to true if we were inactive. */, +    private void markLastWrite(Engine.Operation op) {, +        lastWriteNS = op.startTime();, +        if (active.getAndSet(true) == false) {, +            // We are currently inactive, but a new write operation just showed up, so we now notify IMC, +            // to wake up and fix our indexing buffer.  We could do this async instead, but cost should, +            // be low, and it's rare this happens., +            indexingMemoryController.forceCheck();, +        }, +    }, +, +    /** Called by {@link IndexingMemoryController} to check whether more than {@code inactiveTimeNS} has passed since the last, +     *  indexing operation, and become inactive (reducing indexing and translog buffers to tiny values) if so. */, +    public void checkIdle(long inactiveTimeNS) {, +        if (System.nanoTime() - lastWriteNS >= inactiveTimeNS) {, +            boolean wasActive = active.getAndSet(false);, +            if (wasActive) {, +                logger.debug("shard is now inactive");, +                indicesLifecycle.onShardInactive(this);, +            }, +        }, +    }, +, +    /** Returns {@code true} if this shard is active (has seen indexing ops in the last {@link, +     *  IndexingMemoryController#SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */, +    public boolean getActive() {, +        return active.get();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** True if this shard is still indexing (recently) and false if we've been idle for long enough (as periodically checked by {@link, +     *  IndexingMemoryController}). */, +    private final AtomicBoolean active = new AtomicBoolean();, +, +    private volatile long lastWriteNS;, +        markLastWrite(index);, +        markLastWrite(delete);, +    /** Returns timestamp of last indexing operation */, +    public long getLastWriteNS() {, +        return lastWriteNS;, +    }, +, +    /** Records timestamp of the last write operation, possibly switching {@code active} to true if we were inactive. */, +    private void markLastWrite(Engine.Operation op) {, +        lastWriteNS = op.startTime();, +        if (active.getAndSet(true) == false) {, +            // We are currently inactive, but a new write operation just showed up, so we now notify IMC, +            // to wake up and fix our indexing buffer.  We could do this async instead, but cost should, +            // be low, and it's rare this happens., +            indexingMemoryController.forceCheck();, +        }, +    }, +, +    /** Called by {@link IndexingMemoryController} to check whether more than {@code inactiveTimeNS} has passed since the last, +     *  indexing operation, and become inactive (reducing indexing and translog buffers to tiny values) if so. */, +    public void checkIdle(long inactiveTimeNS) {, +        if (System.nanoTime() - lastWriteNS >= inactiveTimeNS) {, +            boolean wasActive = active.getAndSet(false);, +            if (wasActive) {, +                logger.debug("shard is now inactive");, +                indicesLifecycle.onShardInactive(this);, +            }, +        }, +    }, +, +    /** Returns {@code true} if this shard is active (has seen indexing ops in the last {@link, +     *  IndexingMemoryController#SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */, +    public boolean getActive() {, +        return active.get();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +    /** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */, +    public static final String SHARD_INACTIVE_TIME_SETTING = "indices.memory.shard_inactive_time";, +, +    private final TimeValue inactiveTime;, +        this.inactiveTime = this.settings.getAsTime(SHARD_INACTIVE_TIME_SETTING, TimeValue.timeValueMinutes(5));, +        logger.debug("using indexing buffer size [{}] with {} [{}], {} [{}]",, +                     this.indexingBuffer,, +                     SHARD_INACTIVE_TIME_SETTING, this.inactiveTime,, +                     SHARD_MEMORY_INTERVAL_TIME_SETTING, this.interval);, +    /** ask this shard to check now whether it is inactive, and reduces its indexing and translog buffers if so.  returns Boolean.TRUE if, +     *  it did deactive, Boolean.FALSE if it did not, and null if the shard is unknown */, +    protected void checkIdle(ShardId shardId, long inactiveTimeNS) {, +        final IndexShard shard = getShard(shardId);, +        if (shard != null) {, +            shard.checkIdle(inactiveTimeNS);]