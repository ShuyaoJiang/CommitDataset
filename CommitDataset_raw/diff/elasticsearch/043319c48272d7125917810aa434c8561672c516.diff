[+++ b/build.gradle, +task run() {, +  dependsOn ':distribution:run', +  description = 'Runs elasticsearch in the foreground', +  group = 'Verification', +}, +++ b/build.gradle, +task run() {, +  dependsOn ':distribution:run', +  description = 'Runs elasticsearch in the foreground', +  group = 'Verification', +}, +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/TestProgressLogger.groovy, +import com.carrotsearch.ant.tasks.junit4.events.aggregated.AggregatedTestResultEvent, +import static com.carrotsearch.ant.tasks.junit4.events.aggregated.TestStatus.*, +import static java.lang.Math.max, +/**, + * Adapts junit4's event listeners into gradle's ProgressLogger. Note that, + * junit4 guarantees (via guava) that methods on this class won't be called by, + * multiple threads simultaneously which is helpful in making it simpler., + *, + * Every time a test finishes this class will update the logger. It will log, + * the last finished test method on the logger line until the first suite, + * finishes. Once the first suite finishes it always logs the last finished, + * suite. This means that in test runs with a single suite the logger will be, + * updated with the test name the whole time which is useful because these runs, + * usually have longer individual tests. For test runs with lots of suites the, + * majority of the time is spent showing the last suite that finished which is, + * more useful for those test runs because test methods there tend to be very, + * quick., + */, +    int totalSuites, +    int totalSlaves, +, +    // sprintf formats used to align the integers we print, +    String suitesFormat, +    String slavesFormat, +    String testsFormat, +, +    // Counters incremented test completion., +    volatile int suitesCompleted = 0, +    volatile int testsCompleted = 0, +    volatile int testsFailed = 0, +    volatile int testsIgnored = 0, +, +    // Information about the last, most interesting event., +    volatile String eventDescription, +    volatile int eventSlave, +    volatile long eventExecutionTime, +, +    /** Have we finished a whole suite yet? */, +    volatile boolean suiteFinished = false, +    /* Note that we probably overuse volatile here but it isn't hurting us and, +      lets us move things around without worying about breaking things. */, +        totalSuites = e.suiteCount, +        totalSlaves = e.slaveCount, +        progressLogger.progress(, +            "Starting JUnit4 for ${totalSuites} suites on ${totalSlaves} jvms"), +, +        suitesFormat = "%0${widthForTotal(totalSuites)}d", +        slavesFormat = "%-${widthForTotal(totalSlaves)}s", +        /* Just guess the number of tests because we can't figure it out from, +          here and it isn't worth doing anything fancy to prevent the console, +          from jumping around a little. 200 is a pretty wild guess for the, +          minimum but it makes REST tests output sanely. */, +        int totalNumberOfTestsGuess = max(200, totalSuites * 10), +        testsFormat = "%0${widthForTotal(totalNumberOfTestsGuess)}d", +    }, +, +    @Subscribe, +    void onTestResult(AggregatedTestResultEvent e) throws IOException {, +        testsCompleted++, +        switch (e.status) {, +        case ERROR:, +        case FAILURE:, +            testsFailed++, +            break, +        case IGNORED:, +        case IGNORED_ASSUMPTION:, +            testsIgnored++, +            break, +        case OK:, +            break, +        default:, +            throw new IllegalArgumentException(, +                "Unknown test status: [${e.status}]"), +        }, +        if (!suiteFinished) {, +            updateEventInfo(e), +        }, +, +        log(), +        suitesCompleted++, +        suiteFinished = true, +        updateEventInfo(e), +        log(), +    }, +, +    /**, +     * Update the suite information with a junit4 event.]