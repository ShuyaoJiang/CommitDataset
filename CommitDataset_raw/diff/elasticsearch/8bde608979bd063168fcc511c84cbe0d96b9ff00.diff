[+++ b/server/src/main/java/org/elasticsearch/plugins/RepositoryPlugin.java, +, +    /**, +     * Returns internal repository types added by this plugin. Internal repositories cannot be registered, +     * through the external API., +     *, +     * @param env The environment for the local node, which may be used for the local settings and path.repo, +     *, +     * The key of the returned {@link Map} is the type name of the repository and, +     * the value is a factory to construct the {@link Repository} interface., +     */, +    default Map<String, Repository.Factory> getInternalRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {, +        return Collections.emptyMap();, +    }, +++ b/server/src/main/java/org/elasticsearch/plugins/RepositoryPlugin.java, +, +    /**, +     * Returns internal repository types added by this plugin. Internal repositories cannot be registered, +     * through the external API., +     *, +     * @param env The environment for the local node, which may be used for the local settings and path.repo, +     *, +     * The key of the returned {@link Map} is the type name of the repository and, +     * the value is a factory to construct the {@link Repository} interface., +     */, +    default Map<String, Repository.Factory> getInternalRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {, +        return Collections.emptyMap();, +    }, +++ b/server/src/main/java/org/elasticsearch/repositories/RepositoriesModule.java, +        Map<String, Repository.Factory> internalFactories = new HashMap<>();, +        for (RepositoryPlugin repoPlugin : repoPlugins) {, +            Map<String, Repository.Factory> newRepoTypes = repoPlugin.getInternalRepositories(env, namedXContentRegistry);, +            for (Map.Entry<String, Repository.Factory> entry : newRepoTypes.entrySet()) {, +                if (internalFactories.put(entry.getKey(), entry.getValue()) != null) {, +                    throw new IllegalArgumentException("Internal repository type [" + entry.getKey() + "] is already registered");, +                }, +                if (factories.put(entry.getKey(), entry.getValue()) != null) {, +                    throw new IllegalArgumentException("Internal repository type [" + entry.getKey() + "] is already registered as a " +, +                        "non-internal repository");, +                }, +            }, +        }, +, +        Map<String, Repository.Factory> internalRepositoryTypes = Collections.unmodifiableMap(internalFactories);, +        repositoriesService = new RepositoriesService(env.settings(), clusterService, transportService, repositoryTypes,, +            internalRepositoryTypes, threadPool);, +++ b/server/src/main/java/org/elasticsearch/plugins/RepositoryPlugin.java, +, +    /**, +     * Returns internal repository types added by this plugin. Internal repositories cannot be registered, +     * through the external API., +     *, +     * @param env The environment for the local node, which may be used for the local settings and path.repo, +     *, +     * The key of the returned {@link Map} is the type name of the repository and, +     * the value is a factory to construct the {@link Repository} interface., +     */, +    default Map<String, Repository.Factory> getInternalRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {, +        return Collections.emptyMap();, +    }, +++ b/server/src/main/java/org/elasticsearch/repositories/RepositoriesModule.java, +        Map<String, Repository.Factory> internalFactories = new HashMap<>();, +        for (RepositoryPlugin repoPlugin : repoPlugins) {, +            Map<String, Repository.Factory> newRepoTypes = repoPlugin.getInternalRepositories(env, namedXContentRegistry);, +            for (Map.Entry<String, Repository.Factory> entry : newRepoTypes.entrySet()) {, +                if (internalFactories.put(entry.getKey(), entry.getValue()) != null) {, +                    throw new IllegalArgumentException("Internal repository type [" + entry.getKey() + "] is already registered");, +                }, +                if (factories.put(entry.getKey(), entry.getValue()) != null) {, +                    throw new IllegalArgumentException("Internal repository type [" + entry.getKey() + "] is already registered as a " +, +                        "non-internal repository");, +                }, +            }, +        }, +, +        Map<String, Repository.Factory> internalRepositoryTypes = Collections.unmodifiableMap(internalFactories);, +        repositoriesService = new RepositoriesService(env.settings(), clusterService, transportService, repositoryTypes,, +            internalRepositoryTypes, threadPool);, +++ b/server/src/main/java/org/elasticsearch/repositories/RepositoriesService.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +    private final Map<String, Repository.Factory> internalTypesRegistry;, +    private final Map<String, Repository> internalRepositories = ConcurrentCollections.newConcurrentMap();, +                               Map<String, Repository.Factory> typesRegistry, Map<String, Repository.Factory> internalTypesRegistry,, +        this.internalTypesRegistry = internalTypesRegistry;, +            closeRepository(createRepository(newRepositoryMetaData, typesRegistry));, +                                repository = createRepository(repositoryMetaData, typesRegistry);, +                            repository = createRepository(repositoryMetaData, typesRegistry);, +        repository = internalRepositories.get(repositoryName);, +        if (repository != null) {, +            return repository;, +        }, +    public void registerInternalRepository(String name, String type) {, +        RepositoryMetaData metaData = new RepositoryMetaData(name, type, Settings.EMPTY);, +        Repository repository = internalRepositories.computeIfAbsent(name, (n) -> {, +            logger.debug("put internal repository [{}][{}]", name, type);, +            return createRepository(metaData, internalTypesRegistry);, +        });, +        if (type.equals(repository.getMetadata().type()) == false) {, +            logger.warn(new ParameterizedMessage("internal repository [{}][{}] already registered. this prevented the registration of " +, +                "internal repository [{}][{}].", name, repository.getMetadata().type(), name, type));]