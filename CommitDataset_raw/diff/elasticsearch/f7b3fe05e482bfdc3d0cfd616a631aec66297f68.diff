[+++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +        logger.warn("Unable to lock JVM Memory: error=" + errno + ",reason=" + errMsg);, +        logger.warn("This can result in part of the JVM being swapped out.");, +                    String user = System.getProperty("user.name");, +                                "\t# allow user '" + user + "' mlockall\n" +, +                                "\t" + user + " soft memlock unlimited\n" +, +                                "\t" + user + " hard memlock unlimited", +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +        logger.warn("Unable to lock JVM Memory: error=" + errno + ",reason=" + errMsg);, +        logger.warn("This can result in part of the JVM being swapped out.");, +                    String user = System.getProperty("user.name");, +                                "\t# allow user '" + user + "' mlockall\n" +, +                                "\t" + user + " soft memlock unlimited\n" +, +                                "\t" + user + " hard memlock unlimited", +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.common.inject.Module;, +                // plugin modules must be added here, before others or we can get crazy injection errors..., +                for (Module pluginModule : pluginsService.nodeModules()) {, +                    modules.add(pluginModule);, +                }, +                modules.add(new PluginsModule(pluginsService));, +                pluginsService.processModules(modules);, +, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +        logger.warn("Unable to lock JVM Memory: error=" + errno + ",reason=" + errMsg);, +        logger.warn("This can result in part of the JVM being swapped out.");, +                    String user = System.getProperty("user.name");, +                                "\t# allow user '" + user + "' mlockall\n" +, +                                "\t" + user + " soft memlock unlimited\n" +, +                                "\t" + user + " hard memlock unlimited", +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.common.inject.Module;, +                // plugin modules must be added here, before others or we can get crazy injection errors..., +                for (Module pluginModule : pluginsService.nodeModules()) {, +                    modules.add(pluginModule);, +                }, +                modules.add(new PluginsModule(pluginsService));, +                pluginsService.processModules(modules);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +import org.elasticsearch.index.shard.ShardId;, +        // use list here since we need to maintain identity across shards, +        ArrayList<ShardIterator> set = new ArrayList<>();, +        for (String index : indices) {, +            IndexRoutingTable indexRoutingTable = index(index);, +            if (indexRoutingTable == null) {, +                continue;, +                // we simply ignore indices that don't exists (make sense for operations that use it currently), +            }, +            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {, +                for (ShardRouting shardRouting : indexShardRoutingTable) {, +                    if (shardRouting.active()) {, +                        set.add(shardRouting.shardsIt());, +                        if (includeRelocationTargets && shardRouting.relocating()) {, +                            set.add(new PlainShardIterator(shardRouting.shardId(), Collections.singletonList(shardRouting.buildTargetRelocatingShard())));, +                        }, +                    } else if (includeEmpty) { // we need this for counting properly, just make it an empty one, +                        set.add(new PlainShardIterator(shardRouting.shardId(), Collections.<ShardRouting>emptyList()));, +                    }, +                }, +            }, +        }, +        return new GroupShardsIterator(set);, +                    if (shardRouting.assignedToNode()) {, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +        logger.warn("Unable to lock JVM Memory: error=" + errno + ",reason=" + errMsg);, +        logger.warn("This can result in part of the JVM being swapped out.");, +                    String user = System.getProperty("user.name");, +                                "\t# allow user '" + user + "' mlockall\n" +, +                                "\t" + user + " soft memlock unlimited\n" +, +                                "\t" + user + " hard memlock unlimited", +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.common.inject.Module;, +                // plugin modules must be added here, before others or we can get crazy injection errors..., +                for (Module pluginModule : pluginsService.nodeModules()) {, +                    modules.add(pluginModule);, +                }, +                modules.add(new PluginsModule(pluginsService));, +                pluginsService.processModules(modules);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +import org.elasticsearch.index.shard.ShardId;, +        // use list here since we need to maintain identity across shards, +        ArrayList<ShardIterator> set = new ArrayList<>();, +        for (String index : indices) {, +            IndexRoutingTable indexRoutingTable = index(index);, +            if (indexRoutingTable == null) {, +                continue;, +                // we simply ignore indices that don't exists (make sense for operations that use it currently), +            }, +            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {, +                for (ShardRouting shardRouting : indexShardRoutingTable) {, +                    if (shardRouting.active()) {, +                        set.add(shardRouting.shardsIt());, +                        if (includeRelocationTargets && shardRouting.relocating()) {, +                            set.add(new PlainShardIterator(shardRouting.shardId(), Collections.singletonList(shardRouting.buildTargetRelocatingShard())));, +                        }, +                    } else if (includeEmpty) { // we need this for counting properly, just make it an empty one, +                        set.add(new PlainShardIterator(shardRouting.shardId(), Collections.<ShardRouting>emptyList()));, +                    }]