[+++ b/plugins/river/twitter/src/main/java/org/elasticsearch/river/twitter/TwitterRiver.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.threadpool.ThreadPool;, +    private final ThreadPool threadPool;, +, +    private final String user;, +, +    private final String password;, +, +    private volatile TwitterStream stream;, +    private volatile boolean closed = false;, +, +    @Inject public TwitterRiver(RiverName riverName, RiverSettings settings, Client client, ThreadPool threadPool) {, +        this.threadPool = threadPool;, +        this.user = user;, +        this.password = password;, +    private void reconnect() {, +        if (closed) {, +            return;, +        }, +        try {, +            stream.cleanUp();, +        } catch (Exception e) {, +            logger.debug("failed to cleanup after failure", e);, +        }, +        try {, +            stream.shutdown();, +        } catch (Exception e) {, +            logger.debug("failed to shutdown after failure", e);, +        }, +        if (closed) {, +            return;, +        }, +, +        try {, +            stream = new TwitterStreamFactory().getInstance(user, password);, +            stream.addListener(new StatusHandler());, +, +            if (streamType.equals("filter") || filterQuery != null) {, +                try {, +                    stream.filter(filterQuery);, +                } catch (TwitterException e) {, +                    logger.warn("failed to create filter stream based on query, disabling river....");, +                }, +            } else if (streamType.equals("firehose")) {, +                stream.firehose(0);, +            } else {, +                stream.sample();, +            }, +        } catch (Exception e) {, +            if (closed) {, +                close();, +                return;, +            }, +            // TODO, we can update the status of the river to RECONNECT, +            logger.warn("failed to connect after failure, throttling", e);, +            threadPool.schedule(TimeValue.timeValueSeconds(10), ThreadPool.Names.CACHED, new Runnable() {, +                @Override public void run() {, +                    reconnect();, +                }, +            });, +        }, +    }, +, +        this.closed = true;, +            logger.info("received track limitation notice, number_of_limited_statuses {}", numberOfLimitedStatuses);, +            logger.warn("stream failure, restarting stream...", ex);, +            threadPool.cached().execute(new Runnable() {, +                @Override public void run() {, +                    reconnect();, +                }, +            });]