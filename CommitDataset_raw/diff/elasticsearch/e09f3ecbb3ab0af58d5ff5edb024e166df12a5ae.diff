[+++ b/core/src/main/java/org/elasticsearch/search/suggest/Suggest.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +, +            public static class Option implements Streamable, ToXContentObject {, +                public static final ParseField TEXT = new ParseField("text");, +                public static final ParseField HIGHLIGHTED = new ParseField("highlighted");, +                public static final ParseField SCORE = new ParseField("score");, +                public static final ParseField COLLATE_MATCH = new ParseField("collate_match");, +                    builder.field(TEXT.getPreferredName(), text);, +                        builder.field(HIGHLIGHTED.getPreferredName(), highlighted);, +                    builder.field(SCORE.getPreferredName(), score);, +                        builder.field(COLLATE_MATCH.getPreferredName(), collateMatch.booleanValue());, +                private static final ConstructingObjectParser<Option, Void> PARSER = new ConstructingObjectParser<>("SuggestOptionParser",, +                        true, args -> {, +                            Text text = new Text((String) args[0]);, +                            float score = (Float) args[1];, +                            String highlighted = (String) args[2];, +                            Text highlightedText = highlighted == null ? null : new Text(highlighted);, +                            Boolean collateMatch = (Boolean) args[3];, +                            return new Option(text, highlightedText, score, collateMatch);, +                        });, +, +                static {, +                    PARSER.declareString(constructorArg(), TEXT);, +                    PARSER.declareFloat(constructorArg(), SCORE);, +                    PARSER.declareString(optionalConstructorArg(), HIGHLIGHTED);, +                    PARSER.declareBoolean(optionalConstructorArg(), COLLATE_MATCH);, +                }, +, +                public static Option fromXContent(XContentParser parser) {, +                    return PARSER.apply(parser, null);, +                }, +, +++ b/core/src/main/java/org/elasticsearch/search/suggest/Suggest.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +, +            public static class Option implements Streamable, ToXContentObject {, +                public static final ParseField TEXT = new ParseField("text");, +                public static final ParseField HIGHLIGHTED = new ParseField("highlighted");, +                public static final ParseField SCORE = new ParseField("score");, +                public static final ParseField COLLATE_MATCH = new ParseField("collate_match");, +                    builder.field(TEXT.getPreferredName(), text);, +                        builder.field(HIGHLIGHTED.getPreferredName(), highlighted);, +                    builder.field(SCORE.getPreferredName(), score);, +                        builder.field(COLLATE_MATCH.getPreferredName(), collateMatch.booleanValue());, +                private static final ConstructingObjectParser<Option, Void> PARSER = new ConstructingObjectParser<>("SuggestOptionParser",, +                        true, args -> {, +                            Text text = new Text((String) args[0]);, +                            float score = (Float) args[1];, +                            String highlighted = (String) args[2];, +                            Text highlightedText = highlighted == null ? null : new Text(highlighted);, +                            Boolean collateMatch = (Boolean) args[3];, +                            return new Option(text, highlightedText, score, collateMatch);, +                        });, +, +                static {, +                    PARSER.declareString(constructorArg(), TEXT);, +                    PARSER.declareFloat(constructorArg(), SCORE);, +                    PARSER.declareString(optionalConstructorArg(), HIGHLIGHTED);, +                    PARSER.declareBoolean(optionalConstructorArg(), COLLATE_MATCH);, +                }, +, +                public static Option fromXContent(XContentParser parser) {, +                    return PARSER.apply(parser, null);, +                }, +, +++ b/core/src/main/java/org/elasticsearch/search/suggest/term/TermSuggestion.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.XContentParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +, +            public static final ParseField FREQ = new ParseField("freq");, +            public Option(Text text, int freq, float score) {, +                builder.field(FREQ.getPreferredName(), freq);, +, +            private static final ConstructingObjectParser<Option, Void> PARSER = new ConstructingObjectParser<>(, +                    "TermSuggestionOptionParser", true,, +                    args -> {, +                        Text text = new Text((String) args[0]);, +                        int freq = (Integer) args[1];, +                        float score = (Float) args[2];, +                        return new Option(text, freq, score);, +                    });, +, +            static {, +                PARSER.declareString(constructorArg(), Suggestion.Entry.Option.TEXT);, +                PARSER.declareInt(constructorArg(), FREQ);, +                PARSER.declareFloat(constructorArg(), Suggestion.Entry.Option.SCORE);, +            }]