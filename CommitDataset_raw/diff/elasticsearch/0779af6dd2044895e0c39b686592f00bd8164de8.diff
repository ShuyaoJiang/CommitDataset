[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = null;, +                try (Releasable ignore = versionMap.acquireLock(get.uid().bytes())) {, +                    // we need to lock here to access the version map to do this truly in RT, +                    versionValue = getVersionFromMap(get.uid().bytes());, +                }, +            try (Releasable ignored = versionMap.acquireLock(index.uid().bytes());, +        try (ReleasableLock ignored = readLock.acquire(); Releasable ignored2 = versionMap.acquireLock(delete.uid().bytes())) {, +            try (Releasable ignored = versionMap.acquireLock(uid)) {, +                // can we do it without this lock on each value? maybe batch to a set and get the lock once per set?, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = null;, +                try (Releasable ignore = versionMap.acquireLock(get.uid().bytes())) {, +                    // we need to lock here to access the version map to do this truly in RT, +                    versionValue = getVersionFromMap(get.uid().bytes());, +                }, +            try (Releasable ignored = versionMap.acquireLock(index.uid().bytes());, +        try (ReleasableLock ignored = readLock.acquire(); Releasable ignored2 = versionMap.acquireLock(delete.uid().bytes())) {, +            try (Releasable ignored = versionMap.acquireLock(uid)) {, +                // can we do it without this lock on each value? maybe batch to a set and get the lock once per set?, +++ b/core/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +    private final KeyedLock<BytesRef> keyedLock = new KeyedLock<>();, +, +    /**, +     * Bytes consumed for each BytesRef UID:, +     * instances)., +     */, +    /**, +     * Bytes used by having CHM point to a key/value., +     */, +, +    /**, +     * Tracks bytes used by current map, i.e. what is freed on refresh. For deletes, which are also added to tombstones, we only account, +     * for the CHM entry here, and account for BytesRef/VersionValue against the tombstones, since refresh would not clear this RAM., +     */, +    /**, +     * Tracks bytes used by tombstones (deletes), +     */, +    /**, +     * Returns the live version (add or delete) for this uid., +     */, +        assert keyedLock.isHeldByCurrentThread(uid);, +    /**, +     * Adds this uid/version to the pending adds map iff the map needs safe access., +     */, +        assert keyedLock.isHeldByCurrentThread(uid);, +    /**, +     * Adds this uid/version to the pending adds map., +     */, +    /**, +     * Adds this uid/version to the pending adds map., +     */, +        assert keyedLock.isHeldByCurrentThread(uid);, +    /**, +     * Removes this uid from the pending deletes map., +     */, +        assert keyedLock.isHeldByCurrentThread(uid);, +    /**, +     * Caller has a lock, so that this uid will not be concurrently added/deleted by another thread., +     */, +        assert keyedLock.isHeldByCurrentThread(uid);, +    /**, +     * Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones (exposed via reader but not yet GC'd)., +     */, +    /**, +     * clears all tombstones ops, +     */, +    /**, +     * Called when this index is closed., +     */, +    /**, +     * Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they, +     * don't clear on refresh., +     */, +    /**, +     * Returns the current internal versions as a point in time snapshot, +     */, +    }, +, +    /**, +     * Acquires a releaseable lock for the given uId. All *UnderLock methods require, +     * this lock to be hold by the caller otherwise the visibility guarantees of this version, +     * map are broken. We assert on this lock to be hold when calling these methods., +     * @see KeyedLock, +     */, +    Releasable acquireLock(BytesRef uid) {, +        return keyedLock.acquire(uid);, +    }, +}, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = null;, +                try (Releasable ignore = versionMap.acquireLock(get.uid().bytes())) {, +                    // we need to lock here to access the version map to do this truly in RT, +                    versionValue = getVersionFromMap(get.uid().bytes());, +                }, +            try (Releasable ignored = versionMap.acquireLock(index.uid().bytes());, +        try (ReleasableLock ignored = readLock.acquire(); Releasable ignored2 = versionMap.acquireLock(delete.uid().bytes())) {, +            try (Releasable ignored = versionMap.acquireLock(uid)) {]