[+++ b/src/main/java/org/elasticsearch/indices/store/IndicesStore.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.*;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.index.shard.IndexShardState;, +import org.elasticsearch.index.shard.service.IndexShard;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.transport.*;, +import java.io.IOException;, +import java.util.*;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final String ACTION_SHARD_EXISTS = "index/shard/exists";, +    private static final EnumSet<IndexShardState> ACTIVE_STATES = EnumSet.of(IndexShardState.STARTED, IndexShardState.RELOCATED);, +, +        transportService.registerHandler(ACTION_SHARD_EXISTS, new ShardActiveRequestHandler());, +    IndicesStore() {, +        super(ImmutableSettings.EMPTY);, +        nodeEnv = null;, +        nodeSettingsService = null;, +        indicesService = null;, +        this.clusterService = null;, +        this.transportService = null;, +    }, +, +                if (shardCanBeDeleted(event.state(), indexShardRoutingTable)) {, +                    IndexService indexService = indicesService.indexService(shardId.getIndex());, +                    if (indexService == null || !indexService.hasShard(shardId.getId())) {, +                        deleteShardIfExistElseWhere(event.state(), indexShardRoutingTable);, +                    }, +                }, +            }, +        }, +    }, +, +    boolean shardCanBeDeleted(ClusterState state, IndexShardRoutingTable indexShardRoutingTable) {, +            return false;, +        }, +, +                return false;, +            // if the allocated or relocation node id doesn't exists in the cluster state  it may be a stale node,, +            // make sure we don't do anything with this until the routing table has properly been rerouted to reflect, +            // the fact that the node does not exists, +            DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId());, +            if (node == null) {, +                return false;, +            }, +            // If all nodes have been upgraded to >= 1.3.0 at some point we get back here and have the chance to, +            // run this api. (when cluster state is then updated), +            if (node.getVersion().before(Version.V_1_3_0)) {, +                logger.debug("Skip deleting deleting shard instance [{}], a node holding a shard instance is < 1.3.0", shardRouting);, +                return false;, +                node = state.nodes().get(shardRouting.relocatingNodeId());, +                if (node == null) {, +                    return false;, +                }, +                if (node.getVersion().before(Version.V_1_3_0)) {, +                    logger.debug("Skip deleting deleting shard instance [{}], a node holding a shard instance is < 1.3.0", shardRouting);, +                    return false;, +            String localNodeId = state.getNodes().localNode().id();, +                return false;, +, +        return true;, +, +    private void deleteShardIfExistElseWhere(ClusterState state, IndexShardRoutingTable indexShardRoutingTable) {, +        List<Tuple<DiscoveryNode, ShardActiveRequest>> requests = new ArrayList<>(indexShardRoutingTable.size());, +        String indexUUID = state.getMetaData().index(indexShardRoutingTable.shardId().getIndex()).getUUID();, +        ClusterName clusterName = state.getClusterName();, +        for (ShardRouting shardRouting : indexShardRoutingTable) {, +            // Node can't be null, because otherwise shardCanBeDeleted() would have returned false, +            DiscoveryNode currentNode = state.nodes().get(shardRouting.currentNodeId());, +            assert currentNode != null;, +, +            requests.add(new Tuple<>(currentNode, new ShardActiveRequest(clusterName, indexUUID, shardRouting.shardId())));, +            if (shardRouting.relocatingNodeId() != null) {, +                DiscoveryNode relocatingNode = state.nodes().get(shardRouting.relocatingNodeId());, +                assert  relocatingNode != null;, +                requests.add(new Tuple<>(relocatingNode, new ShardActiveRequest(clusterName, indexUUID, shardRouting.shardId())));, +            }, +        }, +, +        ShardActiveResponseHandler responseHandler = new ShardActiveResponseHandler(indexShardRoutingTable.shardId(), state, requests.size());, +        for (Tuple<DiscoveryNode, ShardActiveRequest> request : requests) {, +            transportService.submitRequest(request.v1(), ACTION_SHARD_EXISTS, request.v2(), responseHandler);, +        }, +    }, +, +    private class ShardActiveResponseHandler implements TransportResponseHandler<ShardActiveResponse> {, +, +        private final ShardId shardId;, +        private final int expectedActiveCopies;, +        private final ClusterState clusterState;, +        private final AtomicInteger awaitingResponses;, +        private final AtomicInteger activeCopies;, +, +        public ShardActiveResponseHandler(ShardId shardId, ClusterState clusterState, int expectedActiveCopies) {, +            this.shardId = shardId;, +            this.expectedActiveCopies = expectedActiveCopies;]