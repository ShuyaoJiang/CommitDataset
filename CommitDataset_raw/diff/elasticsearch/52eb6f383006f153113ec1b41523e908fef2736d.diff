[+++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java, +        return new BestBucketsDeferringCollector(context());, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java, +        return new BestBucketsDeferringCollector(context());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Weight;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +    final AggregationContext aggContext;, +    public BestBucketsDeferringCollector(AggregationContext context) {, +        this.aggContext = context;, +        boolean needsScores = collector.needsScores();, +        Weight weight = null;, +        if (needsScores) {, +            weight = aggContext.searchContext().searcher(), +                        .createNormalizedWeight(aggContext.searchContext().query(), true);, +            DocIdSetIterator docIt = null;, +            if (needsScores && entry.docDeltas.size() > 0) {, +                Scorer scorer = weight.scorer(entry.context);, +                // We don't need to check if the scorer is null, +                // since we are sure that there are documents to replay (entry.docDeltas it not empty)., +                docIt = scorer.iterator();, +                leafCollector.setScorer(scorer);, +            }, +                if (needsScores) {, +                    if (docIt.docID() < doc) {, +                        docIt.advance(doc);, +                    }, +                    // aggregations should only be replayed on matching documents, +                    assert docIt.docID() == doc;, +                }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java, +        return new BestBucketsDeferringCollector(context());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Weight;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +    final AggregationContext aggContext;, +    public BestBucketsDeferringCollector(AggregationContext context) {, +        this.aggContext = context;, +        boolean needsScores = collector.needsScores();, +        Weight weight = null;, +        if (needsScores) {, +            weight = aggContext.searchContext().searcher(), +                        .createNormalizedWeight(aggContext.searchContext().query(), true);, +            DocIdSetIterator docIt = null;, +            if (needsScores && entry.docDeltas.size() > 0) {, +                Scorer scorer = weight.scorer(entry.context);, +                // We don't need to check if the scorer is null, +                // since we are sure that there are documents to replay (entry.docDeltas it not empty)., +                docIt = scorer.iterator();, +                leafCollector.setScorer(scorer);, +            }, +                if (needsScores) {, +                    if (docIt.docID() < doc) {, +                        docIt.advance(doc);, +                    }, +                    // aggregations should only be replayed on matching documents, +                    assert docIt.docID() == doc;, +                }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java, +        return new BestBucketsDeferringCollector(context());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Weight;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +    final AggregationContext aggContext;, +    public BestBucketsDeferringCollector(AggregationContext context) {, +        this.aggContext = context;, +        boolean needsScores = collector.needsScores();, +        Weight weight = null;, +        if (needsScores) {, +            weight = aggContext.searchContext().searcher(), +                        .createNormalizedWeight(aggContext.searchContext().query(), true);, +            DocIdSetIterator docIt = null;, +            if (needsScores && entry.docDeltas.size() > 0) {, +                Scorer scorer = weight.scorer(entry.context);, +                // We don't need to check if the scorer is null, +                // since we are sure that there are documents to replay (entry.docDeltas it not empty)., +                docIt = scorer.iterator();, +                leafCollector.setScorer(scorer);, +            }, +                if (needsScores) {, +                    if (docIt.docID() < doc) {, +                        docIt.advance(doc);, +                    }, +                    // aggregations should only be replayed on matching documents, +                    assert docIt.docID() == doc;, +                }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/metrics/TopHitsIT.java]