[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/realm/TransportClearRealmCacheAction.java, +import org.elasticsearch.xpack.security.authc.AuthenticationService;, +    private final AuthenticationService authenticationService;, +                                          ActionFilters actionFilters, Realms realms, AuthenticationService authenticationService) {, +        this.authenticationService = authenticationService;, +        clearAuthenticationServiceCache(nodeRequest.getUsernames());, +    private void clearAuthenticationServiceCache(String[] usernames) {, +        // this is heavy handed since we could also take realm into account but that would add, +        // complexity since we would need to iterate over the cache under a lock to remove all, +        // entries that referenced the specific realm, +        if (usernames != null && usernames.length != 0) {, +            for (String username : usernames) {, +                authenticationService.expire(username);, +            }, +        } else {, +            authenticationService.expireAll();, +        }, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/realm/TransportClearRealmCacheAction.java, +import org.elasticsearch.xpack.security.authc.AuthenticationService;, +    private final AuthenticationService authenticationService;, +                                          ActionFilters actionFilters, Realms realms, AuthenticationService authenticationService) {, +        this.authenticationService = authenticationService;, +        clearAuthenticationServiceCache(nodeRequest.getUsernames());, +    private void clearAuthenticationServiceCache(String[] usernames) {, +        // this is heavy handed since we could also take realm into account but that would add, +        // complexity since we would need to iterate over the cache under a lock to remove all, +        // entries that referenced the specific realm, +        if (usernames != null && usernames.length != 0) {, +            for (String username : usernames) {, +                authenticationService.expire(username);, +            }, +        } else {, +            authenticationService.expireAll();, +        }, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/AuthenticationService.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.settings.Setting.Property;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.xpack.security.support.SecurityIndexManager;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.concurrent.atomic.AtomicLong;, +import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;, +import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;, +, +    static final Setting<Boolean> SUCCESS_AUTH_CACHE_ENABLED =, +        Setting.boolSetting("xpack.security.authc.success_cache.enabled", true, Property.NodeScope);, +    private static final Setting<Integer> SUCCESS_AUTH_CACHE_MAX_SIZE =, +        Setting.intSetting("xpack.security.authc.success_cache.size", 10000, Property.NodeScope);, +    private static final Setting<TimeValue> SUCCESS_AUTH_CACHE_EXPIRE_AFTER_ACCESS =, +        Setting.timeSetting("xpack.security.authc.success_cache.expire_after_access", TimeValue.timeValueHours(1L), Property.NodeScope);, +    private final Cache<String, Realm> lastSuccessfulAuthCache;, +    private final AtomicLong numInvalidation = new AtomicLong();, +        if (SUCCESS_AUTH_CACHE_ENABLED.get(settings)) {, +            this.lastSuccessfulAuthCache = CacheBuilder.<String, Realm>builder(), +                .setMaximumWeight(Integer.toUnsignedLong(SUCCESS_AUTH_CACHE_MAX_SIZE.get(settings))), +                .setExpireAfterAccess(SUCCESS_AUTH_CACHE_EXPIRE_AFTER_ACCESS.get(settings)), +                .build();, +        } else {, +            this.lastSuccessfulAuthCache = null;, +        }, +    public void expire(String principal) {, +        if (lastSuccessfulAuthCache != null) {, +            numInvalidation.incrementAndGet();, +            lastSuccessfulAuthCache.invalidate(principal);, +        }, +    }, +, +    public void expireAll() {, +        if (lastSuccessfulAuthCache != null) {, +            numInvalidation.incrementAndGet();, +            lastSuccessfulAuthCache.invalidateAll();, +        }, +    }, +, +    public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {, +        if (lastSuccessfulAuthCache != null) {, +            if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)) {, +                expireAll();, +            }, +        }, +    }, +, +    // pkg private method for testing, +    long getNumInvalidation() {, +        return numInvalidation.get();, +    }, +, +                final List<Realm> realmsList = getRealmList(authenticationToken.principal());]