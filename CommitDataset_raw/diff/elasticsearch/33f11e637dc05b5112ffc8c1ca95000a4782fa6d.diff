[+++ b/docs/reference/rest-api/info.asciidoc, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            failShard("Failing shard because of exception during storeStats", e);, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            failShard("Failing shard because of exception during storeStats", e);, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.FilterDirectory;, +import org.elasticsearch.ElasticsearchException;, +import java.util.function.Supplier;, +, +    public void testShardStatsWithFailures() throws IOException {, +        allowShardFailures();, +        final ShardId shardId = new ShardId("index", "_na_", 0);, +        final ShardRouting shardRouting = newShardRouting(shardId, "node", true, RecoverySource.StoreRecoverySource.EMPTY_STORE_INSTANCE, ShardRoutingState.INITIALIZING);, +        final NodeEnvironment.NodePath nodePath = new NodeEnvironment.NodePath(createTempDir());, +, +, +        ShardPath shardPath = new ShardPath(false, nodePath.resolve(shardId), nodePath.resolve(shardId), shardId);, +        Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0), +                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +                .build();, +        IndexMetaData metaData = IndexMetaData.builder(shardRouting.getIndexName()), +                .settings(settings), +                .primaryTerm(0, 1), +                .build();, +, +        // Override two Directory methods to make them fail at our will, +        // We use AtomicReference here to inject failure in the middle of the test not immediately, +        // We use Supplier<IOException> instead of IOException to produce meaningful stacktrace, +        // (remember stack trace is filled when exception is instantiated), +        AtomicReference<Supplier<IOException>> exceptionToThrow = new AtomicReference<>();, +        AtomicBoolean throwWhenMarkingStoreCorrupted = new AtomicBoolean(false);, +        Directory directory = new FilterDirectory(newFSDirectory(shardPath.resolveIndex())) {, +            //fileLength method is called during storeStats try block, +            //it's not called when store is marked as corrupted, +            @Override, +            public long fileLength(String name) throws IOException {, +                Supplier<IOException> ex = exceptionToThrow.get();, +                if (ex == null) {, +                    return super.fileLength(name);, +                } else {, +                    throw ex.get();, +                }, +            }, +, +            //listAll method is called when marking store as corrupted, +            @Override, +            public String[] listAll() throws IOException {, +                Supplier<IOException> ex = exceptionToThrow.get();, +                if (throwWhenMarkingStoreCorrupted.get() && ex != null) {, +                    throw ex.get();, +                } else {, +                    return super.listAll();, +                }, +            }, +        };, +, +        try (Store store = createStore(shardId, new IndexSettings(metaData, Settings.EMPTY), directory)) {, +            IndexShard shard = newShard(shardRouting, shardPath, metaData, store,, +                    null, new InternalEngineFactory(), () -> {, +                    }, EMPTY_EVENT_LISTENER);, +            AtomicBoolean failureCallbackTriggered = new AtomicBoolean(false);, +            shard.addShardFailureCallback((ig)->failureCallbackTriggered.set(true));, +, +            recoverShardFromStore(shard);, +, +            final boolean corruptIndexException = randomBoolean();, +, +            if (corruptIndexException) {, +                exceptionToThrow.set(() -> new CorruptIndexException("Test CorruptIndexException", "Test resource"));, +                throwWhenMarkingStoreCorrupted.set(randomBoolean());, +            } else {, +                exceptionToThrow.set(() -> new IOException("Test IOException"));, +            }, +            ElasticsearchException e = expectThrows(ElasticsearchException.class, shard::storeStats);, +            assertTrue(failureCallbackTriggered.get());, +, +            if (corruptIndexException && !throwWhenMarkingStoreCorrupted.get()) {, +                assertTrue(store.isMarkedCorrupted());, +            }, +        }, +    }, +, +                null,, +                null,, +                null, null, indexShard.engineFactory, indexShard.getGlobalCheckpointSyncer(), EMPTY_EVENT_LISTENER);, +        IndexShard primary = newShard(shardRouting, shardPath, metaData, null, null, new InternalEngineFactory(), () -> {, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            failShard("Failing shard because of exception during storeStats", e);, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.FilterDirectory;, +import org.elasticsearch.ElasticsearchException;, +import java.util.function.Supplier;, +]