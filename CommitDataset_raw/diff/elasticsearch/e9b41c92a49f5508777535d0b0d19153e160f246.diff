[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private Long minDocCount;, +    public DateHistogramBuilder minDocCount(long minDocCount) {, +        this.minDocCount = minDocCount;, +        return this;, +    }, +, +        if (minDocCount != null) {, +            builder.field("min_doc_count", minDocCount);, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private Long minDocCount;, +    public DateHistogramBuilder minDocCount(long minDocCount) {, +        this.minDocCount = minDocCount;, +        return this;, +    }, +, +        if (minDocCount != null) {, +            builder.field("min_doc_count", minDocCount);, +        }, +, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/MinDocCountTests.java, +import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram;, +import org.joda.time.DateTime;, +import org.joda.time.format.DateTimeFormat;, +import static org.elasticsearch.search.aggregations.AggregationBuilders.*;, +        final Set<String> dateTerms = new HashSet<String>();, +            String dateTerm = DateTimeFormat.forPattern("yyyy-MM-dd").print(new DateTime(2014, 1, ((int) longTerm % 20) + 1, 0, 0));, +                indexRequests.add(client().prepareIndex("idx", "type").setSource(jsonBuilder(), +                        .startObject(), +                        .field("s", stringTerm), +                        .field("l", longTerm), +                        .field("d", doubleTerm), +                        .field("date", dateTerm), +                        .field("match", randomBoolean()), +                        .endObject()));, +    private void assertSubset(DateHistogram histo1, DateHistogram histo2, long minDocCount) {, +        final Iterator<DateHistogram.Bucket> it2 = histo2.iterator();, +        for (DateHistogram.Bucket b1 : histo1) {, +            if (b1.getDocCount() >= minDocCount) {, +                final DateHistogram.Bucket b2 = it2.next();, +                assertEquals(b1.getKey(), b2.getKey());, +                assertEquals(b1.getDocCount(), b2.getDocCount());, +            }, +        }, +    }, +, +    public void testDateHistogramCountAsc() throws Exception {, +        testMinDocCountOnDateHistogram(Histogram.Order.COUNT_ASC);, +    }, +, +    public void testDateHistogramCountDesc() throws Exception {, +        testMinDocCountOnDateHistogram(Histogram.Order.COUNT_DESC);, +    }, +, +    public void testDateHistogramKeyAsc() throws Exception {, +        testMinDocCountOnDateHistogram(Histogram.Order.KEY_ASC);, +    }, +, +    public void testDateHistogramKeyDesc() throws Exception {, +        testMinDocCountOnDateHistogram(Histogram.Order.KEY_DESC);, +    }, +, +    private void testMinDocCountOnDateHistogram(Histogram.Order order) throws Exception {, +        final int interval = randomIntBetween(1, 3);, +        final SearchResponse allResponse = client().prepareSearch("idx").setTypes("type"), +                .setSearchType(SearchType.COUNT), +                .setQuery(QUERY), +                .addAggregation(dateHistogram("histo").field("date").interval(DateHistogram.Interval.DAY).order(order).minDocCount(0)), +                .execute().actionGet();, +, +        final DateHistogram allHisto = allResponse.getAggregations().get("histo");, +, +        for (long minDocCount = 0; minDocCount < 50; ++minDocCount) {, +            final SearchResponse response = client().prepareSearch("idx").setTypes("type"), +                    .setSearchType(SearchType.COUNT), +                    .setQuery(QUERY), +                    .addAggregation(dateHistogram("histo").field("date").interval(DateHistogram.Interval.DAY).order(order).minDocCount(minDocCount)), +                    .execute().actionGet();, +            assertSubset(allHisto, (DateHistogram) response.getAggregations().get("histo"), minDocCount);, +        }, +, +    }, +]