[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import com.carrotsearch.hppc.cursors.IntObjectCursor;, +                builder.startObject(IndexMetaData.KEY_ACTIVE_ALLOCATIONS);, +                for (IntObjectCursor<Set<String>> cursor : indexMetaData.getActiveAllocationIds()) {, +                    builder.startArray(String.valueOf(cursor.key));, +                    for (String allocationId : cursor.value) {, +                        builder.value(allocationId);, +                    }, +                    builder.endArray();, +                }, +                builder.endObject();, +, +            this.metaData = routingResult.metaData();, +            customs = DiffableUtils.diff(before.customs, after.customs, DiffableUtils.getStringKeySerializer());, +            customs = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(),, +                    new DiffableUtils.DiffableValueSerializer<String, Custom>() {, +                public Custom read(StreamInput in, String key) throws IOException {, +                public Diff<Custom> readDiff(StreamInput in, String key) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import com.carrotsearch.hppc.cursors.IntObjectCursor;, +                builder.startObject(IndexMetaData.KEY_ACTIVE_ALLOCATIONS);, +                for (IntObjectCursor<Set<String>> cursor : indexMetaData.getActiveAllocationIds()) {, +                    builder.startArray(String.valueOf(cursor.key));, +                    for (String allocationId : cursor.value) {, +                        builder.value(allocationId);, +                    }, +                    builder.endArray();, +                }, +                builder.endObject();, +, +            this.metaData = routingResult.metaData();, +            customs = DiffableUtils.diff(before.customs, after.customs, DiffableUtils.getStringKeySerializer());, +            customs = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(),, +                    new DiffableUtils.DiffableValueSerializer<String, Custom>() {, +                public Custom read(StreamInput in, String key) throws IOException {, +                public Diff<Custom> readDiff(StreamInput in, String key) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import com.carrotsearch.hppc.cursors.IntObjectCursor;, +import org.elasticsearch.common.collect.ImmutableOpenIntMap;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +    public static final String KEY_ACTIVE_ALLOCATIONS = "active_allocations";, +, +    private final ImmutableOpenIntMap<Set<String>> activeAllocationIds;, +, +    private IndexMetaData(String index, long version, State state, int numberOfShards, int numberOfReplicas, Settings settings,, +                          ImmutableOpenMap<String, MappingMetaData> mappings, ImmutableOpenMap<String, AliasMetaData> aliases,, +                          ImmutableOpenMap<String, Custom> customs, ImmutableOpenIntMap<Set<String>> activeAllocationIds,, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                          Version indexCreatedVersion, Version indexUpgradedVersion, org.apache.lucene.util.Version minimumCompatibleLuceneVersion) {, +        this.settings = settings;, +        this.mappings = mappings;, +        this.customs = customs;, +        this.activeAllocationIds = activeAllocationIds;, +        this.requireFilters = requireFilters;, +        this.includeFilters = includeFilters;, +        this.excludeFilters = excludeFilters;, +        this.indexCreatedVersion = indexCreatedVersion;, +        this.indexUpgradedVersion = indexUpgradedVersion;, +        this.minimumCompatibleLuceneVersion = minimumCompatibleLuceneVersion;, +    public ImmutableOpenIntMap<Set<String>> getActiveAllocationIds() {, +        return activeAllocationIds;, +    }, +, +    public Set<String> activeAllocationIds(int shardId) {, +        assert shardId >= 0 && shardId < numberOfShards;, +        return activeAllocationIds.get(shardId);, +    }, +, +        if (!activeAllocationIds.equals(that.activeAllocationIds)) {, +            return false;, +        }, +        result = 31 * result + activeAllocationIds.hashCode();, +        private final Diff<ImmutableOpenMap<String, Custom>> customs;, +        private final Diff<ImmutableOpenIntMap<Set<String>>> activeAllocationIds;, +            mappings = DiffableUtils.diff(before.mappings, after.mappings, DiffableUtils.getStringKeySerializer());, +            aliases = DiffableUtils.diff(before.aliases, after.aliases, DiffableUtils.getStringKeySerializer());, +            customs = DiffableUtils.diff(before.customs, after.customs, DiffableUtils.getStringKeySerializer());, +            activeAllocationIds = DiffableUtils.diff(before.activeAllocationIds, after.activeAllocationIds,, +                    DiffableUtils.getVIntKeySerializer(), DiffableUtils.StringSetValueSerializer.getInstance());, +            mappings = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), MappingMetaData.PROTO);, +            aliases = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), AliasMetaData.PROTO);, +            customs = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(),, +                    new DiffableUtils.DiffableValueSerializer<String, Custom>() {, +                public Custom read(StreamInput in, String key) throws IOException {, +                public Diff<Custom> readDiff(StreamInput in, String key) throws IOException {, +            activeAllocationIds = DiffableUtils.readImmutableOpenIntMapDiff(in, DiffableUtils.getVIntKeySerializer(),, +                    DiffableUtils.StringSetValueSerializer.getInstance());, +            activeAllocationIds.writeTo(out);, +            builder.activeAllocationIds.putAll(activeAllocationIds.apply(part.activeAllocationIds));, +        int activeAllocationIdsSize = in.readVInt();, +        for (int i = 0; i < activeAllocationIdsSize; i++) {, +            int key = in.readVInt();, +            Set<String> allocationIds = DiffableUtils.StringSetValueSerializer.getInstance().read(in, key);, +            builder.putActiveAllocationIds(key, allocationIds);, +        }, +        out.writeVInt(activeAllocationIds.size());, +        for (IntObjectCursor<Set<String>> cursor : activeAllocationIds) {, +            out.writeVInt(cursor.key);]