[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +class DocumentParser implements Closeable {, +        ParsedDocument doc = parsedDocument(source, context, update(context, mapping));, +            Mapper update = parseObject(context, mapping.root, true);, +            if (update != null) {, +                context.addDynamicMappingsUpdate(update);, +            }, +    private static Mapping update(ParseContext.InternalParseContext context, Mapping mapping) {, +        Mapper rootDynamicUpdate = context.dynamicMappingsUpdate();, +        return rootDynamicUpdate != null ? mapping.mappingUpdate(rootDynamicUpdate) : null;, +    }, +, +    static ObjectMapper parseObject(ParseContext context, ObjectMapper mapper, boolean atRoot) throws IOException {, +            return null;, +            return null;, +        update = innerParseObject(context, mapper, parser, currentFieldName, token, update);, +        return update;, +    private static ObjectMapper innerParseObject(ParseContext context, ObjectMapper mapper, XContentParser parser, String currentFieldName, XContentParser.Token token, ObjectMapper update) throws IOException {, +            ObjectMapper newUpdate = null;, +                newUpdate = parseObject(context, mapper, currentFieldName);, +                newUpdate = parseArray(context, mapper, currentFieldName);, +                newUpdate = parseValue(context, mapper, currentFieldName, token);, +            if (newUpdate != null) {, +                if (update == null) {, +                    update = newUpdate;, +                } else {, +                    update = update.merge(newUpdate, false);, +        }, +        return update;, +    }, +    private static Mapper parseObjectOrField(ParseContext context, Mapper mapper) throws IOException {, +            return parseObject(context, (ObjectMapper) mapper, false);, +            return update;, +        if (currentFieldName == null) {, +            throw new MapperParsingException("object mapping [" + mapper.name() + "] trying to serialize an object with no field associated with it, current value [" + context.parser().textOrNull() + "]");, +        }, +            final Mapper subUpdate = parseObjectOrField(context, objectMapper);, +            if (subUpdate != null) {, +                // propagate mapping update, +                update = mapper.mappingUpdate(subUpdate);, +            }, +                update = mapper.mappingUpdate(parseAndMergeUpdate(objectMapper, context));, +    private static ObjectMapper parseArray(ParseContext context, ObjectMapper parentMapper, String lastFieldName) throws IOException {, +                final Mapper subUpdate = parseObjectOrField(context, mapper);, +                if (subUpdate != null) {, +                    // propagate the mapping update, +                    return parentMapper.mappingUpdate(subUpdate);, +                    return null;, +                }, +            } else {, +                return parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);, +                    return parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);, +                if (mapper != null && mapper instanceof ArrayValueMapperParser) {, +                    mapper = parseAndMergeUpdate(mapper, context);, +                    return parentMapper.mappingUpdate(mapper);, +                    return parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);, +                return parseNonDynamicArray(context, parentMapper, lastFieldName, arrayFieldName);, +    private static ObjectMapper parseNonDynamicArray(ParseContext context, ObjectMapper mapper, String lastFieldName, String arrayFieldName) throws IOException {, +                return parseObject(context, mapper, lastFieldName);, +                return parseArray(context, mapper, lastFieldName);, +                return parseValue(context, mapper, lastFieldName, token);, +        return null;, +    private static ObjectMapper parseValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {, +            Mapper subUpdate = parseObjectOrField(context, mapper);, +            if (subUpdate == null) {, +                return null;, +            }, +            return parentMapper.mappingUpdate(subUpdate);, +            return parseDynamicValue(context, parentMapper, currentFieldName, token);, +    private static ObjectMapper parseDynamicValue(final ParseContext context, ObjectMapper parentMapper, String currentFieldName, XContentParser.Token token) throws IOException {, +            return null;, +        mapper = parseAndMergeUpdate(mapper, context);, +, +        ObjectMapper update = null;, +        if (mapper != null) {, +            update = parentMapper.mappingUpdate(mapper);, +        }, +        return update;, +            String[] paths = Strings.splitStringToArray(field, '.');, +            String fieldName = paths[paths.length-1];, +            ObjectMapper update = parseDynamicValue(context, mapper, fieldName, context.parser().currentToken());, +            assert update != null; // we are parsing a dynamic value so we necessarily created a new mapping, +, +            if (paths.length > 1) {, +                for (int i = paths.length - 2; i >= 0; i--) {, +                    ObjectMapper parent = context.root();, +                    if (i > 0) {, +                        parent = mappers[i-1];, +                    assert parent != null;, +                    update = parent.mappingUpdate(update);, +                }, +            }, +            context.addDynamicMappingsUpdate(update);]