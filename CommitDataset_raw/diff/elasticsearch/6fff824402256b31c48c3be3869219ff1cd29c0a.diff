[+++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            settingsService.addListener(indexShard);, +                    settingsService.removeListener(indexShard);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            settingsService.addListener(indexShard);, +                    settingsService.removeListener(indexShard);, +++ b/core/src/main/java/org/elasticsearch/index/settings/IndexSettingsService.java, +    /**, +     * Returns <code>true</code> iff the given listener is already registered otherwise <code>false</code>, +     */, +    public boolean isRegistered(Listener listener) {, +        return listeners.contains(listener);, +    }, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            settingsService.addListener(indexShard);, +                    settingsService.removeListener(indexShard);, +++ b/core/src/main/java/org/elasticsearch/index/settings/IndexSettingsService.java, +    /**, +     * Returns <code>true</code> iff the given listener is already registered otherwise <code>false</code>, +     */, +    public boolean isRegistered(Listener listener) {, +        return listeners.contains(listener);, +    }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.settings.IndexSettings;, +public class IndexShard extends AbstractIndexShardComponent implements IndexSettingsService.Listener {, +    public IndexShard(ShardId shardId, @IndexSettings Settings indexSettings, IndicesLifecycle indicesLifecycle, Store store,, +                      ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService) {, +        super(shardId, indexSettings);, +     * Marks the shard as recovering based on a recovery state, fails with exception is recovering is not allowed to be set., +    public IndexShardState recovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(ShardRouting shard, DiscoveryNode localNode) {, +    public boolean restoreFromRepository(ShardRouting shard, IndexShardRepository repository, DiscoveryNode locaNode) {, +        return storeRecovery.recoverFromRepository(this, repository, locaNode);, +            int flushThresholdOperations = settings.getAsInt(INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS, this.flushThresholdOperations);, +            if (flushThresholdOperations != this.flushThresholdOperations) {, +                logger.info("updating flush_threshold_ops from [{}] to [{}]", this.flushThresholdOperations, flushThresholdOperations);, +                this.flushThresholdOperations = flushThresholdOperations;, +            ByteSizeValue flushThresholdSize = settings.getAsBytesSize(INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, this.flushThresholdSize);, +            if (!flushThresholdSize.equals(this.flushThresholdSize)) {, +                logger.info("updating flush_threshold_size from [{}] to [{}]", this.flushThresholdSize, flushThresholdSize);, +                this.flushThresholdSize = flushThresholdSize;, +            boolean disableFlush = settings.getAsBoolean(INDEX_TRANSLOG_DISABLE_FLUSH, this.disableFlush);, +            if (disableFlush != this.disableFlush) {, +                logger.info("updating disable_flush from [{}] to [{}]", this.disableFlush, disableFlush);, +                this.disableFlush = disableFlush;, +            final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, this.flushOnClose);, +            if (flushOnClose != this.flushOnClose) {, +                logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, this.flushOnClose, flushOnClose);, +                this.flushOnClose = flushOnClose;, +            TimeValue refreshInterval = settings.getAsTime(INDEX_REFRESH_INTERVAL, this.refreshInterval);, +            if (!refreshInterval.equals(this.refreshInterval)) {, +                logger.info("updating refresh_interval from [{}] to [{}]", this.refreshInterval, refreshInterval);, +                this.refreshInterval = refreshInterval;, +                threadPool, indexingService, indexSettings, warmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig,, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            settingsService.addListener(indexShard);, +                    settingsService.removeListener(indexShard);, +++ b/core/src/main/java/org/elasticsearch/index/settings/IndexSettingsService.java, +    /**, +     * Returns <code>true</code> iff the given listener is already registered otherwise <code>false</code>, +     */, +    public boolean isRegistered(Listener listener) {, +        return listeners.contains(listener);, +    }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.settings.IndexSettings;, +public class IndexShard extends AbstractIndexShardComponent implements IndexSettingsService.Listener {, +    public IndexShard(ShardId shardId, @IndexSettings Settings indexSettings, IndicesLifecycle indicesLifecycle, Store store,, +                      ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService) {, +        super(shardId, indexSettings);, +     * Marks the shard as recovering based on a recovery state, fails with exception is recovering is not allowed to be set., +    public IndexShardState recovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(ShardRouting shard, DiscoveryNode localNode) {, +    public boolean restoreFromRepository(ShardRouting shard, IndexShardRepository repository, DiscoveryNode locaNode) {, +        return storeRecovery.recoverFromRepository(this, repository, locaNode);, +            int flushThresholdOperations = settings.getAsInt(INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS, this.flushThresholdOperations);, +            if (flushThresholdOperations != this.flushThresholdOperations) {, +                logger.info("updating flush_threshold_ops from [{}] to [{}]", this.flushThresholdOperations, flushThresholdOperations);, +                this.flushThresholdOperations = flushThresholdOperations;, +            ByteSizeValue flushThresholdSize = settings.getAsBytesSize(INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, this.flushThresholdSize);, +            if (!flushThresholdSize.equals(this.flushThresholdSize)) {, +                logger.info("updating flush_threshold_size from [{}] to [{}]", this.flushThresholdSize, flushThresholdSize);, +                this.flushThresholdSize = flushThresholdSize;, +            boolean disableFlush = settings.getAsBoolean(INDEX_TRANSLOG_DISABLE_FLUSH, this.disableFlush);, +            if (disableFlush != this.disableFlush) {, +                logger.info("updating disable_flush from [{}] to [{}]", this.disableFlush, disableFlush);, +                this.disableFlush = disableFlush;, +            final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, this.flushOnClose);, +            if (flushOnClose != this.flushOnClose) {, +                logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, this.flushOnClose, flushOnClose);, +                this.flushOnClose = flushOnClose;, +            TimeValue refreshInterval = settings.getAsTime(INDEX_REFRESH_INTERVAL, this.refreshInterval);, +            if (!refreshInterval.equals(this.refreshInterval)) {, +                logger.info("updating refresh_interval from [{}] to [{}]", this.refreshInterval, refreshInterval);, +                this.refreshInterval = refreshInterval;]