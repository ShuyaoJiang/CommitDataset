[+++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.apache.lucene.index.LeafReader;, +    // TODO: do we really need to store all this stuff? some if it might not speed up anything., +    // we keep it around for now, to reduce the amount of e.g. hash lookups by field and stuff, +    /** terms enum for uid field */, +    private final TermsEnum termsEnum;, +    /** _version data */, +    private final NumericDocValues versions;, +    /** Only true when versions are indexed as payloads instead of docvalues */, +    private final boolean hasPayloads;, +    /** Reused for iteration (when the term exists) */, +    private PostingsEnum docsEnum;, +    /** Only used for back compat, to lookup a version from payload */, +    private PostingsEnum posEnum;, +    /**, +     * Initialize lookup for the provided segment, +     */, +    public PerThreadIDAndVersionLookup(LeafReader reader) throws IOException {, +        TermsEnum termsEnum = null;, +        NumericDocValues versions = null;, +        boolean hasPayloads = false;, +        Fields fields = reader.fields();, +                hasPayloads = terms.hasPayloads();, +                termsEnum = terms.iterator();, +                assert termsEnum != null;, +                versions = reader.getNumericDocValues(VersionFieldMapper.NAME);, +, +        this.versions = versions;, +        this.termsEnum = termsEnum;, +        this.hasPayloads = hasPayloads;, +    public DocIdAndVersion lookup(BytesRef id, Bits liveDocs, LeafReaderContext context) throws IOException {, +        if (termsEnum.seekExact(id)) {, +            if (versions != null || hasPayloads == false) {, +                docsEnum = termsEnum.postings(docsEnum, 0);, +                for (int d = docsEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = docsEnum.nextDoc()) {, +                    if (versions != null) {, +                        return new DocIdAndVersion(docID, versions.get(docID), context);, +                        return new DocIdAndVersion(docID, Versions.NOT_SET, context);, +            posEnum = termsEnum.postings(posEnum, PostingsEnum.PAYLOADS);, +            assert posEnum != null; // terms has payloads, +            for (int d = posEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = posEnum.nextDoc()) {, +                posEnum.nextPosition();, +                final BytesRef payload = posEnum.getPayload();, +                    return new DocIdAndVersion(d, Numbers.bytesToLong(payload), context);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.apache.lucene.index.LeafReader;, +    // TODO: do we really need to store all this stuff? some if it might not speed up anything., +    // we keep it around for now, to reduce the amount of e.g. hash lookups by field and stuff, +    /** terms enum for uid field */, +    private final TermsEnum termsEnum;, +    /** _version data */, +    private final NumericDocValues versions;, +    /** Only true when versions are indexed as payloads instead of docvalues */, +    private final boolean hasPayloads;, +    /** Reused for iteration (when the term exists) */, +    private PostingsEnum docsEnum;, +    /** Only used for back compat, to lookup a version from payload */, +    private PostingsEnum posEnum;, +    /**, +     * Initialize lookup for the provided segment, +     */, +    public PerThreadIDAndVersionLookup(LeafReader reader) throws IOException {, +        TermsEnum termsEnum = null;, +        NumericDocValues versions = null;, +        boolean hasPayloads = false;, +        Fields fields = reader.fields();, +                hasPayloads = terms.hasPayloads();, +                termsEnum = terms.iterator();, +                assert termsEnum != null;, +                versions = reader.getNumericDocValues(VersionFieldMapper.NAME);, +, +        this.versions = versions;, +        this.termsEnum = termsEnum;, +        this.hasPayloads = hasPayloads;, +    public DocIdAndVersion lookup(BytesRef id, Bits liveDocs, LeafReaderContext context) throws IOException {, +        if (termsEnum.seekExact(id)) {, +            if (versions != null || hasPayloads == false) {, +                docsEnum = termsEnum.postings(docsEnum, 0);, +                for (int d = docsEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = docsEnum.nextDoc()) {, +                    if (versions != null) {, +                        return new DocIdAndVersion(docID, versions.get(docID), context);, +                        return new DocIdAndVersion(docID, Versions.NOT_SET, context);, +            posEnum = termsEnum.postings(posEnum, PostingsEnum.PAYLOADS);, +            assert posEnum != null; // terms has payloads, +            for (int d = posEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = posEnum.nextDoc()) {, +                posEnum.nextPosition();, +                final BytesRef payload = posEnum.getPayload();, +                    return new DocIdAndVersion(d, Numbers.bytesToLong(payload), context);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/Versions.java, +import org.apache.lucene.index.LeafReader;, +import org.apache.lucene.index.LeafReader.CoreClosedListener;, +import java.util.List;, +     * see {@link PerThreadIDAndVersionLookup#lookup}, +    static final ConcurrentMap<Object, CloseableThreadLocal<PerThreadIDAndVersionLookup>> lookupStates = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();, +    private static final CoreClosedListener removeLookupState = new CoreClosedListener() {, +        public void onClose(Object key) {, +            CloseableThreadLocal<PerThreadIDAndVersionLookup> ctl = lookupStates.remove(key);, +    private static PerThreadIDAndVersionLookup getLookupState(LeafReader reader) throws IOException {, +        Object key = reader.getCoreCacheKey();, +        CloseableThreadLocal<PerThreadIDAndVersionLookup> ctl = lookupStates.get(key);]