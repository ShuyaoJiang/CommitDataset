[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import java.util.Locale;, +                        patternsForTheSameRemoteCluster, remoteClusterState.metaData(), resultHandler);, +                                            MetaData remoteMetadata,, +                    final Settings leaderIndexSettings = remoteMetadata.getIndexSafe(indexToFollow).getSettings();, +                    if (leaderIndexSettings.getAsBoolean(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(),, +                        IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(leaderIndexSettings).onOrAfter(Version.V_7_0_0)) == false) {, +, +                        String message = String.format(Locale.ROOT, "index [%s] cannot be followed, because soft deletes are not enabled",, +                            indexToFollow.getName());, +                        LOGGER.warn(message);, +                        updateAutoFollowMetadata(recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow), error -> {, +                            ElasticsearchException failure = new ElasticsearchException(message);, +                            if (error != null) {, +                                failure.addSuppressed(error);, +                            }, +                            results.set(slot, new Tuple<>(indexToFollow, failure));, +                            if (leaderIndicesCountDown.countDown()) {, +                                resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList()));, +                            }, +                        });, +                        continue;, +                    }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import java.util.Locale;, +                        patternsForTheSameRemoteCluster, remoteClusterState.metaData(), resultHandler);, +                                            MetaData remoteMetadata,, +                    final Settings leaderIndexSettings = remoteMetadata.getIndexSafe(indexToFollow).getSettings();, +                    if (leaderIndexSettings.getAsBoolean(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(),, +                        IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(leaderIndexSettings).onOrAfter(Version.V_7_0_0)) == false) {, +, +                        String message = String.format(Locale.ROOT, "index [%s] cannot be followed, because soft deletes are not enabled",, +                            indexToFollow.getName());, +                        LOGGER.warn(message);, +                        updateAutoFollowMetadata(recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow), error -> {, +                            ElasticsearchException failure = new ElasticsearchException(message);, +                            if (error != null) {, +                                failure.addSuppressed(error);, +                            }, +                            results.set(slot, new Tuple<>(indexToFollow, failure));, +                            if (leaderIndicesCountDown.countDown()) {, +                                resultHandler.accept(new AutoFollowResult(autoFollowPattenName, results.asList()));, +                            }, +                        });, +                        continue;, +                    }, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/AutoFollowIT.java, +    public void testAutoFollowSoftDeletesDisabled() throws Exception {, +        putAutoFollowPatterns("my-pattern1", new String[] {"logs-*"});, +, +        // Soft deletes are disabled:, +        Settings leaderIndexSettings = Settings.builder(), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false), +            .put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1), +            .put(IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0), +            .build();, +        createLeaderIndex("logs-20200101", leaderIndexSettings);, +        assertBusy(() -> {, +            AutoFollowStats autoFollowStats = getAutoFollowStats();, +            assertThat(autoFollowStats.getNumberOfSuccessfulFollowIndices(), equalTo(0L));, +            assertThat(autoFollowStats.getNumberOfFailedFollowIndices(), equalTo(1L));, +            assertThat(autoFollowStats.getRecentAutoFollowErrors().size(), equalTo(1));, +            ElasticsearchException failure  = autoFollowStats.getRecentAutoFollowErrors().firstEntry().getValue();, +            assertThat(failure.getMessage(), equalTo("index [logs-20200101] cannot be followed, " +, +                "because soft deletes are not enabled"));, +            IndicesExistsRequest request = new IndicesExistsRequest("copy-logs-20200101");, +            assertFalse(followerClient().admin().indices().exists(request).actionGet().isExists());, +        });, +, +        // Soft deletes are enabled:, +        leaderIndexSettings = Settings.builder(), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true), +            .put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1), +            .put(IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0), +            .build();, +        createLeaderIndex("logs-20200102", leaderIndexSettings);, +        assertBusy(() -> {, +            AutoFollowStats autoFollowStats = getAutoFollowStats();, +            assertThat(autoFollowStats.getNumberOfSuccessfulFollowIndices(), equalTo(1L));, +            IndicesExistsRequest request = new IndicesExistsRequest("copy-logs-20200102");, +            assertTrue(followerClient().admin().indices().exists(request).actionGet().isExists());, +        });, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import java.util.Locale;, +                        patternsForTheSameRemoteCluster, remoteClusterState.metaData(), resultHandler);, +                                            MetaData remoteMetadata,, +                    final Settings leaderIndexSettings = remoteMetadata.getIndexSafe(indexToFollow).getSettings();, +                    if (leaderIndexSettings.getAsBoolean(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(),, +                        IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(leaderIndexSettings).onOrAfter(Version.V_7_0_0)) == false) {, +, +                        String message = String.format(Locale.ROOT, "index [%s] cannot be followed, because soft deletes are not enabled",, +                            indexToFollow.getName());, +                        LOGGER.warn(message);, +                        updateAutoFollowMetadata(recordLeaderIndexAsFollowFunction(autoFollowPattenName, indexToFollow), error -> {, +                            ElasticsearchException failure = new ElasticsearchException(message);, +                            if (error != null) {, +                                failure.addSuppressed(error);, +                            }]