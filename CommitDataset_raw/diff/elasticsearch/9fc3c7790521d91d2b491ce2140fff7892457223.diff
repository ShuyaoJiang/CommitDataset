[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/manager/JobManager.java, +, +            if (!allocation.getStatus().isAnyOf(JobStatus.CLOSED, JobStatus.PAUSED, JobStatus.FAILED)) {, +                throw ExceptionsHelper.conflictStatusException(Messages.getMessage(, +                        Messages.JOB_CANNOT_DELETE_WHILE_RUNNING, jobId, allocation.getStatus()));, +            }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/manager/JobManager.java, +, +            if (!allocation.getStatus().isAnyOf(JobStatus.CLOSED, JobStatus.PAUSED, JobStatus.FAILED)) {, +                throw ExceptionsHelper.conflictStatusException(Messages.getMessage(, +                        Messages.JOB_CANNOT_DELETE_WHILE_RUNNING, jobId, allocation.getStatus()));, +            }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/messages/Messages.java, +    public static final String JOB_CANNOT_DELETE_WHILE_RUNNING = "job.cannot.delete.while.running";, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/manager/JobManager.java, +, +            if (!allocation.getStatus().isAnyOf(JobStatus.CLOSED, JobStatus.PAUSED, JobStatus.FAILED)) {, +                throw ExceptionsHelper.conflictStatusException(Messages.getMessage(, +                        Messages.JOB_CANNOT_DELETE_WHILE_RUNNING, jobId, allocation.getStatus()));, +            }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/messages/Messages.java, +    public static final String JOB_CANNOT_DELETE_WHILE_RUNNING = "job.cannot.delete.while.running";, +++ b/elasticsearch/src/main/resources/org/elasticsearch/xpack/prelert/job/messages/prelert_messages.properties, +job.cannot.delete.while.running = Cannot delete job ''{0}'' while it is {1}, +job.cannot.delete.while.scheduler.runs = Cannot delete job ''{0}'' while the scheduler is running, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/manager/JobManager.java, +, +            if (!allocation.getStatus().isAnyOf(JobStatus.CLOSED, JobStatus.PAUSED, JobStatus.FAILED)) {, +                throw ExceptionsHelper.conflictStatusException(Messages.getMessage(, +                        Messages.JOB_CANNOT_DELETE_WHILE_RUNNING, jobId, allocation.getStatus()));, +            }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/messages/Messages.java, +    public static final String JOB_CANNOT_DELETE_WHILE_RUNNING = "job.cannot.delete.while.running";, +++ b/elasticsearch/src/main/resources/org/elasticsearch/xpack/prelert/job/messages/prelert_messages.properties, +job.cannot.delete.while.running = Cannot delete job ''{0}'' while it is {1}, +job.cannot.delete.while.scheduler.runs = Cannot delete job ''{0}'' while the scheduler is running, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/integration/ScheduledJobIT.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.ElasticsearchStatusException;, +        ResponseException e = expectThrows(ResponseException.class,, +                () -> client().performRequest("delete", PrelertPlugin.BASE_PATH + "jobs/scheduled"));, +        response = e.getResponse();, +        assertThat(response.getStatusLine().getStatusCode(), equalTo(409));, +        assertThat(responseEntityToString(response), containsString("Cannot delete job 'scheduled' while the scheduler is running"));, +, +        response = client().performRequest("delete", PrelertPlugin.BASE_PATH + "jobs/scheduled");, +        assertThat(response.getStatusLine().getStatusCode(), equalTo(200));, +        assertThat(responseEntityToString(response), equalTo("{\"acknowledged\":true}"));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/manager/JobManager.java, +, +            if (!allocation.getStatus().isAnyOf(JobStatus.CLOSED, JobStatus.PAUSED, JobStatus.FAILED)) {, +                throw ExceptionsHelper.conflictStatusException(Messages.getMessage(, +                        Messages.JOB_CANNOT_DELETE_WHILE_RUNNING, jobId, allocation.getStatus()));, +            }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/messages/Messages.java, +    public static final String JOB_CANNOT_DELETE_WHILE_RUNNING = "job.cannot.delete.while.running";, +++ b/elasticsearch/src/main/resources/org/elasticsearch/xpack/prelert/job/messages/prelert_messages.properties, +job.cannot.delete.while.running = Cannot delete job ''{0}'' while it is {1}, +job.cannot.delete.while.scheduler.runs = Cannot delete job ''{0}'' while the scheduler is running, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/integration/ScheduledJobIT.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.ElasticsearchStatusException;, +        ResponseException e = expectThrows(ResponseException.class,, +                () -> client().performRequest("delete", PrelertPlugin.BASE_PATH + "jobs/scheduled"));, +        response = e.getResponse();, +        assertThat(response.getStatusLine().getStatusCode(), equalTo(409));, +        assertThat(responseEntityToString(response), containsString("Cannot delete job 'scheduled' while the scheduler is running"));, +, +        response = client().performRequest("delete", PrelertPlugin.BASE_PATH + "jobs/scheduled");, +        assertThat(response.getStatusLine().getStatusCode(), equalTo(200));, +        assertThat(responseEntityToString(response), equalTo("{\"acknowledged\":true}"));, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/job/manager/JobManagerTests.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.xpack.prelert.job.JobSchedulerStatus;, +import org.elasticsearch.xpack.prelert.job.JobStatus;, +import org.elasticsearch.xpack.prelert.job.SchedulerState;, +import org.elasticsearch.xpack.prelert.job.metadata.Allocation;, +    public void testRemoveJobFromClusterState_GivenJobIsRunning() {, +        JobManager jobManager = createJobManager();, +        ClusterState clusterState = createClusterState();, +        Job job = buildJobBuilder("foo").build();, +        clusterState = jobManager.innerPutJob(job, false, clusterState);, +        Allocation.Builder allocation = new Allocation.Builder();, +        allocation.setNodeId("myNode");, +        allocation.setJobId(job.getId());, +        allocation.setStatus(JobStatus.RUNNING);, +        PrelertMetadata.Builder newMetadata = new PrelertMetadata.Builder(clusterState.metaData().custom(PrelertMetadata.TYPE));, +        newMetadata.putAllocation("myNode", job.getId());, +        newMetadata.updateAllocation(job.getId(), allocation.build());, +, +        ClusterState jobRunningClusterState = new ClusterState.Builder(clusterState), +                .metaData(MetaData.builder().putCustom(PrelertMetadata.TYPE, newMetadata.build())).build();, +, +        ElasticsearchStatusException e = expectThrows(ElasticsearchStatusException.class,, +                () -> jobManager.removeJobFromClusterState("foo", jobRunningClusterState));, +        assertThat(e.status(), equalTo(RestStatus.CONFLICT));, +        assertThat(e.getMessage(), equalTo("Cannot delete job 'foo' while it is RUNNING"));, +    }, +]