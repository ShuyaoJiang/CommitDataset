[+++ b/src/main/java/org/elasticsearch/action/admin/indices/template/put/PutIndexTemplateRequest.java, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +    private Map<String, IndexMetaData.Custom> customs = newHashMap();, +, +        for (Map.Entry<String, Object> entry : source.entrySet()) {, +            String name = entry.getKey();, +            if (name.equals("template")) {, +                template(entry.getValue().toString());, +            } else if (name.equals("order")) {, +                order(XContentMapValues.nodeIntegerValue(entry.getValue(), order()));, +            } else if (name.equals("settings")) {, +                if (!(entry.getValue() instanceof Map)) {, +                settings((Map<String, Object>) entry.getValue());, +            } else if (name.equals("mappings")) {, +                Map<String, Object> mappings = (Map<String, Object>) entry.getValue();, +                for (Map.Entry<String, Object> entry1 : mappings.entrySet()) {, +                    if (!(entry1.getValue() instanceof Map)) {, +                        throw new ElasticSearchIllegalArgumentException("Malformed mappings section for type [" + entry1.getKey() + "], should include an inner object describing the mapping");, +                    mapping(entry1.getKey(), (Map<String, Object>) entry1.getValue());, +            } else {, +                // maybe custom?, +                IndexMetaData.Custom.Factory factory = IndexMetaData.lookupFactory(name);, +                if (factory != null) {, +                    try {, +                        customs.put(name, factory.fromMap((Map<String, Object>) entry.getValue()));, +                    } catch (IOException e) {, +                        throw new ElasticSearchParseException("failed to parse custom metadata for [" + name + "]");, +                    }, +                }, +    public PutIndexTemplateRequest custom(IndexMetaData.Custom custom) {, +        customs.put(custom.type(), custom);, +        return this;, +    }, +, +    Map<String, IndexMetaData.Custom> customs() {, +        return this.customs;, +    }, +, +        int customSize = in.readVInt();, +        for (int i = 0; i < customSize; i++) {, +            String type = in.readUTF();, +            IndexMetaData.Custom customIndexMetaData = IndexMetaData.lookupFactorySafe(type).readFrom(in);, +            customs.put(type, customIndexMetaData);, +        }, +        out.writeVInt(customs.size());, +        for (Map.Entry<String, IndexMetaData.Custom> entry : customs.entrySet()) {, +            out.writeUTF(entry.getKey());, +            IndexMetaData.lookupFactorySafe(entry.getKey()).writeTo(entry.getValue(), out);, +        }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/template/put/PutIndexTemplateRequest.java, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +    private Map<String, IndexMetaData.Custom> customs = newHashMap();, +, +        for (Map.Entry<String, Object> entry : source.entrySet()) {, +            String name = entry.getKey();, +            if (name.equals("template")) {, +                template(entry.getValue().toString());, +            } else if (name.equals("order")) {, +                order(XContentMapValues.nodeIntegerValue(entry.getValue(), order()));, +            } else if (name.equals("settings")) {, +                if (!(entry.getValue() instanceof Map)) {, +                settings((Map<String, Object>) entry.getValue());, +            } else if (name.equals("mappings")) {, +                Map<String, Object> mappings = (Map<String, Object>) entry.getValue();, +                for (Map.Entry<String, Object> entry1 : mappings.entrySet()) {, +                    if (!(entry1.getValue() instanceof Map)) {, +                        throw new ElasticSearchIllegalArgumentException("Malformed mappings section for type [" + entry1.getKey() + "], should include an inner object describing the mapping");, +                    mapping(entry1.getKey(), (Map<String, Object>) entry1.getValue());, +            } else {, +                // maybe custom?, +                IndexMetaData.Custom.Factory factory = IndexMetaData.lookupFactory(name);, +                if (factory != null) {, +                    try {, +                        customs.put(name, factory.fromMap((Map<String, Object>) entry.getValue()));, +                    } catch (IOException e) {, +                        throw new ElasticSearchParseException("failed to parse custom metadata for [" + name + "]");, +                    }, +                }, +    public PutIndexTemplateRequest custom(IndexMetaData.Custom custom) {, +        customs.put(custom.type(), custom);, +        return this;, +    }, +, +    Map<String, IndexMetaData.Custom> customs() {, +        return this.customs;, +    }, +, +        int customSize = in.readVInt();, +        for (int i = 0; i < customSize; i++) {, +            String type = in.readUTF();, +            IndexMetaData.Custom customIndexMetaData = IndexMetaData.lookupFactorySafe(type).readFrom(in);, +            customs.put(type, customIndexMetaData);, +        }, +        out.writeVInt(customs.size());, +        for (Map.Entry<String, IndexMetaData.Custom> entry : customs.entrySet()) {, +            out.writeUTF(entry.getKey());, +            IndexMetaData.lookupFactorySafe(entry.getKey()).writeTo(entry.getValue(), out);, +        }]