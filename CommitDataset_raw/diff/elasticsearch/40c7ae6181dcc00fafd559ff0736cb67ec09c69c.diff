[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String resolvedType = resolveType(sourceToParse.type());, +            final SourceToParse sourceWithResolvedType;, +            if (resolvedType.equals(sourceToParse.type())) {, +                sourceWithResolvedType = sourceToParse;, +            } else {, +                sourceWithResolvedType = SourceToParse.source(sourceToParse.index(), resolvedType, sourceToParse.id(),, +                    sourceToParse.source(), sourceToParse.getXContentType());, +                sourceWithResolvedType.routing(sourceToParse.routing());, +            }, +            operation = prepareIndex(docMapper(resolvedType), indexSettings.getIndexVersionCreated(), sourceWithResolvedType,, +                seqNo, opPrimaryTerm, version, versionType, origin, autoGeneratedTimeStamp, isRetry, ifSeqNo, ifPrimaryTerm);, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String resolvedType = resolveType(sourceToParse.type());, +            final SourceToParse sourceWithResolvedType;, +            if (resolvedType.equals(sourceToParse.type())) {, +                sourceWithResolvedType = sourceToParse;, +            } else {, +                sourceWithResolvedType = SourceToParse.source(sourceToParse.index(), resolvedType, sourceToParse.id(),, +                    sourceToParse.source(), sourceToParse.getXContentType());, +                sourceWithResolvedType.routing(sourceToParse.routing());, +            }, +            operation = prepareIndex(docMapper(resolvedType), indexSettings.getIndexVersionCreated(), sourceWithResolvedType,, +                seqNo, opPrimaryTerm, version, versionType, origin, autoGeneratedTimeStamp, isRetry, ifSeqNo, ifPrimaryTerm);, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java, +import org.elasticsearch.index.translog.TestTranslog;, +    public void testShardChangesWithDefaultDocType() throws Exception {, +        Settings settings = Settings.builder(), +            .put("index.number_of_shards", 1), +            .put("index.number_of_replicas", 0), +            .put("index.translog.flush_threshold_size", "512mb") // do not flush, +            .put("index.soft_deletes.enabled", true).build();, +        IndexService indexService = createIndex("index", settings, "user_doc", "title", "type=keyword");, +        int numOps = between(1, 10);, +        for (int i = 0; i < numOps; i++) {, +            if (randomBoolean()) {, +                client().prepareIndex("index", randomFrom("_doc", "user_doc"), randomFrom("1", "2")), +                    .setSource("{}", XContentType.JSON).get();, +            } else {, +                client().prepareDelete("index", randomFrom("_doc", "user_doc"), randomFrom("1", "2")).get();, +            }, +        }, +        IndexShard shard = indexService.getShard(0);, +        try (Translog.Snapshot luceneSnapshot = shard.newChangesSnapshot("test", 0, numOps - 1, true);, +             Translog.Snapshot translogSnapshot = getTranslog(shard).newSnapshot()) {, +            List<Translog.Operation> opsFromLucene = TestTranslog.drainSnapshot(luceneSnapshot, true);, +            List<Translog.Operation> opsFromTranslog = TestTranslog.drainSnapshot(translogSnapshot, true);, +            assertThat(opsFromLucene, equalTo(opsFromTranslog));, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String resolvedType = resolveType(sourceToParse.type());, +            final SourceToParse sourceWithResolvedType;, +            if (resolvedType.equals(sourceToParse.type())) {, +                sourceWithResolvedType = sourceToParse;, +            } else {, +                sourceWithResolvedType = SourceToParse.source(sourceToParse.index(), resolvedType, sourceToParse.id(),, +                    sourceToParse.source(), sourceToParse.getXContentType());, +                sourceWithResolvedType.routing(sourceToParse.routing());, +            }, +            operation = prepareIndex(docMapper(resolvedType), indexSettings.getIndexVersionCreated(), sourceWithResolvedType,, +                seqNo, opPrimaryTerm, version, versionType, origin, autoGeneratedTimeStamp, isRetry, ifSeqNo, ifPrimaryTerm);, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java, +import org.elasticsearch.index.translog.TestTranslog;, +    public void testShardChangesWithDefaultDocType() throws Exception {, +        Settings settings = Settings.builder(), +            .put("index.number_of_shards", 1), +            .put("index.number_of_replicas", 0), +            .put("index.translog.flush_threshold_size", "512mb") // do not flush, +            .put("index.soft_deletes.enabled", true).build();, +        IndexService indexService = createIndex("index", settings, "user_doc", "title", "type=keyword");, +        int numOps = between(1, 10);, +        for (int i = 0; i < numOps; i++) {, +            if (randomBoolean()) {, +                client().prepareIndex("index", randomFrom("_doc", "user_doc"), randomFrom("1", "2")), +                    .setSource("{}", XContentType.JSON).get();, +            } else {, +                client().prepareDelete("index", randomFrom("_doc", "user_doc"), randomFrom("1", "2")).get();, +            }, +        }, +        IndexShard shard = indexService.getShard(0);, +        try (Translog.Snapshot luceneSnapshot = shard.newChangesSnapshot("test", 0, numOps - 1, true);, +             Translog.Snapshot translogSnapshot = getTranslog(shard).newSnapshot()) {, +            List<Translog.Operation> opsFromLucene = TestTranslog.drainSnapshot(luceneSnapshot, true);, +            List<Translog.Operation> opsFromTranslog = TestTranslog.drainSnapshot(translogSnapshot, true);, +            assertThat(opsFromLucene, equalTo(opsFromTranslog));, +        }, +    }, +++ b/server/src/test/java/org/elasticsearch/index/translog/TestTranslog.java, +import java.util.ArrayList;, +import java.util.Comparator;, +, +    public static List<Translog.Operation> drainSnapshot(Translog.Snapshot snapshot, boolean sortBySeqNo) throws IOException {, +        final List<Translog.Operation> ops = new ArrayList<>(snapshot.totalOperations());, +        Translog.Operation op;, +        while ((op = snapshot.next()) != null) {, +            ops.add(op);, +        }, +        if (sortBySeqNo) {, +            ops.sort(Comparator.comparing(Translog.Operation::seqNo));]