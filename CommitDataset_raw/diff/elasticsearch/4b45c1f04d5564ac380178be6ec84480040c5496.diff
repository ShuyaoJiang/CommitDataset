[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/DataFrameMessages.java, +    public static final String FAILED_TO_PARSE_TRANSFORM_CHECKPOINTS =, +            "Failed to parse transform checkpoints for [{0}]";, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/DataFrameMessages.java, +    public static final String FAILED_TO_PARSE_TRANSFORM_CHECKPOINTS =, +            "Failed to parse transform checkpoints for [{0}]";, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/transforms/DataFrameTransformCheckpoint.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +, +package org.elasticsearch.xpack.core.dataframe.transforms;, +, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.xpack.core.dataframe.DataFrameField;, +, +import java.io.IOException;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.Map;, +import java.util.Map.Entry;, +import java.util.Objects;, +import java.util.TreeMap;, +, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +, +/**, + * Checkpoint document to store the checkpoint of a data frame transform, + *, + * The fields:, + *, + *  timestamp the timestamp when this document has been created, + *  checkpoint the checkpoint number, incremented for every checkpoint, + *  indices a map of the indices from the source including all checkpoints of all indices matching the source pattern, shard level, + *  time_upper_bound for time-based indices this holds the upper time boundary of this checkpoint, + *, + */, +public class DataFrameTransformCheckpoint implements Writeable, ToXContentObject {, +, +    public static DataFrameTransformCheckpoint EMPTY = new DataFrameTransformCheckpoint("empty", 0L, -1L, Collections.emptyMap(), 0L);, +, +    // the timestamp of the checkpoint, mandatory, +    public static final ParseField TIMESTAMP_MILLIS = new ParseField("timestamp_millis");, +    public static final ParseField TIMESTAMP = new ParseField("timestamp");, +, +    // the own checkpoint, +    public static final ParseField CHECKPOINT = new ParseField("checkpoint");, +, +    // checkpoint of the indexes (sequence id's), +    public static final ParseField INDICES = new ParseField("indices");, +, +    // checkpoint for for time based sync, +    // TODO: consider a lower bound for usecases where you want to transform on a window of a stream, +    public static final ParseField TIME_UPPER_BOUND_MILLIS = new ParseField("time_upper_bound_millis");, +    public static final ParseField TIME_UPPER_BOUND = new ParseField("time_upper_bound");, +, +    private static final String NAME = "data_frame_transform_checkpoint";, +, +    private static final ConstructingObjectParser<DataFrameTransformCheckpoint, Void> STRICT_PARSER = createParser(false);, +    private static final ConstructingObjectParser<DataFrameTransformCheckpoint, Void> LENIENT_PARSER = createParser(true);, +, +    private final String transformId;, +    private final long timestampMillis;, +    private final long checkpoint;, +    private final Map<String, long[]> indicesCheckpoints;, +    private final long timeUpperBoundMillis;, +, +    private static ConstructingObjectParser<DataFrameTransformCheckpoint, Void> createParser(boolean lenient) {, +        ConstructingObjectParser<DataFrameTransformCheckpoint, Void> parser = new ConstructingObjectParser<>(NAME,, +                lenient, args -> {, +                    String id = (String) args[0];, +                    Long timestamp = (Long) args[1];, +                    Long checkpoint = (Long) args[2];, +, +                    @SuppressWarnings("unchecked"), +                    Map<String, long[]> checkpoints = (Map<String, long[]>) args[3];, +, +                    Long timestamp_checkpoint = (Long) args[4];, +, +                    // ignored, only for internal storage: String docType = (String) args[5];, +                    return new DataFrameTransformCheckpoint(id, timestamp, checkpoint, checkpoints, timestamp_checkpoint);, +                });, +, +        parser.declareString(constructorArg(), DataFrameField.ID);, +, +        // note: this is never parsed from the outside where timestamp can be formatted as date time]