[+++ b/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.index.mapper.MergeContext;, +import org.elasticsearch.index.mapper.MergeMappingException;, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;, +        public static final EnabledAttributeMapper ENABLED_STATE = EnabledAttributeMapper.UNSET_ENABLED;, +        private EnabledAttributeMapper enabledState = Defaults.ENABLED_STATE;, +            indexName = Defaults.NAME;, +            enabled(index);, +        public Builder enabled(boolean enabled) {, +            this.enabledState = enabled ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;, +            return this;, +        }, +, +            return new FieldNamesFieldMapper(name, indexName, boost, fieldType, enabledState, fieldDataSettings, context.indexSettings());, +            if (parserContext.indexVersionCreated().before(Version.V_1_3_0)) {, +                throw new ElasticsearchIllegalArgumentException("type="+CONTENT_TYPE+" is not supported on indices created before version 1.3.0. Is your cluster running multiple datanode versions?");, +            }, +            , +, +            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {, +                Map.Entry<String, Object> entry = iterator.next();, +                String fieldName = Strings.toUnderscoreCase(entry.getKey());, +                Object fieldNode = entry.getValue();, +                if (fieldName.equals("enabled")) {, +                    builder.enabled(nodeBooleanValue(fieldNode));, +                    iterator.remove();, +            return builder;, +        }, +    private EnabledAttributeMapper enabledState;, +        this(Defaults.NAME, Defaults.NAME, Defaults.BOOST, new FieldType(Defaults.FIELD_TYPE), Defaults.ENABLED_STATE, null, indexSettings);, +    public FieldNamesFieldMapper(String name, String indexName, float boost, FieldType fieldType, EnabledAttributeMapper enabledState, @Nullable Settings fieldDataSettings, Settings indexSettings) {, +        this.defaultFieldType = Defaults.FIELD_TYPE;, +        this.enabledState = enabledState;, +    }, +, +    public boolean enabled() {, +        return enabledState.enabled;, +        if (enabledState.enabled == false) {, +        boolean includeDefaults = params.paramAsBoolean("include_defaults", false);, +, +        if (includeDefaults == false && fieldType().equals(Defaults.FIELD_TYPE) && enabledState == Defaults.ENABLED_STATE) {, +        , +        builder.startObject(NAME);, +        if (includeDefaults || enabledState != Defaults.ENABLED_STATE) {, +            builder.field("enabled", enabledState.enabled);, +        }, +        if (includeDefaults || fieldType().equals(Defaults.FIELD_TYPE) == false) {, +            super.doXContentBody(builder, includeDefaults, params);, +        }, +        , +        builder.endObject();, +        return builder;, +    }, +, +    @Override, +    public void merge(Mapper mergeWith, MergeContext mergeContext) throws MergeMappingException {, +        FieldNamesFieldMapper fieldNamesMapperMergeWith = (FieldNamesFieldMapper)mergeWith;, +        if (!mergeContext.mergeFlags().simulate()) {, +            if (fieldNamesMapperMergeWith.enabledState != enabledState && !fieldNamesMapperMergeWith.enabledState.unset()) {, +                this.enabledState = fieldNamesMapperMergeWith.enabledState;, +            }, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.index.mapper.MergeContext;, +import org.elasticsearch.index.mapper.MergeMappingException;, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;, +        public static final EnabledAttributeMapper ENABLED_STATE = EnabledAttributeMapper.UNSET_ENABLED;, +        private EnabledAttributeMapper enabledState = Defaults.ENABLED_STATE;, +            indexName = Defaults.NAME;, +            enabled(index);, +        public Builder enabled(boolean enabled) {, +            this.enabledState = enabled ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;, +            return this;, +        }, +, +            return new FieldNamesFieldMapper(name, indexName, boost, fieldType, enabledState, fieldDataSettings, context.indexSettings());, +            if (parserContext.indexVersionCreated().before(Version.V_1_3_0)) {, +                throw new ElasticsearchIllegalArgumentException("type="+CONTENT_TYPE+" is not supported on indices created before version 1.3.0. Is your cluster running multiple datanode versions?");, +            }, +            , +, +            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {, +                Map.Entry<String, Object> entry = iterator.next();, +                String fieldName = Strings.toUnderscoreCase(entry.getKey());, +                Object fieldNode = entry.getValue();, +                if (fieldName.equals("enabled")) {, +                    builder.enabled(nodeBooleanValue(fieldNode));, +                    iterator.remove();, +            return builder;, +        }, +    private EnabledAttributeMapper enabledState;, +        this(Defaults.NAME, Defaults.NAME, Defaults.BOOST, new FieldType(Defaults.FIELD_TYPE), Defaults.ENABLED_STATE, null, indexSettings);, +    public FieldNamesFieldMapper(String name, String indexName, float boost, FieldType fieldType, EnabledAttributeMapper enabledState, @Nullable Settings fieldDataSettings, Settings indexSettings) {, +        this.defaultFieldType = Defaults.FIELD_TYPE;, +        this.enabledState = enabledState;, +    }, +, +    public boolean enabled() {]