[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/FilterCacheModule.java, +import org.elasticsearch.index.cache.filter.weak.WeakFilterCache;, +                .to(settings.getAsClass(FilterCacheSettings.FILTER_CACHE_TYPE, WeakFilterCache.class, "org.elasticsearch.index.cache.filter.", "FilterCache")), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/FilterCacheModule.java, +import org.elasticsearch.index.cache.filter.weak.WeakFilterCache;, +                .to(settings.getAsClass(FilterCacheSettings.FILTER_CACHE_TYPE, WeakFilterCache.class, "org.elasticsearch.index.cache.filter.", "FilterCache")), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +        super(index, indexSettings, new MapMaker().softKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/FilterCacheModule.java, +import org.elasticsearch.index.cache.filter.weak.WeakFilterCache;, +                .to(settings.getAsClass(FilterCacheSettings.FILTER_CACHE_TYPE, WeakFilterCache.class, "org.elasticsearch.index.cache.filter.", "FilterCache")), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +        super(index, indexSettings, new MapMaker().softKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    private final ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache;, +                                               ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache) {, +        // can't do this, since we cache on cacheKey..., +//        int totalCount = cache.size();, +//        int cleaned = 0;, +//        for (Iterator<IndexReader> readerIt = cache.keySet().iterator(); readerIt.hasNext();) {, +//            IndexReader reader = readerIt.next();, +//            if (reader.getRefCount() <= 0) {, +//                readerIt.remove();, +//                cleaned++;, +//            }, +//        }, +//        if (logger.isDebugEnabled()) {, +//            if (cleaned > 0) {, +//                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//            }, +//        } else if (logger.isTraceEnabled()) {, +//            logger.trace("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//        }, +            ConcurrentMap<Filter, DocIdSet> cachedFilters = cache.get(reader.getFieldCacheKey());, +                cache.putIfAbsent(reader.getFieldCacheKey(), cachedFilters);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/FilterCacheModule.java, +import org.elasticsearch.index.cache.filter.weak.WeakFilterCache;, +                .to(settings.getAsClass(FilterCacheSettings.FILTER_CACHE_TYPE, WeakFilterCache.class, "org.elasticsearch.index.cache.filter.", "FilterCache")), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +        super(index, indexSettings, new MapMaker().softKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    private final ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache;, +                                               ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache) {, +        // can't do this, since we cache on cacheKey..., +//        int totalCount = cache.size();, +//        int cleaned = 0;, +//        for (Iterator<IndexReader> readerIt = cache.keySet().iterator(); readerIt.hasNext();) {, +//            IndexReader reader = readerIt.next();, +//            if (reader.getRefCount() <= 0) {, +//                readerIt.remove();, +//                cleaned++;, +//            }, +//        }, +//        if (logger.isDebugEnabled()) {, +//            if (cleaned > 0) {, +//                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//            }, +//        } else if (logger.isTraceEnabled()) {, +//            logger.trace("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//        }, +            ConcurrentMap<Filter, DocIdSet> cachedFilters = cache.get(reader.getFieldCacheKey());, +                cache.putIfAbsent(reader.getFieldCacheKey(), cachedFilters);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/weak/WeakFilterCache.java, +        super(index, indexSettings, new MapMaker().weakKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/FilterCacheModule.java, +import org.elasticsearch.index.cache.filter.weak.WeakFilterCache;, +                .to(settings.getAsClass(FilterCacheSettings.FILTER_CACHE_TYPE, WeakFilterCache.class, "org.elasticsearch.index.cache.filter.", "FilterCache")), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +        super(index, indexSettings, new MapMaker().softKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    private final ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache;, +                                               ConcurrentMap<Object, ConcurrentMap<Filter, DocIdSet>> cache) {, +        // can't do this, since we cache on cacheKey..., +//        int totalCount = cache.size();, +//        int cleaned = 0;, +//        for (Iterator<IndexReader> readerIt = cache.keySet().iterator(); readerIt.hasNext();) {, +//            IndexReader reader = readerIt.next();, +//            if (reader.getRefCount() <= 0) {, +//                readerIt.remove();, +//                cleaned++;, +//            }, +//        }, +//        if (logger.isDebugEnabled()) {, +//            if (cleaned > 0) {, +//                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//            }, +//        } else if (logger.isTraceEnabled()) {, +//            logger.trace("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +//        }, +            ConcurrentMap<Filter, DocIdSet> cachedFilters = cache.get(reader.getFieldCacheKey());, +                cache.putIfAbsent(reader.getFieldCacheKey(), cachedFilters);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/weak/WeakFilterCache.java, +        super(index, indexSettings, new MapMaker().weakKeys().<Object, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/ConstantScoreQueryParser.java, +import org.apache.lucene.search.DeletionAwareConstantScoreQuery;, +        Query query;, +            Filter nonCachedFilter = filter;, +            if (parseContext.indexEngine().readerClonedOnDeletion() && (filter != nonCachedFilter)) {, +                query = new DeletionAwareConstantScoreQuery(filter, true);, +            } else {]