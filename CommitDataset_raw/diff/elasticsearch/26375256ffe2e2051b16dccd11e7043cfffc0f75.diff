[+++ b/core/src/main/java/org/elasticsearch/Version.java, +import org.apache.lucene.util.MathUtil;, +        final int bwcMajor;, +        final int bwcMinor;, +        if (this.onOrAfter(Version.V_6_0_0_alpha1)) {, +            bwcMajor = major-1;, +            bwcMinor = 0; // TODO we have to move this to the latest released minor of the last major but for now we just keep, +        } else {, +            bwcMajor = major;, +            bwcMinor = 0;, +        }, +        return Version.smallest(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99));, +    }, +, +    /**, +     * Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>, +     */, +    public boolean isCompatible(Version version) {, +        boolean compatible = onOrAfter(version.minimumCompatibilityVersion()), +            && version.onOrAfter(minimumCompatibilityVersion());, +, +        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1;, +        return compatible;, +++ b/core/src/main/java/org/elasticsearch/Version.java, +import org.apache.lucene.util.MathUtil;, +        final int bwcMajor;, +        final int bwcMinor;, +        if (this.onOrAfter(Version.V_6_0_0_alpha1)) {, +            bwcMajor = major-1;, +            bwcMinor = 0; // TODO we have to move this to the latest released minor of the last major but for now we just keep, +        } else {, +            bwcMajor = major;, +            bwcMinor = 0;, +        }, +        return Version.smallest(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99));, +    }, +, +    /**, +     * Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>, +     */, +    public boolean isCompatible(Version version) {, +        boolean compatible = onOrAfter(version.minimumCompatibilityVersion()), +            && version.onOrAfter(minimumCompatibilityVersion());, +, +        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1;, +        return compatible;, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/template/put/PutIndexTemplateRequest.java, +        if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +        if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/Version.java, +import org.apache.lucene.util.MathUtil;, +        final int bwcMajor;, +        final int bwcMinor;, +        if (this.onOrAfter(Version.V_6_0_0_alpha1)) {, +            bwcMajor = major-1;, +            bwcMinor = 0; // TODO we have to move this to the latest released minor of the last major but for now we just keep, +        } else {, +            bwcMajor = major;, +            bwcMinor = 0;, +        }, +        return Version.smallest(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99));, +    }, +, +    /**, +     * Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>, +     */, +    public boolean isCompatible(Version version) {, +        boolean compatible = onOrAfter(version.minimumCompatibilityVersion()), +            && version.onOrAfter(minimumCompatibilityVersion());, +, +        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1;, +        return compatible;, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/template/put/PutIndexTemplateRequest.java, +        if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +        if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java, +        if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +        if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/Version.java, +import org.apache.lucene.util.MathUtil;, +        final int bwcMajor;, +        final int bwcMinor;, +        if (this.onOrAfter(Version.V_6_0_0_alpha1)) {, +            bwcMajor = major-1;, +            bwcMinor = 0; // TODO we have to move this to the latest released minor of the last major but for now we just keep, +        } else {, +            bwcMajor = major;, +            bwcMinor = 0;, +        }, +        return Version.smallest(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99));, +    }, +, +    /**, +     * Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>, +     */, +    public boolean isCompatible(Version version) {, +        boolean compatible = onOrAfter(version.minimumCompatibilityVersion()), +            && version.onOrAfter(minimumCompatibilityVersion());, +, +        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1;]