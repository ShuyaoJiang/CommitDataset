[+++ b/src/main/java/org/apache/lucene/util/packed/XAbstractPagedMutable.java, +package org.apache.lucene.util.packed;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import static org.apache.lucene.util.packed.XPackedInts.checkBlockSize;, +import static org.apache.lucene.util.packed.XPackedInts.numBlocks;, +, +import org.apache.lucene.util.Version;, +import org.elasticsearch.common.lucene.Lucene;, +, +import org.apache.lucene.util.ArrayUtil;, +import org.apache.lucene.util.RamUsageEstimator;, +, +/**, + * Base implementation for {@link XPagedMutable} and {@link PagedGrowableWriter}., + * @lucene.internal, + */, +abstract class XAbstractPagedMutable<T extends XAbstractPagedMutable<T>> {, +, +    static {, +        // LUCENE MONITOR: this should be in Lucene 4.4 copied from Revision: 1492640., +        assert Lucene.VERSION == Version.LUCENE_43 : "Elasticsearch has upgraded to Lucene Version: [" + Lucene.VERSION + "] this class should be removed";, +    }, +, +  static final int MIN_BLOCK_SIZE = 1 << 6;, +  static final int MAX_BLOCK_SIZE = 1 << 30;, +, +  final long size;, +  final int pageShift;, +  final int pageMask;, +  final PackedInts.Mutable[] subMutables;, +  final int bitsPerValue;, +, +  XAbstractPagedMutable(int bitsPerValue, long size, int pageSize) {, +    this.bitsPerValue = bitsPerValue;, +    this.size = size;, +    pageShift = checkBlockSize(pageSize, MIN_BLOCK_SIZE, MAX_BLOCK_SIZE);, +    pageMask = pageSize - 1;, +    final int numPages = numBlocks(size, pageSize);, +    subMutables = new PackedInts.Mutable[numPages];, +  }, +, +  protected final void fillPages() {, +    final int numPages = numBlocks(size, pageSize());, +    for (int i = 0; i < numPages; ++i) {, +      // do not allocate for more entries than necessary on the last page, +      final int valueCount = i == numPages - 1 ? lastPageSize(size) : pageSize();, +      subMutables[i] = newMutable(valueCount, bitsPerValue);, +    }, +  }, +, +  protected abstract PackedInts.Mutable newMutable(int valueCount, int bitsPerValue);, +, +  final int lastPageSize(long size) {, +    final int sz = indexInPage(size);, +    return sz == 0 ? pageSize() : sz;, +  }, +, +  final int pageSize() {, +    return pageMask + 1;, +  }, +, +  /** The number of values. */, +  public final long size() {, +    return size;, +  }, +, +  final int pageIndex(long index) {, +    return (int) (index >>> pageShift);, +  }, +, +  final int indexInPage(long index) {, +    return (int) index & pageMask;, +  }, +, +  /** Get value at <code>index</code>. */, +  public final long get(long index) {, +    assert index >= 0 && index < size;, +    final int pageIndex = pageIndex(index);, +    final int indexInPage = indexInPage(index);, +    return subMutables[pageIndex].get(indexInPage);, +  }, +, +  /** Set value at <code>index</code>. */]