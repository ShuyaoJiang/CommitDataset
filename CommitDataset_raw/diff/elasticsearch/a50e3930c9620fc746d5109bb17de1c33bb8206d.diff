[+++ b/src/main/java/org/elasticsearch/search/aggregations/NonCollectingAggregator.java, +    protected NonCollectingAggregator(String name, AggregationContext context, Aggregator parent, AggregatorFactories subFactories, Map<String, Object> metaData) {, +        super(name, BucketAggregationMode.MULTI_BUCKETS, subFactories, 0, context, parent, metaData);, +    }, +, +        this(name, context, parent, AggregatorFactories.EMPTY, metaData);, +++ b/src/main/java/org/elasticsearch/search/aggregations/NonCollectingAggregator.java, +    protected NonCollectingAggregator(String name, AggregationContext context, Aggregator parent, AggregatorFactories subFactories, Map<String, Object> metaData) {, +        super(name, BucketAggregationMode.MULTI_BUCKETS, subFactories, 0, context, parent, metaData);, +    }, +, +        this(name, context, parent, AggregatorFactories.EMPTY, metaData);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +        return new NonCollectingAggregator(name, aggregationContext, parent, factories, metaData) {, +            {, +                // even in the case of an unmapped aggregator, validate the order, +                InternalOrder.validate(order, this);, +            }, +++ b/src/main/java/org/elasticsearch/search/aggregations/NonCollectingAggregator.java, +    protected NonCollectingAggregator(String name, AggregationContext context, Aggregator parent, AggregatorFactories subFactories, Map<String, Object> metaData) {, +        super(name, BucketAggregationMode.MULTI_BUCKETS, subFactories, 0, context, parent, metaData);, +    }, +, +        this(name, context, parent, AggregatorFactories.EMPTY, metaData);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +        return new NonCollectingAggregator(name, aggregationContext, parent, factories, metaData) {, +            {, +                // even in the case of an unmapped aggregator, validate the order, +                InternalOrder.validate(order, this);, +            }, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java, +import java.util.Arrays;, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +                                .field(SINGLE_VALUED_FIELD_NAME + "2"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +++ b/src/main/java/org/elasticsearch/search/aggregations/NonCollectingAggregator.java, +    protected NonCollectingAggregator(String name, AggregationContext context, Aggregator parent, AggregatorFactories subFactories, Map<String, Object> metaData) {, +        super(name, BucketAggregationMode.MULTI_BUCKETS, subFactories, 0, context, parent, metaData);, +    }, +, +        this(name, context, parent, AggregatorFactories.EMPTY, metaData);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +        return new NonCollectingAggregator(name, aggregationContext, parent, factories, metaData) {, +            {, +                // even in the case of an unmapped aggregator, validate the order, +                InternalOrder.validate(order, this);, +            }, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java, +import java.util.Arrays;, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +                                .field(SINGLE_VALUED_FIELD_NAME + "2"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/LongTermsTests.java, +import java.util.Arrays;, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +        for (String index : Arrays.asList("idx", "idx_unmapped")) {, +                client().prepareSearch(index).setTypes("type"), +    }, +++ b/src/main/java/org/elasticsearch/search/aggregations/NonCollectingAggregator.java, +    protected NonCollectingAggregator(String name, AggregationContext context, Aggregator parent, AggregatorFactories subFactories, Map<String, Object> metaData) {, +        super(name, BucketAggregationMode.MULTI_BUCKETS, subFactories, 0, context, parent, metaData);, +    }, +, +        this(name, context, parent, AggregatorFactories.EMPTY, metaData);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +        return new NonCollectingAggregator(name, aggregationContext, parent, factories, metaData) {, +            {, +                // even in the case of an unmapped aggregator, validate the order, +                InternalOrder.validate(order, this);, +            }, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java, +import java.util.Arrays;]