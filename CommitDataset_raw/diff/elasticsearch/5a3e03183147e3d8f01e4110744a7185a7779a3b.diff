[+++ b/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java, +import org.elasticsearch.Version;, +import java.util.LinkedList;, +                if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0_alpha1)) {, +                    /**, +                     * For indices created on or after {@link Version#V_7_0_0_alpha1} we preserve the order, +                     * of the children while ensuring that parents appear after them., +                     */, +                    List<Document> newDocs = reorderParent(documents);, +                    documents.clear();, +                    documents.addAll(newDocs);, +                } else {, +                    // reverse the order of docs for nested docs support, parent should be last, +        }, +, +        /**, +         * Returns a copy of the provided {@link List} where parent documents appear, +         * after their children., +         */, +        private List<Document> reorderParent(List<Document> docs) {, +            List<Document> newDocs = new ArrayList<>(docs.size());, +            LinkedList<Document> parents = new LinkedList<>();, +            for (Document doc : docs) {, +                while (parents.peek() != doc.getParent()){, +                    newDocs.add(parents.poll());, +                }, +                parents.add(0, doc);, +            }, +            newDocs.addAll(parents);, +            return newDocs;, +        }, +++ b/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java, +import org.elasticsearch.Version;, +import java.util.LinkedList;, +                if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0_alpha1)) {, +                    /**, +                     * For indices created on or after {@link Version#V_7_0_0_alpha1} we preserve the order, +                     * of the children while ensuring that parents appear after them., +                     */, +                    List<Document> newDocs = reorderParent(documents);, +                    documents.clear();, +                    documents.addAll(newDocs);, +                } else {, +                    // reverse the order of docs for nested docs support, parent should be last, +        }, +, +        /**, +         * Returns a copy of the provided {@link List} where parent documents appear, +         * after their children., +         */, +        private List<Document> reorderParent(List<Document> docs) {, +            List<Document> newDocs = new ArrayList<>(docs.size());, +            LinkedList<Document> parents = new LinkedList<>();, +            for (Document doc : docs) {, +                while (parents.peek() != doc.getParent()){, +                    newDocs.add(parents.poll());, +                }, +                parents.add(0, doc);, +            }, +            newDocs.addAll(parents);, +            return newDocs;, +        }, +++ b/server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.IndexSettings;, +        final IndexSettings indexSettings = context.getQueryShardContext().getIndexSettings();, +            if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0_alpha1)) {, +                /**, +                 * Starts from the previous parent and finds the offset of the, +                 * <code>nestedSubDocID</code> within the nested children. Nested documents, +                 * are indexed in the same order than in the source array so the offset, +                 * of the nested child is the number of nested document with the same parent, +                 * that appear before him., +                 */, +                int previousParent = parentBits.prevSetBit(currentParent);, +                for (int docId = childIter.advance(previousParent + 1); docId < nestedSubDocId && docId != DocIdSetIterator.NO_MORE_DOCS;, +                        docId = childIter.nextDoc()) {, +                    offset++;, +                }, +                currentParent = nestedSubDocId;, +            } else {, +                /**, +                 * Nested documents are in reverse order in this version so we start from the current nested document, +                 * and find the number of documents with the same parent that appear after it., +                 */, +            }, +++ b/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java, +import org.elasticsearch.Version;, +import java.util.LinkedList;, +                if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0_alpha1)) {, +                    /**, +                     * For indices created on or after {@link Version#V_7_0_0_alpha1} we preserve the order, +                     * of the children while ensuring that parents appear after them., +                     */, +                    List<Document> newDocs = reorderParent(documents);, +                    documents.clear();, +                    documents.addAll(newDocs);, +                } else {, +                    // reverse the order of docs for nested docs support, parent should be last, +        }]