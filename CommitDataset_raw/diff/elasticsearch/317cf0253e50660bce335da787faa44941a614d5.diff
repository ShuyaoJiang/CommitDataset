[+++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsCatalog.java, +        // NOCOMMIT verify that this works if the index isn't on the node, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsCatalog.java, +        // NOCOMMIT verify that this works if the index isn't on the node, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/jdbc/server/JdbcServerProtoUtils.java, +import org.joda.time.ReadableInstant;, +, +import java.io.DataOutput;, +import java.io.DataOutputStream;, +import java.io.IOException;, +import java.io.PrintWriter;, +import java.io.StringWriter;, +import java.sql.Types;, +import java.util.concurrent.TimeoutException;, +                if (jdbcTypes[i] == Types.TIMESTAMP && value instanceof ReadableInstant) {, +                    // NOCOMMIT feels like a hack that'd be better cleaned up another way., +                    value = ((ReadableInstant) value).getMillis();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsCatalog.java, +        // NOCOMMIT verify that this works if the index isn't on the node, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/jdbc/server/JdbcServerProtoUtils.java, +import org.joda.time.ReadableInstant;, +, +import java.io.DataOutput;, +import java.io.DataOutputStream;, +import java.io.IOException;, +import java.io.PrintWriter;, +import java.io.StringWriter;, +import java.sql.Types;, +import java.util.concurrent.TimeoutException;, +                if (jdbcTypes[i] == Types.TIMESTAMP && value instanceof ReadableInstant) {, +                    // NOCOMMIT feels like a hack that'd be better cleaned up another way., +                    value = ((ReadableInstant) value).getMillis();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/type/DateType.java, +        /* Since we normalize timestamps to UTC for storage and do not keep, +         * the origination zone information information we are technically, +         * `TIMESTAMP WITHOUT TIME ZONE` or just `TIMESTAMP`, or, in Oracle, +         * parlance, `TIMESTAMP WITH LOCAL TIME ZONE`., +         * `TIMESTAMP WITH TIME ZONE` implies that we store the original, +         * time zone of the even. Confusingly, PostgreSQL's, +         * `TIMESTAMP WITH TIME ZONE` type does not store original time zone,, +         * unlike H2 and Oracle, *but* it is aware of the session's time zone, +         * so it is preferred. But it is *weird*. As bad as it feels not to, +         * be like PostgreSQL, we are going to not be like PostgreSQL here, +         * and return TIMESTAMP so we more closely conform with H2 and, +         * (shudder) Oracle. */, +        super(JDBCType.TIMESTAMP, docValues);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsCatalog.java, +        // NOCOMMIT verify that this works if the index isn't on the node, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/jdbc/server/JdbcServerProtoUtils.java, +import org.joda.time.ReadableInstant;, +, +import java.io.DataOutput;, +import java.io.DataOutputStream;, +import java.io.IOException;, +import java.io.PrintWriter;, +import java.io.StringWriter;, +import java.sql.Types;, +import java.util.concurrent.TimeoutException;, +                if (jdbcTypes[i] == Types.TIMESTAMP && value instanceof ReadableInstant) {, +                    // NOCOMMIT feels like a hack that'd be better cleaned up another way., +                    value = ((ReadableInstant) value).getMillis();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/type/DateType.java, +        /* Since we normalize timestamps to UTC for storage and do not keep, +         * the origination zone information information we are technically, +         * `TIMESTAMP WITHOUT TIME ZONE` or just `TIMESTAMP`, or, in Oracle, +         * parlance, `TIMESTAMP WITH LOCAL TIME ZONE`., +         * `TIMESTAMP WITH TIME ZONE` implies that we store the original, +         * time zone of the even. Confusingly, PostgreSQL's, +         * `TIMESTAMP WITH TIME ZONE` type does not store original time zone,, +         * unlike H2 and Oracle, *but* it is aware of the session's time zone, +         * so it is preferred. But it is *weird*. As bad as it feels not to, +         * be like PostgreSQL, we are going to not be like PostgreSQL here, +         * and return TIMESTAMP so we more closely conform with H2 and, +         * (shudder) Oracle. */, +        super(JDBCType.TIMESTAMP, docValues);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/type/JdbcUtils.java, +            case TIMESTAMP: return 20;, +            case TIMESTAMP:, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsCatalog.java, +        // NOCOMMIT verify that this works if the index isn't on the node, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/jdbc/server/JdbcServerProtoUtils.java, +import org.joda.time.ReadableInstant;, +, +import java.io.DataOutput;, +import java.io.DataOutputStream;, +import java.io.IOException;, +import java.io.PrintWriter;, +import java.io.StringWriter;, +import java.sql.Types;, +import java.util.concurrent.TimeoutException;, +                if (jdbcTypes[i] == Types.TIMESTAMP && value instanceof ReadableInstant) {, +                    // NOCOMMIT feels like a hack that'd be better cleaned up another way., +                    value = ((ReadableInstant) value).getMillis();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/type/DateType.java, +        /* Since we normalize timestamps to UTC for storage and do not keep, +         * the origination zone information information we are technically, +         * `TIMESTAMP WITHOUT TIME ZONE` or just `TIMESTAMP`, or, in Oracle, +         * parlance, `TIMESTAMP WITH LOCAL TIME ZONE`., +         * `TIMESTAMP WITH TIME ZONE` implies that we store the original, +         * time zone of the even. Confusingly, PostgreSQL's]