[+++ b/core/src/main/java/org/elasticsearch/action/support/tasks/TransportTasksAction.java, +            for (int i = 0; i < this.nodesIds.length; i++) {, +                this.nodes[i] = nodes.get(this.nodesIds[i]);, +++ b/core/src/main/java/org/elasticsearch/action/support/tasks/TransportTasksAction.java, +            for (int i = 0; i < this.nodesIds.length; i++) {, +                this.nodes[i] = nodes.get(this.nodesIds[i]);, +++ b/core/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/TaskManagerTestCase.java, +, +        public String getNodeId() {, +            return discoveryNode.getId();, +        }, +++ b/core/src/main/java/org/elasticsearch/action/support/tasks/TransportTasksAction.java, +            for (int i = 0; i < this.nodesIds.length; i++) {, +                this.nodes[i] = nodes.get(this.nodesIds[i]);, +++ b/core/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/TaskManagerTestCase.java, +, +        public String getNodeId() {, +            return discoveryNode.getId();, +        }, +++ b/core/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/TransportTasksActionTests.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.Set;, +, +, +    /**, +     * This test starts nodes actions that blocks on all nodes. While node actions are blocked in the middle of execution, +     * it executes a tasks action that targets these blocked node actions. The test verifies that task actions are only, +     * getting executed on nodes that are not listed in the node filter., +     */, +    public void testTaskNodeFiltering() throws ExecutionException, InterruptedException, IOException {, +        setupTestNodes(Settings.EMPTY);, +        connectNodes(testNodes);, +        CountDownLatch checkLatch = new CountDownLatch(1);, +        // Start some test nodes action so we could have something to run tasks actions on, +        ActionFuture<NodesResponse> future = startBlockingTestNodesAction(checkLatch);, +, +        String[] allNodes = new String[testNodes.length];, +        for (int i = 0; i < testNodes.length; i++) {, +            allNodes[i] = testNodes[i].getNodeId();, +        }, +, +        int filterNodesSize = randomInt(allNodes.length);, +        Set<String> filterNodes = new HashSet<>(randomSubsetOf(filterNodesSize, allNodes));, +        logger.info("Filtering out nodes {} size: {}", filterNodes, filterNodesSize);, +, +        TestTasksAction[] tasksActions = new TestTasksAction[nodesCount];, +        for (int i = 0; i < testNodes.length; i++) {, +            final int node = i;, +            // Simulate a task action that works on all nodes except nodes listed in filterNodes., +            // We are testing that it works., +            tasksActions[i] = new TestTasksAction(Settings.EMPTY, "testTasksAction", clusterName, threadPool,, +                testNodes[i].clusterService, testNodes[i].transportService) {, +, +                @Override, +                protected String[] filterNodeIds(DiscoveryNodes nodes, String[] nodesIds) {, +                    String[] superNodes = super.filterNodeIds(nodes, nodesIds);, +                    List<String> filteredNodes = new ArrayList<>();, +                    for (String node : superNodes) {, +                        if (filterNodes.contains(node) == false) {, +                            filteredNodes.add(node);, +                        }, +                    }, +                    return filteredNodes.toArray(new String[filteredNodes.size()]);, +                }, +, +                @Override, +                protected TestTaskResponse taskOperation(TestTasksRequest request, Task task) {, +                    return new TestTaskResponse(testNodes[node].getNodeId());, +                }, +            };, +        }, +, +        // Run task action on node tasks that are currently running, +        // should be successful on all nodes except nodes that we filtered out, +        TestTasksRequest testTasksRequest = new TestTasksRequest();, +        testTasksRequest.setActions("testAction[n]"); // pick all test actions, +        TestTasksResponse response = tasksActions[randomIntBetween(0, nodesCount - 1)].execute(testTasksRequest).get();, +, +        // Get successful responses from all nodes except nodes that we filtered out, +        assertEquals(testNodes.length - filterNodes.size(), response.tasks.size());, +        assertEquals(0, response.getTaskFailures().size()); // no task failed, +        assertEquals(0, response.getNodeFailures().size()); // no nodes failed, +, +        // Make sure that filtered nodes didn't send any responses, +        for (TestTaskResponse taskResponse : response.tasks) {, +            String nodeId = taskResponse.getStatus();, +            assertFalse("Found response from filtered node " + nodeId, filterNodes.contains(nodeId));, +        }, +, +        // Release all node tasks and wait for response, +        checkLatch.countDown();, +        NodesResponse responses = future.get();, +        assertEquals(0, responses.failureCount());, +    }]