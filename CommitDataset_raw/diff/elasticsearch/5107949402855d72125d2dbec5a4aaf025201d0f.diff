[+++ b/docs/reference/analysis/tokenfilters/multiplexer-tokenfilter.asciidoc, +, +NOTE: The synonym and synonym_graph filters use their preceding analysis chain to, +parse and analyse their synonym lists, and ignore any token filters in the chain, +that produce multiple tokens at the same position.  This means that any filters, +within the multiplexer will be ignored for the purpose of synonyms.  If you want to, +use filters contained within the multiplexer for parsing synonyms (for example, to, +apply stemming to the synonym lists), then you should append the synonym filter, +to the relevant multiplexer filter list., +++ b/docs/reference/analysis/tokenfilters/multiplexer-tokenfilter.asciidoc, +, +NOTE: The synonym and synonym_graph filters use their preceding analysis chain to, +parse and analyse their synonym lists, and ignore any token filters in the chain, +that produce multiple tokens at the same position.  This means that any filters, +within the multiplexer will be ignored for the purpose of synonyms.  If you want to, +use filters contained within the multiplexer for parsing synonyms (for example, to, +apply stemming to the synonym lists), then you should append the synonym filter, +to the relevant multiplexer filter list., +++ b/modules/analysis-common/src/main/java/org/elasticsearch/analysis/common/MultiplexerTokenFilterFactory.java, +import org.elasticsearch.index.analysis.CharFilterFactory;, +import org.elasticsearch.index.analysis.TokenizerFactory;, +public class MultiplexerTokenFilterFactory extends AbstractTokenFilterFactory {, +        throw new UnsupportedOperationException("TokenFilterFactory.getChainAwareTokenFilterFactory() must be called first");, +    }, +, +    @Override, +    public TokenFilterFactory getChainAwareTokenFilterFactory(TokenizerFactory tokenizer, List<CharFilterFactory> charFilters,, +                                                              List<TokenFilterFactory> previousTokenFilters,, +                                                              Function<String, TokenFilterFactory> allFilters) {, +        List<TokenFilterFactory> filters = new ArrayList<>();, +        if (preserveOriginal) {, +            filters.add(IDENTITY_FILTER);, +        }, +        for (String filter : filterNames) {, +            String[] parts = Strings.tokenizeToStringArray(filter, ",");, +            if (parts.length == 1) {, +                TokenFilterFactory factory = resolveFilterFactory(allFilters, parts[0]);, +                factory = factory.getChainAwareTokenFilterFactory(tokenizer, charFilters, previousTokenFilters, allFilters);, +                filters.add(factory);, +            } else {, +                List<TokenFilterFactory> existingChain = new ArrayList<>(previousTokenFilters);, +                List<TokenFilterFactory> chain = new ArrayList<>();, +                for (String subfilter : parts) {, +                    TokenFilterFactory factory = resolveFilterFactory(allFilters, subfilter);, +                    factory = factory.getChainAwareTokenFilterFactory(tokenizer, charFilters, existingChain, allFilters);, +                    chain.add(factory);, +                    existingChain.add(factory);, +                }, +                filters.add(chainFilters(filter, chain));, +            }, +        }, +, +        return new TokenFilterFactory() {, +            @Override, +            public String name() {, +                return MultiplexerTokenFilterFactory.this.name();, +            }, +, +            @Override, +            public TokenStream create(TokenStream tokenStream) {, +            public TokenFilterFactory getSynonymFilter() {, +                return IDENTITY_FILTER;, +        };, +    private TokenFilterFactory resolveFilterFactory(Function<String, TokenFilterFactory> factories, String name) {, +        TokenFilterFactory factory = factories.apply(name);, +        if (factory == null) {, +            return factory;, +++ b/docs/reference/analysis/tokenfilters/multiplexer-tokenfilter.asciidoc, +, +NOTE: The synonym and synonym_graph filters use their preceding analysis chain to, +parse and analyse their synonym lists, and ignore any token filters in the chain, +that produce multiple tokens at the same position.  This means that any filters, +within the multiplexer will be ignored for the purpose of synonyms.  If you want to, +use filters contained within the multiplexer for parsing synonyms (for example, to, +apply stemming to the synonym lists), then you should append the synonym filter, +to the relevant multiplexer filter list., +++ b/modules/analysis-common/src/main/java/org/elasticsearch/analysis/common/MultiplexerTokenFilterFactory.java, +import org.elasticsearch.index.analysis.CharFilterFactory;, +import org.elasticsearch.index.analysis.TokenizerFactory;, +public class MultiplexerTokenFilterFactory extends AbstractTokenFilterFactory {, +        throw new UnsupportedOperationException("TokenFilterFactory.getChainAwareTokenFilterFactory() must be called first");, +    }, +, +    @Override, +    public TokenFilterFactory getChainAwareTokenFilterFactory(TokenizerFactory tokenizer, List<CharFilterFactory> charFilters,, +                                                              List<TokenFilterFactory> previousTokenFilters,, +                                                              Function<String, TokenFilterFactory> allFilters) {, +        List<TokenFilterFactory> filters = new ArrayList<>();, +        if (preserveOriginal) {, +            filters.add(IDENTITY_FILTER);, +        }, +        for (String filter : filterNames) {, +            String[] parts = Strings.tokenizeToStringArray(filter, ",");, +            if (parts.length == 1) {, +                TokenFilterFactory factory = resolveFilterFactory(allFilters, parts[0]);, +                factory = factory.getChainAwareTokenFilterFactory(tokenizer, charFilters, previousTokenFilters, allFilters);, +                filters.add(factory);, +            } else {, +                List<TokenFilterFactory> existingChain = new ArrayList<>(previousTokenFilters);, +                List<TokenFilterFactory> chain = new ArrayList<>();]