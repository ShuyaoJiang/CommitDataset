[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                case 18:, +                    return (T) readStackTrace(new InterruptedException(readOptionalString()), this);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                case 18:, +                    return (T) readStackTrace(new InterruptedException(readOptionalString()), this);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +            } else if (throwable instanceof InterruptedException) {, +                writeVInt(18);, +                writeCause = false;, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                case 18:, +                    return (T) readStackTrace(new InterruptedException(readOptionalString()), this);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +            } else if (throwable instanceof InterruptedException) {, +                writeVInt(18);, +                writeCause = false;, +++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                case 18:, +                    return (T) readStackTrace(new InterruptedException(readOptionalString()), this);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +            } else if (throwable instanceof InterruptedException) {, +                writeVInt(18);, +                writeCause = false;, +++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +++ b/core/src/test/java/org/elasticsearch/ExceptionSerializationTests.java, +, +    public void testInterruptedException() throws IOException {, +        InterruptedException orig = randomBoolean() ? new InterruptedException("boom") : new InterruptedException();, +        InterruptedException ex = serialize(orig);, +        assertEquals(orig.getMessage(), ex.getMessage());, +    }, +, +    public static class UnknownException extends Exception {, +        public UnknownException(String message) {, +            super(message);, +        }, +, +        public UnknownException(String message, Throwable cause) {, +            super(message, cause);, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                case 18:, +                    return (T) readStackTrace(new InterruptedException(readOptionalString()), this);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +            } else if (throwable instanceof InterruptedException) {, +                writeVInt(18);, +                writeCause = false;, +++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +++ b/core/src/test/java/org/elasticsearch/ExceptionSerializationTests.java, +, +    public void testInterruptedException() throws IOException {, +        InterruptedException orig = randomBoolean() ? new InterruptedException("boom") : new InterruptedException();, +        InterruptedException ex = serialize(orig);, +        assertEquals(orig.getMessage(), ex.getMessage());, +    }, +, +    public static class UnknownException extends Exception {, +        public UnknownException(String message) {, +            super(message);, +        }, +, +        public UnknownException(String message, Throwable cause) {, +            super(message, cause);, +        }, +    }, +++ b/core/src/test/java/org/elasticsearch/test/discovery/ClusterDiscoveryConfiguration.java, +        private final int[] unicastHostOrdinals;, +        private final int[] unicastHostPorts;, +            this.unicastHostPorts = localMode ? new int[0] : unicastHostPorts(numOfNodes);, +            assert localMode || unicastHostOrdinals.length <= unicastHostPorts.length;, +            this.unicastHostOrdinals = unicastHostOrdinals;, +            this.unicastHostPorts = localMode ? new int[0] : unicastHostPorts(numOfNodes);, +            assert localMode || unicastHostOrdinals.length <= unicastHostPorts.length;, +            String[] unicastHosts = new String[unicastHostOrdinals.length];, +                for (int i = 0; i < unicastHosts.length; i++) {, +                    unicastHosts[i] = "node_" + unicastHostOrdinals[i];, +                }, +            } else if (nodeOrdinal >= unicastHostPorts.length) {, +                throw new ElasticsearchException("nodeOrdinal [" + nodeOrdinal + "] is greater than the number unicast ports [" + unicastHostPorts.length + "]");, +                builder.put("transport.tcp.port", unicastHostPorts[nodeOrdinal]);, +                for (int i = 0; i < unicastHostOrdinals.length; i++) {, +                    unicastHosts[i] = "localhost:" + (unicastHostPorts[unicastHostOrdinals[i]]);, +                }, +        protected synchronized static int[] unicastHostPorts(int numHosts) {, +            int[] unicastHostPorts = new int[numHosts];, +            final int basePort = calcBasePort();, +            final int maxPort = basePort + InternalTestCluster.PORTS_PER_JVM;, +            int tries = 0;, +                boolean foundPortInRange = false;, +                while (tries < InternalTestCluster.PORTS_PER_JVM && !foundPortInRange) {, +                    try (ServerSocket serverSocket = new ServerSocket()) {, +                        // Set SO_REUSEADDR as we may bind here and not be able to reuse the address immediately without it., +                        serverSocket.setReuseAddress(NetworkUtils.defaultReuseAddress());, +                        serverSocket.bind(new InetSocketAddress("127.0.0.1", nextPort));, +                        // bind was a success, +                        foundPortInRange = true;, +                        unicastHostPorts[i] = nextPort;]