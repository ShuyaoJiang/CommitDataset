[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import java.util.ArrayList;, +import java.util.stream.Collectors;, +            typeIntersection = indexService.mapperService().types(), +                    .stream(), +                    .filter(type -> Regex.simpleMatch(request.types(), type)), +                    .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import java.util.ArrayList;, +import java.util.stream.Collectors;, +            typeIntersection = indexService.mapperService().types(), +                    .stream(), +                    .filter(type -> Regex.simpleMatch(request.types(), type)), +                    .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.stream.Collectors;, +                    matches = metaData.getAliasAndIndexLookup(), +                            .entrySet(), +                            .stream(), +                            .filter(e -> Regex.simpleMatch(pattern, e.getKey())), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import java.util.ArrayList;, +import java.util.stream.Collectors;, +            typeIntersection = indexService.mapperService().types(), +                    .stream(), +                    .filter(type -> Regex.simpleMatch(request.types(), type)), +                    .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.stream.Collectors;, +                    matches = metaData.getAliasAndIndexLookup(), +                            .entrySet(), +                            .stream(), +                            .filter(e -> Regex.simpleMatch(pattern, e.getKey())), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import java.util.stream.Collectors;, +import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;, +import static org.elasticsearch.common.settings.Settings.settingsBuilder;, +import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;, +            Collection<IndexWarmersMetaData.Entry> filteredWarmers =, +                    indexWarmersMetaData, +                            .entries(), +                            .stream(), +                            .filter(warmer -> {, +                            }), +                            .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import java.util.ArrayList;, +import java.util.stream.Collectors;, +            typeIntersection = indexService.mapperService().types(), +                    .stream(), +                    .filter(type -> Regex.simpleMatch(request.types(), type)), +                    .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.stream.Collectors;, +                    matches = metaData.getAliasAndIndexLookup(), +                            .entrySet(), +                            .stream(), +                            .filter(e -> Regex.simpleMatch(pattern, e.getKey())), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import java.util.stream.Collectors;, +import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;, +import static org.elasticsearch.common.settings.Settings.settingsBuilder;, +import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;, +            Collection<IndexWarmersMetaData.Entry> filteredWarmers =, +                    indexWarmersMetaData, +                            .entries(), +                            .stream(), +                            .filter(warmer -> {, +                            }), +                            .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import java.util.function.Predicate;, +                if (predicate.test(shardRouting)) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import java.util.ArrayList;, +import java.util.stream.Collectors;, +            typeIntersection = indexService.mapperService().types(), +                    .stream(), +                    .filter(type -> Regex.simpleMatch(request.types(), type)), +                    .collect(Collectors.toCollection(ArrayList::new));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.stream.Collectors;, +                    matches = metaData.getAliasAndIndexLookup(), +                            .entrySet(), +                            .stream(), +                            .filter(e -> Regex.simpleMatch(pattern, e.getKey())), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import java.util.stream.Collectors;, +import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;, +import static org.elasticsearch.common.settings.Settings.settingsBuilder;, +import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;, +            Collection<IndexWarmersMetaData.Entry> filteredWarmers =, +                    indexWarmersMetaData, +                            .entries(), +                            .stream(), +                            .filter(warmer -> {]