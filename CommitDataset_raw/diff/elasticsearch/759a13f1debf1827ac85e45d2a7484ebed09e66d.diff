[+++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import com.google.common.base.Predicate;, +    public List<MutableShardRouting> shards(Predicate<MutableShardRouting> predicate) {, +        List<MutableShardRouting> shards = newArrayList();, +        for (RoutingNode routingNode : this) {, +            List<MutableShardRouting> nodeShards = routingNode.shards();, +            for (int i = 0; i < nodeShards.size(); i++) {, +                MutableShardRouting shardRouting = nodeShards.get(i);, +                if (predicate.apply(shardRouting)) {, +                    shards.add(shardRouting);, +                }, +            }, +        }, +        return shards;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import com.google.common.base.Predicate;, +    public List<MutableShardRouting> shards(Predicate<MutableShardRouting> predicate) {, +        List<MutableShardRouting> shards = newArrayList();, +        for (RoutingNode routingNode : this) {, +            List<MutableShardRouting> nodeShards = routingNode.shards();, +            for (int i = 0; i < nodeShards.size(); i++) {, +                MutableShardRouting shardRouting = nodeShards.get(i);, +                if (predicate.apply(shardRouting)) {, +                    shards.add(shardRouting);, +                }, +            }, +        }, +        return shards;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.elasticsearch.cluster.routing.MutableShardRouting;, +import org.elasticsearch.cluster.routing.RoutingNode;, +import org.elasticsearch.cluster.routing.RoutingNodes;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +         * returned sorter is not sorted. Use {@link NodeSorter#reset(org.elasticsearch.cluster.routing.allocation.allocator.BalancedShardsAllocator.Operation, String)}, +            return new NodeSorter(nodesArray(), weight, this);, +            indices.addAll(allocation.routingTable().indicesRouting().keySet());, +            buildModelFromAssigned(routing.shards(assignedFilter));, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import com.google.common.base.Predicate;, +    public List<MutableShardRouting> shards(Predicate<MutableShardRouting> predicate) {, +        List<MutableShardRouting> shards = newArrayList();, +        for (RoutingNode routingNode : this) {, +            List<MutableShardRouting> nodeShards = routingNode.shards();, +            for (int i = 0; i < nodeShards.size(); i++) {, +                MutableShardRouting shardRouting = nodeShards.get(i);, +                if (predicate.apply(shardRouting)) {, +                    shards.add(shardRouting);, +                }, +            }, +        }, +        return shards;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.elasticsearch.cluster.routing.MutableShardRouting;, +import org.elasticsearch.cluster.routing.RoutingNode;, +import org.elasticsearch.cluster.routing.RoutingNodes;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +         * returned sorter is not sorted. Use {@link NodeSorter#reset(org.elasticsearch.cluster.routing.allocation.allocator.BalancedShardsAllocator.Operation, String)}, +            return new NodeSorter(nodesArray(), weight, this);, +            indices.addAll(allocation.routingTable().indicesRouting().keySet());, +            buildModelFromAssigned(routing.shards(assignedFilter));, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +            List<MutableShardRouting> unassigned = allocation.routingNodes().unassigned();, +            for (int i1 = 0; i1 < unassigned.size(); i1++) {, +                MutableShardRouting shard = unassigned.get(i1);, +                    break;]