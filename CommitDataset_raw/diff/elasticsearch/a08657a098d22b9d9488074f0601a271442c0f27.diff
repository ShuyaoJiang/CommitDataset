[+++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.cluster.NotMasterException;, +import org.elasticsearch.discovery.Discovery;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +        new AsyncSingleAction(request, listener).start();, +    }, +, +    class AsyncSingleAction {, +, +        private final ActionListener<Response> listener;, +        private final Request request;, +        private volatile ClusterStateObserver observer;, +, +        private final ClusterStateObserver.ChangePredicate retryableOrNoBlockPredicate = new ClusterStateObserver.ValidationPredicate() {, +            @Override, +            protected boolean validate(ClusterState newState) {, +                ClusterBlockException blockException = checkBlock(request, newState);, +                return (blockException == null || !blockException.retryable());, +            }, +        };, +, +        AsyncSingleAction(Request request, ActionListener<Response> listener) {, +            this.request = request;, +            this.listener = listener;, +        public void start() {, +            this.observer = new ClusterStateObserver(clusterService, request.masterNodeTimeout(), logger);, +            doStart();, +        }, +, +        protected void doStart() {, +                        logger.trace("can't execute due to a cluster block, retrying", blockException);, +                        retry(blockException, retryableOrNoBlockPredicate);, +                    }, +                } else {, +                    ActionListener<Response> delegate = new ActionListener<Response>() {, +                        @Override, +                        public void onResponse(Response response) {, +                            listener.onResponse(response);, +                        }, +, +                        @Override, +                        public void onFailure(Throwable t) {, +                            if (t instanceof Discovery.FailedToCommitClusterStateException, +                                    || (t instanceof NotMasterException)) {, +                                logger.debug("master could not publish cluster state or stepped down before publishing action [{}], scheduling a retry", t, actionName);, +                                retry(t, masterNodeChangedPredicate);, +                            } else {, +                                listener.onFailure(t);, +                            }, +                        }, +                    };, +                    threadPool.executor(executor).execute(new ActionRunnable(delegate) {, +                            masterOperation(request, clusterService.state(), delegate);, +                    retry(new MasterNotDiscoveredException(), masterNodeChangedPredicate);, +                } else {, +                    transportService.sendRequest(nodes.masterNode(), actionName, request, new ActionListenerResponseHandler<Response>(listener) {, +                            Throwable cause = exp.unwrapCause();, +                            if (cause instanceof ConnectTransportException) {, +                                logger.debug("connection exception while trying to forward request with action name [{}] to master node [{}], scheduling a retry. Error: [{}]",, +                                        actionName, nodes.masterNode(), exp.getDetailedMessage());, +                                retry(cause, masterNodeChangedPredicate);, +                            } else {, +                                listener.onFailure(exp);, +                            }, +                        }, +                    });, +                }, +            }, +        }, +, +        private void retry(final Throwable failure, final ClusterStateObserver.ChangePredicate changePredicate) {, +            observer.waitForNextChange(, +                new ClusterStateObserver.Listener() {, +                        doStart();, +                        logger.debug("timed out while retrying [{}] after failure (timeout [{}])", failure, actionName, timeout);, +                        listener.onFailure(failure);, +                }, changePredicate, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.cluster.NotMasterException;, +import org.elasticsearch.discovery.Discovery;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;]