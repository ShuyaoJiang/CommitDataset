[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true);, +        private final boolean preserveAliases;, +            this(state, options, System.currentTimeMillis());, +        }, +, +        Context(ClusterState state, IndicesOptions options, boolean preserveAliases) {, +            this(state, options, System.currentTimeMillis(), preserveAliases);, +           this(state, options, startTime, false);, +        }, +, +        public Context(ClusterState state, IndicesOptions options, long startTime, boolean preserveAliases) {, +            this.preserveAliases = preserveAliases;, +, +        /**, +         * This is used to prevent resolving aliases to concrete indices but this also means, +         * that we might return aliases that point to a closed index. This is currently only used, +         * by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases, +         */, +        boolean isPreserveAliases() {, +            return preserveAliases;, +        }, +                if (Strings.isEmpty(expression)) {, +                    throw new IndexNotFoundException(expression);, +                }, +                Set<String> expand = new HashSet<>();, +                    if (context.isPreserveAliases() && aliasOrIndex.isAlias()) {, +                        expand.add(entry.getKey());, +                        for (IndexMetaData meta : aliasOrIndex.getIndices()) {, +                            if (excludeState == null || meta.getState() != excludeState) {, +                                expand.add(meta.getIndex());, +                    }, +                }, +                if (add) {, +                    result.addAll(expand);, +                } else {, +                    result.removeAll(expand);, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true);, +        private final boolean preserveAliases;, +            this(state, options, System.currentTimeMillis());, +        }, +, +        Context(ClusterState state, IndicesOptions options, boolean preserveAliases) {, +            this(state, options, System.currentTimeMillis(), preserveAliases);, +           this(state, options, startTime, false);, +        }, +, +        public Context(ClusterState state, IndicesOptions options, long startTime, boolean preserveAliases) {, +            this.preserveAliases = preserveAliases;, +, +        /**, +         * This is used to prevent resolving aliases to concrete indices but this also means, +         * that we might return aliases that point to a closed index. This is currently only used, +         * by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases, +         */, +        boolean isPreserveAliases() {, +            return preserveAliases;, +        }, +                if (Strings.isEmpty(expression)) {, +                    throw new IndexNotFoundException(expression);, +                }, +                Set<String> expand = new HashSet<>();, +                    if (context.isPreserveAliases() && aliasOrIndex.isAlias()) {, +                        expand.add(entry.getKey());, +                        for (IndexMetaData meta : aliasOrIndex.getIndices()) {, +                            if (excludeState == null || meta.getState() != excludeState) {, +                                expand.add(meta.getIndex());, +                    }, +                }, +                if (add) {, +                    result.addAll(expand);, +                } else {, +                    result.removeAll(expand);, +                }, +++ b/core/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java, +        assertEquals(Arrays.toString(results), 4, results.length);, +, +    public void testFilterClosedIndicesOnAliases() {, +        MetaData.Builder mdBuilder = MetaData.builder(), +            .put(indexBuilder("test-0").state(State.OPEN).putAlias(AliasMetaData.builder("alias-0"))), +            .put(indexBuilder("test-1").state(IndexMetaData.State.CLOSE).putAlias(AliasMetaData.builder("alias-1")));, +        ClusterState state = ClusterState.builder(new ClusterName("_name")).metaData(mdBuilder).build();, +, +        IndexNameExpressionResolver.Context context = new IndexNameExpressionResolver.Context(state, IndicesOptions.lenientExpandOpen());, +        String[] strings = indexNameExpressionResolver.concreteIndices(context, "alias-*");, +        assertArrayEquals(new String[] {"test-0"}, strings);, +, +        context = new IndexNameExpressionResolver.Context(state, IndicesOptions.strictExpandOpen());, +        strings = indexNameExpressionResolver.concreteIndices(context, "alias-*");, +, +        assertArrayEquals(new String[] {"test-0"}, strings);, +    }, +, +    public void testFilteringAliases() {, +        MetaData.Builder mdBuilder = MetaData.builder(), +            .put(indexBuilder("test-0").state(State.OPEN).putAlias(AliasMetaData.builder("alias-0").filter("{ \"term\": \"foo\"}"))), +            .put(indexBuilder("test-1").state(State.OPEN).putAlias(AliasMetaData.builder("alias-1")));, +        ClusterState state = ClusterState.builder(new ClusterName("_name")).metaData(mdBuilder).build();]