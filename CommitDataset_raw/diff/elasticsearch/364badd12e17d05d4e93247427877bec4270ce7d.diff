[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessExecuteAction.java, +                    Objects.equals(query, that.query) &&, +                    Objects.equals(xContentType, that.xContentType);, +                return Objects.hash(index, document, query, xContentType);, +                out.writeOptionalString(xContentType != null ? xContentType.mediaTypeWithoutParameters(): null);, +            builder.startObject();, +            builder.endObject();, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessExecuteAction.java, +                    Objects.equals(query, that.query) &&, +                    Objects.equals(xContentType, that.xContentType);, +                return Objects.hash(index, document, query, xContentType);, +                out.writeOptionalString(xContentType != null ? xContentType.mediaTypeWithoutParameters(): null);, +            builder.startObject();, +            builder.endObject();, +++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/PainlessExecuteRequestTests.java, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;, +import org.elasticsearch.common.xcontent.XContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.test.AbstractStreamableTestCase;, +import java.io.UncheckedIOException;, +import static org.hamcrest.Matchers.equalTo;, +, +public class PainlessExecuteRequestTests extends AbstractStreamableTestCase<PainlessExecuteAction.Request> {, +, +    // Testing XContent serialization manually here, because the xContentType field in ContextSetup determines, +    // how the request needs to parse and the xcontent serialization framework randomizes that. The XContentType, +    // is not known and accessable when the test request instance is created in the xcontent serialization framework., +    // Changing that is a big change. Writing a custom xcontent test here is the best option for now, because as far, +    // as I know this request class is the only case where this is a problem., +    public final void testFromXContent() throws Exception {, +        for (int i = 0; i < 20; i++) {, +            PainlessExecuteAction.Request testInstance = createTestInstance();, +            ContextSetup contextSetup = testInstance.getContextSetup();, +            XContent xContent = randomFrom(XContentType.values()).xContent();, +            if (contextSetup != null && contextSetup.getXContentType() != null) {, +                xContent = contextSetup.getXContentType().xContent();, +            }, +, +            try (XContentBuilder builder = XContentBuilder.builder(xContent)) {, +                builder.value(testInstance);, +                StreamInput instanceInput = BytesReference.bytes(builder).streamInput();, +                try (XContentParser parser = xContent.createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, instanceInput)) {, +                    PainlessExecuteAction.Request result = PainlessExecuteAction.Request.parse(parser);, +                    assertThat(result, equalTo(testInstance));, +                }, +            }, +        }, +    }, +        XContentType xContentType = randomFrom(XContentType.values());, +        if (randomBoolean()) {, +            try {, +                XContentBuilder xContentBuilder = XContentBuilder.builder(xContentType.xContent());, +                xContentBuilder.startObject();, +                xContentBuilder.endObject();, +                doc = BytesReference.bytes(xContentBuilder);, +            } catch (IOException e) {, +                throw new UncheckedIOException(e);, +            }, +        }, +        contextSetup.setXContentType(xContentType);]