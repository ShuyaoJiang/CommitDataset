[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    public AllocationService getAllocationService() {, +        return this.allocationService;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    public AllocationService getAllocationService() {, +        return this.allocationService;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    void setRoutingService(RoutingService routingService);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    public AllocationService getAllocationService() {, +        return this.allocationService;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    void setRoutingService(RoutingService routingService);, +++ b/core/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    private RoutingService routingService;, +    public void setRoutingService(RoutingService routingService) {, +        this.routingService = routingService;, +                        return ClusterState.builder(currentState).nodes(nodesBuilder).build();, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        // we reroute not in the same cluster state update since in certain areas we rely on, +                        // the node to be in the cluster state (sampled from ClusterService#state) to be there, also, +                        // shard transitions need to better be handled in such cases, +                        master.routingService.reroute("post_node_add");, +                    }, +                        RoutingAllocation.Result routingResult = master.routingService.getAllocationService().reroute(, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    public AllocationService getAllocationService() {, +        return this.allocationService;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    void setRoutingService(RoutingService routingService);, +++ b/core/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    private RoutingService routingService;, +    public void setRoutingService(RoutingService routingService) {, +        this.routingService = routingService;, +                        return ClusterState.builder(currentState).nodes(nodesBuilder).build();, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        // we reroute not in the same cluster state update since in certain areas we rely on, +                        // the node to be in the cluster state (sampled from ClusterService#state) to be there, also, +                        // shard transitions need to better be handled in such cases, +                        master.routingService.reroute("post_node_add");, +                    }, +                        RoutingAllocation.Result routingResult = master.routingService.getAllocationService().reroute(, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/NodeJoinController.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    private final RoutingService routingService;, +    public NodeJoinController(ClusterService clusterService, RoutingService routingService, ElectMasterService electMaster, DiscoverySettings discoverySettings, Settings settings) {, +        this.routingService = routingService;, +                newState.nodes(nodesBuilder);, +, +                // reroute now to remove any dead nodes (master may have stepped down when they left and didn't update the routing table), +                // Note: also do it now to avoid assigning shards to these nodes. We will have another reroute after the cluster, +                // state is published., +                // TODO: this publishing of a cluster state with no nodes assigned to joining nodes shouldn't be needed anymore. remove., +, +                final ClusterState tmpState = newState.build();, +                RoutingAllocation.Result result = routingService.getAllocationService().reroute(tmpState, "nodes joined");, +                newState = ClusterState.builder(tmpState);, +                if (result.changed()) {, +                    newState.routingResult(result);, +                }, +                nodesBuilder = DiscoveryNodes.builder(tmpState.nodes());, +                            logger.warn("received join request from node [{}], but found existing node {} with same address, removing existing node", node, existingNode);, +            if (event.nodesDelta().hasChanges()) {, +                // we reroute not in the same cluster state update since in certain areas we rely on, +                // the node to be in the cluster state (sampled from ClusterService#state) to be there, also, +                // shard transitions need to better be handled in such cases, +                routingService.reroute("post_node_add");, +            }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    public AllocationService getAllocationService() {, +        return this.allocationService;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    void setRoutingService(RoutingService routingService);, +++ b/core/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.cluster.routing.RoutingService;, +    private RoutingService routingService;, +    public void setRoutingService(RoutingService routingService) {, +        this.routingService = routingService;, +                        return ClusterState.builder(currentState).nodes(nodesBuilder).build();, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {]