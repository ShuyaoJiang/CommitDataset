[+++ b/dev-tools/ci, +gradle --info check -Dtests.network=true -Dtests.badapples=true, +++ b/dev-tools/ci, +gradle --info check -Dtests.network=true -Dtests.badapples=true, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/monitoring/OldMonitoringIndicesBackwardsCompatibilityTests.java, +import org.elasticsearch.action.admin.indices.exists.indices.IndicesExistsResponse;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.xpack.monitoring.exporter.MonitoringDoc;, +import static org.hamcrest.Matchers.is;, +, +                // Do not start monitoring exporters at startup, +                .put(MonitoringSettings.INTERVAL.getKey(), "-1");, +            if (httpExporter) {, +                // If we're using the http exporter we need to update the port and enable it, +                NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().get();, +                TransportAddress publishAddress = nodeInfos.getNodes().get(0).getHttp().address().publishAddress();, +                InetSocketAddress address = publishAddress.address();, +                Settings.Builder settings = Settings.builder();, +                setupHttpExporter(settings, address.getPort());, +, +                logger.info("--> Enabling http exporter pointing to [localhost:{}]", address.getPort());, +                assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(settings).get());, +            // Monitoring can now start to collect new data, +            Settings.Builder settings = Settings.builder().put(MonitoringSettings.INTERVAL.getKey(), timeValueSeconds(3).getStringRep());, +            // And we wait until data have been indexed locally using either by the local or http exporter, +            MonitoringIndexNameResolver.Timestamped resolver = new IndexStatsResolver(MonitoredSystem.ES, Settings.EMPTY);, +            MonitoringDoc monitoringDoc = new MonitoringDoc(MonitoredSystem.ES.getSystem(), randomAsciiOfLength(2));, +            monitoringDoc.setTimestamp(System.currentTimeMillis());, +            final String expectedIndex = resolver.index(monitoringDoc);, +, +            logger.info("--> {} Waiting for [{}] to be created", Thread.currentThread().getName(), expectedIndex);, +            assertBusy(() -> assertTrue(client().admin().indices().prepareExists(expectedIndex).get().isExists()));, +            assertBusy(() -> assertThat(client().prepareSearch(expectedIndex).setSize(0).get().getHits().getTotalHits(), greaterThan(1L)));, +, +            if (version.before(Version.V_2_3_0)) {, +                /* We can't do anything with indexes created before 2.3 so we just assert that we didn't delete them or do, +                    anything otherwise crazy. */, +, +             * Monitoring doesn't really have a Java API so we can't test that, but we can test that we write the data we expected to, +             * write. */, +            SearchResponse firstIndices = search(new IndicesStatsResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +            SearchResponse firstNode = search(new NodeStatsResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +            SearchResponse firstState = search(new ClusterStateResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +            Arrays.stream(firstIndices.getHits().hits()).forEach(hit -> checkIndicesStats(version, hit.sourceAsMap()));, +            Arrays.stream(firstNode.getHits().hits()).forEach(hit -> checkNodeStats(version, masterNodeId, hit.sourceAsMap()));, +            Arrays.stream(firstState.getHits().hits()).forEach(hit -> checkClusterState(version, hit.sourceAsMap()));, +                    greaterThan(firstIndices.getHits().totalHits())), 1, TimeUnit.MINUTES);, +                    greaterThan(firstNode.getHits().totalHits())), 1, TimeUnit.MINUTES);, +                    greaterThan(firstState.getHits().totalHits())), 1, TimeUnit.MINUTES);, +, +        } finally {, +            /* Now we stop monitoring and disable the HTTP exporter. We also delete all data and checks multiple times, +                if they have not been re created by some in flight monitoring bulk request */, +            internalCluster().getInstances(AgentService.class).forEach(AgentService::stop);, +, +            Settings.Builder settings = Settings.builder().put(MonitoringSettings.INTERVAL.getKey(), "-1");, +            if (httpExporter) {, +                logger.info("--> Disabling http exporter after test");, +                setupHttpExporter(settings, null);, +            }, +            assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(settings).get());, +, +            CountDown retries = new CountDown(5);, +            assertBusy(() -> {, +                String[] indices = new String[]{".marvel-*", ".monitoring-*"};, +                IndicesExistsResponse existsResponse = client().admin().indices().prepareExists(indices).get();, +                if (existsResponse.isExists()) {, +                    assertAcked(client().admin().indices().prepareDelete(indices));, +                } else {, +                    retries.countDown();, +                }, +                assertThat(retries.isCountedDown(), is(true));, +            });, +        }]