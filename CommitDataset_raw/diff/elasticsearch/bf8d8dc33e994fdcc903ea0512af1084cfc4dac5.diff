[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private String format;, +    public DateHistogramBuilder format(String format) {, +        this.format = format;, +        return this;, +    }, +, +        if (format != null) {, +            builder.field("format", format);, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private String format;, +    public DateHistogramBuilder format(String format) {, +        this.format = format;, +        return this;, +    }, +, +        if (format != null) {, +            builder.field("format", format);, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +                } else if ("pre_zone_adjust_large_interval".equals(currentFieldName) || "preZoneAdjustLargeInterval".equals(currentFieldName)) {, +                    preZoneAdjustLargeInterval = parser.booleanValue();, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private String format;, +    public DateHistogramBuilder format(String format) {, +        this.format = format;, +        return this;, +    }, +, +        if (format != null) {, +            builder.field("format", format);, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +                } else if ("pre_zone_adjust_large_interval".equals(currentFieldName) || "preZoneAdjustLargeInterval".equals(currentFieldName)) {, +                    preZoneAdjustLargeInterval = parser.booleanValue();, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +import com.carrotsearch.hppc.ObjectObjectOpenHashMap;, +    private ObjectObjectOpenHashMap<String, InternalDateHistogram.Bucket> bucketsMap;, +, +    public Bucket getBucketByKey(String key) {, +        try {, +            long time = Long.parseLong(key);, +            return super.getBucketByKey(time);, +        } catch (NumberFormatException nfe) {, +            // it's not a number, so lets try to parse it as a date using the formatter., +        }, +        if (bucketsMap == null) {, +            bucketsMap = new ObjectObjectOpenHashMap<String, InternalDateHistogram.Bucket>();, +            for (InternalDateHistogram.Bucket bucket : buckets) {, +                bucketsMap.put(bucket.getKey(), bucket);, +            }, +        }, +        return bucketsMap.get(key);, +    }, +, +    @Override, +, +    @Override, +    public void readFrom(StreamInput in) throws IOException {, +        super.readFrom(in);, +        bucketsMap = null; // we need to reset this on read (as it's lazily created on demand), +    }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramBuilder.java, +    private String format;, +    public DateHistogramBuilder format(String format) {, +        this.format = format;, +        return this;, +    }, +, +        if (format != null) {, +            builder.field("format", format);, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +                } else if ("pre_zone_adjust_large_interval".equals(currentFieldName) || "preZoneAdjustLargeInterval".equals(currentFieldName)) {, +                    preZoneAdjustLargeInterval = parser.booleanValue();, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +import com.carrotsearch.hppc.ObjectObjectOpenHashMap;, +    private ObjectObjectOpenHashMap<String, InternalDateHistogram.Bucket> bucketsMap;, +, +    public Bucket getBucketByKey(String key) {, +        try {, +            long time = Long.parseLong(key);, +            return super.getBucketByKey(time);, +        } catch (NumberFormatException nfe) {, +            // it's not a number, so lets try to parse it as a date using the formatter., +        }, +        if (bucketsMap == null) {, +            bucketsMap = new ObjectObjectOpenHashMap<String, InternalDateHistogram.Bucket>();, +            for (InternalDateHistogram.Bucket bucket : buckets) {, +                bucketsMap.put(bucket.getKey(), bucket);, +            }, +        }, +        return bucketsMap.get(key);, +    }]