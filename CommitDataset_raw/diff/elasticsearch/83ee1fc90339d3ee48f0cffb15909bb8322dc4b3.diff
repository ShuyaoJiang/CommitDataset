[+++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public boolean syncNeeded() {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public boolean syncNeeded() {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public boolean syncNeeded() {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +            doClose();, +    protected void doClose() throws IOException {, +        channelReference.decRef();, +        if (closed.get()) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public boolean syncNeeded() {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +            doClose();, +    protected void doClose() throws IOException {, +        channelReference.decRef();, +        if (closed.get()) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +    public static TranslogWriter create(Type type, ShardId shardId, String translogUUID, long fileGeneration, Path file, Callback<ChannelReference> onClose, int bufferSize) throws IOException {, +        final FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);, +            operationCounter = operationCounter + 1;, +    protected final void doClose() throws IOException {, +        try (ReleasableLock lock = writeLock.acquire()) {, +            sync();, +        } finally {, +            super.doClose();, +        }, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public boolean syncNeeded() {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +            doClose();, +    protected void doClose() throws IOException {, +        channelReference.decRef();, +        if (closed.get()) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +    public static TranslogWriter create(Type type, ShardId shardId, String translogUUID, long fileGeneration, Path file, Callback<ChannelReference> onClose, int bufferSize) throws IOException {, +        final FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);, +            operationCounter = operationCounter + 1;, +    protected final void doClose() throws IOException {, +        try (ReleasableLock lock = writeLock.acquire()) {, +            sync();, +        } finally {, +            super.doClose();, +        }, +    }, +, +    @Override, +++ b/core/src/test/java/org/elasticsearch/index/query/RangeQueryBuilderTests.java, +import org.elasticsearch.common.ParseFieldMatcher;, +import org.hamcrest.core.IsEqual;, +]