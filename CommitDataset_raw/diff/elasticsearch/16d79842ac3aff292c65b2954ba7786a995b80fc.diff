[+++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +    public SearchTransportService(Settings settings, TransportService transportService) {, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +    public SearchTransportService(Settings settings, TransportService transportService) {, +, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +    private Map<String, AliasFilter> buildPerIndexAliasFilter(SearchRequest request, ClusterState clusterState, Index[] concreteIndices) {, +, +        Index[] indices = indexNameExpressionResolver.concreteIndices(clusterState, searchRequest.indicesOptions(),, +            startTimeInMillis, searchRequest.indices());, +        Map<String, AliasFilter> aliasFilter = buildPerIndexAliasFilter(searchRequest, clusterState, indices);, +        GroupShardsIterator shardIterators = clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap,, +        searchAsyncAction((SearchTask)task, searchRequest, shardIterators, startTimeInMillis, clusterState,, +                                                        long startTime, ClusterState state,  Map<String, AliasFilter> aliasFilter,, +        final Function<String, DiscoveryNode> nodesLookup = state.nodes()::get;, +        final long clusterStateVersion = state.version();, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +    public SearchTransportService(Settings settings, TransportService transportService) {, +, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +    private Map<String, AliasFilter> buildPerIndexAliasFilter(SearchRequest request, ClusterState clusterState, Index[] concreteIndices) {, +, +        Index[] indices = indexNameExpressionResolver.concreteIndices(clusterState, searchRequest.indicesOptions(),, +            startTimeInMillis, searchRequest.indices());, +        Map<String, AliasFilter> aliasFilter = buildPerIndexAliasFilter(searchRequest, clusterState, indices);, +        GroupShardsIterator shardIterators = clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap,, +        searchAsyncAction((SearchTask)task, searchRequest, shardIterators, startTimeInMillis, clusterState,, +                                                        long startTime, ClusterState state,  Map<String, AliasFilter> aliasFilter,, +        final Function<String, DiscoveryNode> nodesLookup = state.nodes()::get;, +        final long clusterStateVersion = state.version();, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +    public SearchTransportService(Settings settings, TransportService transportService) {, +, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +    private Map<String, AliasFilter> buildPerIndexAliasFilter(SearchRequest request, ClusterState clusterState, Index[] concreteIndices) {, +, +        Index[] indices = indexNameExpressionResolver.concreteIndices(clusterState, searchRequest.indicesOptions(),, +            startTimeInMillis, searchRequest.indices());, +        Map<String, AliasFilter> aliasFilter = buildPerIndexAliasFilter(searchRequest, clusterState, indices);, +        GroupShardsIterator shardIterators = clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap,, +        searchAsyncAction((SearchTask)task, searchRequest, shardIterators, startTimeInMillis, clusterState,, +                                                        long startTime, ClusterState state,  Map<String, AliasFilter> aliasFilter,, +        final Function<String, DiscoveryNode> nodesLookup = state.nodes()::get;, +        final long clusterStateVersion = state.version();, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +++ b/core/src/main/java/org/elasticsearch/index/query/BoolQueryBuilder.java, +    private static final ParseField MINIMUM_SHOULD_MATCH = new ParseField("minimum_should_match", "minimum_number_should_match");, +     * @see #minimumShouldMatch(int), +     *  @see #minimumShouldMatch(int), +     * Sets the minimum should match as an integer value., +     */, +    public BoolQueryBuilder minimumShouldMatch(int minimumShouldMatch) {, +        this.minimumShouldMatch = Integer.toString(minimumShouldMatch);, +        return this;, +    }, +, +    /**, +        boolQuery.minimumShouldMatch(minimumShouldMatch);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +    public SearchTransportService(Settings settings, TransportService transportService) {, +, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +    private Map<String, AliasFilter> buildPerIndexAliasFilter(SearchRequest request, ClusterState clusterState, Index[] concreteIndices) {, +, +        Index[] indices = indexNameExpressionResolver.concreteIndices(clusterState, searchRequest.indicesOptions(),, +            startTimeInMillis, searchRequest.indices());, +        Map<String, AliasFilter> aliasFilter = buildPerIndexAliasFilter(searchRequest, clusterState, indices);, +        GroupShardsIterator shardIterators = clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap,, +        searchAsyncAction((SearchTask)task, searchRequest, shardIterators, startTimeInMillis, clusterState,, +                                                        long startTime, ClusterState state,  Map<String, AliasFilter> aliasFilter,, +        final Function<String, DiscoveryNode> nodesLookup = state.nodes()::get;, +        final long clusterStateVersion = state.version();, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +++ b/core/src/main/java/org/elasticsearch/index/query/BoolQueryBuilder.java, +    private static final ParseField MINIMUM_SHOULD_MATCH = new ParseField("minimum_should_match", "minimum_number_should_match");, +     * @see #minimumShouldMatch(int), +     *  @see #minimumShouldMatch(int), +     * Sets the minimum should match as an integer value., +     */, +    public BoolQueryBuilder minimumShouldMatch(int minimumShouldMatch) {, +        this.minimumShouldMatch = Integer.toString(minimumShouldMatch);, +        return this;, +    }, +, +    /**]