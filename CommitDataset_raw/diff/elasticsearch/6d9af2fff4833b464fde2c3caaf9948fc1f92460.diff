[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java, +    public PutMappingClusterStateUpdateRequest() {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java, +    public PutMappingClusterStateUpdateRequest() {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.apache.lucene.util.IOUtils;, +            Map<Index, MapperService> indexMapperServices = new HashMap<>();, +                            if (indexMapperServices.containsKey(indexMetaData.getIndex()) == false) {, +                                MapperService mapperService = indicesService.createIndexMapperService(indexMetaData);, +                                indexMapperServices.put(index, mapperService);, +                                    mapperService.merge(mapping.value.type(), mapping.value.source(),, +                        currentState = applyRequest(currentState, request, indexMapperServices);, +                IOUtils.close(indexMapperServices.values());, +        private ClusterState applyRequest(ClusterState currentState, PutMappingClusterStateUpdateRequest request,, +                                          Map<Index, MapperService> indexMapperServices) throws IOException {, +            final List<IndexMetaData> updateList = new ArrayList<>();, +                MapperService mapperService = indexMapperServices.get(index);, +                // this is paranoia... just to be sure we use the exact same metadata tuple on the update that, +                updateList.add(indexMetaData);, +                DocumentMapper existingMapper = mapperService.documentMapper(request.type());, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, false);, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, existingMapper == null);, +                                        mapperService.getParentTypes().contains(parentType) == false) {, +            boolean updated = false;, +            for (IndexMetaData indexMetaData : updateList) {, +                final MapperService mapperService = indexMapperServices.get(index);, +                DocumentMapper existingMapper = mapperService.documentMapper(mappingType);, +                DocumentMapper mergedMapper = mapperService.merge(mappingType, mappingUpdateSource, MapperService.MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                        updated = true;, +                    updated = true;, +                for (DocumentMapper mapper : mapperService.docMappers(true)) {, +            if (updated) {, +            } else {, +                return currentState;, +            }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java, +    public PutMappingClusterStateUpdateRequest() {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.apache.lucene.util.IOUtils;, +            Map<Index, MapperService> indexMapperServices = new HashMap<>();, +                            if (indexMapperServices.containsKey(indexMetaData.getIndex()) == false) {, +                                MapperService mapperService = indicesService.createIndexMapperService(indexMetaData);, +                                indexMapperServices.put(index, mapperService);, +                                    mapperService.merge(mapping.value.type(), mapping.value.source(),, +                        currentState = applyRequest(currentState, request, indexMapperServices);, +                IOUtils.close(indexMapperServices.values());, +        private ClusterState applyRequest(ClusterState currentState, PutMappingClusterStateUpdateRequest request,, +                                          Map<Index, MapperService> indexMapperServices) throws IOException {, +            final List<IndexMetaData> updateList = new ArrayList<>();, +                MapperService mapperService = indexMapperServices.get(index);, +                // this is paranoia... just to be sure we use the exact same metadata tuple on the update that, +                updateList.add(indexMetaData);, +                DocumentMapper existingMapper = mapperService.documentMapper(request.type());, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, false);, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, existingMapper == null);, +                                        mapperService.getParentTypes().contains(parentType) == false) {, +            boolean updated = false;, +            for (IndexMetaData indexMetaData : updateList) {, +                final MapperService mapperService = indexMapperServices.get(index);, +                DocumentMapper existingMapper = mapperService.documentMapper(mappingType);, +                DocumentMapper mergedMapper = mapperService.merge(mappingType, mappingUpdateSource, MapperService.MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                        updated = true;, +                    updated = true;, +                for (DocumentMapper mapper : mapperService.docMappers(true)) {, +            if (updated) {, +            } else {, +                return currentState;, +            }, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.index.mapper.MapperService;, +     * creates a new mapper service to do administrative work like mapping updates. This *should not* be used for document parsing., +     * doing so will result in an exception., +     */, +    public MapperService newIndexMapperService(MapperRegistry mapperRegistry) throws IOException {, +        return new MapperService(indexSettings, analysisRegistry.build(indexSettings),, +            new SimilarityService(indexSettings, similarities), mapperRegistry,, +            () -> { throw new UnsupportedOperationException("no index query shard context available"); });, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java, +    public PutMappingClusterStateUpdateRequest() {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.apache.lucene.util.IOUtils;, +            Map<Index, MapperService> indexMapperServices = new HashMap<>();, +                            if (indexMapperServices.containsKey(indexMetaData.getIndex()) == false) {, +                                MapperService mapperService = indicesService.createIndexMapperService(indexMetaData);, +                                indexMapperServices.put(index, mapperService);, +                                    mapperService.merge(mapping.value.type(), mapping.value.source(),, +                        currentState = applyRequest(currentState, request, indexMapperServices);, +                IOUtils.close(indexMapperServices.values());, +        private ClusterState applyRequest(ClusterState currentState, PutMappingClusterStateUpdateRequest request,, +                                          Map<Index, MapperService> indexMapperServices) throws IOException {, +            final List<IndexMetaData> updateList = new ArrayList<>();, +                MapperService mapperService = indexMapperServices.get(index);, +                // this is paranoia... just to be sure we use the exact same metadata tuple on the update that, +                updateList.add(indexMetaData);, +                DocumentMapper existingMapper = mapperService.documentMapper(request.type());, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, false);, +                    newMapper = mapperService.parse(request.type(), mappingUpdateSource, existingMapper == null);]