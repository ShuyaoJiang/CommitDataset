[+++ b/plugins/analysis-icu/src/main/java/org/elasticsearch/index/analysis/IcuTokenizerFactory.java, +                final RuleBasedBreakIterator breakers[] = new RuleBasedBreakIterator[UScript.CODE_LIMIT];, +    private RuleBasedBreakIterator parseRules(String filename, Environment env) throws IOException {, +++ b/plugins/analysis-icu/src/main/java/org/elasticsearch/index/analysis/IcuTokenizerFactory.java, +                final RuleBasedBreakIterator breakers[] = new RuleBasedBreakIterator[UScript.CODE_LIMIT];, +    private RuleBasedBreakIterator parseRules(String filename, Environment env) throws IOException {, +++ b/server/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_6_2_0 = new Version(V_6_2_0_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_1 = new Version(V_6_2_1_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_2 = new Version(V_6_2_2_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_3 = new Version(V_6_2_3_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_4 = new Version(V_6_2_4_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_5 = new Version(V_6_2_5_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +++ b/plugins/analysis-icu/src/main/java/org/elasticsearch/index/analysis/IcuTokenizerFactory.java, +                final RuleBasedBreakIterator breakers[] = new RuleBasedBreakIterator[UScript.CODE_LIMIT];, +    private RuleBasedBreakIterator parseRules(String filename, Environment env) throws IOException {, +++ b/server/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_6_2_0 = new Version(V_6_2_0_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_1 = new Version(V_6_2_1_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_2 = new Version(V_6_2_2_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_3 = new Version(V_6_2_3_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_4 = new Version(V_6_2_4_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_5 = new Version(V_6_2_5_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/AliasMetaData.java, +public class AliasMetaData extends AbstractDiffable<AliasMetaData> {, +++ b/plugins/analysis-icu/src/main/java/org/elasticsearch/index/analysis/IcuTokenizerFactory.java, +                final RuleBasedBreakIterator breakers[] = new RuleBasedBreakIterator[UScript.CODE_LIMIT];, +    private RuleBasedBreakIterator parseRules(String filename, Environment env) throws IOException {, +++ b/server/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_6_2_0 = new Version(V_6_2_0_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_1 = new Version(V_6_2_1_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_2 = new Version(V_6_2_2_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_3 = new Version(V_6_2_3_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_4 = new Version(V_6_2_4_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +    public static final Version V_6_2_5 = new Version(V_6_2_5_ID, org.apache.lucene.util.Version.LUCENE_7_2_1);, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/AliasMetaData.java, +public class AliasMetaData extends AbstractDiffable<AliasMetaData> {, +++ b/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.FilterDirectoryReader;, +import org.apache.lucene.index.SoftDeletesDirectoryReaderWrapper;, +    public static final String SOFT_DELETE_FIELD = "__soft_delete";, +, +     * Unlike {@link #getNumDocs(SegmentInfos)} this method returns a numDocs that always excludes soft-deleted docs., +     * This method is expensive thus prefer using {@link #getNumDocs(SegmentInfos)} unless an exact numDocs is required., +     */, +    public static int getExactNumDocs(IndexCommit commit) throws IOException {, +        try (DirectoryReader reader = DirectoryReader.open(commit)) {, +            return new SoftDeletesDirectoryReaderWrapper(reader, Lucene.SOFT_DELETE_FIELD).numDocs();, +        }, +    }, +, +    /**, +, +    /**, +     * Wraps a directory reader to include all live docs., +     * The wrapped reader can be used to query all documents., +     *, +     * @param in the input directory reader, +     * @return the wrapped reader, +     */, +    public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {, +        return new DirectoryReaderWithAllLiveDocs(in);, +    }, +, +    private static final class DirectoryReaderWithAllLiveDocs extends FilterDirectoryReader {, +        static final class SubReaderWithAllLiveDocs extends FilterLeafReader {, +            SubReaderWithAllLiveDocs(LeafReader in) {, +                super(in);, +            }, +            @Override, +            public Bits getLiveDocs() {, +                return null;, +            }, +            @Override, +            public int numDocs() {, +                return maxDoc();, +            }, +            @Override, +            public CacheHelper getCoreCacheHelper() {, +                return in.getCoreCacheHelper();, +            }, +            @Override, +            public CacheHelper getReaderCacheHelper() {, +                return null; // Modifying liveDocs, +            }, +        }, +        DirectoryReaderWithAllLiveDocs(DirectoryReader in) throws IOException {, +            super(in, new FilterDirectoryReader.SubReaderWrapper() {, +                @Override, +                public LeafReader wrap(LeafReader leaf) {, +                    return new SubReaderWithAllLiveDocs(leaf);, +                }, +            });, +        }, +        @Override, +        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) throws IOException {, +            return wrapAllDocsLive(in);, +        }, +]