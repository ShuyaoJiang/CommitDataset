[+++ b/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +import org.apache.lucene.search.BooleanClause.Occur;, +            } if (severalTokensAtSamePosition && occur == Occur.MUST) {, +                BooleanQuery q = new BooleanQuery(positionCount == 1);, +                Query currentQuery = null;, +                for (int i = 0; i < numTokens; i++) {, +                    boolean hasNext = buffer.incrementToken();, +                    assert hasNext == true;, +                  if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {, +                    if (!(currentQuery instanceof BooleanQuery)) {, +                      Query t = currentQuery;, +                      currentQuery = new BooleanQuery(true);, +                      ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);, +                    }, +                    ((BooleanQuery)currentQuery).add(newTermQuery(mapper, new Term(field, termToByteRef(termAtt))), BooleanClause.Occur.SHOULD);, +                  } else {, +                    if (currentQuery != null) {, +                      q.add(currentQuery, occur);, +                    }, +                    currentQuery = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));, +                  }, +                }, +                q.add(currentQuery, occur);, +                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);, +++ b/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +import org.apache.lucene.search.BooleanClause.Occur;, +            } if (severalTokensAtSamePosition && occur == Occur.MUST) {, +                BooleanQuery q = new BooleanQuery(positionCount == 1);, +                Query currentQuery = null;, +                for (int i = 0; i < numTokens; i++) {, +                    boolean hasNext = buffer.incrementToken();, +                    assert hasNext == true;, +                  if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {, +                    if (!(currentQuery instanceof BooleanQuery)) {, +                      Query t = currentQuery;, +                      currentQuery = new BooleanQuery(true);, +                      ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);, +                    }, +                    ((BooleanQuery)currentQuery).add(newTermQuery(mapper, new Term(field, termToByteRef(termAtt))), BooleanClause.Occur.SHOULD);, +                  } else {, +                    if (currentQuery != null) {, +                      q.add(currentQuery, occur);, +                    }, +                    currentQuery = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));, +                  }, +                }, +                q.add(currentQuery, occur);, +                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);, +++ b/src/test/java/org/elasticsearch/count/query/SimpleQueryTests.java, +import static org.hamcrest.Matchers.*;, +++ b/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +import org.apache.lucene.search.BooleanClause.Occur;, +            } if (severalTokensAtSamePosition && occur == Occur.MUST) {, +                BooleanQuery q = new BooleanQuery(positionCount == 1);, +                Query currentQuery = null;, +                for (int i = 0; i < numTokens; i++) {, +                    boolean hasNext = buffer.incrementToken();, +                    assert hasNext == true;, +                  if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {, +                    if (!(currentQuery instanceof BooleanQuery)) {, +                      Query t = currentQuery;, +                      currentQuery = new BooleanQuery(true);, +                      ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);, +                    }, +                    ((BooleanQuery)currentQuery).add(newTermQuery(mapper, new Term(field, termToByteRef(termAtt))), BooleanClause.Occur.SHOULD);, +                  } else {, +                    if (currentQuery != null) {, +                      q.add(currentQuery, occur);, +                    }, +                    currentQuery = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));, +                  }, +                }, +                q.add(currentQuery, occur);, +                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);, +++ b/src/test/java/org/elasticsearch/count/query/SimpleQueryTests.java, +import static org.hamcrest.Matchers.*;, +++ b/src/test/java/org/elasticsearch/search/query/SimpleQueryTests.java, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;, +    , +    // see #3881 - for extensive description of the issue, +    @Test, +    public void testMatchQueryWithSynonyms() throws IOException {, +        CreateIndexRequestBuilder builder = prepareCreate("test").setSettings(settingsBuilder(), +                .put(SETTING_NUMBER_OF_SHARDS, 1), +                .put(SETTING_NUMBER_OF_REPLICAS, 0), +                .put("index.analysis.analyzer.index.type", "custom"), +                .put("index.analysis.analyzer.index.tokenizer", "standard"), +                .put("index.analysis.analyzer.index.filter", "lowercase"), +                .put("index.analysis.analyzer.search.type", "custom"), +                                .put("index.analysis.analyzer.search.tokenizer", "standard"), +, +                .putArray("index.analysis.analyzer.search.filter", "lowercase", "synonym"), +                .put("index.analysis.filter.synonym.type", "synonym"), +                .putArray("index.analysis.filter.synonym.synonyms", "fast, quick"));, +        , +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("test")]