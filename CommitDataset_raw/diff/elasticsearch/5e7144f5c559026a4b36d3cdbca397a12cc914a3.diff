[+++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    private final IndexingMemoryController indexingMemoryController;, +                        MapperRegistry mapperRegistry,, +                        IndexingMemoryController indexingMemoryController) throws IOException {, +        this.indexingMemoryController = indexingMemoryController;, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, slowLog, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    private final IndexingMemoryController indexingMemoryController;, +                        MapperRegistry mapperRegistry,, +                        IndexingMemoryController indexingMemoryController) throws IOException {, +        this.indexingMemoryController = indexingMemoryController;, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, slowLog, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/NodeServicesProvider.java, +    public NodeServicesProvider(ThreadPool threadPool, IndicesQueryCache indicesQueryCache, TermVectorsService termVectorsService, @Nullable IndicesWarmer warmer, BigArrays bigArrays, Client client, ScriptService scriptService, IndicesQueriesRegistry indicesQueriesRegistry, IndicesFieldDataCache indicesFieldDataCache, CircuitBreakerService circuitBreakerService) {, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    private final IndexingMemoryController indexingMemoryController;, +                        MapperRegistry mapperRegistry,, +                        IndexingMemoryController indexingMemoryController) throws IOException {, +        this.indexingMemoryController = indexingMemoryController;, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, slowLog, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/NodeServicesProvider.java, +    public NodeServicesProvider(ThreadPool threadPool, IndicesQueryCache indicesQueryCache, TermVectorsService termVectorsService, @Nullable IndicesWarmer warmer, BigArrays bigArrays, Client client, ScriptService scriptService, IndicesQueriesRegistry indicesQueriesRegistry, IndicesFieldDataCache indicesFieldDataCache, CircuitBreakerService circuitBreakerService) {, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this, +     *  across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents, +     *  being indexed/deleted. */, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    private final IndexingMemoryController indexingMemoryController;, +                        MapperRegistry mapperRegistry,, +                        IndexingMemoryController indexingMemoryController) throws IOException {, +        this.indexingMemoryController = indexingMemoryController;, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, slowLog, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/NodeServicesProvider.java, +    public NodeServicesProvider(ThreadPool threadPool, IndicesQueryCache indicesQueryCache, TermVectorsService termVectorsService, @Nullable IndicesWarmer warmer, BigArrays bigArrays, Client client, ScriptService scriptService, IndicesQueriesRegistry indicesQueriesRegistry, IndicesFieldDataCache indicesFieldDataCache, CircuitBreakerService circuitBreakerService) {, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this, +     *  across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents, +     *  being indexed/deleted. */, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.shard.IndexingOperationListener;, +public class IndexingMemoryController extends AbstractComponent implements IndexingOperationListener, Closeable {, +, +        // Need to save this so we can later launch async "write indexing buffer to disk" on shards:, +        this.threadPool = threadPool;, +        if (threadPool != null) {, +        } else {, +            // tests pass null for threadPool --> no periodic checking, +            return null;, +        }, +    @Override, +    public void postIndex(Engine.Index index) {, +        bytesWritten(index.getTranslogLocation().size);        , +    }, +, +    @Override, +    public void postDelete(Engine.Delete delete) {, +        bytesWritten(delete.getTranslogLocation().size);        , +    }, +, +    private static final class ShardAndBytesUsed implements Comparable<ShardAndBytesUsed> {, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter, NodeServicesProvider servicesProvider, MapperRegistry mapperRegistry,, +                                        IndexingMemoryController indexingMemoryController) throws IOException {, +                servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indexingMemoryController);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.indices.IndexingMemoryController;, +    private final IndexingMemoryController indexingMemoryController;, +                        MapperRegistry mapperRegistry,, +                        IndexingMemoryController indexingMemoryController) throws IOException {]