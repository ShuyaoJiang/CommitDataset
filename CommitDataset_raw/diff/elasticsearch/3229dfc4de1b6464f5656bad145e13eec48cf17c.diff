[+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java, +        return createSearchContext(request, timeout, true, "search");, +                                                     boolean assertAsyncActions, String source), +        Engine.Searcher engineSearcher = indexShard.acquireSearcher(source);, +        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {, +++ b/server/src/main/java/org/elasticsearch/search/SearchService.java, +        return createSearchContext(request, timeout, true, "search");, +                                                     boolean assertAsyncActions, String source), +        Engine.Searcher engineSearcher = indexShard.acquireSearcher(source);, +        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/index/engine/FrozenEngine.java, +import org.apache.lucene.store.Directory;, +import java.util.concurrent.CountDownLatch;, +    private final DirectoryReader canMatchReader;, +, +        boolean success = false;, +        Directory directory = store.directory();, +        try (DirectoryReader reader = DirectoryReader.open(directory)) {, +            canMatchReader = new RewriteCachingDirectoryReader(directory, reader.leaves());, +            success = true;, +        } catch (IOException e) {, +            throw new UncheckedIOException(e);, +        } finally {, +            if (success == false) {, +                closeNoLock("failed on construction", new CountDownLatch(1));, +            }, +        }, +                case "can_match": // special case for can_match phase - we use the cached point values reader, +                if ("can_match".equals(source)) {, +                    canMatchReader.incRef();, +                    return new Searcher(source, new IndexSearcher(canMatchReader), canMatchReader::decRef);, +                }, +++ b/server/src/main/java/org/elasticsearch/search/SearchService.java, +        return createSearchContext(request, timeout, true, "search");, +                                                     boolean assertAsyncActions, String source), +        Engine.Searcher engineSearcher = indexShard.acquireSearcher(source);, +        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/index/engine/FrozenEngine.java, +import org.apache.lucene.store.Directory;, +import java.util.concurrent.CountDownLatch;, +    private final DirectoryReader canMatchReader;, +, +        boolean success = false;, +        Directory directory = store.directory();, +        try (DirectoryReader reader = DirectoryReader.open(directory)) {, +            canMatchReader = new RewriteCachingDirectoryReader(directory, reader.leaves());, +            success = true;, +        } catch (IOException e) {, +            throw new UncheckedIOException(e);, +        } finally {, +            if (success == false) {, +                closeNoLock("failed on construction", new CountDownLatch(1));, +            }, +        }, +                case "can_match": // special case for can_match phase - we use the cached point values reader, +                if ("can_match".equals(source)) {, +                    canMatchReader.incRef();, +                    return new Searcher(source, new IndexSearcher(canMatchReader), canMatchReader::decRef);, +                }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/index/engine/RewriteCachingDirectoryReader.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.index.engine;, +, +import org.apache.lucene.index.BinaryDocValues;, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.index.FieldInfo;, +import org.apache.lucene.index.FieldInfos;, +import org.apache.lucene.index.Fields;, +import org.apache.lucene.index.IndexCommit;, +import org.apache.lucene.index.IndexWriter;, +import org.apache.lucene.index.LeafMetaData;, +import org.apache.lucene.index.LeafReader;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.NumericDocValues;, +import org.apache.lucene.index.PointValues;, +import org.apache.lucene.index.SortedDocValues;, +import org.apache.lucene.index.SortedNumericDocValues;, +import org.apache.lucene.index.SortedSetDocValues;, +import org.apache.lucene.index.StoredFieldVisitor;, +import org.apache.lucene.index.Terms;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.util.Bits;, +, +import java.io.IOException;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +, +/**, + * This special DirectoryReader is used to handle can_match requests against frozen indices., + * It' caches all relevant point value data for every point value field ie. min/max packed values etc., + * to hold enough information to rewrite a date range query and make a decisions if an index can match or not., + * This allows frozen indices to be searched with wildcards in a very efficient way without opening a reader on them., + */, +final class RewriteCachingDirectoryReader extends DirectoryReader {, +]