[+++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +        if (explanation.getDescription() == null) {, +            throw new ElasticsearchIllegalArgumentException("Explanation descriptions should NOT be null\n[" + explanation.toString() + "]");, +        }, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +        if (explanation.getDescription() == null) {, +            throw new ElasticsearchIllegalArgumentException("Explanation descriptions should NOT be null\n[" + explanation.toString() + "]");, +        }, +++ b/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.queries.TermFilter;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +            DocIdSet docAndNestedDocsIdSet = null;, +            if (context.mapperService().documentMapper(hitContext.hit().type()).hasNestedObjects()) {, +                // Both main and nested Lucene docs have a _uid field, +                Filter docAndNestedDocsFilter = new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id())));, +                docAndNestedDocsIdSet = docAndNestedDocsFilter.getDocIdSet(hitContext.readerContext(), null);, +            }, +            addMatchedQueries(hitContext, context.parsedQuery().namedFilters(), matchedQueries, docAndNestedDocsIdSet);, +                addMatchedQueries(hitContext, context.parsedPostFilter().namedFilters(), matchedQueries, docAndNestedDocsIdSet);, +    private void addMatchedQueries(HitContext hitContext, ImmutableMap<String, Filter> namedFiltersAndQueries, List<String> matchedQueries, DocIdSet docAndNestedDocsIdSet) throws IOException {, +                if (!DocIdSets.isEmpty(docAndNestedDocsIdSet)) {, +                    DocIdSetIterator filterIterator = filterDocIdSet.iterator();, +                    DocIdSetIterator docAndNestedDocsIterator = docAndNestedDocsIdSet.iterator();, +                    if (filterIterator != null && docAndNestedDocsIterator != null) {, +                        int matchedDocId = -1;, +                        for (int docId = docAndNestedDocsIterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = docAndNestedDocsIterator.nextDoc()) {, +                            if (docId != matchedDocId) {, +                                matchedDocId = filterIterator.advance(docId);, +                            }, +                            if (matchedDocId == docId) {, +                                matchedQueries.add(name);, +                                break;, +                            }, +                        }, +                    }, +                } else {, +}, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +        if (explanation.getDescription() == null) {, +            throw new ElasticsearchIllegalArgumentException("Explanation descriptions should NOT be null\n[" + explanation.toString() + "]");, +        }, +++ b/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.queries.TermFilter;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +            DocIdSet docAndNestedDocsIdSet = null;, +            if (context.mapperService().documentMapper(hitContext.hit().type()).hasNestedObjects()) {, +                // Both main and nested Lucene docs have a _uid field, +                Filter docAndNestedDocsFilter = new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id())));, +                docAndNestedDocsIdSet = docAndNestedDocsFilter.getDocIdSet(hitContext.readerContext(), null);, +            }, +            addMatchedQueries(hitContext, context.parsedQuery().namedFilters(), matchedQueries, docAndNestedDocsIdSet);, +                addMatchedQueries(hitContext, context.parsedPostFilter().namedFilters(), matchedQueries, docAndNestedDocsIdSet);, +    private void addMatchedQueries(HitContext hitContext, ImmutableMap<String, Filter> namedFiltersAndQueries, List<String> matchedQueries, DocIdSet docAndNestedDocsIdSet) throws IOException {, +                if (!DocIdSets.isEmpty(docAndNestedDocsIdSet)) {, +                    DocIdSetIterator filterIterator = filterDocIdSet.iterator();, +                    DocIdSetIterator docAndNestedDocsIterator = docAndNestedDocsIdSet.iterator();, +                    if (filterIterator != null && docAndNestedDocsIterator != null) {, +                        int matchedDocId = -1;, +                        for (int docId = docAndNestedDocsIterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = docAndNestedDocsIterator.nextDoc()) {, +                            if (docId != matchedDocId) {, +                                matchedDocId = filterIterator.advance(docId);, +                            }, +                            if (matchedDocId == docId) {, +                                matchedQueries.add(name);, +                                break;, +                            }, +                        }, +                    }, +                } else {, +}, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/TopHitsTests.java, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.emptyArray;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.hamcrest.Matchers.nullValue;, +import static org.hamcrest.Matchers.sameInstance;, +    @Test @AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/10661"), +        assertThat(searchHit.matchedQueries(), emptyArray());]