[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            final float indexBalance = settings.getAsFloat(SETTING_INDEX_BALANCE_FACTOR, weightFunction.indexBalance);, +            final float shardBalance = settings.getAsFloat(SETTING_SHARD_BALANCE_FACTOR, weightFunction.shardBalance);, +            final float primaryBalance = settings.getAsFloat(SETTING_PRIMARY_BALANCE_FACTOR, weightFunction.primaryBalance);, +, +, +        private final EnumMap<Operation, float[]> thetaMap = new EnumMap<BalancedShardsAllocator.Operation, float[]>(Operation.class);, +            float sum = indexBalance + shardBalance + primaryBalance;, +            final float[] defaultTheta = new float[] {  shardBalance / sum, indexBalance / sum, primaryBalance / sum };, +            for(Operation operation : Operation.values()) {, +                switch(operation) {, +                case THRESHOLD_CHECK:, +                    sum = indexBalance + shardBalance;, +                    if (sum <= 0.0f) {, +                        thetaMap.put(operation,  defaultTheta);, +                    }, +                    thetaMap.put(operation,  new float[] { shardBalance / sum,  indexBalance / sum, 0});, +                    break;, +                case BALANCE:, +                case ALLOCATE:, +                case MOVE:, +                    thetaMap.put(operation,  defaultTheta);, +                    break;, +                default:, +                    assert false;, +                }, +            }, +            this.indexBalance = indexBalance;, +            this.shardBalance = shardBalance;, +            this.primaryBalance = primaryBalance;, +        public float weight(Operation operation, Balancer balancer, ModelNode node, String index) {, +            final float weightShard = (node.numShards() - balancer.avgShardsPerNode());, +            final float weightIndex = (node.numShards(index) - balancer.avgShardsPerNode(index));, +            final float weightPrimary = (node.numPrimaries() - balancer.avgPrimariesPerNode());, +            final float[] theta = thetaMap.get(operation);, +            assert theta != null;, +            return theta[0] * weightShard + theta[1] * weightIndex + theta[2] * weightPrimary;    , +     * An enum that donates the actual operation the {@link WeightFunction} is, +     * applied to., +     */, +    public static enum Operation {, +        /**, +         * Provided during balance operations. , +         */, +        BALANCE,, +        /**, +         * Provided during initial allocation operation for unassigned shards. , +         */, +        ALLOCATE,, +        /**, +         * Provided during move operation., +         */, +        MOVE, , +        /**, +         * Provided when the weight delta is checked against the configured threshold., +         * This can be used to ignore tie-breaking weight factors that should not , +         * solely trigger a relocation unless the delta is above the threshold. , +         */, +        THRESHOLD_CHECK, +    }, +, +    /**, +, +                for (String index : buildWeightOrderedIndidces(Operation.BALANCE, sorter)) {, +                    sorter.reset(Operation.BALANCE,index);, +                            delta = delta <= threshold ? delta : sorter.weight(Operation.THRESHOLD_CHECK, maxNode) - sorter.weight(Operation.THRESHOLD_CHECK, minNode);, +                                    , +                            if (tryRelocateShard(Operation.BALANCE, minNode, maxNode, index, delta)) {, +                                weights[lowIdx] = sorter.weight(Operation.BALANCE, modelNodes[lowIdx]);, +                                weights[highIdx] = sorter.weight(Operation.BALANCE, modelNodes[highIdx]);, +        private String[] buildWeightOrderedIndidces(Operation operation, NodeSorter sorter) {, +                sorter.reset(operation, indices[i]);, +            sorter.reset(Operation.MOVE, shard.getIndex());, +                            float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index());, +        private boolean tryRelocateShard(Operation operation, ModelNode minNode, ModelNode maxNode, String idx, float minCost) {, +                                final float delta = weight.weight(operation, this, minNode, idx) - weight.weight(operation, this, maxNode, idx);, +        public void reset(Operation operation, String index) {, +                weights[i] = weight(operation, modelNodes[i]);, +        public float weight(Operation operation, ModelNode node) {, +            return function.weight(operation, balancer, node, index);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            final float indexBalance = settings.getAsFloat(SETTING_INDEX_BALANCE_FACTOR, weightFunction.indexBalance);, +            final float shardBalance = settings.getAsFloat(SETTING_SHARD_BALANCE_FACTOR, weightFunction.shardBalance);, +            final float primaryBalance = settings.getAsFloat(SETTING_PRIMARY_BALANCE_FACTOR, weightFunction.primaryBalance);, +, +, +        private final EnumMap<Operation, float[]> thetaMap = new EnumMap<BalancedShardsAllocator.Operation, float[]>(Operation.class);, +            float sum = indexBalance + shardBalance + primaryBalance;, +            final float[] defaultTheta = new float[] {  shardBalance / sum, indexBalance / sum, primaryBalance / sum };, +            for(Operation operation : Operation.values()) {, +                switch(operation) {, +                case THRESHOLD_CHECK:, +                    sum = indexBalance + shardBalance;, +                    if (sum <= 0.0f) {, +                        thetaMap.put(operation,  defaultTheta);, +                    }, +                    thetaMap.put(operation,  new float[] { shardBalance / sum,  indexBalance / sum, 0});, +                    break;, +                case BALANCE:, +                case ALLOCATE:]