[+++ b/core/src/main/java/org/elasticsearch/index/query/AbstractQueryBuilder.java, +import org.elasticsearch.common.ParseField;, +    public static final ParseField NAME_FIELD = new ParseField("_name");, +    public static final ParseField BOOST_FIELD = new ParseField("boost");, +++ b/core/src/main/java/org/elasticsearch/index/query/AbstractQueryBuilder.java, +import org.elasticsearch.common.ParseField;, +    public static final ParseField NAME_FIELD = new ParseField("_name");, +    public static final ParseField BOOST_FIELD = new ParseField("boost");, +++ b/core/src/main/java/org/elasticsearch/index/query/GeohashCellQuery.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import java.util.Objects;, +    public static final ParseField NEIGHBORS_FIELD = new ParseField("neighbors");, +    public static final ParseField PRECISION_FIELD = new ParseField("precision");, +    public static final boolean DEFAULT_NEIGHBORS = false;, +        private String fieldName;, +        private Integer levels = null;, +        private boolean neighbors = DEFAULT_NEIGHBORS;, +            this.fieldName = field;, +        public String geohash() {, +            return geohash;, +        }, +, +        public Integer precision() {, +            return levels;, +        }, +, +        public boolean neighbors() {, +            return neighbors;, +        }, +, +        public Builder fieldName(String fieldName) {, +            this.fieldName = fieldName;, +        public String fieldName() {, +            return fieldName;, +        }, +, +        @Override, +        public QueryValidationException validate() {, +            QueryValidationException errors = null;, +            if (fieldName == null) {, +                errors = QueryValidationException.addValidationError(NAME, "fieldName must not be null", errors);, +            }, +            if (geohash == null) {, +                errors = QueryValidationException.addValidationError(NAME, "geohash or point must be defined", errors);, +            }, +            if (levels != null && levels <= 0) {, +                errors = QueryValidationException.addValidationError(NAME, "precision must be greater than 0. Found [" + levels + "]",, +                        errors);, +            }, +            return errors;, +        }, +, +        @Override, +        protected Query doToQuery(QueryShardContext context) throws IOException {, +            MappedFieldType fieldType = context.fieldMapper(fieldName);, +            if (fieldType == null) {, +                throw new QueryShardException(context, "failed to parse [{}] query. missing [{}] field [{}]", NAME,, +                        GeoPointFieldMapper.CONTENT_TYPE, fieldName);, +            }, +, +            if (!(fieldType instanceof GeoPointFieldMapper.GeoPointFieldType)) {, +                throw new QueryShardException(context, "failed to parse [{}] query. field [{}] is not a geo_point field", NAME, fieldName);, +            }, +, +            GeoPointFieldMapper.GeoPointFieldType geoFieldType = ((GeoPointFieldMapper.GeoPointFieldType) fieldType);, +            if (!geoFieldType.isGeohashPrefixEnabled()) {, +                throw new QueryShardException(context, "failed to parse [{}] query. [geohash_prefix] is not enabled for field [{}]", NAME,, +                        fieldName);, +            }, +, +            if (levels != null) {, +                int len = Math.min(levels, geohash.length());, +                geohash = geohash.substring(0, len);, +            }, +, +            Query query;, +            if (neighbors) {, +                query = create(context, geoFieldType, geohash, GeoHashUtils.addNeighbors(geohash, new ArrayList<CharSequence>(8)));, +            } else {, +                query = create(context, geoFieldType, geohash, null);, +            }, +            return query;, +        }, +, +            builder.field(NEIGHBORS_FIELD.getPreferredName(), neighbors);, +            if (levels != null) {, +                builder.field(PRECISION_FIELD.getPreferredName(), levels);, +            builder.field(fieldName, geohash);, +        protected Builder doReadFrom(StreamInput in) throws IOException {, +            String field = in.readString();, +            String geohash = in.readString();, +            Builder builder = new Builder(field, geohash);, +            if (in.readBoolean()) {, +                builder.precision(in.readVInt());, +            }, +            builder.neighbors(in.readBoolean());, +            return builder;, +        }]