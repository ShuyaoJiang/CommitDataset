[+++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +     * This method is executed on master node and it's complimentary to the, +     * {@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it, +                        final IndexShardSnapshotStatus shardSnapshotStatus;, +                        if (snapshotInfo.state() == SnapshotState.FAILED) {, +                            // If the snapshot failed, but the shard's snapshot does, +                            // not have an exception, it means that partial snapshots, +                            // were disabled and in this case, the shard snapshot will, +                            // *not* have any metadata, so attempting to read the shard, +                            // snapshot status will throw an exception.  Instead, we create, +                            // a status for the shard to indicate that the shard snapshot, +                            // could not be taken due to partial being set to false., +                            shardSnapshotStatus = new IndexShardSnapshotStatus();, +                            shardSnapshotStatus.updateStage(IndexShardSnapshotStatus.Stage.FAILURE);, +                            shardSnapshotStatus.failure("skipped");, +                        } else {, +                            shardSnapshotStatus = repository.getShardSnapshotStatus(, +                                snapshotInfo.snapshotId(),, +                                snapshotInfo.version(),, +                                indexId,, +                                shardId);, +                        }, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +     * This method is executed on master node and it's complimentary to the, +     * {@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it, +                        final IndexShardSnapshotStatus shardSnapshotStatus;, +                        if (snapshotInfo.state() == SnapshotState.FAILED) {, +                            // If the snapshot failed, but the shard's snapshot does, +                            // not have an exception, it means that partial snapshots, +                            // were disabled and in this case, the shard snapshot will, +                            // *not* have any metadata, so attempting to read the shard, +                            // snapshot status will throw an exception.  Instead, we create, +                            // a status for the shard to indicate that the shard snapshot, +                            // could not be taken due to partial being set to false., +                            shardSnapshotStatus = new IndexShardSnapshotStatus();, +                            shardSnapshotStatus.updateStage(IndexShardSnapshotStatus.Stage.FAILURE);, +                            shardSnapshotStatus.failure("skipped");, +                        } else {, +                            shardSnapshotStatus = repository.getShardSnapshotStatus(, +                                snapshotInfo.snapshotId(),, +                                snapshotInfo.version(),, +                                indexId,, +                                shardId);, +                        }, +++ b/core/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreIT.java, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +    public void testSnapshotStatusOnFailedIndex() throws Exception {, +        logger.info("--> creating repository");, +        final Path repoPath = randomRepoPath();, +        final Client client = client();, +        assertAcked(client.admin().cluster(), +            .preparePutRepository("test-repo"), +            .setType("fs"), +            .setVerify(false), +            .setSettings(Settings.builder().put("location", repoPath)));, +, +        logger.info("--> creating good index");, +        assertAcked(prepareCreate("test-idx-good"), +            .setSettings(Settings.builder(), +                .put(SETTING_NUMBER_OF_SHARDS, 1), +                .put(SETTING_NUMBER_OF_REPLICAS, 0)));, +        ensureGreen();, +        final int numDocs = randomIntBetween(1, 5);, +        for (int i = 0; i < numDocs; i++) {, +            index("test-idx-good", "doc", Integer.toString(i), "foo", "bar" + i);, +        }, +        refresh();, +, +        logger.info("--> creating bad index");, +        assertAcked(prepareCreate("test-idx-bad"), +            .setWaitForActiveShards(ActiveShardCount.NONE), +            .setSettings(Settings.builder(), +                .put(SETTING_NUMBER_OF_SHARDS, 1), +                .put(SETTING_NUMBER_OF_REPLICAS, 0), +                // set shard allocation to none so the primary cannot be, +                // allocated - simulates a "bad" index that fails to snapshot, +                .put(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(),, +                     "none")));, +, +        logger.info("--> snapshot bad index and get status");, +        client.admin().cluster(), +            .prepareCreateSnapshot("test-repo", "test-snap1"), +            .setWaitForCompletion(true), +            .setIndices("test-idx-bad"), +            .get();, +        SnapshotsStatusResponse snapshotsStatusResponse = client.admin().cluster(), +            .prepareSnapshotStatus("test-repo"), +            .setSnapshots("test-snap1"), +            .get();, +        assertEquals(1, snapshotsStatusResponse.getSnapshots().size());, +        assertEquals(State.FAILED, snapshotsStatusResponse.getSnapshots().get(0).getState());, +, +        logger.info("--> snapshot both good and bad index and get status");, +        client.admin().cluster(), +            .prepareCreateSnapshot("test-repo", "test-snap2"), +            .setWaitForCompletion(true), +            .setIndices("test-idx-good", "test-idx-bad"), +            .get();, +        snapshotsStatusResponse = client.admin().cluster(), +            .prepareSnapshotStatus("test-repo")]