[+++ b/src/test/java/org/elasticsearch/index/search/child/ChildrenQueryTests.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements. See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +, +package org.elasticsearch.index.search.child;, +, +import com.carrotsearch.hppc.FloatArrayList;, +import com.carrotsearch.hppc.ObjectObjectOpenHashMap;, +import org.apache.lucene.document.Document;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.StringField;, +import org.apache.lucene.index.*;, +import org.apache.lucene.queries.TermFilter;, +import org.apache.lucene.search.*;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.util.FixedBitSet;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.internal.ParentFieldMapper;, +import org.elasticsearch.index.mapper.internal.TypeFieldMapper;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +import org.elasticsearch.search.internal.ContextIndexSearcher;, +import org.elasticsearch.search.internal.SearchContext;, +import org.elasticsearch.test.ElasticsearchLuceneTestCase;, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, +import org.junit.Test;, +, +import java.io.IOException;, +import java.util.Map;, +import java.util.NavigableMap;, +import java.util.TreeMap;, +, +import static org.elasticsearch.index.search.child.ChildrenConstantScoreQueryTests.assertBitSet;, +import static org.elasticsearch.index.search.child.ChildrenConstantScoreQueryTests.createSearchContext;, +import static org.hamcrest.Matchers.equalTo;, +, +public class ChildrenQueryTests extends ElasticsearchLuceneTestCase {, +, +    @BeforeClass, +    public static void before() throws IOException {, +        SearchContext.setCurrent(createSearchContext("test", "parent", "child"));, +    }, +, +    @AfterClass, +    public static void after() throws IOException {, +        SearchContext.removeCurrent();, +    }, +, +    @Test, +    public void testRandom() throws Exception {, +        Directory directory = newDirectory();, +        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);, +        int numUniqueChildValues = 1 + random().nextInt(TEST_NIGHTLY ? 6000 : 600);, +        String[] childValues = new String[numUniqueChildValues];, +        for (int i = 0; i < numUniqueChildValues; i++) {, +            childValues[i] = Integer.toString(i);, +        }, +, +        int childDocId = 0;, +        int numParentDocs = 1 + random().nextInt(TEST_NIGHTLY ? 20000 : 1000);, +        ObjectObjectOpenHashMap<String, NavigableMap<String, FloatArrayList>> childValueToParentIds = new ObjectObjectOpenHashMap<String, NavigableMap<String, FloatArrayList>>();, +        for (int parentDocId = 0; parentDocId < numParentDocs; parentDocId++) {, +            boolean markParentAsDeleted = rarely();, +            String parent = Integer.toString(parentDocId);, +            Document document = new Document();, +            document.add(new StringField(UidFieldMapper.NAME, Uid.createUid("parent", parent), Field.Store.YES));, +            document.add(new StringField(TypeFieldMapper.NAME, "parent", Field.Store.NO));, +            if (markParentAsDeleted) {, +                document.add(new StringField("delete", "me", Field.Store.NO));, +            }, +            indexWriter.addDocument(document);, +, +            int numChildDocs = random().nextInt(TEST_NIGHTLY ? 100 : 25);, +            for (int i = 0; i < numChildDocs; i++) {, +                boolean markChildAsDeleted = rarely();, +                String childValue = childValues[random().nextInt(childValues.length)];, +, +                document = new Document();, +                document.add(new StringField(UidFieldMapper.NAME, Uid.createUid("child", Integer.toString(childDocId)), Field.Store.NO));, +                document.add(new StringField(TypeFieldMapper.NAME, "child", Field.Store.NO));, +                document.add(new StringField(ParentFieldMapper.NAME, Uid.createUid("parent", parent), Field.Store.NO));, +                document.add(new StringField("field1", childValue, Field.Store.NO));, +                if (markChildAsDeleted) {, +                    document.add(new StringField("delete", "me", Field.Store.NO));]