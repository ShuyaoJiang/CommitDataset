[+++ b/pom.xml, +                                <!-- security manager / test.policy -->, +                                <java.security.policy>${basedir}/src/main/resources/org/elasticsearch/bootstrap/security.policy</java.security.policy>, +++ b/pom.xml, +                                <!-- security manager / test.policy -->, +                                <java.security.policy>${basedir}/src/main/resources/org/elasticsearch/bootstrap/security.policy</java.security.policy>, +++ /dev/null, +++ b/pom.xml, +                                <!-- security manager / test.policy -->, +                                <java.security.policy>${basedir}/src/main/resources/org/elasticsearch/bootstrap/security.policy</java.security.policy>, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/bootstrap/Security.java, +import java.net.URI;, +import java.security.Permission;, +import java.security.PermissionCollection;, +import java.security.ProtectionDomain;, +import java.security.URIParameter;, +class Security {, +    , +    /** template policy file, the one used in tests */, +    static final String POLICY_RESOURCE = "security.policy";, +        URI template = Security.class.getResource(POLICY_RESOURCE).toURI();, +        Policy.setPolicy(new ESPolicy(template, createPermissions(environment)));, +    static Permissions createPermissions(Environment environment) throws IOException {, +    static void addPath(Permissions policy, Path path, String permissions) throws IOException {, +    static void selfTest() {, +, +    /** custom policy for union of static and dynamic permissions */, +    static class ESPolicy extends Policy {, +        final Policy template;, +        final PermissionCollection dynamic;, +, +        ESPolicy(URI template, PermissionCollection dynamic) throws Exception {, +            this.template = Policy.getInstance("JavaPolicy", new URIParameter(template));, +            this.dynamic = dynamic;, +        }, +, +        @Override, +        public boolean implies(ProtectionDomain domain, Permission permission) {, +            return template.implies(domain, permission) || dynamic.implies(permission);, +        }, +    }, +++ b/pom.xml, +                                <!-- security manager / test.policy -->, +                                <java.security.policy>${basedir}/src/main/resources/org/elasticsearch/bootstrap/security.policy</java.security.policy>, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/bootstrap/Security.java, +import java.net.URI;, +import java.security.Permission;, +import java.security.PermissionCollection;, +import java.security.ProtectionDomain;, +import java.security.URIParameter;, +class Security {, +    , +    /** template policy file, the one used in tests */, +    static final String POLICY_RESOURCE = "security.policy";, +        URI template = Security.class.getResource(POLICY_RESOURCE).toURI();, +        Policy.setPolicy(new ESPolicy(template, createPermissions(environment)));, +    static Permissions createPermissions(Environment environment) throws IOException {, +    static void addPath(Permissions policy, Path path, String permissions) throws IOException {, +    static void selfTest() {, +, +    /** custom policy for union of static and dynamic permissions */, +    static class ESPolicy extends Policy {, +        final Policy template;, +        final PermissionCollection dynamic;, +, +        ESPolicy(URI template, PermissionCollection dynamic) throws Exception {, +            this.template = Policy.getInstance("JavaPolicy", new URIParameter(template));, +            this.dynamic = dynamic;, +        }, +, +        @Override, +        public boolean implies(ProtectionDomain domain, Permission permission) {, +            return template.implies(domain, permission) || dynamic.implies(permission);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import org.elasticsearch.cluster.service.InternalClusterService;, +import org.elasticsearch.discovery.Discovery;, +import org.elasticsearch.discovery.DiscoveryService;, +import org.elasticsearch.discovery.local.LocalDiscovery;, +import org.elasticsearch.discovery.zen.publish.PublishClusterStateAction;, + * Represents the current state of the cluster., + * The cluster state object is immutable with an, + * exception of the {@link RoutingNodes} structure, which is built on demand from the {@link RoutingTable},, + * and cluster state {@link #status}, which is updated during cluster state publishing and applying, + * processing.  The cluster state can be updated only on the master node. All updates are performed by on a, + * single thread and controlled by the {@link InternalClusterService}. After every update the, + * {@link DiscoveryService#publish} method publishes new version of the cluster state to all other nodes in the, + * cluster.  The actual publishing mechanism is delegated to the {@link Discovery#publish} method and depends on, + * the type of discovery. For example, for local discovery it is implemented by the {@link LocalDiscovery#publish}, + * method. In the Zen Discovery it is handled in the {@link PublishClusterStateAction#publish} method. The, + * publishing mechanism can be overridden by other discovery., + *, + * The cluster state implements the {@link Diffable} interface in order to support publishing of cluster state, + * differences instead of the entire state on each change. The publishing mechanism should only send differences, + * to a node if this node was present in the previous version of the cluster state. If a node is not present was, + * not present in the previous version of the cluster state, such node is unlikely to have the previous cluster, + * state version and should be sent a complete version. In order to make sure that the differences are applied to]