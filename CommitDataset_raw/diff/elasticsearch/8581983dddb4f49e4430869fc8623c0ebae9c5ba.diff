[+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.cluster.ClusterStateTaskListener;, +import org.elasticsearch.cluster.coordination.LinearizabilityChecker.History;, +import org.elasticsearch.cluster.coordination.LinearizabilityChecker.SequentialSpec;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.discovery.zen.PublishClusterStateStats;, +import static org.elasticsearch.cluster.coordination.Reconfigurator.CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION;, +        }, (source, e) -> {});, +        private final LinearizabilityChecker linearizabilityChecker = new LinearizabilityChecker();, +        private final History history = new History();, +            final int keyRange = randomSteps / 50; // for randomized writes and reads, +                    if (finishTime == -1 && randomBoolean() && randomBoolean() && randomBoolean()) {, +                        final int key = randomIntBetween(0, keyRange);, +                            clusterNode.submitValue(key, newValue);, +                        }).run();, +                    } else if (finishTime == -1 && randomBoolean() && randomBoolean() && randomBoolean()) {, +                        final ClusterNode clusterNode = getAnyNodePreferringLeaders();, +                        final int key = randomIntBetween(0, keyRange);, +                        clusterNode.onNode(() -> {, +                            logger.debug("----> [runRandomly {}] reading value from [{}]",, +                                thisStep, clusterNode.getId());, +                            clusterNode.readValue(key);, +, +            logger.info("checking linearizability of history with size {}: {}", history.size(), history);, +            assertTrue("history not linearizable: " + history, linearizabilityChecker.isLinearizable(spec, history, i -> null));, +            logger.info("linearizability check completed");, +                        .build(), (source, e) -> {});, +                return submitValue(0, value);, +            AckCollector submitValue(final int key, final long value) {, +                final int eventId = history.invoke(new Tuple<>(key, value));, +                return submitUpdateTask("new value [" + value + "]", cs -> setValue(cs, key, value), new ClusterStateTaskListener() {, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        history.respond(eventId, value(oldState, key));, +                    }, +, +                    @Override, +                    public void onNoLongerMaster(String source) {, +                        // in this case, we know for sure that event was not processed by the system and will not change history, +                        // remove event to help avoid bloated history and state space explosion in linearizability checker, +                        history.remove(eventId);, +                    }, +, +                    @Override, +                    public void onFailure(String source, Exception e) {, +                        // do not remove event from history, the write might still take place, +                        // instead, complete history when checking for linearizability, +                    }, +                });, +            }, +, +            void readValue(int key) {, +                final int eventId = history.invoke(new Tuple<>(key, null));, +                submitUpdateTask("read value", cs -> ClusterState.builder(cs).build(), new ClusterStateTaskListener() {, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        history.respond(eventId, value(newState, key));, +                    }, +, +                    @Override, +                    public void onFailure(String source, Exception e) {, +                        // reads do not change state, +                        // remove event to help avoid bloated history and state space explosion in linearizability checker, +                        history.remove(eventId);, +                    }, +                });, +            }, +, +            AckCollector submitUpdateTask(String source, UnaryOperator<ClusterState> clusterStateUpdate,, +                                          ClusterStateTaskListener taskListener) {, +                                taskListener.onFailure(source, e);, +                            }, +, +                            @Override, +                            public void onNoLongerMaster(String source) {, +                                logger.trace("no longer master: [{}]", source);, +                                taskListener.onNoLongerMaster(source);, +                                assertStateEquals(state, newState);, +                                taskListener.clusterStateProcessed(source, oldState, newState);, +    public ClusterState setValue(ClusterState clusterState, int key, long value) {, +        return ClusterState.builder(clusterState).metaData(, +            MetaData.builder(clusterState.metaData()), +                .persistentSettings(Settings.builder(), +                    .put(clusterState.metaData().persistentSettings()), +                    .put("value_" + key, value), +                    .build()), +                .build()), +            .build();, +    }, +, +    public long value(ClusterState clusterState) {, +        return value(clusterState, 0);, +    }, +, +    public long value(ClusterState clusterState, int key) {, +        return clusterState.metaData().persistentSettings().getAsLong("value_" + key, 0L);, +    }, +, +    public void assertStateEquals(ClusterState clusterState1, ClusterState clusterState2) {, +        assertEquals(clusterState1.version(), clusterState2.version());]