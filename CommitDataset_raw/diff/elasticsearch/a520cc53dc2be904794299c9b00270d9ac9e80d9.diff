[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (delete.origin().isFromTranslog() == false && deleteResult.getResultType() == Result.Type.SUCCESS) {, +                final Translog.Location location = translog.add(new Translog.Delete(delete, deleteResult));, +                maybeFailEngine("delete", e);, +                throw new AssertionError("delete operation should never fail at document level", ex);, +            throw ex;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (delete.origin().isFromTranslog() == false && deleteResult.getResultType() == Result.Type.SUCCESS) {, +                final Translog.Location location = translog.add(new Translog.Delete(delete, deleteResult));, +                maybeFailEngine("delete", e);, +                throw new AssertionError("delete operation should never fail at document level", ex);, +            throw ex;, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +    public void testDeleteWithFatalError() throws Exception {, +        final IllegalStateException tragicException = new IllegalStateException("fail to store tombstone");, +        try (Store store = createStore()) {, +            EngineConfig.TombstoneDocSupplier tombstoneDocSupplier = new EngineConfig.TombstoneDocSupplier() {, +                @Override, +                public ParsedDocument newDeleteTombstoneDoc(String type, String id) {, +                    ParsedDocument parsedDocument = tombstoneDocSupplier().newDeleteTombstoneDoc(type, id);, +                    parsedDocument.rootDoc().add(new StoredField("foo", "bar") {, +                        // this is a hack to add a failure during store document which triggers a tragic event, +                        // and in turn fails the engine, +                        @Override, +                        public BytesRef binaryValue() {, +                            throw tragicException;, +                        }, +                    });, +                    return parsedDocument;, +                }, +, +                @Override, +                public ParsedDocument newNoopTombstoneDoc(String reason) {, +                    return tombstoneDocSupplier().newNoopTombstoneDoc(reason);, +                }, +            };, +            try (InternalEngine engine = createEngine(null, null, null, config(this.engine.config(), store, tombstoneDocSupplier))) {, +                final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);, +                engine.index(indexForDoc(doc));, +                expectThrows(IllegalStateException.class,, +                    () -> engine.delete(new Engine.Delete("test", "1", newUid("1"), primaryTerm.get())));, +                assertTrue(engine.isClosed.get());, +                assertSame(tragicException, engine.failedEngine.get());, +            }, +        }, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (delete.origin().isFromTranslog() == false && deleteResult.getResultType() == Result.Type.SUCCESS) {, +                final Translog.Location location = translog.add(new Translog.Delete(delete, deleteResult));, +                maybeFailEngine("delete", e);, +                throw new AssertionError("delete operation should never fail at document level", ex);, +            throw ex;, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +    public void testDeleteWithFatalError() throws Exception {, +        final IllegalStateException tragicException = new IllegalStateException("fail to store tombstone");, +        try (Store store = createStore()) {, +            EngineConfig.TombstoneDocSupplier tombstoneDocSupplier = new EngineConfig.TombstoneDocSupplier() {, +                @Override, +                public ParsedDocument newDeleteTombstoneDoc(String type, String id) {, +                    ParsedDocument parsedDocument = tombstoneDocSupplier().newDeleteTombstoneDoc(type, id);, +                    parsedDocument.rootDoc().add(new StoredField("foo", "bar") {, +                        // this is a hack to add a failure during store document which triggers a tragic event, +                        // and in turn fails the engine, +                        @Override, +                        public BytesRef binaryValue() {, +                            throw tragicException;, +                        }, +                    });, +                    return parsedDocument;, +                }, +, +                @Override, +                public ParsedDocument newNoopTombstoneDoc(String reason) {, +                    return tombstoneDocSupplier().newNoopTombstoneDoc(reason);, +                }, +            };, +            try (InternalEngine engine = createEngine(null, null, null, config(this.engine.config(), store, tombstoneDocSupplier))) {, +                final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);, +                engine.index(indexForDoc(doc));, +                expectThrows(IllegalStateException.class,, +                    () -> engine.delete(new Engine.Delete("test", "1", newUid("1"), primaryTerm.get())));, +                assertTrue(engine.isClosed.get());, +                assertSame(tragicException, engine.failedEngine.get());, +            }, +        }, +    }, +, +++ b/server/src/test/java/org/elasticsearch/index/replication/IndexLevelReplicationTests.java, +                    if (isTombstone) {, +                        return super.addDocument(doc); // allow to add Noop, +                        throw indexException;, +            assertThat(indexResp.isFailed(), equalTo(true));, +            assertThat(indexResp.getFailure().getCause(), equalTo(indexException));, +            expectedTranslogOps.add(new Translog.NoOp(0, primaryTerm, indexException.toString()));, +            shards.assertAllEqual(0);, +            // the failure replicated directly from the replication channel., +            expectedTranslogOps.add(new Translog.NoOp(1, primaryTerm, indexException.toString()));, +            shards.assertAllEqual(0);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java]