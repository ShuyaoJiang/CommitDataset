[+++ b/src/test/java/org/elasticsearch/gateway/local/QuorumLocalGatewayTests.java, +        final String[] nodes = cluster().startNodesAsync(3, settingsBuilder().put("gateway.type", "local").build()).get().toArray(new String[0]);, +        cluster().startNodesAsync(3, settingsBuilder().put("gateway.type", "local").build()).get();, +++ b/src/test/java/org/elasticsearch/gateway/local/QuorumLocalGatewayTests.java, +        final String[] nodes = cluster().startNodesAsync(3, settingsBuilder().put("gateway.type", "local").build()).get().toArray(new String[0]);, +        cluster().startNodesAsync(3, settingsBuilder().put("gateway.type", "local").build()).get();, +++ b/src/test/java/org/elasticsearch/test/TestCluster.java, +import com.google.common.util.concurrent.Futures;, +import com.google.common.util.concurrent.ListenableFuture;, +import com.google.common.util.concurrent.SettableFuture;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.*;, +    /* sorted map to make traverse order reproducible, concurrent since we do checks on it not within a sync block */, +    private final NavigableMap<String, NodeAndClient> nodes = new TreeMap<>();, +    private final ExecutorService executor;, +, +        executor = EsExecutors.newCached(1, TimeUnit.MINUTES, EsExecutors.daemonThreadFactory("test_" + clusterName));, +    public void ensureAtLeastNumNodes(int n) {, +        List<ListenableFuture<String>> futures = Lists.newArrayList();, +        synchronized (this) {, +                futures.add(startNodeAsync());, +            }, +        }, +        try {, +            Futures.allAsList(futures).get();, +        } catch (Exception e) {, +            throw new ElasticsearchException("failed to start nodes", e);, +        assert Thread.holdsLock(this);, +            executor.shutdownNow();, +    public synchronized String startNode() {, +    public synchronized String startNode(Version version) {, +    public synchronized String startNode(Settings.Builder settings) {, +    public synchronized String startNode(Settings settings) {, +    /**, +     * Starts a node with the given settings and version and returns it's name., +     */, +    public synchronized String startNode(Settings settings, Version version) {, +    /**, +     * Starts a node in an async manner with the given settings and returns future with its name., +     */, +    public synchronized ListenableFuture<String> startNodeAsync() {, +        return startNodeAsync(ImmutableSettings.EMPTY, Version.CURRENT);, +    }, +, +    /**, +     * Starts a node in an async manner with the given settings and returns future with its name., +     */, +    public synchronized ListenableFuture<String> startNodeAsync(final Settings settings) {, +        return startNodeAsync(settings, Version.CURRENT);, +    }, +, +    /**, +     * Starts a node in an async manner with the given settings and version and returns future with its name., +     */, +    public synchronized ListenableFuture<String> startNodeAsync(final Settings settings, final Version version) {, +        final SettableFuture<String> future = SettableFuture.create();, +        final NodeAndClient buildNode = buildNode(settings, version);, +        Runnable startNode = new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    buildNode.node().start();, +                    publishNode(buildNode);, +                    future.set(buildNode.name);, +                } catch (Throwable t) {, +                    future.setException(t);, +                }, +            }, +        };, +        executor.execute(startNode);, +        return future;, +    }, +, +    /**, +     * Starts multiple nodes in an async manner with the given settings and version and returns future with its name., +     */, +    public synchronized ListenableFuture<List<String>> startNodesAsync(final int numNodes, final Settings settings) {, +        return startNodesAsync(numNodes, settings, Version.CURRENT);, +    }, +, +    /**, +     * Starts multiple nodes in an async manner with the given settings and version and returns future with its name., +     */, +    public synchronized ListenableFuture<List<String>> startNodesAsync(final int numNodes, final Settings settings, final Version version) {, +        List<ListenableFuture<String>> futures = Lists.newArrayList();, +        for (int i = 0; i < numNodes; i++) {, +            futures.add(startNodeAsync(settings, version));, +        }, +        return Futures.allAsList(futures);, +    }, +, +    private synchronized void publishNode(NodeAndClient nodeAndClient) {]