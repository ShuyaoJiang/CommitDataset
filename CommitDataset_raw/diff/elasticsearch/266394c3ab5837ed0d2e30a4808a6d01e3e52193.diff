[+++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        private final boolean partial;, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, boolean partial, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this.partial = partial;, +            this(entry.snapshotId, entry.includeGlobalState, entry.partial, state, entry.indices, entry.startTime, shards);, +        public boolean partial() {, +            return partial;, +        }, +, +            if (partial != entry.partial) return false;, +            result = 31 * result + (partial ? 1 : 0);, +            boolean partial = in.readBoolean();, +            entries[i] = new Entry(snapshotId, includeGlobalState, partial, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +            out.writeBoolean(entry.partial());, +        static final XContentBuilderString PARTIAL = new XContentBuilderString("partial");, +        builder.field(Fields.PARTIAL, entry.partial());, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        private final boolean partial;, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, boolean partial, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this.partial = partial;, +            this(entry.snapshotId, entry.includeGlobalState, entry.partial, state, entry.indices, entry.startTime, shards);, +        public boolean partial() {, +            return partial;, +        }, +, +            if (partial != entry.partial) return false;, +            result = 31 * result + (partial ? 1 : 0);, +            boolean partial = in.readBoolean();, +            entries[i] = new Entry(snapshotId, includeGlobalState, partial, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +            out.writeBoolean(entry.partial());, +        static final XContentBuilderString PARTIAL = new XContentBuilderString("partial");, +        builder.field(Fields.PARTIAL, entry.partial());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.snapshots.SnapshotsService;, +import java.util.Set;, +        Set<String> indices = Sets.newHashSet(request.indices);, +                // Check if index deletion conflicts with any running snapshots, +                SnapshotsService.checkIndexDeletion(currentState, indices);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        private final boolean partial;, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, boolean partial, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this.partial = partial;, +            this(entry.snapshotId, entry.includeGlobalState, entry.partial, state, entry.indices, entry.startTime, shards);, +        public boolean partial() {, +            return partial;, +        }, +, +            if (partial != entry.partial) return false;, +            result = 31 * result + (partial ? 1 : 0);, +            boolean partial = in.readBoolean();, +            entries[i] = new Entry(snapshotId, includeGlobalState, partial, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +            out.writeBoolean(entry.partial());, +        static final XContentBuilderString PARTIAL = new XContentBuilderString("partial");, +        builder.field(Fields.PARTIAL, entry.partial());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.snapshots.SnapshotsService;, +import java.util.Set;, +        Set<String> indices = Sets.newHashSet(request.indices);, +                // Check if index deletion conflicts with any running snapshots, +                SnapshotsService.checkIndexDeletion(currentState, indices);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import org.elasticsearch.snapshots.RestoreService;, +import org.elasticsearch.snapshots.SnapshotsService;, +                // Check if index closing conflicts with any running restores, +                RestoreService.checkIndexClosing(currentState, indicesToClose);, +                // Check if index closing conflicts with any running snapshots, +                SnapshotsService.checkIndexClosing(currentState, indicesToClose);, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        private final boolean partial;, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, boolean partial, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this.partial = partial;, +            this(entry.snapshotId, entry.includeGlobalState, entry.partial, state, entry.indices, entry.startTime, shards);, +        public boolean partial() {, +            return partial;, +        }, +, +            if (partial != entry.partial) return false;, +            result = 31 * result + (partial ? 1 : 0);, +            boolean partial = in.readBoolean();, +            entries[i] = new Entry(snapshotId, includeGlobalState, partial, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +            out.writeBoolean(entry.partial());, +        static final XContentBuilderString PARTIAL = new XContentBuilderString("partial");, +        builder.field(Fields.PARTIAL, entry.partial());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.snapshots.SnapshotsService;, +import java.util.Set;, +        Set<String> indices = Sets.newHashSet(request.indices);, +                // Check if index deletion conflicts with any running snapshots, +                SnapshotsService.checkIndexDeletion(currentState, indices);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import org.elasticsearch.snapshots.RestoreService;, +import org.elasticsearch.snapshots.SnapshotsService;, +                // Check if index closing conflicts with any running restores, +                RestoreService.checkIndexClosing(currentState, indicesToClose);]