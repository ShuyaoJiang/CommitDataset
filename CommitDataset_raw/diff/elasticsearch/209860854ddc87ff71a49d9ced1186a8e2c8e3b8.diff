[+++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +            builder.field("index", indexTokenizeOption(indexed, fieldType().tokenized()));, +    /* Only protected so that string can override it */, +    protected Object indexTokenizeOption(boolean indexed, boolean tokenized) {, +        return indexed;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +            builder.field("index", indexTokenizeOption(indexed, fieldType().tokenized()));, +    /* Only protected so that string can override it */, +    protected Object indexTokenizeOption(boolean indexed, boolean tokenized) {, +        return indexed;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +            // hack for the fact that string can't just accept true/false for, +            // the index property and still accepts no/not_analyzed/analyzed, +            final Object index = node.remove("index");, +            if (index != null) {, +                final String normalizedIndex = Strings.toUnderscoreCase(index.toString());, +                switch (normalizedIndex) {, +                case "analyzed":, +                    builder.tokenized(true);, +                    node.put("index", true);, +                    break;, +                case "not_analyzed":, +                    builder.tokenized(false);, +                    node.put("index", true);, +                    break;, +                case "no":, +                    node.put("index", false);, +                    break;, +                default:, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +                }, +            }, +    protected String indexTokenizeOption(boolean indexed, boolean tokenized) {, +        if (!indexed) {, +            return "no";, +        } else if (tokenized) {, +            return "analyzed";, +        } else {, +            return "not_analyzed";, +        }, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +            builder.field("index", indexTokenizeOption(indexed, fieldType().tokenized()));, +    /* Only protected so that string can override it */, +    protected Object indexTokenizeOption(boolean indexed, boolean tokenized) {, +        return indexed;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +            // hack for the fact that string can't just accept true/false for, +            // the index property and still accepts no/not_analyzed/analyzed, +            final Object index = node.remove("index");, +            if (index != null) {, +                final String normalizedIndex = Strings.toUnderscoreCase(index.toString());, +                switch (normalizedIndex) {, +                case "analyzed":, +                    builder.tokenized(true);, +                    node.put("index", true);, +                    break;, +                case "not_analyzed":, +                    builder.tokenized(false);, +                    node.put("index", true);, +                    break;, +                case "no":, +                    node.put("index", false);, +                    break;, +                default:, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +                }, +            }, +    protected String indexTokenizeOption(boolean indexed, boolean tokenized) {, +        if (!indexed) {, +            return "no";, +        } else if (tokenized) {, +            return "analyzed";, +        } else {, +            return "not_analyzed";, +        }, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +                builder.index(parseIndex(name, propNode.toString(), parserContext));, +    public static boolean parseIndex(String fieldName, String index, Mapper.TypeParser.ParserContext parserContext) throws MapperParsingException {, +        if (parserContext.indexVersionCreated().onOrAfter(Version.V_3_0_0)) {, +            switch (index) {, +            case "true":, +                return true;, +            case "false":, +                return false;, +            default:, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "], expected [true] or [false]");, +            }, +            final String normalizedIndex = Strings.toUnderscoreCase(index);, +            switch (normalizedIndex) {, +            case "true":, +            case "not_analyzed":, +            case "analyzed":, +                return true;, +            case "false":]