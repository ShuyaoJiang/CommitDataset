[+++ b/server/src/main/java/org/elasticsearch/plugins/PluginsService.java, +import java.util.LinkedHashMap;, +import java.util.stream.Stream;, +        // we need to build a List of plugins for checking mandatory plugins, +        final List<String> pluginsNames = new ArrayList<>();, +            pluginsNames.add(pluginInfo.getName());, +                    List<BundleCollection> plugins = getPluginBundleCollections(pluginsDirectory);, +                    for (final BundleCollection plugin : plugins) {, +                        final Collection<Bundle> bundles = plugin.bundles();, +                        for (final Bundle bundle : bundles) {, +                        seenBundles.addAll(bundles);, +                        pluginsNames.add(plugin.name());, +                    }, +                final String message = String.format(, +                        Locale.ROOT,, +                        "missing mandatory plugins [%s]",, +                        Strings.collectionToDelimitedString(missingPlugins, ", "));, +                throw new IllegalStateException(message);, +    /**, +     * An abstraction over a single plugin and meta-plugins., +     */, +    interface BundleCollection {, +        String name();, +        Collection<Bundle> bundles();, +    }, +, +    static class Bundle implements BundleCollection {, +        public String name() {, +            return plugin.getName();, +        }, +, +        @Override, +        public Collection<Bundle> bundles() {, +            return Collections.singletonList(this);, +        }, +, +        @Override, +     * Represents a meta-plugin and the {@link Bundle}s corresponding to its constituents., +     */, +    static class MetaBundle implements BundleCollection {, +        private final String name;, +        private final List<Bundle> bundles;, +, +        MetaBundle(final String name, final List<Bundle> bundles) {, +            this.name = name;, +            this.bundles = bundles;, +        }, +, +        @Override, +        public String name() {, +            return name;, +        }, +, +        @Override, +        public Collection<Bundle> bundles() {, +            return bundles;, +        }, +        , +    }, +, +    /**, +     * Extracts all installed plugin directories from the provided {@code rootPath} expanding meta-plugins if needed., +     *, +     * @return a list of all plugin paths installed in the {@code rootPath}, +        final Tuple<List<Path>, Map<String, List<Path>>> groupedPluginDirs = findGroupedPluginDirs(rootPath);, +        return Stream.concat(, +                groupedPluginDirs.v1().stream(),, +                groupedPluginDirs.v2().values().stream().flatMap(Collection::stream)), +                .collect(Collectors.toList());, +    }, +, +    /**, +     * Extracts all installed plugin directories from the provided {@code rootPath} expanding meta-plugins if needed. The plugins are, +     * grouped into plugins and meta-plugins. The meta-plugins are keyed by the meta-plugin name., +     *, +     * @param rootPath the path where the plugins are installed, +     * @return a tuple of plugins as the first component and meta-plugins keyed by meta-plugin name as the second component, +     * @throws IOException if an I/O exception occurred reading the directories, +     */, +    private static Tuple<List<Path>, Map<String, List<Path>>> findGroupedPluginDirs(final Path rootPath) throws IOException {, +        final Map<String, List<Path>> metaPlugins = new LinkedHashMap<>();, +                        final String name = plugin.getFileName().toString();, +                                metaPlugins.computeIfAbsent(name, n -> new ArrayList<>()).add(subPlugin);, +        return Tuple.tuple(plugins, metaPlugins);, +        return getPluginBundleCollections(pluginsDirectory).stream().flatMap(b -> b.bundles().stream()).collect(Collectors.toSet());, +    }, +    private static List<BundleCollection> getPluginBundleCollections(final Path pluginsDirectory) throws IOException {, +        final List<BundleCollection> bundles = new ArrayList<>();, +        final Set<Bundle> seenBundles = new HashSet<>();, +        final Tuple<List<Path>, Map<String, List<Path>>> groupedPluginDirs = findGroupedPluginDirs(pluginsDirectory);, +        for (final Path plugin : groupedPluginDirs.v1()) {, +            final Bundle bundle = bundle(seenBundles, plugin);, +            bundles.add(bundle);, +        }, +        for (final Map.Entry<String, List<Path>> metaPlugin : groupedPluginDirs.v2().entrySet()) {, +            final List<Bundle> metaPluginBundles = new ArrayList<>();, +            for (final Path metaPluginPlugin : metaPlugin.getValue()) {, +                final Bundle bundle = bundle(seenBundles, metaPluginPlugin);, +                metaPluginBundles.add(bundle);, +            }]