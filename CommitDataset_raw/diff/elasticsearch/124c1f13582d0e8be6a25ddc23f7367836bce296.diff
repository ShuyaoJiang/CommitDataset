[+++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +                executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated);, +                                executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated);, +                                executeIngestAndBulk(task, bulkRequest, startTime, ActionListener.wrap(listener::onResponse, inner -> {, +            executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, emptyMap());, +        }, +    }, +, +    private void executeIngestAndBulk(Task task, final BulkRequest bulkRequest, final long startTimeNanos,, +        final ActionListener<BulkResponse> listener, final AtomicArray<BulkItemResponse> responses,, +        Map<String, IndexNotFoundException> indicesThatCannotBeCreated) {, +        boolean hasIndexRequestsWithPipelines = false;, +        ImmutableOpenMap<String, IndexMetaData> indicesMetaData = clusterService.state().getMetaData().indices();, +        for (DocWriteRequest<?> actionRequest : bulkRequest.requests) {, +            if (actionRequest instanceof IndexRequest) {, +                IndexRequest indexRequest = (IndexRequest) actionRequest;, +                String pipeline = indexRequest.getPipeline();, +                if (pipeline == null) {, +                    IndexMetaData indexMetaData = indicesMetaData.get(indexRequest.index());, +                    if (indexMetaData == null) {, +                        indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME);, +                    } else {, +                        String defaultPipeline = IndexSettings.DEFAULT_PIPELINE.get(indexMetaData.getSettings());, +                        indexRequest.setPipeline(defaultPipeline);, +                        if (IngestService.NOOP_PIPELINE_NAME.equals(defaultPipeline) == false) {, +                            hasIndexRequestsWithPipelines = true;, +                        }, +                    }, +                } else if (IngestService.NOOP_PIPELINE_NAME.equals(pipeline) == false) {, +                    hasIndexRequestsWithPipelines = true;, +                }, +            }, +        }, +        if (hasIndexRequestsWithPipelines) {, +            try {, +                if (clusterService.localNode().isIngestNode()) {, +                    processBulkIndexIngestRequest(task, bulkRequest, listener);, +                } else {, +                    ingestForwarder.forwardIngestRequest(BulkAction.INSTANCE, bulkRequest, listener);, +                }, +            } catch (Exception e) {, +                listener.onFailure(e);, +            }, +        } else {, +            executeBulk(task, bulkRequest, startTimeNanos, listener, responses, indicesThatCannotBeCreated);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +                executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated);, +                                executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated);, +                                executeIngestAndBulk(task, bulkRequest, startTime, ActionListener.wrap(listener::onResponse, inner -> {, +            executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, emptyMap());, +        }, +    }, +, +    private void executeIngestAndBulk(Task task, final BulkRequest bulkRequest, final long startTimeNanos,, +        final ActionListener<BulkResponse> listener, final AtomicArray<BulkItemResponse> responses,, +        Map<String, IndexNotFoundException> indicesThatCannotBeCreated) {, +        boolean hasIndexRequestsWithPipelines = false;, +        ImmutableOpenMap<String, IndexMetaData> indicesMetaData = clusterService.state().getMetaData().indices();, +        for (DocWriteRequest<?> actionRequest : bulkRequest.requests) {, +            if (actionRequest instanceof IndexRequest) {, +                IndexRequest indexRequest = (IndexRequest) actionRequest;, +                String pipeline = indexRequest.getPipeline();, +                if (pipeline == null) {, +                    IndexMetaData indexMetaData = indicesMetaData.get(indexRequest.index());, +                    if (indexMetaData == null) {, +                        indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME);, +                    } else {, +                        String defaultPipeline = IndexSettings.DEFAULT_PIPELINE.get(indexMetaData.getSettings());, +                        indexRequest.setPipeline(defaultPipeline);, +                        if (IngestService.NOOP_PIPELINE_NAME.equals(defaultPipeline) == false) {, +                            hasIndexRequestsWithPipelines = true;, +                        }, +                    }, +                } else if (IngestService.NOOP_PIPELINE_NAME.equals(pipeline) == false) {, +                    hasIndexRequestsWithPipelines = true;, +                }, +            }, +        }, +        if (hasIndexRequestsWithPipelines) {, +            try {, +                if (clusterService.localNode().isIngestNode()) {, +                    processBulkIndexIngestRequest(task, bulkRequest, listener);, +                } else {, +                    ingestForwarder.forwardIngestRequest(BulkAction.INSTANCE, bulkRequest, listener);, +                }, +            } catch (Exception e) {, +                listener.onFailure(e);, +            }, +        } else {, +            executeBulk(task, bulkRequest, startTimeNanos, listener, responses, indicesThatCannotBeCreated);, +++ b/server/src/test/java/org/elasticsearch/action/bulk/TransportBulkActionIngestTests.java, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.action.support.AutoCreateIndex;, +import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.unit.TimeValue;, +    private static final Settings SETTINGS =, +        Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), true).build();, +, +]