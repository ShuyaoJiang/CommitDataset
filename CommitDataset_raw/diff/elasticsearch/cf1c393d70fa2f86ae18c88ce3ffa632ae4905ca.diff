[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        // TODO REMOVE THIS DIRTY FIX FOR #15168, +        if (licensesDir.exists() == false) {, +            return, +        if (licensesDir.exists() == false && dependencies.isEmpty() == false) {, +        if (licensesDir.exists() && dependencies.isEmpty()) {, +            throw new GradleException("Licenses dir ${licensesDir} exists, but there are no dependencies"), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        // TODO REMOVE THIS DIRTY FIX FOR #15168, +        if (licensesDir.exists() == false) {, +            return, +        if (licensesDir.exists() == false && dependencies.isEmpty() == false) {, +        if (licensesDir.exists() && dependencies.isEmpty()) {, +            throw new GradleException("Licenses dir ${licensesDir} exists, but there are no dependencies"), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                signaturesURLs += [, +                        getClass().getResource('/forbidden/core-signatures.txt'),, +                        getClass().getResource('/forbidden/third-party-signatures.txt')], +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        // TODO REMOVE THIS DIRTY FIX FOR #15168, +        if (licensesDir.exists() == false) {, +            return, +        if (licensesDir.exists() == false && dependencies.isEmpty() == false) {, +        if (licensesDir.exists() && dependencies.isEmpty()) {, +            throw new GradleException("Licenses dir ${licensesDir} exists, but there are no dependencies"), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                signaturesURLs += [, +                        getClass().getResource('/forbidden/core-signatures.txt'),, +                        getClass().getResource('/forbidden/third-party-signatures.txt')], +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        // TODO REMOVE THIS DIRTY FIX FOR #15168, +        if (licensesDir.exists() == false) {, +            return, +        if (licensesDir.exists() == false && dependencies.isEmpty() == false) {, +        if (licensesDir.exists() && dependencies.isEmpty()) {, +            throw new GradleException("Licenses dir ${licensesDir} exists, but there are no dependencies"), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                signaturesURLs += [, +                        getClass().getResource('/forbidden/core-signatures.txt'),, +                        getClass().getResource('/forbidden/third-party-signatures.txt')], +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/core-signatures.txt, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        // TODO REMOVE THIS DIRTY FIX FOR #15168, +        if (licensesDir.exists() == false) {, +            return, +        if (licensesDir.exists() == false && dependencies.isEmpty() == false) {, +        if (licensesDir.exists() && dependencies.isEmpty()) {, +            throw new GradleException("Licenses dir ${licensesDir} exists, but there are no dependencies"), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                signaturesURLs += [, +                        getClass().getResource('/forbidden/core-signatures.txt'),, +                        getClass().getResource('/forbidden/third-party-signatures.txt')], +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/core-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/third-party-signatures.txt, +# Licensed to Elasticsearch under one or more contributor, +# license agreements. See the NOTICE file distributed with, +# this work for additional information regarding copyright, +# ownership. Elasticsearch licenses this file to you under, +# the Apache License, Version 2.0 (the "License"); you may, +# not use this file except in compliance  with the License., +# You may obtain a copy of the License at, +#, +#     http://www.apache.org/licenses/LICENSE-2.0, +#, +# Unless required by applicable law or agreed to in writing,, +# software distributed under the License is distributed on, +# an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,, +# either express or implied. See the License for the specific, +# language governing permissions and limitations under the License., +, +@defaultMessage unsafe encoders/decoders have problems in the lzf compress library.  Use variants of encode/decode functions which take Encoder/Decoder., +com.ning.compress.lzf.impl.UnsafeChunkEncoders#createEncoder(int), +com.ning.compress.lzf.impl.UnsafeChunkEncoders#createNonAllocatingEncoder(int), +com.ning.compress.lzf.impl.UnsafeChunkEncoders#createEncoder(int, com.ning.compress.BufferRecycler), +com.ning.compress.lzf.impl.UnsafeChunkEncoders#createNonAllocatingEncoder(int, com.ning.compress.BufferRecycler), +com.ning.compress.lzf.impl.UnsafeChunkDecoder#<init>(), +com.ning.compress.lzf.parallel.CompressTask, +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalInstance(), +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalInstance(int), +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalNonAllocatingInstance(int), +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalInstance(com.ning.compress.BufferRecycler), +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalInstance(int, com.ning.compress.BufferRecycler), +com.ning.compress.lzf.util.ChunkEncoderFactory#optimalNonAllocatingInstance(int, com.ning.compress.BufferRecycler), +com.ning.compress.lzf.util.ChunkDecoderFactory#optimalInstance(), +com.ning.compress.lzf.util.LZFFileInputStream#<init>(java.io.File), +com.ning.compress.lzf.util.LZFFileInputStream#<init>(java.io.FileDescriptor), +com.ning.compress.lzf.util.LZFFileInputStream#<init>(java.lang.String), +com.ning.compress.lzf.util.LZFFileOutputStream#<init>(java.io.File), +com.ning.compress.lzf.util.LZFFileOutputStream#<init>(java.io.File, boolean), +com.ning.compress.lzf.util.LZFFileOutputStream#<init>(java.io.FileDescriptor), +com.ning.compress.lzf.util.LZFFileOutputStream#<init>(java.lang.String), +com.ning.compress.lzf.util.LZFFileOutputStream#<init>(java.lang.String, boolean)]