[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        // always configure soft-deletes field so an engine with soft-deletes disabled can open a Lucene index with soft-deletes., +        if (softDeleteEnabled) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        // always configure soft-deletes field so an engine with soft-deletes disabled can open a Lucene index with soft-deletes., +        if (softDeleteEnabled) {, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +    public void testOpenSoftDeletesIndexWithSoftDeletesDisabled() throws Exception {, +        try (Store store = createStore()) {, +            Path translogPath = createTempDir();, +            final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);, +            final IndexSettings softDeletesEnabled = IndexSettingsModule.newIndexSettings(, +                IndexMetaData.builder(defaultSettings.getIndexMetaData()).settings(Settings.builder()., +                    put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)).build());, +            final List<DocIdSeqNoAndTerm> docs;, +            try (InternalEngine engine = createEngine(, +                config(softDeletesEnabled, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get))) {, +                List<Engine.Operation> ops = generateReplicaHistory(between(1, 100), randomBoolean());, +                applyOperations(engine, ops);, +                globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getLocalCheckpoint()));, +                engine.syncTranslog();, +                engine.flush();, +                docs = getDocIds(engine, true);, +            }, +            final IndexSettings softDeletesDisabled = IndexSettingsModule.newIndexSettings(, +                IndexMetaData.builder(defaultSettings.getIndexMetaData()).settings(Settings.builder(), +                    .put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false)).build());, +            EngineConfig config = config(softDeletesDisabled, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get);, +            trimUnsafeCommits(config);, +            try (InternalEngine engine = createEngine(config)) {, +                assertThat(getDocIds(engine, true), equalTo(docs));, +            }, +        }, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        // always configure soft-deletes field so an engine with soft-deletes disabled can open a Lucene index with soft-deletes., +        if (softDeleteEnabled) {, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +    public void testOpenSoftDeletesIndexWithSoftDeletesDisabled() throws Exception {, +        try (Store store = createStore()) {, +            Path translogPath = createTempDir();, +            final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);, +            final IndexSettings softDeletesEnabled = IndexSettingsModule.newIndexSettings(, +                IndexMetaData.builder(defaultSettings.getIndexMetaData()).settings(Settings.builder()., +                    put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)).build());, +            final List<DocIdSeqNoAndTerm> docs;, +            try (InternalEngine engine = createEngine(, +                config(softDeletesEnabled, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get))) {, +                List<Engine.Operation> ops = generateReplicaHistory(between(1, 100), randomBoolean());, +                applyOperations(engine, ops);, +                globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getLocalCheckpoint()));, +                engine.syncTranslog();, +                engine.flush();, +                docs = getDocIds(engine, true);, +            }, +            final IndexSettings softDeletesDisabled = IndexSettingsModule.newIndexSettings(, +                IndexMetaData.builder(defaultSettings.getIndexMetaData()).settings(Settings.builder(), +                    .put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false)).build());, +            EngineConfig config = config(softDeletesDisabled, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get);, +            trimUnsafeCommits(config);, +            try (InternalEngine engine = createEngine(config)) {, +                assertThat(getDocIds(engine, true), equalTo(docs));, +            }, +        }, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +import org.elasticsearch.common.Randomness;, +    public List<Engine.Operation> generateReplicaHistory(int numOps, boolean allowGapInSeqNo) {, +        long seqNo = 0;, +        List<Engine.Operation> operations = new ArrayList<>(numOps);, +        for (int i = 0; i < numOps; i++) {, +            String id = Integer.toString(between(1, 100));, +            final ParsedDocument doc = EngineTestCase.createParsedDoc(id, null);, +            if (randomBoolean()) {, +                operations.add(new Engine.Index(EngineTestCase.newUid(doc), doc, seqNo, primaryTerm.get(),, +                    i, null, Engine.Operation.Origin.REPLICA, threadPool.relativeTimeInMillis(),, +                    -1, true));, +            } else if (randomBoolean()) {, +                operations.add(new Engine.Delete(doc.type(), doc.id(), EngineTestCase.newUid(doc), seqNo, primaryTerm.get(),, +                    i, null, Engine.Operation.Origin.REPLICA, threadPool.relativeTimeInMillis()));, +            } else {, +                operations.add(new Engine.NoOp(seqNo, primaryTerm.get(), Engine.Operation.Origin.REPLICA,, +                    threadPool.relativeTimeInMillis(), "test-" + i));, +            }, +            seqNo++;, +            if (allowGapInSeqNo && rarely()) {, +                seqNo++;, +            }, +        }, +        Randomness.shuffle(operations);, +        return operations;, +    }, +, +                        applyOperation(engine, ops.get(docOffset));, +    public static void applyOperations(Engine engine, List<Engine.Operation> operations) throws IOException {, +        for (Engine.Operation operation : operations) {, +            applyOperation(engine, operation);, +            if (randomInt(100) < 10) {]