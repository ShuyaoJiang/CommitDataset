[+++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.indices.IndicesService;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final IndicesService indicesService;, +, +    private final boolean waitForMappingChange;, +                                MetaDataMappingService metaDataMappingService, IndicesService indicesService) {, +        this.indicesService = indicesService;, +        this.waitForMappingChange = settings.getAsBoolean("action.wait_on_mapping_change", false);, +    public void updateMappingOnMaster(String index, String type, boolean neverWaitForMappingChange) {, +        IndexMetaData metaData = clusterService.state().metaData().index(index);, +        if (metaData != null) {, +            updateMappingOnMaster(index, type, metaData.getUUID(), neverWaitForMappingChange);, +        }, +    }, +, +    public void updateMappingOnMaster(String index, String type, String indexUUID, boolean neverWaitForMappingChange) {, +        final MapperService mapperService = indicesService.indexServiceSafe(index).mapperService();, +        final DocumentMapper documentMapper = mapperService.documentMapper(type);, +        if (documentMapper != null) { // should not happen, +            updateMappingOnMaster(documentMapper, index, type, indexUUID, neverWaitForMappingChange);, +        }, +    }, +, +    public void updateMappingOnMaster(DocumentMapper documentMapper, String index, String type, String indexUUID, boolean neverWaitForMappingChange) {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final MappingUpdatedAction.MappingUpdatedRequest mappingRequest;, +        try {, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdateOrderGen.incrementAndGet();, +            documentMapper.refreshSource();, +            DiscoveryNode node = clusterService.localNode();, +            mappingRequest = new MappingUpdatedAction.MappingUpdatedRequest(, +                    index, indexUUID, type, documentMapper.mappingSource(), orderId, node != null ? node.id() : null, +            );, +        } catch (Throwable t) {, +            logger.warn("Failed to update master on updated mapping for index [" + index + "], type [" + type + "]", t);, +            latch.countDown();, +            throw t;, +        }, +        logger.trace("Sending mapping updated to master: {}", mappingRequest);, +        execute(mappingRequest, new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {, +            @Override, +            public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {, +                // all is well, +                latch.countDown();, +                logger.debug("Successfully updated master with mapping update: {}", mappingRequest);, +            }, +, +            @Override, +            public void onFailure(Throwable e) {, +                latch.countDown();, +                logger.warn("Failed to update master on updated mapping for {}", e, mappingRequest);, +            }, +        });, +        if (waitForMappingChange && !neverWaitForMappingChange) {, +            try {, +                latch.await(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            }, +        }, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +            mappingUpdatedAction.updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2(), true);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +                mappingUpdatedAction.updateMappingOnMaster(request.index(), request.type(), indexMetaData.getUUID(), false);, +++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.indices.IndicesService;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final IndicesService indicesService;, +, +    private final boolean waitForMappingChange;, +                                MetaDataMappingService metaDataMappingService, IndicesService indicesService) {, +        this.indicesService = indicesService;]