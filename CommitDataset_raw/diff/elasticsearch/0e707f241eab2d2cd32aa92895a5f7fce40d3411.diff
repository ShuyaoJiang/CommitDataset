[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.indices.recovery.PeerRecoveryTargetService;, +        final ShardRouting currentRouting;, +        synchronized (mutex) {, +            currentRouting = this.shardRouting;, +, +            if (currentRouting != null && currentRouting.primary() && newRouting.primary() == false) {, +                throw new IllegalArgumentException("illegal state: trying to move shard from primary mode to replica mode. Current ", +                    + currentRouting + ", new " + newRouting);, +            if (state == IndexShardState.POST_RECOVERY && newRouting.active()) {, +                assert currentRouting.active() == false : "we are in POST_RECOVERY, but our shard routing is active " + currentRouting;, +            } else if (state == IndexShardState.RELOCATED &&, +        if (currentRouting != null && currentRouting.active() == false && newRouting.active()) {, +            indexEventListener.afterIndexShardStarted(this);, +        }, +        if (newRouting.equals(currentRouting) == false) {, +            indexEventListener.shardRoutingChanged(this, currentRouting, newRouting);, +        }, +    }, +        assert shardRouting.primary() : "only primaries can be marked as relocated: " + shardRouting;, +                    // if the master cancelled the recovery, the target will be removed, +                    // and the recovery will stopped., +                    // However, it is still possible that we concurrently end up here, +                    // and therefore have to protect we don't mark the shard as relocated when, +                    // its shard routing says otherwise., +                    if (shardRouting.relocating() == false) {, +                        throw new IllegalIndexShardStateException(shardId, IndexShardState.STARTED,, +                            ": shard is no longer relocating " + shardRouting);, +                    }, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.indices.recovery.PeerRecoveryTargetService;, +        final ShardRouting currentRouting;, +        synchronized (mutex) {, +            currentRouting = this.shardRouting;, +, +            if (currentRouting != null && currentRouting.primary() && newRouting.primary() == false) {, +                throw new IllegalArgumentException("illegal state: trying to move shard from primary mode to replica mode. Current ", +                    + currentRouting + ", new " + newRouting);, +            if (state == IndexShardState.POST_RECOVERY && newRouting.active()) {, +                assert currentRouting.active() == false : "we are in POST_RECOVERY, but our shard routing is active " + currentRouting;, +            } else if (state == IndexShardState.RELOCATED &&, +        if (currentRouting != null && currentRouting.active() == false && newRouting.active()) {, +            indexEventListener.afterIndexShardStarted(this);, +        }, +        if (newRouting.equals(currentRouting) == false) {, +            indexEventListener.shardRoutingChanged(this, currentRouting, newRouting);, +        }, +    }, +        assert shardRouting.primary() : "only primaries can be marked as relocated: " + shardRouting;, +                    // if the master cancelled the recovery, the target will be removed, +                    // and the recovery will stopped., +                    // However, it is still possible that we concurrently end up here, +                    // and therefore have to protect we don't mark the shard as relocated when, +                    // its shard routing says otherwise., +                    if (shardRouting.relocating() == false) {, +                        throw new IllegalIndexShardStateException(shardId, IndexShardState.STARTED,, +                            ": shard is no longer relocating " + shardRouting);, +                    }, +++ b/core/src/test/java/org/elasticsearch/index/query/MatchQueryBuilderTests.java, +, +    public void testParseFailsWithTermsArray() throws Exception {, +        String json1 = "{\n" +, +                "  \"match\" : {\n" +, +                "    \"message1\" : {\n" +, +                "      \"query\" : [\"term1\", \"term2\"]\n" +, +                "    }\n" +, +                "  }\n" +, +                "}";, +        expectThrows(ParsingException.class, () -> parseQuery(json1));, +, +        String json2 = "{\n" +, +                "  \"match\" : {\n" +, +                "    \"message1\" : [\"term1\", \"term2\"]\n" +, +                "  }\n" +, +                "}";, +        expectThrows(IllegalStateException.class, () -> parseQuery(json2));, +    }, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.indices.recovery.PeerRecoveryTargetService;, +        final ShardRouting currentRouting;, +        synchronized (mutex) {, +            currentRouting = this.shardRouting;, +, +            if (currentRouting != null && currentRouting.primary() && newRouting.primary() == false) {, +                throw new IllegalArgumentException("illegal state: trying to move shard from primary mode to replica mode. Current ", +                    + currentRouting + ", new " + newRouting);, +            if (state == IndexShardState.POST_RECOVERY && newRouting.active()) {, +                assert currentRouting.active() == false : "we are in POST_RECOVERY, but our shard routing is active " + currentRouting;, +            } else if (state == IndexShardState.RELOCATED &&, +        if (currentRouting != null && currentRouting.active() == false && newRouting.active()) {, +            indexEventListener.afterIndexShardStarted(this);, +        }, +        if (newRouting.equals(currentRouting) == false) {, +            indexEventListener.shardRoutingChanged(this, currentRouting, newRouting);, +        }, +    }]