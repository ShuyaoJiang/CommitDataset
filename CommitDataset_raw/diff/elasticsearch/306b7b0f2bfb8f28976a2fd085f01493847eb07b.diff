[+++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +            deleteIndexDirectoryUnderLock(index, indexSettings);, +        } finally {, +            IOUtils.closeWhileHandlingException(locks);, +        }, +    }, +, +    /**, +     * Deletes an indexes data directory recursively., +     * Note: this method assumes that the shard lock is acquired, +     *, +     * @param index the index to delete, +     * @param indexSettings settings for the index being deleted, +     */, +    public void deleteIndexDirectoryUnderLock(Index index, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +            deleteIndexDirectoryUnderLock(index, indexSettings);, +        } finally {, +            IOUtils.closeWhileHandlingException(locks);, +        }, +    }, +, +    /**, +     * Deletes an indexes data directory recursively., +     * Note: this method assumes that the shard lock is acquired, +     *, +     * @param index the index to delete, +     * @param indexSettings settings for the index being deleted, +     */, +    public void deleteIndexDirectoryUnderLock(Index index, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +                indicesServices.addPendingDelete(lock.getShardId(), indexSettings);, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +            deleteIndexDirectoryUnderLock(index, indexSettings);, +        } finally {, +            IOUtils.closeWhileHandlingException(locks);, +        }, +    }, +, +    /**, +     * Deletes an indexes data directory recursively., +     * Note: this method assumes that the shard lock is acquired, +     *, +     * @param index the index to delete, +     * @param indexSettings settings for the index being deleted, +     */, +    public void deleteIndexDirectoryUnderLock(Index index, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +                indicesServices.addPendingDelete(lock.getShardId(), indexSettings);, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +            deleteIndexDirectoryUnderLock(index, indexSettings);, +        } finally {, +            IOUtils.closeWhileHandlingException(locks);, +        }, +    }, +, +    /**, +     * Deletes an indexes data directory recursively., +     * Note: this method assumes that the shard lock is acquired, +     *, +     * @param index the index to delete, +     * @param indexSettings settings for the index being deleted, +     */, +    public void deleteIndexDirectoryUnderLock(Index index, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +                indicesServices.addPendingDelete(lock.getShardId(), indexSettings);, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.apache.lucene.util.CollectionUtil;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.bootstrap.Elasticsearch;, +        boolean success = false;, +            success = true;, +            if (success == false) {, +                addPendingDelete(index, indexSettings);, +            }, +     * Adds a pending delete for the given index shard., +    public void addPendingDelete(ShardId shardId, @IndexSettings Settings settings) {, +        if (shardId == null) {, +            throw new ElasticsearchIllegalArgumentException("shardId must not be null");, +        }, +        if (settings == null) {, +            throw new ElasticsearchIllegalArgumentException("settings must not be null");, +        }, +        PendingDelete pendingDelete = new PendingDelete(shardId, settings, false);, +        addPendingDelete(shardId.index(), pendingDelete);, +    }, +, +    private void addPendingDelete(Index index, PendingDelete pendingDelete) {, +            list.add(pendingDelete);, +    /**]