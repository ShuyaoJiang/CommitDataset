[+++ b/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +    public static Builder builder(String index) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +    public static Builder builder(String index) {, +++ b/src/test/java/org/elasticsearch/cluster/ClusterHealthResponsesTests.java, +package org.elasticsearch.cluster;, +/*, + * Licensed to ElasticSearch under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.action.admin.cluster.health.ClusterIndexHealth;, +import org.elasticsearch.action.admin.cluster.health.ClusterShardHealth;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.routing.*;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.test.ElasticsearchTestCase;, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.equalTo;, +, +public class ClusterHealthResponsesTests extends ElasticsearchTestCase {, +, +, +    private void assertIndexHealth(ClusterIndexHealth indexHealth, ShardCounter counter, IndexMetaData indexMetaData) {, +        assertThat(indexHealth.getStatus(), equalTo(counter.status()));, +        assertThat(indexHealth.getNumberOfShards(), equalTo(indexMetaData.getNumberOfShards()));, +        assertThat(indexHealth.getNumberOfReplicas(), equalTo(indexMetaData.getNumberOfReplicas()));, +        assertThat(indexHealth.getActiveShards(), equalTo(counter.active));, +        assertThat(indexHealth.getRelocatingShards(), equalTo(counter.relocating));, +        assertThat(indexHealth.getInitializingShards(), equalTo(counter.initializing));, +        assertThat(indexHealth.getUnassignedShards(), equalTo(counter.unassigned));, +        assertThat(indexHealth.getShards().size(), equalTo(indexMetaData.getNumberOfShards()));, +        int totalShards = 0;, +        for (ClusterShardHealth shardHealth : indexHealth.getShards().values()) {, +            totalShards += shardHealth.getActiveShards() + shardHealth.getInitializingShards() + shardHealth.getUnassignedShards();, +        }, +, +        assertThat(totalShards, equalTo(indexMetaData.getNumberOfShards() * (1 + indexMetaData.getNumberOfReplicas())));, +    }, +, +    protected class ShardCounter {, +        public int active;, +        public int relocating;, +        public int initializing;, +        public int unassigned;, +        public int primaryActive;, +        public int primaryInactive;, +, +        public ClusterHealthStatus status() {, +            if (primaryInactive > 0) {, +                return ClusterHealthStatus.RED;, +            }, +            if (unassigned > 0 || initializing > 0) {, +                return ClusterHealthStatus.YELLOW;, +            }, +            return ClusterHealthStatus.GREEN;, +        }, +, +        public void update(ShardRouting shardRouting) {, +            if (shardRouting.active()) {, +                active++;, +                if (shardRouting.primary()) {, +                    primaryActive++;, +                }, +                if (shardRouting.relocating()) {, +                    relocating++;, +                }, +                return;, +            }, +, +            if (shardRouting.primary()) {, +                primaryInactive++;, +            }, +            if (shardRouting.initializing()) {, +                initializing++;, +            } else {, +                unassigned++;, +            }, +        }, +    }]