[+++ b/src/main/java/org/elasticsearch/watcher/rest/action/RestExecuteWatchAction.java, +++ b/src/main/java/org/elasticsearch/watcher/rest/action/RestExecuteWatchAction.java, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.watcher.support.clock.Clock;, +import java.util.concurrent.Callable;, +import java.util.concurrent.TimeUnit;, +    public static final DateMathParser dateMathParser = new DateMathParser(dateTimeFormatter, TimeUnit.SECONDS);, +    public static DateTime parseDateMath(String fieldName, XContentParser parser, DateTimeZone timeZone, Clock clock) throws IOException {, +        if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {, +            throw new ParseException("could not parse date/time expected date field [{}] to not be null but was null", fieldName);, +        }, +        return parseDateMathOrNull(fieldName, parser, timeZone, clock);, +    }, +, +    public static DateTime parseDateMathOrNull(String fieldName, XContentParser parser, DateTimeZone timeZone, Clock clock) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        if (token == XContentParser.Token.VALUE_NUMBER) {, +            return new DateTime(parser.longValue(), timeZone);, +        }, +        if (token == XContentParser.Token.VALUE_STRING) {, +            try {, +                return parseDateMath(parser.text(), timeZone, clock);, +            } catch (ElasticsearchParseException epe) {, +                throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a DateMath string but found [{}] instead", epe, fieldName, parser.text());, +            }, +        }, +        if (token == XContentParser.Token.VALUE_NULL) {, +            return null;, +        }, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static DateTime parseDateMath(String valueString, DateTimeZone timeZone, final Clock clock) {, +        return new DateTime(dateMathParser.parse(valueString, new ClockNowCallable(clock)), timeZone);, +    }, +, +        public ParseException(String msg, Throwable cause, Object... args) {, +            super(msg, cause, args);, +        }, +, +, +    private static class ClockNowCallable implements Callable<Long> {, +        private final Clock clock;, +, +        ClockNowCallable(Clock clock){, +            this.clock = clock;, +        }, +, +        @Override, +        public Long call() throws Exception {, +            return clock.millis();, +        }, +    }, +++ b/src/main/java/org/elasticsearch/watcher/rest/action/RestExecuteWatchAction.java, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.watcher.support.clock.Clock;, +import java.util.concurrent.Callable;, +import java.util.concurrent.TimeUnit;, +    public static final DateMathParser dateMathParser = new DateMathParser(dateTimeFormatter, TimeUnit.SECONDS);, +    public static DateTime parseDateMath(String fieldName, XContentParser parser, DateTimeZone timeZone, Clock clock) throws IOException {, +        if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {, +            throw new ParseException("could not parse date/time expected date field [{}] to not be null but was null", fieldName);, +        }, +        return parseDateMathOrNull(fieldName, parser, timeZone, clock);, +    }, +, +    public static DateTime parseDateMathOrNull(String fieldName, XContentParser parser, DateTimeZone timeZone, Clock clock) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        if (token == XContentParser.Token.VALUE_NUMBER) {, +            return new DateTime(parser.longValue(), timeZone);, +        }, +        if (token == XContentParser.Token.VALUE_STRING) {, +            try {, +                return parseDateMath(parser.text(), timeZone, clock);, +            } catch (ElasticsearchParseException epe) {, +                throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a DateMath string but found [{}] instead", epe, fieldName, parser.text());, +            }, +        }, +        if (token == XContentParser.Token.VALUE_NULL) {, +            return null;, +        }, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static DateTime parseDateMath(String valueString, DateTimeZone timeZone, final Clock clock) {, +        return new DateTime(dateMathParser.parse(valueString, new ClockNowCallable(clock)), timeZone);, +    }, +, +        public ParseException(String msg, Throwable cause, Object... args) {, +            super(msg, cause, args);, +        }, +, +, +    private static class ClockNowCallable implements Callable<Long> {, +        private final Clock clock;, +]