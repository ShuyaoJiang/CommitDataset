[+++ b/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +    /**, +     * Clears the list of cached ping responses., +     */, +    public void clearTemporalReponses() {, +        temporalResponses.clear();, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +    /**, +     * Clears the list of cached ping responses., +     */, +    public void clearTemporalReponses() {, +        temporalResponses.clear();, +    }, +, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +import org.elasticsearch.cluster.block.ClusterBlock;, +import org.elasticsearch.discovery.zen.ping.ZenPing;, +import org.elasticsearch.discovery.zen.ping.ZenPingService;, +import org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing;, +, +        // TODO: Rarely use default settings form some of these, +                .put("gateway.local.list_timeout", "10s") // still long to induce failures but to long so test won't time out, +        // TODO: this is a temporary solution so that nodes will not base their reaction to a partition based on previous successful results, +        for (ZenPingService pingService : internalCluster().getInstances(ZenPingService.class)) {, +            for (ZenPing zenPing : pingService.zenPings()) {, +                if (zenPing instanceof UnicastZenPing) {, +                    ((UnicastZenPing) zenPing).clearTemporalReponses();, +                }, +            }, +        }, +, +        assertNoMaster(unluckyNode);, +        assertNoMaster(isolatedNode, DiscoverySettings.NO_MASTER_BLOCK_WRITES, TimeValue.timeValueSeconds(10));, +            boolean success = true;, +        assertNoMaster(isolatedNode, DiscoverySettings.NO_MASTER_BLOCK_ALL, TimeValue.timeValueSeconds(10));, +        // make sure isolated need picks up on things., +        assertNoMaster(isolatedNode, TimeValue.timeValueSeconds(40));, +, +    private void assertNoMaster(final String node) throws Exception {, +        assertNoMaster(node, null, TimeValue.timeValueSeconds(10));, +    }, +, +    private void assertNoMaster(final String node, TimeValue maxWaitTime) throws Exception {, +        assertNoMaster(node, null, maxWaitTime);, +    }, +, +    private void assertNoMaster(final String node, @Nullable final ClusterBlock expectedBlocks, TimeValue maxWaitTime) throws Exception {, +        assertBusy(new Runnable() {, +            @Override, +            public void run() {, +                ClusterState state = getNodeClusterState(node);, +                assertNull("node [" + node + "] still has [" + state.nodes().masterNode() + "] as master", state.nodes().masterNode());, +                if (expectedBlocks != null) {, +                    for (ClusterBlockLevel level : expectedBlocks.levels()) {, +                        assertTrue("node [" + node + "] does have level [" + level + "] in it's blocks", state.getBlocks().hasGlobalBlock(level));, +                    }, +                }, +            }, +        }, maxWaitTime.getMillis(), TimeUnit.MILLISECONDS);, +    }]