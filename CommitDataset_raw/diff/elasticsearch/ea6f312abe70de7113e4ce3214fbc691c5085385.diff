[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import java.util.Objects;, +    static final ParseField PATH_FIELD = new ParseField("path");, +, +        /**, +         * @param name, +         *            the name of this aggregation, +         * @param path, +         *            the path to use for this nested aggregation. The path must, +         *            match the path to a nested object in the mappings., +         */, +        /**, +         * Get the path to use for this nested aggregation., +         */, +        public String path() {, +            return path;, +        }, +, +        @Override, +        protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.startObject();, +            builder.field(PATH_FIELD.getPreferredName(), path);, +            builder.endObject();, +            return builder;, +        }, +, +        @Override, +        protected AggregatorFactory doReadFrom(String name, StreamInput in) throws IOException {, +            String path = in.readString();, +            Factory factory = new Factory(name, path);, +            return factory;, +        }, +, +        @Override, +        protected void doWriteTo(StreamOutput out) throws IOException {, +            out.writeString(path);, +        }, +, +        @Override, +        protected int doHashCode() {, +            return Objects.hash(path);, +        }, +, +        @Override, +        protected boolean doEquals(Object obj) {, +            Factory other = (Factory) obj;, +            return Objects.equals(path, other.path);, +        }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import java.util.Objects;, +    static final ParseField PATH_FIELD = new ParseField("path");, +, +        /**, +         * @param name, +         *            the name of this aggregation, +         * @param path, +         *            the path to use for this nested aggregation. The path must, +         *            match the path to a nested object in the mappings., +         */, +        /**, +         * Get the path to use for this nested aggregation., +         */, +        public String path() {, +            return path;, +        }, +, +        @Override, +        protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.startObject();, +            builder.field(PATH_FIELD.getPreferredName(), path);, +            builder.endObject();, +            return builder;, +        }, +, +        @Override, +        protected AggregatorFactory doReadFrom(String name, StreamInput in) throws IOException {, +            String path = in.readString();, +            Factory factory = new Factory(name, path);, +            return factory;, +        }, +, +        @Override, +        protected void doWriteTo(StreamOutput out) throws IOException {, +            out.writeString(path);, +        }, +, +        @Override, +        protected int doHashCode() {, +            return Objects.hash(path);, +        }, +]