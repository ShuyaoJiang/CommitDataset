[+++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.MatchNoDocsQuery;, +        return new MatchNoDocsQuery();, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.MatchNoDocsQuery;, +        return new MatchNoDocsQuery();, +++ b/core/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +        // TODO This is weird: DEFAULT_ZERO_TERMS_QUERY is a public static final field, so this can have only one value., +        // why are we then having this if clause in here?, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.MatchNoDocsQuery;, +        return new MatchNoDocsQuery();, +++ b/core/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +        // TODO This is weird: DEFAULT_ZERO_TERMS_QUERY is a public static final field, so this can have only one value., +        // why are we then having this if clause in here?, +++ b/core/src/main/java/org/elasticsearch/rest/action/cat/RestFielddataAction.java, +import com.carrotsearch.hppc.ObjectLongHashMap;, +import com.carrotsearch.hppc.ObjectLongMap;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.Set;, +, +, +                .addCell("total", "text-align:right;desc:total field data usage"), +        Set<String> fieldNames = new HashSet<>();, +        Map<NodeStats, ObjectLongMap<String>> nodesFields = new HashMap<>();, +        // Collect all the field names so a new table can be built, +        for (NodeStats ns : nodeStatses.getNodes()) {, +            ObjectLongHashMap<String> fields = ns.getIndices().getFieldData().getFields();, +            nodesFields.put(ns, fields);, +            if (fields != null) {, +                for (String key : fields.keys().toArray(String.class)) {, +                    fieldNames.add(key);, +                }, +            }, +        }, +, +        // The table must be rebuilt because it has dynamic headers based on the fields, +        Table table = new Table();, +        table.startHeaders(), +                .addCell("id", "desc:node id"), +                .addCell("host", "alias:h;desc:host name"), +                .addCell("ip", "desc:ip address"), +                .addCell("node", "alias:n;desc:node name"), +                .addCell("total", "text-align:right;desc:total field data usage");, +        // The table columns must be built dynamically since the number of fields is unknown, +        for (String fieldName : fieldNames) {, +            table.addCell(fieldName, "text-align:right;desc:" + fieldName + " field");, +        }, +        table.endHeaders();, +, +        for (Map.Entry<NodeStats, ObjectLongMap<String>> statsEntry : nodesFields.entrySet()) {, +            // add the node info and field data total before each individual field, +            NodeStats ns = statsEntry.getKey();, +            table.addCell(ns.getNode().getId());, +            table.addCell(ns.getNode().getHostName());, +            table.addCell(ns.getNode().getHostAddress());, +            table.addCell(ns.getNode().getName());, +            table.addCell(ns.getIndices().getFieldData().getMemorySize());, +            ObjectLongMap<String> fields = statsEntry.getValue();, +            for (String fieldName : fieldNames) {, +                table.addCell(new ByteSizeValue(fields == null ? 0L : fields.getOrDefault(fieldName, 0L)));, +            }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.MatchNoDocsQuery;, +        return new MatchNoDocsQuery();, +++ b/core/src/main/java/org/elasticsearch/index/search/MatchQuery.java, +        // TODO This is weird: DEFAULT_ZERO_TERMS_QUERY is a public static final field, so this can have only one value., +        // why are we then having this if clause in here?, +++ b/core/src/main/java/org/elasticsearch/rest/action/cat/RestFielddataAction.java, +import com.carrotsearch.hppc.ObjectLongHashMap;, +import com.carrotsearch.hppc.ObjectLongMap;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.Set;, +, +, +                .addCell("total", "text-align:right;desc:total field data usage"), +        Set<String> fieldNames = new HashSet<>();, +        Map<NodeStats, ObjectLongMap<String>> nodesFields = new HashMap<>();, +        // Collect all the field names so a new table can be built, +        for (NodeStats ns : nodeStatses.getNodes()) {, +            ObjectLongHashMap<String> fields = ns.getIndices().getFieldData().getFields();, +            nodesFields.put(ns, fields);, +            if (fields != null) {, +                for (String key : fields.keys().toArray(String.class)) {, +                    fieldNames.add(key);, +                }, +            }, +        }, +, +        // The table must be rebuilt because it has dynamic headers based on the fields, +        Table table = new Table();, +        table.startHeaders(), +                .addCell("id", "desc:node id"), +                .addCell("host", "alias:h;desc:host name"), +                .addCell("ip", "desc:ip address"), +                .addCell("node", "alias:n;desc:node name")]