[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +        Query query = MissingQueryParser.newFilter(parseContext, queryText, MissingQueryParser.DEFAULT_EXISTENCE_VALUE, MissingQueryParser.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +        Query query = MissingQueryParser.newFilter(parseContext, queryText, MissingQueryParser.DEFAULT_EXISTENCE_VALUE, MissingQueryParser.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/elasticsearch/index/query/MissingQueryBuilder.java, + * Constructs a filter that only match on documents that the field has a value in them., +    private String name;, +    private Boolean nullValue;, +    private Boolean existence;, +    public MissingQueryBuilder(String name) {, +        this.name = name;, +     * Should the missing filter include documents where the field doesn't exists in the docs., +        builder.field("field", name);, +        if (nullValue != null) {, +        }, +        if (existence != null) {, +        }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +        Query query = MissingQueryParser.newFilter(parseContext, queryText, MissingQueryParser.DEFAULT_EXISTENCE_VALUE, MissingQueryParser.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/elasticsearch/index/query/MissingQueryBuilder.java, + * Constructs a filter that only match on documents that the field has a value in them., +    private String name;, +    private Boolean nullValue;, +    private Boolean existence;, +    public MissingQueryBuilder(String name) {, +        this.name = name;, +     * Should the missing filter include documents where the field doesn't exists in the docs., +        builder.field("field", name);, +        if (nullValue != null) {, +        }, +        if (existence != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/index/query/MissingQueryParser.java, +import org.apache.lucene.search.BooleanClause;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.TermRangeQuery;, +import org.elasticsearch.common.lucene.search.Queries;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.internal.FieldNamesFieldMapper;, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +import java.util.Collection;, +public class MissingQueryParser extends BaseQueryParserTemp {, +, +    public static final boolean DEFAULT_NULL_VALUE = false;, +    public static final boolean DEFAULT_EXISTENCE_VALUE = true;, +    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {, +        boolean nullValue = DEFAULT_NULL_VALUE;, +        boolean existence = DEFAULT_EXISTENCE_VALUE;, +        Query query = newFilter(parseContext, fieldPattern, existence, nullValue);, +        if (queryName != null) {, +            parseContext.addNamedQuery(queryName, query);, +        }, +        if (query != null) {, +            query.setBoost(boost);, +        }, +        return query;, +    }, +, +    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, boolean existence, boolean nullValue) {, +        if (!existence && !nullValue) {, +            throw new QueryParsingException(parseContext, "missing must have either existence, or null_value, or both set to true");, +        }, +, +        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);, +        if (fieldNamesFieldType == null) {, +            // can only happen when no types exist, so no docs exist either, +            return Queries.newMatchNoDocsQuery();, +        }, +, +        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);, +        if (objectMapper != null) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            if (existence) {, +                // if we ask for existence of fields, and we found none, then we should match on all, +                return Queries.newMatchAllQuery();, +            }, +            return null;, +        }, +, +        Query existenceFilter = null;, +        Query nullFilter = null;, +, +        if (existence) {, +            BooleanQuery boolFilter = new BooleanQuery();, +            for (String field : fields) {, +                MappedFieldType fieldType = parseContext.fieldMapper(field);, +                Query filter = null;, +                if (fieldNamesFieldType.isEnabled()) {, +                    final String f;, +                    if (fieldType != null) {, +                        f = fieldType.names().indexName();, +                    } else {, +                        f = field;]