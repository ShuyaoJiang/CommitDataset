[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +                indexService.logger.trace("scheduling {} every {}", toString(), interval);, +                indexService.logger.trace("scheduled {} disabled", toString());, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +                indexService.logger.trace("scheduling {} every {}", toString(), interval);, +                indexService.logger.trace("scheduled {} disabled", toString());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregator.java, +import org.apache.lucene.search.IndexSearcher;, +                            Weight filter,, +        this.filter = filter;, +        // TODO: refactor in order to initialize the factory once with its parent,, +        // the context, etc. and then have a no-arg lightweight create method, +        // (since create may be called thousands of times)]