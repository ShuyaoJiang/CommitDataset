[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityIndexManager.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +        this(client, indexName, State.UNRECOVERED_STATE);, +    public boolean isStateRecovered() {, +        return this.indexState != State.UNRECOVERED_STATE;, +    }, +, +        if (indexState == State.UNRECOVERED_STATE) {, +            consumer.accept(new ElasticsearchStatusException("Cluster state has not been recovered yet, cannot write to the security index",, +                    RestStatus.SERVICE_UNAVAILABLE));, +        } else if (indexState.indexExists && indexState.isIndexUpToDate == false) {, +        public static final State UNRECOVERED_STATE = new State(false, false, false, false, null, null, null);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityIndexManager.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +        this(client, indexName, State.UNRECOVERED_STATE);, +    public boolean isStateRecovered() {, +        return this.indexState != State.UNRECOVERED_STATE;, +    }, +, +        if (indexState == State.UNRECOVERED_STATE) {, +            consumer.accept(new ElasticsearchStatusException("Cluster state has not been recovered yet, cannot write to the security index",, +                    RestStatus.SERVICE_UNAVAILABLE));, +        } else if (indexState.indexExists && indexState.isIndexUpToDate == false) {, +        public static final State UNRECOVERED_STATE = new State(false, false, false, false, null, null, null);, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/support/SecurityIndexManagerTests.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.cluster.block.ClusterBlocks;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import org.elasticsearch.gateway.GatewayService;, +import org.elasticsearch.rest.RestStatus;, +import static org.hamcrest.Matchers.instanceOf;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.hamcrest.Matchers.nullValue;, +        when(threadPool.generic()).thenReturn(EsExecutors.newDirectExecutorService());, +    public void testWriteBeforeStateNotRecovered() throws Exception {, +        final AtomicBoolean prepareRunnableCalled = new AtomicBoolean(false);, +        final AtomicReference<Exception> prepareException = new AtomicReference<>(null);, +        manager.prepareIndexIfNeededThenExecute(ex -> {, +            prepareException.set(ex);, +        }, () -> {, +            prepareRunnableCalled.set(true);, +        });, +        assertThat(prepareException.get(), is(notNullValue()));, +        assertThat(prepareException.get(), instanceOf(ElasticsearchStatusException.class));, +        assertThat(((ElasticsearchStatusException)prepareException.get()).status(), is(RestStatus.SERVICE_UNAVAILABLE));, +        assertThat(prepareRunnableCalled.get(), is(false));, +        prepareException.set(null);, +        prepareRunnableCalled.set(false);, +        // state not recovered, +        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK);, +        manager.clusterChanged(event(new ClusterState.Builder(CLUSTER_NAME).blocks(blocks)));, +        manager.prepareIndexIfNeededThenExecute(ex -> {, +            prepareException.set(ex);, +        }, () -> {, +            prepareRunnableCalled.set(true);, +        });, +        assertThat(prepareException.get(), is(notNullValue()));, +        assertThat(prepareException.get(), instanceOf(ElasticsearchStatusException.class));, +        assertThat(((ElasticsearchStatusException)prepareException.get()).status(), is(RestStatus.SERVICE_UNAVAILABLE));, +        assertThat(prepareRunnableCalled.get(), is(false));, +        prepareException.set(null);, +        prepareRunnableCalled.set(false);, +        // state recovered with index, +        ClusterState.Builder clusterStateBuilder = createClusterState(INDEX_NAME, TEMPLATE_NAME,, +                SecurityIndexManager.INTERNAL_INDEX_FORMAT);, +        markShardsAvailable(clusterStateBuilder);, +        manager.clusterChanged(event(clusterStateBuilder));, +        manager.prepareIndexIfNeededThenExecute(ex -> {, +            prepareException.set(ex);, +        }, () -> {, +            prepareRunnableCalled.set(true);, +        });, +        assertThat(prepareException.get(), is(nullValue()));, +        assertThat(prepareRunnableCalled.get(), is(true));, +    }, +, +    public void testListeneredNotCalledBeforeStateNotRecovered() throws Exception {, +        final AtomicBoolean listenerCalled = new AtomicBoolean(false);, +        manager.addIndexStateListener((prev, current) -> {, +            listenerCalled.set(true);, +        });, +        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK);, +        // state not recovered, +        manager.clusterChanged(event(new ClusterState.Builder(CLUSTER_NAME).blocks(blocks)));, +        assertThat(manager.isStateRecovered(), is(false));, +        assertThat(listenerCalled.get(), is(false));, +        // state recovered with index, +        ClusterState.Builder clusterStateBuilder = createClusterState(INDEX_NAME, TEMPLATE_NAME,, +                SecurityIndexManager.INTERNAL_INDEX_FORMAT);, +        markShardsAvailable(clusterStateBuilder);, +        manager.clusterChanged(event(clusterStateBuilder));, +        assertThat(manager.isStateRecovered(), is(true));, +        assertThat(listenerCalled.get(), is(true));, +    }, +, +        assertThat(manager.isStateRecovered(), Matchers.equalTo(false));, +        assertThat(manager.isStateRecovered(), Matchers.equalTo(true));]