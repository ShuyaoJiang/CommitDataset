[+++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +    public static final String ACTION_NAME = BulkAction.NAME + "[s]";, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +    public static final String ACTION_NAME = BulkAction.NAME + "[s]";, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                                internalRequest.request().setCanHaveDuplicates();, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +    public static final String ACTION_NAME = BulkAction.NAME + "[s]";, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                                internalRequest.request().setCanHaveDuplicates();, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +            } else if (create.origin() == Operation.Origin.PRIMARY && create.autoGeneratedId() && create.canHaveDuplicates() && currentVersion == 1 && create.version() == Versions.MATCH_ANY) {, +                /**, +                 * If bulk index request fails due to a disconnect, unavailable shard etc. then the request is, +                 * retried before it actually fails. However, the documents might already be indexed., +                 * For autogenerated ids this means that a version conflict will be reported in the bulk request, +                 * although the document was indexed properly., +                 * To avoid this we have to make sure that the index request is treated as an update and set updatedVersion to 1., +                 * See also discussion on https://github.com/elasticsearch/elasticsearch/pull/9125, +                 */, +                doUpdate = true;, +                updatedVersion = 1;, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +    public static final String ACTION_NAME = BulkAction.NAME + "[s]";, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                                internalRequest.request().setCanHaveDuplicates();, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +            } else if (create.origin() == Operation.Origin.PRIMARY && create.autoGeneratedId() && create.canHaveDuplicates() && currentVersion == 1 && create.version() == Versions.MATCH_ANY) {, +                /**, +                 * If bulk index request fails due to a disconnect, unavailable shard etc. then the request is, +                 * retried before it actually fails. However, the documents might already be indexed., +                 * For autogenerated ids this means that a version conflict will be reported in the bulk request, +                 * although the document was indexed properly., +                 * To avoid this we have to make sure that the index request is treated as an update and set updatedVersion to 1., +                 * See also discussion on https://github.com/elasticsearch/elasticsearch/pull/9125, +                 */, +                doUpdate = true;, +                updatedVersion = 1;, +++ b/src/test/java/org/elasticsearch/index/store/ExceptionRetryTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.store;, +, +import com.google.common.collect.Iterables;, +import com.google.common.collect.Lists;, +import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;, +import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;, +import org.elasticsearch.action.bulk.BulkItemResponse;, +import org.elasticsearch.action.bulk.BulkRequestBuilder;, +import org.elasticsearch.action.bulk.BulkResponse;, +import org.elasticsearch.action.bulk.TransportShardBulkAction;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.discovery.Discovery;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.test.ElasticsearchIntegrationTest;, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.*;, +import org.junit.Test;, +, +import java.io.IOException;, +import java.util.*;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;, +import static org.elasticsearch.index.query.QueryBuilders.termQuery;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.*;, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.Matchers.greaterThan;, +, +@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.SUITE), +public class ExceptionRetryTests extends ElasticsearchIntegrationTest {, +, +    @Override, +    protected Settings nodeSettings(int nodeOrdinal) {, +        return ImmutableSettings.builder(), +                .put(super.nodeSettings(nodeOrdinal)).put("gateway.type", "local"), +                .put(TransportModule.TRANSPORT_SERVICE_TYPE_KEY, MockTransportService.class.getName()), +                .build();, +    }]