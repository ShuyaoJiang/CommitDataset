[+++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequestBuilder.java, +     * to <tt>60s</tt>., +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequestBuilder.java, +     * to <tt>60s</tt>., +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +        final DeleteIndexListener listener = new DeleteIndexListener(mdLock, userListener);, +                // this listener will be notified once we get back a notification based on the cluster state change below., +        volatile ScheduledFuture<?> future;, +        private DeleteIndexListener(Semaphore mdLock, Listener listener) {, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequestBuilder.java, +     * to <tt>60s</tt>., +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +        final DeleteIndexListener listener = new DeleteIndexListener(mdLock, userListener);, +                // this listener will be notified once we get back a notification based on the cluster state change below., +        volatile ScheduledFuture<?> future;, +        private DeleteIndexListener(Semaphore mdLock, Listener listener) {, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +                    } catch (Throwable e) {, +                    } catch (Throwable e) {, +                } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequestBuilder.java, +     * to <tt>60s</tt>., +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +        final DeleteIndexListener listener = new DeleteIndexListener(mdLock, userListener);, +                // this listener will be notified once we get back a notification based on the cluster state change below., +        volatile ScheduledFuture<?> future;, +        private DeleteIndexListener(Semaphore mdLock, Listener listener) {, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +                    } catch (Throwable e) {, +                    } catch (Throwable e) {, +                } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        /*, +         * TODO: we execute this in parallel but it's a synced method. Yet, we might, +         * be able to serialize the execution via the cluster state in the future. for now we just, +         * keep it synced., +         */, +        final Injector shardInjector;, +        final IndexShard indexShard;, +        final ShardId sId = new ShardId(index, shardId);, +            } catch (Throwable e) {, +        } catch (Throwable e) {, +            } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +        } catch (Throwable e) {, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java, +    private TimeValue timeout = timeValueSeconds(60);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequestBuilder.java, +     * to <tt>60s</tt>., +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +        final DeleteIndexListener listener = new DeleteIndexListener(mdLock, userListener);, +                // this listener will be notified once we get back a notification based on the cluster state change below., +        volatile ScheduledFuture<?> future;, +        private DeleteIndexListener(Semaphore mdLock, Listener listener) {, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +                    } catch (Throwable e) {, +                    } catch (Throwable e) {, +                } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +        Throwable lastFailure = null;, +            } catch (Throwable e) {, +                } catch (Throwable e) {, +                } catch (Throwable e) {, +++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        /*, +         * TODO: we execute this in parallel but it's a synced method. Yet, we might]