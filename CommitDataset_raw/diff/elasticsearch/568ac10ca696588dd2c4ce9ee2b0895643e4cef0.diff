[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/action/FindFileStructureAction.java, +import java.util.Arrays;, +import java.util.List;, +import java.util.Locale;, +        public static final ParseField CHARSET = FileStructure.CHARSET;, +        public static final ParseField FORMAT = FileStructure.FORMAT;, +        public static final ParseField COLUMN_NAMES = FileStructure.COLUMN_NAMES;, +        public static final ParseField HAS_HEADER_ROW = FileStructure.HAS_HEADER_ROW;, +        public static final ParseField DELIMITER = FileStructure.DELIMITER;, +        public static final ParseField QUOTE = FileStructure.QUOTE;, +        public static final ParseField SHOULD_TRIM_FIELDS = FileStructure.SHOULD_TRIM_FIELDS;, +        public static final ParseField GROK_PATTERN = FileStructure.GROK_PATTERN;, +        // This one is plural in FileStructure, but singular in FileStructureOverrides, +        public static final ParseField TIMESTAMP_FORMAT = new ParseField("timestamp_format");, +        public static final ParseField TIMESTAMP_FIELD = FileStructure.TIMESTAMP_FIELD;, +, +        private static final String ARG_INCOMPATIBLE_WITH_FORMAT_TEMPLATE =, +            "[%s] may only be specified if [" + FORMAT.getPreferredName() + "] is [%s]";, +        private String charset;, +        private FileStructure.Format format;, +        private List<String> columnNames;, +        private Boolean hasHeaderRow;, +        private Character delimiter;, +        private Character quote;, +        private Boolean shouldTrimFields;, +        private String grokPattern;, +        private String timestampFormat;, +        private String timestampField;, +        public String getCharset() {, +            return charset;, +        }, +, +        public void setCharset(String charset) {, +            this.charset = (charset == null || charset.isEmpty()) ? null : charset;, +        }, +, +        public FileStructure.Format getFormat() {, +            return format;, +        }, +, +        public void setFormat(FileStructure.Format format) {, +            this.format = format;, +        }, +, +        public void setFormat(String format) {, +            this.format = (format == null || format.isEmpty()) ? null : FileStructure.Format.fromString(format);, +        }, +, +        public List<String> getColumnNames() {, +            return columnNames;, +        }, +, +        public void setColumnNames(List<String> columnNames) {, +            this.columnNames = (columnNames == null || columnNames.isEmpty()) ? null : columnNames;, +        }, +, +        public void setColumnNames(String[] columnNames) {, +            this.columnNames = (columnNames == null || columnNames.length == 0) ? null : Arrays.asList(columnNames);, +        }, +, +        public Boolean getHasHeaderRow() {, +            return hasHeaderRow;, +        }, +, +        public void setHasHeaderRow(Boolean hasHeaderRow) {, +            this.hasHeaderRow = hasHeaderRow;, +        }, +, +        public Character getDelimiter() {, +            return delimiter;, +        }, +, +        public void setDelimiter(Character delimiter) {, +            this.delimiter = delimiter;, +        }, +, +        public void setDelimiter(String delimiter) {, +            if (delimiter == null || delimiter.isEmpty()) {, +                this.delimiter = null;, +            } else if (delimiter.length() == 1) {, +                this.delimiter = delimiter.charAt(0);, +            } else {, +                throw new IllegalArgumentException(DELIMITER.getPreferredName() + " must be a single character");, +            }, +        }, +, +        public Character getQuote() {, +            return quote;, +        }, +, +        public void setQuote(Character quote) {, +            this.quote = quote;, +        }, +, +        public void setQuote(String quote) {, +            if (quote == null || quote.isEmpty()) {, +                this.quote = null;, +            } else if (quote.length() == 1) {, +                this.quote = quote.charAt(0);, +            } else {]