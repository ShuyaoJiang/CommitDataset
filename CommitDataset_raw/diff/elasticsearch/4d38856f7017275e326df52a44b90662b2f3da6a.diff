[+++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +    private boolean detectNoop = false;, +     * Should this update attempt to detect if it is a noop?, +, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +    private boolean detectNoop = false;, +     * Should this update attempt to detect if it is a noop?, +, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +    private boolean detectNoop = false;, +     * Should this update attempt to detect if it is a noop?, +, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +, +import java.nio.file.Path;, +import java.util.Map;, +, +                // TODO: we should, instead, hold a "bytes reserved" of how large we anticipate this shard will be, e.g. for a shard, +                // that's being relocated/replicated we know how large it will become once it's done copying:, +, +                // Count up how many shards are currently on each data path:, +                Map<Path,Integer> dataPathToShardCount = new HashMap<>();, +                for(IndexShard shard : this) {, +                    Path dataPath = NodeEnvironment.shardStatePathToDataPath(shard.shardPath().getShardStatePath());, +                    Integer curCount = dataPathToShardCount.get(dataPath);, +                    if (curCount == null) {, +                        curCount = 0;, +                    }, +                    dataPathToShardCount.put(dataPath, curCount+1);, +                }, +                path = ShardPath.selectNewPathForShard(nodeEnv, shardId, indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(),, +                                                       dataPathToShardCount);, +            indicesLifecycle.beforeIndexShardCreated(shardId, indexSettings);, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +    private boolean detectNoop = false;, +     * Should this update attempt to detect if it is a noop?, +, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +, +import java.nio.file.Path;, +import java.util.Map;, +, +                // TODO: we should, instead, hold a "bytes reserved" of how large we anticipate this shard will be, e.g. for a shard, +                // that's being relocated/replicated we know how large it will become once it's done copying:, +, +                // Count up how many shards are currently on each data path:, +                Map<Path,Integer> dataPathToShardCount = new HashMap<>();, +                for(IndexShard shard : this) {, +                    Path dataPath = NodeEnvironment.shardStatePathToDataPath(shard.shardPath().getShardStatePath());, +                    Integer curCount = dataPathToShardCount.get(dataPath);, +                    if (curCount == null) {, +                        curCount = 0;, +                    }, +                    dataPathToShardCount.put(dataPath, curCount+1);, +                }, +                path = ShardPath.selectNewPathForShard(nodeEnv, shardId, indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(),, +                                                       dataPathToShardCount);, +            indicesLifecycle.beforeIndexShardCreated(shardId, indexSettings);, +++ b/core/src/main/java/org/elasticsearch/index/shard/ShardPath.java, +                                                  long avgShardSizeInBytes, Map<Path,Integer> dataPathToShardCount) throws IOException {, +            long totFreeSpace = 0;, +            for (NodeEnvironment.NodePath nodePath : env.nodePaths()) {, +                totFreeSpace += nodePath.fileStore.getUsableSpace();, +            }, +, +            // TODO: this is a hack!!  We should instead keep track of incoming (relocated) shards since we know, +            // how large they will be once they're done copying, instead of a silly guess for such cases:, +, +            // Very rough heurisic of how much disk space we expect the shard will use over its lifetime, the max of current average, +            // shard size across the cluster and 5% of the total available free space on this node:, +            long estShardSizeInBytes = Math.max(avgShardSizeInBytes, (long) (totFreeSpace/20.0));, +, +                Integer count = dataPathToShardCount.get(nodePath.path);, +                if (count != null) {, +                    usableBytes -= estShardSizeInBytes * count;, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +    private boolean detectNoop = false;, +     * Should this update attempt to detect if it is a noop?, +, +++ b/core/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +, +import java.nio.file.Path;, +import java.util.Map;, +, +                // TODO: we should, instead, hold a "bytes reserved" of how large we anticipate this shard will be, e.g. for a shard, +                // that's being relocated/replicated we know how large it will become once it's done copying:, +, +                // Count up how many shards are currently on each data path:, +                Map<Path,Integer> dataPathToShardCount = new HashMap<>();, +                for(IndexShard shard : this) {, +                    Path dataPath = NodeEnvironment.shardStatePathToDataPath(shard.shardPath().getShardStatePath());, +                    Integer curCount = dataPathToShardCount.get(dataPath);, +                    if (curCount == null) {, +                        curCount = 0;, +                    }, +                    dataPathToShardCount.put(dataPath, curCount+1);]