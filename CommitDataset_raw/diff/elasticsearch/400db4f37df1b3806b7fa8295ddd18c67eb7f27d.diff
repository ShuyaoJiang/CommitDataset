[+++ b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/jdbc/JdbcPreparedStatement.java, +import org.elasticsearch.xpack.sql.type.DataType;, +, +import java.sql.SQLDataException;, +import java.sql.Struct;, +import java.time.LocalDate;, +import java.time.LocalDateTime;, +import java.time.LocalTime;, +import java.time.OffsetDateTime;, +import java.time.OffsetTime;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +import java.util.Locale;, +        setObject(parameterIndex, x, Types.BOOLEAN);, +        setObject(parameterIndex, x, Types.TINYINT);, +        setObject(parameterIndex, x, Types.SMALLINT);, +        setObject(parameterIndex, x, Types.INTEGER);, +        setObject(parameterIndex, x, Types.BIGINT);, +        setObject(parameterIndex, x, Types.REAL);, +        setObject(parameterIndex, x, Types.DOUBLE);, +        setObject(parameterIndex, x, Types.BIGINT);, +        setObject(parameterIndex, x, Types.VARCHAR);, +        setObject(parameterIndex, x, Types.VARBINARY);, +        setObject(parameterIndex, x, Types.TIMESTAMP);, +        setObject(parameterIndex, x, Types.TIMESTAMP);, +        setObject(parameterIndex, x, Types.TIMESTAMP);, +        // the value of scaleOrLength parameter doesn't matter, as it's not used in the called method below, +        setObject(parameterIndex, x, targetSqlType, 0);, +        if (x == null) {, +            setParam(parameterIndex, null, Types.NULL);, +            return;, +        }, +        , +        // check also here the unsupported types so that any unsupported interfaces ({@code java.sql.Struct},, +        // {@code java.sql.Array} etc) will generate the correct exception message. Otherwise, the method call, +        // {@code TypeConverter.fromJavaToJDBC(x.getClass())} will report the implementing class as not being supported., +        checkKnownUnsupportedTypes(x);, +        setObject(parameterIndex, x, TypeConverter.fromJavaToJDBC(x.getClass()).getVendorTypeNumber(), 0);, +        setObject(parameterIndex, x);, +        setObject(parameterIndex, x);, +        setObject(parameterIndex, x);, +        setObject(parameterIndex, x);, +        if (cal == null) {, +            setObject(parameterIndex, x, Types.TIMESTAMP);, +            return;, +        }, +        if (x == null) {, +            setNull(parameterIndex, Types.TIMESTAMP);, +            return;, +        }, +        // converting to UTC since this is what ES is storing internally, +        setObject(parameterIndex, new Date(TypeConverter.convertFromCalendarToUTC(x.getTime(), cal)), Types.TIMESTAMP);, +        if (cal == null) {, +            setObject(parameterIndex, x, Types.TIMESTAMP);, +            return;, +        }, +        if (x == null) {, +            setNull(parameterIndex, Types.TIMESTAMP);, +            return;, +        }, +        // converting to UTC since this is what ES is storing internally, +        setObject(parameterIndex, new Time(TypeConverter.convertFromCalendarToUTC(x.getTime(), cal)), Types.TIMESTAMP);, +        if (cal == null) {, +            setObject(parameterIndex, x, Types.TIMESTAMP);, +            return;, +        }, +        if (x == null) {, +            setNull(parameterIndex, Types.TIMESTAMP);, +            return;, +        }, +        // converting to UTC since this is what ES is storing internally, +        setObject(parameterIndex, new Timestamp(TypeConverter.convertFromCalendarToUTC(x.getTime(), cal)), Types.TIMESTAMP);, +        setObject(parameterIndex, x);, +        setObject(parameterIndex, x);, +        setObject(parameterIndex, value);, +        setObject(parameterIndex, xmlObject);, +        checkOpen();, +        , +        JDBCType targetJDBCType;, +        try {, +            // this is also a way to check early for the validity of the desired sql type, +            targetJDBCType = JDBCType.valueOf(targetSqlType);, +        } catch (IllegalArgumentException e) {, +            throw new SQLDataException(e.getMessage());, +        }, +        , +        // set the null value on the type and exit, +        if (x == null) {, +            setParam(parameterIndex, null, targetSqlType);, +            return;, +        }, +        , +        checkKnownUnsupportedTypes(x);, +        if (x instanceof byte[]) {, +            if (targetJDBCType != JDBCType.VARBINARY) {, +                throw new SQLFeatureNotSupportedException(, +                        "Conversion from type byte[] to " + targetJDBCType + " not supported");, +            }, +            setParam(parameterIndex, x, Types.VARBINARY);]