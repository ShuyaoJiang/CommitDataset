[+++ b/elasticsearch/src/main/java/org/elasticsearch/license/License.java, +     *, +     * The id byte is used for ordering operation modes (used for merging license md in tribe node), +        MISSING((byte) 0),, +        TRIAL((byte) 1),, +        BASIC((byte) 2),, +        STANDARD((byte) 3),, +        GOLD((byte) 4),, +        PLATINUM((byte) 5);, +, +        private final byte id;, +, +        OperationMode(byte id) {, +            this.id = id;, +        }, +, +        /** Returns non-zero positive number when <code>opMode1</code> is greater than <code>opMode2</code> */, +        public static int compare(OperationMode opMode1, OperationMode opMode2) {, +            return Integer.compare(opMode1.id, opMode2.id);, +        }, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/License.java, +     *, +     * The id byte is used for ordering operation modes (used for merging license md in tribe node), +        MISSING((byte) 0),, +        TRIAL((byte) 1),, +        BASIC((byte) 2),, +        STANDARD((byte) 3),, +        GOLD((byte) 4),, +        PLATINUM((byte) 5);, +, +        private final byte id;, +, +        OperationMode(byte id) {, +            this.id = id;, +        }, +, +        /** Returns non-zero positive number when <code>opMode1</code> is greater than <code>opMode2</code> */, +        public static int compare(OperationMode opMode1, OperationMode opMode2) {, +            return Integer.compare(opMode1.id, opMode2.id);, +        }, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/LicensesMetaData.java, +import org.elasticsearch.license.License.OperationMode;, +import org.elasticsearch.tribe.TribeService;, +class LicensesMetaData extends AbstractDiffable<MetaData.Custom> implements MetaData.Custom,, +        TribeService.MergableCustomMetaData<LicensesMetaData> {, +    @Override, +    public LicensesMetaData merge(LicensesMetaData other) {, +        if (other.license == null) {, +            return this;, +        } else if (license == null, +                || OperationMode.compare(other.license.operationMode(), license.operationMode()) > 0) {, +            return other;, +        }, +        return this;, +    }, +, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/License.java, +     *, +     * The id byte is used for ordering operation modes (used for merging license md in tribe node), +        MISSING((byte) 0),, +        TRIAL((byte) 1),, +        BASIC((byte) 2),, +        STANDARD((byte) 3),, +        GOLD((byte) 4),, +        PLATINUM((byte) 5);, +, +        private final byte id;, +, +        OperationMode(byte id) {, +            this.id = id;, +        }, +, +        /** Returns non-zero positive number when <code>opMode1</code> is greater than <code>opMode2</code> */, +        public static int compare(OperationMode opMode1, OperationMode opMode2) {, +            return Integer.compare(opMode1.id, opMode2.id);, +        }, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/LicensesMetaData.java, +import org.elasticsearch.license.License.OperationMode;, +import org.elasticsearch.tribe.TribeService;, +class LicensesMetaData extends AbstractDiffable<MetaData.Custom> implements MetaData.Custom,, +        TribeService.MergableCustomMetaData<LicensesMetaData> {, +    @Override, +    public LicensesMetaData merge(LicensesMetaData other) {, +        if (other.license == null) {, +            return this;, +        } else if (license == null, +                || OperationMode.compare(other.license.operationMode(), license.operationMode()) > 0) {, +            return other;, +        }, +        return this;, +    }, +, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/Licensing.java, +        // we have to make sure we don't override the prototype, if we already, +        // registered. This causes class cast exceptions while casting license, +        // meta data on tribe node, as the registration happens for every tribe, +        // client nodes and the tribe node itself, +        if (MetaData.lookupPrototype(LicensesMetaData.TYPE) == null) {, +    }, +            return Collections.singletonList(new ActionHandler<>(GetLicenseAction.INSTANCE, TransportGetLicenseAction.class));]