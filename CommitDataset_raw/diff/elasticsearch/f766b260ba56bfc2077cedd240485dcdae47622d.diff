[+++ b/docs/reference/migration/migrate_2_0.asciidoc, +via the API.  For example, instead of adding a field `_parent` within a document,, +use the `parent` url parameter when indexing that document., +++ b/docs/reference/migration/migrate_2_0.asciidoc, +via the API.  For example, instead of adding a field `_parent` within a document,, +use the `parent` url parameter when indexing that document., +++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +via the API.  For example, instead of adding a field `_parent` within a document,, +use the `parent` url parameter when indexing that document., +++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +++ b/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java, +import org.elasticsearch.index.mapper.ParsedDocument;, +, +    public void testIncludeInObjectBackcompat() throws Exception {, +        String mapping = jsonBuilder().startObject().startObject("type").endObject().endObject().string();, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper docMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +        ParsedDocument doc = docMapper.parse("type", "1", XContentFactory.jsonBuilder(), +            .startObject().field("_all", "foo").endObject().bytes());, +, +        assertNull(doc.rootDoc().get("_all"));, +        AllField field = (AllField) doc.rootDoc().getField("_all");, +        // the backcompat behavior is actually ignoring directly specifying _all, +        assertFalse(field.getAllEntries().fields().iterator().hasNext());, +    }, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +via the API.  For example, instead of adding a field `_parent` within a document,, +use the `parent` url parameter when indexing that document., +++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +++ b/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java, +import org.elasticsearch.index.mapper.ParsedDocument;, +, +    public void testIncludeInObjectBackcompat() throws Exception {, +        String mapping = jsonBuilder().startObject().startObject("type").endObject().endObject().string();, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper docMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +        ParsedDocument doc = docMapper.parse("type", "1", XContentFactory.jsonBuilder(), +            .startObject().field("_all", "foo").endObject().bytes());, +, +        assertNull(doc.rootDoc().get("_all"));, +        AllField field = (AllField) doc.rootDoc().getField("_all");, +        // the backcompat behavior is actually ignoring directly specifying _all, +        assertFalse(field.getAllEntries().fields().iterator().hasNext());, +    }, +++ b/src/test/java/org/elasticsearch/index/mapper/id/IdMappingTests.java, +import org.elasticsearch.index.mapper.SourceToParse;, +import org.elasticsearch.index.mapper.Uid;, +, +    public void testIncludeInObjectBackcompat() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type").endObject().endObject().string();, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper docMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +, +        ParsedDocument doc = docMapper.parse(SourceToParse.source(XContentFactory.jsonBuilder(), +            .startObject(), +            .field("_id", "1"), +            .endObject(), +            .bytes()).type("type"));, +, +        // _id is not indexed so we need to check _uid, +        assertEquals(Uid.createUid("type", "1"), doc.rootDoc().get(UidFieldMapper.NAME));, +    }, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +via the API.  For example, instead of adding a field `_parent` within a document,, +use the `parent` url parameter when indexing that document., +++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +++ b/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java, +import org.elasticsearch.index.mapper.ParsedDocument;, +, +    public void testIncludeInObjectBackcompat() throws Exception {, +        String mapping = jsonBuilder().startObject().startObject("type").endObject().endObject().string();, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper docMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +        ParsedDocument doc = docMapper.parse("type", "1", XContentFactory.jsonBuilder(), +            .startObject().field("_all", "foo").endObject().bytes());, +, +        assertNull(doc.rootDoc().get("_all"));, +        AllField field = (AllField) doc.rootDoc().getField("_all");, +        // the backcompat behavior is actually ignoring directly specifying _all, +        assertFalse(field.getAllEntries().fields().iterator().hasNext());, +    }, +++ b/src/test/java/org/elasticsearch/index/mapper/id/IdMappingTests.java, +import org.elasticsearch.index.mapper.SourceToParse;, +import org.elasticsearch.index.mapper.Uid;, +, +    public void testIncludeInObjectBackcompat() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type").endObject().endObject().string();, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper docMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +, +        ParsedDocument doc = docMapper.parse(SourceToParse.source(XContentFactory.jsonBuilder(), +            .startObject(), +            .field("_id", "1"), +            .endObject(), +            .bytes()).type("type"));, +, +        // _id is not indexed so we need to check _uid, +        assertEquals(Uid.createUid("type", "1"), doc.rootDoc().get(UidFieldMapper.NAME));, +    }]