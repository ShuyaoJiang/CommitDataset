[+++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    // TODO: If Watcher was stopped via api and the master is changed then Watcher will start regardless of the previous, +    // stop command, so at some point this needs to be a cluster setting, +        start(clusterService.state(), true);, +    private synchronized void start(ClusterState state, boolean manual) {, +        WatcherState watcherState = watcherService.state();, +        if (watcherState != WatcherState.STOPPED) {, +            logger.debug("Not starting, because state [{}] while [{}] is expected", watcherState, WatcherState.STOPPED);, +        // If we start from a cluster state update we need to check if previously we stopped manually, +        // otherwise Watcher would start upon the next cluster state update while the user instructed Watcher to not run, +        if (!manual && manuallyStopped) {, +            logger.debug("Not starting, because watcher has been stopped manually, so watcher can't be started automatically");, +            return;, +        }, +, +            logger.debug("Not starting, because the cluster state isn't valid");, +                logger.debug("Start attempt [{}], based on cluster state version [{}]", attempts, state.getVersion());, +                watcherService.start(state);, +, +    @Override, +    public void clusterChanged(final ClusterChangedEvent event) {, +        if (!event.localNodeMaster()) {, +            // We're no longer the master so we need to stop the watcher., +            // Stopping the watcher may take a while since it will wait on the scheduler to complete shutdown,, +            // so we fork here so that we don't wait too long. Other events may need to be processed and, +            // other cluster state listeners may need to be executed as well for this event., +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                @Override, +                public void run() {, +                    stop(false);, +            });, +        } else {, +            if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +                // wait until the gateway has recovered from disk, otherwise we think may not have .watches and, +                // a .triggered_watches index, but they may not have been restored from the cluster state on disk, +                return;, +            }, +, +            final ClusterState state = event.state();, +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                @Override, +                public void run() {, +                    start(state, false);, +                }, +            });, +++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    // TODO: If Watcher was stopped via api and the master is changed then Watcher will start regardless of the previous, +    // stop command, so at some point this needs to be a cluster setting, +        start(clusterService.state(), true);, +    private synchronized void start(ClusterState state, boolean manual) {, +        WatcherState watcherState = watcherService.state();, +        if (watcherState != WatcherState.STOPPED) {, +            logger.debug("Not starting, because state [{}] while [{}] is expected", watcherState, WatcherState.STOPPED);, +        // If we start from a cluster state update we need to check if previously we stopped manually, +        // otherwise Watcher would start upon the next cluster state update while the user instructed Watcher to not run, +        if (!manual && manuallyStopped) {, +            logger.debug("Not starting, because watcher has been stopped manually, so watcher can't be started automatically");, +            return;, +        }, +, +            logger.debug("Not starting, because the cluster state isn't valid");, +                logger.debug("Start attempt [{}], based on cluster state version [{}]", attempts, state.getVersion());, +                watcherService.start(state);, +, +    @Override, +    public void clusterChanged(final ClusterChangedEvent event) {, +        if (!event.localNodeMaster()) {, +            // We're no longer the master so we need to stop the watcher., +            // Stopping the watcher may take a while since it will wait on the scheduler to complete shutdown,, +            // so we fork here so that we don't wait too long. Other events may need to be processed and, +            // other cluster state listeners may need to be executed as well for this event., +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                @Override, +                public void run() {, +                    stop(false);, +            });, +        } else {, +            if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +                // wait until the gateway has recovered from disk, otherwise we think may not have .watches and, +                // a .triggered_watches index, but they may not have been restored from the cluster state on disk, +                return;, +            }, +, +            final ClusterState state = event.state();, +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                @Override, +                public void run() {, +                    start(state, false);, +                }, +            });, +++ b/src/test/java/org/elasticsearch/watcher/WatcherLifeCycleServiceTests.java, +    private ClusterService clusterService;, +        clusterService = mock(ClusterService.class);, +        DiscoveryNodes.Builder nodes = new DiscoveryNodes.Builder().masterNodeId("id1").localNodeId("id1");, +        ClusterState clusterState = ClusterState.builder(new ClusterName("my-cluster")), +                .nodes(nodes).build();, +        when(clusterService.state()).thenReturn(clusterState);, +        when(watcherService.state()).thenReturn(WatcherState.STOPPED);, +        when(watcherService.validate(clusterState)).thenReturn(true);, +]