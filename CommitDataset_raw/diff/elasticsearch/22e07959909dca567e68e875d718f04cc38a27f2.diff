[+++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +import java.util.Arrays;, +    private volatile ClusterServiceTaskBatcher taskBatcher;, +        this.threadPoolExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME,, +            daemonThreadFactory(settings, UPDATE_THREAD_NAME), threadPool.getThreadContext(), threadPool.scheduler());, +        this.taskBatcher = new ClusterServiceTaskBatcher(logger, threadPoolExecutor);, +    class ClusterServiceTaskBatcher extends TaskBatcher {, +, +        ClusterServiceTaskBatcher(Logger logger, PrioritizedEsThreadPoolExecutor threadExecutor) {, +            super(logger, threadExecutor);, +        }, +, +        @Override, +        protected void onTimeout(List<? extends BatchedTask> tasks, TimeValue timeout) {, +            threadPool.generic().execute(, +                () -> tasks.forEach(, +                    task -> ((UpdateTask) task).listener.onFailure(task.source,, +                        new ProcessClusterEventTimeoutException(timeout, task.source))));, +        }, +, +        @Override, +        protected void run(Object batchingKey, List<? extends BatchedTask> tasks, String tasksSummary) {, +            ClusterStateTaskExecutor<Object> taskExecutor = (ClusterStateTaskExecutor<Object>) batchingKey;, +            List<UpdateTask> updateTasks = (List<UpdateTask>) tasks;, +            runTasks(new ClusterService.TaskInputs(taskExecutor, updateTasks, tasksSummary));, +        }, +, +        class UpdateTask extends BatchedTask {, +            final ClusterStateTaskListener listener;, +, +            UpdateTask(Priority priority, String source, Object task, ClusterStateTaskListener listener,, +                       ClusterStateTaskExecutor<?> executor) {, +                super(priority, source, executor, task);, +                this.listener = listener;, +            }, +, +            @Override, +            public String describeTasks(List<? extends BatchedTask> tasks) {, +                return ((ClusterStateTaskExecutor<Object>) batchingKey).describeTasks(, +                    tasks.stream().map(BatchedTask::getTask).collect(Collectors.toList()));, +            }, +        }, +    }, +, +, +            List<ClusterServiceTaskBatcher.UpdateTask> safeTasks = tasks.entrySet().stream(), +                .map(e -> taskBatcher.new UpdateTask(config.priority(), source, e.getKey(), safe(e.getValue(), logger), executor)), +                .collect(Collectors.toList());, +            taskBatcher.submitTasks(safeTasks, config.timeout());, +        return Arrays.stream(threadPoolExecutor.getPending()).map(pending -> {, +            assert pending.task instanceof SourcePrioritizedRunnable :, +                "thread pool executor should only use SourcePrioritizedRunnable instances but found: " + pending.task.getClass().getName();, +            SourcePrioritizedRunnable task = (SourcePrioritizedRunnable) pending.task;, +            return new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(task.source()),, +                task.getAgeInMillis(), pending.executing);, +        }).collect(Collectors.toList());, +        List<ClusterServiceTaskBatcher.UpdateTask> nonFailedTasks = new ArrayList<>();, +        for (ClusterServiceTaskBatcher.UpdateTask updateTask : taskInputs.updateTasks) {, +            List<Object> inputs = taskInputs.updateTasks.stream(), +                .map(ClusterServiceTaskBatcher.UpdateTask::getTask).collect(Collectors.toList());, +                .failures(taskInputs.updateTasks.stream().map(ClusterServiceTaskBatcher.UpdateTask::getTask)::iterator, e), +            for (ClusterServiceTaskBatcher.UpdateTask updateTask : taskInputs.updateTasks) {, +        public final List<ClusterServiceTaskBatcher.UpdateTask> updateTasks;, +        TaskInputs(ClusterStateTaskExecutor<Object> executor, List<ClusterServiceTaskBatcher.UpdateTask> updateTasks, String summary) {, +        public final List<ClusterServiceTaskBatcher.UpdateTask> nonFailedTasks;, +                           ClusterState newClusterState, List<ClusterServiceTaskBatcher.UpdateTask> nonFailedTasks,, +            for (ClusterServiceTaskBatcher.UpdateTask updateTask : taskInputs.updateTasks) {, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +import java.util.Arrays;, +    private volatile ClusterServiceTaskBatcher taskBatcher;, +        this.threadPoolExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME,, +            daemonThreadFactory(settings, UPDATE_THREAD_NAME), threadPool.getThreadContext(), threadPool.scheduler());, +        this.taskBatcher = new ClusterServiceTaskBatcher(logger, threadPoolExecutor);, +    class ClusterServiceTaskBatcher extends TaskBatcher {, +, +        ClusterServiceTaskBatcher(Logger logger, PrioritizedEsThreadPoolExecutor threadExecutor) {, +            super(logger, threadExecutor);, +        }, +, +        @Override, +        protected void onTimeout(List<? extends BatchedTask> tasks, TimeValue timeout) {, +            threadPool.generic().execute(, +                () -> tasks.forEach(, +                    task -> ((UpdateTask) task).listener.onFailure(task.source,, +                        new ProcessClusterEventTimeoutException(timeout, task.source))));, +        }, +, +        @Override, +        protected void run(Object batchingKey, List<? extends BatchedTask> tasks, String tasksSummary) {, +            ClusterStateTaskExecutor<Object> taskExecutor = (ClusterStateTaskExecutor<Object>) batchingKey;, +            List<UpdateTask> updateTasks = (List<UpdateTask>) tasks;, +            runTasks(new ClusterService.TaskInputs(taskExecutor, updateTasks, tasksSummary));, +        }, +, +        class UpdateTask extends BatchedTask {, +            final ClusterStateTaskListener listener;, +, +            UpdateTask(Priority priority, String source, Object task, ClusterStateTaskListener listener,, +                       ClusterStateTaskExecutor<?> executor) {, +                super(priority, source, executor, task);]