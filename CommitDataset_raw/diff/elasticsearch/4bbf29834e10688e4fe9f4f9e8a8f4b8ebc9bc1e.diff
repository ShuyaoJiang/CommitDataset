[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkDecoder.java, +package org.elasticsearch.common.compress.lzf;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * Decoder that handles decoding of sequence of encoded LZF chunks,, + * combining them into a single contiguous result byte array., + *, + * @author Tatu Saloranta (tatu@ning.com), + * @since 0.9, + */, +public abstract class ChunkDecoder {, +    protected final static byte BYTE_NULL = 0;, +    protected final static int HEADER_BYTES = 5;, +, +    public ChunkDecoder() {, +    }, +, +    /*, +    ///////////////////////////////////////////////////////////////////////, +    // Public API, +    ///////////////////////////////////////////////////////////////////////, +     */, +, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public final byte[] decode(final byte[] inputBuffer) throws IOException {, +        byte[] result = new byte[calculateUncompressedSize(inputBuffer, 0, inputBuffer.length)];, +        decode(inputBuffer, 0, inputBuffer.length, result);, +        return result;, +    }, +, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public final byte[] decode(final byte[] inputBuffer, int inputPtr, int inputLen) throws IOException {, +        byte[] result = new byte[calculateUncompressedSize(inputBuffer, inputPtr, inputLen)];, +        decode(inputBuffer, inputPtr, inputLen, result);, +        return result;, +    }, +, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public final int decode(final byte[] inputBuffer, final byte[] targetBuffer) throws IOException {, +        return decode(inputBuffer, 0, inputBuffer.length, targetBuffer);, +    }, +, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public int decode(final byte[] sourceBuffer, int inPtr, int inLength,, +                      final byte[] targetBuffer) throws IOException {, +        byte[] result = targetBuffer;, +        int outPtr = 0;, +        int blockNr = 0;, +, +        final int end = inPtr + inLength - 1; // -1 to offset possible end marker, +, +        while (inPtr < end) {, +            // let's do basic sanity checks; no point in skimping with these checks, +            if (sourceBuffer[inPtr] != LZFChunk.BYTE_Z || sourceBuffer[inPtr + 1] != LZFChunk.BYTE_V) {, +                throw new IOException("Corrupt input data, block #" + blockNr + " (at offset " + inPtr + "): did not start with 'ZV' signature bytes");, +            }, +            inPtr += 2;, +            int type = sourceBuffer[inPtr++];, +            int len = uint16(sourceBuffer, inPtr);, +            inPtr += 2;, +            if (type == LZFChunk.BLOCK_TYPE_NON_COMPRESSED) { // uncompressed, +                System.arraycopy(sourceBuffer, inPtr, result, outPtr, len);, +                outPtr += len;, +            } else { // compressed, +                int uncompLen = uint16(sourceBuffer, inPtr);, +                inPtr += 2;, +                decodeChunk(sourceBuffer, inPtr, result, outPtr, outPtr + uncompLen);, +                outPtr += uncompLen;, +            }, +            inPtr += len;, +            ++blockNr;, +        }, +        return outPtr;]