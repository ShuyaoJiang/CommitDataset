[+++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +                if (Arrays.asList(null, "no", "not_analyzed", "analyzed").contains(index) == false) {, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [no], [not_analyzed] or [analyzed]");, +                }, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [no], [not_analyzed] or [analyzed]");, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +                if (Arrays.asList(null, "no", "not_analyzed", "analyzed").contains(index) == false) {, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [no], [not_analyzed] or [analyzed]");, +                }, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [no], [not_analyzed] or [analyzed]");, +++ b/core/src/test/java/org/elasticsearch/index/mapper/core/StringMappingUpgradeTests.java, +    public void testIllegalIndexValue() throws IOException {, +        IndexService indexService = createIndex("test");, +        DocumentMapperParser parser = indexService.mapperService().documentMapperParser();, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("properties"), +                    .startObject("field"), +                        .field("type", "string"), +                        .field("index", false), +                    .endObject(), +                .endObject() .endObject().endObject().string();, +        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,, +                () -> parser.parse("type", new CompressedXContent(mapping)));, +        assertThat(e.getMessage(),, +                containsString("Can't parse [index] value [false] for field [field], expected [no], [not_analyzed] or [analyzed]"));, +    }, +]