[+++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, edges, 0);, +            int length = createEdges(i+1, true, this.holes.get(i), edges, offset);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, edges, 0);, +            int length = createEdges(i+1, true, this.holes.get(i), edges, offset);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +        if (p1.x == p2.x && p1.x != dateline) {, +        } else if (p1.x == p2.x && p1.x == dateline) {, +            return 1.0;, +            boolean orientation = points[offset + prev].x > points[offset + next].x;, +, +            // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness) , +            // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards, +            // thus no need to compute orientation at runtime (which fails on ambiguous polys anyway, +            final int rngIdx = (orientation) ? next : prev;, +            if ( ((orientation && component == 0) || (!orientation && component < 0)) &&, +                    points[offset+top].x - points[offset+rngIdx].x > DATELINE) {, +                transform(points);, +                orientation = !orientation;, +            }, +         * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range , +         * @param points, +         */, +        protected static void transform(Coordinate[] points) {, +            for (Coordinate c : points) {, +                if (c.x < 0) {, +                    c.x += 2*DATELINE;, +                }, +            }, +        }, +, +        /**, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, edges, 0);, +            int length = createEdges(i+1, true, this.holes.get(i), edges, offset);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +        if (p1.x == p2.x && p1.x != dateline) {, +        } else if (p1.x == p2.x && p1.x == dateline) {, +            return 1.0;, +            boolean orientation = points[offset + prev].x > points[offset + next].x;, +, +            // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness) , +            // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards, +            // thus no need to compute orientation at runtime (which fails on ambiguous polys anyway, +            final int rngIdx = (orientation) ? next : prev;, +            if ( ((orientation && component == 0) || (!orientation && component < 0)) &&, +                    points[offset+top].x - points[offset+rngIdx].x > DATELINE) {, +                transform(points);, +                orientation = !orientation;, +            }, +         * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range , +         * @param points, +         */, +        protected static void transform(Coordinate[] points) {, +            for (Coordinate c : points) {, +                if (c.x < 0) {, +                    c.x += 2*DATELINE;, +                }, +            }, +        }, +, +        /**, +++ b/src/test/java/org/elasticsearch/common/geo/GeoJSONShapeParserTests.java, +    public void testParse_polygonNoHolesOGCCompliance() throws IOException {, +        // test ccw poly (large poly intended to not cross dateline), +        String polygonGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "Polygon"), +                .startArray("coordinates"), +                .startArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .startArray().value(-177.0).value(-10.0).endArray(), +                .startArray().value(176.0).value(-15.0).endArray(), +                .startArray().value(172.0).value(0.0).endArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .endArray(), +                .endArray(), +                .endObject().string();, +, +        XContentParser parser = JsonXContent.jsonXContent.createParser(polygonGeoJson);, +        parser.nextToken();, +        Shape shape = ShapeBuilder.parse(parser).build();, +, +        // test cw poly (small poly expected to cross dateline), +        polygonGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "Polygon"), +                .startArray("coordinates"), +                .startArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .startArray().value(172.0).value(0.0).endArray(), +                .startArray().value(176.0).value(-15.0).endArray(), +                .startArray().value(-177.0).value(-10.0).endArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .endArray(), +                .endArray(), +                .endObject().string();, +, +        parser = JsonXContent.jsonXContent.createParser(polygonGeoJson);, +        parser.nextToken();, +        shape = ShapeBuilder.parse(parser).build();]