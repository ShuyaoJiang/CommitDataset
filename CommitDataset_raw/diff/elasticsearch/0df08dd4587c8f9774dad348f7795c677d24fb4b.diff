[+++ b/server/src/main/java/org/elasticsearch/Version.java, +import java.util.Objects;, +                // We need at least the major of the Lucene version to be correct., +                // Our best guess is to use the same Lucene version as the previous, +                // version in the list, assuming that it didn't change. This is at, +                // least correct for patch versions of known minors since we never, +                // update the Lucene dependency for patch versions., +                List<Version> versions = DeclaredVersionsHolder.DECLARED_VERSIONS;, +                Version tmp = new Version(id, org.apache.lucene.util.Version.LATEST);, +                int index = Collections.binarySearch(versions, tmp);, +                if (index < 0) {, +                    index = -2 - index;, +                } else {, +                    assert false : "Version [" + tmp + "] is declared but absent from the switch statement in Version#fromId";, +                }, +                final org.apache.lucene.util.Version luceneVersion;, +                if (index == -1) {, +                    // this version is older than any supported version, so we, +                    // assume it is the previous major to the oldest Lucene version, +                    // that we know about, +                    luceneVersion = org.apache.lucene.util.Version.fromBits(, +                            versions.get(0).luceneVersion.major - 1, 0, 0);, +                } else {, +                    luceneVersion = versions.get(index).luceneVersion;, +                }, +                return new Version(id, luceneVersion);, +        this.luceneVersion = Objects.requireNonNull(luceneVersion);, +++ b/server/src/main/java/org/elasticsearch/Version.java, +import java.util.Objects;, +                // We need at least the major of the Lucene version to be correct., +                // Our best guess is to use the same Lucene version as the previous, +                // version in the list, assuming that it didn't change. This is at, +                // least correct for patch versions of known minors since we never, +                // update the Lucene dependency for patch versions., +                List<Version> versions = DeclaredVersionsHolder.DECLARED_VERSIONS;, +                Version tmp = new Version(id, org.apache.lucene.util.Version.LATEST);, +                int index = Collections.binarySearch(versions, tmp);, +                if (index < 0) {, +                    index = -2 - index;, +                } else {, +                    assert false : "Version [" + tmp + "] is declared but absent from the switch statement in Version#fromId";, +                }, +                final org.apache.lucene.util.Version luceneVersion;, +                if (index == -1) {, +                    // this version is older than any supported version, so we, +                    // assume it is the previous major to the oldest Lucene version, +                    // that we know about, +                    luceneVersion = org.apache.lucene.util.Version.fromBits(, +                            versions.get(0).luceneVersion.major - 1, 0, 0);, +                } else {, +                    luceneVersion = versions.get(index).luceneVersion;, +                }, +                return new Version(id, luceneVersion);, +        this.luceneVersion = Objects.requireNonNull(luceneVersion);, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            .setOpenMode(IndexWriterConfig.OpenMode.CREATE), +            .setIndexCreatedVersionMajor(luceneIndexCreatedVersionMajor);, +                store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion);, +++ b/server/src/main/java/org/elasticsearch/Version.java, +import java.util.Objects;, +                // We need at least the major of the Lucene version to be correct., +                // Our best guess is to use the same Lucene version as the previous, +                // version in the list, assuming that it didn't change. This is at, +                // least correct for patch versions of known minors since we never, +                // update the Lucene dependency for patch versions., +                List<Version> versions = DeclaredVersionsHolder.DECLARED_VERSIONS;, +                Version tmp = new Version(id, org.apache.lucene.util.Version.LATEST);, +                int index = Collections.binarySearch(versions, tmp);, +                if (index < 0) {, +                    index = -2 - index;, +                } else {, +                    assert false : "Version [" + tmp + "] is declared but absent from the switch statement in Version#fromId";, +                }, +                final org.apache.lucene.util.Version luceneVersion;, +                if (index == -1) {, +                    // this version is older than any supported version, so we, +                    // assume it is the previous major to the oldest Lucene version, +                    // that we know about, +                    luceneVersion = org.apache.lucene.util.Version.fromBits(, +                            versions.get(0).luceneVersion.major - 1, 0, 0);, +                } else {, +                    luceneVersion = versions.get(index).luceneVersion;, +                }, +                return new Version(id, luceneVersion);, +        this.luceneVersion = Objects.requireNonNull(luceneVersion);, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            .setOpenMode(IndexWriterConfig.OpenMode.CREATE), +            .setIndexCreatedVersionMajor(luceneIndexCreatedVersionMajor);, +                store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion);, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +    public void createEmpty(Version luceneVersion) throws IOException {, +        try (IndexWriter writer = newEmptyIndexWriter(directory, luceneVersion)) {, +        try (IndexWriter writer = newAppendingIndexWriter(directory, null)) {, +        try (IndexWriter writer = newAppendingIndexWriter(directory, null)) {, +        try (IndexWriter writer = newAppendingIndexWriter(directory, null)) {, +                try (IndexWriter writer = newAppendingIndexWriter(directory, startingIndexCommit)) {, +    private static IndexWriter newAppendingIndexWriter(final Directory dir, final IndexCommit commit) throws IOException {, +        IndexWriterConfig iwc = newIndexWriterConfig(), +            .setIndexCommit(commit), +            .setOpenMode(IndexWriterConfig.OpenMode.APPEND);]