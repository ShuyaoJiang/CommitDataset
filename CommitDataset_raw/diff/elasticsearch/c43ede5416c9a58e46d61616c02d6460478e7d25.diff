[+++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        Engine engine = engineUnsafe();, +        if (engine == null) {, +            logger.debug("updateBufferSize: engine is closed; skipping");, +            return;, +        }, +, +, +, +        if (preValue.bytes() != shardIndexingBufferSize.bytes()) {, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +, +            // so we push changes these changes down to IndexWriter:, +            engine.onSettingsChanged();, +, +                engine().onSettingsChanged();, +                // TODO: why force a refresh here...?, +        final TranslogRecoveryPerformer translogRecoveryPerformer = new TranslogRecoveryPerformer(shardId, mapperService, queryParserService, indexAliasesService, indexCache) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        Engine engine = engineUnsafe();, +        if (engine == null) {, +            logger.debug("updateBufferSize: engine is closed; skipping");, +            return;, +        }, +, +, +, +        if (preValue.bytes() != shardIndexingBufferSize.bytes()) {, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +, +            // so we push changes these changes down to IndexWriter:, +            engine.onSettingsChanged();, +, +                engine().onSettingsChanged();, +                // TODO: why force a refresh here...?, +        final TranslogRecoveryPerformer translogRecoveryPerformer = new TranslogRecoveryPerformer(shardId, mapperService, queryParserService, indexAliasesService, indexCache) {, +++ b/core/src/main/java/org/elasticsearch/index/shard/TranslogRecoveryPerformer.java, +import org.elasticsearch.index.mapper.DocumentMapperForType;, +import org.elasticsearch.index.mapper.MapperException;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.index.mapper.MapperUtils;, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.Uid;, +    protected TranslogRecoveryPerformer(ShardId shardId, MapperService mapperService, IndexQueryParserService queryParserService, IndexAliasesService indexAliasesService, IndexCache indexCache) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        Engine engine = engineUnsafe();, +        if (engine == null) {, +            logger.debug("updateBufferSize: engine is closed; skipping");, +            return;, +        }, +, +, +, +        if (preValue.bytes() != shardIndexingBufferSize.bytes()) {, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +, +            // so we push changes these changes down to IndexWriter:, +            engine.onSettingsChanged();, +]