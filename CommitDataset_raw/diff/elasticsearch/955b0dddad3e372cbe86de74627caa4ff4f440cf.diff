[+++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/execution/WatchExecutionContext.java, +     * @return true if execution is allowed (this depends on the type of the watch context), +     */, +    public abstract boolean shouldBeExecuted();, +, +    /**, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/execution/WatchExecutionContext.java, +     * @return true if execution is allowed (this depends on the type of the watch context), +     */, +    public abstract boolean shouldBeExecuted();, +, +    /**, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                    if (ctx.shouldBeExecuted()) {, +                        logger.debug("not executing watch [{}]", watchId);, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/execution/WatchExecutionContext.java, +     * @return true if execution is allowed (this depends on the type of the watch context), +     */, +    public abstract boolean shouldBeExecuted();, +, +    /**, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                    if (ctx.shouldBeExecuted()) {, +                        logger.debug("not executing watch [{}]", watchId);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ManualExecutionContext.java, +    public boolean shouldBeExecuted() {, +        // we always want to execute a manually triggered watch as the user has triggered this via an, +        // external API call, +        return true;, +    }, +, +    @Override, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/execution/WatchExecutionContext.java, +     * @return true if execution is allowed (this depends on the type of the watch context), +     */, +    public abstract boolean shouldBeExecuted();, +, +    /**, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                    if (ctx.shouldBeExecuted()) {, +                        logger.debug("not executing watch [{}]", watchId);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ManualExecutionContext.java, +    public boolean shouldBeExecuted() {, +        // we always want to execute a manually triggered watch as the user has triggered this via an, +        // external API call, +        return true;, +    }, +, +    @Override, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/TriggeredExecutionContext.java, +    public boolean shouldBeExecuted() {, +        return watch().status().state().isActive();, +    }, +, +    @Override, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/execution/WatchExecutionContext.java, +     * @return true if execution is allowed (this depends on the type of the watch context), +     */, +    public abstract boolean shouldBeExecuted();, +, +    /**, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                    if (ctx.shouldBeExecuted()) {, +                        logger.debug("not executing watch [{}]", watchId);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ManualExecutionContext.java, +    public boolean shouldBeExecuted() {, +        // we always want to execute a manually triggered watch as the user has triggered this via an, +        // external API call, +        return true;, +    }, +, +    @Override, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/TriggeredExecutionContext.java, +    public boolean shouldBeExecuted() {, +        return watch().status().state().isActive();, +    }, +, +    @Override, +++ b/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/execution/ExecutionServiceTests.java, +    public void testManualWatchExecutionContextGetsAlwaysExecuted() throws Exception {, +        Watch watch = mock(Watch.class);, +        when(watch.id()).thenReturn("_id");, +, +        DateTime now = new DateTime(clock.millis());, +        ScheduleTriggerEvent event = new ScheduleTriggerEvent("_id", now, now);, +        ManualExecutionContext ctx = ManualExecutionContext.builder(watch, true,, +                new ManualTriggerEvent("foo", event), timeValueSeconds(5)).build();, +, +        when(watch.input()).thenReturn(input);, +        Condition.Result conditionResult = InternalAlwaysCondition.RESULT_INSTANCE;, +        ExecutableCondition condition = mock(ExecutableCondition.class);, +        when(condition.execute(any(WatchExecutionContext.class))).thenReturn(conditionResult);, +        when(watch.condition()).thenReturn(condition);, +, +        Action.Result actionResult = mock(Action.Result.class);, +        when(actionResult.type()).thenReturn("_action_type");, +        when(actionResult.status()).thenReturn(Action.Result.Status.SUCCESS);, +        ExecutableAction action = mock(ExecutableAction.class);, +        when(action.logger()).thenReturn(logger);, +        when(action.execute(eq("_action"), eq(ctx), eq(payload))).thenReturn(actionResult);]