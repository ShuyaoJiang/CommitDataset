[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +    @Inject public SoftFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().softKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +    @Inject public SoftFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().softKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    protected AbstractConcurrentMapFilterCache(Index index, @IndexSettings Settings indexSettings,, +        if (logger.isDebugEnabled()) {, +            if (cleaned > 0) {, +                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +            }, +        } else if (logger.isTraceEnabled()) {, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +    @Inject public SoftFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().softKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    protected AbstractConcurrentMapFilterCache(Index index, @IndexSettings Settings indexSettings,, +        if (logger.isDebugEnabled()) {, +            if (cleaned > 0) {, +                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +            }, +        } else if (logger.isTraceEnabled()) {, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/weak/WeakFilterCache.java, +    @Inject public WeakFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().weakKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +    @Inject public SoftFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().softKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    protected AbstractConcurrentMapFilterCache(Index index, @IndexSettings Settings indexSettings,, +        if (logger.isDebugEnabled()) {, +            if (cleaned > 0) {, +                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +            }, +        } else if (logger.isTraceEnabled()) {, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/weak/WeakFilterCache.java, +    @Inject public WeakFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().weakKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/IndicesMemoryCleaner.java, +import org.elasticsearch.util.inject.Inject;, +    public void cacheClearUnreferenced() {, +        for (IndexService indexService : indicesService) {, +            indexService.cache().clearUnreferenced();, +        }, +    }, +, +    public void cacheClear() {, +        for (IndexService indexService : indicesService) {, +            indexService.cache().clear();, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/soft/SoftFilterCache.java, +    @Inject public SoftFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().softKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractConcurrentMapFilterCache.java, +    protected AbstractConcurrentMapFilterCache(Index index, @IndexSettings Settings indexSettings,, +        if (logger.isDebugEnabled()) {, +            if (cleaned > 0) {, +                logger.debug("Cleaned [{}] out of estimated total [{}]", cleaned, totalCount);, +            }, +        } else if (logger.isTraceEnabled()) {, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/weak/WeakFilterCache.java, +    @Inject public WeakFilterCache(Index index, @IndexSettings Settings indexSettings) {, +        super(index, indexSettings, new MapMaker().weakKeys().<IndexReader, ConcurrentMap<Filter, DocIdSet>>makeMap());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/IndicesMemoryCleaner.java, +import org.elasticsearch.util.inject.Inject;, +    public void cacheClearUnreferenced() {, +        for (IndexService indexService : indicesService) {, +            indexService.cache().clearUnreferenced();, +        }, +    }, +, +    public void cacheClear() {, +        for (IndexService indexService : indicesService) {, +            indexService.cache().clear();, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/monitor/memory/alpha/AlphaMemoryMonitor.java, +import org.elasticsearch.util.*;, +    private final int clearCacheThreshold;, +    private AtomicLong totalClearCache = new AtomicLong();, +        this.clearCacheThreshold = componentSettings.getAsInt("clear_cache_threshold", 2);, +        private int clearCacheCounter;, +            // clear unreferenced in the cache, +            indicesMemoryCleaner.cacheClearUnreferenced();, +, +            // which means recovery it will take a long time (since the target re-index all this data), +                logger.debug("[" + totalClean + "] [Translog] " + translogCleanResult);, +                clearCacheCounter = 0;, +                sb.append('[').append(totalClean).append("] ");, +                sb.append("[Cleaning] memory_to_clean [").append(new SizeValue(memoryToClean)).append(']');, +                sb.append(", lower_memory_threshold [").append(new SizeValue(lowerThresholdMemory)).append(']');, +                sb.append(", upper_memory_threshold [").append(new SizeValue(upperThresholdMemory)).append(']');]