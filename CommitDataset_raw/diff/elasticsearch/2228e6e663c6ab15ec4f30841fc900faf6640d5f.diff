[+++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/BulkProcessorRetryIT.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.client;, +, +import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;, +import org.elasticsearch.action.bulk.BackoffPolicy;, +import org.elasticsearch.action.bulk.BulkItemResponse;, +import org.elasticsearch.action.bulk.BulkProcessor;, +import org.elasticsearch.action.bulk.BulkRequest;, +import org.elasticsearch.action.bulk.BulkResponse;, +import org.elasticsearch.action.get.MultiGetRequest;, +import org.elasticsearch.action.index.IndexRequest;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.rest.RestStatus;, +, +import java.util.Collections;, +import java.util.Iterator;, +import java.util.Map;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.lessThan;, +import static org.hamcrest.Matchers.lessThanOrEqualTo;, +, +public class BulkProcessorRetryIT extends ESRestHighLevelClientTestCase {, +, +    private static final String INDEX_NAME = "index";, +    private static final String TYPE_NAME = "type";, +, +    private static BulkProcessor.Builder initBulkProcessorBuilder(BulkProcessor.Listener listener) {, +        return BulkProcessor.builder(highLevelClient()::bulkAsync, listener);, +    }, +, +    public void testBulkRejectionLoadWithoutBackoff() throws Exception {, +        boolean rejectedExecutionExpected = true;, +        executeBulkRejectionLoad(BackoffPolicy.noBackoff(), rejectedExecutionExpected);, +    }, +, +    public void testBulkRejectionLoadWithBackoff() throws Throwable {, +        boolean rejectedExecutionExpected = false;, +        executeBulkRejectionLoad(BackoffPolicy.exponentialBackoff(), rejectedExecutionExpected);, +    }, +, +    private void executeBulkRejectionLoad(BackoffPolicy backoffPolicy, boolean rejectedExecutionExpected) throws Exception {, +        final CorrelatingBackoffPolicy internalPolicy = new CorrelatingBackoffPolicy(backoffPolicy);, +        final int numberOfAsyncOps = randomIntBetween(600, 700);, +        final CountDownLatch latch = new CountDownLatch(numberOfAsyncOps);, +        final Set<Object> responses = Collections.newSetFromMap(new ConcurrentHashMap<>());, +, +        BulkProcessor bulkProcessor = initBulkProcessorBuilder(new BulkProcessor.Listener() {, +            @Override, +            public void beforeBulk(long executionId, BulkRequest request) {, +            }, +, +            @Override, +            public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {, +                internalPolicy.logResponse(response);, +                responses.add(response);, +                latch.countDown();, +            }, +, +            @Override, +            public void afterBulk(long executionId, BulkRequest request, Throwable failure) {, +                responses.add(failure);, +                latch.countDown();, +            }, +        }).setBulkActions(1), +            .setConcurrentRequests(randomIntBetween(0, 100)), +            .setBackoffPolicy(internalPolicy), +            .build();, +, +        MultiGetRequest multiGetRequest = indexDocs(bulkProcessor, numberOfAsyncOps);, +        latch.await(10, TimeUnit.SECONDS);, +        bulkProcessor.close();, +, +        assertEquals(responses.size(), numberOfAsyncOps);, +, +        boolean rejectedAfterAllRetries = false;, +        for (Object response : responses) {]