[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +    public static class ReplicaResult {, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +    public static class ReplicaResult {, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseBackgroundSyncTask retentionLeaseBackgroundSyncTask;, +        this.retentionLeaseBackgroundSyncTask = new AsyncRetentionLeaseBackgroundSyncTask(this);, +                        globalCheckpointTask,, +                        retentionLeaseBackgroundSyncTask);, +                    retentionLeaseSyncer,, +        sync(is -> is.maybeSyncGlobalCheckpoint("background"), "global checkpoint");, +    }, +, +    private void backgroundSyncRetentionLeases() {, +        sync(IndexShard::backgroundSyncRetentionLeases, "retention lease");, +    }, +, +    private void sync(final Consumer<IndexShard> sync, final String source) {, +                                    () -> sync.accept(shard),, +                                                            "{} failed to execute background {} sync", shard.shardId(), source), e);, +                                    "background " + source + " sync");, +    // this setting is intentionally not registered, it is only used in tests, +    public static final Setting<TimeValue> RETENTION_LEASE_SYNC_INTERVAL_SETTING =, +            Setting.timeSetting(, +                    "index.soft_deletes.retention_lease.sync_interval",, +                    new TimeValue(5, TimeUnit.MINUTES),, +                    new TimeValue(0, TimeUnit.MILLISECONDS),, +                    Property.Dynamic,, +                    Property.IndexScope);, +, +    final class AsyncRetentionLeaseBackgroundSyncTask extends BaseAsyncTask {, +, +        AsyncRetentionLeaseBackgroundSyncTask(final IndexService indexService) {, +            super(indexService, RETENTION_LEASE_SYNC_INTERVAL_SETTING.get(indexService.getIndexSettings().getSettings()));, +        }, +, +        @Override, +        protected void runInternal() {, +            indexService.backgroundSyncRetentionLeases();, +        }, +, +        @Override, +        protected String getThreadPool() {, +            return ThreadPool.Names.MANAGEMENT;, +        }, +, +        @Override, +        public String toString() {, +            return "retention_lease_background_sync";, +        }, +, +    }, +, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +    public static class ReplicaResult {, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseBackgroundSyncTask retentionLeaseBackgroundSyncTask;, +        this.retentionLeaseBackgroundSyncTask = new AsyncRetentionLeaseBackgroundSyncTask(this);, +                        globalCheckpointTask,, +                        retentionLeaseBackgroundSyncTask);, +                    retentionLeaseSyncer,, +        sync(is -> is.maybeSyncGlobalCheckpoint("background"), "global checkpoint");, +    }, +, +    private void backgroundSyncRetentionLeases() {, +        sync(IndexShard::backgroundSyncRetentionLeases, "retention lease");, +    }, +, +    private void sync(final Consumer<IndexShard> sync, final String source) {, +                                    () -> sync.accept(shard),, +                                                            "{} failed to execute background {} sync", shard.shardId(), source), e);, +                                    "background " + source + " sync");, +    // this setting is intentionally not registered, it is only used in tests, +    public static final Setting<TimeValue> RETENTION_LEASE_SYNC_INTERVAL_SETTING =, +            Setting.timeSetting(, +                    "index.soft_deletes.retention_lease.sync_interval",, +                    new TimeValue(5, TimeUnit.MINUTES),, +                    new TimeValue(0, TimeUnit.MILLISECONDS),, +                    Property.Dynamic,, +                    Property.IndexScope);, +, +    final class AsyncRetentionLeaseBackgroundSyncTask extends BaseAsyncTask {, +, +        AsyncRetentionLeaseBackgroundSyncTask(final IndexService indexService) {, +            super(indexService, RETENTION_LEASE_SYNC_INTERVAL_SETTING.get(indexService.getIndexSettings().getSettings()));, +        }, +, +        @Override, +        protected void runInternal() {, +            indexService.backgroundSyncRetentionLeases();, +        }, +, +        @Override, +        protected String getThreadPool() {, +            return ThreadPool.Names.MANAGEMENT;, +        }, +, +        @Override, +        public String toString() {, +            return "retention_lease_background_sync";]