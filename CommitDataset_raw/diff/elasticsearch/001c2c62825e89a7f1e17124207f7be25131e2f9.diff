[+++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.function.BiConsumer;, +    @FunctionalInterface, +    interface Writer {, +        void write(XContentGenerator g, Object v) throws IOException;, +    }, +, +    private final static Map<Class<?>, Writer> MAP;, +, +    static {, +        Map<Class<?>, Writer> map = new HashMap<>();, +        map.put(String.class, (g, v) -> g.writeString((String) v));, +        map.put(Integer.class, (g, v) -> g.writeNumber((Integer) v));, +        map.put(Long.class, (g, v) -> g.writeNumber((Long) v));, +        map.put(Float.class, (g, v) -> g.writeNumber((Float) v));, +        map.put(Double.class, (g, v) -> g.writeNumber((Double) v));, +        map.put(Byte.class, (g, v) -> g.writeNumber((Byte) v));, +        map.put(Short.class, (g, v) -> g.writeNumber((Short) v));, +        map.put(Boolean.class, (g, v) -> g.writeBoolean((Boolean) v));, +        map.put(GeoPoint.class, (g, v) -> {, +            g.writeStartObject();, +            g.writeNumberField("lat", ((GeoPoint) v).lat());, +            g.writeNumberField("lon", ((GeoPoint) v).lon());, +            g.writeEndObject();, +        });, +        map.put(int[].class, (g, v) -> {, +            g.writeStartArray();, +            for (int item : (int[]) v) {, +                g.writeNumber(item);, +            }, +            g.writeEndArray();, +        });, +        map.put(long[].class, (g, v) -> {, +            g.writeStartArray();, +            for (long item : (long[]) v) {, +                g.writeNumber(item);, +            }, +            g.writeEndArray();, +        });, +        map.put(float[].class, (g, v) -> {, +            g.writeStartArray();, +            for (float item : (float[]) v) {, +                g.writeNumber(item);, +            }, +            g.writeEndArray();, +        });, +        map.put(double[].class, (g, v) -> {, +            g.writeStartArray();, +            for (double item : (double[])v) {, +                g.writeNumber(item);, +            }, +            g.writeEndArray();, +        });, +        map.put(byte[].class, (g, v) -> g.writeBinary((byte[]) v));, +        map.put(short[].class, (g, v) -> {, +            g.writeStartArray();, +            for (short item : (short[])v) {, +                g.writeNumber(item);, +            }, +            g.writeEndArray();, +        });, +        map.put(BytesRef.class, (g, v) -> {, +            BytesRef bytes = (BytesRef) v;, +            g.writeBinary(bytes.bytes, bytes.offset, bytes.length);, +        });, +        map.put(Text.class, (g, v) -> {, +            Text text = (Text) v;, +            if (text.hasBytes() && text.bytes().hasArray()) {, +                g.writeUTF8String(text.bytes().array(), text.bytes().arrayOffset(), text.bytes().length());, +            } else if (text.hasString()) {, +                g.writeString(text.string());, +            } else {, +                BytesArray bytesArray = text.bytes().toBytesArray();, +                g.writeUTF8String(bytesArray.array(), bytesArray.arrayOffset(), bytesArray.length());, +            }, +        });, +        MAP = Collections.unmodifiableMap(map);, +    }, +, +        Writer writer = MAP.get(type);, +        if (writer != null) {, +            writer.write(generator, value);, +            writeIterable((Iterable<?>) value);, +            writeObjectArray((Object[]) value);, +            writeBytesReference((BytesReference) value);, +, +    private void writeBytesReference(BytesReference value) throws IOException {, +        BytesReference bytes = value;, +        if (!bytes.hasArray()) {, +            bytes = bytes.toBytesArray();, +        }, +        generator.writeBinary(bytes.array(), bytes.arrayOffset(), bytes.length());, +    }, +, +    private void writeIterable(Iterable<?> value) throws IOException {, +        generator.writeStartArray();, +        for (Object v : value) {, +            writeValue(v);]