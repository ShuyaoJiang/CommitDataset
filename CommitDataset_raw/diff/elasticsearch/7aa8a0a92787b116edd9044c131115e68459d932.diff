[+++ b/docs/reference/ingest/ingest-node.asciidoc, +| `prefix`         | no        | `null`   | Prefix to be added to extracted keys, +| `trim_key`       | no        | `null`   | String of characters to trim from extracted keys, +| `trim_value`     | no        | `null`   | String of characters to trim from extracted values, +| `strip_brackets` | no        | `false`  | If `true` strip brackets `()`, `<>`, `[]` as well as quotes `'` and `"` from extracted values, +++ b/docs/reference/ingest/ingest-node.asciidoc, +| `prefix`         | no        | `null`   | Prefix to be added to extracted keys, +| `trim_key`       | no        | `null`   | String of characters to trim from extracted keys, +| `trim_value`     | no        | `null`   | String of characters to trim from extracted values, +| `strip_brackets` | no        | `false`  | If `true` strip brackets `()`, `<>`, `[]` as well as quotes `'` and `"` from extracted values, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/KeyValueProcessor.java, +import java.util.function.Consumer;, +import java.util.function.Function;, +import java.util.function.Predicate;, +import java.util.regex.Pattern;, +    private static final Pattern STRIP_BRACKETS = Pattern.compile("(^[\\(\\[<\"'])|([\\]\\)>\"']$)");, +, +    private final Consumer<IngestDocument> execution;, +                      Set<String> excludeKeys, String targetField, boolean ignoreMissing,, +                      String trimKey, String trimValue, boolean stripBrackets, String prefix) {, +        this.execution = buildExecution(, +            fieldSplit, valueSplit, field, includeKeys, excludeKeys, targetField, ignoreMissing, trimKey, trimValue,, +            stripBrackets, prefix, +        );, +    }, +, +    private static Consumer<IngestDocument> buildExecution(String fieldSplit, String valueSplit, String field,, +                                                           Set<String> includeKeys, Set<String> excludeKeys,, +                                                           String targetField, boolean ignoreMissing,, +                                                           String trimKey, String trimValue, boolean stripBrackets,, +                                                           String prefix) {, +        final Predicate<String> keyFilter;, +        if (includeKeys == null) {, +            if (excludeKeys == null) {, +                keyFilter = key -> true;, +            } else {, +                keyFilter = key -> excludeKeys.contains(key) == false;, +            }, +        } else {, +            if (excludeKeys == null) {, +                keyFilter = includeKeys::contains;, +            } else {, +                keyFilter = key -> includeKeys.contains(key) && excludeKeys.contains(key) == false;, +            }, +        }, +        final String fieldPathPrefix;, +        String keyPrefix = prefix == null ? "" : prefix;, +        if (targetField == null) {, +            fieldPathPrefix = keyPrefix;, +        } else {, +            fieldPathPrefix = targetField + "." + keyPrefix;, +        }, +        final Function<String, String> keyPrefixer;, +        if (fieldPathPrefix.isEmpty()) {, +            keyPrefixer = val -> val;, +        } else {, +            keyPrefixer = val -> fieldPathPrefix + val;, +        }, +        final Function<String, String[]> fieldSplitter = buildSplitter(fieldSplit, true);, +        Function<String, String[]> valueSplitter = buildSplitter(valueSplit, false);, +        final Function<String, String> keyTrimmer = buildTrimmer(trimKey);, +        final Function<String, String> bracketStrip;, +        if (stripBrackets) {, +            bracketStrip = val -> STRIP_BRACKETS.matcher(val).replaceAll("");, +        } else {, +            bracketStrip = val -> val;, +        }, +        final Function<String, String> valueTrimmer = buildTrimmer(trimValue);, +        return document -> {, +            String value = document.getFieldValue(field, String.class, ignoreMissing);, +            if (value == null) {, +                if (ignoreMissing) {, +                    return;, +                }, +                throw new IllegalArgumentException("field [" + field + "] is null, cannot extract key-value pairs.");, +            }, +            for (String part : fieldSplitter.apply(value)) {, +                String[] kv = valueSplitter.apply(part);, +                if (kv.length != 2) {, +                    throw new IllegalArgumentException("field [" + field + "] does not contain value_split [" + valueSplit + "]");, +                }, +                String key = keyTrimmer.apply(kv[0]);, +                if (keyFilter.test(key)) {, +                    append(document, keyPrefixer.apply(key), valueTrimmer.apply(bracketStrip.apply(kv[1])));, +                }, +            }, +        };, +    }, +, +    private static Function<String, String> buildTrimmer(String trim) {, +        if (trim == null) {, +            return val -> val;, +        } else {, +            Pattern pattern = Pattern.compile("(^([" + trim + "]+))|([" + trim + "]+$)");, +            return val -> pattern.matcher(val).replaceAll("");, +        }, +    }, +, +    private static Function<String, String[]> buildSplitter(String split, boolean fields) {, +        int limit = fields ? 0 : 2;]