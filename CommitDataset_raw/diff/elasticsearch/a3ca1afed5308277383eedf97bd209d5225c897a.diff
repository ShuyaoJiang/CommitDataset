[+++ b/src/main/java/org/elasticsearch/index/store/Store.java, +    class StoreDirectory extends Directory implements ForceSyncDirectory {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +    class StoreDirectory extends Directory implements ForceSyncDirectory {, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +package org.elasticsearch.index.translog.fs;, +, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.index.translog.Translog;, +import org.elasticsearch.index.translog.TranslogException;, +, +import java.io.IOException;, +import java.nio.ByteBuffer;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +, +/**, + */, +public class BufferingFsTranslogFile implements FsTranslogFile {, +, +    private final long id;, +    private final ShardId shardId;, +    private final RafReference raf;, +, +    private final ReadWriteLock rwl = new ReentrantReadWriteLock();, +, +    private volatile int operationCounter;, +, +    private long lastPosition;, +    private volatile long lastWrittenPosition;, +, +    private volatile long lastSyncPosition = 0;, +, +    private byte[] buffer;, +    private int bufferCount;, +, +    public BufferingFsTranslogFile(ShardId shardId, long id, RafReference raf, int bufferSize) throws IOException {, +        this.shardId = shardId;, +        this.id = id;, +        this.raf = raf;, +        this.buffer = new byte[bufferSize];, +        raf.raf().setLength(0);, +    }, +, +    public long id() {, +        return this.id;, +    }, +, +    public int estimatedNumberOfOperations() {, +        return operationCounter;, +    }, +, +    public long translogSizeInBytes() {, +        return lastWrittenPosition;, +    }, +, +    @Override, +    public Translog.Location add(byte[] data, int from, int size) throws IOException {, +        rwl.writeLock().lock();, +        try {, +            operationCounter++;, +            long position = lastPosition;, +            if (size >= buffer.length) {, +                flushBuffer();, +                raf.raf().write(data, from, size);, +                lastWrittenPosition += size;, +                lastPosition += size;, +                return new Translog.Location(id, position, size);, +            }, +            if (size > buffer.length - bufferCount) {, +                flushBuffer();, +            }, +            System.arraycopy(data, from, buffer, bufferCount, size);, +            bufferCount += size;, +            lastPosition += size;, +            return new Translog.Location(id, position, size);, +        } finally {, +            rwl.writeLock().unlock();, +        }, +    }, +, +    private void flushBuffer() throws IOException {, +        if (bufferCount > 0) {, +            raf.raf().write(buffer, 0, bufferCount);, +            lastWrittenPosition += bufferCount;, +            bufferCount = 0;, +        }, +    }, +, +    @Override, +    public byte[] read(Translog.Location location) throws IOException {, +        rwl.readLock().lock();, +        try {, +            if (location.translogLocation >= lastWrittenPosition) {, +                byte[] data = new byte[location.size];, +                System.arraycopy(buffer, (int) (location.translogLocation - lastWrittenPosition), data, 0, location.size);, +                return data;, +            }, +        } finally {, +            rwl.readLock().unlock();]