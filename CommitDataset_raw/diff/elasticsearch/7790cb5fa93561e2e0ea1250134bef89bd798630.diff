[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/BinaryComparison.java, +    /**, +     * Compares two expression arguments (typically Numbers), if possible., +     * Otherwise returns null (the arguments are not comparable or at least, +     * one of them is null)., +     */, +    public static Integer compare(Object l, Object r) {, +        // typical number comparison, +        if (l instanceof Number && r instanceof Number) {, +            return compare((Number) l, (Number) r);, +, +        if (l instanceof Comparable && r instanceof Comparable) {, +            try {, +                return Integer.valueOf(((Comparable) l).compareTo(r));, +            } catch (ClassCastException cce) {, +                // when types are not compatible, cce is thrown, +                // fall back to null, +, +        return null;, +    }, +, +    static Integer compare(Number l, Number r) {, +        if (l instanceof Double || r instanceof Double) {, +            return Double.compare(l.doubleValue(), r.doubleValue());, +        }, +        if (l instanceof Float || r instanceof Float) {, +            return Float.compare(l.floatValue(), r.floatValue());, +        }, +        if (l instanceof Long || r instanceof Long) {, +            return Long.compare(l.longValue(), r.longValue());, +        }, +, +        return Integer.valueOf(Integer.compare(l.intValue(), r.intValue()));, +    }, +}, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/BinaryComparison.java, +    /**, +     * Compares two expression arguments (typically Numbers), if possible., +     * Otherwise returns null (the arguments are not comparable or at least, +     * one of them is null)., +     */, +    public static Integer compare(Object l, Object r) {, +        // typical number comparison, +        if (l instanceof Number && r instanceof Number) {, +            return compare((Number) l, (Number) r);, +, +        if (l instanceof Comparable && r instanceof Comparable) {, +            try {, +                return Integer.valueOf(((Comparable) l).compareTo(r));, +            } catch (ClassCastException cce) {, +                // when types are not compatible, cce is thrown, +                // fall back to null, +, +        return null;, +    }, +, +    static Integer compare(Number l, Number r) {, +        if (l instanceof Double || r instanceof Double) {, +            return Double.compare(l.doubleValue(), r.doubleValue());, +        }, +        if (l instanceof Float || r instanceof Float) {, +            return Float.compare(l.floatValue(), r.floatValue());, +        }, +        if (l instanceof Long || r instanceof Long) {, +            return Long.compare(l.longValue(), r.longValue());, +        }, +, +        return Integer.valueOf(Integer.compare(l.intValue(), r.intValue()));, +    }, +}, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/Predicates.java, +import java.util.function.BiFunction;, +, +import static java.util.Collections.emptyList;, +import static java.util.Collections.singletonList;, +        return singletonList(exp);, +        return singletonList(exp);, +        return combine(exps, (l, r) -> new Or(l.location(), l, r));, +        return combine(exps, (l, r) -> new And(l.location(), l, r));, +    }, +, +    /**, +     * Build a binary 'pyramid' from the given list:, +     * <pre>, +     *       AND, +     *      /   \, +     *   AND     AND, +     *  /   \   /   \, +     * A     B C     D, +     * </pre>, +     * , +     * using the given combiner., +     * , +     * While a bit longer, this method creates a balanced tree as oppose to a plain, +     * recursive approach which creates an unbalanced one (either to the left or right)., +     */, +    private static Expression combine(List<Expression> exps, BiFunction<Expression, Expression, Expression> combiner) {, +        if (exps.isEmpty()) {, +            return null;, +        }]