[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +            if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +            if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +++ b/core/src/main/java/org/elasticsearch/index/query/HasChildQueryBuilder.java, +, +    /**, +     * The default value for ignore_unmapped., +     */, +    public static final boolean DEFAULT_IGNORE_UNMAPPED = false;, +    private static final ParseField IGNORE_UNMAPPED_FIELD = new ParseField("ignore_unmapped");, +    private boolean ignoreUnmapped = false;, +, +        ignoreUnmapped = in.readBoolean();, +        out.writeBoolean(ignoreUnmapped);, +    /**, +     * Sets whether the query builder should ignore unmapped types (and run a, +     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if, +     * the type is unmapped., +     */, +    public HasChildQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {, +        this.ignoreUnmapped = ignoreUnmapped;, +        return this;, +    }, +, +    /**, +     * Gets whether the query builder will ignore unmapped types (and run a, +     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if, +     * the type is unmapped., +     */, +    public boolean ignoreUnmapped() {, +        return ignoreUnmapped;, +    }, +, +        builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped);, +        boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED;, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, IGNORE_UNMAPPED_FIELD)) {, +                    ignoreUnmapped = parser.booleanValue();, +        hasChildQueryBuilder.ignoreUnmapped(ignoreUnmapped);, +            if (ignoreUnmapped) {, +                return new MatchNoDocsQuery();, +            } else {, +        }, +            throw new QueryShardException(context,, +                    "[" + NAME + "] Type [" + type + "] points to a non existent parent type [" + parentType + "]");, +                && Objects.equals(innerHitBuilder, that.innerHitBuilder) , +                && Objects.equals(ignoreUnmapped, that.ignoreUnmapped);, +        return Objects.hash(query, type, scoreMode, minChildren, maxChildren, innerHitBuilder, ignoreUnmapped);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +            if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +                if (clauses.isEmpty()) return null; // happens for stopwords, +++ b/core/src/main/java/org/elasticsearch/index/query/HasChildQueryBuilder.java, +, +    /**, +     * The default value for ignore_unmapped., +     */, +    public static final boolean DEFAULT_IGNORE_UNMAPPED = false;, +    private static final ParseField IGNORE_UNMAPPED_FIELD = new ParseField("ignore_unmapped");, +    private boolean ignoreUnmapped = false;, +, +        ignoreUnmapped = in.readBoolean();, +        out.writeBoolean(ignoreUnmapped);, +    /**, +     * Sets whether the query builder should ignore unmapped types (and run a, +     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if, +     * the type is unmapped., +     */, +    public HasChildQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {, +        this.ignoreUnmapped = ignoreUnmapped;, +        return this;, +    }, +, +    /**, +     * Gets whether the query builder will ignore unmapped types (and run a, +     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if, +     * the type is unmapped., +     */, +    public boolean ignoreUnmapped() {, +        return ignoreUnmapped;, +    }, +, +        builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped);, +        boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED;, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, IGNORE_UNMAPPED_FIELD)) {, +                    ignoreUnmapped = parser.booleanValue();, +        hasChildQueryBuilder.ignoreUnmapped(ignoreUnmapped);]