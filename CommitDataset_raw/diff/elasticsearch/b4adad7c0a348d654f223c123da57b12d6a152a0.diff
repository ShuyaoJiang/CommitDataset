[+++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.support.*;, +import org.elasticsearch.transport.*;, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +    private Response newResponse(, +                        nodeIds.put(nodeId, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.support.*;, +import org.elasticsearch.transport.*;, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +    private Response newResponse(, +                        nodeIds.put(nodeId, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size., +     * This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.support.*;, +import org.elasticsearch.transport.*;, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +    private Response newResponse(, +                        nodeIds.put(nodeId, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size., +     * This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            updateIndexWriterSettings();, +            updateIndexWriterSettings();, +, +, +, +, +, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.support.*;, +import org.elasticsearch.transport.*;, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +    private Response newResponse(, +                        nodeIds.put(nodeId, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size., +     * This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            updateIndexWriterSettings();, +            updateIndexWriterSettings();, +, +, +, +, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if (preValue.bytes() != shardIndexingBufferSize.bytes() && engineUnsafe() != null) {, +            // its inactive, make sure we do a refresh / full IW flush in this case, since the memory, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER && preValue != EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +        Engine engine = engineUnsafe();, +        if (engine != null) {, +    }, +        final TranslogRecoveryPerformer translogRecoveryPerformer = new TranslogRecoveryPerformer(shardId, mapperService, queryParserService,, +                indexAliasesService, indexCache, logger) {, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.support.*;, +import org.elasticsearch.transport.*;, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +    private Response newResponse(, +                        nodeIds.put(nodeId, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size., +     * This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            updateIndexWriterSettings();, +            updateIndexWriterSettings();, +, +, +, +, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if (preValue.bytes() != shardIndexingBufferSize.bytes() && engineUnsafe() != null) {, +            // its inactive, make sure we do a refresh / full IW flush in this case, since the memory, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER && preValue != EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +        Engine engine = engineUnsafe();, +        if (engine != null) {, +    }, +        final TranslogRecoveryPerformer translogRecoveryPerformer = new TranslogRecoveryPerformer(shardId, mapperService, queryParserService,, +                indexAliasesService, indexCache, logger) {, +++ b/core/src/main/java/org/elasticsearch/index/shard/TranslogRecoveryPerformer.java, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.index.mapper.*;, +    private final ESLogger logger;, +    protected TranslogRecoveryPerformer(ShardId shardId, MapperService mapperService, IndexQueryParserService queryParserService,, +                                        IndexAliasesService indexAliasesService, IndexCache indexCache, ESLogger logger) {, +        this.logger = logger;, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("[translog] recover [create] op of [{}][{}]", create.type(), create.id());, +                    }, +                    if (logger.isTraceEnabled()) {]