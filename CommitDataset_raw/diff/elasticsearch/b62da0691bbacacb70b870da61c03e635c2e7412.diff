[+++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        DeleteResponse deleteResponse = alertsStore.deleteAlert(name);, +        if (deleteResponse.isFound()) {, +            scheduler.remove(name);, +        return deleteResponse;, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        DeleteResponse deleteResponse = alertsStore.deleteAlert(name);, +        if (deleteResponse.isFound()) {, +            scheduler.remove(name);, +        return deleteResponse;, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.lucene.uid.Versions;, +            return new DeleteResponse(ALERT_INDEX, ALERT_TYPE, name, Versions.MATCH_ANY, false);, +                        searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen()); // TODO: make options configurable, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        DeleteResponse deleteResponse = alertsStore.deleteAlert(name);, +        if (deleteResponse.isFound()) {, +            scheduler.remove(name);, +        return deleteResponse;, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.lucene.uid.Versions;, +            return new DeleteResponse(ALERT_INDEX, ALERT_TYPE, name, Versions.MATCH_ANY, false);, +                        searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen()); // TODO: make options configurable, +++ b/src/main/java/org/elasticsearch/alerts/transport/actions/delete/DeleteAlertResponse.java, +            deleteResponse = new DeleteResponse();, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        DeleteResponse deleteResponse = alertsStore.deleteAlert(name);, +        if (deleteResponse.isFound()) {, +            scheduler.remove(name);, +        return deleteResponse;, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.lucene.uid.Versions;, +            return new DeleteResponse(ALERT_INDEX, ALERT_TYPE, name, Versions.MATCH_ANY, false);, +                        searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen()); // TODO: make options configurable, +++ b/src/main/java/org/elasticsearch/alerts/transport/actions/delete/DeleteAlertResponse.java, +            deleteResponse = new DeleteResponse();, +++ b/src/test/java/org/elasticsearch/alerts/AbstractAlertingTests.java, +    protected void assertNoAlertTrigger(final String alertName) throws Exception {, +        assertBusy(new Runnable() {, +            @Override, +            public void run() {, +                // The alerthistory index gets created in the background when the first alert fires, so we to check first is this index is created and shards are started, +                IndicesExistsResponse indicesExistsResponse = client().admin().indices().prepareExists(AlertActionManager.ALERT_HISTORY_INDEX).get();, +                assertThat(indicesExistsResponse.isExists(), is(true));, +                ClusterState state = client().admin().cluster().prepareState().get().getState();, +                IndexRoutingTable routingTable = state.getRoutingTable().index(AlertActionManager.ALERT_HISTORY_INDEX);, +                assertThat(routingTable, notNullValue());, +                assertThat(routingTable.allPrimaryShardsActive(), is(true));, +, +                SearchResponse searchResponse = client().prepareSearch(AlertActionManager.ALERT_HISTORY_INDEX), +                        .setIndicesOptions(IndicesOptions.lenientExpandOpen()), +                        .setQuery(boolQuery().must(matchQuery("alert_name", alertName)).must(matchQuery("state", AlertActionState.NO_ACTION_NEEDED.toString()))), +                        .setSize(1), +                        .get();, +                assertThat(searchResponse.getHits().getHits().length, equalTo(1));, +            }, +        });, +    }, +, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        DeleteResponse deleteResponse = alertsStore.deleteAlert(name);, +        if (deleteResponse.isFound()) {, +            scheduler.remove(name);, +        return deleteResponse;, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.lucene.uid.Versions;, +            return new DeleteResponse(ALERT_INDEX, ALERT_TYPE, name, Versions.MATCH_ANY, false);, +                        searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen()); // TODO: make options configurable, +++ b/src/main/java/org/elasticsearch/alerts/transport/actions/delete/DeleteAlertResponse.java, +            deleteResponse = new DeleteResponse();, +++ b/src/test/java/org/elasticsearch/alerts/AbstractAlertingTests.java, +    protected void assertNoAlertTrigger(final String alertName) throws Exception {, +        assertBusy(new Runnable() {, +            @Override, +            public void run() {, +                // The alerthistory index gets created in the background when the first alert fires, so we to check first is this index is created and shards are started, +                IndicesExistsResponse indicesExistsResponse = client().admin().indices().prepareExists(AlertActionManager.ALERT_HISTORY_INDEX).get();, +                assertThat(indicesExistsResponse.isExists(), is(true));, +                ClusterState state = client().admin().cluster().prepareState().get().getState();, +                IndexRoutingTable routingTable = state.getRoutingTable().index(AlertActionManager.ALERT_HISTORY_INDEX);, +                assertThat(routingTable, notNullValue());, +                assertThat(routingTable.allPrimaryShardsActive(), is(true));, +, +                SearchResponse searchResponse = client().prepareSearch(AlertActionManager.ALERT_HISTORY_INDEX), +                        .setIndicesOptions(IndicesOptions.lenientExpandOpen()), +                        .setQuery(boolQuery().must(matchQuery("alert_name", alertName)).must(matchQuery("state", AlertActionState.NO_ACTION_NEEDED.toString()))), +                        .setSize(1), +                        .get();, +                assertThat(searchResponse.getHits().getHits().length, equalTo(1));, +            }, +        });, +    }, +, +++ b/src/test/java/org/elasticsearch/alerts/BasicAlertingTest.java, +    public void testIndexAlert_registerAlertBeforeTargetIndex() throws Exception {, +        AlertsClientInterface alertsClient = alertClient();]