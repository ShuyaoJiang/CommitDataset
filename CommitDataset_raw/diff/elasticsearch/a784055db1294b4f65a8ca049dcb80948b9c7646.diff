[+++ b/core/src/test/java/org/elasticsearch/search/suggest/SuggestSearchIT.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.plugins.ScriptPlugin;, +import org.elasticsearch.script.CompiledScript;, +import org.elasticsearch.script.ExecutableScript;, +import org.elasticsearch.script.ScriptEngineService;, +import org.elasticsearch.script.SearchScript;, +import org.elasticsearch.search.lookup.SearchLookup;, +import java.util.Collection;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSuggestionPhraseCollateMatchExists;, +    @Override, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Collections.singleton(DummyTemplatePlugin.class);, +    }, +, +    public static class DummyTemplatePlugin extends Plugin implements ScriptPlugin {, +        @Override, +        public ScriptEngineService getScriptEngineService(Settings settings) {, +            return new DummyTemplateScriptEngine();, +        }, +    }, +, +    public static class DummyTemplateScriptEngine implements ScriptEngineService {, +, +        // The collate query setter is hard coded to use mustache, so lets lie in this test about the script plugin,, +        // which makes the collate code thinks mustache is evaluating the query., +        public static final String NAME = "mustache";, +, +        @Override, +        public void close() throws IOException {, +        }, +, +        @Override, +        public String getType() {, +            return NAME;, +        }, +, +        @Override, +        public String getExtension() {, +            return NAME;, +        }, +, +        @Override, +        public Object compile(String scriptName, String scriptSource, Map<String, String> params) {, +            return scriptSource;, +        }, +, +        @Override, +        public ExecutableScript executable(CompiledScript compiledScript, Map<String, Object> params) {, +            String script = (String) compiledScript.compiled();, +            for (Entry<String, Object> entry : params.entrySet()) {, +                script = script.replace("{{" + entry.getKey() + "}}", String.valueOf(entry.getValue()));, +            }, +            String result = script;, +            return new ExecutableScript() {, +                @Override, +                public void setNextVar(String name, Object value) {, +                    throw new UnsupportedOperationException("setNextVar not supported");, +                }, +, +                @Override, +                public Object run() {, +                    return new BytesArray(result);, +                }, +            };, +        }, +, +        @Override, +        public SearchScript search(CompiledScript compiledScript, SearchLookup lookup, Map<String, Object> vars) {, +            throw new UnsupportedOperationException("search script not supported");, +        }, +, +        @Override, +        public boolean isInlineScriptEnabled() {, +            return true;, +        }, +    }, +, +    public void testPhraseSuggesterCollate() throws InterruptedException, ExecutionException, IOException {, +        CreateIndexRequestBuilder builder = prepareCreate("test").setSettings(Settings.builder(), +                .put(indexSettings()), +                .put(SETTING_NUMBER_OF_SHARDS, 1) // A single shard will help to keep the tests repeatable., +                .put("index.analysis.analyzer.text.tokenizer", "standard"), +                .putArray("index.analysis.analyzer.text.filter", "lowercase", "my_shingle"), +                .put("index.analysis.filter.my_shingle.type", "shingle"), +                .put("index.analysis.filter.my_shingle.output_unigrams", true), +                .put("index.analysis.filter.my_shingle.min_shingle_size", 2), +                .put("index.analysis.filter.my_shingle.max_shingle_size", 3));, +, +        XContentBuilder mapping = XContentFactory.jsonBuilder(), +                .startObject(), +                .startObject("type1"), +                .startObject("properties"), +                .startObject("title"), +                .field("type", "text"), +                .field("analyzer", "text"), +                .endObject(), +                .endObject()]