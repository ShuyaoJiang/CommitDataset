[+++ b/client/rest/src/main/java/org/elasticsearch/client/ResponseException.java, +    /**, +     * Wrap a {@linkplain ResponseException} with another one with the current, +     * stack trace. This is used during synchronous calls so that the caller, +     * ends up in the stack trace of the exception thrown., +     */, +    ResponseException(ResponseException e) throws IOException {, +        super(e.getMessage(), e);, +        this.response = e.getResponse();, +    }, +, +++ b/client/rest/src/main/java/org/elasticsearch/client/ResponseException.java, +    /**, +     * Wrap a {@linkplain ResponseException} with another one with the current, +     * stack trace. This is used during synchronous calls so that the caller, +     * ends up in the stack trace of the exception thrown., +     */, +    ResponseException(ResponseException e) throws IOException {, +        super(e.getMessage(), e);, +        this.response = e.getResponse();, +    }, +, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +import org.apache.http.ConnectionClosedException;, +import org.apache.http.conn.ConnectTimeoutException;, +import java.net.SocketTimeoutException;, +     * This method works by performing an asynchronous call and waiting, +     * for the result. If the asynchronous call throws an exception we wrap, +     * it and rethrow it so that the stack trace attached to the exception, +     * contains the call site. While we attempt to preserve the original, +     * exception this isn't always possible and likely haven't covered all of, +     * the cases. You can get the original exception from, +     * {@link Exception#getCause()}., +     *, +        performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,, +            listener, headers);, +            performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,, +                responseListener, headers);, +        } catch (Exception e) {, +            responseListener.onFailure(e);, +        }, +    }, +, +    void performRequestAsyncNoCatch(String method, String endpoint, Map<String, String> params,, +                                    HttpEntity entity, HttpAsyncResponseConsumerFactory httpAsyncResponseConsumerFactory,, +                                    ResponseListener responseListener, Header... headers) {, +                /*, +                 * Wrap and rethrow whatever exception we received, copying the type, +                 * where possible so the synchronous API looks as much as possible, +                 * like the asynchronous API. We wrap the exception so that the caller's, +                 * signature shows up in any exception we throw., +                 */, +                if (exception instanceof ResponseException) {, +                    throw new ResponseException((ResponseException) exception);, +                }, +                if (exception instanceof ConnectTimeoutException) {, +                    ConnectTimeoutException e = new ConnectTimeoutException(exception.getMessage());, +                    e.initCause(exception);, +                    throw e;, +                }, +                if (exception instanceof SocketTimeoutException) {, +                    SocketTimeoutException e = new SocketTimeoutException(exception.getMessage());, +                    e.initCause(exception);, +                    throw e;, +                }, +                if (exception instanceof ConnectionClosedException) {, +                    ConnectionClosedException e = new ConnectionClosedException(exception.getMessage());, +                    e.initCause(exception);, +                    throw e;, +                }, +                    throw new IOException(exception.getMessage(), exception);, +                    throw new RuntimeException(exception.getMessage(), exception);, +++ b/client/rest/src/main/java/org/elasticsearch/client/ResponseException.java, +    /**, +     * Wrap a {@linkplain ResponseException} with another one with the current, +     * stack trace. This is used during synchronous calls so that the caller, +     * ends up in the stack trace of the exception thrown., +     */, +    ResponseException(ResponseException e) throws IOException {, +        super(e.getMessage(), e);, +        this.response = e.getResponse();, +    }, +, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +import org.apache.http.ConnectionClosedException;, +import org.apache.http.conn.ConnectTimeoutException;, +import java.net.SocketTimeoutException;, +     * This method works by performing an asynchronous call and waiting, +     * for the result. If the asynchronous call throws an exception we wrap, +     * it and rethrow it so that the stack trace attached to the exception, +     * contains the call site. While we attempt to preserve the original, +     * exception this isn't always possible and likely haven't covered all of, +     * the cases. You can get the original exception from, +     * {@link Exception#getCause()}., +     *, +        performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,, +            listener, headers);, +            performRequestAsyncNoCatch(method, endpoint, params, entity, httpAsyncResponseConsumerFactory,, +                responseListener, headers);, +        } catch (Exception e) {]