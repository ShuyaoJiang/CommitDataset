[+++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT,, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT,, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +import org.apache.logging.log4j.Logger;, +import java.util.Iterator;, +import java.util.Objects;, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +import java.util.stream.Collectors;, +    public static final Setting<TimeValue> DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT =, +        Setting.positiveTimeSetting("discovery.zen.ping.unicast.hosts.resolve_timeout", TimeValue.timeValueSeconds(5), Property.NodeScope);, +    private final List<String> configuredHosts;, +, +    private final int limitPortCounts;, +    // a list of temporal responses a node will return for a request (holds responses from other nodes), +    private final ExecutorService unicastZenPingExecutorService;, +, +    private final TimeValue resolveTimeout;, +        final List<String> hosts = DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING.get(settings);, +            configuredHosts = transportService.getLocalAddresses();, +            configuredHosts = hosts;, +        resolveTimeout = DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT.get(settings);, +        logger.debug(, +            "using initial hosts {}, with concurrent_connects [{}], resolve_timeout [{}]",, +            configuredHosts,, +            concurrentConnects,, +            resolveTimeout);, +        final ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(settings, "[unicast_connect]");, +        unicastZenPingExecutorService = EsExecutors.newScaling(, +            "unicast_connect",, +            0, concurrentConnects,, +            60,, +            TimeUnit.SECONDS,, +            threadFactory,, +            threadPool.getThreadContext());, +     * Resolves a list of hosts to a list of discovery nodes. Each host is resolved into a transport address (or a collection of addresses, +     * if the number of ports is greater than one) and the transport addresses are used to created discovery nodes. Host lookups are done, +     * in parallel using specified executor service up to the specified resolve timeout., +     * @param executorService  the executor service used to parallelize hostname lookups, +     * @param logger           logger used for logging messages regarding hostname lookups, +     * @param hosts            the hosts to resolve, +     * @param resolveTimeout   the timeout before returning from hostname lookups, +    public static List<DiscoveryNode> resolveDiscoveryNodes(, +        final ExecutorService executorService,, +        final Logger logger,, +        final List<String> hosts,, +        final int limitPortCounts,, +        final TransportService transportService,, +        final Supplier<String> idGenerator,, +        final TimeValue resolveTimeout) throws InterruptedException {, +        Objects.requireNonNull(executorService);, +        Objects.requireNonNull(logger);, +        Objects.requireNonNull(hosts);, +        Objects.requireNonNull(transportService);, +        Objects.requireNonNull(idGenerator);, +        Objects.requireNonNull(resolveTimeout);, +        if (resolveTimeout.nanos() < 0) {, +            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]");, +        }, +        // create tasks to submit to the executor service; we will wait up to resolveTimeout for these tasks to complete, +        final List<Callable<TransportAddress[]>> callables =, +            hosts, +                .stream(), +                .map(hn -> (Callable<TransportAddress[]>)() -> transportService.addressesFromString(hn, limitPortCounts)), +                .collect(Collectors.toList());, +        final List<Future<TransportAddress[]>> futures =, +            executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS);, +        final List<DiscoveryNode> discoveryNodes = new ArrayList<>();, +        // ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the, +        // hostname with the corresponding task by iterating together, +        final Iterator<String> it = hosts.iterator();, +        for (final Future<TransportAddress[]> future : futures) {, +            final String hostname = it.next();, +            if (!future.isCancelled()) {, +                assert future.isDone();, +                    final TransportAddress[] addresses = future.get();, +                    logger.trace("resolved host [{}] to {}", hostname, addresses);, +                    for (final TransportAddress address : addresses) {, +                        discoveryNodes.add(, +                            new DiscoveryNode(, +                                idGenerator.get(),, +                                address,, +                                emptyMap(),, +                                emptySet(),, +                } catch (final ExecutionException e) {, +                    assert e.getCause() != null;, +                    final String message = "failed to resolve host [" + hostname + "]";, +                    logger.warn(message, e.getCause());, +                }, +            } else {, +                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname);, +            }, +        ThreadPool.terminate(unicastZenPingExecutorService, 0, TimeUnit.SECONDS);, +    /**, +     * Sends three rounds of pings notifying the specified {@link PingListener} when pinging is complete. Pings are sent after resolving, +     * configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch, +     * of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}.]