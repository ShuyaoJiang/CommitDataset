[+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java, +                ch.pipeline().addLast("pipelining", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java, +                ch.pipeline().addLast("pipelining", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/pipelining/HttpPipeliningHandler.java, +import org.apache.logging.log4j.Logger;, +import java.nio.channels.ClosedChannelException;, +    private final Logger logger;, +     * @param logger for logging unexpected errors, +    public HttpPipeliningHandler(Logger logger, final int maxEventsHeld) {, +        this.logger = logger;, +    @Override, +    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, +        if (holdingQueue.isEmpty() == false) {, +            ClosedChannelException closedChannelException = new ClosedChannelException();, +            HttpPipelinedResponse pipelinedResponse;, +            while ((pipelinedResponse = holdingQueue.poll()) != null) {, +                try {, +                    pipelinedResponse.release();, +                    pipelinedResponse.promise().setFailure(closedChannelException);, +                } catch (Exception e) {, +                    logger.error("unexpected error while releasing pipelined http responses", e);, +                }, +            }, +        }, +        ctx.close(promise);, +    }, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java, +                ch.pipeline().addLast("pipelining", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/pipelining/HttpPipeliningHandler.java, +import org.apache.logging.log4j.Logger;, +import java.nio.channels.ClosedChannelException;, +    private final Logger logger;, +     * @param logger for logging unexpected errors, +    public HttpPipeliningHandler(Logger logger, final int maxEventsHeld) {, +        this.logger = logger;, +    @Override, +    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, +        if (holdingQueue.isEmpty() == false) {, +            ClosedChannelException closedChannelException = new ClosedChannelException();, +            HttpPipelinedResponse pipelinedResponse;, +            while ((pipelinedResponse = holdingQueue.poll()) != null) {, +                try {, +                    pipelinedResponse.release();, +                    pipelinedResponse.promise().setFailure(closedChannelException);, +                } catch (Exception e) {, +                    logger.error("unexpected error while releasing pipelined http responses", e);, +                }, +            }, +        }, +        ctx.close(promise);, +    }, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/pipelining/Netty4HttpPipeliningHandlerTests.java, +import java.nio.channels.ClosedChannelException;, +    private final ExecutorService executorService = Executors.newFixedThreadPool(randomIntBetween(4, 8));, +    private final Map<String, CountDownLatch> waitingRequests = new ConcurrentHashMap<>();, +    private final Map<String, CountDownLatch> finishingRequests = new ConcurrentHashMap<>();, +        final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new HttpPipeliningHandler(logger, numberOfRequests),, +            new WorkEmulatorHandler());, +        final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new HttpPipeliningHandler(logger, numberOfRequests),, +            new WorkEmulatorHandler());, +                new HttpPipeliningHandler(logger, numberOfRequests),, +        final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new HttpPipeliningHandler(logger, numberOfRequests),, +            new WorkEmulatorHandler());, +    public void testPipeliningRequestsAreReleased() throws InterruptedException {, +        final int numberOfRequests = 10;, +        final EmbeddedChannel embeddedChannel =, +            new EmbeddedChannel(new HttpPipeliningHandler(logger, numberOfRequests + 1));, +, +        for (int i = 0; i < numberOfRequests; i++) {, +            embeddedChannel.writeInbound(createHttpRequest("/" + i));, +        }, +, +        HttpPipelinedRequest inbound;, +        ArrayList<HttpPipelinedRequest> requests = new ArrayList<>();, +        while ((inbound = embeddedChannel.readInbound()) != null) {, +            requests.add(inbound);, +        }, +, +        ArrayList<ChannelPromise> promises = new ArrayList<>();, +        for (int i = 1; i < requests.size(); ++i) {, +            final DefaultFullHttpResponse httpResponse = new DefaultFullHttpResponse(HTTP_1_1, OK);, +            ChannelPromise promise = embeddedChannel.newPromise();, +            promises.add(promise);, +            HttpPipelinedResponse response = requests.get(i).createHttpResponse(httpResponse, promise);, +            embeddedChannel.writeAndFlush(response, promise);, +        }, +, +        for (ChannelPromise promise : promises) {, +            assertFalse(promise.isDone());, +        }, +        embeddedChannel.close().syncUninterruptibly();, +        for (ChannelPromise promise : promises) {, +            assertTrue(promise.isDone());, +            assertTrue(promise.cause() instanceof ClosedChannelException);, +        }, +    }, +]