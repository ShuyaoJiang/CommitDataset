[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                ClearScrollRequest clearScrollRequest = new ClearScrollRequest();, +                clearScrollRequest.addScrollId(response.getScrollId());, +                        if (results.size() > resp.getHits().getTotalHits()) {, +                            clearScroll.accept(lastResponse);, +                            listener.onFailure(new IllegalStateException("scrolling returned more hits [" + results.size(), +                                    + "] than expected [" + resp.getHits().getTotalHits() + "] so bailing out to prevent unbounded ", +                                    + "memory consumption."));, +                        } else {, +                            SearchScrollRequest scrollRequest = new SearchScrollRequest(resp.getScrollId());, +                            scrollRequest.scroll(request.scroll().keepAlive());, +                            client.searchScroll(scrollRequest, this);, +                        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                ClearScrollRequest clearScrollRequest = new ClearScrollRequest();, +                clearScrollRequest.addScrollId(response.getScrollId());, +                        if (results.size() > resp.getHits().getTotalHits()) {, +                            clearScroll.accept(lastResponse);, +                            listener.onFailure(new IllegalStateException("scrolling returned more hits [" + results.size(), +                                    + "] than expected [" + resp.getHits().getTotalHits() + "] so bailing out to prevent unbounded ", +                                    + "memory consumption."));, +                        } else {, +                            SearchScrollRequest scrollRequest = new SearchScrollRequest(resp.getScrollId());, +                            scrollRequest.scroll(request.scroll().keepAlive());, +                            client.searchScroll(scrollRequest, this);, +                        }, +++ b/plugin/src/test/java/org/elasticsearch/xpack/security/InternalClientIntegTests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.search.SearchHits;, +import org.elasticsearch.search.internal.InternalSearchResponse;, +import org.mockito.stubbing.Answer;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.function.Function;, +, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +, +, +    /**, +     * Tests that, +     * {@link InternalClient#fetchAllByEntity(Client, SearchRequest, org.elasticsearch.action.ActionListener, java.util.function.Function)}, +     * defends against scrolls broken in such a way that the remote Elasticsearch returns infinite results. While Elasticsearch, +     * <strong>shouldn't</strong> do this it has in the past and it is <strong>very</strong> when it does. It takes out the whole node. So, +     * this makes sure we defend against it properly., +     */, +    public void testFetchAllByEntityWithBrokenScroll() {, +        Client client = mock(Client.class);, +        SearchRequest request = new SearchRequest();, +, +        String scrollId = randomAlphaOfLength(5);, +        SearchHit[] hits = new SearchHit[] {new SearchHit(1)};, +        InternalSearchResponse internalResponse = new InternalSearchResponse(new SearchHits(hits, 1, 1), null, null, null, false, false, 1);, +        SearchResponse response = new SearchResponse(internalResponse, scrollId, 1, 1, 0, ShardSearchFailure.EMPTY_ARRAY);, +, +        Answer<?> returnResponse = invocation -> {, +            @SuppressWarnings("unchecked"), +            ActionListener<SearchResponse> listener = (ActionListener<SearchResponse>) invocation.getArguments()[1];, +            listener.onResponse(response);, +            return null;, +        };, +        doAnswer(returnResponse).when(client).search(eq(request), anyObject());, +        /* The line below simulates the evil cluster. A working cluster would return, +         * a response with 0 hits. Our simulated broken cluster returns the same, +         * response over and over again. */, +        doAnswer(returnResponse).when(client).searchScroll(anyObject(), anyObject());, +, +        AtomicReference<Exception> failure = new AtomicReference<>();, +        InternalClient.fetchAllByEntity(client, request, new ActionListener<Collection<SearchHit>>() {, +            @Override, +            public void onResponse(Collection<SearchHit> response) {, +                fail("This shouldn't succeed.");, +            }, +, +            @Override, +            public void onFailure(Exception e) {, +                failure.set(e);, +            }, +        }, Function.identity());, +, +        assertNotNull("onFailure wasn't called", failure.get());, +        assertEquals("scrolling returned more hits [2] than expected [1] so bailing out to prevent unbounded memory consumption.",, +                failure.get().getMessage());, +    }]