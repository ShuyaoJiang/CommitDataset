[+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job/DateHistogramGroupConfigSerializingTests.java, +    public void testValidateWeek() {, +        ActionRequestValidationException e = new ActionRequestValidationException();, +        Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>();, +, +        // Have to mock fieldcaps because the ctor's aren't public..., +        FieldCapabilities fieldCaps = mock(FieldCapabilities.class);, +        when(fieldCaps.isAggregatable()).thenReturn(true);, +        responseMap.put("my_field", Collections.singletonMap("date", fieldCaps));, +, +        DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1w"), null, null);, +        config.validateMappings(responseMap, e);, +        assertThat(e.validationErrors().size(), equalTo(0));, +    }, +, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job/DateHistogramGroupConfigSerializingTests.java, +    public void testValidateWeek() {, +        ActionRequestValidationException e = new ActionRequestValidationException();, +        Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>();, +, +        // Have to mock fieldcaps because the ctor's aren't public..., +        FieldCapabilities fieldCaps = mock(FieldCapabilities.class);, +        when(fieldCaps.isAggregatable()).thenReturn(true);, +        responseMap.put("my_field", Collections.singletonMap("date", fieldCaps));, +, +        DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1w"), null, null);, +        config.validateMappings(responseMap, e);, +        assertThat(e.validationErrors().size(), equalTo(0));, +    }, +, +++ b/x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/RollupJobIdentifierUtils.java, +import org.elasticsearch.common.rounding.DateTimeUnit;, +    static final Comparator<RollupJobCaps> COMPARATOR = RollupJobIdentifierUtils.getComparator();, +        DateTimeUnit requestUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(requestInterval.toString());, +        long requestOrder = requestUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        DateTimeUnit configUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(configInterval.toString());, +        long configOrder = configUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        // Both are fixed, good to convert to millis now, +            long thisTime = Long.MAX_VALUE;, +            long thatTime = Long.MAX_VALUE;, +                        thisTime = getMillisFixedOrCalendar((String) agg.get(RollupField.INTERVAL));, +                        thatTime = getMillisFixedOrCalendar((String) agg.get(RollupField.INTERVAL));, +            int timeCompare = Long.compare(thisTime, thatTime);, +, +    static long getMillisFixedOrCalendar(String value) {, +        DateHistogramInterval interval = new DateHistogramInterval(value);, +        if (isCalendarInterval(interval)) {, +            DateTimeUnit intervalUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(interval.toString());, +            return intervalUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        } else {, +            return TimeValue.parseTimeValue(value, "date_histo.comparator.interval").getMillis();, +        }, +    }, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/rollup/job/DateHistogramGroupConfigSerializingTests.java, +    public void testValidateWeek() {, +        ActionRequestValidationException e = new ActionRequestValidationException();, +        Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>();, +, +        // Have to mock fieldcaps because the ctor's aren't public..., +        FieldCapabilities fieldCaps = mock(FieldCapabilities.class);, +        when(fieldCaps.isAggregatable()).thenReturn(true);, +        responseMap.put("my_field", Collections.singletonMap("date", fieldCaps));, +, +        DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1w"), null, null);, +        config.validateMappings(responseMap, e);, +        assertThat(e.validationErrors().size(), equalTo(0));, +    }, +, +++ b/x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/RollupJobIdentifierUtils.java, +import org.elasticsearch.common.rounding.DateTimeUnit;, +    static final Comparator<RollupJobCaps> COMPARATOR = RollupJobIdentifierUtils.getComparator();, +        DateTimeUnit requestUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(requestInterval.toString());, +        long requestOrder = requestUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        DateTimeUnit configUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(configInterval.toString());, +        long configOrder = configUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        // Both are fixed, good to convert to millis now, +            long thisTime = Long.MAX_VALUE;, +            long thatTime = Long.MAX_VALUE;, +                        thisTime = getMillisFixedOrCalendar((String) agg.get(RollupField.INTERVAL));, +                        thatTime = getMillisFixedOrCalendar((String) agg.get(RollupField.INTERVAL));, +            int timeCompare = Long.compare(thisTime, thatTime);, +, +    static long getMillisFixedOrCalendar(String value) {, +        DateHistogramInterval interval = new DateHistogramInterval(value);, +        if (isCalendarInterval(interval)) {, +            DateTimeUnit intervalUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(interval.toString());, +            return intervalUnit.field(DateTimeZone.UTC).getDurationField().getUnitMillis();, +        } else {, +            return TimeValue.parseTimeValue(value, "date_histo.comparator.interval").getMillis();, +        }, +    }, +++ b/x-pack/plugin/rollup/src/test/java/org/elasticsearch/xpack/rollup/RollupJobIdentifierUtilTests.java, +import org.elasticsearch.xpack.core.rollup.RollupField;, +import java.util.ArrayList;, +import java.util.Map;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +    private static final List<String> UNITS = new ArrayList<>(DateHistogramAggregationBuilder.DATE_FIELD_UNITS.keySet());, +, +    public void testComparatorMixed() {, +        int numCaps = randomIntBetween(1, 10);]