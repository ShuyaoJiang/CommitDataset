[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +import org.elasticsearch.painless.lookup.PainlessConstructor;, +import java.lang.reflect.Constructor;, +import java.util.List;, +    /** delegate method type parameters */, +    public final List<Class<?>> delegateTypeParameters;, +    /** delegate method return type */, +    public final Class<?> delegateReturnType;, +    public static FunctionRef resolveFromLookup(, +            PainlessLookup painlessLookup, Class<?> expected, String type, String call, int numCaptures) {, +, +        if ("new".equals(call)) {, +            return new FunctionRef(expected, painlessLookup.getPainlessStructFromJavaClass(expected).functionalMethod,, +                    lookup(painlessLookup, expected, type), numCaptures);, +        } else {, +            return new FunctionRef(expected, painlessLookup.getPainlessStructFromJavaClass(expected).functionalMethod,, +    }, +, +    /**, +     * Creates a new FunctionRef (already resolved), +     * @param expected functional interface type to implement, +     * @param interfaceMethod functional interface method, +     * @param delegateConstructor implementation constructor, +     * @param numCaptures number of captured arguments, +     */, +    public FunctionRef(Class<?> expected, PainlessMethod interfaceMethod, PainlessConstructor delegateConstructor, int numCaptures) {, +        Constructor<?> javaConstructor = delegateConstructor.javaConstructor;, +        MethodType delegateMethodType = delegateConstructor.methodType;, +, +        interfaceMethodName = interfaceMethod.name;, +        factoryMethodType = MethodType.methodType(expected,, +                delegateMethodType.dropParameterTypes(numCaptures, delegateMethodType.parameterCount()));, +        interfaceMethodType = interfaceMethod.methodType.dropParameterTypes(0, 1);, +, +        delegateClassName = javaConstructor.getDeclaringClass().getName();, +        isDelegateInterface = false;, +        delegateInvokeType = H_NEWINVOKESPECIAL;, +        delegateMethodName = PainlessLookupUtility.CONSTRUCTOR_NAME;, +        this.delegateMethodType = delegateMethodType.dropParameterTypes(0, numCaptures);, +, +        this.interfaceMethod = interfaceMethod;, +        delegateTypeParameters = delegateConstructor.typeParameters;, +        delegateReturnType = void.class;, +, +        factoryDescriptor = factoryMethodType.toMethodDescriptorString();, +        interfaceType = Type.getMethodType(interfaceMethodType.toMethodDescriptorString());, +        delegateType = Type.getMethodType(this.delegateMethodType.toMethodDescriptorString());, +    }, +        if (Modifier.isStatic(delegateMethod.modifiers)) {, +        delegateTypeParameters = delegateMethod.arguments;, +        delegateReturnType = delegateMethod.rtn;, +        delegateTypeParameters = null;, +        delegateReturnType = null;, +     * Looks up {@code type} from the whitelist, and returns a matching constructor., +     */, +    private static PainlessConstructor lookup(PainlessLookup painlessLookup, Class<?> expected, String type) {, +        // check its really a functional interface, +        // for e.g. Comparable, +        PainlessMethod method = painlessLookup.getPainlessStructFromJavaClass(expected).functionalMethod;, +        if (method == null) {, +            throw new IllegalArgumentException("Cannot convert function reference [" + type + "::new] " +, +                    "to [" + PainlessLookupUtility.typeToCanonicalTypeName(expected) + "], not a functional interface");, +        }, +, +        // lookup requested constructor, +        PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(painlessLookup.getJavaClassFromPainlessType(type));, +        PainlessConstructor impl = struct.constructors.get(PainlessLookupUtility.buildPainlessConstructorKey(method.arguments.size()));, +, +        if (impl == null) {, +            throw new IllegalArgumentException("Unknown reference [" + type + "::new] matching [" + expected + "]");, +        }, +, +        return impl;, +    }, +, +    /**, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +import org.elasticsearch.painless.lookup.PainlessConstructor;, +import java.lang.reflect.Constructor;, +import java.util.List;, +    /** delegate method type parameters */, +    public final List<Class<?>> delegateTypeParameters;, +    /** delegate method return type */, +    public final Class<?> delegateReturnType;, +    public static FunctionRef resolveFromLookup(, +            PainlessLookup painlessLookup, Class<?> expected, String type, String call, int numCaptures) {, +, +        if ("new".equals(call)) {, +            return new FunctionRef(expected, painlessLookup.getPainlessStructFromJavaClass(expected).functionalMethod,, +                    lookup(painlessLookup, expected, type), numCaptures);, +        } else {, +            return new FunctionRef(expected, painlessLookup.getPainlessStructFromJavaClass(expected).functionalMethod,, +    }, +]