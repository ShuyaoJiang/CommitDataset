[+++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import org.elasticsearch.action.support.PlainActionFuture;, +        PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture();, +        Releasable pendingConnection = transport.openConnection(node, connectionProfile, future);, +        Transport.Connection connection;, +        try {, +            connection = future.actionGet();, +        } catch (IllegalStateException e) {, +            // If the future was interrupted we must cancel the pending connection to avoid channels leaking, +            if (e.getCause() instanceof InterruptedException) {, +                pendingConnection.close();, +            }, +            throw e;, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import org.elasticsearch.action.support.PlainActionFuture;, +        PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture();, +        Releasable pendingConnection = transport.openConnection(node, connectionProfile, future);, +        Transport.Connection connection;, +        try {, +            connection = future.actionGet();, +        } catch (IllegalStateException e) {, +            // If the future was interrupted we must cancel the pending connection to avoid channels leaking, +            if (e.getCause() instanceof InterruptedException) {, +                pendingConnection.close();, +            }, +            throw e;, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.lease.Releasable;, +    public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Transport.Connection> listener) {, +        Objects.requireNonNull(profile, "connection profile cannot be null");, +        ConnectionProfile finalProfile = maybeOverrideConnectionProfile(profile);, +            List<TcpChannel> pendingChannels = initiateConnection(node, finalProfile, listener);, +            return () -> CloseableChannel.closeChannels(pendingChannels, false);, +                                                ActionListener<Transport.Connection> listener) {, +        InetAddress[] hostAddresses;, +        private final ActionListener<Transport.Connection> listener;, +                                          ActionListener<Transport.Connection> listener) {, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import org.elasticsearch.action.support.PlainActionFuture;, +        PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture();, +        Releasable pendingConnection = transport.openConnection(node, connectionProfile, future);, +        Transport.Connection connection;, +        try {, +            connection = future.actionGet();, +        } catch (IllegalStateException e) {, +            // If the future was interrupted we must cancel the pending connection to avoid channels leaking, +            if (e.getCause() instanceof InterruptedException) {, +                pendingConnection.close();, +            }, +            throw e;, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.lease.Releasable;, +    public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Transport.Connection> listener) {, +        Objects.requireNonNull(profile, "connection profile cannot be null");, +        ConnectionProfile finalProfile = maybeOverrideConnectionProfile(profile);, +            List<TcpChannel> pendingChannels = initiateConnection(node, finalProfile, listener);, +            return () -> CloseableChannel.closeChannels(pendingChannels, false);, +                                                ActionListener<Transport.Connection> listener) {, +        InetAddress[] hostAddresses;, +        private final ActionListener<Transport.Connection> listener;, +                                          ActionListener<Transport.Connection> listener) {, +++ b/server/src/main/java/org/elasticsearch/transport/Transport.java, +import org.elasticsearch.common.lease.Releasable;, +     * Opens a new connection to the given node. When the connection is fully connected, the listener is, +     * called. A {@link Releasable} is returned representing the pending connection. If the caller of this, +     * method decides to move on before the listener is called with the completed connection, they should, +     * release the pending connection to prevent hanging connections., +    Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Transport.Connection> listener);, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import org.elasticsearch.action.support.PlainActionFuture;, +        PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture();, +        Releasable pendingConnection = transport.openConnection(node, connectionProfile, future);, +        Transport.Connection connection;, +        try {, +            connection = future.actionGet();, +        } catch (IllegalStateException e) {, +            // If the future was interrupted we must cancel the pending connection to avoid channels leaking, +            if (e.getCause() instanceof InterruptedException) {, +                pendingConnection.close();, +            }, +            throw e;, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.lease.Releasable;, +    public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Transport.Connection> listener) {, +        Objects.requireNonNull(profile, "connection profile cannot be null");, +        ConnectionProfile finalProfile = maybeOverrideConnectionProfile(profile);, +            List<TcpChannel> pendingChannels = initiateConnection(node, finalProfile, listener);, +            return () -> CloseableChannel.closeChannels(pendingChannels, false);, +                                                ActionListener<Transport.Connection> listener) {, +        InetAddress[] hostAddresses;, +        private final ActionListener<Transport.Connection> listener;, +                                          ActionListener<Transport.Connection> listener) {, +++ b/server/src/main/java/org/elasticsearch/transport/Transport.java, +import org.elasticsearch.common.lease.Releasable;, +     * Opens a new connection to the given node. When the connection is fully connected, the listener is, +     * called. A {@link Releasable} is returned representing the pending connection. If the caller of this]