[+++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import org.apache.lucene.util.UnicodeUtil;, +, +            // Need to check whether upper is not smaller than lower, otherwise NumericUtils.subtract(...) fails IAE, +            // If upper is really smaller than lower then we deal with like MatchNoDocsQuery. (verified and no extractions), +            if (new BytesRef(lowerPoint).compareTo(new BytesRef(upperPoint)) > 0) {, +                return new Result(true, Collections.emptySet());, +            }, +, +                if (extraction1SmallestRange == null) {, +                    return extractions2;, +                } else if (extraction2SmallestRange == null) {, +                    return extractions1;, +                }, +, +        BytesRef min = null;, +                if (min == null || qt.range.interval.compareTo(min) < 0) {, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import org.apache.lucene.util.UnicodeUtil;, +, +            // Need to check whether upper is not smaller than lower, otherwise NumericUtils.subtract(...) fails IAE, +            // If upper is really smaller than lower then we deal with like MatchNoDocsQuery. (verified and no extractions), +            if (new BytesRef(lowerPoint).compareTo(new BytesRef(upperPoint)) > 0) {, +                return new Result(true, Collections.emptySet());, +            }, +, +                if (extraction1SmallestRange == null) {, +                    return extractions2;, +                } else if (extraction2SmallestRange == null) {, +                    return extractions1;, +                }, +, +        BytesRef min = null;, +                if (min == null || qt.range.interval.compareTo(min) < 0) {, +++ b/modules/percolator/src/test/java/org/elasticsearch/percolator/QueryAnalyzerTests.java, +, +        queryTerms1 = terms(new int[]{});, +        queryTerms2 = terms(new int[]{});, +        result = selectBestExtraction(Collections.emptyMap(), queryTerms1, queryTerms2);, +        assertSame("In case query extractions are empty", queryTerms2, result);, +, +        queryTerms1 = terms(new int[]{1});, +        queryTerms2 = terms(new int[]{});, +        result = selectBestExtraction(Collections.emptyMap(), queryTerms1, queryTerms2);, +        assertSame("In case query a single extraction is empty", queryTerms1, result);, +, +        queryTerms1 = terms(new int[]{});, +        queryTerms2 = terms(new int[]{1});, +        result = selectBestExtraction(Collections.emptyMap(), queryTerms1, queryTerms2);, +        assertSame("In case query a single extraction is empty", queryTerms2, result);, +    public void testPointRangeQuery_lowerUpperReversed() {, +        Query query = IntPoint.newRangeQuery("_field", 20, 10);, +        Result result = analyze(query, Collections.emptyMap());, +        assertTrue(result.verified);, +        assertThat(result.extractions.size(), equalTo(0));, +    }, +]