[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.Lists;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.xcontent.XContentIndexQueryParser;, +import org.elasticsearch.index.service.IndexService;, +import org.elasticsearch.indices.IndicesService;, +import java.util.List;, +import java.util.Map;, +, +    private final IndicesService indicesService;, +, +    @Inject public MetaDataIndexAliasesService(Settings settings, ClusterService clusterService, IndicesService indicesService) {, +        this.indicesService = indicesService;, +                List<String> indicesToClose = Lists.newArrayList();, +                Map<String, IndexService> indices = Maps.newHashMap();, +                try {, +                            String filter = aliasAction.filter();, +                            if (Strings.hasLength(filter)) {, +                                // parse the filter, in order to validate it, +                                IndexService indexService = indices.get(indexMetaData.index());, +                                if (indexService == null) {, +                                    indexService = indicesService.indexService(indexMetaData.index());, +                                    if (indexService == null) {, +                                        // temporarily create the index so we have can parse the filter, +                                        indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());, +                                        indicesToClose.add(indexMetaData.index());, +                                    }, +                                    indices.put(indexMetaData.index(), indexService);, +                                }, +, +                                // now, parse the filter, +                                XContentIndexQueryParser indexQueryParser = (XContentIndexQueryParser) indexService.queryParserService().defaultIndexQueryParser();, +                                try {, +                                    XContentParser parser = XContentFactory.xContent(filter).createParser(filter);, +                                    try {, +                                        indexQueryParser.parseInnerFilter(parser);, +                                    } finally {, +                                        parser.close();, +                                    }, +                                } catch (Exception e) {, +                                    listener.onFailure(new ElasticSearchIllegalArgumentException("failed to parse filter for [" + aliasAction.alias() + "]", e));, +                                    return currentState;, +                                }, +                            }, +                            indexMetaDataBuilder.putAlias(AliasMetaData.newAliasMetaDataBuilder(aliasAction.alias()).filter(filter).build());, +                } finally {, +                    for (String index : indicesToClose) {, +                        indicesService.cleanIndex(index, "created for mapping processing");, +                    }, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.Lists;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.xcontent.XContentIndexQueryParser;, +import org.elasticsearch.index.service.IndexService;, +import org.elasticsearch.indices.IndicesService;, +import java.util.List;, +import java.util.Map;, +, +    private final IndicesService indicesService;, +, +    @Inject public MetaDataIndexAliasesService(Settings settings, ClusterService clusterService, IndicesService indicesService) {, +        this.indicesService = indicesService;, +                List<String> indicesToClose = Lists.newArrayList();, +                Map<String, IndexService> indices = Maps.newHashMap();, +                try {, +                            String filter = aliasAction.filter();, +                            if (Strings.hasLength(filter)) {, +                                // parse the filter, in order to validate it, +                                IndexService indexService = indices.get(indexMetaData.index());, +                                if (indexService == null) {, +                                    indexService = indicesService.indexService(indexMetaData.index());, +                                    if (indexService == null) {, +                                        // temporarily create the index so we have can parse the filter, +                                        indexService = indicesService.createIndex(indexMetaData.index(), indexMetaData.settings(), currentState.nodes().localNode().id());, +                                        indicesToClose.add(indexMetaData.index());, +                                    }, +                                    indices.put(indexMetaData.index(), indexService);, +                                }, +, +                                // now, parse the filter, +                                XContentIndexQueryParser indexQueryParser = (XContentIndexQueryParser) indexService.queryParserService().defaultIndexQueryParser();, +                                try {, +                                    XContentParser parser = XContentFactory.xContent(filter).createParser(filter);, +                                    try {, +                                        indexQueryParser.parseInnerFilter(parser);, +                                    } finally {, +                                        parser.close();, +                                    }, +                                } catch (Exception e) {, +                                    listener.onFailure(new ElasticSearchIllegalArgumentException("failed to parse filter for [" + aliasAction.alias() + "]", e));, +                                    return currentState;]