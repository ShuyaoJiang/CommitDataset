[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.support.TransportActions;, +    private static boolean isConflictException(final Exception e) {, +        return ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException;, +    }, +, +                        if (!TransportActions.isShardNotAvailableException(failure)) {, +                    if (!TransportActions.isShardNotAvailableException(e)) {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.support.TransportActions;, +    private static boolean isConflictException(final Exception e) {, +        return ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException;, +    }, +, +                        if (!TransportActions.isShardNotAvailableException(failure)) {, +                    if (!TransportActions.isShardNotAvailableException(e)) {, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +                if (TransportActions.isShardNotAvailableException(replicaException)) {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.support.TransportActions;, +    private static boolean isConflictException(final Exception e) {, +        return ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException;, +    }, +, +                        if (!TransportActions.isShardNotAvailableException(failure)) {, +                    if (!TransportActions.isShardNotAvailableException(e)) {, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +                if (TransportActions.isShardNotAvailableException(replicaException)) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (op.origin() == Operation.Origin.PRIMARY) {, +            } else {, +                /*, +                 * Version conflicts during recovery and on replicas are normal due to asynchronous execution; as such, we should return a, +                 * successful result., +                 */, +                result = onSuccess.get();, +            final Optional<IndexResult> resultOnVersionConflict =, +            if (resultOnVersionConflict.isPresent()) {, +                indexResult = resultOnVersionConflict.get();, +                /*, +                versionMap.putUnderLock(index.uid().bytes(), new VersionValue(updatedVersion));, +            }, +            if (!indexResult.hasFailure()) {, +            final Optional<DeleteResult> resultOnVersionConflict =, +            if (resultOnVersionConflict.isPresent()) {, +                deleteResult = resultOnVersionConflict.get();, +, +                versionMap.putUnderLock(delete.uid().bytes(),, +                    new DeleteVersionValue(updatedVersion, engineConfig.getThreadPool().estimatedTimeInMillis()));, +            }, +            if (!deleteResult.hasFailure()) {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.support.TransportActions;, +    private static boolean isConflictException(final Exception e) {, +        return ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException;, +    }, +, +                        if (!TransportActions.isShardNotAvailableException(failure)) {, +                    if (!TransportActions.isShardNotAvailableException(e)) {, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +                if (TransportActions.isShardNotAvailableException(replicaException)) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (op.origin() == Operation.Origin.PRIMARY) {, +            } else {, +                /*, +                 * Version conflicts during recovery and on replicas are normal due to asynchronous execution; as such, we should return a, +                 * successful result., +                 */, +                result = onSuccess.get();, +            final Optional<IndexResult> resultOnVersionConflict =, +            if (resultOnVersionConflict.isPresent()) {, +                indexResult = resultOnVersionConflict.get();, +                /*, +                versionMap.putUnderLock(index.uid().bytes(), new VersionValue(updatedVersion));, +            }, +            if (!indexResult.hasFailure()) {, +            final Optional<DeleteResult> resultOnVersionConflict =, +            if (resultOnVersionConflict.isPresent()) {, +                deleteResult = resultOnVersionConflict.get();, +, +                versionMap.putUnderLock(delete.uid().bytes(),, +                    new DeleteVersionValue(updatedVersion, engineConfig.getThreadPool().estimatedTimeInMillis()));, +            }, +            if (!deleteResult.hasFailure()) {, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +        final ParsedDocument doc = testParsedDocument("1", "1", "test", null, testDocument(), B_1, null);, +        final Engine.Index v1Index = new Engine.Index(newUid("1"), doc);, +        final Engine.IndexResult v1Result = engine.index(v1Index);, +        assertThat(v1Result.getVersion(), equalTo(1L));, +        final Engine.Index v2Index = new Engine.Index(newUid("1"), doc);, +        final Engine.IndexResult v2Result = engine.index(v2Index);, +        assertThat(v2Result.getVersion(), equalTo(2L));, +        final Engine.Index replicaV2Index = new Engine.Index(, +            newUid("1"),, +            doc,, +            v2Result.getSeqNo(),]