[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    final BytesReference buildHeader(long requestId, byte status, Version protocolVersion, int length) throws IOException {, +                if (TransportStatus.isHandshake(status)) {, +            if (TransportStatus.isHandshake(status)) {, +    protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException, InterruptedException {, +                // we have to protect us here since sendRequestToChannel won't barf if the channel is closed., +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    final BytesReference buildHeader(long requestId, byte status, Version protocolVersion, int length) throws IOException {, +                if (TransportStatus.isHandshake(status)) {, +            if (TransportStatus.isHandshake(status)) {, +    protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException, InterruptedException {, +                // we have to protect us here since sendRequestToChannel won't barf if the channel is closed., +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/SimpleNetty4TransportTests.java, +import io.netty.channel.Channel;, +import org.elasticsearch.common.unit.TimeValue;, +import java.io.IOException;, +            ClusterSettings clusterSettings, boolean doHandshake) {, +, +            @Override, +            protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException,, +                InterruptedException {, +                if (doHandshake) {, +                    return super.executeHandshake(node, channel, timeout);, +                } else {, +                    return version.minimumCompatibilityVersion();, +                }, +            }, +, +    protected MockTransportService build(Settings settings, Version version, ClusterSettings clusterSettings, boolean doHandshake) {, +        MockTransportService transportService = nettyFromThreadPool(settings, threadPool, version, clusterSettings, doHandshake);, +            MockTransportService transportService = nettyFromThreadPool(settings, threadPool, Version.CURRENT, clusterSettings, true);, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    final BytesReference buildHeader(long requestId, byte status, Version protocolVersion, int length) throws IOException {, +                if (TransportStatus.isHandshake(status)) {, +            if (TransportStatus.isHandshake(status)) {, +    protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException, InterruptedException {, +                // we have to protect us here since sendRequestToChannel won't barf if the channel is closed., +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/SimpleNetty4TransportTests.java, +import io.netty.channel.Channel;, +import org.elasticsearch.common.unit.TimeValue;, +import java.io.IOException;, +            ClusterSettings clusterSettings, boolean doHandshake) {, +, +            @Override, +            protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException,, +                InterruptedException {, +                if (doHandshake) {, +                    return super.executeHandshake(node, channel, timeout);, +                } else {, +                    return version.minimumCompatibilityVersion();, +                }, +            }, +, +    protected MockTransportService build(Settings settings, Version version, ClusterSettings clusterSettings, boolean doHandshake) {, +        MockTransportService transportService = nettyFromThreadPool(settings, threadPool, version, clusterSettings, doHandshake);, +            MockTransportService transportService = nettyFromThreadPool(settings, threadPool, Version.CURRENT, clusterSettings, true);, +++ b/test/framework/src/main/java/org/elasticsearch/transport/AbstractSimpleTransportTestCase.java, +import org.elasticsearch.common.io.stream.InputStreamStreamInput;, +import org.elasticsearch.common.io.stream.NamedWriteableRegistry;, +import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;, +import org.elasticsearch.common.network.NetworkService;, +import org.elasticsearch.common.util.BigArrays;, +import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.util.Collections;, +    protected abstract MockTransportService build(Settings settings, Version version, ClusterSettings clusterSettings, boolean doHandshake);, +                                              Settings settings, boolean acceptRequests, boolean doHandshake) {, +            clusterSettings, doHandshake);, +        return buildService(name, version, clusterSettings, Settings.EMPTY, true, true);, +            Settings.EMPTY, false, false)) {, +                Settings.EMPTY, true, false);, +            null, true);, +                Settings.EMPTY, true, false)) {, +        NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry(Collections.emptyList());, +, +        try (MockTcpTransport transport = new MockTcpTransport(Settings.EMPTY, threadPool, BigArrays.NON_RECYCLING_INSTANCE,, +            new NoneCircuitBreakerService(), namedWriteableRegistry,  new NetworkService(Settings.EMPTY, Collections.emptyList())){, +            @Override, +            protected String handleRequest(MockChannel mockChannel, String profileName, StreamInput stream, long requestId,, +                                           int messageLengthBytes, Version version, InetSocketAddress remoteAddress, byte status), +                throws IOException {, +                return super.handleRequest(mockChannel, profileName, stream, requestId, messageLengthBytes, version, remoteAddress,, +                    (byte)(status & ~(1<<3))); // we flip the isHanshake bit back and ackt like the handler is not found, +            }, +        }) {, +            transport.transportServiceAdapter(serviceA.new Adapter());, +            transport.start();, +                new DiscoveryNode("TS_TPC", "TS_TPC", transport.boundAddress().publishAddress(), emptyMap(), emptySet(), version0);, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    final BytesReference buildHeader(long requestId, byte status, Version protocolVersion, int length) throws IOException {, +                if (TransportStatus.isHandshake(status)) {, +            if (TransportStatus.isHandshake(status)) {, +    protected Version executeHandshake(DiscoveryNode node, Channel channel, TimeValue timeout) throws IOException, InterruptedException {, +                // we have to protect us here since sendRequestToChannel won't barf if the channel is closed., +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/SimpleNetty4TransportTests.java, +import io.netty.channel.Channel;, +import org.elasticsearch.common.unit.TimeValue;, +import java.io.IOException;, +            ClusterSettings clusterSettings, boolean doHandshake) {]