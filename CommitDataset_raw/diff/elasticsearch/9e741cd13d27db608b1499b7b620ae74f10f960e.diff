[+++ b/core/src/main/java/org/elasticsearch/search/SearchHit.java, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +    private static ObjectParser<Map<String, Object>, Void> MAP_PARSER = new ObjectParser<>("innerHitParser", true, HashMap::new);, +            String name = parser.currentName();, +            ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);, +            ensureFieldName(parser, parser.nextToken(), SearchHits.Fields.HITS);, +            innerHits.put(name, SearchHits.fromXContent(parser));, +                parser.skipChildren();, +        private static final ConstructingObjectParser<NestedIdentity, Void> PARSER = new ConstructingObjectParser<>("nested_identity", true,, +++ b/core/src/main/java/org/elasticsearch/search/SearchHit.java, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +    private static ObjectParser<Map<String, Object>, Void> MAP_PARSER = new ObjectParser<>("innerHitParser", true, HashMap::new);, +            String name = parser.currentName();, +            ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);, +            ensureFieldName(parser, parser.nextToken(), SearchHits.Fields.HITS);, +            innerHits.put(name, SearchHits.fromXContent(parser));, +                parser.skipChildren();, +        private static final ConstructingObjectParser<NestedIdentity, Void> PARSER = new ConstructingObjectParser<>("nested_identity", true,, +++ b/core/src/main/java/org/elasticsearch/search/SearchHits.java, +                if (Fields.HITS.equals(currentFieldName)) {, +                } else {, +                    parser.skipChildren();, +                }, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                parser.skipChildren();, +++ b/core/src/main/java/org/elasticsearch/search/SearchHit.java, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +    private static ObjectParser<Map<String, Object>, Void> MAP_PARSER = new ObjectParser<>("innerHitParser", true, HashMap::new);, +            String name = parser.currentName();, +            ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);, +            ensureFieldName(parser, parser.nextToken(), SearchHits.Fields.HITS);, +            innerHits.put(name, SearchHits.fromXContent(parser));, +                parser.skipChildren();, +        private static final ConstructingObjectParser<NestedIdentity, Void> PARSER = new ConstructingObjectParser<>("nested_identity", true,, +++ b/core/src/main/java/org/elasticsearch/search/SearchHits.java, +                if (Fields.HITS.equals(currentFieldName)) {, +                } else {, +                    parser.skipChildren();, +                }, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                parser.skipChildren();, +++ b/core/src/test/java/org/elasticsearch/action/main/MainResponseTests.java, +import static org.elasticsearch.test.XContentTestUtils.insertRandomFields;, +        // we add a few random fields to check that parser is lenient on new fields, +        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, null, random());, +        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {, +++ b/core/src/main/java/org/elasticsearch/search/SearchHit.java, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +    private static ObjectParser<Map<String, Object>, Void> MAP_PARSER = new ObjectParser<>("innerHitParser", true, HashMap::new);, +            String name = parser.currentName();, +            ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);, +            ensureFieldName(parser, parser.nextToken(), SearchHits.Fields.HITS);, +            innerHits.put(name, SearchHits.fromXContent(parser));, +                parser.skipChildren();, +        private static final ConstructingObjectParser<NestedIdentity, Void> PARSER = new ConstructingObjectParser<>("nested_identity", true,, +++ b/core/src/main/java/org/elasticsearch/search/SearchHits.java, +                if (Fields.HITS.equals(currentFieldName)) {, +                } else {, +                    parser.skipChildren();, +                }, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                parser.skipChildren();, +++ b/core/src/test/java/org/elasticsearch/action/main/MainResponseTests.java, +import static org.elasticsearch.test.XContentTestUtils.insertRandomFields;, +        // we add a few random fields to check that parser is lenient on new fields, +        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, null, random());, +        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {, +++ b/core/src/test/java/org/elasticsearch/search/SearchHitTests.java, +import java.util.function.Predicate;, +import static org.elasticsearch.test.XContentTestUtils.insertRandomFields;, +     * This test adds randomized fields on all json objects and checks that we can parse it to, +     * ensure the parsing is lenient for forward compatibility., +     * We need to exclude json objects with the "highlight" and "fields" field name since these, +     * objects allow arbitrary keys (the field names that are queries). Also we want to exclude, +     * to add anything under "_source" since it is not parsed, and avoid complexity by excluding, +     * everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,, +     * which are already tested elsewhere., +     */, +    public void testFromXContentLenientParsing() throws IOException {, +        SearchHit searchHit = createTestItem(true);, +        XContentType xContentType = randomFrom(XContentType.values());, +        BytesReference originalBytes = toXContent(searchHit, xContentType, true);, +        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source"), +                || path.contains("inner_hits"));, +        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random());, +, +        SearchHit parsed;, +        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {, +            parser.nextToken(); // jump to first START_OBJECT, +            parsed = SearchHit.fromXContent(parser);, +            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken());, +            assertNull(parser.nextToken());, +        }, +        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType);, +    }, +]