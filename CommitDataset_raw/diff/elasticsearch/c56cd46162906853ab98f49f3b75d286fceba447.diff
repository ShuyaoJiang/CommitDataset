[+++ b/.gitignore, +# gradle wrapper , +gradle/, +gradlew, +gradlew.bat, +, +++ b/.gitignore, +# gradle wrapper , +gradle/, +gradlew, +gradlew.bat, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]plugins[/\\]RemovePluginCommand.java" checks="LineLength" />, +++ b/.gitignore, +# gradle wrapper , +gradle/, +gradlew, +gradlew.bat, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]plugins[/\\]RemovePluginCommand.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.index.shard.ShardNotFoundException;, +import org.elasticsearch.tasks.TaskId;, +import org.elasticsearch.transport.TransportRequest;, +import java.util.Objects;, +        transportService.registerRequestHandler(transportPrimaryAction, () -> new ConcreteShardRequest<>(request), executor,, +            new PrimaryOperationTransportHandler());, +        transportService.registerRequestHandler(transportReplicaAction,, +            () -> new ConcreteShardRequest<>(replicaRequest),, +            executor, true, true,, +     * {@link #acquireReplicaOperationLock(ShardId, long, String, ActionListener)}., +    class PrimaryOperationTransportHandler implements TransportRequestHandler<ConcreteShardRequest<Request>> {, +        public void messageReceived(final ConcreteShardRequest<Request> request, final TransportChannel channel) throws Exception {, +        public void messageReceived(ConcreteShardRequest<Request> request, TransportChannel channel, Task task) {, +            new AsyncPrimaryAction(request.request, request.targetAllocationID, channel, (ReplicationTask) task).run();, +        /** targetAllocationID of the shard this request is meant for */, +        private final String targetAllocationID;, +        AsyncPrimaryAction(Request request, String targetAllocationID, TransportChannel channel, ReplicationTask replicationTask) {, +            this.targetAllocationID = targetAllocationID;, +            acquirePrimaryShardReference(request.shardId(), targetAllocationID, this);, +                    transportService.sendRequest(relocatingNode, transportPrimaryAction,, +                        new ConcreteShardRequest<>(request, primary.allocationId().getRelocationId()),, +                        transportOptions,, +    class ReplicaOperationTransportHandler implements TransportRequestHandler<ConcreteShardRequest<ReplicaRequest>> {, +        public void messageReceived(final ConcreteShardRequest<ReplicaRequest> request, final TransportChannel channel), +            throws Exception {, +        public void messageReceived(ConcreteShardRequest<ReplicaRequest> requestWithAID, TransportChannel channel, Task task), +            throws Exception {, +            new AsyncReplicaAction(requestWithAID.request, requestWithAID.targetAllocationID, channel, (ReplicationTask) task).run();, +        // allocation id of the replica this request is meant for, +        private final String targetAllocationID;, +        AsyncReplicaAction(ReplicaRequest request, String targetAllocationID, TransportChannel channel, ReplicationTask task) {, +            this.targetAllocationID = targetAllocationID;, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction,, +                            new ConcreteShardRequest<>(request, targetAllocationID),, +                            handler);, +            acquireReplicaOperationLock(request.shardId(), request.primaryTerm(), targetAllocationID, this);, +            performAction(node, transportPrimaryAction, true, new ConcreteShardRequest<>(request, primary.allocationId().getId()));, +            performAction(node, actionName, false, request);, +        private void performAction(final DiscoveryNode node, final String action, final boolean isPrimaryAction,, +                                   final TransportRequest requestToPerform) {, +            transportService.sendRequest(node, action, requestToPerform, transportOptions, new TransportResponseHandler<Response>() {, +                                    requestToPerform),, +    protected void acquirePrimaryShardReference(ShardId shardId, String allocationId,, +                                                ActionListener<PrimaryShardReference> onReferenceAcquired) {, +        final String actualAllocationId = indexShard.routingEntry().allocationId().getId();, +        if (actualAllocationId.equals(allocationId) == false) {, +            throw new ShardNotFoundException(shardId, "expected aID [{}] but found [{}]", allocationId, actualAllocationId);, +        }, +    protected void acquireReplicaOperationLock(ShardId shardId, long primaryTerm, final String allocationId,, +                                               ActionListener<Releasable> onLockAcquired) {, +        final String actualAllocationId = indexShard.routingEntry().allocationId().getId();, +        if (actualAllocationId.equals(allocationId) == false) {, +            throw new ShardNotFoundException(shardId, "expected aID [{}] but found [{}]", allocationId, actualAllocationId);, +        }, +            transportService.sendRequest(node, transportReplicaAction,, +                new ConcreteShardRequest<>(request, replica.allocationId().getId()), transportOptions,, +    /** a wrapper class to encapsulate a request when being sent to a specific allocation id **/, +    final class ConcreteShardRequest<R extends TransportRequest> extends TransportRequest {, +, +        /** {@link AllocationId#getId()} of the shard this request is sent to **/, +        private String targetAllocationID;, +, +        private R request;, +, +        ConcreteShardRequest(Supplier<R> requestSupplier) {, +            request = requestSupplier.get();, +            // null now, but will be populated by reading from the streams, +            targetAllocationID = null;, +        }, +, +        ConcreteShardRequest(R request, String targetAllocationID) {, +            Objects.requireNonNull(request);, +            Objects.requireNonNull(targetAllocationID);, +            this.request = request;, +            this.targetAllocationID = targetAllocationID;]