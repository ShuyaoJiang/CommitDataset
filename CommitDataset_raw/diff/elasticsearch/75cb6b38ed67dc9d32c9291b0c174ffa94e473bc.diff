[+++ b/x-pack/plugin/sql/qa/security/build.gradle, +    def today = new Date().format('yyyy-MM-dd'), +    systemProperty 'tests.audit.yesterday.logfile',, +        "${ -> integTest.nodes[0].homeDir}/logs/${ -> integTest.nodes[0].clusterName }_audit-${today}.json", +++ b/x-pack/plugin/sql/qa/security/build.gradle, +    def today = new Date().format('yyyy-MM-dd'), +    systemProperty 'tests.audit.yesterday.logfile',, +        "${ -> integTest.nodes[0].homeDir}/logs/${ -> integTest.nodes[0].clusterName }_audit-${today}.json", +++ b/x-pack/plugin/sql/qa/security/src/test/java/org/elasticsearch/xpack/sql/qa/security/SqlSecurityTestCase.java, +    private static final Path ROLLED_OVER_AUDIT_LOG_FILE = lookupRolledOverAuditLog();, +    @SuppressForbidden(reason="security doesn't work with mock filesystem"), +    private static Path lookupRolledOverAuditLog() {, +        String auditLogFileString = System.getProperty("tests.audit.yesterday.logfile");, +        if (null == auditLogFileString) {, +            throw new IllegalStateException("tests.audit.yesterday.logfile must be set to run this test. It should be automatically ", +                    + "set by gradle.");, +        }        , +        return Paths.get(auditLogFileString);, +    }, +, +    private static long auditLogWrittenBeforeTestStart;, +    , +    /**, +     * If the audit log file rolled over. This is a rare case possible only at midnight., +     */, +    private static boolean auditFileRolledOver = false;, +                    , +                    BufferedReader[] logReaders = new BufferedReader[2];, +                    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {, +                            // the audit log file rolled over during the test, +                            // and we need to consume the rest of the rolled over file plus the new audit log file, +                            if (auditFileRolledOver == false && Files.exists(ROLLED_OVER_AUDIT_LOG_FILE)) {, +                                // once the audit file rolled over, it will stay like this, +                                auditFileRolledOver = true;, +                                // the order in the array matters, as the readers will be used in that order, +                                logReaders[0] = Files.newBufferedReader(ROLLED_OVER_AUDIT_LOG_FILE, StandardCharsets.UTF_8);, +                            }, +                            logReaders[1] = Files.newBufferedReader(AUDIT_LOG_FILE, StandardCharsets.UTF_8);, +                            return null;, +                    , +                    // The "index" is used as a way of reading from both rolled over file and current audit file in order: rolled over file, +                    // first, then the audit log file. Very rarely we will read from the rolled over file: when the test happened to run, +                    // at midnight and the audit file rolled over during the test., +                    int index;, +                    if (logReaders[0] != null) {, +                        logReaders[0].skip(auditLogWrittenBeforeTestStart);, +                        // start with the rolled over file first, +                        index = 0;, +                    } else {, +                        // the current audit log file reader should always be non-null, +                        logReaders[1].skip(auditLogWrittenBeforeTestStart);, +                        // start with the current audit logging file, +                        index = 1;, +                    }, +                    while (index < 2) {, +                        line = logReaders[index].readLine();, +                        // when the end of the file is reached, either stop or move to the next reader, +                        if (line == null) {, +                            if (++index == 2) {, +                                break;, +                            }, +                        }, +                        else {, +                    }, +++ b/x-pack/plugin/sql/qa/security/build.gradle, +    def today = new Date().format('yyyy-MM-dd'), +    systemProperty 'tests.audit.yesterday.logfile',, +        "${ -> integTest.nodes[0].homeDir}/logs/${ -> integTest.nodes[0].clusterName }_audit-${today}.json", +++ b/x-pack/plugin/sql/qa/security/src/test/java/org/elasticsearch/xpack/sql/qa/security/SqlSecurityTestCase.java, +    private static final Path ROLLED_OVER_AUDIT_LOG_FILE = lookupRolledOverAuditLog();, +    @SuppressForbidden(reason="security doesn't work with mock filesystem"), +    private static Path lookupRolledOverAuditLog() {, +        String auditLogFileString = System.getProperty("tests.audit.yesterday.logfile");, +        if (null == auditLogFileString) {, +            throw new IllegalStateException("tests.audit.yesterday.logfile must be set to run this test. It should be automatically ", +                    + "set by gradle.");, +        }        , +        return Paths.get(auditLogFileString);, +    }, +, +    private static long auditLogWrittenBeforeTestStart;, +    , +    /**, +     * If the audit log file rolled over. This is a rare case possible only at midnight., +     */, +    private static boolean auditFileRolledOver = false;, +                    , +                    BufferedReader[] logReaders = new BufferedReader[2];, +                    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {, +                            // the audit log file rolled over during the test, +                            // and we need to consume the rest of the rolled over file plus the new audit log file, +                            if (auditFileRolledOver == false && Files.exists(ROLLED_OVER_AUDIT_LOG_FILE)) {, +                                // once the audit file rolled over, it will stay like this, +                                auditFileRolledOver = true;, +                                // the order in the array matters, as the readers will be used in that order, +                                logReaders[0] = Files.newBufferedReader(ROLLED_OVER_AUDIT_LOG_FILE, StandardCharsets.UTF_8);, +                            }, +                            logReaders[1] = Files.newBufferedReader(AUDIT_LOG_FILE, StandardCharsets.UTF_8);, +                            return null;, +                    ]