[+++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            return EpochTime.SECONDS_FORMATTER;, +            return EpochTime.MILLIS_FORMATTER;, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            return EpochTime.SECONDS_FORMATTER;, +            return EpochTime.MILLIS_FORMATTER;, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            return EpochTime.SECONDS_FORMATTER;, +            return EpochTime.MILLIS_FORMATTER;, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/common/time/EpochTime.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.time;, +, +import java.time.format.DateTimeFormatter;, +import java.time.format.DateTimeFormatterBuilder;, +import java.time.format.ResolverStyle;, +import java.time.format.SignStyle;, +import java.time.temporal.ChronoField;, +import java.time.temporal.ChronoUnit;, +import java.time.temporal.Temporal;, +import java.time.temporal.TemporalAccessor;, +import java.time.temporal.TemporalField;, +import java.time.temporal.TemporalUnit;, +import java.time.temporal.ValueRange;, +import java.util.Locale;, +import java.util.Map;, +, +/**, + * This class provides {@link DateTimeFormatter}s capable of parsing epoch seconds and milliseconds., + * <p>, + * The seconds formatter is provided by {@link #SECONDS_FORMATTER}., + * The milliseconds formatter is provided by {@link #MILLIS_FORMATTER}., + * <p>, + * Both formatters support fractional time, up to nanosecond precision. Values must be positive numbers., + */, +class EpochTime {, +, +    private static final ValueRange LONG_POSITIVE_RANGE = ValueRange.of(0, Long.MAX_VALUE);, +, +    private static final EpochField SECONDS = new EpochField(ChronoUnit.SECONDS, ChronoUnit.FOREVER, LONG_POSITIVE_RANGE) {, +        @Override, +        public boolean isSupportedBy(TemporalAccessor temporal) {, +            return temporal.isSupported(ChronoField.INSTANT_SECONDS);, +        }, +        @Override, +        public long getFrom(TemporalAccessor temporal) {, +            return temporal.getLong(ChronoField.INSTANT_SECONDS);, +        }, +        @Override, +        public TemporalAccessor resolve(Map<TemporalField,Long> fieldValues,, +                                        TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {, +            long seconds = fieldValues.remove(this);, +            fieldValues.put(ChronoField.INSTANT_SECONDS, seconds);, +            Long nanos = fieldValues.remove(NANOS_OF_SECOND);, +            if (nanos != null) {, +                fieldValues.put(ChronoField.NANO_OF_SECOND, nanos);, +            }, +            return null;, +        }, +    };, +, +    private static final EpochField NANOS_OF_SECOND = new EpochField(ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999_999_999)) {, +        @Override, +        public boolean isSupportedBy(TemporalAccessor temporal) {, +            return temporal.isSupported(ChronoField.NANO_OF_SECOND) && temporal.getLong(ChronoField.NANO_OF_SECOND) != 0;, +        }, +        @Override, +        public long getFrom(TemporalAccessor temporal) {, +            return temporal.getLong(ChronoField.NANO_OF_SECOND);, +        }, +    };, +, +    private static final EpochField MILLIS = new EpochField(ChronoUnit.MILLIS, ChronoUnit.FOREVER, LONG_POSITIVE_RANGE) {, +        @Override, +        public boolean isSupportedBy(TemporalAccessor temporal) {, +            return temporal.isSupported(ChronoField.INSTANT_SECONDS) && temporal.isSupported(ChronoField.MILLI_OF_SECOND);, +        }, +        @Override, +        public long getFrom(TemporalAccessor temporal) {, +            return temporal.getLong(ChronoField.INSTANT_SECONDS) * 1_000 + temporal.getLong(ChronoField.MILLI_OF_SECOND);]