[+++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +        Directory directory = nameDirMapping.get(name);, +        if (directory == null) {, +            // name is not yet bound to a directory:, +, +            if (iterate) { // in order to get stuff like "write.lock" that might not be written through this directory, +                        directory = nameDirMapping.putIfAbsent(name, dir);, +, +            // Pick a directory and associate this new file with it:, +            directory = nameDirMapping.putIfAbsent(name, dir);, +            if (directory == null) {, +                // putIfAbsent did in fact put dir:, +                directory = dir;, +            }, +        }, +            , +        return directory;, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +        Directory directory = nameDirMapping.get(name);, +        if (directory == null) {, +            // name is not yet bound to a directory:, +, +            if (iterate) { // in order to get stuff like "write.lock" that might not be written through this directory, +                        directory = nameDirMapping.putIfAbsent(name, dir);, +, +            // Pick a directory and associate this new file with it:, +            directory = nameDirMapping.putIfAbsent(name, dir);, +            if (directory == null) {, +                // putIfAbsent did in fact put dir:, +                directory = dir;, +            }, +        }, +            , +        return directory;, +++ b/src/test/java/org/elasticsearch/index/store/DistributorDirectoryTest.java, +import java.io.File;, +import java.io.IOException;, +, +import org.apache.lucene.store.BaseDirectoryTestCase;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.IOContext;, +import org.apache.lucene.util.LuceneTestCase;, +import org.apache.lucene.util.TimeUnits;, +import org.elasticsearch.index.store.distributor.Distributor;, +import org.elasticsearch.test.ElasticsearchThreadFilter;, +import org.elasticsearch.test.junit.listeners.LoggingListener;, +    // #7306: don't invoke the distributor when we are opening an already existing file, +    public void testDoNotCallDistributorOnRead() throws Exception {      , +        Directory dir = newDirectory();, +        dir.createOutput("one.txt", IOContext.DEFAULT).close();, +, +        final Directory[] dirs = new Directory[] {dir};, +, +        Distributor distrib = new Distributor() {, +, +            @Override, +            public Directory primary() {, +                return dirs[0];, +            }, +, +            @Override, +            public Directory[] all() {, +                return dirs;, +            }, +, +            @Override, +            public synchronized Directory any() {, +                throw new IllegalStateException("any should not be called");, +            }, +            };, +, +        Directory dd = new DistributorDirectory(distrib);, +        assertEquals(0, dd.fileLength("one.txt"));, +        dd.openInput("one.txt", IOContext.DEFAULT).close();, +        try {, +            dd.createOutput("three.txt", IOContext.DEFAULT).close();, +            fail("didn't hit expected exception");, +        } catch (IllegalStateException ise) {, +            // expected, +        }, +        dd.close();, +    }]