[+++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java, +import org.elasticsearch.action.support.ActiveShardCount;, +        assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards();, +            waitForActiveShards(ActiveShardCount.NONE);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java, +import org.elasticsearch.action.support.ActiveShardCount;, +        assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards();, +            waitForActiveShards(ActiveShardCount.NONE);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java, +import org.elasticsearch.action.support.ActiveShardCount;, +        assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards();, +            waitForActiveShards(ActiveShardCount.NONE);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseBackgroundSyncAction.java, +import org.elasticsearch.action.support.ActiveShardCount;, +        assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards();, +            waitForActiveShards(ActiveShardCount.NONE);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java, +import org.elasticsearch.action.support.ActiveShardCount;, +        assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards();, +            waitForActiveShards(ActiveShardCount.NONE);, +++ b/server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseIT.java, +            final BiConsumer<IndexShard, ActionListener<ReplicationResponse>> primaryConsumer,, +        primary.addRetentionLease(idForInitialRetentionLease, initialRetainingSequenceNumber, source, listener);, +            primaryConsumer.accept(, +    public void testCanAddRetentionLeaseWithoutWaitingForShards() throws InterruptedException {, +        final String idForInitialRetentionLease = randomAlphaOfLength(8);, +        runWaitForShardsTest(, +                idForInitialRetentionLease,, +                randomLongBetween(0, Long.MAX_VALUE),, +                (primary, listener) -> {, +                    final String nextId = randomValueOtherThan(idForInitialRetentionLease, () -> randomAlphaOfLength(8));, +                    final long nextRetainingSequenceNumber = randomLongBetween(0, Long.MAX_VALUE);, +                    final String nextSource = randomAlphaOfLength(8);, +                    primary.addRetentionLease(nextId, nextRetainingSequenceNumber, nextSource, listener);, +                },, +                primary -> {});, +    }, +, +    public void testCanRenewRetentionLeaseWithoutWaitingForShards() throws InterruptedException {, +        final String idForInitialRetentionLease = randomAlphaOfLength(8);, +        final long initialRetainingSequenceNumber = randomLongBetween(0, Long.MAX_VALUE);, +        final AtomicReference<RetentionLease> retentionLease = new AtomicReference<>();, +        runWaitForShardsTest(, +                idForInitialRetentionLease,, +                initialRetainingSequenceNumber,, +                (primary, listener) -> {, +                    final long nextRetainingSequenceNumber = randomLongBetween(initialRetainingSequenceNumber, Long.MAX_VALUE);, +                    final String nextSource = randomAlphaOfLength(8);, +                    retentionLease.set(primary.renewRetentionLease(idForInitialRetentionLease, nextRetainingSequenceNumber, nextSource));, +                    listener.onResponse(new ReplicationResponse());, +                },, +                primary -> {, +                    try {, +                        /*, +                         * If the background renew was able to execute, then the retention leases were persisted to disk. There is no other, +                         * way for the current retention leases to end up written to disk so we assume that if they are written to disk, it, +                         * implies that the background sync was able to execute despite wait for shards being set on the index., +                         */, +                        assertBusy(() -> assertThat(primary.loadRetentionLeases().leases(), contains(retentionLease.get())));, +                    } catch (final Exception e) {, +                        fail(e.toString());, +                    }, +                });, +, +    }, +, +    public void testCanRemoveRetentionLeasesWithoutWaitingForShards() throws InterruptedException {, +        final String idForInitialRetentionLease = randomAlphaOfLength(8);, +        runWaitForShardsTest(, +                idForInitialRetentionLease,, +                randomLongBetween(0, Long.MAX_VALUE),, +                (primary, listener) -> primary.removeRetentionLease(idForInitialRetentionLease, listener),, +                primary -> {});, +    }, +, +    private void runWaitForShardsTest(, +            final String idForInitialRetentionLease,, +            final long initialRetainingSequenceNumber,, +            final BiConsumer<IndexShard, ActionListener<ReplicationResponse>> primaryConsumer,, +            final Consumer<IndexShard> afterSync) throws InterruptedException {, +        final int numDataNodes = internalCluster().numDataNodes();, +        final Settings settings = Settings.builder(), +                .put("index.number_of_shards", 1), +                .put("index.number_of_replicas", numDataNodes == 1 ? 0 : numDataNodes - 1), +                .put(IndexService.RETENTION_LEASE_SYNC_INTERVAL_SETTING.getKey(), TimeValue.timeValueSeconds(1)), +                .build();, +        assertAcked(prepareCreate("index").setSettings(settings));, +        ensureYellowAndNoInitializingShards("index");, +        assertFalse(client().admin().cluster().prepareHealth("index").setWaitForActiveShards(numDataNodes).get().isTimedOut());, +, +        final String primaryShardNodeId = clusterService().state().routingTable().index("index").shard(0).primaryShard().currentNodeId();, +        final String primaryShardNodeName = clusterService().state().nodes().get(primaryShardNodeId).getName();, +        final IndexShard primary = internalCluster(), +                .getInstance(IndicesService.class, primaryShardNodeName), +                .getShardOrNull(new ShardId(resolveIndex("index"), 0));, +, +        final String source = randomAlphaOfLength(8);, +        final CountDownLatch latch = new CountDownLatch(1);, +        final ActionListener<ReplicationResponse> listener = ActionListener.wrap(r -> latch.countDown(), e -> fail(e.toString()));, +        primary.addRetentionLease(idForInitialRetentionLease, initialRetainingSequenceNumber, source, listener);]