[+++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexGeoPointFieldData.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexGeoPointFieldData.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/GeoPointArrayIndexFieldData.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            final GeoPointField.TermEncoding termEncoding = indexSettings.getIndexVersionCreated().onOrAfter(Version.V_2_3_0) ?, +                GeoPointField.TermEncoding.PREFIX : GeoPointField.TermEncoding.NUMERIC;, +            final GeoPointTermsEnum iter = new GeoPointTermsEnum(builder.buildFromTerms(OrdinalsBuilder.wrapNumeric64Bit(terms.iterator())), termEncoding);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexGeoPointFieldData.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/GeoPointArrayIndexFieldData.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            final GeoPointField.TermEncoding termEncoding = indexSettings.getIndexVersionCreated().onOrAfter(Version.V_2_3_0) ?, +                GeoPointField.TermEncoding.PREFIX : GeoPointField.TermEncoding.NUMERIC;, +            final GeoPointTermsEnum iter = new GeoPointTermsEnum(builder.buildFromTerms(OrdinalsBuilder.wrapNumeric64Bit(terms.iterator())), termEncoding);, +++ b/core/src/main/java/org/elasticsearch/index/query/functionscore/FunctionScoreQueryParser.java, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.List;, +, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                if ("query".equals(currentFieldName)) {, +                    if (query != null) {, +                        throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. [query] is already defined.", FunctionScoreQueryBuilder.NAME);, +                    query = parseContext.parseInnerQueryBuilder();, +                    // we try to parse a score function. If there is no score function for the current field name,, +                    // functionParserMapper.get() may throw an Exception., +                    ScoreFunctionBuilder<?> scoreFunction = functionParserMapper.get(parser.getTokenLocation(), currentFieldName).fromXContent(parseContext, parser);, +            } else if (token == XContentParser.Token.START_ARRAY) {, +                if ("functions".equals(currentFieldName)) {, +                    if (singleFunctionFound) {, +                        String errorString = "already found [" + singleFunctionName + "], now encountering [functions].";, +                        handleMisplacedFunctionsDeclaration(parser.getTokenLocation(), errorString);, +                    }, +                    functionArrayFound = true;, +                    currentFieldName = parseFiltersAndFunctions(parseContext, parser, filterFunctionBuilders);, +                } else {, +                    throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. array [{}] is not supported", FunctionScoreQueryBuilder.NAME, currentFieldName);, +                }, +, +            } else if (token.isValue()) {, +                if ("score_mode".equals(currentFieldName) || "scoreMode".equals(currentFieldName)) {, +                    scoreMode = FiltersFunctionScoreQuery.ScoreMode.fromString(parser.text());, +                } else if ("boost_mode".equals(currentFieldName) || "boostMode".equals(currentFieldName)) {, +                    combineFunction = CombineFunction.fromString(parser.text());, +                } else if ("max_boost".equals(currentFieldName) || "maxBoost".equals(currentFieldName)) {, +                    maxBoost = parser.floatValue();, +                } else if ("boost".equals(currentFieldName)) {, +                    boost = parser.floatValue();, +                } else if ("_name".equals(currentFieldName)) {, +                    queryName = parser.text();, +                } else if ("min_score".equals(currentFieldName) || "minScore".equals(currentFieldName)) {, +                    minScore = parser.floatValue();, +                } else {, +                    if (singleFunctionFound) {, +                        throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. already found function [{}], now encountering [{}]. use [functions] array if you want to define several functions.", FunctionScoreQueryBuilder.NAME, singleFunctionName, currentFieldName);, +                    }, +                    if (functionArrayFound) {, +                        String errorString = "already found [functions] array, now encountering [" + currentFieldName + "].";, +                        handleMisplacedFunctionsDeclaration(parser.getTokenLocation(), errorString);, +                    }, +                    if (parseContext.parseFieldMatcher().match(currentFieldName, WEIGHT_FIELD)) {, +                        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(new WeightBuilder().setWeight(parser.floatValue())));, +                        singleFunctionFound = true;, +                        singleFunctionName = currentFieldName;, +                    } else {, +                        throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. field [{}] is not supported", FunctionScoreQueryBuilder.NAME, currentFieldName);, +                    }, +                }, +            }, +                    } else if (token == XContentParser.Token.START_OBJECT) {, +                            // do not need to check null here, functionParserMapper does it already, +                    } else if (token.isValue()) {, +                        if (parseContext.parseFieldMatcher().match(currentFieldName, WEIGHT_FIELD)) {, +                            functionWeight = parser.floatValue();, +                        } else {, +                            throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. field [{}] is not supported", FunctionScoreQueryBuilder.NAME, currentFieldName);, +                        }, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexGeoPointFieldData.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/GeoPointArrayIndexFieldData.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            final GeoPointField.TermEncoding termEncoding = indexSettings.getIndexVersionCreated().onOrAfter(Version.V_2_3_0) ?, +                GeoPointField.TermEncoding.PREFIX : GeoPointField.TermEncoding.NUMERIC;, +            final GeoPointTermsEnum iter = new GeoPointTermsEnum(builder.buildFromTerms(OrdinalsBuilder.wrapNumeric64Bit(terms.iterator())), termEncoding);, +++ b/core/src/main/java/org/elasticsearch/index/query/functionscore/FunctionScoreQueryParser.java, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.List;, +, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                if ("query".equals(currentFieldName)) {, +                    if (query != null) {, +                        throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. [query] is already defined.", FunctionScoreQueryBuilder.NAME);, +                    query = parseContext.parseInnerQueryBuilder();, +                    // we try to parse a score function. If there is no score function for the current field name,, +                    // functionParserMapper.get() may throw an Exception., +                    ScoreFunctionBuilder<?> scoreFunction = functionParserMapper.get(parser.getTokenLocation(), currentFieldName).fromXContent(parseContext, parser);]