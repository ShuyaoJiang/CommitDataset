[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.ipv4.IPv4RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.metrics.avg.AvgAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.derivative.DerivativePipelineAggregatorBuilder;, +        registerAggregation(AvgAggregatorBuilder::new, new AvgParser(), AvgAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(FiltersAggregatorBuilder::new, (n, c) -> FiltersAggregatorBuilder.parse(queryParserRegistry, n, c),, +                FiltersAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(RangeAggregatorBuilder::new, new RangeParser(), RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateRangeAggregatorBuilder::new, new DateRangeParser(), DateRangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(IPv4RangeAggregatorBuilder::new, new IpRangeParser(), IPv4RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(DerivativePipelineAggregatorBuilder::new, DerivativePipelineAggregatorBuilder::parse,, +                DerivativePipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.ipv4.IPv4RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.metrics.avg.AvgAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.derivative.DerivativePipelineAggregatorBuilder;, +        registerAggregation(AvgAggregatorBuilder::new, new AvgParser(), AvgAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(FiltersAggregatorBuilder::new, (n, c) -> FiltersAggregatorBuilder.parse(queryParserRegistry, n, c),, +                FiltersAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(RangeAggregatorBuilder::new, new RangeParser(), RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateRangeAggregatorBuilder::new, new DateRangeParser(), DateRangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(IPv4RangeAggregatorBuilder::new, new IpRangeParser(), IPv4RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(DerivativePipelineAggregatorBuilder::new, DerivativePipelineAggregatorBuilder::parse,, +                DerivativePipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBuilder.java, +        assert usesNewStyleSerialization() == false: "migrated aggregations should just return their NAME";, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.range.ipv4.IPv4RangeAggregatorBuilder;, +import org.elasticsearch.search.aggregations.metrics.avg.AvgAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.derivative.DerivativePipelineAggregatorBuilder;, +        registerAggregation(AvgAggregatorBuilder::new, new AvgParser(), AvgAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(FiltersAggregatorBuilder::new, (n, c) -> FiltersAggregatorBuilder.parse(queryParserRegistry, n, c),, +                FiltersAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(RangeAggregatorBuilder::new, new RangeParser(), RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateRangeAggregatorBuilder::new, new DateRangeParser(), DateRangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(IPv4RangeAggregatorBuilder::new, new IpRangeParser(), IPv4RangeAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(DerivativePipelineAggregatorBuilder::new, DerivativePipelineAggregatorBuilder::parse,, +                DerivativePipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregatorBuilder.java, +        assert usesNewStyleSerialization() == false: "migrated aggregations should just return their NAME";, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryBuilders;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.indices.query.IndicesQueriesRegistry;, +import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;, +public class FiltersAggregatorBuilder extends AggregatorBuilder<FiltersAggregatorBuilder> {, +    public static final String NAME = InternalFilters.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +, +    private static final ParseField FILTERS_FIELD = new ParseField("filters");, +    private static final ParseField OTHER_BUCKET_FIELD = new ParseField("other_bucket");, +    private static final ParseField OTHER_BUCKET_KEY_FIELD = new ParseField("other_bucket_key");, +     * Read from a stream., +     */, +    public FiltersAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, InternalFilters.TYPE);, +        keyed = in.readBoolean();, +        int filtersSize = in.readVInt();, +        filters = new ArrayList<>(filtersSize);, +        if (keyed) {, +            for (int i = 0; i < filtersSize; i++) {, +                filters.add(KeyedFilter.PROTOTYPE.readFrom(in));, +            }, +        } else {, +            for (int i = 0; i < filtersSize; i++) {, +                filters.add(new KeyedFilter(String.valueOf(i), in.readQuery()));, +            }, +        }, +        otherBucket = in.readBoolean();, +        otherBucketKey = in.readString();, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeBoolean(keyed);, +        out.writeVInt(filters.size());, +        if (keyed) {, +            for (KeyedFilter keyedFilter : filters) {, +                keyedFilter.writeTo(out);, +            }, +        } else {, +            for (KeyedFilter keyedFilter : filters) {, +                out.writeQuery(keyedFilter.filter());, +            }, +        }, +        out.writeBoolean(otherBucket);, +        out.writeString(otherBucketKey);, +    }]