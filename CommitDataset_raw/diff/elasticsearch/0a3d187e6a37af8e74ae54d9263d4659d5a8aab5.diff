[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/ObjectMapper.java, +            ObjectMapper objectMapper = createMapper(name, enabled, dynamic, pathType, mappers);, +        protected ObjectMapper createMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers) {, +            return new ObjectMapper(name, enabled, dynamic, pathType, mappers);, +, +        this(name, enabled, dynamic, pathType, null);, +    ObjectMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers) {, +                            builder = XContentMapperBuilders.object(currentFieldName).enabled(true).dynamic(dynamic).pathType(pathType);, +                    for (FormatDateTimeFormatter dateTimeFormatter : context.root().dateTimeFormatters()) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/ObjectMapper.java, +            ObjectMapper objectMapper = createMapper(name, enabled, dynamic, pathType, mappers);, +        protected ObjectMapper createMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers) {, +            return new ObjectMapper(name, enabled, dynamic, pathType, mappers);, +, +        this(name, enabled, dynamic, pathType, null);, +    ObjectMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers) {, +                            builder = XContentMapperBuilders.object(currentFieldName).enabled(true).dynamic(dynamic).pathType(pathType);, +                    for (FormatDateTimeFormatter dateTimeFormatter : context.root().dateTimeFormatters()) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/RootObjectMapper.java, +import org.elasticsearch.common.joda.Joda;, +import static org.elasticsearch.index.mapper.xcontent.XContentTypeParsers.*;, +    public static class Defaults {, +        public static final FormatDateTimeFormatter[] DATE_TIME_FORMATTERS =, +                new FormatDateTimeFormatter[]{, +                        DateFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                        Joda.forPattern("yyyy/MM/dd HH:mm:ss||yyyy/MM/dd"), +                };, +    }, +, +        protected List<FormatDateTimeFormatter> dateTimeFormatters = newArrayList();, +, +        public Builder noDateTimeFormatter() {, +            this.dateTimeFormatters = null;, +            return builder;, +        }, +, +        public Builder dateTimeFormatter(Iterable<FormatDateTimeFormatter> dateTimeFormatters) {, +            for (FormatDateTimeFormatter dateTimeFormatter : dateTimeFormatters) {, +                this.dateTimeFormatters.add(dateTimeFormatter);, +            }, +            return builder;, +        }, +, +        public Builder dateTimeFormatter(FormatDateTimeFormatter[] dateTimeFormatters) {, +            this.dateTimeFormatters.addAll(newArrayList(dateTimeFormatters));, +            return builder;, +        }, +, +        public Builder dateTimeFormatter(FormatDateTimeFormatter dateTimeFormatter) {, +            this.dateTimeFormatters.add(dateTimeFormatter);, +            return builder;, +        }, +, +        @Override protected ObjectMapper createMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers) {, +            if (dateTimeFormatters == null) {, +                dateTimeFormatters = newArrayList();, +            } else if (dateTimeFormatters.isEmpty()) {, +                // add the default one, +                dateTimeFormatters.addAll(newArrayList(Defaults.DATE_TIME_FORMATTERS));, +            }, +            return new RootObjectMapper(name, enabled, dynamic, pathType, mappers,, +                    dateTimeFormatters.toArray(new FormatDateTimeFormatter[dateTimeFormatters.size()]),, +                    dynamicTemplates.toArray(new DynamicTemplate[dynamicTemplates.size()]));, +            if (fieldName.equals("date_formats")) {, +                List<FormatDateTimeFormatter> dateTimeFormatters = newArrayList();, +                if (fieldNode instanceof List) {, +                    for (Object node1 : (List) fieldNode) {, +                        dateTimeFormatters.add(parseDateTimeFormatter(fieldName, node1));, +                    }, +                } else if ("none".equals(fieldNode.toString())) {, +                    dateTimeFormatters = null;, +                } else {, +                    dateTimeFormatters.add(parseDateTimeFormatter(fieldName, fieldNode));, +                }, +                if (dateTimeFormatters == null) {, +                    ((Builder) builder).noDateTimeFormatter();, +                } else {, +                    ((Builder) builder).dateTimeFormatter(dateTimeFormatters);, +                }, +            } else if (fieldName.equals("dynamic_templates")) {, +    private final FormatDateTimeFormatter[] dateTimeFormatters;, +, +    RootObjectMapper(String name, boolean enabled, boolean dynamic, ContentPath.Type pathType, Map<String, XContentMapper> mappers,, +                     FormatDateTimeFormatter[] dateTimeFormatters, DynamicTemplate dynamicTemplates[]) {, +        super(name, enabled, dynamic, pathType, mappers);, +        this.dateTimeFormatters = dateTimeFormatters;, +    }, +, +    public FormatDateTimeFormatter[] dateTimeFormatters() {, +        return dateTimeFormatters;, +        if (dateTimeFormatters.length > 0) {, +            builder.startArray("date_formats");, +            for (FormatDateTimeFormatter dateTimeFormatter : dateTimeFormatters) {, +                builder.value(dateTimeFormatter.format());, +            }, +            builder.endArray();, +        }, +]