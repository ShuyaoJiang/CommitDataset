[+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.indices.IndexCreationException;, +    private final NodeEnvironment nodeEnv;, +    public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService,, +                                      IndicesService indicesService, AllocationService allocationService, MetaDataService metaDataService,, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +                                      Set<IndexTemplateFilter> indexTemplateFilters, NodeEnvironment nodeEnv) {, +        this.nodeEnv = nodeEnv;, +        String customPath = request.settings().get(IndexMetaData.SETTING_DATA_PATH, null);, +        if (customPath != null && nodeEnv.isCustomPathsEnabled() == false) {, +            throw new IndexCreationException(new Index(request.index()),, +                    new ElasticsearchIllegalArgumentException("custom data_paths for indices is disabled"));, +        }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.indices.IndexCreationException;, +    private final NodeEnvironment nodeEnv;, +    public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService,, +                                      IndicesService indicesService, AllocationService allocationService, MetaDataService metaDataService,, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +                                      Set<IndexTemplateFilter> indexTemplateFilters, NodeEnvironment nodeEnv) {, +        this.nodeEnv = nodeEnv;, +        String customPath = request.settings().get(IndexMetaData.SETTING_DATA_PATH, null);, +        if (customPath != null && nodeEnv.isCustomPathsEnabled() == false) {, +            throw new IndexCreationException(new Index(request.index()),, +                    new ElasticsearchIllegalArgumentException("custom data_paths for indices is disabled"));, +        }, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.io.FileSystemUtils;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.index.settings.IndexSettings;, +    private final boolean addNodeId;, +    private final boolean customPathsEnabled;, +, +    // Setting to automatically append node id to custom data paths, +    public static final String ADD_NODE_ID_TO_CUSTOM_PATH = "node.add_id_to_custom_path";, +    // Setting to enable custom index.data_path setting for new indices, +    public static final String SETTING_CUSTOM_DATA_PATH_ENABLED = "node.enable_custom_paths";, +, +    public static final String NODES_FOLDER = "nodes";, +    public static final String INDICES_FOLDER = "indices";, +    public static final String NODE_LOCK_FILENAME = "node.lock";, +, +        this.addNodeId = settings.getAsBoolean(ADD_NODE_ID_TO_CUSTOM_PATH, true);, +        this.customPathsEnabled = settings.getAsBoolean(SETTING_CUSTOM_DATA_PATH_ENABLED, false);, +, +                Path dir = environment.dataWithClusterFiles()[dirIndex].resolve(Paths.get(NODES_FOLDER, Integer.toString(possibleLockId)));, +                    Lock tmpLock = luceneDir.makeLock(NODE_LOCK_FILENAME);, +            throw new ElasticsearchIllegalStateException("Failed to obtain node lock, is the following location writable?: ", +                    + Arrays.toString(environment.dataWithClusterFiles()), lastException);, +                sb.append(" -> "), +                        .append(file.toAbsolutePath()), +                        .append(", free_space ["), +                        .append(new ByteSizeValue(Files.getFileStore(file).getUnallocatedSpace())), +                        .append("], usable_space ["), +                        .append(new ByteSizeValue(Files.getFileStore(file).getUsableSpace())), +                        .append("]\n");, +            nodeIndicesPaths[i] = nodePaths[i].resolve(INDICES_FOLDER);, +    public void deleteShardDirectorySafe(ShardId shardId, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +        logger.trace("deleting shard {} directory, paths: [{}]", shardId, paths);, +            if (hasCustomDataPath(indexSettings)) {, +                Path customLocation = resolveCustomLocation(indexSettings, shardId);, +                logger.trace("deleting custom shard {} directory [{}]", shardId, customLocation);, +                IOUtils.rm(customLocation);, +            }, +            logger.trace("deleted shard {} directory, paths: [{}]", shardId, paths);, +            assert FileSystemUtils.exists(paths) == false;, +    public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings != ImmutableSettings.EMPTY;, +            final Path[] indexPaths = indexPaths(index);, +            logger.trace("deleting index {} directory, paths({}): [{}]", index, indexPaths.length, indexPaths);, +            if (hasCustomDataPath(indexSettings)) {, +                Path customLocation = resolveCustomLocation(indexSettings, index.name());, +                logger.trace("deleting custom index {} directory [{}]", index, customLocation);, +                IOUtils.rm(customLocation);, +            }, +        logger.trace("locking all shards for index {} - [{}]", index, allShardIds);, +        List<ShardLock> allLocks = new ArrayList<>(allShardIds.size());]