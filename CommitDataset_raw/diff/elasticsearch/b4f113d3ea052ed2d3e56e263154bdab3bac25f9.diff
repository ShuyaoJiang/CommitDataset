[+++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportResponseHandler;, +import java.util.function.Consumer;, +        // we fork off quickly here and go async but this is called from the cluster state applier thread too and that can cause, +        // assertions to trip if we executed it on the same thread hence we fork off to the generic threadpool., +        CancellableThreads cancellableThreads;, +            cancellableThreads = recoveryTarget.cancellableThreads();, +        Consumer<Exception> handleException = e -> {, +                    "[{}][{}] Got exception on recovery", request.shardId().getIndex().getName(),, +                    request.shardId().id()), e);, +                retryRecovery(recoveryId, cause, recoverySettings.retryDelayStateSync(),, +                    recoverySettings.activityTimeout());, +                retryRecovery(recoveryId, cause.getMessage(), recoverySettings.retryDelayNetwork(),, +                    recoverySettings.activityTimeout());, +        };, +, +        try {, +            logger.trace("{} starting recovery from {}", request.shardId(), request.sourceNode());, +            cancellableThreads.executeIO(() ->, +                // we still execute under cancelableThreads here to ensure we interrupt any blocking call to the network if any, +                // on the underlying transport. It's unclear if we need this here at all after moving to async execution but, +                // the issues that a missing call to this could cause are sneaky and hard to debug. If we don't need it on this, +                // call we can potentially remove it altogether which we should do it in a major release only with enough, +                // time to test. This shoudl be done for 7.0 if possible, +                transportService.submitRequest(request.sourceNode(), PeerRecoverySourceService.Actions.START_RECOVERY, request,, +                    new TransportResponseHandler<RecoveryResponse>() {, +                        @Override, +                        public void handleResponse(RecoveryResponse recoveryResponse) {, +                            final TimeValue recoveryTime = new TimeValue(timer.time());, +                            // do this through ongoing recoveries to remove it from the collection, +                            onGoingRecoveries.markRecoveryAsDone(recoveryId);, +                            if (logger.isTraceEnabled()) {, +                                StringBuilder sb = new StringBuilder();, +                                sb.append('[').append(request.shardId().getIndex().getName()).append(']'), +                                    .append('[').append(request.shardId().id()).append("] ");, +                                sb.append("recovery completed from ").append(request.sourceNode()).append(", took[").append(recoveryTime), +                                    .append("]\n");, +                                sb.append("   phase1: recovered_files [").append(recoveryResponse.phase1FileNames.size()).append("]"), +                                    .append(" with total_size of [").append(new ByteSizeValue(recoveryResponse.phase1TotalSize)).append("]"), +                                    .append(", took [").append(timeValueMillis(recoveryResponse.phase1Time)).append("], throttling_wait ["), +                                    .append(timeValueMillis(recoveryResponse.phase1ThrottlingWaitTime)).append(']').append("\n");, +                                sb.append("         : reusing_files   [").append(recoveryResponse.phase1ExistingFileNames.size()), +                                    .append("] with total_size of [").append(new ByteSizeValue(recoveryResponse.phase1ExistingTotalSize)), +                                    .append("]\n");, +                                sb.append("   phase2: start took [").append(timeValueMillis(recoveryResponse.startTime)).append("]\n");, +                                sb.append("         : recovered [").append(recoveryResponse.phase2Operations).append("]"), +                                    .append(" transaction log operations"), +                                    .append(", took [").append(timeValueMillis(recoveryResponse.phase2Time)).append("]"), +                                    .append("\n");, +                                logger.trace("{}", sb);, +                            } else {, +                                logger.debug("{} recovery done from [{}], took [{}]", request.shardId(), request.sourceNode(),, +                                    recoveryTime);, +                            }, +                        }, +, +                        @Override, +                        public void handleException(TransportException e) {, +                            handleException.accept(e);, +                        }, +, +                        @Override, +                        public String executor() {, +                            // we do some heavy work like refreshes in the response so fork off to the generic threadpool, +                            return ThreadPool.Names.GENERIC;, +                        }, +, +                        @Override, +                        public RecoveryResponse read(StreamInput in) throws IOException {, +                            RecoveryResponse recoveryResponse = new RecoveryResponse();, +                            recoveryResponse.readFrom(in);, +                            return recoveryResponse;, +                        }, +                    }), +            );, +        } catch (CancellableThreads.ExecutionCancelledException e) {, +            logger.trace("recovery cancelled", e);, +        } catch (Exception e) {, +            handleException.accept(e);]