[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import java.util.concurrent.ConcurrentHashMap;, +            indexShardReference = getIndexShardReferenceOnPrimary(shardId, request);, +, +    static ConcurrentMap<IndexShardReference, String> openShardReferences;, +, +    static boolean setupShardReferenceAssertions() {, +        openShardReferences = new ConcurrentHashMap<>();, +        return true;, +    }, +, +    static boolean addShardReference(IndexShardReference ref, String desc) {, +        String prev = openShardReferences.put(ref, desc);, +        if (prev != null) {, +            throw new AssertionError("shard ref " + ref + " is added twice. current [" + desc + "] prev [" + prev + "]");, +        }, +        return true;, +    }, +, +    static boolean removeShardReference(IndexShardReference ref) {, +        assert openShardReferences.remove(ref) != null : "failed to find ref [" + ref + "]";, +        return true;, +    }, +, +    static {, +        assert setupShardReferenceAssertions();, +    }, +, +    static public void assertAllShardReferencesAreCleaned() {, +        if (openShardReferences == null || openShardReferences.isEmpty()) {, +            return;, +        }, +        StringBuilder sb = new StringBuilder();, +        for (String desc : openShardReferences.values()) {, +            sb.append(desc).append("\n");, +        }, +        assert sb.length() == 0 : "Found unclosed shard references:\n" + sb;, +    }, +, +    protected IndexShardReference getIndexShardReferenceOnPrimary(ShardId shardId, Request request) {, +        IndexShardReference ref = IndexShardReferenceImpl.createOnPrimary(indexShard);, +        assert addShardReference(ref, "primary: " + request.toString() + " " + ref.routingEntry());, +        return ref;, +        IndexShardReference ref = IndexShardReferenceImpl.createOnReplica(indexShard, primaryTerm);, +        assert addShardReference(ref, "primary term: " + primaryTerm + " " + ref.routingEntry());, +        return ref;, +                                                    String message = "unknown";, +                                                    try {, +                                                        message = String.format(Locale.ROOT, "primary shard [%s] was demoted while failing replica shard [%s] for [%s]", primaryShard, shard, exp);, +                                                    } catch (Throwable t) {, +                                                        shardFailedError.addSuppressed(t);, +                                                    }, +                                                    // these can occur if the node is shutting down and are okay, +                                                    // any other exception here is not expected and merits investigation, +                                                    assert shardFailedError instanceof TransportException ||, +                                                            shardFailedError instanceof NodeClosedException : shardFailedError;, +, +, +            assert removeShardReference(this);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import java.util.concurrent.ConcurrentHashMap;, +            indexShardReference = getIndexShardReferenceOnPrimary(shardId, request);, +, +    static ConcurrentMap<IndexShardReference, String> openShardReferences;, +, +    static boolean setupShardReferenceAssertions() {, +        openShardReferences = new ConcurrentHashMap<>();, +        return true;, +    }, +, +    static boolean addShardReference(IndexShardReference ref, String desc) {, +        String prev = openShardReferences.put(ref, desc);, +        if (prev != null) {, +            throw new AssertionError("shard ref " + ref + " is added twice. current [" + desc + "] prev [" + prev + "]");, +        }, +        return true;, +    }, +, +    static boolean removeShardReference(IndexShardReference ref) {, +        assert openShardReferences.remove(ref) != null : "failed to find ref [" + ref + "]";, +        return true;, +    }, +, +    static {, +        assert setupShardReferenceAssertions();, +    }, +, +    static public void assertAllShardReferencesAreCleaned() {, +        if (openShardReferences == null || openShardReferences.isEmpty()) {, +            return;, +        }, +        StringBuilder sb = new StringBuilder();, +        for (String desc : openShardReferences.values()) {, +            sb.append(desc).append("\n");, +        }, +        assert sb.length() == 0 : "Found unclosed shard references:\n" + sb;, +    }, +, +    protected IndexShardReference getIndexShardReferenceOnPrimary(ShardId shardId, Request request) {, +        IndexShardReference ref = IndexShardReferenceImpl.createOnPrimary(indexShard);]