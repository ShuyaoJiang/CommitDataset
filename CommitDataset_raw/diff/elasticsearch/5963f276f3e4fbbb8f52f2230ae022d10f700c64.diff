[+++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +                Setting<?> overlappingSetting = findOverlappingSetting(setting, complexMatchers);, +                if (overlappingSetting != null) {, +                    throw new IllegalArgumentException("complex setting key: [" + setting.getKey() + "] overlaps existing setting key: [" +, +                        overlappingSetting.getKey() + "]");, +                }, +    private static Setting<?> findOverlappingSetting(Setting<?> newSetting, Map<String, Setting<?>> complexMatchers) {, +        assert newSetting.hasComplexMatcher();, +        if (complexMatchers.containsKey(newSetting.getKey())) {, +            // we return null here because we use a putIfAbsent call when inserting into the map, so if it exists then we already checked, +            // the setting to make sure there are no overlapping settings., +            return null;, +        }, +, +        for (Setting<?> existingSetting : complexMatchers.values()) {, +            if (newSetting.match(existingSetting.getKey()) || existingSetting.match(newSetting.getKey())) {, +                return existingSetting;, +            }, +        }, +        return null;, +    }, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +                Setting<?> overlappingSetting = findOverlappingSetting(setting, complexMatchers);, +                if (overlappingSetting != null) {, +                    throw new IllegalArgumentException("complex setting key: [" + setting.getKey() + "] overlaps existing setting key: [" +, +                        overlappingSetting.getKey() + "]");, +                }, +    private static Setting<?> findOverlappingSetting(Setting<?> newSetting, Map<String, Setting<?>> complexMatchers) {, +        assert newSetting.hasComplexMatcher();, +        if (complexMatchers.containsKey(newSetting.getKey())) {, +            // we return null here because we use a putIfAbsent call when inserting into the map, so if it exists then we already checked, +            // the setting to make sure there are no overlapping settings., +            return null;, +        }, +, +        for (Setting<?> existingSetting : complexMatchers.values()) {, +            if (newSetting.match(existingSetting.getKey()) || existingSetting.match(newSetting.getKey())) {, +                return existingSetting;, +            }, +        }, +        return null;, +    }, +++ b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java, +import java.util.LinkedHashSet;, +import java.util.Set;, +import java.util.function.Function;, +, +    public void testOverlappingComplexMatchSettings() {, +        Set<Setting<?>> settings = new LinkedHashSet<>(2);, +        final boolean groupFirst = randomBoolean();, +        final Setting<?> groupSetting = Setting.groupSetting("foo.", false, Setting.Scope.CLUSTER);, +        final Setting<?> listSetting = Setting.listSetting("foo.bar", Collections.emptyList(), Function.identity(), false,, +            Setting.Scope.CLUSTER);, +        settings.add(groupFirst ? groupSetting : listSetting);, +        settings.add(groupFirst ? listSetting : groupSetting);, +, +        try {, +            new ClusterSettings(Settings.EMPTY, settings);, +            fail("an exception should have been thrown because settings overlap");, +        } catch (IllegalArgumentException e) {, +            if (groupFirst) {, +                assertEquals("complex setting key: [foo.bar] overlaps existing setting key: [foo.]", e.getMessage());, +            } else {, +                assertEquals("complex setting key: [foo.] overlaps existing setting key: [foo.bar]", e.getMessage());, +            }, +        }, +    }]