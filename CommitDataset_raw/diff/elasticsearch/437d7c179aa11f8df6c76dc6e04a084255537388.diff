[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.MergePolicyConfig;, +import org.elasticsearch.index.MergeSchedulerConfig;, +        registerIndexDynamicSetting(IndexSettings.INDEX_GC_DELETES_SETTING, Validator.TIME);, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +        registerIndexDynamicSetting(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, Validator.BYTES_SIZE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.MergePolicyConfig;, +import org.elasticsearch.index.MergeSchedulerConfig;, +        registerIndexDynamicSetting(IndexSettings.INDEX_GC_DELETES_SETTING, Validator.TIME);, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +        registerIndexDynamicSetting(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, Validator.BYTES_SIZE);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.search.stats.SearchSlowLog;, +    private final SearchSlowLog searchSlowLog;, +        searchSlowLog = new SearchSlowLog(indexSettings.getSettings());, +                indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, searchSlowLog); // no indexing listeners - shadow  engines don't index, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, searchSlowLog, listeners);, +    public SearchSlowLog getSearchSlowLog() {, +        return searchSlowLog;, +    }, +, +                    shard.onSettingsChanged();, +                    logger.warn("[{}] failed to notify shard about setting change", e, shard.shardId().id());, +, +            try {, +                searchSlowLog.onRefreshSettings(settings); // this will be refactored soon anyway so duplication is ok here, +            } catch (Exception e) {, +                logger.warn("failed to refresh slowlog settings", e);, +            }, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.MergePolicyConfig;, +import org.elasticsearch.index.MergeSchedulerConfig;, +        registerIndexDynamicSetting(IndexSettings.INDEX_GC_DELETES_SETTING, Validator.TIME);, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +        registerIndexDynamicSetting(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, Validator.BYTES_SIZE);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.search.stats.SearchSlowLog;, +    private final SearchSlowLog searchSlowLog;, +        searchSlowLog = new SearchSlowLog(indexSettings.getSettings());, +                indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, searchSlowLog); // no indexing listeners - shadow  engines don't index, +                indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider, searchSlowLog, listeners);, +    public SearchSlowLog getSearchSlowLog() {, +        return searchSlowLog;, +    }, +, +                    shard.onSettingsChanged();, +                    logger.warn("[{}] failed to notify shard about setting change", e, shard.shardId().id());, +, +            try {, +                searchSlowLog.onRefreshSettings(settings); // this will be refactored soon anyway so duplication is ok here, +            } catch (Exception e) {, +                logger.warn("failed to refresh slowlog settings", e);, +            }, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +import org.apache.lucene.index.MergePolicy;, +import org.elasticsearch.common.unit.ByteSizeUnit;, +import org.elasticsearch.common.unit.ByteSizeValue;, +    public static final String INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE = "index.translog.flush_threshold_size";, +    public static final TimeValue DEFAULT_GC_DELETES = TimeValue.timeValueSeconds(60);, +, +    /**, +     * Index setting to control if a flush is executed before engine is closed, +     * This setting is realtime updateable., +     */, +    public static final String INDEX_FLUSH_ON_CLOSE = "index.flush_on_close";, +    /**, +     * Index setting to enable / disable deletes garbage collection., +     * This setting is realtime updateable, +     */, +    public static final String INDEX_GC_DELETES_SETTING = "index.gc_deletes";, +    private volatile ByteSizeValue flushThresholdSize;, +    private volatile boolean flushOnClose = true;, +    private final MergeSchedulerConfig mergeSchedulerConfig;, +    private final MergePolicyConfig mergePolicyConfig;, +    private long gcDeletesInMillis = DEFAULT_GC_DELETES.millis();, +        flushThresholdSize = settings.getAsBytesSize(INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, new ByteSizeValue(512, ByteSizeUnit.MB));, +        flushOnClose = settings.getAsBoolean(IndexSettings.INDEX_FLUSH_ON_CLOSE, true);, +        mergeSchedulerConfig = new MergeSchedulerConfig(settings);, +        gcDeletesInMillis = settings.getAsTime(IndexSettings.INDEX_GC_DELETES_SETTING, DEFAULT_GC_DELETES).getMillis();, +        this.mergePolicyConfig = new MergePolicyConfig(logger, settings);, +, +        ByteSizeValue flushThresholdSize = settings.getAsBytesSize(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, this.flushThresholdSize);, +        if (!flushThresholdSize.equals(this.flushThresholdSize)) {, +            logger.info("updating flush_threshold_size from [{}] to [{}]", this.flushThresholdSize, flushThresholdSize);, +            this.flushThresholdSize = flushThresholdSize;, +        final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, this.flushOnClose);, +        if (flushOnClose != this.flushOnClose) {, +            logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, this.flushOnClose, flushOnClose);, +            this.flushOnClose = flushOnClose;, +        }, +, +        final int maxThreadCount = settings.getAsInt(MergeSchedulerConfig.MAX_THREAD_COUNT, mergeSchedulerConfig.getMaxThreadCount());, +        if (maxThreadCount != mergeSchedulerConfig.getMaxThreadCount()) {, +            logger.info("updating [{}] from [{}] to [{}]", MergeSchedulerConfig.MAX_THREAD_COUNT, mergeSchedulerConfig.getMaxMergeCount(), maxThreadCount);, +            mergeSchedulerConfig.setMaxThreadCount(maxThreadCount);, +        }, +, +        final int maxMergeCount = settings.getAsInt(MergeSchedulerConfig.MAX_MERGE_COUNT, mergeSchedulerConfig.getMaxMergeCount());, +        if (maxMergeCount != mergeSchedulerConfig.getMaxMergeCount()) {]