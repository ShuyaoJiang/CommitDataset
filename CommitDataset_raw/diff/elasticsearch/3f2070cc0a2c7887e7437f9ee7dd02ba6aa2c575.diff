[+++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    public WatcherLifeCycleService(Settings settings, ClusterService clusterService, ThreadPool threadPool, WatcherService watcherService) {, +        clusterService.addLifecycleListener(new LifecycleListener() {, +++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    public WatcherLifeCycleService(Settings settings, ClusterService clusterService, ThreadPool threadPool, WatcherService watcherService) {, +        clusterService.addLifecycleListener(new LifecycleListener() {, +++ b/src/main/java/org/elasticsearch/watcher/history/HistoryStore.java, +import com.google.common.collect.ImmutableSet;, +import org.elasticsearch.cluster.settings.ClusterDynamicSettings;, +import org.elasticsearch.cluster.settings.DynamicSettings;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.node.settings.NodeSettingsService;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.*;, +public class HistoryStore extends AbstractComponent implements NodeSettingsService.Listener {, +    private static final ImmutableSet<String> forbiddenIndexSettings = ImmutableSet.of("index.mapper.dynamic");, +    private final ThreadPool threadPool;, +    private volatile Settings customIndexSettings = ImmutableSettings.EMPTY;, +, +    public HistoryStore(Settings settings, ClientProxy client, TemplateUtils templateUtils, WatchRecord.Parser recordParser,, +                        NodeSettingsService nodeSettingsService, @ClusterDynamicSettings DynamicSettings dynamicSettings,, +                        ThreadPool threadPool) {, +        this.threadPool = threadPool;, +, +        updateHistorySettings(settings, false);, +        nodeSettingsService.addListener(this);, +        dynamicSettings.addDynamicSetting("watcher.history.index.*");, +    @Override, +    public void onRefreshSettings(Settings settings) {, +        updateHistorySettings(settings, true);, +    }, +, +    private void updateHistorySettings(Settings settings, boolean updateIndexTemplate) {, +        Settings newSettings = ImmutableSettings.builder(), +                .put(settings.getAsSettings("watcher.history.index")), +                .build();, +        if (newSettings.names().isEmpty()) {, +            return;, +        }, +, +        boolean changed = false;, +        ImmutableSettings.Builder builder = ImmutableSettings.builder().put(customIndexSettings);, +, +        for (Map.Entry<String, String> entry : newSettings.getAsMap().entrySet()) {, +            String name = "index." + entry.getKey();, +            if (forbiddenIndexSettings.contains(name)) {, +                logger.warn("overriding the default [{}} setting is forbidden. ignoring...", name);, +                continue;, +            }, +, +            String newValue = entry.getValue();, +            String currentValue = customIndexSettings.get(name);, +            if (!newValue.equals(currentValue)) {, +                changed = true;, +                builder.put(name, newValue);, +                logger.info("changing setting [{}] from [{}] to [{}]", name, currentValue, newValue);, +            }, +        }, +, +        if (changed) {, +            customIndexSettings = builder.build();, +            if (updateIndexTemplate) {, +                // Need to fork to prevent dead lock. (We're on the cluster service update task, but the put index template, +                // needs to update the cluster state too, and because the update takes is a single threaded operation,, +                // we would then be stuck), +                threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        templateUtils.putTemplate(INDEX_TEMPLATE_NAME, customIndexSettings);, +                    }, +                });, +            }, +        }, +    }, +, +, +            templateUtils.putTemplate(INDEX_TEMPLATE_NAME, customIndexSettings);, +        templateUtils.putTemplate(INDEX_TEMPLATE_NAME, customIndexSettings);, +++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    public WatcherLifeCycleService(Settings settings, ClusterService clusterService, ThreadPool threadPool, WatcherService watcherService) {, +        clusterService.addLifecycleListener(new LifecycleListener() {, +++ b/src/main/java/org/elasticsearch/watcher/history/HistoryStore.java, +import com.google.common.collect.ImmutableSet;, +import org.elasticsearch.cluster.settings.ClusterDynamicSettings;, +import org.elasticsearch.cluster.settings.DynamicSettings;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.node.settings.NodeSettingsService;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.*;, +public class HistoryStore extends AbstractComponent implements NodeSettingsService.Listener {, +    private static final ImmutableSet<String> forbiddenIndexSettings = ImmutableSet.of("index.mapper.dynamic");, +    private final ThreadPool threadPool;, +    private volatile Settings customIndexSettings = ImmutableSettings.EMPTY;, +, +    public HistoryStore(Settings settings, ClientProxy client, TemplateUtils templateUtils, WatchRecord.Parser recordParser,, +                        NodeSettingsService nodeSettingsService, @ClusterDynamicSettings DynamicSettings dynamicSettings,, +                        ThreadPool threadPool) {, +        this.threadPool = threadPool;, +, +        updateHistorySettings(settings, false);]