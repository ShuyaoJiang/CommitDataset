[+++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +                copyCheckpointTo(commitCheckpoint);, +        }, +        return foundTranslogs;, +    }, +, +    private void copyCheckpointTo(Path targetPath) throws IOException {, +        // a temp file to copy checkpoint to - note it must be in on the same FS otherwise atomic move won't work, +        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, CHECKPOINT_SUFFIX);, +        boolean tempFileRenamed = false;, +, +        try {, +            // we first copy this into the temp-file and then fsync it followed by an atomic move into the target file, +            // that way if we hit a disk-full here we are still in an consistent state., +            Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING);, +            IOUtils.fsync(tempFile, false);, +            Files.move(tempFile, targetPath, StandardCopyOption.ATOMIC_MOVE);, +            tempFileRenamed = true;, +            // we only fsync the directory the tempFile was already fsynced, +            IOUtils.fsync(targetPath.getParent(), true);, +        } finally {, +                assert Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME)).generation == current.getGeneration();, +                copyCheckpointTo(location.resolve(getCommitCheckpointFileName(current.getGeneration())));, +++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +                copyCheckpointTo(commitCheckpoint);, +        }, +        return foundTranslogs;, +    }, +, +    private void copyCheckpointTo(Path targetPath) throws IOException {, +        // a temp file to copy checkpoint to - note it must be in on the same FS otherwise atomic move won't work, +        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, CHECKPOINT_SUFFIX);, +        boolean tempFileRenamed = false;, +, +        try {, +            // we first copy this into the temp-file and then fsync it followed by an atomic move into the target file, +            // that way if we hit a disk-full here we are still in an consistent state., +            Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING);, +            IOUtils.fsync(tempFile, false);, +            Files.move(tempFile, targetPath, StandardCopyOption.ATOMIC_MOVE);, +            tempFileRenamed = true;, +            // we only fsync the directory the tempFile was already fsynced, +            IOUtils.fsync(targetPath.getParent(), true);, +        } finally {, +                assert Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME)).generation == current.getGeneration();, +                copyCheckpointTo(location.resolve(getCommitCheckpointFileName(current.getGeneration())));, +++ b/server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +import org.apache.lucene.mockfile.FilterFileSystemProvider;, +import java.nio.file.CopyOption;, +, +    public void testCrashDuringCheckpointCopy() throws IOException {, +        final Path path = createTempDir();, +        final AtomicBoolean failOnCopy = new AtomicBoolean();, +        final String expectedExceptionMessage = "simulated failure during copy";, +        final FilterFileSystemProvider filterFileSystemProvider, +            = new FilterFileSystemProvider(path.getFileSystem().provider().getScheme(), path.getFileSystem()) {, +, +            @Override, +            public void copy(Path source, Path target, CopyOption... options) throws IOException {, +                if (failOnCopy.get() && source.toString().endsWith(Translog.CHECKPOINT_SUFFIX)) {, +                    deleteIfExists(target);, +                    Files.createFile(target);, +                    throw new IOException(expectedExceptionMessage);, +                } else {, +                    super.copy(source, target, options);, +                }, +            }, +        };, +, +        try (Translog brokenTranslog = create(filterFileSystemProvider.getPath(path.toUri()))) {, +            failOnCopy.set(true);, +            assertThat(expectThrows(IOException.class, brokenTranslog::rollGeneration).getMessage(), equalTo(expectedExceptionMessage));, +            assertFalse(brokenTranslog.isOpen());, +, +            try (Translog recoveredTranslog = new Translog(getTranslogConfig(path), brokenTranslog.getTranslogUUID(),, +                brokenTranslog.getDeletionPolicy(), () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {, +                recoveredTranslog.rollGeneration();, +                assertFilePresences(recoveredTranslog);, +            }, +        }, +    }]