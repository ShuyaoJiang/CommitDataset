[+++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +import java.util.ArrayList;, +import java.util.IdentityHashMap;, +import java.util.Map;, +        final Map<Directory, Collection<String>> perDirectory = new IdentityHashMap<>();, +        for (String name : names) {, +            final Directory dir = getDirectory(name);, +            Collection<String> dirNames = perDirectory.get(dir);, +            if (dirNames == null) {, +                dirNames = new ArrayList<>();, +                perDirectory.put(dir, dirNames);, +            }, +            dirNames.add(name);, +        }, +        for (Map.Entry<Directory, Collection<String>> entry : perDirectory.entrySet()) {, +            final Directory dir = entry.getKey();, +            final Collection<String> dirNames = entry.getValue();, +            dir.sync(dirNames);, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +import java.util.ArrayList;, +import java.util.IdentityHashMap;, +import java.util.Map;, +        final Map<Directory, Collection<String>> perDirectory = new IdentityHashMap<>();, +        for (String name : names) {, +            final Directory dir = getDirectory(name);, +            Collection<String> dirNames = perDirectory.get(dir);, +            if (dirNames == null) {, +                dirNames = new ArrayList<>();, +                perDirectory.put(dir, dirNames);, +            }, +            dirNames.add(name);, +        }, +        for (Map.Entry<Directory, Collection<String>> entry : perDirectory.entrySet()) {, +            final Directory dir = entry.getKey();, +            final Collection<String> dirNames = entry.getValue();, +            dir.sync(dirNames);, +++ b/src/test/java/org/elasticsearch/index/store/DistributorDirectoryTest.java, +import com.carrotsearch.randomizedtesting.generators.RandomInts;, +import com.google.common.collect.ImmutableSet;, +, +import java.util.Collection;, +import java.util.HashSet;, +import java.util.Set;, +, +    public void testSync() throws IOException {, +        final Set<String> syncedFiles = new HashSet<>();, +        final Directory[] directories = new Directory[RandomInts.randomIntBetween(random(), 1, 5)];, +        for (int i = 0; i < directories.length; ++i) {, +            final Directory dir = newDirectory();, +            directories[i] = new FilterDirectory(dir) {, +                @Override, +                public void sync(Collection<String> names) throws IOException {, +                    super.sync(names);, +                    syncedFiles.addAll(names);, +                }, +            };, +        }, +, +        final Directory directory = new DistributorDirectory(directories);, +, +        for (String file : Arrays.asList("a.bin", "b.bin")) {, +            try (IndexOutput out = directory.createOutput(file, IOContext.DEFAULT)) {, +                out.writeInt(random().nextInt());, +            }, +        }, +, +        // syncing on a missing file throws an exception, +        try {, +            directory.sync(Arrays.asList("a.bin", "c.bin"));, +        } catch (FileNotFoundException e) {, +            // expected, +        }, +        assertEquals(ImmutableSet.of(), syncedFiles);, +, +        // but syncing on existing files actually delegates, +        directory.sync(Arrays.asList("a.bin", "b.bin"));, +        assertEquals(ImmutableSet.of("a.bin", "b.bin"), syncedFiles);, +, +        directory.close();, +    }]