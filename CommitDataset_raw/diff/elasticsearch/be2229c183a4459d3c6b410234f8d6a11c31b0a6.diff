[+++ b/src/main/java/org/elasticsearch/discovery/zen/ping/ZenPing.java, +        /** the number of nodes for which there are known pings */, +        public synchronized int size() {, +            return pings.size();, +        }, +++ b/src/main/java/org/elasticsearch/discovery/zen/ping/ZenPing.java, +        /** the number of nodes for which there are known pings */, +        public synchronized int size() {, +            return pings.size();, +        }, +++ b/src/main/java/org/elasticsearch/discovery/zen/ping/multicast/MulticastZenPing.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +        threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2), ThreadPool.Names.GENERIC, new AbstractRunnable() {, +            public void onFailure(Throwable t) {, +                logger.warn("[{}] failed to send second ping request", t, id);, +                finalizePingCycle(id, listener);, +, +            @Override, +            public void doRun() {, +                sendPingRequest(id);, +                threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2), ThreadPool.Names.GENERIC, new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.warn("[{}] failed to send third ping request", t, id);, +                        finalizePingCycle(id, listener);, +                    }, +, +                    @Override, +                    public void doRun() {, +                        // make one last ping, but finalize as soon as all nodes have responded or a timeout has past, +                        PingCollection collection = receivedResponses.get(id);, +                        FinalizingPingCollection finalizingPingCollection = new FinalizingPingCollection(id, collection, collection.size(), listener);, +                        receivedResponses.put(id, finalizingPingCollection);, +                        logger.trace("[{}] sending last pings", id);, +                        sendPingRequest(id);, +                        threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 4), ThreadPool.Names.GENERIC, new AbstractRunnable() {, +                            @Override, +                            public void onFailure(Throwable t) {, +                                logger.warn("[{}] failed to finalize ping", t, id);, +                            }, +, +                            @Override, +                            protected void doRun() throws Exception {, +                                finalizePingCycle(id, listener);, +                    }, +                });, +            }, +        });, +, +    }, +, +    /**, +     * takes all pings collected for a given id and pass them to the given listener., +     * this method is safe to call multiple times as is guaranteed to only finalize once., +     */, +    private void finalizePingCycle(int id, final PingListener listener) {, +        if (responses != null) {, +    class FinalizingPingCollection extends PingCollection {, +        final private PingCollection internalCollection;, +        final private int expectedResponses;, +        final private AtomicInteger responseCount;, +        final private PingListener listener;, +        final private int id;, +, +        public FinalizingPingCollection(int id, PingCollection internalCollection, int expectedResponses, PingListener listener) {, +            this.id = id;, +            this.internalCollection = internalCollection;, +            this.expectedResponses = expectedResponses;, +            this.responseCount = new AtomicInteger();, +            this.listener = listener;, +        }, +, +        @Override, +        public synchronized boolean addPing(PingResponse ping) {, +            if (internalCollection.addPing(ping)) {, +                if (responseCount.incrementAndGet() >= expectedResponses) {, +                    logger.trace("[{}] all nodes responded", id);, +                    finish();, +                }, +                return true;, +            }, +            return false;, +        }, +, +        @Override, +        public synchronized void addPings(PingResponse[] pings) {, +            internalCollection.addPings(pings);, +        }, +, +        @Override, +        public synchronized PingResponse[] toArray() {, +            return internalCollection.toArray();, +        }, +, +        void finish() {, +            // spawn another thread as we may be running on a network thread, +            threadPool.generic().execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Throwable t) {, +                    logger.error("failed to call ping listener", t);]