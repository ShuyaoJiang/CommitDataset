[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        samMethodType = adapt(interfaceMethodType, impl.getMethodType().dropParameterTypes(0, captures.length));, +        samMethodType = adapt(interfaceMethodType, impl.type().dropParameterTypes(0, captures.length));, +    , +    /** , +     * If the interface expects a primitive type to be returned, we can't return Object,, +     * But we can set SAM to the wrapper version, and a cast will take place , +     */, +    private static MethodType adapt(MethodType expected, MethodType actual) {, +        if (expected.returnType().isPrimitive() && actual.returnType() == Object.class) {, +            actual = actual.changeReturnType(MethodType.methodType(expected.returnType()).wrap().returnType());, +        }, +        return actual;, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        samMethodType = adapt(interfaceMethodType, impl.getMethodType().dropParameterTypes(0, captures.length));, +        samMethodType = adapt(interfaceMethodType, impl.type().dropParameterTypes(0, captures.length));, +    , +    /** , +     * If the interface expects a primitive type to be returned, we can't return Object,, +     * But we can set SAM to the wrapper version, and a cast will take place , +     */, +    private static MethodType adapt(MethodType expected, MethodType actual) {, +        if (expected.returnType().isPrimitive() && actual.returnType() == Object.class) {, +            actual = actual.changeReturnType(MethodType.methodType(expected.returnType()).wrap().returnType());, +        }, +        return actual;, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +    private int syntheticCounter = 0;, +                paramTypes.add("def");, +        String name = nextLambda();, +        synthetic.add(new SFunction((FunctionReserved)reserved.pop(), location(ctx), "def", name, , +                      paramTypes, paramNames, statements, true));, +        return new EFunctionRef(location(ctx), "this", name);, +        // TODO: use a real node for captures and shit, +            String name = nextLambda();, +    , +    /** Returns name of next lambda */, +    private String nextLambda() {, +        return "lambda$" + syntheticCounter++;, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        samMethodType = adapt(interfaceMethodType, impl.getMethodType().dropParameterTypes(0, captures.length));, +        samMethodType = adapt(interfaceMethodType, impl.type().dropParameterTypes(0, captures.length));, +    , +    /** , +     * If the interface expects a primitive type to be returned, we can't return Object,, +     * But we can set SAM to the wrapper version, and a cast will take place , +     */, +    private static MethodType adapt(MethodType expected, MethodType actual) {, +        if (expected.returnType().isPrimitive() && actual.returnType() == Object.class) {, +            actual = actual.changeReturnType(MethodType.methodType(expected.returnType()).wrap().returnType());, +        }, +        return actual;, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +    private int syntheticCounter = 0;, +                paramTypes.add("def");, +        String name = nextLambda();, +        synthetic.add(new SFunction((FunctionReserved)reserved.pop(), location(ctx), "def", name, , +                      paramTypes, paramNames, statements, true));, +        return new EFunctionRef(location(ctx), "this", name);, +        // TODO: use a real node for captures and shit, +            String name = nextLambda();, +    , +    /** Returns name of next lambda */, +    private String nextLambda() {, +        return "lambda$" + syntheticCounter++;, +    }, +++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        samMethodType = adapt(interfaceMethodType, impl.getMethodType().dropParameterTypes(0, captures.length));, +        samMethodType = adapt(interfaceMethodType, impl.type().dropParameterTypes(0, captures.length));, +    , +    /** , +     * If the interface expects a primitive type to be returned, we can't return Object,, +     * But we can set SAM to the wrapper version, and a cast will take place , +     */, +    private static MethodType adapt(MethodType expected, MethodType actual) {, +        if (expected.returnType().isPrimitive() && actual.returnType() == Object.class) {, +            actual = actual.changeReturnType(MethodType.methodType(expected.returnType()).wrap().returnType());, +        }, +        return actual;, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +    private int syntheticCounter = 0;, +                paramTypes.add("def");, +        String name = nextLambda();, +        synthetic.add(new SFunction((FunctionReserved)reserved.pop(), location(ctx), "def", name, , +                      paramTypes, paramNames, statements, true));, +        return new EFunctionRef(location(ctx), "this", name);, +        // TODO: use a real node for captures and shit, +            String name = nextLambda();, +    , +    /** Returns name of next lambda */, +    private String nextLambda() {, +        return "lambda$" + syntheticCounter++;, +    }, +++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java]