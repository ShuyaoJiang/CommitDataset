[+++ b/pom.xml, +            <version>2.1.10</version>, +++ b/pom.xml, +            <version>2.1.10</version>, +++ b/src/test/java/org/elasticsearch/test/CompositeTestCluster.java, +        super(cluster.seed());, +++ b/pom.xml, +            <version>2.1.10</version>, +++ b/src/test/java/org/elasticsearch/test/CompositeTestCluster.java, +        super(cluster.seed());, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchBackwardsCompatIntegrationTest.java, +    protected TestCluster buildTestCluster(Scope scope, long seed) throws IOException {, +        TestCluster cluster = super.buildTestCluster(scope, seed);, +++ b/pom.xml, +            <version>2.1.10</version>, +++ b/src/test/java/org/elasticsearch/test/CompositeTestCluster.java, +        super(cluster.seed());, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchBackwardsCompatIntegrationTest.java, +    protected TestCluster buildTestCluster(Scope scope, long seed) throws IOException {, +        TestCluster cluster = super.buildTestCluster(scope, seed);, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +import com.carrotsearch.randomizedtesting.Randomness;, +    private static Long SUITE_SEED = null;, +        SUITE_SEED = randomLong();, +    protected final void beforeInternal() throws Exception {, +                    currentCluster = buildAndPutCluster(currentClusterScope, SeedUtils.parseSeed(RandomizedContext.current().getRunnerSeedAsString()));, +                    assert SUITE_SEED != null : "Suite seed was not initialized";, +                    currentCluster = buildAndPutCluster(currentClusterScope, SUITE_SEED.longValue());, +                    currentCluster = buildAndPutCluster(currentClusterScope, randomLong());, +    private TestCluster buildWithPrivateContext(final Scope scope, final long seed) throws Exception {, +        return RandomizedContext.current().runWithPrivateRandomness(new Randomness(seed), new Callable<TestCluster>() {, +            @Override, +            public TestCluster call() throws Exception {, +                return buildTestCluster(scope, seed);, +        });, +    }, +, +    private TestCluster buildAndPutCluster(Scope currentClusterScope, long seed) throws Exception {, +        final Class<?> clazz = this.getClass();, +        TestCluster testCluster = clusters.remove(clazz); // remove this cluster first, +        clearClusters(); // all leftovers are gone by now... this is really just a double safety if we miss something somewhere, +        switch (currentClusterScope) {, +            case GLOBAL:, +                // never put the global cluster into the map otherwise it will be closed, +                if (GLOBAL_CLUSTER == null) {, +                    return GLOBAL_CLUSTER = buildWithPrivateContext(currentClusterScope, seed);, +                }, +                return GLOBAL_CLUSTER;, +            case SUITE:, +                if (testCluster == null) { // only build if it's not there yet, +                    testCluster = buildWithPrivateContext(currentClusterScope, seed);, +                }, +                break;, +            case TEST:, +                // close the previous one and create a new one, +                IOUtils.closeWhileHandlingException(testCluster);, +                testCluster = buildTestCluster(currentClusterScope, seed);, +                break;, +        }, +        assert testCluster != GLOBAL_CLUSTER : "Global cluster must be handled via the GLOBAL_CLUSTER static member";, +        clusters.put(clazz, testCluster);, +    protected final void afterInternal() throws Exception {, +                        IOUtils.closeWhileHandlingException(GLOBAL_CLUSTER);, +    protected TestCluster buildTestCluster(Scope scope, long seed) throws IOException {, +        int numClientNodes = InternalTestCluster.DEFAULT_NUM_CLIENT_NODES;, +        boolean enableRandomBenchNodes = InternalTestCluster.DEFAULT_ENABLE_RANDOM_BENCH_NODES;, +        int minNumDataNodes = InternalTestCluster.DEFAULT_MIN_NUM_DATA_NODES;, +        int maxNumDataNodes = InternalTestCluster.DEFAULT_MAX_NUM_DATA_NODES;, +        SettingsSource settingsSource = InternalTestCluster.DEFAULT_SETTINGS_SOURCE;, +        final String nodePrefix;, +        switch (scope) {, +            case GLOBAL:, +                if (globalCompatibilityVersion().before(Version.V_1_2_0)) {, +                    numClientNodes = 0;, +                }, +                nodePrefix = GLOBAL_CLUSTER_NODE_PREFIX;, +                break;, +            case TEST:, +                nodePrefix = TEST_CLUSTER_NODE_PREFIX;, +                break;, +            case SUITE:, +                nodePrefix = SUITE_CLUSTER_NODE_PREFIX;, +                break;, +            default:, +                throw new ElasticsearchException("Scope not supported: " + scope);, +        }, +        if (scope == Scope.GLOBAL) {, +            String cluster = System.getProperty(TESTS_CLUSTER);, +            if (Strings.hasLength(cluster)) {, +                String[] stringAddresses = cluster.split(",");, +                TransportAddress[] transportAddresses = new TransportAddress[stringAddresses.length];, +                int i = 0;, +                for (String stringAddress : stringAddresses) {, +                    String[] split = stringAddress.split(":");, +                    if (split.length < 2) {, +                        throw new IllegalArgumentException("address [" + cluster + "] not valid");, +                    }, +                    try {, +                        transportAddresses[i++] = new InetSocketTransportAddress(split[0], Integer.valueOf(split[1]));, +                    } catch (NumberFormatException e) {]