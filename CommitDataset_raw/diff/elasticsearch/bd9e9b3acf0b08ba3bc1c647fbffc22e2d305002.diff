[+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentSubParser.java, + * Wrapper for a XContentParser that makes a single object/array look like a complete document., +        if (parser.currentToken() != Token.START_OBJECT && parser.currentToken() != Token.START_ARRAY) {, +            throw new IllegalStateException("The sub parser has to be created on the start of an object or array");, +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentSubParser.java, + * Wrapper for a XContentParser that makes a single object/array look like a complete document., +        if (parser.currentToken() != Token.START_OBJECT && parser.currentToken() != Token.START_ARRAY) {, +            throw new IllegalStateException("The sub parser has to be created on the start of an object or array");, +++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/XContentParserTests.java, +    public void testSubParserObject() throws IOException {, +, +    public void testSubParserArray() throws IOException {, +        XContentBuilder builder = XContentFactory.jsonBuilder();, +        int numberOfArrayElements = randomInt(10);, +        builder.startObject();, +        builder.field("array");, +        builder.startArray();, +        int numberOfTokens = 0;, +        for (int i = 0; i < numberOfArrayElements; ++i) {, +            numberOfTokens += generateRandomObjectForMarking(builder);, +        }, +        builder.endArray();, +        builder.endObject();, +, +        String content = Strings.toString(builder);, +, +        try (XContentParser parser = createParser(JsonXContent.jsonXContent, content)) {, +            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());, +            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken()); // array field, +            assertEquals("array", parser.currentName());, +            assertEquals(XContentParser.Token.START_ARRAY, parser.nextToken()); // [, +            XContentParser subParser = new XContentSubParser(parser);, +            try {, +                int tokensToSkip = randomInt(numberOfTokens - 1);, +                for (int i = 0; i < tokensToSkip; i++) {, +                    // Simulate incomplete parsing, +                    assertNotNull(subParser.nextToken());, +                }, +                if (randomBoolean()) {, +                    // And sometimes skipping children, +                    subParser.skipChildren();, +                }, +, +            }  finally {, +                assertFalse(subParser.isClosed());, +                subParser.close();, +                assertTrue(subParser.isClosed());, +            }, +            assertEquals(XContentParser.Token.END_ARRAY, parser.currentToken());, +            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());, +            assertNull(parser.nextToken());, +        }, +    }, +, +            assertEquals("The sub parser has to be created on the start of an object or array", exception.getMessage());, +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentSubParser.java, + * Wrapper for a XContentParser that makes a single object/array look like a complete document., +        if (parser.currentToken() != Token.START_OBJECT && parser.currentToken() != Token.START_ARRAY) {, +            throw new IllegalStateException("The sub parser has to be created on the start of an object or array");, +++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/XContentParserTests.java, +    public void testSubParserObject() throws IOException {, +, +    public void testSubParserArray() throws IOException {, +        XContentBuilder builder = XContentFactory.jsonBuilder();, +        int numberOfArrayElements = randomInt(10);, +        builder.startObject();, +        builder.field("array");, +        builder.startArray();, +        int numberOfTokens = 0;, +        for (int i = 0; i < numberOfArrayElements; ++i) {, +            numberOfTokens += generateRandomObjectForMarking(builder);, +        }, +        builder.endArray();, +        builder.endObject();, +, +        String content = Strings.toString(builder);, +, +        try (XContentParser parser = createParser(JsonXContent.jsonXContent, content)) {, +            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());, +            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken()); // array field, +            assertEquals("array", parser.currentName());, +            assertEquals(XContentParser.Token.START_ARRAY, parser.nextToken()); // [, +            XContentParser subParser = new XContentSubParser(parser);, +            try {, +                int tokensToSkip = randomInt(numberOfTokens - 1);, +                for (int i = 0; i < tokensToSkip; i++) {, +                    // Simulate incomplete parsing, +                    assertNotNull(subParser.nextToken());, +                }, +                if (randomBoolean()) {, +                    // And sometimes skipping children, +                    subParser.skipChildren();, +                }, +, +            }  finally {, +                assertFalse(subParser.isClosed());, +                subParser.close();, +                assertTrue(subParser.isClosed());, +            }, +            assertEquals(XContentParser.Token.END_ARRAY, parser.currentToken());]