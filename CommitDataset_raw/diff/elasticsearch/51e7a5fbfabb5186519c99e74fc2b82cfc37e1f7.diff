[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    retentionLeases, sendSnapshotStep);, +        logger.trace("recovery [phase2]: sending transaction log operations (from [" + startingSeqNo + "] to [" + endingSeqNo + "]");, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    retentionLeases, sendSnapshotStep);, +        logger.trace("recovery [phase2]: sending transaction log operations (from [" + startingSeqNo + "] to [" + endingSeqNo + "]");, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +        final long endingSeqNo = randomLongBetween(startingSeqNo, numberOfDocsWithValidSequenceNumbers - 1);, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(operations, Collections.emptyList()),, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(ops, Collections.emptyList()),, +            void phase2(long startingSeqNo, long endingSeqNo, Translog.Snapshot snapshot,, +                super.phase2(startingSeqNo, endingSeqNo, snapshot,, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    retentionLeases, sendSnapshotStep);, +        logger.trace("recovery [phase2]: sending transaction log operations (from [" + startingSeqNo + "] to [" + endingSeqNo + "]");, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +        final long endingSeqNo = randomLongBetween(startingSeqNo, numberOfDocsWithValidSequenceNumbers - 1);, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(operations, Collections.emptyList()),, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(ops, Collections.emptyList()),, +            void phase2(long startingSeqNo, long endingSeqNo, Translog.Snapshot snapshot,, +                super.phase2(startingSeqNo, endingSeqNo, snapshot,, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +    /**, +     * Waits for all operations up to the provided sequence number to complete in the given internal engine., +     *, +     * @param seqNo the sequence number that the checkpoint must advance to before this method returns, +     * @throws InterruptedException if the thread was interrupted while blocking on the condition, +     */, +    public static void waitForOpsToComplete(InternalEngine engine, long seqNo) throws InterruptedException {, +        engine.getLocalCheckpointTracker().waitForOpsToComplete(seqNo);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    retentionLeases, sendSnapshotStep);, +        logger.trace("recovery [phase2]: sending transaction log operations (from [" + startingSeqNo + "] to [" + endingSeqNo + "]");, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +        final long endingSeqNo = randomLongBetween(startingSeqNo, numberOfDocsWithValidSequenceNumbers - 1);, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(operations, Collections.emptyList()),, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(ops, Collections.emptyList()),, +            void phase2(long startingSeqNo, long endingSeqNo, Translog.Snapshot snapshot,, +                super.phase2(startingSeqNo, endingSeqNo, snapshot,, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +    /**, +     * Waits for all operations up to the provided sequence number to complete in the given internal engine., +     *, +     * @param seqNo the sequence number that the checkpoint must advance to before this method returns, +     * @throws InterruptedException if the thread was interrupted while blocking on the condition, +     */, +    public static void waitForOpsToComplete(InternalEngine engine, long seqNo) throws InterruptedException {, +        engine.getLocalCheckpointTracker().waitForOpsToComplete(seqNo);, +    }, +, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/IndexFollowingIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    retentionLeases, sendSnapshotStep);, +        logger.trace("recovery [phase2]: sending transaction log operations (from [" + startingSeqNo + "] to [" + endingSeqNo + "]");, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +        final long endingSeqNo = randomLongBetween(startingSeqNo, numberOfDocsWithValidSequenceNumbers - 1);, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(operations, Collections.emptyList()),, +        handler.phase2(startingSeqNo, endingSeqNo, newTranslogSnapshot(ops, Collections.emptyList()),, +            void phase2(long startingSeqNo, long endingSeqNo, Translog.Snapshot snapshot,, +                super.phase2(startingSeqNo, endingSeqNo, snapshot,, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +    /**, +     * Waits for all operations up to the provided sequence number to complete in the given internal engine.]