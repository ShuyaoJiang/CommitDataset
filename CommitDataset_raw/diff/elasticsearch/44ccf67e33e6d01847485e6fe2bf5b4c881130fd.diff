[+++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +        this(new BytesRef(bytes));, +            bytesRef = BytesRef.deepCopyOf(bytesRef);, +        }, +        this(bytes, 0, bytes.length);, +, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +        this(new BytesRef(bytes));, +            bytesRef = BytesRef.deepCopyOf(bytesRef);, +        }, +        this(bytes, 0, bytes.length);, +, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import java.io.InputStream;, +    public StreamInput streamInput() throws IOException {, +        return new MarkSupportingStreamInputWrapper(this);, +, +    /**, +     * Instead of adding the complexity of {@link InputStream#reset()} etc to the actual impl, +     * this wrapper builds it on top of the BytesReferenceStreamInput which is much simpler, +     * that way., +     */, +    private static final class MarkSupportingStreamInputWrapper extends StreamInput {, +        private final BytesReference reference;, +        private BytesReferenceStreamInput input;, +        private int mark = 0;, +, +        private MarkSupportingStreamInputWrapper(BytesReference reference) throws IOException {, +            this.reference = reference;, +            this.input = new BytesReferenceStreamInput(reference.iterator(), reference.length());, +        }, +, +        @Override, +        public byte readByte() throws IOException {, +            return input.readByte();, +        }, +, +        @Override, +        public void readBytes(byte[] b, int offset, int len) throws IOException {, +            input.readBytes(b, offset, len);, +        }, +, +        @Override, +        public int read(byte[] b, int off, int len) throws IOException {, +            return input.read(b, off, len);, +        }, +, +        @Override, +        public void close() throws IOException {, +            input.close();, +        }, +, +        @Override, +        public int read() throws IOException {, +            return input.read();, +        }, +, +        @Override, +        public int available() throws IOException {, +            return input.available();, +        }, +, +        @Override, +        public void reset() throws IOException {, +            input = new BytesReferenceStreamInput(reference.iterator(), reference.length());, +            input.skip(mark);, +        }, +, +        @Override, +        public boolean markSupported() {, +            return true;, +        }, +, +        @Override, +        public void mark(int readLimit) {, +            // readLimit is optional it only guarantees that the stream remembers data upto this limit but it can remember more, +            // which we do in our case, +            this.mark = input.getOffset();, +        }, +, +        @Override, +        public long skip(long n) throws IOException {, +            return input.skip(n);, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +        this(new BytesRef(bytes));, +            bytesRef = BytesRef.deepCopyOf(bytesRef);, +        }, +        this(bytes, 0, bytes.length);, +, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import java.io.InputStream;, +    public StreamInput streamInput() throws IOException {, +        return new MarkSupportingStreamInputWrapper(this);, +, +    /**, +     * Instead of adding the complexity of {@link InputStream#reset()} etc to the actual impl, +     * this wrapper builds it on top of the BytesReferenceStreamInput which is much simpler, +     * that way.]