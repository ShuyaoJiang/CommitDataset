[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +            precommitTasks.add(configureLoggerUsage(project)), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +            precommitTasks.add(configureLoggerUsage(project)), +++ b/test/logger-usage/build.gradle, +  compile "org.apache.logging.log4j:log4j-api:${versions.log4j}", +loggerUsageCheck.enabled = false, +, +thirdPartyAudit.excludes = [, +  // log4j, +  'org.osgi.framework.AdaptPermission',, +  'org.osgi.framework.AdminPermission',, +  'org.osgi.framework.Bundle',, +  'org.osgi.framework.BundleActivator',, +  'org.osgi.framework.BundleContext',, +  'org.osgi.framework.BundleEvent',, +  'org.osgi.framework.SynchronousBundleListener',, +  'org.osgi.framework.wiring.BundleWire',, +  'org.osgi.framework.wiring.BundleWiring', +], +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +            precommitTasks.add(configureLoggerUsage(project)), +++ b/test/logger-usage/build.gradle, +  compile "org.apache.logging.log4j:log4j-api:${versions.log4j}", +loggerUsageCheck.enabled = false, +, +thirdPartyAudit.excludes = [, +  // log4j, +  'org.osgi.framework.AdaptPermission',, +  'org.osgi.framework.AdminPermission',, +  'org.osgi.framework.Bundle',, +  'org.osgi.framework.BundleActivator',, +  'org.osgi.framework.BundleContext',, +  'org.osgi.framework.BundleEvent',, +  'org.osgi.framework.SynchronousBundleListener',, +  'org.osgi.framework.wiring.BundleWire',, +  'org.osgi.framework.wiring.BundleWiring', +], +++ b/test/logger-usage/src/main/java/org/elasticsearch/test/loggerusage/ESLoggerUsageChecker.java, +import org.apache.logging.log4j.Logger;, +import org.apache.logging.log4j.Marker;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +    public static final Type LOGGER_CLASS = Type.getType(Logger.class);, +    public static final Type THROWABLE_CLASS = Type.getType(Throwable.class);, +    public static final Type STRING_CLASS = Type.getType(String.class);, +    public static final Type STRING_ARRAY_CLASS = Type.getType(String[].class);, +    public static final Type PARAMETERIZED_MESSAGE_CLASS = Type.getType(ParameterizedMessage.class);, +    public static final Type OBJECT_CLASS = Type.getType(Object.class);, +    public static final Type OBJECT_ARRAY_CLASS = Type.getType(Object[].class);, +    public static final Type SUPPLIER_ARRAY_CLASS = Type.getType(Supplier[].class);, +    public static final Type MARKER_CLASS = Type.getType(Marker.class);, +    public static final List<String> LOGGER_METHODS = Arrays.asList("trace", "debug", "info", "warn", "error", "fatal");, +            sb.append(LOGGER_CLASS.getClassName()).append("#").append(logMethodName);, +            Frame<BasicValue>[] logMessageFrames = stringPlaceHolderAnalyzer.getFrames();, +                if (insn.getOpcode() == Opcodes.INVOKEINTERFACE) {, +                    if (Type.getObjectType(methodInsn.owner).equals(LOGGER_CLASS)) {, +, +                        int markerOffset = 0;, +                        if (argumentTypes[0].equals(MARKER_CLASS)) {, +                            markerOffset = 1;, +                        }, +, +                        int lengthWithoutMarker = argumentTypes.length - markerOffset;, +, +                        if (lengthWithoutMarker == 2 &&, +                            argumentTypes[markerOffset + 0].equals(STRING_CLASS) &&, +                            (argumentTypes[markerOffset + 1].equals(OBJECT_ARRAY_CLASS) ||, +                                argumentTypes[markerOffset + 1].equals(SUPPLIER_ARRAY_CLASS))) {, +                            // VARARGS METHOD: debug(Marker?, String, (Object...|Supplier...)), +                            checkArrayArgs(methodNode, logMessageFrames[i], arraySizeFrames[i], lineNumber, methodInsn, markerOffset + 0,, +                                markerOffset + 1);, +                        } else if (lengthWithoutMarker >= 2 &&, +                            argumentTypes[markerOffset + 0].equals(STRING_CLASS) &&, +                            argumentTypes[markerOffset + 1].equals(OBJECT_CLASS)) {, +                            // MULTI-PARAM METHOD: debug(Marker?, String, Object p0, ...), +                            checkFixedArityArgs(methodNode, logMessageFrames[i], lineNumber, methodInsn, markerOffset + 0,, +                                lengthWithoutMarker - 1);, +                        } else if ((lengthWithoutMarker == 1 || lengthWithoutMarker == 2) &&, +                            lengthWithoutMarker == 2 ? argumentTypes[markerOffset + 1].equals(THROWABLE_CLASS) : true) {, +                            // all the rest: debug(Marker?, (Message|MessageSupplier|CharSequence|Object|String|Supplier), Throwable?), +                            checkFixedArityArgs(methodNode, logMessageFrames[i], lineNumber, methodInsn, markerOffset + 0, 0);, +                        } else {, +                            throw new IllegalStateException("Method invoked on " + LOGGER_CLASS.getClassName() +, +                                " that is not supported by logger usage checker");, +                        }, +                    }, +                } else if (insn.getOpcode() == Opcodes.INVOKESPECIAL) { // constructor invocation, +                    MethodInsnNode methodInsn = (MethodInsnNode) insn;, +                    if (Type.getObjectType(methodInsn.owner).equals(PARAMETERIZED_MESSAGE_CLASS)) {, +                        Type[] argumentTypes = Type.getArgumentTypes(methodInsn.desc);, +                        if (argumentTypes.length == 2 &&, +                            argumentTypes[0].equals(STRING_CLASS) &&, +                            argumentTypes[1].equals(OBJECT_ARRAY_CLASS)) {, +                            checkArrayArgs(methodNode, logMessageFrames[i], arraySizeFrames[i], lineNumber, methodInsn, 0, 1);, +                        } else if (argumentTypes.length == 2 &&, +                            argumentTypes[0].equals(STRING_CLASS) &&, +                            argumentTypes[1].equals(OBJECT_CLASS)) {, +                            checkFixedArityArgs(methodNode, logMessageFrames[i], lineNumber, methodInsn, 0, 1);, +                        } else if (argumentTypes.length == 3 &&]