[+++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +    public long getVersionOrMetaDataVersion() {, +        // When following a Zen1 master, the cluster state version is not guaranteed to increase, so instead it is preferable to use the, +        // metadata version to determine the freshest node. However when following a Zen2 master the cluster state version should be used., +        return term() == ZEN1_BWC_TERM ? metaData().version() : version();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +    public long getVersionOrMetaDataVersion() {, +        // When following a Zen1 master, the cluster state version is not guaranteed to increase, so instead it is preferable to use the, +        // metadata version to determine the freshest node. However when following a Zen2 master the cluster state version should be used., +        return term() == ZEN1_BWC_TERM ? metaData().version() : version();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +    private long getLastAcceptedVersionOrMetaDataVersion() {, +        return getLastAcceptedState().getVersionOrMetaDataVersion();, +    }, +, +     * @param initialState The initial state to use. Must have term 0, version equal to the last-accepted version, and non-empty, +     *                     configurations., +, +        final VotingConfiguration lastAcceptedConfiguration = getLastAcceptedConfiguration();, +        if (lastAcceptedConfiguration.isEmpty() == false) {, +            logger.debug("setInitialState: rejecting since last-accepted configuration is nonempty: {}", lastAcceptedConfiguration);, +            throw new CoordinationStateRejectedException(, +                "initial state already set: last-accepted configuration now " + lastAcceptedConfiguration);, +        assert lastPublishedVersion == 0 : lastPublishedVersion;, +        assert initialState.term() == 0 : initialState + " should have term 0";, +        assert initialState.version() == getLastAcceptedVersion() : initialState + " should have version " + getLastAcceptedVersion();, +        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(),, +            getLastAcceptedVersionOrMetaDataVersion());, +        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersionOrMetaDataVersion()) {, +            logger.debug(, +                "handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}]) in term {}",, +                getLastAcceptedVersionOrMetaDataVersion(), join.getLastAcceptedVersion(), lastAcceptedTerm);, +                " of join higher than current last accepted version " + getLastAcceptedVersionOrMetaDataVersion(), +                + " in term " + lastAcceptedTerm);, +        if (getLastAcceptedConfiguration().isEmpty()) {, +            logger.debug("handleJoin: rejecting join since this node has not received its initial configuration yet");, +            throw new CoordinationStateRejectedException("rejecting join since this node has not received its initial configuration yet");, +++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +    public long getVersionOrMetaDataVersion() {, +        // When following a Zen1 master, the cluster state version is not guaranteed to increase, so instead it is preferable to use the, +        // metadata version to determine the freshest node. However when following a Zen2 master the cluster state version should be used., +        return term() == ZEN1_BWC_TERM ? metaData().version() : version();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +    private long getLastAcceptedVersionOrMetaDataVersion() {, +        return getLastAcceptedState().getVersionOrMetaDataVersion();, +    }, +, +     * @param initialState The initial state to use. Must have term 0, version equal to the last-accepted version, and non-empty, +     *                     configurations., +, +        final VotingConfiguration lastAcceptedConfiguration = getLastAcceptedConfiguration();, +        if (lastAcceptedConfiguration.isEmpty() == false) {, +            logger.debug("setInitialState: rejecting since last-accepted configuration is nonempty: {}", lastAcceptedConfiguration);, +            throw new CoordinationStateRejectedException(, +                "initial state already set: last-accepted configuration now " + lastAcceptedConfiguration);, +        assert lastPublishedVersion == 0 : lastPublishedVersion;, +        assert initialState.term() == 0 : initialState + " should have term 0";, +        assert initialState.version() == getLastAcceptedVersion() : initialState + " should have version " + getLastAcceptedVersion();, +        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(),, +            getLastAcceptedVersionOrMetaDataVersion());, +        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersionOrMetaDataVersion()) {, +            logger.debug(, +                "handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}]) in term {}",, +                getLastAcceptedVersionOrMetaDataVersion(), join.getLastAcceptedVersion(), lastAcceptedTerm);, +                " of join higher than current last accepted version " + getLastAcceptedVersionOrMetaDataVersion(), +                + " in term " + lastAcceptedTerm);, +        if (getLastAcceptedConfiguration().isEmpty()) {, +            logger.debug("handleJoin: rejecting join since this node has not received its initial configuration yet");, +            throw new CoordinationStateRejectedException("rejecting join since this node has not received its initial configuration yet");, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            this::isInitialConfigurationSet, joinHelper, peerFinder::getFoundPeers, this::setInitialConfiguration);, +            coordinationState.get().getLastAcceptedState().getVersionOrMetaDataVersion());, +, +            coordinationState.get().setInitialState(ClusterState.builder(currentState).metaData(metaDataBuilder).build());, +++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +    public long getVersionOrMetaDataVersion() {, +        // When following a Zen1 master, the cluster state version is not guaranteed to increase, so instead it is preferable to use the, +        // metadata version to determine the freshest node. However when following a Zen2 master the cluster state version should be used., +        return term() == ZEN1_BWC_TERM ? metaData().version() : version();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +    private long getLastAcceptedVersionOrMetaDataVersion() {, +        return getLastAcceptedState().getVersionOrMetaDataVersion();, +    }, +]