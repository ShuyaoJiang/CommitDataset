[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/notification/NotificationService.java, +import org.elasticsearch.common.util.LazyInitializable;, +    private volatile Map<String, LazyInitializable<Account, SettingsException>> accounts;, +    private volatile LazyInitializable<Account, SettingsException> defaultAccount;, +    protected synchronized void clusterSettingsConsumer(Settings settings) {, +        final Map<String, LazyInitializable<Account, SettingsException>> accounts;, +        final LazyInitializable<Account, SettingsException> defaultAccount;, +        LazyInitializable<Account, SettingsException> theAccount = accounts.getOrDefault(name, defaultAccount);, +        return theAccount.getOrCompute();, +        return settings.getByPrefix(getNotificationsAccountPrefix()).names();, +    private Map<String, LazyInitializable<Account, SettingsException>> createAccounts(Settings settings, Set<String> accountNames,, +        final Map<String, LazyInitializable<Account, SettingsException>> accounts = new HashMap<>();, +            accounts.put(accountName, new LazyInitializable<>(() -> {, +                return accountFactory.apply(accountName, accountSettings);, +            }));, +    private @Nullable LazyInitializable<Account, SettingsException> findDefaultAccountOrNull(Settings settings,, +            Map<String, LazyInitializable<Account, SettingsException>> accounts) {, +            final LazyInitializable<Account, SettingsException> account = accounts.get(defaultAccountName);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/notification/NotificationService.java, +import org.elasticsearch.common.util.LazyInitializable;, +    private volatile Map<String, LazyInitializable<Account, SettingsException>> accounts;, +    private volatile LazyInitializable<Account, SettingsException> defaultAccount;, +    protected synchronized void clusterSettingsConsumer(Settings settings) {, +        final Map<String, LazyInitializable<Account, SettingsException>> accounts;, +        final LazyInitializable<Account, SettingsException> defaultAccount;, +        LazyInitializable<Account, SettingsException> theAccount = accounts.getOrDefault(name, defaultAccount);, +        return theAccount.getOrCompute();, +        return settings.getByPrefix(getNotificationsAccountPrefix()).names();, +    private Map<String, LazyInitializable<Account, SettingsException>> createAccounts(Settings settings, Set<String> accountNames,, +        final Map<String, LazyInitializable<Account, SettingsException>> accounts = new HashMap<>();, +            accounts.put(accountName, new LazyInitializable<>(() -> {, +                return accountFactory.apply(accountName, accountSettings);, +            }));, +    private @Nullable LazyInitializable<Account, SettingsException> findDefaultAccountOrNull(Settings settings,, +            Map<String, LazyInitializable<Account, SettingsException>> accounts) {, +            final LazyInitializable<Account, SettingsException> account = accounts.get(defaultAccountName);, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/notification/NotificationServiceTests.java, +import org.elasticsearch.common.settings.SecureSetting;, +import org.elasticsearch.common.settings.SecureSettings;, +import org.elasticsearch.common.settings.SecureString;, +import org.elasticsearch.common.settings.Setting;, +import java.io.IOException;, +import java.io.InputStream;, +import java.security.GeneralSecurityException;, +import java.util.Arrays;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.function.BiConsumer;, +        assertThat(service.getAccount(null), is(accountName));, +    public void testAccountWithSecureSettings() throws Exception {, +        final Setting<SecureString> secureSetting1 = SecureSetting.secureString("xpack.notification.test.account.secure_only", null);, +        final Setting<SecureString> secureSetting2 = SecureSetting.secureString("xpack.notification.test.account.mixed.secure", null);, +        final Map<String, char[]> secureSettingsMap = new HashMap<>();, +        secureSettingsMap.put(secureSetting1.getKey(), "secure_only".toCharArray());, +        secureSettingsMap.put(secureSetting2.getKey(), "mixed_secure".toCharArray());, +        Settings settings = Settings.builder(), +                .put("xpack.notification.test.account.unsecure_only", "bar"), +                .put("xpack.notification.test.account.mixed.unsecure", "mixed_unsecure"), +                .setSecureSettings(secureSettingsFromMap(secureSettingsMap)), +                .build();, +        TestNotificationService service = new TestNotificationService(settings, Arrays.asList(secureSetting1, secureSetting2));, +        assertThat(service.getAccount("secure_only"), is("secure_only"));, +        assertThat(service.getAccount("unsecure_only"), is("unsecure_only"));, +        assertThat(service.getAccount("mixed"), is("mixed"));, +        assertThat(service.getAccount(null), anyOf(is("secure_only"), is("unsecure_only"), is("mixed")));, +    }, +, +    public void testAccountCreationCached() {, +        String accountName = randomAlphaOfLength(10);, +        Settings settings = Settings.builder().put("xpack.notification.test.account." + accountName, "bar").build();, +        final AtomicInteger validationInvocationCount = new AtomicInteger(0);, +, +        TestNotificationService service = new TestNotificationService(settings, (String name, Settings accountSettings) -> {, +            validationInvocationCount.incrementAndGet();, +        });, +        assertThat(validationInvocationCount.get(), is(0));, +        assertThat(service.getAccount(accountName), is(accountName));, +        assertThat(validationInvocationCount.get(), is(1));, +        if (randomBoolean()) {, +            assertThat(service.getAccount(accountName), is(accountName));, +        } else {, +            assertThat(service.getAccount(null), is(accountName));, +        }, +        // counter is still 1 because the account is cached, +        assertThat(validationInvocationCount.get(), is(1));, +    }, +, +    public void testAccountUpdateSettings() throws Exception {, +        final Setting<SecureString> secureSetting = SecureSetting.secureString("xpack.notification.test.account.x.secure", null);, +        final Setting<String> setting = Setting.simpleString("xpack.notification.test.account.x.dynamic", Setting.Property.Dynamic,, +                Setting.Property.NodeScope);, +        final AtomicReference<String> secureSettingValue = new AtomicReference<String>(randomAlphaOfLength(4));, +        final AtomicReference<String> settingValue = new AtomicReference<String>(randomAlphaOfLength(4));, +        final Map<String, char[]> secureSettingsMap = new HashMap<>();, +        final AtomicInteger validationInvocationCount = new AtomicInteger(0);, +        secureSettingsMap.put(secureSetting.getKey(), secureSettingValue.get().toCharArray());]