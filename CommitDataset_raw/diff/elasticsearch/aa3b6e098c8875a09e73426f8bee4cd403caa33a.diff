[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/FollowIndexAction.java, +        if (CcrSettings.CCR_FOLLOWING_INDEX_SETTING.get(followIndex.getSettings()) == false) {, +            throw new IllegalArgumentException("the following index [" + request.followerIndex + "] is not ready " +, +                "to follow; the setting [" + CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey() + "] must be enabled.");, +        }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/FollowIndexAction.java, +        if (CcrSettings.CCR_FOLLOWING_INDEX_SETTING.get(followIndex.getSettings()) == false) {, +            throw new IllegalArgumentException("the following index [" + request.followerIndex + "] is not ready " +, +                "to follow; the setting [" + CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey() + "] must be enabled.");, +        }, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/ShardChangesIT.java, +import static org.hamcrest.Matchers.containsString;, +    public void testValidateFollowingIndexSettings() throws Exception {, +        assertAcked(client().admin().indices().prepareCreate("test-leader"), +            .setSettings(Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)));, +        // TODO: indexing should be optional but the current mapping logic requires for now., +        client().prepareIndex("test-leader", "doc", "id").setSource("{\"f\": \"v\"}", XContentType.JSON).get();, +        assertAcked(client().admin().indices().prepareCreate("test-follower").get());, +        IllegalArgumentException followError = expectThrows(IllegalArgumentException.class, () -> client().execute(, +            FollowIndexAction.INSTANCE, createFollowRequest("test-leader", "test-follower")).actionGet());, +        assertThat(followError.getMessage(), equalTo("the following index [test-follower] is not ready to follow;" +, +            " the setting [index.xpack.ccr.following_index] must be enabled."));, +        // updating the `following_index` with an open index must not be allowed., +        IllegalArgumentException updateError = expectThrows(IllegalArgumentException.class, () -> {, +            client().admin().indices().prepareUpdateSettings("test-follower"), +                .setSettings(Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)).get();, +        });, +        assertThat(updateError.getMessage(), containsString("Can't update non dynamic settings " +, +            "[[index.xpack.ccr.following_index]] for open indices [[test-follower/"));, +        assertAcked(client().admin().indices().prepareClose("test-follower"));, +        assertAcked(client().admin().indices().prepareUpdateSettings("test-follower"), +            .setSettings(Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)));, +        assertAcked(client().admin().indices().prepareOpen("test-follower"));, +        assertAcked(client().execute(FollowIndexAction.INSTANCE,, +            createFollowRequest("test-leader", "test-follower")).actionGet());, +        unfollowIndex("test-follower");, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/FollowIndexAction.java, +        if (CcrSettings.CCR_FOLLOWING_INDEX_SETTING.get(followIndex.getSettings()) == false) {, +            throw new IllegalArgumentException("the following index [" + request.followerIndex + "] is not ready " +, +                "to follow; the setting [" + CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey() + "] must be enabled.");, +        }, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/ShardChangesIT.java, +import static org.hamcrest.Matchers.containsString;, +    public void testValidateFollowingIndexSettings() throws Exception {, +        assertAcked(client().admin().indices().prepareCreate("test-leader"), +            .setSettings(Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)));, +        // TODO: indexing should be optional but the current mapping logic requires for now., +        client().prepareIndex("test-leader", "doc", "id").setSource("{\"f\": \"v\"}", XContentType.JSON).get();, +        assertAcked(client().admin().indices().prepareCreate("test-follower").get());, +        IllegalArgumentException followError = expectThrows(IllegalArgumentException.class, () -> client().execute(, +            FollowIndexAction.INSTANCE, createFollowRequest("test-leader", "test-follower")).actionGet());, +        assertThat(followError.getMessage(), equalTo("the following index [test-follower] is not ready to follow;" +, +            " the setting [index.xpack.ccr.following_index] must be enabled."));, +        // updating the `following_index` with an open index must not be allowed., +        IllegalArgumentException updateError = expectThrows(IllegalArgumentException.class, () -> {, +            client().admin().indices().prepareUpdateSettings("test-follower"), +                .setSettings(Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)).get();, +        });, +        assertThat(updateError.getMessage(), containsString("Can't update non dynamic settings " +, +            "[[index.xpack.ccr.following_index]] for open indices [[test-follower/"));, +        assertAcked(client().admin().indices().prepareClose("test-follower"));, +        assertAcked(client().admin().indices().prepareUpdateSettings("test-follower"), +            .setSettings(Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)));, +        assertAcked(client().admin().indices().prepareOpen("test-follower"));, +        assertAcked(client().execute(FollowIndexAction.INSTANCE,, +            createFollowRequest("test-leader", "test-follower")).actionGet());, +        unfollowIndex("test-follower");, +    }, +, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/FollowIndexActionTests.java, +import org.elasticsearch.xpack.ccr.CcrSettings;, +            IndexMetaData leaderIMD = createIMD("index1", 5, Settings.EMPTY);, +            IndexMetaData leaderIMD = createIMD("index1", 5, Settings.EMPTY);, +            IndexMetaData followIMD = createIMD("index2", 5, Settings.EMPTY);, +            IndexMetaData leaderIMD = createIMD("index1", 5, Settings.builder(), +                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true").build());, +            IndexMetaData followIMD = createIMD("index2", 4, Settings.EMPTY);, +            IndexMetaData leaderIMD = createIMD("index1", State.CLOSE, "{}", 5, Settings.builder(), +                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true").build());, +            IndexMetaData followIMD = createIMD("index2", State.OPEN, "{}", 5, Settings.builder(), +                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true").build());, +                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true").build());, +            IndexMetaData followIMD = createIMD("index2", State.OPEN, "{\"properties\": {\"field\": {\"type\": \"text\"}}}", 5,, +                Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true).build());, +            IndexMetaData leaderIMD = createIMD("index1", State.OPEN, mapping, 5, Settings.builder(), +                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true"), +                .put("index.analysis.analyzer.my_analyzer.type", "custom"), +                .put("index.analysis.analyzer.my_analyzer.tokenizer", "whitespace").build());, +            IndexMetaData followIMD = createIMD("index2", State.OPEN, mapping, 5, Settings.builder(), +                .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true), +                .put("index.analysis.analyzer.my_analyzer.type", "custom"), +                .put("index.analysis.analyzer.my_analyzer.tokenizer", "standard").build());, +            // should fail because the following index does not have the following_index settings, +            IndexMetaData leaderIMD = createIMD("index1", 5,, +                Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true").build());, +            Settings followingIndexSettings = randomBoolean() ? Settings.EMPTY :, +                Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), false).build();, +            IndexMetaData followIMD = createIMD("index2", 5, followingIndexSettings);]