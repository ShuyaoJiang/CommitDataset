[+++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                threadPool.executor(executorName()).execute(() -> maybeRefresh());, +            threadPool.executor(executorName()).execute(() -> maybeRefresh());, +     * Class used to submit {@link #maybeRefresh()} on the, +                threadPool.executor(executorName()).execute(() -> {, +                    try {, +                        maybeRefresh();, +                    } finally { //schedule again after we refreshed, +                        if (isMaster) {, +                            if (logger.isTraceEnabled()) {, +                                logger.trace("Scheduling next run for updating cluster info in: {}", updateFrequency.toString());, +                            }, +                            try {, +                                threadPool.schedule(updateFrequency, executorName(), this);, +                            } catch (EsRejectedExecutionException ex) {, +                                logger.debug("Reschedule cluster info service was rejected", ex);, +                            }, +                        }, +                    }, +                });, +    private final void maybeRefresh() {, +        if (enabled) {, +            refresh();, +        } else {, +        }, +    /**, +     * Refreshes the ClusterInfo in a blocking fashion, +     * @return, +     */, +    public final ClusterInfo refresh() {, +        if (logger.isTraceEnabled()) {, +            logger.trace("Performing ClusterInfoUpdateJob");, +        }, +        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {, +        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {, +            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout);, +            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout);, +        ClusterInfo clusterInfo = getClusterInfo();, +                l.onNewInfo(clusterInfo);, +        return clusterInfo;, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                threadPool.executor(executorName()).execute(() -> maybeRefresh());, +            threadPool.executor(executorName()).execute(() -> maybeRefresh());, +     * Class used to submit {@link #maybeRefresh()} on the, +                threadPool.executor(executorName()).execute(() -> {, +                    try {, +                        maybeRefresh();, +                    } finally { //schedule again after we refreshed, +                        if (isMaster) {, +                            if (logger.isTraceEnabled()) {, +                                logger.trace("Scheduling next run for updating cluster info in: {}", updateFrequency.toString());, +                            }, +                            try {, +                                threadPool.schedule(updateFrequency, executorName(), this);, +                            } catch (EsRejectedExecutionException ex) {, +                                logger.debug("Reschedule cluster info service was rejected", ex);, +                            }, +                        }, +                    }, +                });, +    private final void maybeRefresh() {, +        if (enabled) {, +            refresh();, +        } else {, +        }, +    /**, +     * Refreshes the ClusterInfo in a blocking fashion, +     * @return, +     */, +    public final ClusterInfo refresh() {, +        if (logger.isTraceEnabled()) {, +            logger.trace("Performing ClusterInfoUpdateJob");, +        }, +        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {, +        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {, +            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout);, +            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout);, +        ClusterInfo clusterInfo = getClusterInfo();, +                l.onNewInfo(clusterInfo);, +        return clusterInfo;, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterInfoServiceIT.java, +        ClusterInfo info = infoService.refresh();, +        ClusterInfo info = infoService.refresh();, +        info = infoService.refresh();, +        info = infoService.refresh();, +        info = infoService.refresh();, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                threadPool.executor(executorName()).execute(() -> maybeRefresh());, +            threadPool.executor(executorName()).execute(() -> maybeRefresh());, +     * Class used to submit {@link #maybeRefresh()} on the, +                threadPool.executor(executorName()).execute(() -> {, +                    try {, +                        maybeRefresh();, +                    } finally { //schedule again after we refreshed, +                        if (isMaster) {, +                            if (logger.isTraceEnabled()) {, +                                logger.trace("Scheduling next run for updating cluster info in: {}", updateFrequency.toString());, +                            }, +                            try {, +                                threadPool.schedule(updateFrequency, executorName(), this);]