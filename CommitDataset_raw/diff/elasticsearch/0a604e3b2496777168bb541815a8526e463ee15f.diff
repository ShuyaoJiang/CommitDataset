[+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import org.elasticsearch.transport.EmptyTransportResponseHandler;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportRequestDeduplicator;, +import org.elasticsearch.transport.TransportResponse;, +    // A map of snapshots to the shardIds that we already reported to the master as failed, +    private final TransportRequestDeduplicator<UpdateIndexShardSnapshotStatusRequest> remoteFailedRequestDeduplicator =, +        new TransportRequestDeduplicator<>();, +, +                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus =, +                                    snapshotStatus.abortIfNotCompleted("snapshot has been aborted");, +                    } else {, +                        final Snapshot snapshot = entry.snapshot();, +                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> curr : entry.shards()) {, +                            // due to CS batching we might have missed the INIT state and straight went into ABORTED, +                            // notify master that abort has completed by moving to FAILED, +                            if (curr.value.state() == State.ABORTED) {, +                                notifyFailedSnapshotShard(snapshot, curr.key, localNodeId, curr.value.reason());, +                            }, +                        }, +        remoteFailedRequestDeduplicator.executeOnce(, +            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),, +            new ActionListener<Void>() {, +                @Override, +                public void onResponse(Void aVoid) {, +                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status);, +, +                @Override, +                public void onFailure(Exception e) {, +                    logger.warn(, +                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e);, +                }, +            },, +            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,, +                new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {, +                    @Override, +                    public void handleResponse(TransportResponse.Empty response) {, +                        reqListener.onResponse(null);, +                    }, +, +                    @Override, +                    public void handleException(TransportException exp) {, +                        reqListener.onFailure(exp);, +                    }, +                }), +        );, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import org.elasticsearch.transport.EmptyTransportResponseHandler;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportRequestDeduplicator;, +import org.elasticsearch.transport.TransportResponse;, +    // A map of snapshots to the shardIds that we already reported to the master as failed, +    private final TransportRequestDeduplicator<UpdateIndexShardSnapshotStatusRequest> remoteFailedRequestDeduplicator =, +        new TransportRequestDeduplicator<>();, +, +                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus =, +                                    snapshotStatus.abortIfNotCompleted("snapshot has been aborted");, +                    } else {, +                        final Snapshot snapshot = entry.snapshot();, +                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> curr : entry.shards()) {, +                            // due to CS batching we might have missed the INIT state and straight went into ABORTED, +                            // notify master that abort has completed by moving to FAILED, +                            if (curr.value.state() == State.ABORTED) {, +                                notifyFailedSnapshotShard(snapshot, curr.key, localNodeId, curr.value.reason());, +                            }, +                        }, +        remoteFailedRequestDeduplicator.executeOnce(, +            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),, +            new ActionListener<Void>() {, +                @Override, +                public void onResponse(Void aVoid) {, +                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status);, +, +                @Override, +                public void onFailure(Exception e) {, +                    logger.warn(, +                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e);, +                }, +            },, +            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,, +                new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {, +                    @Override, +                    public void handleResponse(TransportResponse.Empty response) {, +                        reqListener.onResponse(null);, +                    }, +, +                    @Override, +                    public void handleException(TransportException exp) {, +                        reqListener.onFailure(exp);, +                    }, +                }), +        );, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +                        assert shards.isEmpty();, +                        // No shards in this snapshot, we delete it right away since the SnapshotShardsService, +                        // has no work to do., +                        endSnapshot(snapshotEntry);, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import org.elasticsearch.transport.EmptyTransportResponseHandler;, +import org.elasticsearch.transport.TransportException;]