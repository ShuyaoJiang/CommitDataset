[+++ b/server/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {, +                    assert currentRoutingEntry.initializing() : currentRoutingEntry; // see above if clause, +                    // this can happen when cluster state batching batches activation of the shard, closing an index, reopening it, +                    // and assigning an initializing primary to this node, +                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +++ b/server/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {, +                    assert currentRoutingEntry.initializing() : currentRoutingEntry; // see above if clause, +                    // this can happen when cluster state batching batches activation of the shard, closing an index, reopening it, +                    // and assigning an initializing primary to this node, +                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +++ b/server/src/test/java/org/elasticsearch/action/support/replication/ClusterStateCreationUtils.java, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import java.util.stream.Collectors;, +                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm), +            .build();, +        final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build();, +, +        IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData);, +        indexMetaDataBuilder.putInSyncAllocationIds(0,, +            indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId), +            .collect(Collectors.toSet()), +        );, +        state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded());, +                .addIndexShard(indexShardRoutingTable)).build());, +++ b/server/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {, +                    assert currentRoutingEntry.initializing() : currentRoutingEntry; // see above if clause, +                    // this can happen when cluster state batching batches activation of the shard, closing an index, reopening it, +                    // and assigning an initializing primary to this node, +                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +++ b/server/src/test/java/org/elasticsearch/action/support/replication/ClusterStateCreationUtils.java, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import java.util.stream.Collectors;, +                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm), +            .build();, +        final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build();, +, +        IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData);, +        indexMetaDataBuilder.putInSyncAllocationIds(0,, +            indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId), +            .collect(Collectors.toSet()), +        );, +        state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded());, +                .addIndexShard(indexShardRoutingTable)).build());, +++ b/server/src/test/java/org/elasticsearch/indices/cluster/AbstractIndicesClusterStateServiceTestCase.java, +    protected void disableRandomFailures() {, +        enableRandomFailures = false;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {, +                    assert currentRoutingEntry.initializing() : currentRoutingEntry; // see above if clause, +                    // this can happen when cluster state batching batches activation of the shard, closing an index, reopening it, +                    // and assigning an initializing primary to this node, +                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +++ b/server/src/test/java/org/elasticsearch/action/support/replication/ClusterStateCreationUtils.java, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import java.util.stream.Collectors;, +                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm), +            .build();, +        final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build();, +, +        IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData);, +        indexMetaDataBuilder.putInSyncAllocationIds(0,, +            indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId), +            .collect(Collectors.toSet()), +        );, +        state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded());, +                .addIndexShard(indexShardRoutingTable)).build());, +++ b/server/src/test/java/org/elasticsearch/indices/cluster/AbstractIndicesClusterStateServiceTestCase.java, +    protected void disableRandomFailures() {, +        enableRandomFailures = false;, +    }, +, +++ b/server/src/test/java/org/elasticsearch/indices/cluster/IndicesClusterStateServiceRandomUpdatesTests.java, +import org.elasticsearch.index.shard.ShardId;, +import static org.hamcrest.Matchers.equalTo;, +    /**, +     * In rare cases it is possible that a nodes gets an instruction to replace a replica, +     * shard that's in POST_RECOVERY with a new initializing primary with the same allocation id., +     * This can happen by batching cluster states that include the starting of the replica, with, +     * closing of the indices, opening it up again and allocating the primary shard to the node in, +     * question. The node should then clean it's initializing replica and replace it with a new, +     * initializing primary., +     */, +    public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {, +        disableRandomFailures();, +        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT);, +        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),, +            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING);, +]