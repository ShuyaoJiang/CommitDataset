[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import java.util.Collections;, +        if (settings.fieldsAndWeights() == null) {, +            // this query has no explicit fields to query so we fallback to the default field, +            } else if (fields.isEmpty()) {, +                // the requested fields do not match any field in the mapping, +                // happens for wildcard fields only since we cannot expand to a valid field name, +                // if there is no match in the mappings., +                return new MatchNoDocsQuery("empty fields");, +        Float fieldBoost = settings.fieldsAndWeights() == null ? null : settings.fieldsAndWeights().get(field);, +            Map<String, Float> fieldsAndWeights = settings.fieldsAndWeights();, +            fields = fieldsAndWeights == null ? Collections.emptyList() : settings.fieldsAndWeights().keySet();, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import java.util.Collections;, +        if (settings.fieldsAndWeights() == null) {, +            // this query has no explicit fields to query so we fallback to the default field, +            } else if (fields.isEmpty()) {, +                // the requested fields do not match any field in the mapping, +                // happens for wildcard fields only since we cannot expand to a valid field name, +                // if there is no match in the mappings., +                return new MatchNoDocsQuery("empty fields");, +        Float fieldBoost = settings.fieldsAndWeights() == null ? null : settings.fieldsAndWeights().get(field);, +            Map<String, Float> fieldsAndWeights = settings.fieldsAndWeights();, +            fields = fieldsAndWeights == null ? Collections.emptyList() : settings.fieldsAndWeights().keySet();, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import java.util.Collections;, +        if (settings.fieldsAndWeights() == null) {, +            // this query has no explicit fields to query so we fallback to the default field, +            } else if (fields.isEmpty()) {, +                // the requested fields do not match any field in the mapping, +                // happens for wildcard fields only since we cannot expand to a valid field name, +                // if there is no match in the mappings., +                return new MatchNoDocsQuery("empty fields");, +        Float fieldBoost = settings.fieldsAndWeights() == null ? null : settings.fieldsAndWeights().get(field);, +            Map<String, Float> fieldsAndWeights = settings.fieldsAndWeights();, +            fields = fieldsAndWeights == null ? Collections.emptyList() : settings.fieldsAndWeights().keySet();, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/TokenCountFieldMapper.java, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;, +        public static final boolean DEFAULT_POSITION_INCREMENTS = true;, +        private boolean enablePositionIncrements = Defaults.DEFAULT_POSITION_INCREMENTS;, +        public Builder enablePositionIncrements(boolean enablePositionIncrements) {, +            this.enablePositionIncrements = enablePositionIncrements;, +            return this;, +        }, +, +        public boolean enablePositionIncrements() {, +            return enablePositionIncrements;, +        }, +, +                    context.indexSettings(), analyzer, enablePositionIncrements, multiFieldsBuilder.build(this, context), copyTo);, +        public Mapper.Builder<?,?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {, +                } else if (propName.equals("enable_position_increments")) {, +                    builder.enablePositionIncrements(nodeBooleanValue(propNode));, +                    iterator.remove();, +    private boolean enablePositionIncrements;, +            Settings indexSettings, NamedAnalyzer analyzer, boolean enablePositionIncrements, MultiFields multiFields, CopyTo copyTo) {, +        this.enablePositionIncrements = enablePositionIncrements;, +            tokenCount = countPositions(analyzer, name(), value, enablePositionIncrements);, +     * @param enablePositionIncrements should we count position increments ?, +    static int countPositions(Analyzer analyzer, String fieldName, String fieldValue, boolean enablePositionIncrements) throws IOException {, +                if (enablePositionIncrements) {, +                } else {, +                    count += Math.min(1, position.getPositionIncrement());, +                }, +            if (enablePositionIncrements) {, +            }, +    /**, +     * Indicates if position increments are counted., +     * @return <code>true</code> if position increments are counted, +     */, +    public boolean enablePositionIncrements() {, +        return enablePositionIncrements;, +    }, +, +        this.enablePositionIncrements = ((TokenCountFieldMapper) mergeWith).enablePositionIncrements;, +        if (includeDefaults || enablePositionIncrements() != Defaults.DEFAULT_POSITION_INCREMENTS) {, +            builder.field("enable_position_increments", enablePositionIncrements());, +        }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import java.util.Collections;, +        if (settings.fieldsAndWeights() == null) {, +            // this query has no explicit fields to query so we fallback to the default field, +            } else if (fields.isEmpty()) {, +                // the requested fields do not match any field in the mapping, +                // happens for wildcard fields only since we cannot expand to a valid field name, +                // if there is no match in the mappings., +                return new MatchNoDocsQuery("empty fields");, +        Float fieldBoost = settings.fieldsAndWeights() == null ? null : settings.fieldsAndWeights().get(field);, +            Map<String, Float> fieldsAndWeights = settings.fieldsAndWeights();, +            fields = fieldsAndWeights == null ? Collections.emptyList() : settings.fieldsAndWeights().keySet();, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/TokenCountFieldMapper.java, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;]