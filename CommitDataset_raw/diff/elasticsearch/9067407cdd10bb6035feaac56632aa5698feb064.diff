[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 index so far!, +            // we use "i.r.a.include" rather than "i.r.a.require" since it's allows one of the nodes holding an, +            // instanceof all shards., +            .put("index.routing.allocation.include._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 index so far!, +            // we use "i.r.a.include" rather than "i.r.a.require" since it's allows one of the nodes holding an, +            // instanceof all shards., +            .put("index.routing.allocation.include._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 index so far!, +            // we use "i.r.a.include" rather than "i.r.a.require" since it's allows one of the nodes holding an, +            // instanceof all shards., +            .put("index.routing.allocation.include._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.query.QueryBuilder;, +import java.util.Optional;, +                Optional<QueryBuilder> innerQueryBuilder = shardContext.newParseContext(parser).parseInnerQueryBuilder();, +                if (innerQueryBuilder.isPresent()) {, +                    return shardContext.toFilter(innerQueryBuilder.get()).query();, +                }, +                return null;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/AliasValidator.java, +import java.util.Optional;, +        Optional<QueryBuilder> parseInnerQueryBuilder = queryParseContext.parseInnerQueryBuilder();, +        if (parseInnerQueryBuilder.isPresent()) {, +            QueryBuilder queryBuilder = QueryBuilder.rewriteQuery(parseInnerQueryBuilder.get(), queryShardContext);, +}, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,, +                tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters,, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +            // we can only shrink to 1 index so far!, +            // we use "i.r.a.include" rather than "i.r.a.require" since it's allows one of the nodes holding an, +            // instanceof all shards., +            .put("index.routing.allocation.include._id",, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.query.QueryBuilder;, +import java.util.Optional;, +                Optional<QueryBuilder> innerQueryBuilder = shardContext.newParseContext(parser).parseInnerQueryBuilder();, +                if (innerQueryBuilder.isPresent()) {, +                    return shardContext.toFilter(innerQueryBuilder.get()).query();, +                }, +                return null;, +++ b/core/src/main/java/org/elasticsearch/index/query/BoolQueryBuilder.java, +import java.util.Optional;, +    public static Optional<BoolQueryBuilder> fromXContent(QueryParseContext parseContext) throws IOException, ParsingException {, +                    parseContext.parseInnerQueryBuilder().ifPresent(mustClauses::add);, +                    parseContext.parseInnerQueryBuilder().ifPresent(shouldClauses::add);, +                    parseContext.parseInnerQueryBuilder().ifPresent(filterClauses::add);, +                    parseContext.parseInnerQueryBuilder().ifPresent(mustNotClauses::add);, +                        parseContext.parseInnerQueryBuilder().ifPresent(mustClauses::add);, +                        parseContext.parseInnerQueryBuilder().ifPresent(shouldClauses::add);, +                        parseContext.parseInnerQueryBuilder().ifPresent(filterClauses::add);]