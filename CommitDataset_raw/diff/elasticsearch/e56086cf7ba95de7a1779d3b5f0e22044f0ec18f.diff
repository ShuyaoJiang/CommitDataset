[+++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                    // if it does not exists, and its considered the first index operation (replicas/recovery are 1 of), +                    // then nothing to check, +                        // with replicas/recovery, we only check for previous version, we allow to set a future version, +                            if (create.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +                    if (create.origin() == Operation.Origin.RECOVERY) {, +                        return;, +                    } else {, +                }, +                if (create.origin() == Operation.Origin.RECOVERY) {, +                    return;, +                } else {, +            }, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                    // if it does not exists, and its considered the first index operation (replicas/recovery are 1 of), +                    // then nothing to check, +                        // with replicas/recovery, we only check for previous version, we allow to set a future version, +                            if (index.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                            if (delete.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                    // if it does not exists, and its considered the first index operation (replicas/recovery are 1 of), +                    // then nothing to check, +                        // with replicas/recovery, we only check for previous version, we allow to set a future version, +                            if (create.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +                    if (create.origin() == Operation.Origin.RECOVERY) {, +                        return;, +                    } else {, +                }, +                if (create.origin() == Operation.Origin.RECOVERY) {, +                    return;, +                } else {, +            }, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                    // if it does not exists, and its considered the first index operation (replicas/recovery are 1 of), +                    // then nothing to check, +                        // with replicas/recovery, we only check for previous version, we allow to set a future version, +                            if (index.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                            if (delete.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +        // we allows flush while recovering, since we allow for operations to happen, +        // while recovering, and we want to keep the translog at bay (up to deletes, which, +        // we don't gc)., +        verifyStartedOrRecovering();, +        // we disable deletes since we allow for operations to be executed against the shard while recovering, +        // but we need to make sure we don't loose deletes until we are done recovering, +        engine.enableGcDeletes(false);, +        engine.enableGcDeletes(true);, +    private void writeAllowed() throws IllegalIndexShardStateException {, +        verifyStartedOrRecovering();, +    }, +, +    private void verifyStartedOrRecovering() throws IllegalIndexShardStateException {, +        if (state != IndexShardState.STARTED && state != IndexShardState.RECOVERING) {, +            throw new IllegalIndexShardStateException(shardId, state, "write operation only allowed when started/recovering");, +    private void verifyStarted() throws IllegalIndexShardStateException {, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +            final long currentVersion;, +            } else { // if (index.origin() == Operation.Origin.REPLICA || index.origin() == Operation.Origin.RECOVERY) {, +                    // if it does not exists, and its considered the first index operation (replicas/recovery are 1 of), +                    // then nothing to check, +                        // with replicas/recovery, we only check for previous version, we allow to set a future version, +                            if (create.origin() == Operation.Origin.RECOVERY) {, +                                return;, +                            } else {, +                }, +                    if (create.origin() == Operation.Origin.RECOVERY) {, +                        return;, +                    } else {, +                }, +                if (create.origin() == Operation.Origin.RECOVERY) {, +                    return;, +                } else {]