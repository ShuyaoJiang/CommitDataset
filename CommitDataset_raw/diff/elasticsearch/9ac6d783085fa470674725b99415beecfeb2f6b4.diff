[+++ b/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.transport.ReceiveTimeoutTransportException;, +    public static final String INTERNAL_CLUSTER_INFO_TIMEOUT = "cluster.info.update.timeout";, +    private volatile TimeValue fetchTimeout;, +        this.fetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, TimeValue.timeValueSeconds(15));, +            TimeValue newFetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, null);, +            if (newFetchTimeout != null) {, +                logger.info("updating fetch timeout [{}] from [{}] to [{}]", INTERNAL_CLUSTER_INFO_TIMEOUT, fetchTimeout, newFetchTimeout);, +                InternalClusterInfoService.this.fetchTimeout = newFetchTimeout;, +            }, +, +, +                updateOnce();, +, +    // called from tests as well, +, +    /**, +     * will collect a fresh {@link ClusterInfo} from the nodes, without scheduling a future collection, +     */, +    void updateOnce() {, +        threadPool.executor(executorName()).execute(new ClusterInfoUpdateJob(false));, +    }, +, +            updateOnce();, +        nodesStatsRequest.timeout(fetchTimeout);, +                    if (e instanceof ReceiveTimeoutTransportException) {, +                        logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob (reason [{}])", e.getMessage());, +                    } else {, +                        // we empty the usages list, to be safe - we don't know what's going on., +                        usages = ImmutableMap.of();, +                    }, +                    if (e instanceof ReceiveTimeoutTransportException) {, +                        logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob (reason [{}])", e.getMessage());, +                    } else {, +                        // we empty the usages list, to be safe - we don't know what's going on., +                        shardSizes = ImmutableMap.of();, +                    }, +                nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);, +                indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);, +++ b/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.transport.ReceiveTimeoutTransportException;, +    public static final String INTERNAL_CLUSTER_INFO_TIMEOUT = "cluster.info.update.timeout";, +    private volatile TimeValue fetchTimeout;, +        this.fetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, TimeValue.timeValueSeconds(15));, +            TimeValue newFetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, null);, +            if (newFetchTimeout != null) {, +                logger.info("updating fetch timeout [{}] from [{}] to [{}]", INTERNAL_CLUSTER_INFO_TIMEOUT, fetchTimeout, newFetchTimeout);, +                InternalClusterInfoService.this.fetchTimeout = newFetchTimeout;, +            }, +, +, +                updateOnce();, +, +    // called from tests as well, +, +    /**, +     * will collect a fresh {@link ClusterInfo} from the nodes, without scheduling a future collection, +     */, +    void updateOnce() {, +        threadPool.executor(executorName()).execute(new ClusterInfoUpdateJob(false));, +    }, +, +            updateOnce();, +        nodesStatsRequest.timeout(fetchTimeout);, +                    if (e instanceof ReceiveTimeoutTransportException) {, +                        logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob (reason [{}])", e.getMessage());, +                    } else {, +                        // we empty the usages list, to be safe - we don't know what's going on., +                        usages = ImmutableMap.of();, +                    }, +                    if (e instanceof ReceiveTimeoutTransportException) {, +                        logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob (reason [{}])", e.getMessage());, +                    } else {, +                        // we empty the usages list, to be safe - we don't know what's going on., +                        shardSizes = ImmutableMap.of();, +                    }, +                nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);, +                indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_TIMEOUT, Validator.TIME_NON_NEGATIVE);, +++ b/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +import org.elasticsearch.transport.ReceiveTimeoutTransportException;, +    public static final String INTERNAL_CLUSTER_INFO_TIMEOUT = "cluster.info.update.timeout";, +    private volatile TimeValue fetchTimeout;, +        this.fetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, TimeValue.timeValueSeconds(15));, +            TimeValue newFetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, null);, +            if (newFetchTimeout != null) {, +                logger.info("updating fetch timeout [{}] from [{}] to [{}]", INTERNAL_CLUSTER_INFO_TIMEOUT, fetchTimeout, newFetchTimeout);, +                InternalClusterInfoService.this.fetchTimeout = newFetchTimeout;, +            }, +, +, +                updateOnce();, +, +    // called from tests as well, +, +    /**, +     * will collect a fresh {@link ClusterInfo} from the nodes, without scheduling a future collection, +     */, +    void updateOnce() {]