[+++ b/src/main/java/org/elasticsearch/common/unit/ByteSizeValue.java, +    /**, +     * Largest size possible for Guava caches to prevent overflow. Guava's, +     * caches use integers to track weight per segment and we always 16 segments, +     * so caches of 32GB would always overflow that integer and they'd never be, +     * evicted by size. We set this to 31.9GB leaving 100MB of headroom to, +     * prevent overflow., +     */, +    public static final ByteSizeValue MAX_GUAVA_CACHE_SIZE = new ByteSizeValue(32 * ByteSizeUnit.C3 - 100 * ByteSizeUnit.C2);, +++ b/src/main/java/org/elasticsearch/common/unit/ByteSizeValue.java, +    /**, +     * Largest size possible for Guava caches to prevent overflow. Guava's, +     * caches use integers to track weight per segment and we always 16 segments, +     * so caches of 32GB would always overflow that integer and they'd never be, +     * evicted by size. We set this to 31.9GB leaving 100MB of headroom to, +     * prevent overflow., +     */, +    public static final ByteSizeValue MAX_GUAVA_CACHE_SIZE = new ByteSizeValue(32 * ByteSizeUnit.C3 - 100 * ByteSizeUnit.C2);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +        long sizeInBytes = MemorySizeValue.parseBytesSizeValueOrHeapRatio(size).bytes();, +        if (sizeInBytes > ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes()) {, +            logger.warn("reducing requested filter cache size of [{}] to the maximum allowed size of [{}]", new ByteSizeValue(sizeInBytes),, +                    ByteSizeValue.MAX_GUAVA_CACHE_SIZE);, +            sizeInBytes = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes();, +            // Even though it feels wrong for size and sizeInBytes to get out of, +            // sync we don't update size here because it might cause the cache, +            // to be rebuilt every time new settings are applied., +        }, +        this.sizeInBytes = sizeInBytes;, +++ b/src/main/java/org/elasticsearch/common/unit/ByteSizeValue.java, +    /**, +     * Largest size possible for Guava caches to prevent overflow. Guava's, +     * caches use integers to track weight per segment and we always 16 segments, +     * so caches of 32GB would always overflow that integer and they'd never be, +     * evicted by size. We set this to 31.9GB leaving 100MB of headroom to, +     * prevent overflow., +     */, +    public static final ByteSizeValue MAX_GUAVA_CACHE_SIZE = new ByteSizeValue(32 * ByteSizeUnit.C3 - 100 * ByteSizeUnit.C2);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +        long sizeInBytes = MemorySizeValue.parseBytesSizeValueOrHeapRatio(size).bytes();, +        if (sizeInBytes > ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes()) {, +            logger.warn("reducing requested filter cache size of [{}] to the maximum allowed size of [{}]", new ByteSizeValue(sizeInBytes),, +                    ByteSizeValue.MAX_GUAVA_CACHE_SIZE);, +            sizeInBytes = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes();, +            // Even though it feels wrong for size and sizeInBytes to get out of, +            // sync we don't update size here because it might cause the cache, +            // to be rebuilt every time new settings are applied., +        }, +        this.sizeInBytes = sizeInBytes;, +++ b/src/main/java/org/elasticsearch/indices/fielddata/cache/IndicesFieldDataCache.java, +        String size = componentSettings.get("size", "-1");, +        long sizeInBytes = componentSettings.getAsMemory("size", "-1").bytes();, +        if (sizeInBytes > ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes()) {, +            logger.warn("reducing requested field data cache size of [{}] to the maximum allowed size of [{}]", new ByteSizeValue(sizeInBytes),, +                    ByteSizeValue.MAX_GUAVA_CACHE_SIZE);, +            sizeInBytes = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes();, +            size = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.toString();, +        }, +++ b/src/main/java/org/elasticsearch/common/unit/ByteSizeValue.java, +    /**, +     * Largest size possible for Guava caches to prevent overflow. Guava's, +     * caches use integers to track weight per segment and we always 16 segments, +     * so caches of 32GB would always overflow that integer and they'd never be, +     * evicted by size. We set this to 31.9GB leaving 100MB of headroom to, +     * prevent overflow., +     */, +    public static final ByteSizeValue MAX_GUAVA_CACHE_SIZE = new ByteSizeValue(32 * ByteSizeUnit.C3 - 100 * ByteSizeUnit.C2);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +        long sizeInBytes = MemorySizeValue.parseBytesSizeValueOrHeapRatio(size).bytes();, +        if (sizeInBytes > ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes()) {, +            logger.warn("reducing requested filter cache size of [{}] to the maximum allowed size of [{}]", new ByteSizeValue(sizeInBytes),, +                    ByteSizeValue.MAX_GUAVA_CACHE_SIZE);, +            sizeInBytes = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes();, +            // Even though it feels wrong for size and sizeInBytes to get out of, +            // sync we don't update size here because it might cause the cache, +            // to be rebuilt every time new settings are applied., +        }, +        this.sizeInBytes = sizeInBytes;, +++ b/src/main/java/org/elasticsearch/indices/fielddata/cache/IndicesFieldDataCache.java, +        String size = componentSettings.get("size", "-1");, +        long sizeInBytes = componentSettings.getAsMemory("size", "-1").bytes();, +        if (sizeInBytes > ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes()) {, +            logger.warn("reducing requested field data cache size of [{}] to the maximum allowed size of [{}]", new ByteSizeValue(sizeInBytes),, +                    ByteSizeValue.MAX_GUAVA_CACHE_SIZE);, +            sizeInBytes = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.bytes();, +            size = ByteSizeValue.MAX_GUAVA_CACHE_SIZE.toString();, +        }, +++ b/src/test/java/org/elasticsearch/common/util/GuavaCacheOverflowTest.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,]