[+++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        return state.blocks().globalBlockedException(ClusterBlockLevel.READ);, +        return state.blocks().indicesBlockedException(ClusterBlockLevel.READ, concreteIndices);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        return state.blocks().globalBlockedException(ClusterBlockLevel.READ);, +        return state.blocks().indicesBlockedException(ClusterBlockLevel.READ, concreteIndices);, +++ b/src/test/java/org/elasticsearch/discovery/zen/ZenDiscoveryRejoinOnMaster.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;, +import org.elasticsearch.action.admin.indices.recovery.RecoveryResponse;, +import org.elasticsearch.common.Priority;, +import static org.hamcrest.Matchers.*;, +    public void testChangeRejoinOnMasterOptionIsDynamic() throws Exception {, +    @Test, +    public void testNoShardRelocationsOccurWhenElectedMasterNodeFails() throws Exception {, +        Settings defaultSettings = ImmutableSettings.builder(), +                .put("discovery.zen.fd.ping_timeout", "1s"), +                .put("discovery.zen.fd.ping_retries", "1"), +                .put("discovery.type", "zen"), +                .build();, +, +        Settings masterNodeSettings = ImmutableSettings.builder(), +                .put("node.data", false), +                .put(defaultSettings), +                .build();, +        internalCluster().startNodesAsync(2, masterNodeSettings).get();, +        Settings dateNodeSettings = ImmutableSettings.builder(), +                .put("node.master", false), +                .put(defaultSettings), +                .build();, +        internalCluster().startNodesAsync(2, dateNodeSettings).get();, +        ClusterHealthResponse clusterHealthResponse = client().admin().cluster().prepareHealth(), +                .setWaitForEvents(Priority.LANGUID), +                .setWaitForNodes("4"), +                .setWaitForRelocatingShards(0), +                .get();, +        assertThat(clusterHealthResponse.isTimedOut(), is(false));, +, +        createIndex("test");, +        ensureSearchable("test");, +        RecoveryResponse r = client().admin().indices().prepareRecoveries("test").get();, +        int numRecoveriesBeforeNewMaster = r.shardResponses().get("test").size();, +, +        final String oldMaster = internalCluster().getMasterName();, +        internalCluster().stopCurrentMasterNode();, +        assertBusy(new Runnable() {, +            @Override, +            public void run() {, +                String current = internalCluster().getMasterName();, +                assertThat(current, notNullValue());, +                assertThat(current, not(equalTo(oldMaster)));, +            }, +        });, +        ensureSearchable("test");, +, +        r = client().admin().indices().prepareRecoveries("test").get();, +        int numRecoveriesAfterNewMaster = r.shardResponses().get("test").size();, +        assertThat(numRecoveriesAfterNewMaster, equalTo(numRecoveriesBeforeNewMaster));, +    }, +]