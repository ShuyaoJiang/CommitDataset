[+++ b/docs/CHANGELOG.asciidoc, +, +Allocation::, +, +Auto-expand replicas when adding or removing nodes to prevent shard copies from, +being dropped and resynced when a data node rejoins the cluster ({pull}30423[#30423]), +, +++ b/docs/CHANGELOG.asciidoc, +, +Allocation::, +, +Auto-expand replicas when adding or removing nodes to prevent shard copies from, +being dropped and resynced when a data node rejoins the cluster ({pull}30423[#30423]), +, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/AutoExpandReplicas.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Optional;, +, +public final class AutoExpandReplicas {, +, +    private static final AutoExpandReplicas FALSE_INSTANCE = new AutoExpandReplicas(0, 0, false);, +, +    public static final Setting<AutoExpandReplicas> SETTING = new Setting<>(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "false",, +        AutoExpandReplicas::parse, Property.Dynamic, Property.IndexScope);, +, +    private static AutoExpandReplicas parse(String value) {, +            return FALSE_INSTANCE;, +    }, +    Optional<Integer> getDesiredNumberOfReplicas(int numDataNodes) {, +        if (enabled) {, +            final int min = getMinReplicas();, +            final int max = getMaxReplicas(numDataNodes);, +            int numberOfReplicas = numDataNodes - 1;, +            if (numberOfReplicas < min) {, +                numberOfReplicas = min;, +            } else if (numberOfReplicas > max) {, +                numberOfReplicas = max;, +            }, +, +            if (numberOfReplicas >= min && numberOfReplicas <= max) {, +                return Optional.of(numberOfReplicas);, +            }, +        }, +        return Optional.empty();, +    }, +, +, +    /**, +     * Checks if the are replicas with the auto-expand feature that need to be adapted., +     * Returns a map of updates, which maps the indices to be updated to the desired number of replicas., +     * The map has the desired number of replicas as key and the indices to update as value, as this allows the result, +     * of this method to be directly applied to RoutingTable.Builder#updateNumberOfReplicas., +     */, +    public static Map<Integer, List<String>> getAutoExpandReplicaChanges(MetaData metaData, DiscoveryNodes discoveryNodes) {, +        // used for translating "all" to a number, +        final int dataNodeCount = discoveryNodes.getDataNodes().size();, +, +        Map<Integer, List<String>> nrReplicasChanged = new HashMap<>();, +, +        for (final IndexMetaData indexMetaData : metaData) {, +            if (indexMetaData.getState() != IndexMetaData.State.CLOSE) {, +                AutoExpandReplicas autoExpandReplicas = SETTING.get(indexMetaData.getSettings());, +                autoExpandReplicas.getDesiredNumberOfReplicas(dataNodeCount).ifPresent(numberOfReplicas -> {, +                    if (numberOfReplicas != indexMetaData.getNumberOfReplicas()) {, +                        nrReplicasChanged.computeIfAbsent(numberOfReplicas, ArrayList::new).add(indexMetaData.getIndex().getName());, +                    }, +                });, +            }, +        }, +        return nrReplicasChanged;, +    }, +++ b/docs/CHANGELOG.asciidoc, +, +Allocation::, +, +Auto-expand replicas when adding or removing nodes to prevent shard copies from, +being dropped and resynced when a data node rejoins the cluster ({pull}30423[#30423]), +, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/AutoExpandReplicas.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Optional;, +, +public final class AutoExpandReplicas {, +, +    private static final AutoExpandReplicas FALSE_INSTANCE = new AutoExpandReplicas(0, 0, false);, +, +    public static final Setting<AutoExpandReplicas> SETTING = new Setting<>(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "false",, +        AutoExpandReplicas::parse, Property.Dynamic, Property.IndexScope);, +, +    private static AutoExpandReplicas parse(String value) {, +            return FALSE_INSTANCE;, +    }]