[+++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean failOnMergeFailure;, +, +        this.failOnMergeFailure = indexSettings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, true);, +        if (failOnMergeFailure) {, +            this.mergeScheduler.addFailureListener(new FailEngineOnMergeFailure());, +        }, +    class FailEngineOnMergeFailure implements MergeSchedulerProvider.FailureListener {, +        @Override, +        public void onFailedMerge(MergePolicy.MergeException e) {, +            failEngine(e);, +        }, +    }, +, +    public static final String INDEX_FAIL_ON_MERGE_FAILURE = "index.fail_on_merge_failure";, +            boolean failOnMergeFailure = settings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure);, +            if (termIndexInterval != RobinEngine.this.termIndexInterval || termIndexDivisor != RobinEngine.this.termIndexDivisor || indexConcurrency != RobinEngine.this.indexConcurrency || !codecName.equals(RobinEngine.this.codecName) || failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                    if (failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                        logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure, failOnMergeFailure);, +                        RobinEngine.this.failOnMergeFailure = failOnMergeFailure;, +                    }, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean failOnMergeFailure;, +, +        this.failOnMergeFailure = indexSettings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, true);, +        if (failOnMergeFailure) {, +            this.mergeScheduler.addFailureListener(new FailEngineOnMergeFailure());, +        }, +    class FailEngineOnMergeFailure implements MergeSchedulerProvider.FailureListener {, +        @Override, +        public void onFailedMerge(MergePolicy.MergeException e) {, +            failEngine(e);, +        }, +    }, +, +    public static final String INDEX_FAIL_ON_MERGE_FAILURE = "index.fail_on_merge_failure";, +            boolean failOnMergeFailure = settings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure);, +            if (termIndexInterval != RobinEngine.this.termIndexInterval || termIndexDivisor != RobinEngine.this.termIndexDivisor || indexConcurrency != RobinEngine.this.indexConcurrency || !codecName.equals(RobinEngine.this.codecName) || failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                    if (failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                        logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure, failOnMergeFailure);, +                        RobinEngine.this.failOnMergeFailure = failOnMergeFailure;, +                    }, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +import org.elasticsearch.threadpool.ThreadPool;, +public class ConcurrentMergeSchedulerProvider extends MergeSchedulerProvider {, +    public ConcurrentMergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool) {, +        super(shardId, indexSettings, threadPool);, +            provider.failedMerge(new MergePolicy.MergeException(exc, dir));, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean failOnMergeFailure;, +, +        this.failOnMergeFailure = indexSettings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, true);, +        if (failOnMergeFailure) {, +            this.mergeScheduler.addFailureListener(new FailEngineOnMergeFailure());, +        }, +    class FailEngineOnMergeFailure implements MergeSchedulerProvider.FailureListener {, +        @Override, +        public void onFailedMerge(MergePolicy.MergeException e) {, +            failEngine(e);, +        }, +    }, +, +    public static final String INDEX_FAIL_ON_MERGE_FAILURE = "index.fail_on_merge_failure";, +            boolean failOnMergeFailure = settings.getAsBoolean(INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure);, +            if (termIndexInterval != RobinEngine.this.termIndexInterval || termIndexDivisor != RobinEngine.this.termIndexDivisor || indexConcurrency != RobinEngine.this.indexConcurrency || !codecName.equals(RobinEngine.this.codecName) || failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                    if (failOnMergeFailure != RobinEngine.this.failOnMergeFailure) {, +                        logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_FAIL_ON_MERGE_FAILURE, RobinEngine.this.failOnMergeFailure, failOnMergeFailure);, +                        RobinEngine.this.failOnMergeFailure = failOnMergeFailure;, +                    }, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +import org.elasticsearch.threadpool.ThreadPool;, +public class ConcurrentMergeSchedulerProvider extends MergeSchedulerProvider {, +    public ConcurrentMergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool) {, +        super(shardId, indexSettings, threadPool);, +            provider.failedMerge(new MergePolicy.MergeException(exc, dir));, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/MergeSchedulerProvider.java, +import org.apache.lucene.index.MergePolicy;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.settings.IndexSettings;, +import org.elasticsearch.index.shard.AbstractIndexShardComponent;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.threadpool.ThreadPool;, +, +import java.util.concurrent.CopyOnWriteArrayList;, +public abstract class MergeSchedulerProvider<T extends MergeScheduler> extends AbstractIndexShardComponent implements IndexShardComponent {, +    public static interface FailureListener {, +        void onFailedMerge(MergePolicy.MergeException e);, +    }, +    private final ThreadPool threadPool;, +    private final CopyOnWriteArrayList<FailureListener> failureListeners = new CopyOnWriteArrayList<FailureListener>();, +, +    private final boolean notifyOnMergeFailure;, +, +    protected MergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool) {, +        super(shardId, indexSettings);, +        this.threadPool = threadPool;, +        this.notifyOnMergeFailure = componentSettings.getAsBoolean("notify_on_failure", true);, +    }, +, +    public void addFailureListener(FailureListener listener) {]