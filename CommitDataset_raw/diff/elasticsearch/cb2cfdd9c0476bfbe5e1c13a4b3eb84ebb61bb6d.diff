[+++ b/core/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.ReaderUtil;, +import org.apache.lucene.util.Bits;, +import org.elasticsearch.common.lucene.Lucene;, +import java.util.Arrays;, +import java.util.HashMap;, +        return true; // we short-circuit in hitsExecute, +        if (hits.length == 0) {, +            return;, +        }, +        hits = hits.clone(); // don't modify the incoming hits, +        Arrays.sort(hits, (a, b) -> Integer.compare(a.docId(), b.docId()));, +        @SuppressWarnings("unchecked"), +        List<String>[] matchedQueries = new List[hits.length];, +        for (int i = 0; i < matchedQueries.length; ++i) {, +            matchedQueries[i] = new ArrayList<>();, +        Map<String, Query> namedQueries = new HashMap<>(context.parsedQuery().namedFilters());, +        if (context.parsedPostFilter() != null) {, +            namedQueries.putAll(context.parsedPostFilter().namedFilters());, +            for (Map.Entry<String, Query> entry : namedQueries.entrySet()) {, +                String name = entry.getKey();, +                Query query = entry.getValue();, +                int readerIndex = -1;, +                int docBase = -1;, +                Weight weight = context.searcher().createNormalizedWeight(query, false);, +                Bits matchingDocs = null;, +                for (int i = 0; i < hits.length; ++i) {, +                    InternalSearchHit hit = hits[i];, +                    int hitReaderIndex = ReaderUtil.subIndex(hit.docId(), context.searcher().getIndexReader().leaves());, +                    if (readerIndex != hitReaderIndex) {, +                        readerIndex = hitReaderIndex;, +                        LeafReaderContext ctx = context.searcher().getIndexReader().leaves().get(readerIndex);, +                        docBase = ctx.docBase;, +                        // scorers can be costly to create, so reuse them across docs of the same segment, +                        Scorer scorer = weight.scorer(ctx);, +                        matchingDocs = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), scorer);, +                    }, +                    if (matchingDocs.get(hit.docId() - docBase)) {, +                        matchedQueries[i].add(name);, +                    }, +                }, +            }, +            for (int i = 0; i < hits.length; ++i) {, +                hits[i].matchedQueries(matchedQueries[i].toArray(new String[0]));, +    @Override, +    public boolean hitExecutionNeeded(SearchContext context) {, +        return false;, +    }, +    @Override, +    public void hitExecute(SearchContext context, HitContext hitContext) {, +        // we do everything in hitsExecute]