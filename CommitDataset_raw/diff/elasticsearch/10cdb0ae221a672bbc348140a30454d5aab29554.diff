[+++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        public MappingMetaData mapping(String type) {, +            return mappings.get(type);, +        }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        public MappingMetaData mapping(String type) {, +            return mappings.get(type);, +        }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +, +            IndexMetaData indexMetaData = mdBuilder.get(index);, +                                if (eTask.type.equals(uTask.type)) {, +                }, +            // construct the actual index if needed, and make sure the relevant mappings are there, +                Set<String> typesToIntroduce = Sets.newHashSet();, +                for (MappingTask task : tasks) {, +                    if (task instanceof UpdateTask) {, +                        typesToIntroduce.add(((UpdateTask) task).type);, +                    } else if (task instanceof RefreshTask) {, +                        Collections.addAll(typesToIntroduce, ((RefreshTask) task).types);, +                    }, +                }, +                for (String type : typesToIntroduce) {, +            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData);, +                boolean indexDirty = processIndexMappingTasks(tasks, indexService, builder);, +                if (indexDirty) {, +                    mdBuilder.put(builder);, +    private boolean processIndexMappingTasks(List<MappingTask> tasks, IndexService indexService, IndexMetaData.Builder builder) {, +        boolean dirty = false;, +        String index = indexService.index().name();, +        // keep track of what we already refreshed, no need to refresh it again..., +        Set<String> processedRefreshes = Sets.newHashSet();, +        for (MappingTask task : tasks) {, +            if (task instanceof RefreshTask) {, +                RefreshTask refreshTask = (RefreshTask) task;, +                try {, +                    List<String> updatedTypes = Lists.newArrayList();, +                    for (String type : refreshTask.types) {, +                        if (processedRefreshes.contains(type)) {, +                            continue;, +                        }, +                        DocumentMapper mapper = indexService.mapperService().documentMapper(type);, +                        if (mapper == null) {, +                            continue;, +                        }, +                        if (!mapper.mappingSource().equals(builder.mapping(type).source())) {, +                            updatedTypes.add(type);, +                            builder.putMapping(new MappingMetaData(mapper));, +                        }, +                        processedRefreshes.add(type);, +                    }, +, +                    if (updatedTypes.isEmpty()) {, +                        continue;, +                    }, +, +                    logger.warn("[{}] re-syncing mappings with cluster state for types [{}]", index, updatedTypes);, +                    dirty = true;, +                } catch (Throwable t) {, +                    logger.warn("[{}] failed to refresh-mapping in cluster state, types [{}]", index, refreshTask.types);, +                }, +            } else if (task instanceof UpdateTask) {, +                UpdateTask updateTask = (UpdateTask) task;, +                try {, +                    String type = updateTask.type;, +                    CompressedString mappingSource = updateTask.mappingSource;, +, +                    MappingMetaData mappingMetaData = builder.mapping(type);, +                    if (mappingMetaData != null && mappingMetaData.source().equals(mappingSource)) {, +                        logger.debug("[{}] update_mapping [{}] ignoring mapping update task as its source is equal to ours", index, updateTask.type);, +                        continue;, +                    }, +, +                    DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource, false);, +                    processedRefreshes.add(type);, +, +                    // if we end up with the same mapping as the original once, ignore, +                    if (mappingMetaData != null && mappingMetaData.source().equals(updatedMapper.mappingSource())) {, +                        logger.debug("[{}] update_mapping [{}] ignoring mapping update task as it results in the same source as what we have", index, updateTask.type);, +                        continue;, +                    }, +, +                    // build the updated mapping source, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]", index, type, updatedMapper.mappingSource());, +                    } else if (logger.isInfoEnabled()) {, +                        logger.info("[{}] update_mapping [{}] (dynamic)", index, type);, +                    }, +, +                    builder.putMapping(new MappingMetaData(updatedMapper));, +                    dirty = true;, +                } catch (Throwable t) {, +                    logger.warn("[{}] failed to update-mapping in cluster state, type [{}]", index, updateTask.type);, +                }, +            } else {, +                logger.warn("illegal state, got wrong mapping task type [{}]", task);, +            }, +        }]