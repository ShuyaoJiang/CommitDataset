[+++ b/core/src/main/java/org/elasticsearch/index/query/MultiMatchQueryBuilder.java, +import org.apache.lucene.search.FuzzyQuery;, +import org.apache.lucene.search.Query;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.index.query.support.QueryParsers;, +import org.elasticsearch.index.search.MultiMatchQuery;, +import java.util.Map;, +import java.util.Objects;, +import java.util.TreeMap;, +    public static final MultiMatchQueryBuilder.Type DEFAULT_TYPE = MultiMatchQueryBuilder.Type.BEST_FIELDS;, +    public static final Operator DEFAULT_OPERATOR = Operator.OR;, +    public static final int DEFAULT_PHRASE_SLOP = MatchQuery.DEFAULT_PHRASE_SLOP;, +    public static final int DEFAULT_PREFIX_LENGTH = FuzzyQuery.defaultPrefixLength;, +    public static final int DEFAULT_MAX_EXPANSIONS = FuzzyQuery.defaultMaxExpansions;, +    public static final boolean DEFAULT_LENIENCY = MatchQuery.DEFAULT_LENIENCY;, +    public static final MatchQuery.ZeroTermsQuery DEFAULT_ZERO_TERMS_QUERY = MatchQuery.DEFAULT_ZERO_TERMS_QUERY;, +    private final Object value;, +    private Map<String, Float> fieldsBoosts = new TreeMap<>();, +    private MultiMatchQueryBuilder.Type type = DEFAULT_TYPE;, +    private Operator operator = DEFAULT_OPERATOR;, +    private int slop = DEFAULT_PHRASE_SLOP;, +    private int prefixLength = DEFAULT_PREFIX_LENGTH;, +    private int maxExpansions = DEFAULT_MAX_EXPANSIONS;, +    private boolean lenient = DEFAULT_LENIENCY;, +    private MatchQuery.ZeroTermsQuery zeroTermsQuery = DEFAULT_ZERO_TERMS_QUERY;, +    static final MultiMatchQueryBuilder PROTOTYPE = new MultiMatchQueryBuilder("");, +    public enum Type implements Writeable<Type> {, +        private static final Type PROTOTYPE = BEST_FIELDS;, +, +, +        @Override, +        public Type readFrom(StreamInput in) throws IOException {, +            return Type.values()[in.readVInt()];, +        }, +, +        public static Type readTypeFrom(StreamInput in) throws IOException {, +            return PROTOTYPE.readFrom(in);, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeVInt(this.ordinal());, +        }, +    public MultiMatchQueryBuilder(Object value, String... fields) {, +        if (value == null) {, +            throw new IllegalArgumentException("[" + NAME + "] requires query value");, +        }, +        this.value = value;, +        for (String field : fields) {, +            field(field);, +        }, +    }, +, +    public Object value() {, +        return value;, +        if (Strings.isEmpty(field)) {, +            throw new IllegalArgumentException("supplied field is null or empty.");, +        }, +        this.fieldsBoosts.put(field, AbstractQueryBuilder.DEFAULT_BOOST);, +        if (Strings.isEmpty(field)) {, +            throw new IllegalArgumentException("supplied field is null or empty.");, +        this.fieldsBoosts.put(field, boost);, +     * Add several fields to run the query against with a specific boost., +     */, +    public MultiMatchQueryBuilder fields(Map<String, Float> fields) {, +        this.fieldsBoosts.putAll(fields);, +        return this;, +    }, +, +    public Map<String, Float> fields() {, +        return fieldsBoosts;, +    }, +, +    /**, +        if (type == null) {, +            throw new IllegalArgumentException("[" + NAME + "] requires type to be non-null");, +        }, +        if (type == null) {, +            throw new IllegalArgumentException("[" + NAME + "] requires type to be non-null");, +        }, +        this.type = Type.parse(type.toString().toLowerCase(Locale.ROOT), ParseFieldMatcher.EMPTY);, +    public Type type() {, +        return type;, +    }, +, +        if (operator == null) {, +            throw new IllegalArgumentException("[" + NAME + "] requires operator to be non-null");, +        }, +    public Operator operator() {, +        return operator;, +    }, +, +    public String analyzer() {, +        return analyzer;, +    }]