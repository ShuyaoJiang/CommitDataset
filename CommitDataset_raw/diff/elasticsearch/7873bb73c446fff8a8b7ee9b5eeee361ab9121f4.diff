[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +            assert userWithHash != null : "the cache contract requires that a value returned from computeIfAbsent be non-null or an " +, +                    "ExecutionException should be thrown";, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +            assert userWithHash != null : "the cache contract requires that a value returned from computeIfAbsent be non-null or an " +, +                    "ExecutionException should be thrown";, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/RunAsIntegTests.java, +import static org.hamcrest.Matchers.greaterThan;, +            assertBusy(() -> assertThat(client.connectedNodes().size(), greaterThan(0)));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +            assert userWithHash != null : "the cache contract requires that a value returned from computeIfAbsent be non-null or an " +, +                    "ExecutionException should be thrown";, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/RunAsIntegTests.java, +import static org.hamcrest.Matchers.greaterThan;, +            assertBusy(() -> assertThat(client.connectedNodes().size(), greaterThan(0)));, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/esnative/NativeRealmIntegTests.java, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.CountDownLatch;, +, +    /**, +     * Tests that multiple concurrent run as requests can be authenticated successfully. There was a bug in the Cache implementation used, +     * for our internal realms that caused some run as requests to fail even when the authentication was valid and the run as user existed., +     *, +     * The issue was that when iterating the realms there would be failed lookups and under heavy concurrency, requests will wait for an, +     * existing load attempt in the cache. The original caller was thrown an ExecutionException with a nested NullPointerException since, +     * the loader returned a null value, while the other caller(s) would get a null value unexpectedly, +     */, +    public void testConcurrentRunAs() throws Exception {, +        securityClient().preparePutUser("joe", "s3krit".toCharArray(), SecuritySettingsSource.DEFAULT_ROLE).get();, +        securityClient().preparePutUser("executor", "s3krit".toCharArray(), "superuser").get();, +        final String token = basicAuthHeaderValue("executor", new SecuredString("s3krit".toCharArray()));, +        final Client client = client().filterWithHeader(MapBuilder.<String, String>newMapBuilder(), +                .put("Authorization", token), +                .put("es-security-runas-user", "joe"), +                .immutableMap());, +        final CountDownLatch latch = new CountDownLatch(1);, +        final int numberOfProcessors = Runtime.getRuntime().availableProcessors();, +        final int numberOfThreads = scaledRandomIntBetween(numberOfProcessors, numberOfProcessors * 3);, +        final int numberOfIterations = scaledRandomIntBetween(20, 100);, +        List<Thread> threads = new ArrayList<>();, +        for (int i = 0; i < numberOfThreads; i++) {, +            threads.add(new Thread(() -> {, +                try {, +                    latch.await();, +                    for (int j = 0; j < numberOfIterations; j++) {, +                        ClusterHealthResponse response = client.admin().cluster().prepareHealth().get();, +                        assertNoTimeout(response);, +                    }, +                } catch (InterruptedException e) {, +                }, +            }));, +        }, +, +        for (Thread thread : threads) {, +            thread.start();, +        }, +        latch.countDown();, +        for (Thread thread : threads) {, +            thread.join();, +        }, +    }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +            assert userWithHash != null : "the cache contract requires that a value returned from computeIfAbsent be non-null or an " +, +                    "ExecutionException should be thrown";, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/RunAsIntegTests.java, +import static org.hamcrest.Matchers.greaterThan;, +            assertBusy(() -> assertThat(client.connectedNodes().size(), greaterThan(0)));, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/esnative/NativeRealmIntegTests.java, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.CountDownLatch;, +, +    /**, +     * Tests that multiple concurrent run as requests can be authenticated successfully. There was a bug in the Cache implementation used, +     * for our internal realms that caused some run as requests to fail even when the authentication was valid and the run as user existed., +     *, +     * The issue was that when iterating the realms there would be failed lookups and under heavy concurrency, requests will wait for an, +     * existing load attempt in the cache. The original caller was thrown an ExecutionException with a nested NullPointerException since, +     * the loader returned a null value, while the other caller(s) would get a null value unexpectedly, +     */, +    public void testConcurrentRunAs() throws Exception {, +        securityClient().preparePutUser("joe", "s3krit".toCharArray(), SecuritySettingsSource.DEFAULT_ROLE).get();, +        securityClient().preparePutUser("executor", "s3krit".toCharArray(), "superuser").get();, +        final String token = basicAuthHeaderValue("executor", new SecuredString("s3krit".toCharArray()));, +        final Client client = client().filterWithHeader(MapBuilder.<String, String>newMapBuilder(), +                .put("Authorization", token), +                .put("es-security-runas-user", "joe"), +                .immutableMap());, +        final CountDownLatch latch = new CountDownLatch(1);, +        final int numberOfProcessors = Runtime.getRuntime().availableProcessors();, +        final int numberOfThreads = scaledRandomIntBetween(numberOfProcessors, numberOfProcessors * 3);, +        final int numberOfIterations = scaledRandomIntBetween(20, 100);, +        List<Thread> threads = new ArrayList<>();, +        for (int i = 0; i < numberOfThreads; i++) {, +            threads.add(new Thread(() -> {, +                try {, +                    latch.await();, +                    for (int j = 0; j < numberOfIterations; j++) {, +                        ClusterHealthResponse response = client.admin().cluster().prepareHealth().get();]