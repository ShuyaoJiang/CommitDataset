[+++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentParserUtils.java, +import java.util.function.Consumer;, +     * It also expected that following this field name is either an Object or an array xContent structure and, +     * the cursor points to the start token of this structure., +     *, +     * @param consumer    something to consume the parsed object, +     * @throws ParsingException if the parser isn't positioned on either START_OBJECT or START_ARRAY at the beginning, +    public static <T> void parseTypedKeysObject(XContentParser parser, String delimiter, Class<T> objectClass, Consumer<T> consumer), +            throws IOException {, +        if (parser.currentToken() != XContentParser.Token.START_OBJECT && parser.currentToken() != XContentParser.Token.START_ARRAY) {, +            throwUnknownToken(parser.currentToken(), parser.getTokenLocation());, +        }, +                consumer.accept(parser.namedObject(objectClass, type, name));, +                return;, +            // if we didn't find a delimiter we ignore the object or array for forward compatibility instead of throwing an error, +            parser.skipChildren();, +        } else {, +            throw new ParsingException(parser.getTokenLocation(), "Failed to parse object: empty key");, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentParserUtils.java, +import java.util.function.Consumer;, +     * It also expected that following this field name is either an Object or an array xContent structure and, +     * the cursor points to the start token of this structure., +     *, +     * @param consumer    something to consume the parsed object, +     * @throws ParsingException if the parser isn't positioned on either START_OBJECT or START_ARRAY at the beginning, +    public static <T> void parseTypedKeysObject(XContentParser parser, String delimiter, Class<T> objectClass, Consumer<T> consumer), +            throws IOException {, +        if (parser.currentToken() != XContentParser.Token.START_OBJECT && parser.currentToken() != XContentParser.Token.START_ARRAY) {, +            throwUnknownToken(parser.currentToken(), parser.getTokenLocation());, +        }, +                consumer.accept(parser.namedObject(objectClass, type, name));, +                return;, +            // if we didn't find a delimiter we ignore the object or array for forward compatibility instead of throwing an error, +            parser.skipChildren();, +        } else {, +            throw new ParsingException(parser.getTokenLocation(), "Failed to parse object: empty key");, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/Aggregations.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.common.ParsingException;, +import java.util.Locale;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.parseTypedKeysObject;, +                SetOnce<Aggregation> typedAgg = new SetOnce<>();, +                String currentField = parser.currentName();, +                parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, typedAgg::set);, +                if (typedAgg.get() != null) {, +                    aggregations.add(typedAgg.get());, +                } else {, +                    throw new ParsingException(parser.getTokenLocation(),, +                            String.format(Locale.ROOT, "Could not parse aggregation keyed as [%s]", currentField));, +                }, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentParserUtils.java, +import java.util.function.Consumer;, +     * It also expected that following this field name is either an Object or an array xContent structure and, +     * the cursor points to the start token of this structure., +     *, +     * @param consumer    something to consume the parsed object, +     * @throws ParsingException if the parser isn't positioned on either START_OBJECT or START_ARRAY at the beginning, +    public static <T> void parseTypedKeysObject(XContentParser parser, String delimiter, Class<T> objectClass, Consumer<T> consumer), +            throws IOException {, +        if (parser.currentToken() != XContentParser.Token.START_OBJECT && parser.currentToken() != XContentParser.Token.START_ARRAY) {, +            throwUnknownToken(parser.currentToken(), parser.getTokenLocation());, +        }, +                consumer.accept(parser.namedObject(objectClass, type, name));, +                return;, +            // if we didn't find a delimiter we ignore the object or array for forward compatibility instead of throwing an error, +            parser.skipChildren();, +        } else {, +            throw new ParsingException(parser.getTokenLocation(), "Failed to parse object: empty key");, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/Aggregations.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.common.ParsingException;, +import java.util.Locale;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.parseTypedKeysObject;, +                SetOnce<Aggregation> typedAgg = new SetOnce<>();, +                String currentField = parser.currentName();, +                parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, typedAgg::set);, +                if (typedAgg.get() != null) {, +                    aggregations.add(typedAgg.get());, +                } else {, +                    throw new ParsingException(parser.getTokenLocation(),, +                            String.format(Locale.ROOT, "Could not parse aggregation keyed as [%s]", currentField));, +                }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/ParsedMultiBucketAggregation.java, +                    XContentParserUtils.parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class,, +                            aggregations::add);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentParserUtils.java, +import java.util.function.Consumer;, +     * It also expected that following this field name is either an Object or an array xContent structure and, +     * the cursor points to the start token of this structure., +     *, +     * @param consumer    something to consume the parsed object, +     * @throws ParsingException if the parser isn't positioned on either START_OBJECT or START_ARRAY at the beginning, +    public static <T> void parseTypedKeysObject(XContentParser parser, String delimiter, Class<T> objectClass, Consumer<T> consumer), +            throws IOException {, +        if (parser.currentToken() != XContentParser.Token.START_OBJECT && parser.currentToken() != XContentParser.Token.START_ARRAY) {, +            throwUnknownToken(parser.currentToken(), parser.getTokenLocation());, +        }, +                consumer.accept(parser.namedObject(objectClass, type, name));, +                return;, +            // if we didn't find a delimiter we ignore the object or array for forward compatibility instead of throwing an error]