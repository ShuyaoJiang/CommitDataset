[+++ b/src/main/java/org/elasticsearch/env/Environment.java, +        String origPath = path;, +        // first, try it as a path on the file system, +        Path f1 = PathUtils.get(path);, +        if (Files.exists(f1)) {, +                return f1.toUri().toURL();, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f1 + "]", e);, +            }, +        }, +        if (path.startsWith("/")) {, +            path = path.substring(1);, +        }, +        // next, try it relative to the config location, +        Path f2 = configFile.resolve(path);, +        if (Files.exists(f2)) {, +            try {, +                return f2.toUri().toURL();, +            } catch (MalformedURLException e) {, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f1 + "]", e);, +        throw new FailedToResolveConfigException("Failed to resolve config path [" + origPath + "], tried file path [" + f1 + "], path file [" + f2 + "], and classpath");, +++ b/src/main/java/org/elasticsearch/env/Environment.java, +        String origPath = path;, +        // first, try it as a path on the file system, +        Path f1 = PathUtils.get(path);, +        if (Files.exists(f1)) {, +                return f1.toUri().toURL();, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f1 + "]", e);, +            }, +        }, +        if (path.startsWith("/")) {, +            path = path.substring(1);, +        }, +        // next, try it relative to the config location, +        Path f2 = configFile.resolve(path);, +        if (Files.exists(f2)) {, +            try {, +                return f2.toUri().toURL();, +            } catch (MalformedURLException e) {, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f1 + "]", e);, +        throw new FailedToResolveConfigException("Failed to resolve config path [" + origPath + "], tried file path [" + f1 + "], path file [" + f2 + "], and classpath");, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import com.google.common.collect.ImmutableSet;, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +    private volatile MetaData previousMetaData;, +, +    private volatile ImmutableSet<String> previouslyWrittenIndices = ImmutableSet.of();, +        if (DiscoveryNode.masterNode(settings) || DiscoveryNode.dataNode(settings)) {, +        Set<String> relevantIndices = new HashSet<>();, +            this.previousMetaData = null;, +            previouslyWrittenIndices= ImmutableSet.of();, +        // write the state if this node is a master eligible node or if it is a data node and has shards allocated on it, +        if (state.nodes().localNode().masterNode() || state.nodes().localNode().dataNode()) {, +            if (previousMetaData == null || !MetaData.isGlobalStateEquals(previousMetaData, newMetaData)) {, +                    // we determine if or if not we write meta data on data only nodes by looking at the shard routing, +                    // and only write if a shard of this index is allocated on this node, +                    // however, closed indices do not appear in the shard routing. if the meta data for a closed index is, +                    // updated it will therefore not be written in case the list of previouslyWrittenIndices is empty (because state, +                    // persistence was disabled or the node was restarted), see getRelevantIndicesOnDataOnlyNode()., +                    // we therefore have to check here if we have shards on disk and add their indices to the previouslyWrittenIndices list, +                    if (isDataOnlyNode(state)) {, +                        ImmutableSet.Builder<String> previouslyWrittenIndicesBuilder = ImmutableSet.builder();, +                        for (IndexMetaData indexMetaData : newMetaData) {, +                            IndexMetaData indexMetaDataOnDisk = null;, +                            if (indexMetaData.state().equals(IndexMetaData.State.CLOSE)) {, +                                try {, +                                    indexMetaDataOnDisk = metaStateService.loadIndexState(indexMetaData.index());, +                                } catch (IOException ex) {, +                                    throw new ElasticsearchException("failed to load index state", ex);, +                                }, +                            }, +                            if (indexMetaDataOnDisk != null) {, +                                previouslyWrittenIndicesBuilder.add(indexMetaDataOnDisk.index());, +                            }, +                        }, +                        previouslyWrittenIndices = previouslyWrittenIndicesBuilder.addAll(previouslyWrittenIndices).build();, +                    }, +            Iterable<IndexMetaWriteInfo> writeInfo;, +            relevantIndices = getRelevantIndices(event.state(), previouslyWrittenIndices);, +            writeInfo = resolveStatesToBeWritten(previouslyWrittenIndices, relevantIndices, previousMetaData, event.state().metaData());, +            for (IndexMetaWriteInfo indexMetaWrite : writeInfo) {, +                    metaStateService.writeIndex(indexMetaWrite.reason, indexMetaWrite.newMetaData, indexMetaWrite.previousMetaData);, +            previousMetaData = newMetaData;, +            ImmutableSet.Builder<String> builder= ImmutableSet.builder();, +            previouslyWrittenIndices = builder.addAll(relevantIndices).build();, +    public static Set<String> getRelevantIndices(ClusterState state, ImmutableSet<String> previouslyWrittenIndices) {, +        Set<String> relevantIndices;, +        if (isDataOnlyNode(state)) {, +            relevantIndices = getRelevantIndicesOnDataOnlyNode(state, previouslyWrittenIndices);, +        } else if (state.nodes().localNode().masterNode() == true) {, +            relevantIndices = getRelevantIndicesForMasterEligibleNode(state);, +        } else {, +            relevantIndices = Collections.emptySet();, +        }, +        return relevantIndices;, +    }, +, +, +    protected static boolean isDataOnlyNode(ClusterState state) {, +        return ((state.nodes().localNode().masterNode() == false) && state.nodes().localNode().dataNode());]