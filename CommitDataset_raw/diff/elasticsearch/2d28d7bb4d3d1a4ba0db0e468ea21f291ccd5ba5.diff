[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            } else if (mode == Mode.FOLLOWER) {, +                logger.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);, +            } else if (joinHelper.isJoinPending()) {, +                logger.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);, +            } else {, +                logger.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);, +                throw new CoordinationStateRejectedException(, +                    "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            } else if (mode == Mode.FOLLOWER) {, +                logger.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);, +            } else if (joinHelper.isJoinPending()) {, +                logger.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);, +            } else {, +                logger.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);, +                throw new CoordinationStateRejectedException(, +                    "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +    JoinHelper(Settings settings, AllocationService allocationService, MasterService masterService,, +    boolean isJoinPending() {, +        // cannot use pendingOutgoingJoins.isEmpty() because it's not properly synchronized., +        return pendingOutgoingJoins.iterator().hasNext();, +    void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin) {, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            } else if (mode == Mode.FOLLOWER) {, +                logger.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);, +            } else if (joinHelper.isJoinPending()) {, +                logger.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);, +            } else {, +                logger.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);, +                throw new CoordinationStateRejectedException(, +                    "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +    JoinHelper(Settings settings, AllocationService allocationService, MasterService masterService,, +    boolean isJoinPending() {, +        // cannot use pendingOutgoingJoins.isEmpty() because it's not properly synchronized., +        return pendingOutgoingJoins.iterator().hasNext();, +    void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin) {, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +            expectThrows(CoordinationStateRejectedException.class, () -> nonLeader.coordinator.onFollowerCheckRequest(, +                new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(), leader.getLocalNode())));, +            assertThat(nonLeader.coordinator.getMode(), equalTo(CANDIDATE));, +    public void testFollowerRemovedIfUnableToSendRequestsToMaster() {, +        final Cluster cluster = new Cluster(3);, +        cluster.runRandomly();, +        cluster.stabilise();, +, +        final ClusterNode leader = cluster.getAnyLeader();, +        final ClusterNode otherNode = cluster.getAnyNodeExcept(leader);, +, +        cluster.blackholeConnectionsFrom(otherNode, leader);, +, +        cluster.runFor(, +            (defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING) + defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING)), +                * defaultInt(FOLLOWER_CHECK_RETRY_COUNT_SETTING), +                + (defaultMillis(LEADER_CHECK_INTERVAL_SETTING) + DEFAULT_DELAY_VARIABILITY), +                * defaultInt(LEADER_CHECK_RETRY_COUNT_SETTING), +                + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,, +            "awaiting removal of asymmetrically-partitioned node");, +, +        assertThat(leader.getLastAppliedClusterState().nodes().toString(),, +            leader.getLastAppliedClusterState().nodes().getSize(), equalTo(2));, +, +        cluster.clearBlackholedConnections();, +, +        cluster.stabilise(, +            // time for the disconnected node to find the master again, +            defaultMillis(DISCOVERY_FIND_PEERS_INTERVAL_SETTING) * 2, +                // time for joining, +                + 4 * DEFAULT_DELAY_VARIABILITY, +                // Then a commit of the updated cluster state, +                + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);, +    }, +, +        private final Set<Tuple<String,String>> blackholedConnections = new HashSet<>();, +            } else if (blackholedConnections.contains(Tuple.tuple(sender.getId(), destination.getId()))) {, +                connectionStatus = ConnectionStatus.BLACK_HOLE_REQUESTS_ONLY;, +        void blackholeConnectionsFrom(ClusterNode sender, ClusterNode destination) {, +            blackholedConnections.add(Tuple.tuple(sender.getId(), destination.getId()));, +        }, +, +        void clearBlackholedConnections() {, +            blackholedConnections.clear();, +        }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            } else if (mode == Mode.FOLLOWER) {, +                logger.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);, +            } else if (joinHelper.isJoinPending()) {, +                logger.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);, +            } else {, +                logger.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);, +                throw new CoordinationStateRejectedException(, +                    "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +    JoinHelper(Settings settings, AllocationService allocationService, MasterService masterService,, +    boolean isJoinPending() {, +        // cannot use pendingOutgoingJoins.isEmpty() because it's not properly synchronized., +        return pendingOutgoingJoins.iterator().hasNext();]