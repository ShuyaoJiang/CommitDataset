[+++ b/core/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecyclerModule.java, +    // pkg private so tests can mock, +    Class<? extends PageCacheRecycler> pageCacheRecyclerImpl = PageCacheRecycler.class;, +        if (pageCacheRecyclerImpl == PageCacheRecycler.class) {, +            bind(PageCacheRecycler.class).to(pageCacheRecyclerImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecyclerModule.java, +    // pkg private so tests can mock, +    Class<? extends PageCacheRecycler> pageCacheRecyclerImpl = PageCacheRecycler.class;, +        if (pageCacheRecyclerImpl == PageCacheRecycler.class) {, +            bind(PageCacheRecycler.class).to(pageCacheRecyclerImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    // pkg private so tests can mock, +    Class<? extends ClusterInfoService> clusterInfoServiceImpl = InternalClusterInfoService.class;, +, +        bind(ClusterInfoService.class).to(clusterInfoServiceImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecyclerModule.java, +    // pkg private so tests can mock, +    Class<? extends PageCacheRecycler> pageCacheRecyclerImpl = PageCacheRecycler.class;, +        if (pageCacheRecyclerImpl == PageCacheRecycler.class) {, +            bind(PageCacheRecycler.class).to(pageCacheRecyclerImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    // pkg private so tests can mock, +    Class<? extends ClusterInfoService> clusterInfoServiceImpl = InternalClusterInfoService.class;, +, +        bind(ClusterInfoService.class).to(clusterInfoServiceImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationModule.java, +    private final Map<String, Class<? extends ShardsAllocator>> shardsAllocators = new HashMap<>();, +    private final Set<Class<? extends AllocationDecider>> allocationDeciders = new HashSet<>();, +        this.allocationDeciders.addAll(DEFAULT_ALLOCATION_DECIDERS);, +        registerShardAllocator(BALANCED_ALLOCATOR, BalancedShardsAllocator.class);, +        registerShardAllocator(EVEN_SHARD_COUNT_ALLOCATOR, BalancedShardsAllocator.class);, +        boolean isNew = allocationDeciders.add(allocationDecider);, +        if (isNew == false) {, +            throw new IllegalArgumentException("Cannot register AllocationDecider " + allocationDecider.getName() + " twice");, +        }, +        Class<? extends ShardsAllocator> existing = shardsAllocators.put(name, clazz);, +        if (existing != null) {, +            throw new IllegalArgumentException("Cannot register ShardAllocator [" + name + "] to " + clazz.getName() + ", already registered to " + existing.getName());, +        }, +, +        final String shardsAllocatorType = settings.get(AllocationModule.SHARDS_ALLOCATOR_TYPE_KEY, AllocationModule.BALANCED_ALLOCATOR);, +        final Class<? extends ShardsAllocator> shardsAllocator = shardsAllocators.get(shardsAllocatorType);, +        if (shardsAllocator == null) {, +            throw new IllegalArgumentException("Unknown ShardsAllocator type [" + shardsAllocatorType + "]");, +        } else if (shardsAllocatorType.equals(EVEN_SHARD_COUNT_ALLOCATOR)) {, +        bind(ShardsAllocator.class).to(shardsAllocator).asEagerSingleton();, +        // bind AllocationDeciders, +        Multibinder<AllocationDecider> allocationMultibinder = Multibinder.newSetBinder(binder(), AllocationDecider.class);, +        for (Class<? extends AllocationDecider> allocation : allocationDeciders) {, +            allocationMultibinder.addBinding().to(allocation).asEagerSingleton();, +        bind(GatewayAllocator.class).asEagerSingleton();, +        bind(AllocationDeciders.class).asEagerSingleton();, +        bind(AllocationService.class).asEagerSingleton();, +    }, +++ b/core/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecyclerModule.java, +    // pkg private so tests can mock, +    Class<? extends PageCacheRecycler> pageCacheRecyclerImpl = PageCacheRecycler.class;, +        if (pageCacheRecyclerImpl == PageCacheRecycler.class) {, +            bind(PageCacheRecycler.class).to(pageCacheRecyclerImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    // pkg private so tests can mock, +    Class<? extends ClusterInfoService> clusterInfoServiceImpl = InternalClusterInfoService.class;, +, +        bind(ClusterInfoService.class).to(clusterInfoServiceImpl).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationModule.java, +    private final Map<String, Class<? extends ShardsAllocator>> shardsAllocators = new HashMap<>();, +    private final Set<Class<? extends AllocationDecider>> allocationDeciders = new HashSet<>();, +        this.allocationDeciders.addAll(DEFAULT_ALLOCATION_DECIDERS);, +        registerShardAllocator(BALANCED_ALLOCATOR, BalancedShardsAllocator.class);, +        registerShardAllocator(EVEN_SHARD_COUNT_ALLOCATOR, BalancedShardsAllocator.class);, +        boolean isNew = allocationDeciders.add(allocationDecider);, +        if (isNew == false) {, +            throw new IllegalArgumentException("Cannot register AllocationDecider " + allocationDecider.getName() + " twice");, +        }, +        Class<? extends ShardsAllocator> existing = shardsAllocators.put(name, clazz);, +        if (existing != null) {, +            throw new IllegalArgumentException("Cannot register ShardAllocator [" + name + "] to " + clazz.getName() + ", already registered to " + existing.getName());, +        }, +, +        final String shardsAllocatorType = settings.get(AllocationModule.SHARDS_ALLOCATOR_TYPE_KEY, AllocationModule.BALANCED_ALLOCATOR);, +        final Class<? extends ShardsAllocator> shardsAllocator = shardsAllocators.get(shardsAllocatorType);, +        if (shardsAllocator == null) {, +            throw new IllegalArgumentException("Unknown ShardsAllocator type [" + shardsAllocatorType + "]");, +        } else if (shardsAllocatorType.equals(EVEN_SHARD_COUNT_ALLOCATOR)) {, +        bind(ShardsAllocator.class).to(shardsAllocator).asEagerSingleton();, +        // bind AllocationDeciders, +        Multibinder<AllocationDecider> allocationMultibinder = Multibinder.newSetBinder(binder(), AllocationDecider.class);, +        for (Class<? extends AllocationDecider> allocation : allocationDeciders) {, +            allocationMultibinder.addBinding().to(allocation).asEagerSingleton();, +        bind(GatewayAllocator.class).asEagerSingleton();, +        bind(AllocationDeciders.class).asEagerSingleton();, +        bind(AllocationService.class).asEagerSingleton();, +    }, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +                return this;, +++ b/core/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecyclerModule.java, +    // pkg private so tests can mock, +    Class<? extends PageCacheRecycler> pageCacheRecyclerImpl = PageCacheRecycler.class;, +        if (pageCacheRecyclerImpl == PageCacheRecycler.class) {, +            bind(PageCacheRecycler.class).to(pageCacheRecyclerImpl).asEagerSingleton();]