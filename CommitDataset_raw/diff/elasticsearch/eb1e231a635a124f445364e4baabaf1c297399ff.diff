[+++ b/core/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java, +    public SearchRequestBuilder setNoFields() {, +        sourceBuilder().noFields();, +     * Adds a field to load and return (note, it must be stored) as part of the search request., +    public SearchRequestBuilder addField(String field) {, +        sourceBuilder().field(field);, +        sourceBuilder().fieldDataField(name);, +    public SearchRequestBuilder fields(String... fields) {, +        sourceBuilder().fields(Arrays.asList(fields));, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java, +    public SearchRequestBuilder setNoFields() {, +        sourceBuilder().noFields();, +     * Adds a field to load and return (note, it must be stored) as part of the search request., +    public SearchRequestBuilder addField(String field) {, +        sourceBuilder().field(field);, +        sourceBuilder().fieldDataField(name);, +    public SearchRequestBuilder fields(String... fields) {, +        sourceBuilder().fields(Arrays.asList(fields));, +++ b/core/src/main/java/org/elasticsearch/index/query/InnerHitBuilder.java, +        PARSER.declareStringArray(InnerHitBuilder::setFieldNames, SearchSourceBuilder.FIELDS_FIELD);, +        PARSER.declareStringArray(InnerHitBuilder::setFieldDataFields, SearchSourceBuilder.FIELDDATA_FIELDS_FIELD);, +    private List<String> fieldNames;, +    private List<String> fieldDataFields;, +    /**, +     * Read from a stream., +     */, +    public InnerHitBuilder(StreamInput in) throws IOException {, +        name = in.readOptionalString();, +        nestedPath = in.readOptionalString();, +        parentChildType = in.readOptionalString();, +        from = in.readVInt();, +        size = in.readVInt();, +        explain = in.readBoolean();, +        version = in.readBoolean();, +        trackScores = in.readBoolean();, +        fieldNames = (List<String>) in.readGenericValue();, +        fieldDataFields = (List<String>) in.readGenericValue();, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            scriptFields = new HashSet<>(size);, +            for (int i = 0; i < size; i++) {, +                scriptFields.add(new ScriptField(in));, +            }, +        }, +        fetchSourceContext = in.readOptionalStreamable(FetchSourceContext::new);, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            sorts = new ArrayList<>(size);, +            for (int i = 0; i < size; i++) {, +                sorts.add(in.readNamedWriteable(SortBuilder.class));, +            }, +        }, +        highlightBuilder = in.readOptionalWriteable(HighlightBuilder::new);, +        query = in.readNamedWriteable(QueryBuilder.class);, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            childInnerHits = new HashMap<>(size);, +            for (int i = 0; i < size; i++) {, +                childInnerHits.put(in.readString(), new InnerHitBuilder(in));, +            }, +        }, +    }, +, +        if (other.fieldNames != null) {, +            fieldNames = new ArrayList<>(other.fieldNames);, +        if (other.fieldDataFields != null) {, +            fieldDataFields = new ArrayList<>(other.fieldDataFields);, +        out.writeGenericValue(fieldNames);, +        out.writeGenericValue(fieldDataFields);, +        return fieldNames;, +        this.fieldNames = fieldNames;, +        return fieldDataFields;, +        this.fieldDataFields = fieldDataFields;, +        if (fieldDataFields == null) {, +            fieldDataFields = new ArrayList<>();, +        fieldDataFields.add(field);, +        if (fieldNames != null) {, +            if (fieldNames.isEmpty()) {, +                for (String fieldName : fieldNames) {, +        if (fieldDataFields != null) {, +            for (String field : fieldDataFields) {, +        if (fieldNames != null) {, +            if (fieldNames.size() == 1) {, +                builder.field(SearchSourceBuilder.FIELDS_FIELD.getPreferredName(), fieldNames.get(0));, +                builder.startArray(SearchSourceBuilder.FIELDS_FIELD.getPreferredName());, +                for (String fieldName : fieldNames) {, +        if (fieldDataFields != null) {, +            builder.startArray(SearchSourceBuilder.FIELDDATA_FIELDS_FIELD.getPreferredName());, +            for (String fieldDataField : fieldDataFields) {, +                Objects.equals(fieldNames, that.fieldNames) &&, +                Objects.equals(fieldDataFields, that.fieldDataFields) &&, +        return Objects.hash(name, nestedPath, parentChildType, from, size, explain, version, trackScores, fieldNames,, +                fieldDataFields, scriptFields, fetchSourceContext, sorts, highlightBuilder, query, childInnerHits);, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java, +    public SearchRequestBuilder setNoFields() {, +        sourceBuilder().noFields();, +     * Adds a field to load and return (note, it must be stored) as part of the search request., +    public SearchRequestBuilder addField(String field) {, +        sourceBuilder().field(field);, +        sourceBuilder().fieldDataField(name);]