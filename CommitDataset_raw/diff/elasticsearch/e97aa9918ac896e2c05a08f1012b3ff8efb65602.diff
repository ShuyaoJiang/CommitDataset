[+++ b/src/test/java/org/elasticsearch/cluster/NoMasterNodeTests.java, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.elasticsearch.test.AbstractIntegrationTest.ClusterScope;, +import org.elasticsearch.test.AbstractIntegrationTest.Scope;, +@ClusterScope(scope=Scope.TEST, numNodes=0), +public class NoMasterNodeTests extends AbstractIntegrationTest {, +        cluster().startNode(settings);, +        cluster().startNode(settings);, +        client().admin().indices().prepareCreate("test").execute().actionGet();, +        client().admin().cluster().prepareHealth("test").setWaitForGreenStatus().execute().actionGet();, +        cluster().stopRandomNode();, +        assertThat(awaitBusy(new Predicate<Object>() {, +                ClusterState state = client().admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +        }), equalTo(true));, +            client().prepareGet("test", "type1", "1").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareMultiGet().add("test", "type1", "1").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().preparePercolate(), +            fail("Expected ClusterBlockException");, +            client().prepareUpdate("test", "type1", "1").setScript("test script").setTimeout(timeout).execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().admin().indices().prepareAnalyze("test", "this is a test").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareCount("test").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareIndex("test", "type1", "1").setSource(XContentFactory.jsonBuilder().startObject().endObject()).setTimeout(timeout).execute().actionGet();, +            fail("Expected ClusterBlockException");, +++ b/src/test/java/org/elasticsearch/cluster/NoMasterNodeTests.java, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.elasticsearch.test.AbstractIntegrationTest.ClusterScope;, +import org.elasticsearch.test.AbstractIntegrationTest.Scope;, +@ClusterScope(scope=Scope.TEST, numNodes=0), +public class NoMasterNodeTests extends AbstractIntegrationTest {, +        cluster().startNode(settings);, +        cluster().startNode(settings);, +        client().admin().indices().prepareCreate("test").execute().actionGet();, +        client().admin().cluster().prepareHealth("test").setWaitForGreenStatus().execute().actionGet();, +        cluster().stopRandomNode();, +        assertThat(awaitBusy(new Predicate<Object>() {, +                ClusterState state = client().admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +        }), equalTo(true));, +            client().prepareGet("test", "type1", "1").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareMultiGet().add("test", "type1", "1").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().preparePercolate(), +            fail("Expected ClusterBlockException");, +            client().prepareUpdate("test", "type1", "1").setScript("test script").setTimeout(timeout).execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().admin().indices().prepareAnalyze("test", "this is a test").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareCount("test").execute().actionGet();, +            fail("Expected ClusterBlockException");, +            client().prepareIndex("test", "type1", "1").setSource(XContentFactory.jsonBuilder().startObject().endObject()).setTimeout(timeout).execute().actionGet();, +            fail("Expected ClusterBlockException");, +++ b/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java, +            Scope currentClusterScope = getCurrentClusterScope();, +            if (currentClusterScope == Scope.TEST) {, +                clearClusters(); // it is ok to leave persistent / transient cluster state behind if scope is TEST, +            } else {, +            , +            }]