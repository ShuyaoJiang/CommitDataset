[+++ b/core/src/main/java/org/elasticsearch/common/network/NetworkService.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +    /**, +     * Resolves {@code bindHosts} to a list of internet addresses. The list will, +     * not contain duplicate addresses., +     * @param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames, +     *                  such as _local_ (see the documentation). if it is null, it will be populated, +     *                  based on global default settings., +     * @return unique set of internet addresses, +     */, +    public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException {, +        if (bindHosts == null) {, +            bindHosts = settings.getAsArray(GLOBAL_NETWORK_BINDHOST_SETTING, settings.getAsArray(GLOBAL_NETWORK_HOST_SETTING, null));, +        if (bindHosts == null) {, +        if (bindHosts == null) {, +            bindHosts = new String[] { DEFAULT_NETWORK_HOST };, +        InetAddress addresses[] = resolveInetAddresses(bindHosts);, +            // check if its a wildcard address: this is only ok if its the only address!, +            if (address.isAnyLocalAddress() && addresses.length > 1) {, +                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense");, +    /**, +     * Resolves {@code publishHosts} to a single publish address. The fact that it returns, +     * only one address is just a current limitation., +     * <p>, +     * If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>,, +     * and the user is warned (they can always just be more specific)., +     * @param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames, +     *                     such as _local_ (see the documentation). if it is null, it will be populated, +     *                     based on global default settings., +     * @return single internet address, +     */, +    public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException {, +        if (publishHosts == null) {, +            publishHosts = settings.getAsArray(GLOBAL_NETWORK_PUBLISHHOST_SETTING, settings.getAsArray(GLOBAL_NETWORK_HOST_SETTING, null));, +        if (publishHosts == null) {, +        if (publishHosts == null) {, +            publishHosts = new String[] { DEFAULT_NETWORK_HOST };, +        InetAddress addresses[] = resolveInetAddresses(publishHosts);, +        // for now... the hack begins, +        // 1. single wildcard address, probably set by network.host: expand to all interface addresses., +        if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {, +            HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses()));, +            addresses = all.toArray(new InetAddress[all.size()]);, +        }, +, +        // 2. try to deal with some (mis)configuration, +        for (InetAddress address : addresses) {, +            // check if its a wildcard address: this is only ok if its the only address!, +            // (if it was a single wildcard address, it was replaced by step 1 above), +                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense");, +        // 3. warn user if we end out with multiple publish addresses, +        if (addresses.length > 1) {, +            List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses));, +            NetworkUtils.sortAddresses(sorted);, +            addresses = new InetAddress[] { sorted.get(0) };, +            logger.warn("publish host: {} resolves to multiple addresses, auto-selecting {{}} as single publish address", , +                    Arrays.toString(publishHosts), NetworkAddress.format(addresses[0]));, +        }, +        return addresses[0];, +    }, +    , +    /** resolves (and deduplicates) host specification */, +    private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException {, +        if (hosts.length == 0) {, +            throw new IllegalArgumentException("empty host specification");, +        }, +        // deduplicate, in case of resolver misconfiguration, +        // stuff like https://bugzilla.redhat.com/show_bug.cgi?id=496300, +        HashSet<InetAddress> set = new HashSet<>();, +        for (String host : hosts) {, +            set.addAll(Arrays.asList(resolveInternal(host)));, +        }, +        return set.toArray(new InetAddress[set.size()]);, +    }, +, +    /** resolves a single host specification */, +    private InetAddress[] resolveInternal(String host) throws IOException {, +                case "site":, +                    return NetworkUtils.getSiteLocalAddresses();, +                case "site:ipv4":, +                    return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses());, +                case "site:ipv6":, +                    return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses());, +                case "global":, +                    return NetworkUtils.getGlobalAddresses();, +                case "global:ipv4":, +                    return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses());, +                case "global:ipv6":, +                    return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses());, +        return InetAddress.getAllByName(host);, +++ b/core/src/main/java/org/elasticsearch/common/network/NetworkService.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +    /**, +     * Resolves {@code bindHosts} to a list of internet addresses. The list will, +     * not contain duplicate addresses., +     * @param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames]