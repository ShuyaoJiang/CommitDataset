[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +        boolean success = false;, +        NodeChannels nodeChannels = null;, +            nodeChannels = connectToChannels(node, connectionProfile);, +            nodeChannels = new NodeChannels(nodeChannels, version);// clone the channels - we now have the correct version, +            success = true;, +            return nodeChannels;, +        } finally {, +            if (success == false) {, +                IOUtils.closeWhileHandlingException(nodeChannels);, +            }, +    protected void doClose() {, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +        boolean success = false;, +        NodeChannels nodeChannels = null;, +            nodeChannels = connectToChannels(node, connectionProfile);, +            nodeChannels = new NodeChannels(nodeChannels, version);// clone the channels - we now have the correct version, +            success = true;, +            return nodeChannels;, +        } finally {, +            if (success == false) {, +                IOUtils.closeWhileHandlingException(nodeChannels);, +            }, +    protected void doClose() {, +++ b/test/framework/src/main/java/org/elasticsearch/transport/MockTcpTransport.java, +import java.util.HashMap;, +import java.util.IdentityHashMap;, +    private final Map<MockChannel, Boolean> openChannels = new IdentityHashMap<>();, +, +            synchronized (openChannels) {, +                openChannels.put(this, Boolean.TRUE);, +            }, +                final Boolean removedChannel;, +                synchronized (openChannels) {, +                    removedChannel = openChannels.remove(this);, +                }, +                assert removedChannel : "Channel was not removed or removed twice?";, +    @Override, +    protected void doClose() {, +        if (Thread.currentThread().isInterrupted() == false) {, +            // TCPTransport might be interrupted due to a timeout waiting for connections to be closed., +            // in this case the thread is interrupted and we can't tell if we really missed something or if we are, +            // still closing connections. in such a case we don't assert the open channels, +            synchronized (openChannels) {, +                assert openChannels.isEmpty() : "there are still open channels: " + openChannels;, +            }, +        }, +    }]