[+++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/LicenseHeadersTask.groovy, +import org.gradle.api.file.FileCollection, +import org.gradle.api.tasks.OutputFile, +    @OutputFile, +    File reportFile = new File(project.buildDir, 'reports/licenseHeaders/rat.log'), +, +    /**, +     * The list of java files to check. protected so the afterEvaluate closure in the, +     * constructor can write to it., +     */, +    protected List<FileCollection> javaFiles, +, +        // Delay resolving the dependencies until after evaluation so we pick up generated sources, +        project.afterEvaluate {, +            javaFiles = project.sourceSets.collect({it.allJava}), +            inputs.files(javaFiles), +        }, +        List<FileCollection> input = javaFiles, +               for (FileCollection dirSet : input) {, +                   for (File dir: dirSet.srcDirs) {, +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/LicenseHeadersTask.groovy, +import org.gradle.api.file.FileCollection, +import org.gradle.api.tasks.OutputFile, +    @OutputFile, +    File reportFile = new File(project.buildDir, 'reports/licenseHeaders/rat.log'), +, +    /**, +     * The list of java files to check. protected so the afterEvaluate closure in the, +     * constructor can write to it., +     */, +    protected List<FileCollection> javaFiles, +, +        // Delay resolving the dependencies until after evaluation so we pick up generated sources, +        project.afterEvaluate {, +            javaFiles = project.sourceSets.collect({it.allJava}), +            inputs.files(javaFiles), +        }, +        List<FileCollection> input = javaFiles, +               for (FileCollection dirSet : input) {, +                   for (File dir: dirSet.srcDirs) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.groovy, +import org.gradle.api.tasks.Input, +import org.gradle.api.tasks.InputFiles, +import org.gradle.api.tasks.OutputFile, +    private List<String> excludes = [];, +, +    /**, +     * Input for the task. Set javadoc for {#link getJars} for more. Protected, +     * so the afterEvaluate closure in the constructor can write it., +     */, +    protected FileCollection jars;, +, +    /**, +     * Classpath against which to run the third patty audit. Protected so the, +     * afterEvaluate closure in the constructor can write it., +     */, +    protected FileCollection classpath;, +, +    /**, +     * We use a simple "marker" file that we touch when the task succeeds, +     * as the task output. This is compared against the modified time of the, +     * inputs (ie the jars/class files)., +     */, +    @OutputFile, +    File successMarker = new File(project.buildDir, 'markers/thirdPartyAudit'), +, +        project.afterEvaluate {, +            Configuration configuration = project.configurations.findByName('runtime');, +            if (configuration == null) {, +                // some projects apparently do not have 'runtime'? what a nice inconsistency,, +                // basically only serves to waste time in build logic!, +                configuration = project.configurations.findByName('testCompile');, +            }, +            assert configuration != null;, +            classpath = configuration, +, +            // we only want third party dependencies., +            jars = configuration.fileCollection({ dependency ->, +                dependency.group.startsWith("org.elasticsearch") == false, +            });]