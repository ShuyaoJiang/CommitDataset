[+++ b/src/test/java/org/elasticsearch/test/store/MockDirectoryHelper.java, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +        @Override, +        public synchronized IndexInput openInput(String name, IOContext context) throws IOException {, +            return new CloseTrackingMockIndexInputWrapper(name, super.openInput(name, context), logger);, +        }, +    }, +, +    private static class CloseTrackingMockIndexInputWrapper extends IndexInput {, +        private final AtomicBoolean closed = new AtomicBoolean(false);, +        private final String name;, +        private IndexInput delegate;, +        private final ESLogger logger;, +        private volatile RuntimeException closingStack;, +, +        public CloseTrackingMockIndexInputWrapper(String name, IndexInput delegate, ESLogger logger) {, +            super(name);, +            this.delegate = delegate;, +            this.logger = logger;, +            this.name = name;, +        }, +, +        @Override, +        public void close() throws IOException {, +            if (closed.compareAndSet(false, true)) {, +                closingStack = new RuntimeException("IndexInput closed");, +                delegate.close();, +            }, +        }, +, +        @Override, +        public IndexInput clone() {, +            ensureOpen();, +            return delegate.clone();, +        }, +, +, +        private void ensureOpen() {, +            if (closed.get()) {, +                logger.debug("Abusing IndexInput for: [" + name + "] - already closed", closingStack);, +                throw new RuntimeException("Abusing closed IndexInput!");, +            }, +        }, +, +        @Override, +        public long getFilePointer() {, +            ensureOpen();, +            return delegate.getFilePointer();, +        }, +, +        @Override, +        public void seek(long pos) throws IOException {, +            ensureOpen();, +            delegate.seek(pos);, +        }, +, +        @Override, +        public long length() {, +            ensureOpen();, +            return delegate.length();, +        }, +, +        @Override, +        public byte readByte() throws IOException {, +            ensureOpen();, +            return delegate.readByte();, +        }, +, +        @Override, +        public void readBytes(byte[] b, int offset, int len) throws IOException {, +            ensureOpen();, +            delegate.readBytes(b, offset, len);, +        }, +, +        @Override, +        public void readBytes(byte[] b, int offset, int len, boolean useBuffer), +                throws IOException {, +            ensureOpen();, +            delegate.readBytes(b, offset, len, useBuffer);, +        }, +, +        @Override, +        public short readShort() throws IOException {, +            ensureOpen();, +            return delegate.readShort();, +        }, +, +        @Override, +        public int readInt() throws IOException {, +            ensureOpen();, +            return delegate.readInt();, +        }, +, +        @Override, +        public long readLong() throws IOException {, +            ensureOpen();, +            return delegate.readLong();, +        }]