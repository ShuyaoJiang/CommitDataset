[+++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryModule.java, +    public static final String ZEN_MASTER_SERVICE_TYPE_KEY = "discovery.zen.masterservice.type";, +    private final Map<String, Class<? extends ElectMasterService>> masterServiceType = new HashMap<>();, +        addElectMasterService("zen", ElectMasterService.class);, +        if (discoveryTypes.containsKey(type)) {, +            throw new IllegalArgumentException("discovery type [" + type + "] is already registered");, +        }, +    /**, +     * Adds a custom zen master service type., +     */, +    public void addElectMasterService(String type, Class<? extends ElectMasterService> masterService) {, +        if (masterServiceType.containsKey(type)) {, +            throw new IllegalArgumentException("master service type [" + type + "] is already registered");, +        }, +        this.masterServiceType.put(type, masterService);, +    }, +, +            String masterServiceTypeKey = settings.get(ZEN_MASTER_SERVICE_TYPE_KEY, "zen");, +            final Class<? extends ElectMasterService> masterService = masterServiceType.get(masterServiceTypeKey);, +            if (masterService == null) {, +                throw new IllegalArgumentException("Unknown master service type [" + masterServiceTypeKey + "]");, +            }, +            if (masterService == ElectMasterService.class) {, +            } else {, +                bind(ElectMasterService.class).to(masterService).asEagerSingleton();, +            }, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryModule.java, +    public static final String ZEN_MASTER_SERVICE_TYPE_KEY = "discovery.zen.masterservice.type";, +    private final Map<String, Class<? extends ElectMasterService>> masterServiceType = new HashMap<>();, +        addElectMasterService("zen", ElectMasterService.class);, +        if (discoveryTypes.containsKey(type)) {, +            throw new IllegalArgumentException("discovery type [" + type + "] is already registered");, +        }, +    /**, +     * Adds a custom zen master service type., +     */, +    public void addElectMasterService(String type, Class<? extends ElectMasterService> masterService) {, +        if (masterServiceType.containsKey(type)) {, +            throw new IllegalArgumentException("master service type [" + type + "] is already registered");, +        }, +        this.masterServiceType.put(type, masterService);, +    }, +, +            String masterServiceTypeKey = settings.get(ZEN_MASTER_SERVICE_TYPE_KEY, "zen");, +            final Class<? extends ElectMasterService> masterService = masterServiceType.get(masterServiceTypeKey);, +            if (masterService == null) {, +                throw new IllegalArgumentException("Unknown master service type [" + masterServiceTypeKey + "]");, +            }, +            if (masterService == ElectMasterService.class) {, +            } else {, +                bind(ElectMasterService.class).to(masterService).asEagerSingleton();, +            }, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.common.inject.binder.LinkedBindingBuilder;, +import org.elasticsearch.search.aggregations.*;, +import org.elasticsearch.search.aggregations.bucket.significant.heuristics.*;, +import org.elasticsearch.search.aggregations.bucket.terms.*;, +import org.elasticsearch.search.aggregations.pipeline.movavg.models.*;, +import org.elasticsearch.search.highlight.*;, +import org.elasticsearch.search.suggest.*;, +, +        // configure search private classes..., +        bind(DfsPhase.class).asEagerSingleton();, +        bind(QueryPhase.class).asEagerSingleton();, +        bind(SearchPhaseController.class).asEagerSingleton();, +        bind(FetchPhase.class).asEagerSingleton();, +        bind(SearchServiceTransportAction.class).asEagerSingleton();, +        bind(MoreLikeThisFetchService.class).asEagerSingleton();, +, +        // search service -- testing only!, +        String impl = settings.get(SEARCH_SERVICE_IMPL);, +        if (impl == null) {, +            bind(SearchService.class).asEagerSingleton();, +        } else {, +            Class<? extends SearchService> implClass = Classes.loadClass(getClass().getClassLoader(), impl);, +            bind(SearchService.class).to(implClass).asEagerSingleton();, +        // aggs, +, +        // highlighters, +        Multibinder<Highlighter> multibinder = Multibinder.newSetBinder(binder(), Highlighter.class);, +        for (Class<? extends Highlighter> highlighter : highlighters) {, +            multibinder.addBinding().to(highlighter);, +        }, +        bind(Highlighters.class).asEagerSingleton();, +, +        // suggest, +        Multibinder<Suggester> suggesterMultibinder = Multibinder.newSetBinder(binder(), Suggester.class);, +        for (Class<? extends Suggester> clazz : suggesters) {, +            suggesterMultibinder.addBinding().to(clazz);, +        bind(SuggestParseElement.class).asEagerSingleton();, +        bind(SuggestPhase.class).asEagerSingleton();, +        bind(Suggesters.class).asEagerSingleton();, +        // function score, +        Multibinder<ScoreFunctionParser> parserMapBinder = Multibinder.newSetBinder(binder(), ScoreFunctionParser.class);, +        for (Class<? extends ScoreFunctionParser> clazz : functionScoreParsers) {, +            parserMapBinder.addBinding().to(clazz);, +        bind(ScoreFunctionParserMapper.class);, +, +        // fetch sub phase, +        Multibinder<FetchSubPhase> fetchSubPhaseMultibinder = Multibinder.newSetBinder(binder(), FetchSubPhase.class);]