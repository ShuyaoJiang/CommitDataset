[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedRunnable.java, +import java.util.concurrent.TimeUnit;, +import java.util.function.LongSupplier;, +, +    private final LongSupplier relativeTimeProvider;, +        this(priority, System::nanoTime);, +    }, +, +    // package visible for testing, +    PrioritizedRunnable(Priority priority, LongSupplier relativeTimeProvider) {, +        this.creationDate = relativeTimeProvider.getAsLong();, +        this.relativeTimeProvider = relativeTimeProvider;, +        return TimeUnit.MILLISECONDS.convert(relativeTimeProvider.getAsLong() - creationDate, TimeUnit.NANOSECONDS);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.get(src: "http://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}",, +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                PercolateShardRequest shardRequest = new PercolateShardRequest();, +                shardRequest.readFrom(in);, +                item.request.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/cluster/InternalClusterInfoService.java, +                    logger.trace("node: [{}], most available: total disk: {}, available disk: {} / least available: total disk: {}, available disk: {}",, +                            nodeId, mostAvailablePath.getTotal(), leastAvailablePath.getAvailable(),, +                            leastAvailablePath.getTotal(), leastAvailablePath.getAvailable());, +                if (leastAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] least available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, leastAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }, +                if (mostAvailablePath.getTotal().bytes() < 0) {, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("node: [{}] most available path has less than 0 total bytes of disk [{}], skipping",, +                                nodeId, mostAvailablePath.getTotal().bytes());, +                    }, +                } else {, +                }]