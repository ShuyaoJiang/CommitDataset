[+++ b/core/src/main/java/org/elasticsearch/index/query/support/NestedInnerQueryParseSupport.java, +import org.apache.lucene.search.join.BitSetProducer;, +import org.elasticsearch.common.lucene.search.Queries;, +    private Query innerQuery;, +    private boolean queryParsed = false;, +    protected boolean queryFound = false;, +    protected BitSetProducer parentFilter;, +    protected Query childFilter;, +, +    private ObjectMapper parentObjectMapper;, +, +    }, +, +    public NestedInnerQueryParseSupport(QueryShardContext context) {, +        this.parseContext = context.parseContext();, +        this.shardContext = context;, +    }, +, +    public void query() throws IOException {, +        if (path != null) {, +            setPathLevel();, +            try {, +                innerQuery = parseContext.parseInnerQueryBuilder().toQuery(this.shardContext);, +            } finally {, +                resetPathLevel();, +            }, +            queryParsed = true;, +        } else {, +            source = XContentFactory.smileBuilder().copyCurrentStructure(parseContext.parser()).bytes();, +        }, +        queryFound = true;, +    public Query getInnerQuery() throws IOException {, +        if (queryParsed) {, +            return innerQuery;, +        } else {, +            if (path == null) {, +                throw new QueryShardException(shardContext, "[nested] requires 'path' field");, +            }, +            if (!queryFound) {, +                throw new QueryShardException(shardContext, "[nested] requires either 'query' or 'filter' field");, +            }, +, +            XContentParser old = parseContext.parser();, +            try {, +                XContentParser innerParser = XContentHelper.createParser(source);, +                parseContext.parser(innerParser);, +                setPathLevel();, +                try {, +                    innerQuery = parseContext.parseInnerQueryBuilder().toQuery(this.shardContext);, +                } finally {, +                    resetPathLevel();, +                }, +                queryParsed = true;, +                return innerQuery;, +            } finally {, +                parseContext.parser(old);, +            }, +        }, +    }, +, +    public boolean queryFound() {, +        return queryFound;, +    }, +, +    public ObjectMapper getParentObjectMapper() {, +        return parentObjectMapper;, +    }, +, +        ObjectMapper objectMapper = shardContext.nestedScope().getObjectMapper();, +        if (objectMapper == null) {, +            parentFilter = shardContext.bitsetFilter(Queries.newNonNestedFilter());, +        } else {, +            parentFilter = shardContext.bitsetFilter(objectMapper.nestedTypeFilter());, +        }, +        childFilter = nestedObjectMapper.nestedTypeFilter();, +        parentObjectMapper = shardContext.nestedScope().nextLevel(nestedObjectMapper);, +++ b/core/src/main/java/org/elasticsearch/index/query/support/NestedInnerQueryParseSupport.java, +import org.apache.lucene.search.join.BitSetProducer;, +import org.elasticsearch.common.lucene.search.Queries;, +    private Query innerQuery;, +    private boolean queryParsed = false;, +    protected boolean queryFound = false;, +    protected BitSetProducer parentFilter;, +    protected Query childFilter;, +, +    private ObjectMapper parentObjectMapper;, +, +    }, +, +    public NestedInnerQueryParseSupport(QueryShardContext context) {, +        this.parseContext = context.parseContext();, +        this.shardContext = context;, +    }, +, +    public void query() throws IOException {, +        if (path != null) {, +            setPathLevel();, +            try {, +                innerQuery = parseContext.parseInnerQueryBuilder().toQuery(this.shardContext);, +            } finally {]