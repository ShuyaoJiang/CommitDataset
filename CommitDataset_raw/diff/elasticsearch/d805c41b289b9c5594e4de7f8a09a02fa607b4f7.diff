[+++ b/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java, +    static List<Object> parseValues(XContentParser parser) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java, +    static List<Object> parseValues(XContentParser parser) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/query/TermsSetQueryBuilder.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.query;, +, +import org.apache.lucene.index.DocValues;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.NumericDocValues;, +import org.apache.lucene.index.SortedNumericDocValues;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.CoveringQuery;, +import org.apache.lucene.search.DoubleValues;, +import org.apache.lucene.search.LongValues;, +import org.apache.lucene.search.LongValuesSource;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.TermQuery;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.lucene.BytesRefs;, +import org.elasticsearch.common.lucene.search.Queries;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.fielddata.IndexNumericFieldData;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.script.Script;, +import org.elasticsearch.script.SearchScript;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Objects;, +, +public final class TermsSetQueryBuilder extends AbstractQueryBuilder<TermsSetQueryBuilder> {, +, +    public static final String NAME = "terms_set";, +, +    static final ParseField TERMS_FIELD = new ParseField("terms");, +    static final ParseField MINIMUM_SHOULD_MATCH_FIELD = new ParseField("minimum_should_match_field");, +    static final ParseField MINIMUM_SHOULD_MATCH_SCRIPT = new ParseField("minimum_should_match_script");, +, +    private final String fieldName;, +    private final List<?> values;, +, +    private String minimumShouldMatchField;, +    private Script minimumShouldMatchScript;, +, +    public TermsSetQueryBuilder(String fieldName, List<?> values) {, +        this.fieldName = Objects.requireNonNull(fieldName);, +        this.values = TermsQueryBuilder.convert(Objects.requireNonNull(values));, +    }, +, +    public TermsSetQueryBuilder(StreamInput in) throws IOException {, +        super(in);, +        this.fieldName = in.readString();, +        this.values = (List<?>) in.readGenericValue();, +        this.minimumShouldMatchField = in.readOptionalString();, +        this.minimumShouldMatchScript = in.readOptionalWriteable(Script::new);, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeString(fieldName);, +        out.writeGenericValue(values);, +        out.writeOptionalString(minimumShouldMatchField);, +        out.writeOptionalWriteable(minimumShouldMatchScript);, +    }, +, +    public List<?> getValues() {, +        return values;, +    }, +, +    public String getMinimumShouldMatchField() {, +        return minimumShouldMatchField;, +    }, +]