[+++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java, +        // assume worst-case: use the minor axis, +        double radDist = unit.toMeters(distance) / GeoUtils.EARTH_SEMI_MINOR_AXIS;, +++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java, +        // assume worst-case: use the minor axis, +        double radDist = unit.toMeters(distance) / GeoUtils.EARTH_SEMI_MINOR_AXIS;, +++ b/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceFilter.java, +    private final GeoDistance.DistanceBoundingCheck distanceBoundingCheck;, +        GeoDistance.DistanceBoundingCheck distanceBoundingCheck = null;, +        this.distanceBoundingCheck = distanceBoundingCheck;, +++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java, +        // assume worst-case: use the minor axis, +        double radDist = unit.toMeters(distance) / GeoUtils.EARTH_SEMI_MINOR_AXIS;, +++ b/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceFilter.java, +    private final GeoDistance.DistanceBoundingCheck distanceBoundingCheck;, +        GeoDistance.DistanceBoundingCheck distanceBoundingCheck = null;, +        this.distanceBoundingCheck = distanceBoundingCheck;, +++ b/src/test/java/org/elasticsearch/search/geo/GeoDistanceTests.java, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.search.SearchType;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +    private double randomLon() {, +        return randomDouble() * 360 - 180;, +    }, +, +    private double randomLat() {, +        return randomDouble() * 180 - 90;, +    }, +, +    public void testDuelOptimizations() throws Exception {, +        assertAcked(prepareCreate("index").addMapping("type", "location", "type=geo_point,lat_lon=true"));, +        final int numDocs = scaledRandomIntBetween(3000, 10000);, +        List<IndexRequestBuilder> docs = new ArrayList<>();, +        for (int i = 0; i < numDocs; ++i) {, +            docs.add(client().prepareIndex("index", "type").setSource(jsonBuilder().startObject().startObject("location").field("lat", randomLat()).field("lon", randomLon()).endObject().endObject()));, +        }, +        indexRandom(true, docs);, +        ensureSearchable();, +, +        for (int i = 0; i < 10; ++i) {, +            final double originLat = randomLat();, +            final double originLon = randomLon();, +            final String distance = DistanceUnit.KILOMETERS.toString(randomInt(10000));, +            for (GeoDistance geoDistance : Arrays.asList(GeoDistance.ARC, GeoDistance.SLOPPY_ARC)) {, +                logger.info("Now testing GeoDistance={}, distance={}, origin=({}, {})", geoDistance, distance, originLat, originLon);, +                long matches = -1;, +                for (String optimizeBbox : Arrays.asList("none", "memory", "indexed")) {, +                    SearchResponse resp = client().prepareSearch("index").setSearchType(SearchType.COUNT).setQuery(QueryBuilders.constantScoreQuery(, +                            FilterBuilders.geoDistanceFilter("location").point(originLat, originLon).distance(distance).geoDistance(geoDistance).optimizeBbox(optimizeBbox))).execute().actionGet();, +                    assertSearchResponse(resp);, +                    logger.info("{} -> {} hits", optimizeBbox, resp.getHits().totalHits());, +                    if (matches < 0) {, +                        matches = resp.getHits().totalHits();, +                    } else {, +                        assertEquals(matches, resp.getHits().totalHits());, +                    }, +                }, +            }, +        }, +    }, +]