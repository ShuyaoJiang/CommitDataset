[+++ b/src/main/java/org/elasticsearch/common/util/concurrent/AtomicArray.java, +     * Copies the content of the underlying atomic array to a normal one., +++ b/src/main/java/org/elasticsearch/common/util/concurrent/AtomicArray.java, +     * Copies the content of the underlying atomic array to a normal one., +++ b/src/main/java/org/elasticsearch/search/controller/SearchPhaseController.java, +import java.util.*;, +    public static Comparator<AtomicArray.Entry<? extends QuerySearchResultProvider>> QUERY_RESULT_ORDERING = new Comparator<AtomicArray.Entry<? extends QuerySearchResultProvider>>() {, +        public int compare(AtomicArray.Entry<? extends QuerySearchResultProvider> o1, AtomicArray.Entry<? extends QuerySearchResultProvider> o2) {, +    public ScoreDoc[] sortDocs(AtomicArray<? extends QuerySearchResultProvider> resultsArr) {, +        List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> results = resultsArr.asList();, +        if (results.isEmpty()) {, +            if (results.size() == 1) {, +                result = results.get(0).value.queryResult();, +                shardIndex = results.get(0).index;, +                for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : results) {, +        @SuppressWarnings("unchecked"), +        AtomicArray.Entry<? extends QuerySearchResultProvider>[] sortedResults = results.toArray(new AtomicArray.Entry[results.size()]);, +        Arrays.sort(sortedResults, QUERY_RESULT_ORDERING);, +        QuerySearchResultProvider firstResult = sortedResults[0].value;, +            queueSize *= sortedResults.length;, +                for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : sortedResults) {, +            for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : sortedResults) {, +            for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : sortedResults) {, +            resultDocsSize *= sortedResults.length;, +    public InternalSearchResponse merge(ScoreDoc[] sortedDocs, AtomicArray<? extends QuerySearchResultProvider> queryResultsArr, AtomicArray<? extends FetchSearchResultProvider> fetchResultsArr) {, +        List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> queryResults = queryResultsArr.asList();, +        List<? extends AtomicArray.Entry<? extends FetchSearchResultProvider>> fetchResults = fetchResultsArr.asList();, +        if (queryResults.isEmpty()) {, +        QuerySearchResult firstResult = queryResults.get(0).value.queryResult();, +        boolean sorted = false;, +        int sortScoreIndex = -1;, +        if (firstResult.topDocs() instanceof TopFieldDocs) {, +            TopFieldDocs fieldDocs = (TopFieldDocs) firstResult.queryResult().topDocs();, +        if (!queryResults.isEmpty()) {, +            if (firstResult.facets() != null && firstResult.facets().facets() != null && !firstResult.facets().facets().isEmpty()) {, +                for (Facet facet : firstResult.facets()) {, +                    for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {, +        for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {, +        for (AtomicArray.Entry<? extends FetchSearchResultProvider> entry : fetchResults) {, +        if (!fetchResults.isEmpty()) {, +                FetchSearchResultProvider fetchResultProvider = fetchResultsArr.get(shardDoc.shardIndex);, +        if (!queryResults.isEmpty()) {, +            for (AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {]