[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.ExceptionsHelper;, +        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, clusterName, clusterService);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.ExceptionsHelper;, +        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, clusterName, clusterService);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ProcessedClusterStateNonMasterUpdateTask;, +import org.elasticsearch.common.Nullable;, +    private final ClusterService clusterService;, +                                ClusterName clusterName, ClusterService clusterService) {, +        this.clusterService = clusterService;, +            final MasterPingRequest request = new MasterPingRequest(clusterService.localNode().id(), masterToPing.id(), clusterName);, +        public void messageReceived(final MasterPingRequest request, final TransportChannel channel) throws Exception {, +            final DiscoveryNodes nodes = clusterService.state().nodes();, +            // when we are elected as master or when a node joins, we use a cluster state update thread, +            // to incorporate that information in the cluster state. That cluster state is published, +            // before we make it available locally. This means that a master ping can come from a node, +            // that has already processed the new CS but it is not known locally., +            // Therefore, if we fail we have to check again under a cluster state thread to make sure, +            // all processing is finished., +            //, +, +, +            if (!nodes.localNodeMaster() || !nodes.nodeExists(request.nodeId)) {, +                logger.trace("checking ping from [{}] under a cluster state thread", request.nodeId);, +                clusterService.submitStateUpdateTask("master ping (from: [" + request.nodeId + "])", new ProcessedClusterStateNonMasterUpdateTask() {, +, +                    @Override, +                    public ClusterState execute(ClusterState currentState) throws Exception {, +                        DiscoveryNodes nodes = currentState.nodes();, +                        return currentState;, +                    }, +, +                    @Override, +                    public void onFailure(String source, @Nullable Throwable t) {, +                        if (t == null) {, +                            t = new ElasticsearchException("unknown error while processing ping");, +                        }, +                        try {, +                            channel.sendResponse(t);, +                        } catch (IOException e) {, +                            logger.warn("error while sending ping response", e);, +                        }, +                    }, +, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        try {, +                            channel.sendResponse(new MasterPingResponseResponse(true));, +                        } catch (IOException e) {, +                            logger.warn("error while sending ping response", e);, +                        }, +                    }, +                });, +            } else {, +                channel.sendResponse(new MasterPingResponseResponse(true));, +            }, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.ExceptionsHelper;, +        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, clusterName, clusterService);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ProcessedClusterStateNonMasterUpdateTask;, +import org.elasticsearch.common.Nullable;, +    private final ClusterService clusterService;, +                                ClusterName clusterName, ClusterService clusterService) {, +        this.clusterService = clusterService;, +            final MasterPingRequest request = new MasterPingRequest(clusterService.localNode().id(), masterToPing.id(), clusterName);, +        public void messageReceived(final MasterPingRequest request, final TransportChannel channel) throws Exception {, +            final DiscoveryNodes nodes = clusterService.state().nodes();, +            // when we are elected as master or when a node joins, we use a cluster state update thread, +            // to incorporate that information in the cluster state. That cluster state is published, +            // before we make it available locally. This means that a master ping can come from a node, +            // that has already processed the new CS but it is not known locally., +            // Therefore, if we fail we have to check again under a cluster state thread to make sure, +            // all processing is finished., +            //, +, +, +            if (!nodes.localNodeMaster() || !nodes.nodeExists(request.nodeId)) {, +                logger.trace("checking ping from [{}] under a cluster state thread", request.nodeId);, +                clusterService.submitStateUpdateTask("master ping (from: [" + request.nodeId + "])", new ProcessedClusterStateNonMasterUpdateTask() {, +, +                    @Override, +                    public ClusterState execute(ClusterState currentState) throws Exception {]