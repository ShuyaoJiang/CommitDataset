[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +    /**, +     * Returns the number of routing nodes, +     */, +    public int size() {, +        return nodesToShards.size();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +    /**, +     * Returns the number of routing nodes, +     */, +    public int size() {, +        return nodesToShards.size();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        if (allocation.routingNodes().size() == 0) {, +            /* with no nodes this is pointless */, +            return false;, +        }, +        boolean changed = balancer.allocateUnassigned();, +            final float weightShard = node.numShards() + numAdditionalShards - balancer.avgShardsPerNode();, +            final float weightIndex = node.numShards(index) + numAdditionalShards - balancer.avgShardsPerNode(index);, +            avgShardsPerNode = ((float) metaData.totalNumberOfShards()) / routingNodes.size();, +            buildModelFromAssigned();, +         * Balances the nodes on the cluster model according to the weight function., +         * The actual balancing is delegated to {@link #balanceByWeights()}, +         *, +        private boolean balance() {, +            if (logger.isTraceEnabled()) {, +                logger.trace("Start balancing cluster");, +            }, +            if (allocation.hasPendingAsyncFetch()) {, +                /*, +                 * see https://github.com/elastic/elasticsearch/issues/14387, +                 * if we allow rebalance operations while we are still fetching shard store data, +                 * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +                 * since once the fetches come back we might just move all the shards back again., +                 * Therefore we only do a rebalance if we have fetched all information., +                 */, +                logger.debug("skipping rebalance due to in-flight shard/store fetches");, +                return false;, +            }, +            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {, +                logger.trace("skipping rebalance as it is disabled");, +                return false;, +            }, +            if (nodes.size() < 2) { /* skip if we only have one node */, +                logger.trace("skipping rebalance as single node only");, +                return false;, +            }, +            return balanceByWeights();, +        private boolean balanceByWeights() {, +            boolean changed = false;, +            final NodeSorter sorter = newNodeSorter();, +            final AllocationDeciders deciders = allocation.deciders();, +                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {, +            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class);, +            // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling, +            boolean changed = false;, +            final NodeSorter sorter = newNodeSorter();, +                for (RoutingNode routingNode : allocation.routingNodes()) {, +                        final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());, +                        assert sourceNode != null && sourceNode.containsShard(shardRouting);, +                        Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +                        if (decision.type() == Decision.Type.NO) {, +                            changed |= moveShard(sorter, shardRouting, sourceNode, routingNode);, +                        }, +, +            return changed;, +        /**, +         * Move started shard to the minimal eligible node with respect to the weight function, +         *, +         * @return <code>true</code> if the shard was moved successfully, otherwise <code>false</code>, +         */, +        private boolean moveShard(NodeSorter sorter, ShardRouting shardRouting, ModelNode sourceNode, RoutingNode routingNode) {, +            for (ModelNode currentNode : sorter.modelNodes) {, +                if (currentNode != sourceNode) {, +                    RoutingNode target = currentNode.getRoutingNode();, +                        sourceNode.removeShard(shardRouting);, +                        currentNode.addShard(targetRelocatingShard);, +                        return true;, +            }, +            return false;, +        private void buildModelFromAssigned() {, +            for (RoutingNode rn : routingNodes) {, +                ModelNode node = new ModelNode(rn);, +                nodes.put(rn.nodeId(), node);, +                for (ShardRouting shard : rn) {, +                    assert rn.nodeId().equals(shard.currentNodeId());, +                    if (shard.state() != RELOCATING) {, +                        node.addShard(shard);, +            }, +        }, +         * @return <code>true</code> if the current configuration has been, +         *         changed, otherwise <code>false</code>, +        private boolean allocateUnassigned() {, +            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned();, +            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>());]