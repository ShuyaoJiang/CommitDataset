[+++ b/src/main/java/org/elasticsearch/cluster/ClusterService.java, +    /**, +     * Remove an initial block to be set on the first cluster state created., +     */, +++ b/src/main/java/org/elasticsearch/cluster/ClusterService.java, +    /**, +     * Remove an initial block to be set on the first cluster state created., +     */, +++ b/src/main/java/org/elasticsearch/common/settings/ImmutableSettings.java, +        if (!Strings.hasLength(settingPrefix)) {, +            throw new ElasticsearchIllegalArgumentException("illegal setting prefix " + settingPrefix);, +        }, +++ b/src/main/java/org/elasticsearch/cluster/ClusterService.java, +    /**, +     * Remove an initial block to be set on the first cluster state created., +     */, +++ b/src/main/java/org/elasticsearch/common/settings/ImmutableSettings.java, +        if (!Strings.hasLength(settingPrefix)) {, +            throw new ElasticsearchIllegalArgumentException("illegal setting prefix " + settingPrefix);, +        }, +++ b/src/main/java/org/elasticsearch/node/internal/InternalNode.java, +        // create the environment based on the finalized (processed) view of the settings, +++ b/src/main/java/org/elasticsearch/cluster/ClusterService.java, +    /**, +     * Remove an initial block to be set on the first cluster state created., +     */, +++ b/src/main/java/org/elasticsearch/common/settings/ImmutableSettings.java, +        if (!Strings.hasLength(settingPrefix)) {, +            throw new ElasticsearchIllegalArgumentException("illegal setting prefix " + settingPrefix);, +        }, +++ b/src/main/java/org/elasticsearch/node/internal/InternalNode.java, +        // create the environment based on the finalized (processed) view of the settings, +++ b/src/main/java/org/elasticsearch/tribe/TribeService.java, +import org.elasticsearch.ElasticsearchInterruptedException;, +            throw new ElasticsearchInterruptedException(e.getMessage(), e);, +            try {, +            } catch (Throwable e) {, +                // calling close is safe for non started nodes, we can just iterate over all, +                for (InternalNode otherNode : nodes) {, +                    try {, +                        otherNode.close();, +                    } catch (Throwable t) {, +                        logger.warn("failed to close node {} on failed start", otherNode, t);, +                    }, +                }, +                if (e instanceof RuntimeException) {, +                    throw (RuntimeException) e;, +                }, +                throw new ElasticsearchException(e.getMessage(), e);, +            }, +            try {, +            } catch (Throwable t) {, +                logger.warn("failed to stop node {}", t, node);, +            }, +            try {, +            } catch (Throwable t) {, +                logger.warn("failed to close node {}", t, node);, +            }]