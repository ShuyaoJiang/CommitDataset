[+++ b/server/src/main/java/org/elasticsearch/cluster/service/MasterService.java, +            return new DelegatingAckListener(nonFailedTasks.stream(), +                .filter(task -> task.listener instanceof AckedClusterStateTaskListener), +                .map(task -> new AckCountDownListener((AckedClusterStateTaskListener) task.listener, newClusterState.version(),, +                    newClusterState.nodes(), threadPool)), +                .collect(Collectors.toList()));, +        public void onCommit(TimeValue commitTime) {, +            for (Discovery.AckListener listener : listeners) {, +                listener.onCommit(commitTime);, +            }, +        }, +, +        @Override, +        private final ThreadPool threadPool;, +        private volatile Future<?> ackTimeoutCallback;, +            this.threadPool = threadPool;, +            this.countDown = new CountDown(countDown + 1); // we also wait for onCommit to be called, +        }, +, +        @Override, +        public void onCommit(TimeValue commitTime) {, +            TimeValue ackTimeout = ackedTaskListener.ackTimeout();, +            if (ackTimeout == null) {, +                ackTimeout = TimeValue.ZERO;, +            }, +            final TimeValue timeLeft = TimeValue.timeValueNanos(Math.max(0, ackTimeout.nanos() - commitTime.nanos()));, +            if (timeLeft.nanos() == 0L) {, +                onTimeout();, +            } else if (countDown.countDown()) {, +                finish();, +            } else {, +                this.ackTimeoutCallback = threadPool.schedule(timeLeft, ThreadPool.Names.GENERIC, this::onTimeout);, +                // re-check if onNodeAck has not completed while we were scheduling the timeout, +                if (countDown.isCountedDown()) {, +                    FutureUtils.cancel(ackTimeoutCallback);, +                }, +            }, +                finish();, +            }, +        }, +, +        private void finish() {, +++ b/server/src/main/java/org/elasticsearch/cluster/service/MasterService.java, +            return new DelegatingAckListener(nonFailedTasks.stream(), +                .filter(task -> task.listener instanceof AckedClusterStateTaskListener), +                .map(task -> new AckCountDownListener((AckedClusterStateTaskListener) task.listener, newClusterState.version(),, +                    newClusterState.nodes(), threadPool)), +                .collect(Collectors.toList()));, +        public void onCommit(TimeValue commitTime) {, +            for (Discovery.AckListener listener : listeners) {, +                listener.onCommit(commitTime);, +            }, +        }, +, +        @Override, +        private final ThreadPool threadPool;, +        private volatile Future<?> ackTimeoutCallback;, +            this.threadPool = threadPool;, +            this.countDown = new CountDown(countDown + 1); // we also wait for onCommit to be called, +        }, +, +        @Override, +        public void onCommit(TimeValue commitTime) {, +            TimeValue ackTimeout = ackedTaskListener.ackTimeout();, +            if (ackTimeout == null) {, +                ackTimeout = TimeValue.ZERO;, +            }, +            final TimeValue timeLeft = TimeValue.timeValueNanos(Math.max(0, ackTimeout.nanos() - commitTime.nanos()));, +            if (timeLeft.nanos() == 0L) {, +                onTimeout();, +            } else if (countDown.countDown()) {, +                finish();, +            } else {, +                this.ackTimeoutCallback = threadPool.schedule(timeLeft, ThreadPool.Names.GENERIC, this::onTimeout);, +                // re-check if onNodeAck has not completed while we were scheduling the timeout, +                if (countDown.isCountedDown()) {, +                    FutureUtils.cancel(ackTimeoutCallback);, +                }, +            }, +                finish();, +            }, +        }, +, +        private void finish() {, +++ b/server/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.common.unit.TimeValue;, +        /**, +         * Should be called when the discovery layer has committed the clusters state (i.e. even if this publication fails,, +         * it is guaranteed to appear in future publications)., +         * @param commitTime the time it took to commit the cluster state, +         */, +        void onCommit(TimeValue commitTime);, +, +        /**, +         * Should be called whenever the discovery layer receives confirmation from a node that it has successfully applied, +         * the cluster state. In case of failures, an exception should be provided as parameter., +         * @param node the node, +         * @param e the optional exception, +         */, +++ b/server/src/main/java/org/elasticsearch/cluster/service/MasterService.java]