[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +    private LeafReaderContext reader;, +    , +        // Reset parentFilter, so we resolve the parentDocs for each new segment being searched, +        this.parentFilter = null;, +        this.reader = reader;, +        if (parentFilter == null) {, +            // The aggs are instantiated in reverse, first the most inner nested aggs and lastly the top level aggs, +            // So at the time a nested 'nested' aggs is parsed its closest parent nested aggs hasn't been constructed., +            // So the trick is to set at the last moment just before needed and we can use its child filter as the, +            // parent filter., +, +            // Additional NOTE: Before this logic was performed in the setNextReader(...) method, but the the assumption, +            // that aggs instances are constructed in reverse doesn't hold when buckets are constructed lazily during, +            // aggs execution, +            Filter parentFilterNotCached = findClosestNestedPath(parentAggregator);, +            if (parentFilterNotCached == null) {, +                parentFilterNotCached = NonNestedDocsFilter.INSTANCE;, +            }, +            parentFilter = context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(parentFilterNotCached);, +            BitDocIdSet parentSet = parentFilter.getDocIdSet(reader);, +            if (DocIdSets.isEmpty(parentSet)) {, +                // There are no parentDocs in the segment, so return and set childDocs to null, so we exit early for future invocations., +                childDocs = null;, +                return;, +            } else {, +                parentDocs = parentSet.bits();, +            }, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +    private LeafReaderContext reader;, +    , +        // Reset parentFilter, so we resolve the parentDocs for each new segment being searched, +        this.parentFilter = null;, +        this.reader = reader;, +        if (parentFilter == null) {, +            // The aggs are instantiated in reverse, first the most inner nested aggs and lastly the top level aggs, +            // So at the time a nested 'nested' aggs is parsed its closest parent nested aggs hasn't been constructed., +            // So the trick is to set at the last moment just before needed and we can use its child filter as the, +            // parent filter., +, +            // Additional NOTE: Before this logic was performed in the setNextReader(...) method, but the the assumption, +            // that aggs instances are constructed in reverse doesn't hold when buckets are constructed lazily during, +            // aggs execution, +            Filter parentFilterNotCached = findClosestNestedPath(parentAggregator);, +            if (parentFilterNotCached == null) {, +                parentFilterNotCached = NonNestedDocsFilter.INSTANCE;, +            }, +            parentFilter = context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(parentFilterNotCached);, +            BitDocIdSet parentSet = parentFilter.getDocIdSet(reader);, +            if (DocIdSets.isEmpty(parentSet)) {, +                // There are no parentDocs in the segment, so return and set childDocs to null, so we exit early for future invocations., +                childDocs = null;, +                return;, +            } else {, +                parentDocs = parentSet.bits();, +            }, +        }, +, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.search.aggregations.bucket.filter.Filter;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +import static org.elasticsearch.index.query.FilterBuilders.termFilter;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.*;, +, +    @Test, +    // Test based on: https://github.com/elasticsearch/elasticsearch/issues/9280, +    public void testParentFilterResolvedCorrectly() throws Exception {, +        XContentBuilder mapping = jsonBuilder().startObject().startObject("provider").startObject("properties"), +                    .startObject("comments"), +                        .field("type", "nested"), +                        .startObject("properties"), +                            .startObject("cid").field("type", "long").endObject(), +                            .startObject("identifier").field("type", "string").field("index", "not_analyzed").endObject(), +                            .startObject("tags"), +                                .field("type", "nested"), +                                .startObject("properties"), +                                    .startObject("tid").field("type", "long").endObject(), +                                    .startObject("name").field("type", "string").field("index", "not_analyzed").endObject(), +                                .endObject(), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                    .startObject("dates"), +                        .field("type", "object"), +                        .startObject("properties"), +                            .startObject("day").field("type", "date").field("format", "dateOptionalTime").endObject(), +                            .startObject("month"), +                                .field("type", "object"), +                                .startObject("properties"), +                                    .startObject("end").field("type", "date").field("format", "dateOptionalTime").endObject(), +                                    .startObject("start").field("type", "date").field("format", "dateOptionalTime").endObject(), +                                    .startObject("label").field("type", "string").field("index", "not_analyzed").endObject(), +                                .endObject(), +                            .endObject(), +                        .endObject(), +                    .endObject()]