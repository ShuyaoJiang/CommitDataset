[+++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +import org.elasticsearch.common.lucene.store.ByteArrayIndexInput;, +        private final byte[] footerChecksum = new byte[8]; // this holds the actual footer checksum data written by to this output, +            checksumPosition = metadata.length() - 8; // the last 8 bytes are the checksum - we store it in footerChecksum, +            String footerDigest = null;, +                ByteArrayIndexInput indexInput = new ByteArrayIndexInput("checksum", this.footerChecksum);, +                footerDigest = digestToString(indexInput.readLong());, +                if (metadata.checksum().equals(footerDigest)) {, +            }, +                    " actual=" + actualChecksum + " footer=" + footerDigest +" writtenLength=" + writtenBytes + " expectedLength=" + metadata.length() +, +            final long writtenBytes = this.writtenBytes++;, +            if (writtenBytes == checksumPosition) {, +            } else if (writtenBytes > checksumPosition) { // we are writing parts of the checksum...., +                final int index = Math.toIntExact(writtenBytes - checksumPosition);, +                if (index < footerChecksum.length) {, +                    footerChecksum[index] = b;, +                } else {, +                    verify(); // fail if we write more than expected, +                    throw new AssertionError("write past EOF expected length: " + metadata.length() + " writtenBytes: " + writtenBytes);, +                }, +            if (writtenBytes + length > checksumPosition) {, +                if (actualChecksum == null) {, +                for (int i = 0; i < length; i++) {, +                    writeByte(b[offset+i]);, +                }, +            } else {, +        }, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +import org.elasticsearch.common.lucene.store.ByteArrayIndexInput;, +        private final byte[] footerChecksum = new byte[8]; // this holds the actual footer checksum data written by to this output, +            checksumPosition = metadata.length() - 8; // the last 8 bytes are the checksum - we store it in footerChecksum, +            String footerDigest = null;, +                ByteArrayIndexInput indexInput = new ByteArrayIndexInput("checksum", this.footerChecksum);, +                footerDigest = digestToString(indexInput.readLong());, +                if (metadata.checksum().equals(footerDigest)) {, +            }, +                    " actual=" + actualChecksum + " footer=" + footerDigest +" writtenLength=" + writtenBytes + " expectedLength=" + metadata.length() +, +            final long writtenBytes = this.writtenBytes++;, +            if (writtenBytes == checksumPosition) {, +            } else if (writtenBytes > checksumPosition) { // we are writing parts of the checksum...., +                final int index = Math.toIntExact(writtenBytes - checksumPosition);, +                if (index < footerChecksum.length) {, +                    footerChecksum[index] = b;, +                } else {, +                    verify(); // fail if we write more than expected, +                    throw new AssertionError("write past EOF expected length: " + metadata.length() + " writtenBytes: " + writtenBytes);, +                }, +            if (writtenBytes + length > checksumPosition) {, +                if (actualChecksum == null) {, +                for (int i = 0; i < length; i++) {, +                    writeByte(b[offset+i]);, +                }, +            } else {, +        }, +++ b/core/src/test/java/org/elasticsearch/index/store/StoreTests.java, +        try {, +            appendRandomData(verifyingOutput);, +            fail("should be a corrupted index");, +        } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {, +            // ok, +        }, +, +    public void testChecksumCorrupted() throws IOException {, +        Directory dir = newDirectory();, +        IndexOutput output = dir.createOutput("foo.bar", IOContext.DEFAULT);, +        int iters = scaledRandomIntBetween(10, 100);, +        for (int i = 0; i < iters; i++) {, +            BytesRef bytesRef = new BytesRef(TestUtil.randomRealisticUnicodeString(random(), 10, 1024));, +            output.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);, +        }, +        output.writeInt(CodecUtil.FOOTER_MAGIC);, +        output.writeInt(0);, +        String checksum = Store.digestToString(output.getChecksum());, +        output.writeLong(output.getChecksum() + 1); // write a wrong checksum to the file, +        output.close();, +, +        IndexInput indexInput = dir.openInput("foo.bar", IOContext.DEFAULT);, +        indexInput.seek(0);, +        BytesRef ref = new BytesRef(scaledRandomIntBetween(1, 1024));, +        long length = indexInput.length();, +        IndexOutput verifyingOutput = new Store.LuceneVerifyingIndexOutput(new StoreFileMetaData("foo1.bar", length, checksum), dir.createOutput("foo1.bar", IOContext.DEFAULT));, +        while (length > 0) {, +            if (random().nextInt(10) == 0) {, +                verifyingOutput.writeByte(indexInput.readByte());, +                length--;, +            } else {, +                int min = (int) Math.min(length, ref.bytes.length);, +                indexInput.readBytes(ref.bytes, ref.offset, min);, +                verifyingOutput.writeBytes(ref.bytes, ref.offset, min);, +                length -= min;, +            }, +        }, +, +        try {, +            if (randomBoolean()) {, +               appendRandomData(verifyingOutput);, +            } else {, +                Store.verify(verifyingOutput);, +            }, +            fail("should be a corrupted index");]