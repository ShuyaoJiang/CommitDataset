[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +    private boolean ignoreDuplicates = true;, +, +    public boolean ignoreDuplicates() {, +        return ignoreDuplicates;, +    }, +, +    public PutMappingRequest ignoreDuplicates(boolean ignoreDuplicates) {, +        this.ignoreDuplicates = ignoreDuplicates;, +        return this;, +    }, +, +        ignoreDuplicates = in.readBoolean();, +        out.writeBoolean(ignoreDuplicates);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +    private boolean ignoreDuplicates = true;, +, +    public boolean ignoreDuplicates() {, +        return ignoreDuplicates;, +    }, +, +    public PutMappingRequest ignoreDuplicates(boolean ignoreDuplicates) {, +        this.ignoreDuplicates = ignoreDuplicates;, +        return this;, +    }, +, +        ignoreDuplicates = in.readBoolean();, +        out.writeBoolean(ignoreDuplicates);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java, +    public PutMappingResponse(boolean acknowledged) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +    private boolean ignoreDuplicates = true;, +, +    public boolean ignoreDuplicates() {, +        return ignoreDuplicates;, +    }, +, +    public PutMappingRequest ignoreDuplicates(boolean ignoreDuplicates) {, +        this.ignoreDuplicates = ignoreDuplicates;, +        return this;, +    }, +, +        ignoreDuplicates = in.readBoolean();, +        out.writeBoolean(ignoreDuplicates);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java, +    public PutMappingResponse(boolean acknowledged) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java, +        MetaDataService.PutMappingResult result = metaDataService.putMapping(indices, request.type(), request.mappingSource(), request.ignoreDuplicates(), request.timeout());, +        return new PutMappingResponse(result.acknowledged());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +    private boolean ignoreDuplicates = true;, +, +    public boolean ignoreDuplicates() {, +        return ignoreDuplicates;, +    }, +, +    public PutMappingRequest ignoreDuplicates(boolean ignoreDuplicates) {, +        this.ignoreDuplicates = ignoreDuplicates;, +        return this;, +    }, +, +        ignoreDuplicates = in.readBoolean();, +        out.writeBoolean(ignoreDuplicates);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java, +    public PutMappingResponse(boolean acknowledged) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java, +        MetaDataService.PutMappingResult result = metaDataService.putMapping(indices, request.type(), request.mappingSource(), request.ignoreDuplicates(), request.timeout());, +        return new PutMappingResponse(result.acknowledged());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.index.mapper.ParsedDocument;, +    private final MappingUpdatedAction mappingUpdatedAction;, +, +                                        TransportCreateIndexAction createIndexAction, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +        final IndexRequest request = shardRequest.request;, +        ParsedDocument doc;, +            doc = indexShard(shardRequest).index(request.type(), request.id(), request.source());, +            doc = indexShard(shardRequest).create(request.type(), request.id(), request.source());, +        }, +        if (doc.mappersAdded()) {, +            updateMappingOnMaster(request);, +, +    private void updateMappingOnMaster(final IndexRequest request) {, +        try {, +            MapperService mapperService = indicesService.indexServiceSafe(request.index()).mapperService();, +            final String updatedSource = mapperService.documentMapper(request.type()).buildSource();, +            mappingUpdatedAction.execute(new MappingUpdatedAction.MappingUpdatedRequest(request.index(), request.type(), updatedSource), new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {, +                @Override public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {, +                    // all is well, +                }, +, +                @Override public void onFailure(Throwable e) {, +                    logger.warn("Failed to update master on updated mapping for index [" + request.index() + "], type [" + request.type() + "] and source [" + updatedSource + "]", e);, +                }, +            });, +        } catch (Exception e) {, +            logger.warn("Failed to update master on updated mapping for index [" + request.index() + "], type [" + request.type() + "]", e);, +        }]