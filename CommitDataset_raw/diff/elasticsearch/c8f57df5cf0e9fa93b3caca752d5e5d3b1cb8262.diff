[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesClusterStateUpdateRequest.java, +import java.util.List;, +, +    private final List<AliasAction> actions;, +    public IndicesAliasesClusterStateUpdateRequest(List<AliasAction> actions) {, +        this.actions = actions;, +    public List<AliasAction> actions() {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesClusterStateUpdateRequest.java, +import java.util.List;, +, +    private final List<AliasAction> actions;, +    public IndicesAliasesClusterStateUpdateRequest(List<AliasAction> actions) {, +        this.actions = actions;, +    public List<AliasAction> actions() {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesRequest.java, +, +import org.elasticsearch.ElasticsearchGenerationException;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParseFieldMatcherSupplier;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser.ValueType;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentType;, +import java.util.Arrays;, +import java.util.Objects;, +import java.util.function.Supplier;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +import static org.elasticsearch.common.xcontent.ObjectParser.fromList;, +    /**, +     * Request to take one or more actions on one or more indexes and alias combinations., +    public static class AliasActions implements AliasesRequest, Writeable {, +        public enum Type {, +            ADD((byte) 0),, +            REMOVE((byte) 1),, +            REMOVE_INDEX((byte) 2);, +, +            private final byte value;, +, +            Type(byte value) {, +                this.value = value;, +            }, +, +            public byte value() {, +                return value;, +            }, +, +            public static Type fromValue(byte value) {, +                switch (value) {, +                case 0: return ADD;, +                case 1: return REMOVE;, +                case 2: return REMOVE_INDEX;, +                default: throw new IllegalArgumentException("No type for action [" + value + "]");, +                }, +            }, +        }, +, +        /**, +         * Build a new {@link AliasAction} to add aliases., +         */, +        public static AliasActions add() {, +            return new AliasActions(AliasActions.Type.ADD);, +        }, +        /**, +         * Build a new {@link AliasAction} to remove aliases., +         */, +        public static AliasActions remove() {, +            return new AliasActions(AliasActions.Type.REMOVE);, +        }, +        /**, +         * Build a new {@link AliasAction} to remove aliases., +         */, +        public static AliasActions removeIndex() {, +            return new AliasActions(AliasActions.Type.REMOVE_INDEX);, +        }, +        private static ObjectParser<AliasActions, ParseFieldMatcherSupplier> parser(String name, Supplier<AliasActions> supplier) {, +            ObjectParser<AliasActions, ParseFieldMatcherSupplier> parser = new ObjectParser<>(name, supplier);, +            parser.declareString((action, index) -> {, +                if (action.indices() != null) {, +                    throw new IllegalArgumentException("Only one of [index] and [indices] is supported");, +                }, +                action.index(index);, +            }, new ParseField("index"));, +            parser.declareStringArray(fromList(String.class, (action, indices) -> {, +                if (action.indices() != null) {, +                    throw new IllegalArgumentException("Only one of [index] and [indices] is supported");, +                }, +                action.indices(indices);, +            }), new ParseField("indices"));, +            parser.declareString((action, alias) -> {, +                if (action.aliases() != null && action.aliases().length != 0) {, +                    throw new IllegalArgumentException("Only one of [alias] and [aliases] is supported");, +                }]