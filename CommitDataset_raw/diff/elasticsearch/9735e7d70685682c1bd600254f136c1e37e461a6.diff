[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplainRequest.java, +    public ClusterAllocationExplainRequest(StreamInput in) throws IOException {, +        super(in);, +        checkVersion(in.getVersion());, +        this.index = in.readOptionalString();, +        this.shard = in.readOptionalVInt();, +        this.primary = in.readOptionalBoolean();, +        this.currentNode = in.readOptionalString();, +        this.includeYesDecisions = in.readBoolean();, +        this.includeDiskInfo = in.readBoolean();, +    }, +, +    public void writeTo(StreamOutput out) throws IOException {, +        checkVersion(out.getVersion());, +        super.writeTo(out);, +        out.writeOptionalString(index);, +        out.writeOptionalVInt(shard);, +        out.writeOptionalBoolean(primary);, +        out.writeOptionalString(currentNode);, +        out.writeBoolean(includeYesDecisions);, +        out.writeBoolean(includeDiskInfo);, +    }, +, +    @Override, +        throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable");, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplainRequest.java, +    public ClusterAllocationExplainRequest(StreamInput in) throws IOException {, +        super(in);, +        checkVersion(in.getVersion());, +        this.index = in.readOptionalString();, +        this.shard = in.readOptionalVInt();, +        this.primary = in.readOptionalBoolean();, +        this.currentNode = in.readOptionalString();, +        this.includeYesDecisions = in.readBoolean();, +        this.includeDiskInfo = in.readBoolean();, +    }, +, +    public void writeTo(StreamOutput out) throws IOException {, +        checkVersion(out.getVersion());, +        super.writeTo(out);, +        out.writeOptionalString(index);, +        out.writeOptionalVInt(shard);, +        out.writeOptionalBoolean(primary);, +        out.writeOptionalString(currentNode);, +        out.writeBoolean(includeYesDecisions);, +        out.writeBoolean(includeDiskInfo);, +    }, +, +    @Override, +        throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable");, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +            ClusterAllocationExplainRequest::new, indexNameExpressionResolver);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplainRequest.java, +    public ClusterAllocationExplainRequest(StreamInput in) throws IOException {, +        super(in);, +        checkVersion(in.getVersion());, +        this.index = in.readOptionalString();, +        this.shard = in.readOptionalVInt();, +        this.primary = in.readOptionalBoolean();, +        this.currentNode = in.readOptionalString();, +        this.includeYesDecisions = in.readBoolean();, +        this.includeDiskInfo = in.readBoolean();, +    }, +, +    public void writeTo(StreamOutput out) throws IOException {, +        checkVersion(out.getVersion());, +        super.writeTo(out);, +        out.writeOptionalString(index);, +        out.writeOptionalVInt(shard);, +        out.writeOptionalBoolean(primary);, +        out.writeOptionalString(currentNode);, +        out.writeBoolean(includeYesDecisions);, +        out.writeBoolean(includeDiskInfo);, +    }, +, +    @Override, +        throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable");, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +            ClusterAllocationExplainRequest::new, indexNameExpressionResolver);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/ClusterHealthRequest.java, +    public ClusterHealthRequest(StreamInput in) throws IOException {, +        super(in);, +        int size = in.readVInt();, +        if (size == 0) {, +            indices = Strings.EMPTY_ARRAY;, +        } else {, +            indices = new String[size];, +            for (int i = 0; i < indices.length; i++) {, +                indices[i] = in.readString();, +            }, +        }, +        timeout = new TimeValue(in);, +        if (in.readBoolean()) {, +            waitForStatus = ClusterHealthStatus.fromValue(in.readByte());, +        }, +        waitForNoRelocatingShards = in.readBoolean();, +        waitForActiveShards = ActiveShardCount.readFrom(in);, +        waitForNodes = in.readString();, +        if (in.readBoolean()) {, +            waitForEvents = Priority.readFrom(in);]