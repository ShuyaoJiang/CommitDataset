[+++ b/server/src/main/java/org/elasticsearch/discovery/BlockingClusterStatePublishResponseHandler.java, +import java.util.Collections;, +    private final Set<DiscoveryNode> failedNodes;, +        this.failedNodes = ConcurrentCollections.newConcurrentSet();, +        boolean added = failedNodes.add(node);, +        assert added : "duplicate failures for " + node;, +, +    /**, +     * returns a set of nodes for which publication has failed., +     */, +    public Set<DiscoveryNode> getFailedNodes() {, +        return Collections.unmodifiableSet(failedNodes);, +    }, +++ b/server/src/main/java/org/elasticsearch/discovery/BlockingClusterStatePublishResponseHandler.java, +import java.util.Collections;, +    private final Set<DiscoveryNode> failedNodes;, +        this.failedNodes = ConcurrentCollections.newConcurrentSet();, +        boolean added = failedNodes.add(node);, +        assert added : "duplicate failures for " + node;, +, +    /**, +     * returns a set of nodes for which publication has failed., +     */, +    public Set<DiscoveryNode> getFailedNodes() {, +        return Collections.unmodifiableSet(failedNodes);, +    }, +++ b/server/src/main/java/org/elasticsearch/discovery/zen/PublishClusterStateAction.java, +import org.elasticsearch.core.internal.io.IOUtils;, +            // The failure is logged under debug when a sending failed. we now log a summary., +            Set<DiscoveryNode> failedNodes = publishResponseHandler.getFailedNodes();, +            if (failedNodes.isEmpty() == false) {, +                logger.warn("publishing cluster state with version [{}] failed for the following nodes: [{}]",, +                    clusterChangedEvent.state().version(), failedNodes);, +            }, +        final ClusterState incomingState;, +        synchronized (lastSeenClusterStateMutex) {, +            } catch (Exception e) {, +                logger.warn("unexpected error while deserializing an incoming cluster state", e);, +                throw e;, +            incomingClusterStateListener.onIncomingClusterState(incomingState);, +            lastSeenClusterState = incomingState;, +        }, +++ b/server/src/main/java/org/elasticsearch/discovery/BlockingClusterStatePublishResponseHandler.java, +import java.util.Collections;, +    private final Set<DiscoveryNode> failedNodes;, +        this.failedNodes = ConcurrentCollections.newConcurrentSet();, +        boolean added = failedNodes.add(node);, +        assert added : "duplicate failures for " + node;, +, +    /**, +     * returns a set of nodes for which publication has failed., +     */, +    public Set<DiscoveryNode> getFailedNodes() {, +        return Collections.unmodifiableSet(failedNodes);, +    }, +++ b/server/src/main/java/org/elasticsearch/discovery/zen/PublishClusterStateAction.java, +import org.elasticsearch.core.internal.io.IOUtils;, +            // The failure is logged under debug when a sending failed. we now log a summary., +            Set<DiscoveryNode> failedNodes = publishResponseHandler.getFailedNodes();, +            if (failedNodes.isEmpty() == false) {, +                logger.warn("publishing cluster state with version [{}] failed for the following nodes: [{}]",, +                    clusterChangedEvent.state().version(), failedNodes);, +            }, +        final ClusterState incomingState;, +        synchronized (lastSeenClusterStateMutex) {, +            } catch (Exception e) {, +                logger.warn("unexpected error while deserializing an incoming cluster state", e);, +                throw e;, +            incomingClusterStateListener.onIncomingClusterState(incomingState);, +            lastSeenClusterState = incomingState;, +        }, +++ b/server/src/test/java/org/elasticsearch/discovery/BlockingClusterStatePublishResponseHandlerTests.java, +        Set<DiscoveryNode> expectedFailures = new HashSet<>();, +            final DiscoveryNode node = allNodes[i];, +            completedNodes.add(node);, +            final boolean fail = randomBoolean();, +            if (fail) {, +                expectedFailures.add(node);, +            }, +            threads[i] = new Thread(new PublishResponder(fail, node, barrier, logger, handler));, +            final DiscoveryNode node = allNodes[firstRound + i];, +            final boolean fail = randomBoolean();, +            if (fail) {, +                expectedFailures.add(node);, +            }, +            threads[i] = new Thread(new PublishResponder(fail, node, barrier, logger, handler));, +        assertThat(handler.getFailedNodes(), equalTo(expectedFailures));]