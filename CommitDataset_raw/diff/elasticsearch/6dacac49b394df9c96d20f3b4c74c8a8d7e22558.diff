[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +                ClearIndicesCacheRequest::new, ThreadPool.Names.MANAGEMENT);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +                ClearIndicesCacheRequest::new, ThreadPool.Names.MANAGEMENT);, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +                ClearIndicesCacheRequest::new, ThreadPool.Names.MANAGEMENT);, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java, +     * returns true for initializing shards that recover their data from another shard copy, +     */, +    public boolean isPeerRecovery() {, +        return state == ShardRoutingState.INITIALIZING && (primary() == false || relocatingNodeId != null);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +                ClearIndicesCacheRequest::new, ThreadPool.Names.MANAGEMENT);, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java, +     * returns true for initializing shards that recover their data from another shard copy, +     */, +    public boolean isPeerRecovery() {, +        return state == ShardRoutingState.INITIALIZING && (primary() == false || relocatingNodeId != null);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +                indexShard = new ShadowIndexShard(routing, this.indexSettings, path, store, indexCache, mapperService, similarityService,, +                indexShard = new IndexShard(routing, this.indexSettings, path, store, indexCache, mapperService, similarityService,, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +                ClearIndicesCacheRequest::new, ThreadPool.Names.MANAGEMENT);, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +        transportService.registerRequestHandler(transportNodeBroadcastAction, NodeRequest::new, executor, new BroadcastByNodeTransportRequestHandler());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java, +     * returns true for initializing shards that recover their data from another shard copy, +     */, +    public boolean isPeerRecovery() {, +        return state == ShardRoutingState.INITIALIZING && (primary() == false || relocatingNodeId != null);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +                indexShard = new ShadowIndexShard(routing, this.indexSettings, path, store, indexCache, mapperService, similarityService,, +                indexShard = new IndexShard(routing, this.indexSettings, path, store, indexCache, mapperService, similarityService,, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.cluster.routing.RestoreSource;, +import org.elasticsearch.indices.recovery.RecoveryTargetService;, +import org.elasticsearch.repositories.RepositoriesService;, +    public IndexShard(ShardRouting shardRouting, IndexSettings indexSettings, ShardPath path, Store store, IndexCache indexCache,, +                      Engine.Warmer warmer, List<SearchOperationListener> searchOperationListener, List<IndexingOperationListener> listeners) throws IOException {, +        super(shardRouting.shardId(), indexSettings);, +        assert shardRouting.initializing();, +        this.shardRouting = shardRouting;, +        persistMetadata(shardRouting, null);, +     * Returns the latest cluster routing entry received with this shard., +    public void startRecovery(DiscoveryNode localNode, DiscoveryNode sourceNode, RecoveryTargetService recoveryTargetService,, +                              RecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService) {, +        final RestoreSource restoreSource = shardRouting.restoreSource();, +, +        if (shardRouting.isPeerRecovery()) {, +            assert sourceNode != null : "peer recovery started but sourceNode is null";, +            // we don't mark this one as relocated at the end., +            // For primaries: requests in any case are routed to both when its relocating and that way we handle, +            //    the edge case where its mark as relocated, and we might need to roll it back..., +            // For replicas: we are recovering a backup from a primary, +            RecoveryState.Type type = shardRouting.primary() ? RecoveryState.Type.PRIMARY_RELOCATION : RecoveryState.Type.REPLICA;, +            RecoveryState recoveryState = new RecoveryState(shardId(), shardRouting.primary(), type, sourceNode, localNode);, +            try {, +                markAsRecovering("from " + sourceNode, recoveryState);, +                recoveryTargetService.startRecovery(this, type, sourceNode, recoveryListener);, +            } catch (Throwable e) {, +                failShard("corrupted preexisting index", e);, +                recoveryListener.onRecoveryFailure(recoveryState, new RecoveryFailedException(shardId, sourceNode, localNode, e), true);, +            }, +        } else if (restoreSource == null) {, +            // recover from filesystem store, +            final RecoveryState recoveryState = new RecoveryState(shardId(), shardRouting.primary(),, +                RecoveryState.Type.STORE, localNode, localNode);, +            markAsRecovering("from store", recoveryState); // mark the shard as recovering on the cluster state thread, +            threadPool.generic().execute(() -> {, +                try {, +                    if (recoverFromStore(localNode)) {, +                        recoveryListener.onRecoveryDone(recoveryState);, +                    }, +                } catch (Throwable t) {, +                    recoveryListener.onRecoveryFailure(recoveryState, new RecoveryFailedException(shardId, sourceNode, localNode, t), true);, +                }, +, +            });, +        } else {, +            // recover from a restore, +            final RecoveryState recoveryState = new RecoveryState(shardId(), shardRouting.primary(),, +                RecoveryState.Type.SNAPSHOT, shardRouting.restoreSource(), localNode);, +            markAsRecovering("from snapshot", recoveryState); // mark the shard as recovering on the cluster state thread, +            threadPool.generic().execute(() -> {, +                try {]