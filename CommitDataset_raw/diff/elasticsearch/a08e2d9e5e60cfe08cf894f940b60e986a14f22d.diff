[+++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +            logger.warn("attempt to complete task [{}] with id [{}] in the [{}] state", getAction(), getPersistentTaskId(), prevState);, +                    logger.trace("sending notification for completed task [{}] with id [{}]", getAction(), getPersistentTaskId());, +                    persistentTasksService.sendCompletionNotification(getPersistentTaskId(), getAllocationId(), failure, new, +                                    logger.trace("notification for task [{}] with id [{}] was successful", getAction(),, +                                            getPersistentTaskId());, +                                            new ParameterizedMessage("notification for task [{}] with id [{}] failed",, +                                                    getAction(), getPersistentTaskId()), e);, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +            logger.warn("attempt to complete task [{}] with id [{}] in the [{}] state", getAction(), getPersistentTaskId(), prevState);, +                    logger.trace("sending notification for completed task [{}] with id [{}]", getAction(), getPersistentTaskId());, +                    persistentTasksService.sendCompletionNotification(getPersistentTaskId(), getAllocationId(), failure, new, +                                    logger.trace("notification for task [{}] with id [{}] was successful", getAction(),, +                                            getPersistentTaskId());, +                                            new ParameterizedMessage("notification for task [{}] with id [{}] failed",, +                                                    getAction(), getPersistentTaskId()), e);, +++ b/server/src/main/java/org/elasticsearch/persistent/CompletionPersistentTaskAction.java, +        private long allocationId = -1;, +, +        public Request(String taskId, long allocationId, Exception exception) {, +            this.allocationId = allocationId;, +            allocationId = in.readLong();, +            out.writeLong(allocationId);, +            if (allocationId < 0) {, +                validationException = addValidationError("allocation id is negative or missing", validationException);, +            }, +                    allocationId == request.allocationId &&, +            return Objects.hash(taskId, allocationId, exception);, +            persistentTasksClusterService.completePersistentTask(request.taskId, request.allocationId, request.exception,, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +            logger.warn("attempt to complete task [{}] with id [{}] in the [{}] state", getAction(), getPersistentTaskId(), prevState);, +                    logger.trace("sending notification for completed task [{}] with id [{}]", getAction(), getPersistentTaskId());, +                    persistentTasksService.sendCompletionNotification(getPersistentTaskId(), getAllocationId(), failure, new, +                                    logger.trace("notification for task [{}] with id [{}] was successful", getAction(),, +                                            getPersistentTaskId());, +                                            new ParameterizedMessage("notification for task [{}] with id [{}] failed",, +                                                    getAction(), getPersistentTaskId()), e);, +++ b/server/src/main/java/org/elasticsearch/persistent/CompletionPersistentTaskAction.java, +        private long allocationId = -1;, +, +        public Request(String taskId, long allocationId, Exception exception) {, +            this.allocationId = allocationId;, +            allocationId = in.readLong();, +            out.writeLong(allocationId);, +            if (allocationId < 0) {, +                validationException = addValidationError("allocation id is negative or missing", validationException);, +            }, +                    allocationId == request.allocationId &&, +            return Objects.hash(taskId, allocationId, exception);, +            persistentTasksClusterService.completePersistentTask(request.taskId, request.allocationId, request.exception,, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +     * @param id           the id of the persistent task, +     * @param allocationId the allocation id of the persistent task, +    public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {, +                if (tasksInProgress.hasTask(id, allocationId)) {, +                    if (tasksInProgress.hasTask(id)) {, +                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",, +                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId);, +                    } else {, +                        logger.warn("The task [{}] wasn't found, status is not updated", id);, +                    }, +                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found");, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +            logger.warn("attempt to complete task [{}] with id [{}] in the [{}] state", getAction(), getPersistentTaskId(), prevState);, +                    logger.trace("sending notification for completed task [{}] with id [{}]", getAction(), getPersistentTaskId());, +                    persistentTasksService.sendCompletionNotification(getPersistentTaskId(), getAllocationId(), failure, new, +                                    logger.trace("notification for task [{}] with id [{}] was successful", getAction(),, +                                            getPersistentTaskId());, +                                            new ParameterizedMessage("notification for task [{}] with id [{}] failed",, +                                                    getAction(), getPersistentTaskId()), e);, +++ b/server/src/main/java/org/elasticsearch/persistent/CompletionPersistentTaskAction.java, +        private long allocationId = -1;, +, +        public Request(String taskId, long allocationId, Exception exception) {, +            this.allocationId = allocationId;, +            allocationId = in.readLong();, +            out.writeLong(allocationId);, +            if (allocationId < 0) {, +                validationException = addValidationError("allocation id is negative or missing", validationException);, +            }, +                    allocationId == request.allocationId &&, +            return Objects.hash(taskId, allocationId, exception);, +            persistentTasksClusterService.completePersistentTask(request.taskId, request.allocationId, request.exception,, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +     * @param id           the id of the persistent task, +     * @param allocationId the allocation id of the persistent task, +    public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {, +                if (tasksInProgress.hasTask(id, allocationId)) {, +                    if (tasksInProgress.hasTask(id)) {, +                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",, +                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId);, +                    } else {, +                        logger.warn("The task [{}] wasn't found, status is not updated", id);, +                    }, +                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found");, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +import org.elasticsearch.gateway.GatewayService;, +        if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +            // wait until the gateway has recovered from disk, otherwise if the only master restarts, +            // we start cancelling all local tasks before cluster has a chance to recover.]