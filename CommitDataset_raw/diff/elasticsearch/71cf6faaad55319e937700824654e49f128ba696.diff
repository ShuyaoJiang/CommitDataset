[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {, +            final long previousTerm = getCurrentTerm();, +            if (previousTerm != getCurrentTerm()) {, +    }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {, +            final long previousTerm = getCurrentTerm();, +            if (previousTerm != getCurrentTerm()) {, +    }, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import static org.elasticsearch.discovery.DiscoverySettings.NO_MASTER_BLOCK_ID;, +import static org.hamcrest.Matchers.nullValue;, +    /**, +     * Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where, +     * it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader, +     * does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try, +     * and join the leader again., +     */, +    public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {, +        final Cluster cluster = new Cluster(2, false);, +        cluster.runRandomly();, +        cluster.stabilise();, +, +        final ClusterNode leader = cluster.getAnyLeader();, +        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader);, +        onNode(nonLeader.getLocalNode(), () -> {, +            logger.debug("forcing {} to become candidate", nonLeader.getId());, +            synchronized (nonLeader.coordinator.mutex) {, +                nonLeader.coordinator.becomeCandidate("forced");, +            }, +            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId());, +            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),, +                leader.getLocalNode()));, +        }).run();, +        cluster.stabilise();, +    }, +, +                    assertThat(nodeId + " has correct master", clusterNode.getLastAppliedClusterState().nodes().getMasterNode(),, +                        equalTo(leader.getLocalNode()));, +                    assertThat(nodeId + " has no NO_MASTER_BLOCK",, +                        clusterNode.getLastAppliedClusterState().blocks().hasGlobalBlock(NO_MASTER_BLOCK_ID), equalTo(false));, +                    assertThat(nodeId + " has no master", clusterNode.getLastAppliedClusterState().nodes().getMasterNode(), nullValue());, +                    assertThat(nodeId + " has NO_MASTER_BLOCK",, +                        clusterNode.getLastAppliedClusterState().blocks().hasGlobalBlock(NO_MASTER_BLOCK_ID), equalTo(true));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {, +            final long previousTerm = getCurrentTerm();, +            if (previousTerm != getCurrentTerm()) {, +    }, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import static org.elasticsearch.discovery.DiscoverySettings.NO_MASTER_BLOCK_ID;, +import static org.hamcrest.Matchers.nullValue;, +    /**, +     * Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where, +     * it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader, +     * does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try, +     * and join the leader again., +     */, +    public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {, +        final Cluster cluster = new Cluster(2, false);, +        cluster.runRandomly();, +        cluster.stabilise();, +, +        final ClusterNode leader = cluster.getAnyLeader();, +        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader);, +        onNode(nonLeader.getLocalNode(), () -> {, +            logger.debug("forcing {} to become candidate", nonLeader.getId());, +            synchronized (nonLeader.coordinator.mutex) {, +                nonLeader.coordinator.becomeCandidate("forced");, +            }, +            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId());, +            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),, +                leader.getLocalNode()));, +        }).run();, +        cluster.stabilise();, +    }, +, +                    assertThat(nodeId + " has correct master", clusterNode.getLastAppliedClusterState().nodes().getMasterNode(),, +                        equalTo(leader.getLocalNode()));, +                    assertThat(nodeId + " has no NO_MASTER_BLOCK",, +                        clusterNode.getLastAppliedClusterState().blocks().hasGlobalBlock(NO_MASTER_BLOCK_ID), equalTo(false));, +                    assertThat(nodeId + " has no master", clusterNode.getLastAppliedClusterState().nodes().getMasterNode(), nullValue());, +                    assertThat(nodeId + " has NO_MASTER_BLOCK",, +                        clusterNode.getLastAppliedClusterState().blocks().hasGlobalBlock(NO_MASTER_BLOCK_ID), equalTo(true));, +++ b/server/src/test/java/org/elasticsearch/discovery/ClusterDisruptionIT.java]