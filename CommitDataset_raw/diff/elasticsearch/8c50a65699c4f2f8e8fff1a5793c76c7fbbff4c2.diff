[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java, +import org.elasticsearch.index.mapper.*;, +, +        // if percolator is already allocated, make sure to register real time percolation, +        if (percolatorAllocated()) {, +            IndexService percolatorIndexService = percolatorIndexService();, +            if (percolatorIndexService != null) {, +                for (IndexShard indexShard : percolatorIndexService) {, +                    try {, +                        indexShard.addListener(realTimePercolatorOperationListener);, +                    } catch (Exception e) {, +                        // ignore, +                    }, +                }, +            }, +        }, +        shard.refresh(new Engine.Refresh(true));, +            Document document = reader.document(doc, new UidAndSourceFieldSelector());, +            String id = Uid.createUid(document.get(UidFieldMapper.NAME)).id();, +                            logger.debug("loading percolator queries for index [{}]...", indexService.index().name());, +                            logger.trace("done loading percolator queries for index [{}]", indexService.index().name());, +                logger.debug("loading percolator queries for index [{}]...", indexService.index().name());, +                logger.trace("done loading percolator queries for index [{}]", indexService.index().name());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java, +import org.elasticsearch.index.mapper.*;, +, +        // if percolator is already allocated, make sure to register real time percolation, +        if (percolatorAllocated()) {, +            IndexService percolatorIndexService = percolatorIndexService();, +            if (percolatorIndexService != null) {, +                for (IndexShard indexShard : percolatorIndexService) {, +                    try {, +                        indexShard.addListener(realTimePercolatorOperationListener);, +                    } catch (Exception e) {, +                        // ignore, +                    }, +                }, +            }, +        }, +        shard.refresh(new Engine.Refresh(true));, +            Document document = reader.document(doc, new UidAndSourceFieldSelector());, +            String id = Uid.createUid(document.get(UidFieldMapper.NAME)).id();, +                            logger.debug("loading percolator queries for index [{}]...", indexService.index().name());, +                            logger.trace("done loading percolator queries for index [{}]", indexService.index().name());, +                logger.debug("loading percolator queries for index [{}]...", indexService.index().name());, +                logger.trace("done loading percolator queries for index [{}]", indexService.index().name());, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/percolator/RecoveryPercolatorTests.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.test.integration.percolator;, +, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.action.percolate.PercolateResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.gateway.Gateway;, +import org.elasticsearch.node.internal.InternalNode;, +import org.elasticsearch.test.integration.AbstractNodesTests;, +import org.testng.annotations.AfterMethod;, +import org.testng.annotations.Test;, +, +import static org.elasticsearch.client.Requests.*;, +import static org.elasticsearch.common.settings.ImmutableSettings.*;, +import static org.elasticsearch.common.xcontent.XContentFactory.*;, +import static org.elasticsearch.index.query.xcontent.QueryBuilders.*;, +import static org.hamcrest.MatcherAssert.*;, +import static org.hamcrest.Matchers.*;, +, +@Test, +public class RecoveryPercolatorTests extends AbstractNodesTests {, +, +    @AfterMethod public void cleanAndCloseNodes() throws Exception {, +        for (int i = 0; i < 10; i++) {, +            if (node("node" + i) != null) {, +                node("node" + i).stop();, +                // since we store (by default) the index snapshot under the gateway, resetting it will reset the index data as well, +                if (((InternalNode) node("node" + i)).injector().getInstance(NodeEnvironment.class).hasNodeFile()) {, +                    ((InternalNode) node("node" + i)).injector().getInstance(Gateway.class).reset();, +                }, +            }, +        }, +        closeAllNodes();]