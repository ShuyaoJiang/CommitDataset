[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/NativeAutodetectProcess.java, +    private static final Duration WAIT_FOR_KILL_TIMEOUT = Duration.ofMillis(1000);, +, +, +            // Wait for the process to die before closing processInStream as if the process, +            // is still alive when processInStream is closed autodetect will start persisting state, +            cppLogHandler.waitForLogStreamClose(WAIT_FOR_KILL_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/NativeAutodetectProcess.java, +    private static final Duration WAIT_FOR_KILL_TIMEOUT = Duration.ofMillis(1000);, +, +, +            // Wait for the process to die before closing processInStream as if the process, +            // is still alive when processInStream is closed autodetect will start persisting state, +            cppLogHandler.waitForLogStreamClose(WAIT_FOR_KILL_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/logging/CppLogMessageHandler.java, +    private final CountDownLatch logStreamClosedLatch;, +        logStreamClosedLatch = new CountDownLatch(1);, +            logStreamClosedLatch.countDown();, +        return logStreamClosedLatch.getCount() == 0;, +    public boolean waitForLogStreamClose(Duration timeout) {, +        try {, +            return logStreamClosedLatch.await(timeout.toMillis(), TimeUnit.MILLISECONDS);, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +        }, +        return false;, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/NativeAutodetectProcess.java, +    private static final Duration WAIT_FOR_KILL_TIMEOUT = Duration.ofMillis(1000);, +, +, +            // Wait for the process to die before closing processInStream as if the process, +            // is still alive when processInStream is closed autodetect will start persisting state, +            cppLogHandler.waitForLogStreamClose(WAIT_FOR_KILL_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/logging/CppLogMessageHandler.java, +    private final CountDownLatch logStreamClosedLatch;, +        logStreamClosedLatch = new CountDownLatch(1);, +            logStreamClosedLatch.countDown();, +        return logStreamClosedLatch.getCount() == 0;, +    public boolean waitForLogStreamClose(Duration timeout) {, +        try {, +            return logStreamClosedLatch.await(timeout.toMillis(), TimeUnit.MILLISECONDS);, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +        }, +        return false;, +    }, +, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/job/process/logging/CppLogMessageHandlerTests.java, +    public void testWaitForLogStreamClose() throws IOException {, +        InputStream is = new ByteArrayInputStream(String.join("", TEST_MESSAGE_NOISE, TEST_MESSAGE_NOISE, TEST_MESSAGE_NOISE,, +                TEST_MESSAGE_NOISE, TEST_MESSAGE_NOISE, TEST_MESSAGE_NOISE_DIFFERENT_MESSAGE).getBytes(StandardCharsets.UTF_8));, +, +        try (CppLogMessageHandler handler = new CppLogMessageHandler("test_throttling", is)) {, +            handler.tailStream();, +            assertTrue(handler.waitForLogStreamClose(Duration.ofMillis(100)));, +            assertTrue(handler.hasLogStreamEnded());, +        }, +    }, +]