[+++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, null, edges, 0);, +            int length = createEdges(i+1, true, shell, this.holes.get(i), edges, offset);, +            // 1. per the comment above, the edge array is sorted by y-value of the intersection, +            // to connect. Thus the first logic check enforces the pairwise rule, +            // 2. the second logic ensures the two candidate edges aren't already connected by an, +            //    existing along the dateline - this is necessary due to a logic change that, +            //    computes dateline edges as valid intersect points in support of OGC standards, +                    && !(e1.next.next.coordinate.equals3D(e2.coordinate) && Math.abs(e1.next.coordinate.x) == DATELINE, +                    && Math.abs(e2.coordinate.x) == DATELINE) ) {, +    private static int createEdges(int component, boolean direction, BaseLineStringBuilder<?> shell, BaseLineStringBuilder<?> hole,, +                                   Edge[] edges, int offset) {, +        // set the points array accordingly (shell or hole), +        Coordinate[] points = (hole != null) ? hole.coordinates(false) : shell.coordinates(false);, +        Edge.ring(component, direction, shell, points, 0, edges, offset, points.length-1);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, null, edges, 0);, +            int length = createEdges(i+1, true, shell, this.holes.get(i), edges, offset);, +            // 1. per the comment above, the edge array is sorted by y-value of the intersection, +            // to connect. Thus the first logic check enforces the pairwise rule, +            // 2. the second logic ensures the two candidate edges aren't already connected by an, +            //    existing along the dateline - this is necessary due to a logic change that, +            //    computes dateline edges as valid intersect points in support of OGC standards, +                    && !(e1.next.next.coordinate.equals3D(e2.coordinate) && Math.abs(e1.next.coordinate.x) == DATELINE, +                    && Math.abs(e2.coordinate.x) == DATELINE) ) {, +    private static int createEdges(int component, boolean direction, BaseLineStringBuilder<?> shell, BaseLineStringBuilder<?> hole,, +                                   Edge[] edges, int offset) {, +        // set the points array accordingly (shell or hole), +        Coordinate[] points = (hole != null) ? hole.coordinates(false) : shell.coordinates(false);, +        Edge.ring(component, direction, shell, points, 0, edges, offset, points.length-1);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/PointCollection.java, +    protected boolean translated = false;, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, null, edges, 0);, +            int length = createEdges(i+1, true, shell, this.holes.get(i), edges, offset);, +            // 1. per the comment above, the edge array is sorted by y-value of the intersection, +            // to connect. Thus the first logic check enforces the pairwise rule, +            // 2. the second logic ensures the two candidate edges aren't already connected by an, +            //    existing along the dateline - this is necessary due to a logic change that, +            //    computes dateline edges as valid intersect points in support of OGC standards, +                    && !(e1.next.next.coordinate.equals3D(e2.coordinate) && Math.abs(e1.next.coordinate.x) == DATELINE, +                    && Math.abs(e2.coordinate.x) == DATELINE) ) {, +    private static int createEdges(int component, boolean direction, BaseLineStringBuilder<?> shell, BaseLineStringBuilder<?> hole,, +                                   Edge[] edges, int offset) {, +        // set the points array accordingly (shell or hole), +        Coordinate[] points = (hole != null) ? hole.coordinates(false) : shell.coordinates(false);, +        Edge.ring(component, direction, shell, points, 0, edges, offset, points.length-1);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/PointCollection.java, +    protected boolean translated = false;, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +import org.apache.commons.lang3.tuple.Pair;, +        private static final Pair range(Coordinate[] points, int offset, int length) {, +            double minX = points[0].x;, +            double maxX = points[0].x;, +            double minY = points[0].y;, +            double maxY = points[0].y;, +            // compute the bounding coordinates (@todo: cleanup brute force), +            for (int i = 1; i < length; ++i) {, +                if (points[offset + i].x < minX) {, +                    minX = points[offset + i].x;, +                }, +                if (points[offset + i].x > maxX) {, +                    maxX = points[offset + i].x;, +                }, +                if (points[offset + i].y < minY) {, +                    minY = points[offset + i].y;, +                }, +                if (points[offset + i].y > maxY) {, +                    maxY = points[offset + i].y;, +                }, +            }, +            return Pair.of(Pair.of(minX, maxX), Pair.of(minY, maxY));, +        }, +, +        protected static Edge[] ring(int component, boolean direction, BaseLineStringBuilder<?> shell, Coordinate[] points, int offset, , +                                     Edge[] edges, int toffset, int length) {, +            // thus if orientation is computed as cw, the logic will translate points across dateline, +            // and convert to a right handed system, +, +            // compute the bounding box and calculate range, +            Pair<Pair, Pair> range = range(points, offset, length);, +            final double rng = (Double)range.getLeft().getRight() - (Double)range.getLeft().getLeft();, +            // translate the points if the following is true, +            //   1.  range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres (translation would result in, +            //         a collapsed poly), +            //   2.  the shell of the candidate hole has been translated (to preserve the coordinate system), +            if ((rng > DATELINE && rng != 2*DATELINE && orientation) || (shell.translated && component != 0)) {, +                // flip the translation bit if the shell is being translated, +                if (component == 0 && !shell.translated) {, +                    shell.translated = true;, +                }, +                // correct the orientation post translation (ccw for shell, cw for holes), +                if ((component == 0 && orientation) || (component != 0 && !orientation)) {, +            }, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +        int offset = createEdges(0, false, shell, null, edges, 0);, +            int length = createEdges(i+1, true, shell, this.holes.get(i), edges, offset);, +            // 1. per the comment above, the edge array is sorted by y-value of the intersection, +            // to connect. Thus the first logic check enforces the pairwise rule, +            // 2. the second logic ensures the two candidate edges aren't already connected by an]