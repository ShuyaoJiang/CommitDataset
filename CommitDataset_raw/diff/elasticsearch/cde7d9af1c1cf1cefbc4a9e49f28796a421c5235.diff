[+++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +        final TimeoutHandler timeoutHandler;, +, +            if (options.timeout() == null) {, +                timeoutHandler = null;, +            } else {, +                timeoutHandler = new TimeoutHandler(requestId);, +            }, +            if (timeoutHandler != null) {, +                assert options.timeout() != null;, +                holderToNotify.cancelTimeout();, +        public TransportResponseHandler onResponseReceived(final long requestId) {, +                checkForTimeout(requestId);, +                return null;, +            }, +            holder.cancelTimeout();, +            if (traceEnabled() && shouldTraceAction(holder.action())) {, +                traceReceivedResponse(requestId, holder.node(), holder.action());, +            }, +            return holder.handler();, +        }, +, +        protected void checkForTimeout(long requestId) {, +            // lets see if its in the timeout holder, but sync on mutex to make sure any ongoing timeout handling has finished, +            final DiscoveryNode sourceNode;, +            final String action;, +            assert clientHandlers.get(requestId) == null;, +                action = timeoutInfoHolder.action();, +                sourceNode = timeoutInfoHolder.node();, +                action = null;, +                sourceNode = null;, +            // call tracer out of lock, +            if (traceEnabled() == false) {, +                return;, +            if (action == null) {, +                assert sourceNode == null;, +                traceUnresolvedResponse(requestId);, +            } else if (shouldTraceAction(action)) {, +                traceReceivedResponse(requestId, sourceNode, action);, +            }, +        volatile ScheduledFuture future;, +            // we get first to make sure we only add the TimeoutInfoHandler if needed., +            final RequestHolder holder = clientHandlers.get(requestId);, +                // now that we have the information visible via timeoutInfoHandlers, we try to remove the request id, +                final RequestHolder removedHolder = clientHandlers.remove(requestId);, +                if (removedHolder != null) {, +                    assert removedHolder == holder : "two different holder instances for request [" + requestId + "]";, +                    removedHolder.handler().handleException(new ReceiveTimeoutTransportException(holder.node(), holder.action(), "request_id [" + requestId + "] timed out after [" + (timeoutTime - sentTime) + "ms]"));, +                } else {, +                    // response was processed, remove timeout info., +                    timeoutInfoHandlers.remove(requestId);, +        /**, +         * cancels timeout handling. this is a best effort only to avoid running it. remove the requestId from {@link #clientHandlers}, +         * to make sure this doesn't run., +         */, +        public void cancel() {, +            assert clientHandlers.get(requestId) == null : "cancel must be called after the requestId [" + requestId + "] has been removed from clientHandlers";, +            FutureUtils.cancel(future);, +        }, +    }, +, +        private final TimeoutHandler timeoutHandler;, +        RequestHolder(TransportResponseHandler<T> handler, DiscoveryNode node, String action, TimeoutHandler timeoutHandler) {, +            this.timeoutHandler = timeoutHandler;, +        public void cancelTimeout() {, +            if (timeoutHandler != null) {, +                timeoutHandler.cancel();, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +        final TimeoutHandler timeoutHandler;, +, +            if (options.timeout() == null) {, +                timeoutHandler = null;, +            } else {, +                timeoutHandler = new TimeoutHandler(requestId);, +            }, +            if (timeoutHandler != null) {, +                assert options.timeout() != null;, +                holderToNotify.cancelTimeout();, +        public TransportResponseHandler onResponseReceived(final long requestId) {, +                checkForTimeout(requestId);, +                return null;, +            }, +            holder.cancelTimeout();, +            if (traceEnabled() && shouldTraceAction(holder.action())) {, +                traceReceivedResponse(requestId, holder.node(), holder.action());, +            }, +            return holder.handler();, +        }, +, +        protected void checkForTimeout(long requestId) {, +            // lets see if its in the timeout holder, but sync on mutex to make sure any ongoing timeout handling has finished, +            final DiscoveryNode sourceNode;, +            final String action;, +            assert clientHandlers.get(requestId) == null;, +                action = timeoutInfoHolder.action();, +                sourceNode = timeoutInfoHolder.node();, +                action = null;, +                sourceNode = null;, +            // call tracer out of lock, +            if (traceEnabled() == false) {]