[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            synchronized (mutex) {, +                ensureTermAtLeast(masterNode, term);, +                joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));, +            }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            synchronized (mutex) {, +                ensureTermAtLeast(masterNode, term);, +                joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));, +            }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Set;, +    final Set<Tuple<DiscoveryNode, JoinRequest>> pendingOutgoingJoins = ConcurrentCollections.newConcurrentSet();, +, +                sendJoinRequest(destination, Optional.of(joinLeaderInTerm.apply(request)));, +                channel.sendResponse(Empty.INSTANCE);, +            });, +    }, +, +    public void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin) {, +        final JoinRequest joinRequest = new JoinRequest(transportService.getLocalNode(), optionalJoin);, +        final Tuple<DiscoveryNode, JoinRequest> dedupKey = Tuple.tuple(destination, joinRequest);, +        if (pendingOutgoingJoins.add(dedupKey)) {, +            transportService.sendRequest(destination, JOIN_ACTION_NAME, joinRequest, new TransportResponseHandler<Empty>() {, +                    pendingOutgoingJoins.remove(dedupKey);, +                    pendingOutgoingJoins.remove(dedupKey);, +                    logger.info(() -> new ParameterizedMessage("failed to join {} with {}", destination, joinRequest), exp);, +        } else {, +            logger.debug("already attempting to join {} with request {}, not sending request", destination, joinRequest);, +        }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            synchronized (mutex) {, +                ensureTermAtLeast(masterNode, term);, +                joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));, +            }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Set;, +    final Set<Tuple<DiscoveryNode, JoinRequest>> pendingOutgoingJoins = ConcurrentCollections.newConcurrentSet();, +, +                sendJoinRequest(destination, Optional.of(joinLeaderInTerm.apply(request)));, +                channel.sendResponse(Empty.INSTANCE);, +            });, +    }, +, +    public void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin) {, +        final JoinRequest joinRequest = new JoinRequest(transportService.getLocalNode(), optionalJoin);, +        final Tuple<DiscoveryNode, JoinRequest> dedupKey = Tuple.tuple(destination, joinRequest);, +        if (pendingOutgoingJoins.add(dedupKey)) {, +            transportService.sendRequest(destination, JOIN_ACTION_NAME, joinRequest, new TransportResponseHandler<Empty>() {, +                    pendingOutgoingJoins.remove(dedupKey);, +                    pendingOutgoingJoins.remove(dedupKey);, +                    logger.info(() -> new ParameterizedMessage("failed to join {} with {}", destination, joinRequest), exp);, +        } else {, +            logger.debug("already attempting to join {} with request {}, not sending request", destination, joinRequest);, +        }, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +    public void testNodesJoinAfterStableCluster() {, +        final Cluster cluster = new Cluster(randomIntBetween(1, 5));, +        cluster.stabilise();, +, +        final long currentTerm = cluster.getAnyLeader().coordinator.getCurrentTerm();, +        cluster.addNodes(randomIntBetween(1, 2));, +        cluster.stabilise();, +, +        final long newTerm = cluster.getAnyLeader().coordinator.getCurrentTerm();, +        assertEquals(currentTerm, newTerm);, +    }, +, +        void addNodes(int newNodesCount) {, +            logger.info("--> adding {} nodes", newNodesCount);, +, +            final int nodeSizeAtStart = clusterNodes.size();, +            for (int i = 0; i < newNodesCount; i++) {, +                final ClusterNode clusterNode = new ClusterNode(nodeSizeAtStart + i);, +                clusterNodes.add(clusterNode);, +            }, +        }, +, +            assertThat(leader.coordinator.getLastCommittedState().map(ClusterState::getNodes).map(dn -> dn.nodeExists(leader.getId())),, +                equalTo(Optional.of(true)));, +                assertThat(clusterNode.coordinator.getLastCommittedState().map(ClusterState::getNodes).map(dn -> dn.nodeExists(nodeId)),, +                    equalTo(Optional.of(true)));, +, +            assertThat(leader.coordinator.getLastCommittedState().map(ClusterState::getNodes).map(DiscoveryNodes::getSize),, +                equalTo(Optional.of(clusterNodes.size())));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            synchronized (mutex) {, +                ensureTermAtLeast(masterNode, term);, +                joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));, +            }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Set;, +    final Set<Tuple<DiscoveryNode, JoinRequest>> pendingOutgoingJoins = ConcurrentCollections.newConcurrentSet();]