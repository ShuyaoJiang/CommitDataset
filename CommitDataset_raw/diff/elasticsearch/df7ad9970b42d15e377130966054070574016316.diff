[+++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +, +    /**, +     * Creates a new {@link DiscoveryNode}, +     * <p>, +     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current, +     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used, +     * the node might not be able to communicate with the remove node. After initial handshakes node versions will be discovered, +     * and updated., +     * </p>, +     *, +     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id., +     * @param address          the nodes transport address, +     * @param version          the version of the node, +     */, +    public DiscoveryNode(final String id, TransportAddress address, Version version) {, +        this(id, address, Collections.emptyMap(), Collections.emptySet(), version);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +, +    /**, +     * Creates a new {@link DiscoveryNode}, +     * <p>, +     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current, +     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used, +     * the node might not be able to communicate with the remove node. After initial handshakes node versions will be discovered, +     * and updated., +     * </p>, +     *, +     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id., +     * @param address          the nodes transport address, +     * @param version          the version of the node, +     */, +    public DiscoveryNode(final String id, TransportAddress address, Version version) {, +        this(id, address, Collections.emptyMap(), Collections.emptySet(), version);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +     *, +     *, +     *, +                        throw new IllegalStateException("task [" + existing.task + "] with source [" + source + "] is already queued");, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +, +    /**, +     * Creates a new {@link DiscoveryNode}, +     * <p>, +     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current, +     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used, +     * the node might not be able to communicate with the remove node. After initial handshakes node versions will be discovered, +     * and updated., +     * </p>, +     *, +     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id., +     * @param address          the nodes transport address, +     * @param version          the version of the node, +     */, +    public DiscoveryNode(final String id, TransportAddress address, Version version) {, +        this(id, address, Collections.emptyMap(), Collections.emptySet(), version);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +     *, +     *, +     *, +                        throw new IllegalStateException("task [" + existing.task + "] with source [" + source + "] is already queued");, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.cluster.ClusterStateTaskConfig;, +import org.elasticsearch.cluster.ClusterStateTaskExecutor;, +import org.elasticsearch.cluster.ClusterStateTaskListener;, +import java.util.function.BiFunction;, +    private volatile NodeRemovalClusterStateTaskExecutor nodeRemovalExecutor;, +        this.nodeRemovalExecutor = new NodeRemovalClusterStateTaskExecutor(allocationService, electMaster, this::rejoin, logger);, +    // visible for testing, +    static class NodeRemovalClusterStateTaskExecutor implements ClusterStateTaskExecutor<NodeRemovalClusterStateTaskExecutor.Task>, ClusterStateTaskListener {, +, +        private final AllocationService allocationService;, +        private final ElectMasterService electMasterService;, +        private final BiFunction<ClusterState, String, ClusterState> rejoin;, +        private final ESLogger logger;, +, +        static class Task {, +, +            private final DiscoveryNode node;, +            private final String reason;, +, +            public Task(final DiscoveryNode node, final String reason) {, +                this.node = node;, +                this.reason = reason;, +            }, +, +            public DiscoveryNode node() {, +                return node;, +            }, +, +            public String reason() {, +                return reason;, +            }, +]