[+++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4TransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4TransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/plugins/transport-nio/src/test/java/org/elasticsearch/transport/nio/NioTransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4TransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/plugins/transport-nio/src/test/java/org/elasticsearch/transport/nio/NioTransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/server/src/main/java/org/elasticsearch/transport/InboundMessage.java, +                    message = new Request(threadContext, remoteVersion, status, requestId, action, features, streamInput);, +                    message = new Response(threadContext, remoteVersion, status, requestId, streamInput);, +    public static class Request extends InboundMessage {, +        Request(ThreadContext threadContext, Version version, byte status, long requestId, String actionName, Set<String> features,, +    public static class Response extends InboundMessage {, +        Response(ThreadContext threadContext, Version version, byte status, long requestId, StreamInput streamInput) {, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4TransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/plugins/transport-nio/src/test/java/org/elasticsearch/transport/nio/NioTransportIT.java, +        protected void handleRequest(TcpChannel channel, InboundMessage.Request request, int messageLengthBytes) throws IOException {, +++ b/server/src/main/java/org/elasticsearch/transport/InboundMessage.java, +                    message = new Request(threadContext, remoteVersion, status, requestId, action, features, streamInput);, +                    message = new Response(threadContext, remoteVersion, status, requestId, streamInput);, +    public static class Request extends InboundMessage {, +        Request(ThreadContext threadContext, Version version, byte status, long requestId, String actionName, Set<String> features,, +    public static class Response extends InboundMessage {, +        Response(ThreadContext threadContext, Version version, byte status, long requestId, StreamInput streamInput) {, +++ b/server/src/main/java/org/elasticsearch/transport/OutboundHandler.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.transport.TransportAddress;, +import java.util.Set;, +, +    private final String nodeName;, +    private final Version version;, +    private final String[] features;, +    private volatile TransportMessageListener messageListener = TransportMessageListener.NOOP_LISTENER;, +    OutboundHandler(String nodeName, Version version, String[] features, ThreadPool threadPool, BigArrays bigArrays,, +                    TransportLogger transportLogger) {, +        this.nodeName = nodeName;, +        this.version = version;, +        this.features = features;, +            internalSend(channel, sendContext);, +    /**, +     * Sends the request to the given channel. This method should be used to send {@link TransportRequest}, +     * objects back to the caller., +     */, +    void sendRequest(final DiscoveryNode node, final TcpChannel channel, final long requestId, final String action,, +                     final TransportRequest request, final TransportRequestOptions options, final Version channelVersion,, +                     final boolean compressRequest, final boolean isHandshake) throws IOException, TransportException {, +        Version version = Version.min(this.version, channelVersion);, +        OutboundMessage.Request message = new OutboundMessage.Request(threadPool.getThreadContext(), features, request, version, action,, +            requestId, isHandshake, compressRequest);, +        ActionListener<Void> listener = ActionListener.wrap(() ->, +            messageListener.onRequestSent(node, requestId, action, request, options));, +        sendMessage(channel, message, listener);, +     * Sends the response to the given channel. This method should be used to send {@link TransportResponse}, +     * objects back to the caller., +     *, +     * @see #sendErrorResponse(Version, Set, TcpChannel, long, String, Exception) for sending error responses, +    void sendResponse(final Version nodeVersion, final Set<String> features, final TcpChannel channel,, +                      final long requestId, final String action, final TransportResponse response,, +                      final boolean compress, final boolean isHandshake) throws IOException {, +        Version version = Version.min(this.version, nodeVersion);, +        OutboundMessage.Response message = new OutboundMessage.Response(threadPool.getThreadContext(), features, response, version,, +            requestId, isHandshake, compress);, +        ActionListener<Void> listener = ActionListener.wrap(() -> messageListener.onResponseSent(requestId, action, response));, +        sendMessage(channel, message, listener);, +    }, +, +    /**, +     * Sends back an error response to the caller via the given channel, +     */, +    void sendErrorResponse(final Version nodeVersion, final Set<String> features, final TcpChannel channel, final long requestId,, +                           final String action, final Exception error) throws IOException {, +        Version version = Version.min(this.version, nodeVersion);, +        TransportAddress address = new TransportAddress(channel.getLocalAddress());, +        RemoteTransportException tx = new RemoteTransportException(nodeName, address, action, error);, +        OutboundMessage.Response message = new OutboundMessage.Response(threadPool.getThreadContext(), features, tx, version, requestId,, +            false, false);, +        ActionListener<Void> listener = ActionListener.wrap(() -> messageListener.onResponseSent(requestId, action, error));, +        sendMessage(channel, message, listener);, +    }, +, +    private void sendMessage(TcpChannel channel, OutboundMessage networkMessage, ActionListener<Void> listener) throws IOException {, +        MessageSerializer serializer = new MessageSerializer(networkMessage, bigArrays);, +        SendContext sendContext = new SendContext(channel, serializer, listener, serializer);, +        internalSend(channel, sendContext);, +    }, +, +    private void internalSend(TcpChannel channel, SendContext sendContext) throws IOException {, +    void setMessageListener(TransportMessageListener listener) {, +        if (messageListener == TransportMessageListener.NOOP_LISTENER) {, +            messageListener = listener;, +        } else {, +            throw new IllegalStateException("Cannot set message listener twice");, +        }, +    }, +]