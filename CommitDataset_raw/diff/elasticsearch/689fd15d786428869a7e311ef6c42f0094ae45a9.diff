[+++ b/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +++ b/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +++ b/src/main/java/org/elasticsearch/common/geo/GeoUtils.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import org.elasticsearch.index.mapper.geo.GeoPointFieldMapper;, +, +import java.io.IOException;, +    public static final String LATITUDE = GeoPointFieldMapper.Names.LAT;, +    public static final String LONGITUDE = GeoPointFieldMapper.Names.LON;, +    public static final String GEOHASH = GeoPointFieldMapper.Names.GEOHASH;, +    , +    /**, +     * Parse a {@link GeoPoint} with a {@link XContentParser}:, +     * , +     * @param parser {@link XContentParser} to parse the value from, +     * @return new {@link GeoPoint} parsed from the parse, +     * , +     * @throws IOException, +     * @throws org.elasticsearch.ElasticsearchParseException, +     */, +    public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException {, +        return parseGeoPoint(parser, new GeoPoint());, +    }, +    /**, +     * Parse a {@link GeoPoint} with a {@link XContentParser}. A geopoint has one of the following forms:, +     * , +     * <ul>, +     *     <li>Object: <pre>{&quot;lat&quot;: <i>&lt;latitude&gt;</i>, &quot;lon&quot;: <i>&lt;longitude&gt;</i>}</pre></li>, +     *     <li>String: <pre>&quot;<i>&lt;latitude&gt;</i>,<i>&lt;longitude&gt;</i>&quot;</pre></li>, +     *     <li>Geohash: <pre>&quot;<i>&lt;geohash&gt;</i>&quot;</pre></li>, +     *     <li>Array: <pre>[<i>&lt;longitude&gt;</i>,<i>&lt;latitude&gt;</i>]</pre></li>, +     * </ul>, +     * , +     * @param parser {@link XContentParser} to parse the value from, +     * @param point A {@link GeoPoint} that will be reset by the values parsed, +     * @return new {@link GeoPoint} parsed from the parse, +     * , +     * @throws IOException, +     * @throws org.elasticsearch.ElasticsearchParseException, +     */, +    public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point) throws IOException, ElasticsearchParseException {, +        double lat = Double.NaN;, +        double lon = Double.NaN;, +        String geohash = null;, +        , +        if(parser.currentToken() == Token.START_OBJECT) {, +            while(parser.nextToken() != Token.END_OBJECT) {, +                if(parser.currentToken() == Token.FIELD_NAME) {, +                    String field = parser.text();, +                    if(LATITUDE.equals(field)) {, +                        if(parser.nextToken() == Token.VALUE_NUMBER) {, +                            lat = parser.doubleValue();, +                        } else {, +                            throw new ElasticsearchParseException("latitude must be a number");, +                        }, +                    } else if (LONGITUDE.equals(field)) {, +                        if(parser.nextToken() == Token.VALUE_NUMBER) {, +                            lon = parser.doubleValue();, +                        } else {, +                            throw new ElasticsearchParseException("latitude must be a number");, +                        }, +                    } else if (GEOHASH.equals(field)) {, +                        if(parser.nextToken() == Token.VALUE_STRING) {, +                            geohash = parser.text();, +                        } else {, +                            throw new ElasticsearchParseException("geohash must be a string");, +                        }, +                    } else {, +                        throw new ElasticsearchParseException("field must be either '" + LATITUDE + "', '" + LONGITUDE + "' or '" + GEOHASH + "'");, +                    }, +                } else {, +                    throw new ElasticsearchParseException("Token '"+parser.currentToken()+"' not allowed");, +                }, +            }, +, +            if (geohash != null) {, +                if(!Double.isNaN(lat) || !Double.isNaN(lon)) {, +                    throw new ElasticsearchParseException("field must be either lat/lon or geohash");, +                } else {, +                    return point.resetFromGeoHash(geohash);, +                }, +            } else if (Double.isNaN(lat)) {, +                throw new ElasticsearchParseException("field [" + LATITUDE + "] missing");, +            } else if (Double.isNaN(lon)) {, +                throw new ElasticsearchParseException("field [" + LONGITUDE + "] missing");, +            } else {, +                return point.reset(lat, lon);, +            }, +            , +        } else if(parser.currentToken() == Token.START_ARRAY) {, +            int element = 0;, +            while(parser.nextToken() != Token.END_ARRAY) {, +                if(parser.currentToken() == Token.VALUE_NUMBER) {, +                    element++;, +                    if(element == 1) {, +                        lon = parser.doubleValue();, +                    } else if(element == 2) {, +                        lat = parser.doubleValue();]