[+++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String RETENTION_LEASES = "retention_leases";, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String RETENTION_LEASES = "retention_leases";, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.index.seqno.RetentionLease;, +                    /*, +                     * We sample these from the policy (which occurs under a lock) to ensure that we have a consistent view of the minimum, +                     * retained sequence number, and the retention leases., +                     */, +                    final Tuple<Long, Collection<RetentionLease>> retentionPolicy = softDeletesPolicy.getRetentionPolicy();, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()));, +                    commitData.put(Engine.RETENTION_LEASES, RetentionLease.encodeRetentionLeases(retentionPolicy.v2()));, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String RETENTION_LEASES = "retention_leases";, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.index.seqno.RetentionLease;, +                    /*, +                     * We sample these from the policy (which occurs under a lock) to ensure that we have a consistent view of the minimum, +                     * retained sequence number, and the retention leases., +                     */, +                    final Tuple<Long, Collection<RetentionLease>> retentionPolicy = softDeletesPolicy.getRetentionPolicy();, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()));, +                    commitData.put(Engine.RETENTION_LEASES, RetentionLease.encodeRetentionLeases(retentionPolicy.v2()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +import org.elasticsearch.common.collect.Tuple;, +    private Collection<RetentionLease> retentionLeases;, +        retentionLeases = retentionLeasesSupplier.get();, +        return getRetentionPolicy().v1();, +    }, +, +    public synchronized Tuple<Long, Collection<RetentionLease>> getRetentionPolicy() {, +        // do not advance if the retention lock is held, +            retentionLeases = retentionLeasesSupplier.get();, +            final long minimumRetainingSequenceNumber = retentionLeases, +        return Tuple.tuple(minRetainedSeqNo, retentionLeases);, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String RETENTION_LEASES = "retention_leases";, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.index.seqno.RetentionLease;, +                    /*, +                     * We sample these from the policy (which occurs under a lock) to ensure that we have a consistent view of the minimum, +                     * retained sequence number, and the retention leases., +                     */, +                    final Tuple<Long, Collection<RetentionLease>> retentionPolicy = softDeletesPolicy.getRetentionPolicy();, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()));, +                    commitData.put(Engine.RETENTION_LEASES, RetentionLease.encodeRetentionLeases(retentionPolicy.v2()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +import org.elasticsearch.common.collect.Tuple;, +    private Collection<RetentionLease> retentionLeases;, +        retentionLeases = retentionLeasesSupplier.get();, +        return getRetentionPolicy().v1();, +    }, +, +    public synchronized Tuple<Long, Collection<RetentionLease>> getRetentionPolicy() {, +        // do not advance if the retention lock is held, +            retentionLeases = retentionLeasesSupplier.get();, +            final long minimumRetainingSequenceNumber = retentionLeases, +        return Tuple.tuple(minRetainedSeqNo, retentionLeases);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +    /**, +     * Updates retention leases on a replica., +     *, +     * @param retentionLeases the retention leases, +     */, +    public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {, +        assert primaryMode == false;, +        this.retentionLeases.clear();, +        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())));, +    }, +, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0",, +                     "retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica", +// TESTRESPONSE[s/"retention_leases" : "id:replica-0;retaining_seq_no:0;timestamp:1547235588;source:replica"/"retention_leases": $body.indices.twitter.shards.0.0.commit.user_data.retention_leases/], +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String RETENTION_LEASES = "retention_leases";]