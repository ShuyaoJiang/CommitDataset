[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                throw new IndexFormatTooOldException("translog", "translog has no generation nor a UUID - this might be an index from a previous version consider upgrading to N-1 first");, +                        final long committedGeneration = commitIndexWriter(indexWriter, translog, null);, +                        translog.commit(committedGeneration);, +    /**, +     * Commits the specified index writer., +     *, +     * @param writer   the index writer to commit, +     * @param translog the translog, +     * @param syncId   the sync flush ID ({@code null} if not committing a synced flush), +     * @return the minimum translog generation for the local checkpoint committed with the specified index writer, +     * @throws IOException if an I/O exception occurs committing the specfied writer, +     */, +    private long commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {, +            final long localCheckpoint = seqNoService().getLocalCheckpoint();, +            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1);, +            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration);, +            final String localCheckpointValue = Long.toString(localCheckpoint);, +                 * segments, including the local checkpoint amongst other values. The maximum sequence number is different, we never want, +                 * {@link IndexWriter#commit()} call flushes all documents, we defer computation of the maximum sequence number to the time, +                 * of invocation of the commit data iterator (which occurs after all documents have been flushed to Lucene)., +                final Map<String, String> commitData = new HashMap<>(5);, +                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration);, +                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue);, +            return translogGeneration.translogFileGeneration;, +        } catch (final Exception ex) {, +            } catch (final Exception inner) {, +        } catch (final AssertionError e) {, +            /*, +             * If assertions are enabled, IndexWriter throws AssertionError on commit if any files don't exist, but tests that randomly, +             * throw FileNotFoundException or NoSuchFileException can also hit this., +             */, +                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e);, +                } catch (final Exception inner) {, +        Map<String, String> commitData = new HashMap<>(5);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                throw new IndexFormatTooOldException("translog", "translog has no generation nor a UUID - this might be an index from a previous version consider upgrading to N-1 first");, +                        final long committedGeneration = commitIndexWriter(indexWriter, translog, null);, +                        translog.commit(committedGeneration);, +    /**, +     * Commits the specified index writer., +     *, +     * @param writer   the index writer to commit, +     * @param translog the translog, +     * @param syncId   the sync flush ID ({@code null} if not committing a synced flush), +     * @return the minimum translog generation for the local checkpoint committed with the specified index writer, +     * @throws IOException if an I/O exception occurs committing the specfied writer, +     */, +    private long commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {, +            final long localCheckpoint = seqNoService().getLocalCheckpoint();, +            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1);, +            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration);, +            final String localCheckpointValue = Long.toString(localCheckpoint);, +                 * segments, including the local checkpoint amongst other values. The maximum sequence number is different, we never want, +                 * {@link IndexWriter#commit()} call flushes all documents, we defer computation of the maximum sequence number to the time, +                 * of invocation of the commit data iterator (which occurs after all documents have been flushed to Lucene)., +                final Map<String, String> commitData = new HashMap<>(5);, +                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration);, +                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue);, +            return translogGeneration.translogFileGeneration;, +        } catch (final Exception ex) {, +            } catch (final Exception inner) {, +        } catch (final AssertionError e) {, +            /*, +             * If assertions are enabled, IndexWriter throws AssertionError on commit if any files don't exist, but tests that randomly, +             * throw FileNotFoundException or NoSuchFileException can also hit this., +             */, +                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e);, +                } catch (final Exception inner) {, +        Map<String, String> commitData = new HashMap<>(5);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, + * generation is committed using {@link Translog#commit(long)}. In the common case the translog file generation in the checkpoint and the generation passed to the translog on creation are, + * the same. The only situation when they can be different is when an actual translog commit fails in between {@link Translog#prepareCommit()} and {@link Translog#commit(long)}. In such a case, +public class Translog extends AbstractIndexShardComponent implements IndexShardComponent, Closeable {, +        long primaryTerm();, +, +        @Override, +        @Override, +        @Override, +     * Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if, +     * there is no generation that could any such sequence number., +     *, +     * @param seqNo the sequence number, +     * @return the minimum generation for the sequence number, +     */, +    public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            /*, +             * When flushing, the engine will ask the translog for the minimum generation that could contain any sequence number after the, +             * local checkpoint. Immediately after flushing, there will be no such generation, so this minimum generation in this case will, +             * be the current translog generation as we do not need any prior generations to have a complete history up to the current local, +             * checkpoint., +             */, +            long minTranslogFileGeneration = this.currentFileGeneration();, +            for (final TranslogReader reader : readers) {, +                if (seqNo <= reader.getCheckpoint().maxSeqNo) {, +                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration());, +                }, +            }, +            return new TranslogGeneration(translogUUID, minTranslogFileGeneration);]