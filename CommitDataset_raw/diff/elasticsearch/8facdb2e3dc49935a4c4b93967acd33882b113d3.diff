[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.metadata.MetaDataService;, +        bind(MetaDataService.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.metadata.MetaDataService;, +        bind(MetaDataService.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +    private final MetaDataService metaDataService;, +, +                                              ShardsAllocation shardsAllocation, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, @RiverIndexName String riverIndexName) {, +        this.metaDataService = metaDataService;, +        // we lock here, and not within the cluster service callback since we don't want to, +        // block the whole cluster state handling, +        MetaDataService.MdLock mdLock = metaDataService.indexMetaDataLock(request.index);, +        try {, +            mdLock.lock();, +        } catch (InterruptedException e) {, +            userListener.onFailure(e);, +            return;, +        }, +, +        final CreateIndexListener listener = new CreateIndexListener(mdLock, request, userListener);, +        private final AtomicBoolean notified = new AtomicBoolean();, +, +        private final MetaDataService.MdLock mdLock;, +        private CreateIndexListener(MetaDataService.MdLock mdLock, Request request, Listener listener) {, +            this.mdLock = mdLock;, +                mdLock.unlock();, +                mdLock.unlock();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.metadata.MetaDataService;, +        bind(MetaDataService.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +    private final MetaDataService metaDataService;, +, +                                              ShardsAllocation shardsAllocation, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, @RiverIndexName String riverIndexName) {, +        this.metaDataService = metaDataService;, +        // we lock here, and not within the cluster service callback since we don't want to, +        // block the whole cluster state handling, +        MetaDataService.MdLock mdLock = metaDataService.indexMetaDataLock(request.index);, +        try {, +            mdLock.lock();, +        } catch (InterruptedException e) {, +            userListener.onFailure(e);, +            return;, +        }, +, +        final CreateIndexListener listener = new CreateIndexListener(mdLock, request, userListener);, +        private final AtomicBoolean notified = new AtomicBoolean();, +, +        private final MetaDataService.MdLock mdLock;, +        private CreateIndexListener(MetaDataService.MdLock mdLock, Request request, Listener listener) {, +            this.mdLock = mdLock;, +                mdLock.unlock();, +                mdLock.unlock();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +    private final MetaDataService metaDataService;, +, +                                              NodeIndexDeletedAction nodeIndexDeletedAction, MetaDataService metaDataService) {, +        this.metaDataService = metaDataService;, +        // we lock here, and not within the cluster service callback since we don't want to, +        // block the whole cluster state handling, +        MetaDataService.MdLock mdLock = metaDataService.indexMetaDataLock(request.index);, +        try {, +            mdLock.lock();, +        } catch (InterruptedException e) {, +            userListener.onFailure(e);, +            return;, +        }, +, +        final DeleteIndexListener listener = new DeleteIndexListener(mdLock, request, userListener);, +        private final AtomicBoolean notified = new AtomicBoolean();, +, +        private final MetaDataService.MdLock mdLock;, +        private DeleteIndexListener(MetaDataService.MdLock mdLock, Request request, Listener listener) {, +            this.mdLock = mdLock;, +                mdLock.unlock();, +                mdLock.unlock();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.metadata.MetaDataService;, +        bind(MetaDataService.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +    private final MetaDataService metaDataService;, +, +                                              ShardsAllocation shardsAllocation, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, @RiverIndexName String riverIndexName) {, +        this.metaDataService = metaDataService;, +        // we lock here, and not within the cluster service callback since we don't want to, +        // block the whole cluster state handling, +        MetaDataService.MdLock mdLock = metaDataService.indexMetaDataLock(request.index);, +        try {, +            mdLock.lock();, +        } catch (InterruptedException e) {, +            userListener.onFailure(e);, +            return;, +        }, +, +        final CreateIndexListener listener = new CreateIndexListener(mdLock, request, userListener);, +        private final AtomicBoolean notified = new AtomicBoolean();, +, +        private final MetaDataService.MdLock mdLock;]