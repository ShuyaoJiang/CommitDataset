[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/test/java/org/elasticsearch/threadpool/SimpleThreadPoolIT.java, +                    Pattern.quote("node_tribe2") + ")";, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/test/java/org/elasticsearch/threadpool/SimpleThreadPoolIT.java, +                    Pattern.quote("node_tribe2") + ")";, +++ b/core/src/test/java/org/elasticsearch/tribe/TribeIT.java, +import org.elasticsearch.action.support.DestructiveOperations;, +import org.elasticsearch.cluster.ClusterName;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.discovery.DiscoverySettings;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.transport.Transport;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import java.util.function.Consumer;, +import java.util.function.Predicate;, +import java.util.stream.Stream;, +import java.util.stream.StreamSupport;, +import static java.util.stream.Collectors.toSet;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.core.Is.is;, +@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.SUITE, numDataNodes = 0, numClientNodes = 0, transportClientRatio = 0.0), +    private static final String TRIBE_NODE = "tribe_node";, +    private static InternalTestCluster cluster1;, +    /**, +     * A predicate that is used to select none of the remote clusters, +     **/, +    private static final Predicate<InternalTestCluster> NONE = c -> false;, +, +    /**, +     * A predicate that is used to select the remote cluster 1 only, +     **/, +    private static final Predicate<InternalTestCluster> CLUSTER1_ONLY = c -> c.getClusterName().equals(cluster1.getClusterName());, +, +    /**, +     * A predicate that is used to select the remote cluster 2 only, +     **/, +    private static final Predicate<InternalTestCluster> CLUSTER2_ONLY = c -> c.getClusterName().equals(cluster2.getClusterName());, +, +    /**, +     * A predicate that is used to select the the two remote clusters, +     **/, +    private static final Predicate<InternalTestCluster> ALL = c -> true;, +, +    @Override, +    protected Settings nodeSettings(int nodeOrdinal) {, +        return Settings.builder(), +                .put(super.nodeSettings(nodeOrdinal)), +                // Required to delete _all indices on remote clusters, +                .put(DestructiveOperations.REQUIRES_NAME_SETTING.getKey(), false), +                .build();, +    }, +, +    @Override, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return getMockPlugins();, +    }, +    public void startRemoteClusters() {, +        final int minNumDataNodes = 2;, +        final int maxNumDataNodes = 4;, +        final NodeConfigurationSource nodeConfigurationSource = getNodeConfigSource();, +        final Collection<Class<? extends Plugin>> plugins = nodePlugins();, +, +        if (cluster1 == null) {, +            cluster1 = new InternalTestCluster(randomLong(), createTempDir(), true, minNumDataNodes, maxNumDataNodes,, +                    UUIDs.randomBase64UUID(random()), nodeConfigurationSource, 0, false, "cluster_1",, +                    plugins, Function.identity());, +        if (cluster2 == null) {, +            cluster2 = new InternalTestCluster(randomLong(), createTempDir(), true, minNumDataNodes, maxNumDataNodes,, +                    UUIDs.randomBase64UUID(random()), nodeConfigurationSource, 0, false, "cluster_2",, +                    plugins, Function.identity());, +        }, +, +        doWithAllClusters(c -> {, +                c.beforeTest(random(), 0.1);, +                c.ensureAtLeastNumDataNodes(minNumDataNodes);, +            } catch (Exception e) {, +                throw new RuntimeException("Failed to set up remote cluster [" + c.getClusterName() + "]", e);, +        });, +    public void wipeRemoteClusters() {, +        doWithAllClusters(c -> {, +            final String clusterName = c.getClusterName();, +                c.client().admin().indices().prepareDelete(MetaData.ALL).get();, +                c.afterTest();, +            } catch (IOException e) {, +                throw new RuntimeException("Failed to clean up remote cluster [" + clusterName + "]", e);, +            }, +        });, +    }, +, +    @AfterClass, +    public static void stopRemoteClusters() {, +        try {]