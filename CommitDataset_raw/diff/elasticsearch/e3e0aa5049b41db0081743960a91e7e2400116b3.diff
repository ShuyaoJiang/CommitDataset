[+++ b/core/src/main/java/org/elasticsearch/discovery/zen/publish/PublishClusterStateAction.java, +        final CountDownLatch committedOrFailedLatch;, +        // writes and reads of these are protected under synchronization, +        boolean committedOrFailed; // true if a decision was made w.r.t committing or failing, +        boolean committed;  // true if cluster state was committed, +        int neededMastersToCommit; // number of master nodes acks still needed before committing, +        int pendingMasterNodes; // how many master node still need to respond, +, +        // an external marker to note that the publishing process is timed out. This is useful for proper logging., +            this.committed = neededMastersToCommit == 0;, +            this.committedOrFailed = committed;, +            this.committedOrFailedLatch = new CountDownLatch(committed ? 0 : 1);, +                timedout = committedOrFailedLatch.await(commitTimeout.millis(), TimeUnit.MILLISECONDS) == false;, +, +            if (timedout) {, +                markAsFailed("timed out waiting for commit (commit timeout [" + commitTimeout + "]");, +            }, +            if (isCommitted() == false) {, +        synchronized public boolean isCommitted() {, +            return committed;, +        }, +, +            if (committed) {, +                assert sendAckedBeforeCommit.isEmpty();, +                sendCommitToNode(node, clusterState, this);, +            } else if (committedOrFailed) {, +                logger.trace("ignoring ack from [{}] for cluster state version [{}]. already failed", node, clusterState.version());, +            } else {, +                // we're still waiting, +            }, +        synchronized private void onMasterNodeSendAck(DiscoveryNode node) {, +                if (markAsCommitted()) {, +                }, +        synchronized private void onMasterNodeDone(DiscoveryNode node) {, +                markAsFailed("All master nodes acked or failed but [" + neededMastersToCommit + "] acks are still needed");, +        /**, +         * tries and commit the current state, if a decision wasn't made yet, +         *, +         * @return true if successful, +         */, +        synchronized private boolean markAsCommitted() {, +            if (committedOrFailed) {, +                return committed;, +            }, +            logger.trace("committing version [{}]", clusterState.version());, +            committed = true;, +            committedOrFailed = true;, +            committedOrFailedLatch.countDown();, +            return true;, +        }, +, +        /**, +         * tries marking the publishing as failed, if a decision wasn't made yet, +         *, +         * @return true if the publishing was failed and the cluster state is *not* committed, +         **/, +        synchronized private boolean markAsFailed(String reason) {, +            if (committedOrFailed) {, +                return committed == false;, +            }, +            logger.trace("failed to commit version [{}]. {}", clusterState.version(), reason);, +            committedOrFailed = true;, +            committed = false;, +            committedOrFailedLatch.countDown();, +            return true;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/publish/PublishClusterStateAction.java, +        final CountDownLatch committedOrFailedLatch;, +        // writes and reads of these are protected under synchronization, +        boolean committedOrFailed; // true if a decision was made w.r.t committing or failing, +        boolean committed;  // true if cluster state was committed, +        int neededMastersToCommit; // number of master nodes acks still needed before committing, +        int pendingMasterNodes; // how many master node still need to respond, +, +        // an external marker to note that the publishing process is timed out. This is useful for proper logging., +            this.committed = neededMastersToCommit == 0;, +            this.committedOrFailed = committed;, +            this.committedOrFailedLatch = new CountDownLatch(committed ? 0 : 1);, +                timedout = committedOrFailedLatch.await(commitTimeout.millis(), TimeUnit.MILLISECONDS) == false;, +, +            if (timedout) {, +                markAsFailed("timed out waiting for commit (commit timeout [" + commitTimeout + "]");, +            }, +            if (isCommitted() == false) {, +        synchronized public boolean isCommitted() {, +            return committed;, +        }, +, +            if (committed) {, +                assert sendAckedBeforeCommit.isEmpty();, +                sendCommitToNode(node, clusterState, this);, +            } else if (committedOrFailed) {, +                logger.trace("ignoring ack from [{}] for cluster state version [{}]. already failed", node, clusterState.version());, +            } else {, +                // we're still waiting, +            }, +        synchronized private void onMasterNodeSendAck(DiscoveryNode node) {, +                if (markAsCommitted()) {, +                }]