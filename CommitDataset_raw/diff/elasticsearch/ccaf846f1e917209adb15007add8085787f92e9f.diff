[+++ b/core/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, QueryCache queryCache, BitsetFilterCache bitsetFilterCache) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, QueryCache queryCache, BitsetFilterCache bitsetFilterCache) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/query/QueryCacheModule.java, +++ b/core/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, QueryCache queryCache, BitsetFilterCache bitsetFilterCache) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/query/QueryCacheModule.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.search.QueryCachingPolicy;, +import org.apache.lucene.search.UsageTrackingQueryCachingPolicy;, +import org.elasticsearch.index.cache.query.QueryCacheModule.QueryCacheSettings;, +        final QueryCachingPolicy cachingPolicy;, +        // the query cache is a node-level thing, however we want the most popular filters, +        // to be computed on a per-shard basis, +        if (indexSettings.getAsBoolean(QueryCacheSettings.QUERY_CACHE_EVERYTHING, false)) {, +            cachingPolicy = QueryCachingPolicy.ALWAYS_CACHE;, +        } else {, +            cachingPolicy = new UsageTrackingQueryCachingPolicy();, +        }, +        this.engineConfig = newEngineConfig(translogConfig, cachingPolicy);, +    private final EngineConfig newEngineConfig(TranslogConfig translogConfig, QueryCachingPolicy cachingPolicy) {, +                mapperService.indexAnalyzer(), similarityService.similarity(), codecService, failedEngineListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig);, +++ b/core/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, QueryCache queryCache, BitsetFilterCache bitsetFilterCache) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/query/QueryCacheModule.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.search.QueryCachingPolicy;, +import org.apache.lucene.search.UsageTrackingQueryCachingPolicy;, +import org.elasticsearch.index.cache.query.QueryCacheModule.QueryCacheSettings;, +        final QueryCachingPolicy cachingPolicy;, +        // the query cache is a node-level thing, however we want the most popular filters, +        // to be computed on a per-shard basis, +        if (indexSettings.getAsBoolean(QueryCacheSettings.QUERY_CACHE_EVERYTHING, false)) {, +            cachingPolicy = QueryCachingPolicy.ALWAYS_CACHE;, +        } else {, +            cachingPolicy = new UsageTrackingQueryCachingPolicy();, +        }, +        this.engineConfig = newEngineConfig(translogConfig, cachingPolicy);, +    private final EngineConfig newEngineConfig(TranslogConfig translogConfig, QueryCachingPolicy cachingPolicy) {, +                mapperService.indexAnalyzer(), similarityService.similarity(), codecService, failedEngineListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig);, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +                        if (ref.utf8ToString().equals(translogUUID) == false) {, +                            throw new TranslogCorruptedException("expected shard UUID [" + translogUUID + "] but got: [" + ref.utf8ToString() + "] this translog file belongs to a different translog");, +++ b/core/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, QueryCache queryCache, BitsetFilterCache bitsetFilterCache) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/query/QueryCacheModule.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.search.QueryCachingPolicy;, +import org.apache.lucene.search.UsageTrackingQueryCachingPolicy;, +import org.elasticsearch.index.cache.query.QueryCacheModule.QueryCacheSettings;, +        final QueryCachingPolicy cachingPolicy;, +        // the query cache is a node-level thing, however we want the most popular filters, +        // to be computed on a per-shard basis, +        if (indexSettings.getAsBoolean(QueryCacheSettings.QUERY_CACHE_EVERYTHING, false)) {, +            cachingPolicy = QueryCachingPolicy.ALWAYS_CACHE;, +        } else {, +            cachingPolicy = new UsageTrackingQueryCachingPolicy();, +        }, +        this.engineConfig = newEngineConfig(translogConfig, cachingPolicy);, +    private final EngineConfig newEngineConfig(TranslogConfig translogConfig, QueryCachingPolicy cachingPolicy) {, +                mapperService.indexAnalyzer(), similarityService.similarity(), codecService, failedEngineListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig);, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +                        if (ref.utf8ToString().equals(translogUUID) == false) {, +                            throw new TranslogCorruptedException("expected shard UUID [" + translogUUID + "] but got: [" + ref.utf8ToString() + "] this translog file belongs to a different translog");, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +import org.apache.lucene.search.QueryCachingPolicy;, +            final QueryCachingPolicy cachingPolicy = context.indexShard().engine().config().getQueryCachingPolicy();, +                    indexCache.query(), cachingPolicy));, +            final QueryCachingPolicy cachingPolicy = context.indexShard().engine().config().getQueryCachingPolicy();, +                    indexCache.query(), cachingPolicy));]