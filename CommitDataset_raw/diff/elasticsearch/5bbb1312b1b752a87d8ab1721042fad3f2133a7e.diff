[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +            if (isEmptyOrTrivialWildcard(expressions)) {, +                return resolveEmptyOrTrivialWildcard(options, metaData, true);, +            Set<String> result = innerResolve(context, expressions, options, metaData);, +, +            if (result == null) {, +                return expressions;, +            }, +            if (result.isEmpty() && !options.allowNoIndices()) {, +                IndexNotFoundException infe = new IndexNotFoundException((String)null);, +                infe.setResources("index_or_alias", expressions.toArray(new String[0]));, +                throw infe;, +            }, +            return new ArrayList<>(result);, +        }, +, +        private Set<String> innerResolve(Context context, List<String> expressions, IndicesOptions options, MetaData metaData) {, +                if (aliasOrIndexExists(metaData, expression)) {, +                    throw infe(expression);, +                        List<String> concreteIndices = resolveEmptyOrTrivialWildcard(options, metaData, false);, +                        result = new HashSet<>(concreteIndices);, +                    if (!unavailableIgnoredOrExists(options, metaData, expression)) {, +                        throw infe(expression);, +                    result = new HashSet<>(expressions.subList(0, i));, +                final IndexMetaData.State excludeState = excludeState(options);, +                final Map<String, AliasOrIndex> matches = matches(metaData, expression);, +                Set<String> expand = expand(context, excludeState, matches);, +                if (add) {, +                    result.addAll(expand);, +                } else {, +                    result.removeAll(expand);, +                }, +, +                if (!noIndicesAllowedOrMatches(options, matches)) {, +                    throw infe(expression);, +                }, +            }, +            return result;, +        }, +, +        private boolean noIndicesAllowedOrMatches(IndicesOptions options, Map<String, AliasOrIndex> matches) {, +            return options.allowNoIndices() || !matches.isEmpty();, +        }, +, +        private boolean unavailableIgnoredOrExists(IndicesOptions options, MetaData metaData, String expression) {, +            return options.ignoreUnavailable() || aliasOrIndexExists(metaData, expression);, +        }, +, +        private boolean aliasOrIndexExists(MetaData metaData, String expression) {, +            return metaData.getAliasAndIndexLookup().containsKey(expression);, +        }, +, +        private static IndexNotFoundException infe(String expression) {, +            IndexNotFoundException infe = new IndexNotFoundException(expression);, +            infe.setResources("index_or_alias", expression);, +            return infe;, +        }, +, +        private static IndexMetaData.State excludeState(IndicesOptions options) {, +            return excludeState;, +        }, +        private static Map<String, AliasOrIndex> matches(MetaData metaData, String expression) {, +                return metaData.getAliasAndIndexLookup();, +                return suffixWildcard(metaData, expression);, +            } else {, +                return otherWildcard(metaData, expression);, +            }, +        }, +, +        private static Map<String, AliasOrIndex> suffixWildcard(MetaData metaData, String expression) {, +            return metaData.getAliasAndIndexLookup().subMap(fromPrefix, toPrefix);, +        }, +, +        private static Map<String, AliasOrIndex> otherWildcard(MetaData metaData, String expression) {, +            return metaData.getAliasAndIndexLookup(), +, +        private static Set<String> expand(Context context, IndexMetaData.State excludeState, Map<String, AliasOrIndex> matches) {, +            return expand;, +        private boolean isEmptyOrTrivialWildcard(List<String> expressions) {, +            return expressions.isEmpty() || (expressions.size() == 1 && (MetaData.ALL.equals(expressions.get(0))) || Regex.isMatchAllPattern(expressions.get(0)));, +, +        private List<String> resolveEmptyOrTrivialWildcard(IndicesOptions options, MetaData metaData, boolean assertEmpty) {, +            if (options.expandWildcardsOpen() && options.expandWildcardsClosed()) {, +                return Arrays.asList(metaData.concreteAllIndices());, +            } else if (options.expandWildcardsOpen()) {, +                return Arrays.asList(metaData.concreteAllOpenIndices());, +            } else if (options.expandWildcardsClosed()) {, +                return Arrays.asList(metaData.concreteAllClosedIndices());, +            } else {, +                assert assertEmpty : "Shouldn't end up here";, +                return Collections.emptyList();]