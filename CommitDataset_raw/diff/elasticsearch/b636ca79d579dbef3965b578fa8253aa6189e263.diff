[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            return op.versionType().isVersionConflictForWrites(versionValue.getVersion(), op.version(), versionValue.isDelete()) ?, +                OpVsLuceneDocStatus.OP_STALE_OR_EQUAL : OpVsLuceneDocStatus.OP_NEWER;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            return op.versionType().isVersionConflictForWrites(versionValue.getVersion(), op.version(), versionValue.isDelete()) ?, +                OpVsLuceneDocStatus.OP_STALE_OR_EQUAL : OpVsLuceneDocStatus.OP_NEWER;, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +    protected List<Engine.Operation> generateSingleDocHistory(boolean forReplica, VersionType versionType,, +                                                              boolean partialOldPrimary, long primaryTerm,, +                                                              int minOpCount, int maxOpCount) {, +            final long version;, +            switch (versionType) {, +                case INTERNAL:, +                    version = forReplica ? i : Versions.MATCH_ANY;, +                    break;, +                case EXTERNAL:, +                    version = i;, +                    break;, +                case EXTERNAL_GTE:, +                    version = randomBoolean() ? Math.max(i - 1, 0) : i;, +                    break;, +                case FORCE:, +                    version = randomNonNegativeLong();, +                    break;, +                default:, +                    throw new UnsupportedOperationException("unknown version type: " + versionType);, +            }, +                    version,, +                    version,, +        final List<Engine.Operation> ops = generateSingleDocHistory(true,, +            randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), false, 2, 2, 20);, +        assertOpsOnReplica(ops, replicaEngine, true);, +    public void testNonStandardVersioningOnReplica() throws IOException {, +        // TODO: this can be folded into testOutOfOrderDocsOnReplica once out of order, +        // is detected using seq#, +        final List<Engine.Operation> ops = generateSingleDocHistory(true,, +            randomFrom(VersionType.EXTERNAL_GTE, VersionType.FORCE), false, 2, 2, 20);, +        assertOpsOnReplica(ops, replicaEngine, false);, +    }, +, +, +            final List<Engine.Operation> ops = generateSingleDocHistory(true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), true, 2, 2, 20);, +            assertOpsOnReplica(ops, replicaEngine, true);, +    private void assertOpsOnReplica(List<Engine.Operation> ops, InternalEngine replicaEngine, boolean shuffleOps) throws IOException {, +        if (shuffleOps) {, +        }, +        final List<Engine.Operation> ops = generateSingleDocHistory(true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), false, 2, 100, 300);, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, VersionType.INTERNAL, false, 2, 2, 20);, +    public void testNonInternalVersioningOnPrimary() throws IOException {, +        final Set<VersionType> nonInternalVersioning = new HashSet<>(Arrays.asList(VersionType.values()));, +        nonInternalVersioning.remove(VersionType.INTERNAL);, +        final VersionType versionType = randomFrom(nonInternalVersioning);, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, versionType, false, 2, 2, 20);, +        // other version types don't support out of order processing., +        if (versionType == VersionType.EXTERNAL) {, +        }, +                if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {, +                if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {, +            logger.info("searching for [{}]", lastFieldValue);, +        final List<Engine.Operation> replicaOps = generateSingleDocHistory(true, VersionType.INTERNAL, false, 1, 2, 20);, +        List<Engine.Operation> primaryOps = generateSingleDocHistory(false, VersionType.INTERNAL, false, 2, 2, 20);, +        assertOpsOnReplica(replicaOps, replicaEngine, true);, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, VersionType.EXTERNAL, false, 2, 100, 300);]