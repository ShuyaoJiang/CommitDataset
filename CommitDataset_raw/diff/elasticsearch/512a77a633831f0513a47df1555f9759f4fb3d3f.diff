[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +        STATUS_EXCEPTION(org.elasticsearch.ElasticsearchStatusException.class, org.elasticsearch.ElasticsearchStatusException::new, 145),, +        TASK_CANCELLED_EXCEPTION(org.elasticsearch.tasks.TaskCancelledException.class,, +            org.elasticsearch.tasks.TaskCancelledException::new, 146);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +        STATUS_EXCEPTION(org.elasticsearch.ElasticsearchStatusException.class, org.elasticsearch.ElasticsearchStatusException::new, 145),, +        TASK_CANCELLED_EXCEPTION(org.elasticsearch.tasks.TaskCancelledException.class,, +            org.elasticsearch.tasks.TaskCancelledException::new, 146);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +     * Construct a {@code WeightedDecision} object for the given shard given all the metadata. This also attempts to construct the human, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +        STATUS_EXCEPTION(org.elasticsearch.ElasticsearchStatusException.class, org.elasticsearch.ElasticsearchStatusException::new, 145),, +        TASK_CANCELLED_EXCEPTION(org.elasticsearch.tasks.TaskCancelledException.class,, +            org.elasticsearch.tasks.TaskCancelledException::new, 146);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +     * Construct a {@code WeightedDecision} object for the given shard given all the metadata. This also attempts to construct the human, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.delete.TransportDeleteAction;, +import org.elasticsearch.action.index.TransportIndexAction;, +import org.elasticsearch.index.translog.Translog.Location;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected WriteResult<BulkShardResponse> onPrimaryShard(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new WriteResult<>(response, location);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard indexShard,, +                                                     Translog.Location location, int requestIndex) {, +        preVersions[requestIndex] = request.items()[requestIndex].request().version();, +        preVersionTypes[requestIndex] = request.items()[requestIndex].request().versionType();, +        DocWriteRequest.OpType opType = request.items()[requestIndex].request().opType();, +            WriteResult<? extends DocWriteResponse> writeResult = innerExecuteBulkItemRequest(metaData, indexShard,, +                request, requestIndex);, +            if (writeResult.getLocation() != null) {, +                location = locationToSync(location, writeResult.getLocation());, +            } else {, +                assert writeResult.getResponse().getResult() == DocWriteResponse.Result.NOOP, +                        : "only noop operation can have null next operation";, +            // add the response, +            setResponse(item, new BulkItemResponse(item.id(), opType, writeResult.getResponse()));, +                throw (ElasticsearchException) e;, +            BulkItemRequest item = request.items()[requestIndex];, +            DocWriteRequest docWriteRequest = item.request();, +            if (isConflictException(e)) {, +                logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                        request.shardId(), docWriteRequest.opType().getLowercase(), request), e);, +            } else {, +                logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                        request.shardId(), docWriteRequest.opType().getLowercase(), request), e);, +            // if its a conflict failure, and we already executed the request on a primary (and we execute it, +            // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +            // then just use the response we got from the successful execution, +            if (item.getPrimaryResponse() != null && isConflictException(e)) {, +                setResponse(item, item.getPrimaryResponse());, +            } else {, +                setResponse(item, new BulkItemResponse(item.id(), docWriteRequest.opType(),, +                    new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), e)));, +            }, +        }, +        assert request.items()[requestIndex].getPrimaryResponse() != null;, +        assert preVersionTypes[requestIndex] != null;, +    private WriteResult<? extends DocWriteResponse> innerExecuteBulkItemRequest(IndexMetaData metaData, IndexShard indexShard,, +                                                            BulkShardRequest request, int requestIndex) throws Exception {, +        DocWriteRequest itemRequest = request.items()[requestIndex].request();, +        switch (itemRequest.opType()) {, +            case CREATE:, +            case INDEX:, +                return TransportIndexAction.executeIndexRequestOnPrimary(((IndexRequest) itemRequest), indexShard, mappingUpdatedAction);, +            case UPDATE:, +                int maxAttempts = ((UpdateRequest) itemRequest).retryOnConflict();, +                for (int attemptCount = 0; attemptCount <= maxAttempts; attemptCount++) {, +                    try {, +                        return shardUpdateOperation(metaData, indexShard, request, requestIndex, ((UpdateRequest) itemRequest));, +                    } catch (Exception e) {, +                        final Throwable cause = ExceptionsHelper.unwrapCause(e);, +                        if (attemptCount == maxAttempts  // bubble up exception when we run out of attempts, +                                || (cause instanceof VersionConflictEngineException) == false) { // or when exception is not a version conflict, +                            throw e;, +                        }, +                    }, +                }]