[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import java.util.concurrent.TimeUnit;, +            // Testing non existing document, +            String docId = "does_not_exist";, +            DeleteRequest deleteRequest = new DeleteRequest("index", "type", docId);, +            DeleteResponse deleteResponse = execute(deleteRequest, highLevelClient()::delete, highLevelClient()::deleteAsync);, +            assertEquals("index", deleteResponse.getIndex());, +            assertEquals("type", deleteResponse.getType());, +            assertEquals(docId, deleteResponse.getId());, +            assertEquals(DocWriteResponse.Result.NOT_FOUND, deleteResponse.getResult());, +        }, +        {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import java.util.concurrent.TimeUnit;, +            // Testing non existing document, +            String docId = "does_not_exist";, +            DeleteRequest deleteRequest = new DeleteRequest("index", "type", docId);, +            DeleteResponse deleteResponse = execute(deleteRequest, highLevelClient()::delete, highLevelClient()::deleteAsync);, +            assertEquals("index", deleteResponse.getIndex());, +            assertEquals("type", deleteResponse.getType());, +            assertEquals(docId, deleteResponse.getId());, +            assertEquals(DocWriteResponse.Result.NOT_FOUND, deleteResponse.getResult());, +        }, +        {, +++ b/core/src/main/java/org/elasticsearch/Version.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import java.util.concurrent.TimeUnit;, +            // Testing non existing document, +            String docId = "does_not_exist";, +            DeleteRequest deleteRequest = new DeleteRequest("index", "type", docId);, +            DeleteResponse deleteResponse = execute(deleteRequest, highLevelClient()::delete, highLevelClient()::deleteAsync);, +            assertEquals("index", deleteResponse.getIndex());, +            assertEquals("type", deleteResponse.getType());, +            assertEquals(docId, deleteResponse.getId());, +            assertEquals(DocWriteResponse.Result.NOT_FOUND, deleteResponse.getResult());, +        }, +        {, +++ b/core/src/main/java/org/elasticsearch/Version.java, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                if (out.contains("${pid} org.elasticsearch.bootstrap.Elasticsearch") == false) {, +                    logger.error("pid file: ${pidFile}"), +                    logger.error("pid: ${pid}"), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import java.util.concurrent.TimeUnit;, +            // Testing non existing document, +            String docId = "does_not_exist";, +            DeleteRequest deleteRequest = new DeleteRequest("index", "type", docId);, +            DeleteResponse deleteResponse = execute(deleteRequest, highLevelClient()::delete, highLevelClient()::deleteAsync);, +            assertEquals("index", deleteResponse.getIndex());, +            assertEquals("type", deleteResponse.getType());, +            assertEquals(docId, deleteResponse.getId());, +            assertEquals(DocWriteResponse.Result.NOT_FOUND, deleteResponse.getResult());, +        }, +        {, +++ b/core/src/main/java/org/elasticsearch/Version.java, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchResponse.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.search.profile.SearchProfileShardResults;, +import java.util.ArrayList;, +import java.util.List;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.throwUnknownField;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.throwUnknownToken;, +, +    private static final ParseField SCROLL_ID = new ParseField("_scroll_id");, +    private static final ParseField TOOK = new ParseField("took");, +    private static final ParseField TIMED_OUT = new ParseField("timed_out");, +    private static final ParseField TERMINATED_EARLY = new ParseField("terminated_early");, +    private static final ParseField NUM_REDUCE_PHASES = new ParseField("num_reduce_phases");, +, +    private SearchResponseSections internalResponse;, +    public SearchResponse(SearchResponseSections internalResponse, String scrollId, int totalShards, int successfulShards,]