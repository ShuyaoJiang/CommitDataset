[+++ b/core/src/main/java/org/elasticsearch/common/network/Cidrs.java, +, +    public static String createCIDR(long ipAddress, int networkMask) {, +        return octetsToCIDR(longToOctets(ipAddress), networkMask);, +    }, +++ b/core/src/main/java/org/elasticsearch/common/network/Cidrs.java, +, +    public static String createCIDR(long ipAddress, int networkMask) {, +        return octetsToCIDR(longToOctets(ipAddress), networkMask);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/InternalRange.java, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSourceType;, +        public ValuesSourceType getValueSourceType() {, +            return ValuesSourceType.NUMERIC;, +        }, +, +        public ValueType getValueType() {, +            return ValueType.NUMERIC;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/common/network/Cidrs.java, +, +    public static String createCIDR(long ipAddress, int networkMask) {, +        return octetsToCIDR(longToOctets(ipAddress), networkMask);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/InternalRange.java, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSourceType;, +        public ValuesSourceType getValueSourceType() {, +            return ValuesSourceType.NUMERIC;, +        }, +, +        public ValueType getValueType() {, +            return ValueType.NUMERIC;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParseFieldMatcher;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSource.Numeric;, +import org.elasticsearch.search.aggregations.support.ValuesSourceType;, +import java.util.Objects;, +    public static final ParseField RANGES_FIELD = new ParseField("ranges");, +    public static final ParseField KEYED_FIELD = new ParseField("keyed");, +    public static class Range implements Writeable<Range>, ToXContent {, +        public static final Range PROTOTYPE = new Range(null, -1, null, -1, null);, +        public static final ParseField KEY_FIELD = new ParseField("key");, +        public static final ParseField FROM_FIELD = new ParseField("from");, +        public static final ParseField TO_FIELD = new ParseField("to");, +, +        protected String key;, +        protected double from = Double.NEGATIVE_INFINITY;, +        protected String fromAsStr;, +        protected double to = Double.POSITIVE_INFINITY;, +        protected String toAsStr;, +, +        public Range(String key, double from, double to) {, +            this(key, from, null, to, null);, +        }, +, +        public Range(String key, String from, String to) {, +            this(key, Double.NEGATIVE_INFINITY, from, Double.POSITIVE_INFINITY, to);, +        }, +, +        protected Range(String key, double from, String fromAsStr, double to, String toAsStr) {, +, +        @Override, +        public Range readFrom(StreamInput in) throws IOException {, +            String key = in.readOptionalString();, +            String fromAsStr = in.readOptionalString();, +            String toAsStr = in.readOptionalString();, +            double from = in.readDouble();, +            double to = in.readDouble();, +            return new Range(key, from, fromAsStr, to, toAsStr);, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeOptionalString(key);, +            out.writeOptionalString(fromAsStr);, +            out.writeOptionalString(toAsStr);, +            out.writeDouble(from);, +            out.writeDouble(to);, +        }, +, +        public Range fromXContent(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException {, +, +            XContentParser.Token token;, +            String currentFieldName = null;, +            double from = Double.NEGATIVE_INFINITY;, +            String fromAsStr = null;, +            double to = Double.POSITIVE_INFINITY;]