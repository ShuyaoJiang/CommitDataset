[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/GlobalOrdinalsSignificantTermsAggregator.java, +import org.elasticsearch.search.aggregations.bucket.terms.support.IncludeExclude;, +                                                    IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent,, +        super(name, factories, valuesSource, estimatedBucketCount, maxOrd, null, requiredSize, shardSize, minDocCount, includeExclude, aggregationContext, parent);, +        for (long globalTermOrd = Ordinals.MIN_ORDINAL; globalTermOrd < globalOrdinals.getMaxOrd(); ++globalTermOrd) {, +            final long bucketOrd = getBucketOrd(globalTermOrd);, +            copy(globalValues.getValueByOrd(globalTermOrd), spare.termBytes);, +        public WithHash(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, long estimatedBucketCount, int requiredSize, int shardSize, long minDocCount, long shardMinDocCount, IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory) {, +            super(name, factories, valuesSource, estimatedBucketCount, estimatedBucketCount, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggFactory);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/GlobalOrdinalsSignificantTermsAggregator.java, +import org.elasticsearch.search.aggregations.bucket.terms.support.IncludeExclude;, +                                                    IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent,, +        super(name, factories, valuesSource, estimatedBucketCount, maxOrd, null, requiredSize, shardSize, minDocCount, includeExclude, aggregationContext, parent);, +        for (long globalTermOrd = Ordinals.MIN_ORDINAL; globalTermOrd < globalOrdinals.getMaxOrd(); ++globalTermOrd) {, +            final long bucketOrd = getBucketOrd(globalTermOrd);, +            copy(globalValues.getValueByOrd(globalTermOrd), spare.termBytes);, +        public WithHash(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, long estimatedBucketCount, int requiredSize, int shardSize, long minDocCount, long shardMinDocCount, IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory) {, +            super(name, factories, valuesSource, estimatedBucketCount, estimatedBucketCount, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggFactory);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsAggregatorFactory.java, +                return new GlobalOrdinalsSignificantTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, estimatedBucketCount, maxOrd, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggregatorFactory);, +                return new GlobalOrdinalsSignificantTermsAggregator.WithHash(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, estimatedBucketCount, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggregatorFactory);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/GlobalOrdinalsSignificantTermsAggregator.java, +import org.elasticsearch.search.aggregations.bucket.terms.support.IncludeExclude;, +                                                    IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent,, +        super(name, factories, valuesSource, estimatedBucketCount, maxOrd, null, requiredSize, shardSize, minDocCount, includeExclude, aggregationContext, parent);, +        for (long globalTermOrd = Ordinals.MIN_ORDINAL; globalTermOrd < globalOrdinals.getMaxOrd(); ++globalTermOrd) {, +            final long bucketOrd = getBucketOrd(globalTermOrd);, +            copy(globalValues.getValueByOrd(globalTermOrd), spare.termBytes);, +        public WithHash(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, long estimatedBucketCount, int requiredSize, int shardSize, long minDocCount, long shardMinDocCount, IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory) {, +            super(name, factories, valuesSource, estimatedBucketCount, estimatedBucketCount, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggFactory);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsAggregatorFactory.java, +                return new GlobalOrdinalsSignificantTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, estimatedBucketCount, maxOrd, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggregatorFactory);, +                return new GlobalOrdinalsSignificantTermsAggregator.WithHash(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, estimatedBucketCount, requiredSize, shardSize, minDocCount, shardMinDocCount, includeExclude, aggregationContext, parent, termsAggregatorFactory);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsBuilder.java, +    private String includePattern;, +    private int includeFlags;, +    private String excludePattern;, +    private int excludeFlags;, +    /**, +     * Define a regular expression that will determine what terms should be aggregated. The regular expression is based, +     * on the {@link java.util.regex.Pattern} class., +     *, +     * @see #include(String, int), +     */, +    public SignificantTermsBuilder include(String regex) {, +        return include(regex, 0);, +    }, +, +    /**, +     * Define a regular expression that will determine what terms should be aggregated. The regular expression is based, +     * on the {@link java.util.regex.Pattern} class., +     *, +     * @see java.util.regex.Pattern#compile(String, int), +     */, +    public SignificantTermsBuilder include(String regex, int flags) {, +        this.includePattern = regex;, +        this.includeFlags = flags;, +        return this;, +    }, +, +    /**, +     * Define a regular expression that will filter out terms that should be excluded from the aggregation. The regular, +     * expression is based on the {@link java.util.regex.Pattern} class., +     *, +     * @see #exclude(String, int), +     */, +    public SignificantTermsBuilder exclude(String regex) {, +        return exclude(regex, 0);, +    }, +, +    /**, +     * Define a regular expression that will filter out terms that should be excluded from the aggregation. The regular, +     * expression is based on the {@link java.util.regex.Pattern} class., +     *, +     * @see java.util.regex.Pattern#compile(String, int), +     */, +    public SignificantTermsBuilder exclude(String regex, int flags) {, +        this.excludePattern = regex;, +        this.excludeFlags = flags;, +        return this;, +    }, +, +        if (includePattern != null) {, +            if (includeFlags == 0) {, +                builder.field("include", includePattern);, +            } else {, +                builder.startObject("include"), +                        .field("pattern", includePattern), +                        .field("flags", includeFlags), +                        .endObject();, +            }, +        }, +        if (excludePattern != null) {, +            if (excludeFlags == 0) {, +                builder.field("exclude", excludePattern);, +            } else {, +                builder.startObject("exclude"), +                        .field("pattern", excludePattern), +                        .field("flags", excludeFlags), +                        .endObject();]