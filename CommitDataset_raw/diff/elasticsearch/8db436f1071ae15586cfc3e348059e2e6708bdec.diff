[+++ b/pom.xml, +          <dependency>, +            <groupId>org.apache.lucene</groupId>, +            <artifactId>lucene-spatial</artifactId>, +            <version>${lucene.version}</version>, +            <scope>compile</scope>, +        </dependency>, +++ b/pom.xml, +          <dependency>, +            <groupId>org.apache.lucene</groupId>, +            <artifactId>lucene-spatial</artifactId>, +            <version>${lucene.version}</version>, +            <scope>compile</scope>, +        </dependency>, +++ /dev/null, +++ b/pom.xml, +          <dependency>, +            <groupId>org.apache.lucene</groupId>, +            <artifactId>lucene-spatial</artifactId>, +            <version>${lucene.version}</version>, +            <scope>compile</scope>, +        </dependency>, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/lucene/spatial/XTermQueryPrefixTreeStategy.java, +package org.elasticsearch.common.lucene.spatial;, +, +import java.util.List;, +, +import org.apache.lucene.queries.TermsFilter;, +import org.apache.lucene.search.BooleanClause;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.MatchAllDocsQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.TermQuery;, +import org.apache.lucene.spatial.SpatialStrategy;, +import org.apache.lucene.spatial.prefix.PrefixTreeStrategy;, +import org.apache.lucene.spatial.prefix.tree.Node;, +import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;, +import org.apache.lucene.spatial.query.SpatialArgs;, +import org.apache.lucene.spatial.query.SpatialOperation;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.geo.GeoShapeConstants;, +import org.elasticsearch.common.geo.ShapeBuilder;, +import org.elasticsearch.common.lucene.search.TermFilter;, +import org.elasticsearch.common.lucene.search.XBooleanFilter;, +import org.elasticsearch.index.mapper.FieldMapper;, +import org.elasticsearch.index.mapper.FieldMapper.Names;, +, +import com.spatial4j.core.context.SpatialContext;, +import com.spatial4j.core.shape.Shape;, +import com.spatial4j.core.shape.jts.JtsGeometry;, +import com.vividsolutions.jts.geom.Geometry;, +import com.vividsolutions.jts.operation.buffer.BufferOp;, +import com.vividsolutions.jts.operation.buffer.BufferParameters;, +, +/**, + * Implementation of {@link SpatialStrategy} that uses TermQuerys / TermFilters, + * to query and filter for Shapes related to other Shapes., + */, +public final class XTermQueryPrefixTreeStategy extends PrefixTreeStrategy {, +, +    private static final double WITHIN_BUFFER_DISTANCE = 0.5;, +    private static final BufferParameters BUFFER_PARAMETERS = new BufferParameters(3, BufferParameters.CAP_SQUARE);, +    private final Names fieldName;, +, +    /**, +     * Creates a new XTermQueryPrefixTreeStategy, +     *, +     * @param prefixTree       SpatialPrefixTree that will be used to represent Shapes, +     * @param fieldName        Name of the field the Strategy applies to, +     */, +    public XTermQueryPrefixTreeStategy(SpatialPrefixTree prefixTree, FieldMapper.Names fieldName) {, +        super(prefixTree, fieldName.indexName());, +        this.fieldName = fieldName;, +    }, +    , +    private static double resolveDistErr(Shape shape, SpatialContext ctx, double distErrPct) {, +      return SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);, +    }, +, +    public Filter createIntersectsFilter(Shape shape) {, +        int detailLevel = getGrid().getLevelForDistance(resolveDistErr(shape, ctx, getDistErrPct()));, +        List<Node> nodes = getGrid().getNodes(shape, detailLevel, false);, +, +        BytesRef[] nodeTerms = new BytesRef[nodes.size()];, +        for (int i = 0; i < nodes.size(); i++) {, +            nodeTerms[i] = new BytesRef(nodes.get(i).getTokenString());, +        }, +        return new TermsFilter(fieldName.indexName(), nodeTerms);, +    }, +, +    public Query createIntersectsQuery(Shape shape) {, +        int detailLevel = getGrid().getLevelForDistance(resolveDistErr(shape, ctx, getDistErrPct()));, +        List<Node> nodes = getGrid().getNodes(shape, detailLevel, false);, +, +        BooleanQuery query = new BooleanQuery();, +        for (Node node : nodes) {, +            query.add(new TermQuery(fieldName.createIndexNameTerm(node.getTokenString())),]