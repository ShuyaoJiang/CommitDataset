[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AbstractUnfollowIndexStep.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                                    ClusterStateObserver observer, Listener listener) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AbstractUnfollowIndexStep.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                                    ClusterStateObserver observer, Listener listener) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AsyncActionStep.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public abstract void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                                       ClusterStateObserver observer, Listener listener);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AbstractUnfollowIndexStep.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                                    ClusterStateObserver observer, Listener listener) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AsyncActionStep.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public abstract void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                                       ClusterStateObserver observer, Listener listener);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/AsyncRetryDuringSnapshotActionStep.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +, +package org.elasticsearch.xpack.core.indexlifecycle;, +, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateObserver;, +import org.elasticsearch.cluster.SnapshotsInProgress;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.repositories.IndexId;, +import org.elasticsearch.snapshots.SnapshotInProgressException;, +, +import java.util.function.Consumer;, +, +/**, + * This is an abstract AsyncActionStep that wraps the performed action listener, checking to see, + * if the action fails due to a snapshot being in progress. If a snapshot is in progress, it, + * registers an observer and waits to try again when a snapshot is no longer running., + */, +public abstract class AsyncRetryDuringSnapshotActionStep extends AsyncActionStep {, +    private final Logger logger = LogManager.getLogger(AsyncRetryDuringSnapshotActionStep.class);, +, +    public AsyncRetryDuringSnapshotActionStep(StepKey key, StepKey nextStepKey, Client client) {, +        super(key, nextStepKey, client);, +    }, +, +    @Override, +    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,, +                              ClusterStateObserver observer, Listener listener) {, +        // Wrap the original listener to handle exceptions caused by ongoing snapshots, +        SnapshotExceptionListener snapshotExceptionListener = new SnapshotExceptionListener(indexMetaData.getIndex(), listener, observer);, +        performDuringNoSnapshot(indexMetaData, currentClusterState, snapshotExceptionListener);, +    }, +, +    /**, +     * Method to be performed during which no snapshots for the index are already underway., +     */, +    abstract void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener);, +, +    /**, +     * SnapshotExceptionListener is an injected listener wrapper that checks to see if a particular, +     * action failed due to a {@code SnapshotInProgressException}. If it did, then it registers a, +     * ClusterStateObserver listener waiting for the next time the snapshot is not running,, +     * re-running the step's {@link #performAction(IndexMetaData, ClusterState, ClusterStateObserver, Listener)}, +     * method when the snapshot is no longer running., +     */, +    class SnapshotExceptionListener implements AsyncActionStep.Listener {, +        private final Index index;, +        private final Listener originalListener;, +        private final ClusterStateObserver observer;, +, +        SnapshotExceptionListener(Index index, Listener originalListener, ClusterStateObserver observer) {, +            this.index = index;, +            this.originalListener = originalListener;, +            this.observer = observer;, +        }, +, +        @Override, +        public void onResponse(boolean complete) {, +            originalListener.onResponse(complete);, +        }, +, +        @Override, +        public void onFailure(Exception e) {, +            if (e instanceof SnapshotInProgressException) {, +                try {, +                    logger.debug("[{}] attempted to run ILM step but a snapshot is in progress, step will retry at a later time",, +                        index.getName());, +                    observer.waitForNextChange(, +                        new NoSnapshotRunningListener(observer, index.getName(), state -> {, +                            IndexMetaData idxMeta = state.metaData().index(index);]