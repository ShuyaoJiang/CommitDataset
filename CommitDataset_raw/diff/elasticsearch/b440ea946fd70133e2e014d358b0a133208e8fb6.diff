[+++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsAction;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsResponse;, +import org.elasticsearch.common.Randomness;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.transport.ConnectTransportException;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportResponseHandler;, +import java.net.InetSocketAddress;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +    //TODO what should the setting name be?, +    public static final Setting<Settings> REMOTE_CLUSTERS_SEEDS = Setting.groupSetting("action.search.remote.",, +            SearchTransportService::validateRemoteClustersSeeds,, +            Setting.Property.NodeScope,, +            Setting.Property.Dynamic);, +    private final TransportService transportService;, +    private volatile Map<String, List<DiscoveryNode>> remoteClustersSeeds;, +, +    public SearchTransportService(Settings settings, ClusterSettings clusterSettings, TransportService transportService) {, +        setRemoteClustersSeeds(REMOTE_CLUSTERS_SEEDS.get(settings));, +        clusterSettings.addSettingsUpdateConsumer(REMOTE_CLUSTERS_SEEDS, this::setRemoteClustersSeeds,, +                SearchTransportService::validateRemoteClustersSeeds);, +    }, +, +    private static void validateRemoteClustersSeeds(Settings settings) {, +        //TODO add a static whitelist like in reindex from remote, +        for (String clusterName : settings.names()) {, +            String[] remoteHosts = settings.getAsArray(clusterName);, +            if (remoteHosts.length == 0) {, +                throw new IllegalArgumentException("no hosts set for remote cluster [" + clusterName + "], at least one host is required");, +            }, +            for (String remoteHost : remoteHosts) {, +                String[] strings = remoteHost.split(":");, +                if (strings.length != 2) {, +                    throw new IllegalArgumentException("remote hosts need to be configured as [host:port], found [" + remoteHost + "] " +, +                            "instead for remote cluster [" + clusterName + "]");, +                }, +                try {, +                    Integer.valueOf(strings[1]);, +                } catch(NumberFormatException e) {, +                    throw new IllegalArgumentException("port must be a number, found [" + strings[1] + "] instead for remote cluster [" +, +                            clusterName + "]");, +                }, +            }, +        }, +    }, +, +    private void setRemoteClustersSeeds(Settings settings) {, +        Map<String, List<DiscoveryNode>> remoteClustersNodes = new HashMap<>();, +        for (String clusterName : settings.names()) {, +            String[] remoteHosts = settings.getAsArray(clusterName);, +            for (String remoteHost : remoteHosts) {, +                String[] strings = remoteHost.split(":");, +                String host = strings[0];, +                int port = Integer.valueOf(strings[1]);, +                DiscoveryNode node = new DiscoveryNode(clusterName + "#" + remoteHost,, +                        new TransportAddress(new InetSocketAddress(host, port)), Version.CURRENT.minimumCompatibilityVersion());, +                //don't connect yet as that would require the remote node to be up and would fail the local node startup otherwise, +                List<DiscoveryNode> nodes = remoteClustersNodes.get(clusterName);, +                if (nodes == null) {, +                    nodes = new ArrayList<>();, +                    remoteClustersNodes.put(clusterName, nodes);, +                }, +                nodes.add(node);, +            }, +        }, +        remoteClustersSeeds = remoteClustersNodes;, +    }, +, +    private DiscoveryNode connectToRemoteCluster(String clusterName) {, +        List<DiscoveryNode> nodes = remoteClustersSeeds.get(clusterName);, +        if (nodes == null) {, +            throw new IllegalArgumentException("no remote cluster configured with name [" + clusterName + "]");, +        }, +        DiscoveryNode node = nodes.get(Randomness.get().nextInt(nodes.size()));, +        //TODO we just take a random host for now, implement fallback in case of connect failure, +        try {, +            //TODO we should call liveness api and get back an updated discovery node. that would have the updated version, +            // and would make the search shards call more future-proof. Also validating the cluster name may be a thing., +            connectToRemoteNode(node);, +        } catch(ConnectTransportException e) {, +            throw new ConnectTransportException(node, "unable to connect to remote cluster [" + clusterName + "]", e);, +        }, +        return node;, +    }, +, +    void connectToRemoteNode(DiscoveryNode remoteNode) {, +        //TODO should the list of seeds get updated based on nodes that we get back from the remote cluster through search_shards?, +        transportService.connectToNode(remoteNode);, +        //TODO is it ok to connect and leave the node connected? It will be pinged from now on?]