[+++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                        if (ackedUpdateTask.ackTimeout() == null || ackedUpdateTask.ackTimeout().millis() == 0) {, +                            ackedUpdateTask.onAckTimeout();, +                        } else {, +                                ackListener = new AckCountDownListener(ackedUpdateTask, newClusterState, threadPool);, +                    }, +        private final ClusterState clusterState;, +        AckCountDownListener(AckedClusterStateUpdateTask ackedUpdateTask, ClusterState clusterState, ThreadPool threadPool) {, +            this.clusterState = clusterState;, +            for (DiscoveryNode node : clusterState.nodes()) {, +            //we always wait for at least 1 node (the master), +            countDown = Math.max(1, countDown);, +            logger.trace("expecting {} acknowledgements for cluster_state update (version: {})", countDown, clusterState.version());, +                //we always wait for the master ack anyway, +                if (!node.equals(clusterState.nodes().masterNode())) {, +            }, +                logger.trace("ack received from node [{}], cluster_state update (version: {})", node, clusterState.version());, +                logger.debug("ack received from node [{}], cluster_state update (version: {})", t, node, clusterState.version());, +                logger.trace("all expected nodes acknowledged cluster_state update (version: {})", clusterState.version());, +                logger.trace("timeout waiting for acknowledgement for cluster_state update (version: {})", clusterState.version());, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                        if (ackedUpdateTask.ackTimeout() == null || ackedUpdateTask.ackTimeout().millis() == 0) {, +                            ackedUpdateTask.onAckTimeout();, +                        } else {, +                                ackListener = new AckCountDownListener(ackedUpdateTask, newClusterState, threadPool);, +                    }, +        private final ClusterState clusterState;, +        AckCountDownListener(AckedClusterStateUpdateTask ackedUpdateTask, ClusterState clusterState, ThreadPool threadPool) {, +            this.clusterState = clusterState;, +            for (DiscoveryNode node : clusterState.nodes()) {, +            //we always wait for at least 1 node (the master), +            countDown = Math.max(1, countDown);, +            logger.trace("expecting {} acknowledgements for cluster_state update (version: {})", countDown, clusterState.version());, +                //we always wait for the master ack anyway, +                if (!node.equals(clusterState.nodes().masterNode())) {, +            }, +                logger.trace("ack received from node [{}], cluster_state update (version: {})", node, clusterState.version());, +                logger.debug("ack received from node [{}], cluster_state update (version: {})", t, node, clusterState.version());, +                logger.trace("all expected nodes acknowledged cluster_state update (version: {})", clusterState.version());, +                logger.trace("timeout waiting for acknowledgement for cluster_state update (version: {})", clusterState.version());, +++ b/src/test/java/org/elasticsearch/cluster/ClusterServiceTests.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.Nullable;, +    public void testAckedUpdateTask() throws Exception {, +        Settings settings = settingsBuilder(), +                .put("discovery.type", "zen"), +                .put("discovery.zen.minimum_master_nodes", 1), +                .put("discovery.zen.ping_timeout", "200ms"), +                .put("discovery.initial_state_timeout", "500ms"), +                .build();, +        cluster().startNode(settings);, +        ClusterService clusterService = cluster().getInstance(ClusterService.class);, +, +        final AtomicBoolean allNodesAcked = new AtomicBoolean(false);, +        final AtomicBoolean ackTimeout = new AtomicBoolean(false);, +        final AtomicBoolean onFailure = new AtomicBoolean(false);, +        final AtomicBoolean executed = new AtomicBoolean(false);, +        final AtomicBoolean processed = new AtomicBoolean(false);, +        final CountDownLatch latch = new CountDownLatch(1);, +        clusterService.submitStateUpdateTask("test", new AckedClusterStateUpdateTask() {, +            @Override, +            public boolean mustAck(DiscoveryNode discoveryNode) {, +                return true;, +            }, +, +            @Override, +            public void onAllNodesAcked(@Nullable Throwable t) {, +                allNodesAcked.set(true);, +            }, +, +            @Override, +            public void onAckTimeout() {, +                ackTimeout.set(true);, +            }, +, +            @Override, +            public TimeValue ackTimeout() {, +                return TimeValue.timeValueSeconds(10);, +            }, +, +            @Override, +            public TimeValue timeout() {, +                return TimeValue.timeValueSeconds(10);, +            }, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                processed.set(true);, +                latch.countDown();, +            }, +, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                executed.set(true);, +                return ClusterState.newClusterStateBuilder().state(currentState).build();, +            }, +, +            @Override, +            public void onFailure(String source, Throwable t) {, +                onFailure.set(true);]