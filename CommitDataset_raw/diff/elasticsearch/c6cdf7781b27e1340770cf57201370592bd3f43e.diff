[+++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperService;, +            Mapping update = index.parsedDoc().dynamicMappingsUpdate();, +            if (update != null) {, +                final String indexName = indexService.index().name();, +                if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                    // With rivers, we have a chicken and egg problem if indexing, +                    // the _meta document triggers a mapping update. Because we would, +                    // like to validate the mapping update first, but on the other, +                    // hand putting the mapping would start the river, which expects, +                    // to find a _meta document, +                    // So we have no choice but to index first and send mappings afterwards, +                    MapperService mapperService = indexService.mapperService();, +                    mapperService.merge(indexRequest.type(), new CompressedString(update.toBytes()), true);, +                    mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, indexRequest.type(), update);, +                } else {, +                    mappingUpdatedAction.updateMappingOnMasterSynchronously(indexName, indexRequest.type(), update);, +                    indexShard.index(index);, +                }, +            } else {, +                indexShard.index(index);, +            }, +            Mapping update = create.parsedDoc().dynamicMappingsUpdate();, +            if (update != null) {, +                final String indexName = indexService.index().name();, +                if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                    // With rivers, we have a chicken and egg problem if indexing, +                    // the _meta document triggers a mapping update. Because we would, +                    // like to validate the mapping update first, but on the other, +                    // hand putting the mapping would start the river, which expects, +                    // to find a _meta document, +                    // So we have no choice but to index first and send mappings afterwards, +                    MapperService mapperService = indexService.mapperService();, +                    mapperService.merge(indexRequest.type(), new CompressedString(update.toBytes()), true);, +                    mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, indexRequest.type(), update);, +                } else {, +                    mappingUpdatedAction.updateMappingOnMasterSynchronously(indexName, indexRequest.type(), update);, +                    indexShard.create(create);, +                }, +            } else {, +                indexShard.create(create);, +            }, +    protected void shardOperationOnReplica(ReplicaOperationRequest shardRequest) throws Exception {, +        IndexService indexService = indicesService.indexServiceSafe(shardRequest.shardId.getIndex());, +        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId.id());, +                        if (index.parsedDoc().dynamicMappingsUpdate() != null) {, +                            if (indexService.index().name().equals(RiverIndexName.Conf.indexName(settings))) {, +                                // mappings updates on the _river are not validated synchronously so we can't, +                                // assume they are here when indexing on a replica, +                                indexService.mapperService().merge(indexRequest.type(), new CompressedString(index.parsedDoc().dynamicMappingsUpdate().toBytes()), true);, +                            } else {, +                                throw new ElasticsearchIllegalStateException("Index operations on replicas should not trigger dynamic mappings updates: [" + index.parsedDoc().dynamicMappingsUpdate() + "]");, +                            }, +                        }, +                        if (create.parsedDoc().dynamicMappingsUpdate() != null) {, +                            if (indexService.index().name().equals(RiverIndexName.Conf.indexName(settings))) {, +                                // mappings updates on the _river are not validated synchronously so we can't, +                                // assume they are here when indexing on a replica, +                                indexService.mapperService().merge(indexRequest.type(), new CompressedString(create.parsedDoc().dynamicMappingsUpdate().toBytes()), true);, +                            } else {, +                                throw new ElasticsearchIllegalStateException("Index operations on replicas should not trigger dynamic mappings updates: [" + create.parsedDoc().dynamicMappingsUpdate() + "]");, +                            }, +                        }, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperService;, +            Mapping update = index.parsedDoc().dynamicMappingsUpdate();, +            if (update != null) {, +                final String indexName = indexService.index().name();, +                if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                    // With rivers, we have a chicken and egg problem if indexing, +                    // the _meta document triggers a mapping update. Because we would, +                    // like to validate the mapping update first, but on the other, +                    // hand putting the mapping would start the river, which expects, +                    // to find a _meta document, +                    // So we have no choice but to index first and send mappings afterwards, +                    MapperService mapperService = indexService.mapperService();, +                    mapperService.merge(indexRequest.type(), new CompressedString(update.toBytes()), true);, +                    mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, indexRequest.type(), update);, +                } else {, +                    mappingUpdatedAction.updateMappingOnMasterSynchronously(indexName, indexRequest.type(), update);, +                    indexShard.index(index);, +                }, +            } else {, +                indexShard.index(index);, +            }, +            Mapping update = create.parsedDoc().dynamicMappingsUpdate();, +            if (update != null) {, +                final String indexName = indexService.index().name();, +                if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                    // With rivers, we have a chicken and egg problem if indexing, +                    // the _meta document triggers a mapping update. Because we would, +                    // like to validate the mapping update first, but on the other, +                    // hand putting the mapping would start the river, which expects, +                    // to find a _meta document, +                    // So we have no choice but to index first and send mappings afterwards, +                    MapperService mapperService = indexService.mapperService();, +                    mapperService.merge(indexRequest.type(), new CompressedString(update.toBytes()), true);, +                    mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, indexRequest.type(), update);, +                } else {, +                    mappingUpdatedAction.updateMappingOnMasterSynchronously(indexName, indexRequest.type(), update);]