[+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +++ b/src/main/java/org/elasticsearch/common/io/FileSystemUtils.java, +    @Deprecated // this is only a transition API, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +++ b/src/main/java/org/elasticsearch/common/io/FileSystemUtils.java, +    @Deprecated // this is only a transition API, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import com.google.common.collect.ImmutableSet;, +import org.apache.lucene.store.LockObtainFailedException;, +import org.elasticsearch.common.Nullable;, +import java.io.Closeable;, +import java.nio.file.*;, +import java.util.*;, +import java.util.concurrent.*;, + * A component that holds all data paths for a single node., +public class NodeEnvironment extends AbstractComponent implements Closeable{, +    /* ${data.paths}/nodes/{node.id} */, +    private final Path[] nodePaths;, +    /* ${data.paths}/nodes/{node.id}/indices */, +    private final Path[] nodeIndicesPaths;, +    private final Map<ShardId, InternalShardLock> shardLocks = new HashMap<>();, +    public NodeEnvironment(Settings settings, Environment environment) throws IOException {, +            nodePaths = null;, +            nodeIndicesPaths = null;, +        final Path[] nodePaths = new Path[environment.dataWithClusterFiles().length];, +        final Lock[] locks = new Lock[environment.dataWithClusterFiles().length];, +                Path dir = environment.dataWithClusterFiles()[dirIndex].toPath().resolve(Paths.get("nodes", Integer.toString(possibleLockId)));, +                if (Files.exists(dir) == false) {, +                    Files.createDirectories(dir);, +                logger.trace("obtaining node lock on {} ...", dir.toAbsolutePath());, +                    NativeFSLockFactory lockFactory = new NativeFSLockFactory(dir);, +                        nodePaths[dirIndex] = dir;, +                        logger.trace("failed to obtain node lock on {}", dir.toAbsolutePath());, +                    logger.trace("failed to obtain node lock on {}", e, dir.toAbsolutePath());, +                    lastException = new IOException("failed to obtain lock on " + dir.toAbsolutePath(), e);, +        this.nodePaths = nodePaths;, +, +, +            logger.debug("using node location [{}], local_node_id [{}]", nodePaths, localNodeId);, +            for (Path file : nodePaths) {, +                sb.append(" -> ").append(file.toAbsolutePath()).append(", free_space [").append(new ByteSizeValue(Files.getFileStore(file).getUnallocatedSpace())).append("], usable_space [").append(new ByteSizeValue(Files.getFileStore(file).getUsableSpace())).append("]\n");, +        this.nodeIndicesPaths = new Path[nodePaths.length];, +        for (int i = 0; i < nodePaths.length; i++) {, +            nodeIndicesPaths[i] = nodePaths[i].resolve("indices");, +        }, +    }, +, +, +, +    /**, +     * Deletes a shard data directory iff the shards locks were successfully acquired., +     *, +     * @param shardId the id of the shard to delete to delete, +     * @throws IOException if an IOException occurs, +     */, +    public void deleteShardDirectorySafe(ShardId shardId) throws IOException {, +        final Path[] paths = shardPaths(shardId);, +        try (Closeable lock = shardLock(shardId)) {, +            IOUtils.rm(paths);, +        }, +    }, +, +    /**, +     * Deletes an indexes data directory recursively iff all of the indexes, +     * shards locks were successfully acquired. If any of the indexes shard directories can't be locked, +     * non of the shards will be deleted, +     *, +     * @param index the index to delete, +     * @throws Exception if any of the shards data directories can't be locked or deleted, +     */, +    public void deleteIndexDirectorySafe(Index index) throws IOException {, +        final List<ShardLock> locks = lockAllForIndex(index);, +        try {, +            final Path[] indexPaths = new Path[nodeIndicesPaths.length];, +            for (int i = 0; i < indexPaths.length; i++) {, +                indexPaths[i] = nodeIndicesPaths[i].resolve(index.name());, +            }, +            IOUtils.rm(indexPaths);, +        } finally {, +            IOUtils.closeWhileHandlingException(locks);, +        }, +    }, +, +, +, +    /**, +     * Tries to lock all local shards for the given index. If any of the shard locks can't be acquired, +     * an {@link LockObtainFailedException} is thrown and all previously acquired locks are released., +     *, +     * @param index the index to lock shards for, +     * @return the {@link ShardLock} instances for this index., +     * @throws IOException if an IOException occurs., +     */, +    public List<ShardLock> lockAllForIndex(Index index) throws IOException {, +        Set<ShardId> allShardIds = findAllShardIds(index);, +        List<ShardLock> allLocks = new ArrayList<>();, +        boolean success = false;, +        try {, +            for (ShardId shardId : allShardIds) {]