[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregations.java, +import java.util.Objects;, +    @Override, +    public boolean equals(Object obj) {, +        if (obj == null || getClass() != obj.getClass()) {, +            return false;, +        }, +        return aggregations.equals(((InternalAggregations) obj).aggregations);, +    }, +, +    @Override, +    public int hashCode() {, +        return Objects.hash(getClass(), aggregations);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregations.java, +import java.util.Objects;, +    @Override, +    public boolean equals(Object obj) {, +        if (obj == null || getClass() != obj.getClass()) {, +            return false;, +        }, +        return aggregations.equals(((InternalAggregations) obj).aggregations);, +    }, +, +    @Override, +    public int hashCode() {, +        return Objects.hash(getClass(), aggregations);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +import java.util.Objects;, +        public boolean equals(Object obj) {, +            if (obj == null || obj.getClass() != Bucket.class) {, +                return false;, +            }, +            Bucket that = (Bucket) obj;, +            // No need to take the keyed and format parameters into account,, +            // they are already stored and tested on the InternalHistogram object, +            return key == that.key, +                    && docCount == that.docCount, +                    && Objects.equals(aggregations, that.aggregations);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(getClass(), key, docCount, aggregations);, +        }, +, +        @Override, +        @Override, +        public boolean equals(Object obj) {, +            if (obj == null || getClass() != obj.getClass()) {, +                return false;, +            }, +            EmptyBucketInfo that = (EmptyBucketInfo) obj;, +            return interval == that.interval, +                    && offset == that.offset, +                    && minBound == that.minBound, +                    && maxBound == that.maxBound, +                    && Objects.equals(subAggregations, that.subAggregations);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(getClass(), interval, offset, minBound, maxBound, subAggregations);, +        }, +    @Override, +    protected boolean doEquals(Object obj) {, +        InternalHistogram that = (InternalHistogram) obj;, +        return Objects.equals(buckets, that.buckets), +                && Objects.equals(emptyBucketInfo, that.emptyBucketInfo), +                && Objects.equals(format, that.format), +                && Objects.equals(keyed, that.keyed), +                && Objects.equals(minDocCount, that.minDocCount), +                && Objects.equals(order, that.order);, +    }, +, +    @Override, +    protected int doHashCode() {, +        return Objects.hash(buckets, emptyBucketInfo, format, keyed, minDocCount, order);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregations.java, +import java.util.Objects;, +    @Override, +    public boolean equals(Object obj) {, +        if (obj == null || getClass() != obj.getClass()) {, +            return false;, +        }, +        return aggregations.equals(((InternalAggregations) obj).aggregations);, +    }, +, +    @Override, +    public int hashCode() {, +        return Objects.hash(getClass(), aggregations);, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +import java.util.Objects;, +        public boolean equals(Object obj) {, +            if (obj == null || obj.getClass() != Bucket.class) {, +                return false;, +            }]