[+++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                currentFieldName = parser.currentName();, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                String mappingType = currentFieldName;, +                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();, +                                builder.putMapping(new MappingMetaData(mappingType, mappingSource));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                currentFieldName = parser.currentName();, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                String mappingType = currentFieldName;, +                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();, +                                builder.putMapping(new MappingMetaData(mappingType, mappingSource));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java, +    // the mapping source should always include the type as top level, +                Map<String, Object> mapping = parser.mapOrderedAndClose();, +        public static IndexTemplateMetaData fromXContentStandalone(XContentParser parser) throws IOException {, +            XContentParser.Token token = parser.nextToken();, +            if (token == null) {, +                throw new IOException("no data");, +            }, +            if (token != XContentParser.Token.START_OBJECT) {, +                throw new IOException("should start object");, +            }, +            token = parser.nextToken();, +            if (token != XContentParser.Token.FIELD_NAME) {, +                throw new IOException("the first field should be the template name");, +            }, +            return fromXContent(parser);, +        }, +, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                currentFieldName = parser.currentName();, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                String mappingType = currentFieldName;, +                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();, +                                builder.putMapping(mappingType, XContentFactory.jsonBuilder().map(mappingSource).string());, +                            }, +                        }, +                    }, +                } else if (token == XContentParser.Token.START_ARRAY) {, +                    if ("mappings".equals(currentFieldName)) {, +                            Map<String, Object> mapping = parser.mapOrdered();, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                currentFieldName = parser.currentName();, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                String mappingType = currentFieldName;, +                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();, +                                builder.putMapping(new MappingMetaData(mappingType, mappingSource));, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java, +    // the mapping source should always include the type as top level, +                Map<String, Object> mapping = parser.mapOrderedAndClose();, +        public static IndexTemplateMetaData fromXContentStandalone(XContentParser parser) throws IOException {, +            XContentParser.Token token = parser.nextToken();, +            if (token == null) {, +                throw new IOException("no data");, +            }, +            if (token != XContentParser.Token.START_OBJECT) {, +                throw new IOException("should start object");, +            }, +            token = parser.nextToken();, +            if (token != XContentParser.Token.FIELD_NAME) {, +                throw new IOException("the first field should be the template name");, +            }, +            return fromXContent(parser);, +        }, +, +                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                            if (token == XContentParser.Token.FIELD_NAME) {, +                                currentFieldName = parser.currentName();, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                String mappingType = currentFieldName;, +                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();, +                                builder.putMapping(mappingType, XContentFactory.jsonBuilder().map(mappingSource).string());, +                            }, +                        }, +                    }, +                } else if (token == XContentParser.Token.START_ARRAY) {, +                    if ("mappings".equals(currentFieldName)) {, +                            Map<String, Object> mapping = parser.mapOrdered();, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import com.google.common.io.Closeables;, +import org.elasticsearch.common.xcontent.XContentParser;, +                    List<IndexTemplateMetaData> templates = findTemplates(request, currentState);, +, +        // see if we have templates defined under config, +        File templatesDir = new File(environment.configFile(), "templates");, +        if (templatesDir.exists() && templatesDir.isDirectory()) {, +            File[] templatesFiles = templatesDir.listFiles();, +            if (templatesFiles != null) {, +                for (File templatesFile : templatesFiles) {, +                    XContentParser parser = null;, +                    try {, +                        byte[] templatesData = Streams.copyToByteArray(templatesFile);]