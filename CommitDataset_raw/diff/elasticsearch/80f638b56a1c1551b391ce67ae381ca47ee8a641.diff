[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +    EsThreadPoolExecutor(String name, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,, +            BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, ThreadContext contextHolder) {, +    EsThreadPoolExecutor(String name, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,, +            BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, XRejectedExecutionHandler handler,, +            ThreadContext contextHolder) {, +        return contextHolder.preserveContext(command);, +        return contextHolder.unwrap(runnable);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +    EsThreadPoolExecutor(String name, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,, +            BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, ThreadContext contextHolder) {, +    EsThreadPoolExecutor(String name, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,, +            BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, XRejectedExecutionHandler handler,, +            ThreadContext contextHolder) {, +        return contextHolder.preserveContext(command);, +        return contextHolder.unwrap(runnable);, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java, +    /**, +     * Saves the current thread context and wraps command in a Runnable that restores that context before running command. If, +     * <code>command</code> has already been passed through this method then it is returned unaltered rather than wrapped twice., +     */, +    public Runnable preserveContext(Runnable command) {, +        if (command instanceof ContextPreservingAbstractRunnable) {, +            return command;, +        }, +        if (command instanceof ContextPreservingRunnable) {, +            return command;, +        }, +        if (command instanceof AbstractRunnable) {, +            return new ContextPreservingAbstractRunnable((AbstractRunnable) command);, +        }, +        return new ContextPreservingRunnable(command);, +    }, +, +    /**, +     * Unwraps a command that was previously wrapped by {@link #preserveContext(Runnable)}., +     */, +    public Runnable unwrap(Runnable command) {, +        if (command instanceof ContextPreservingAbstractRunnable) {, +            return ((ContextPreservingAbstractRunnable) command).unwrap();, +        }, +        if (command instanceof ContextPreservingRunnable) {, +            return ((ContextPreservingRunnable) command).unwrap();, +        }, +        return command;, +    }, +, +, +    /**, +     * Wraps a Runnable to preserve the thread context., +     */, +    class ContextPreservingRunnable implements Runnable {, +        private final Runnable in;, +        private final ThreadContext.StoredContext ctx;, +, +        ContextPreservingRunnable(Runnable in) {, +            ctx = newStoredContext();, +            this.in = in;, +        }, +, +        @Override, +        public void run() {, +            boolean whileRunning = false;, +            try (ThreadContext.StoredContext ingore = stashContext()){, +                ctx.restore();, +                whileRunning = true;, +                in.run();, +                whileRunning = false;, +            } catch (IllegalStateException ex) {, +                if (whileRunning || threadLocal.closed.get() == false) {, +                    throw ex;, +                }, +                // if we hit an ISE here we have been shutting down, +                // this comes from the threadcontext and barfs if, +                // our threadpool has been shutting down, +            }, +        }, +, +        @Override, +        public String toString() {, +            return in.toString();, +        }, +, +        public Runnable unwrap() {, +            return in;, +        }, +    }, +, +    /**, +     * Wraps an AbstractRunnable to preserve the thread context., +     */, +    public class ContextPreservingAbstractRunnable extends AbstractRunnable {, +        private final AbstractRunnable in;, +        private final ThreadContext.StoredContext ctx;, +, +        private ContextPreservingAbstractRunnable(AbstractRunnable in) {, +            ctx = newStoredContext();]