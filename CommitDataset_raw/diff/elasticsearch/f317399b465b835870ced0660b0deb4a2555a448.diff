[+++ b/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +import org.elasticsearch.client.internal.InternalClient;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicLong;, + * (either based on number of actions, based on the size, or time), and to easily control the number of concurrent bulk, +     * A listener for the execution., +     */, +    public static interface Listener {, +, +        /**, +         * Callback before the bulk is executed., +         */, +        void beforeBulk(long executionId, BulkRequest request);, +, +        /**, +         * Callback after a successful execution of bulk request., +         */, +        void afterBulk(long executionId, BulkRequest request, BulkResponse response);, +, +        /**, +         * Callback after a failed execution of bulk request., +         */, +        void afterBulk(long executionId, BulkRequest request, Throwable failure);, +    }, +, +    /**, +        private final Listener listener;, +        private String name;, +        private TimeValue flushInterval = null;, +        public Builder(Client client, Listener listener) {, +         * Sets an optional name to identify this bulk processor., +         */, +        public Builder setName(String name) {, +            this.name = name;, +            return this;, +        }, +, +        /**, +         * Sets a flush interval flushing *any* bulk actions pending if the interval passes. Defaults to not set., +         * <p/>, +         * Note, both {@link #setBulkActions(int)} and {@link #setBulkSize(org.elasticsearch.common.unit.ByteSizeValue)}, +         * can be set to <tt>-1</tt> with the flush interval set allowing for complete async processing of bulk actions., +         */, +        public Builder setFlushInterval(TimeValue flushInterval) {, +            this.flushInterval = flushInterval;, +            return this;, +        }, +, +        /**, +            return new BulkProcessor(client, listener, name, concurrentRequests, bulkActions, bulkSize, flushInterval);, +    public static Builder builder(Client client, Listener listener) {, +    private final Listener listener;, +    private final String name;, +, +    private final int concurrentRequests;, +    private final TimeValue flushInterval;, +    private final ScheduledThreadPoolExecutor scheduler;, +    private final ScheduledFuture scheduledFuture;, +, +    private final AtomicLong executionIdGen = new AtomicLong();, +    private volatile boolean closed = false;, +, +    BulkProcessor(Client client, Listener listener, @Nullable String name, int concurrentRequests, int bulkActions, ByteSizeValue bulkSize, @Nullable TimeValue flushInterval) {, +        this.name = name;, +, +        this.flushInterval = flushInterval;, +        if (flushInterval != null) {, +            this.scheduler = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1, EsExecutors.daemonThreadFactory(((InternalClient) client).settings(), (name != null ? "[" + name + "]" : "") + "bulk_processor"));, +            this.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);, +            this.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);, +            this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(new Flush(), flushInterval.millis(), flushInterval.millis(), TimeUnit.MILLISECONDS);, +        } else {, +            this.scheduler = null;, +            this.scheduledFuture = null;, +        }, +    }, +, +    /**, +     * Closes the processor. If flushing by time is enabled, then its shutdown. Any remaining bulk actions are flushed., +     */, +    public synchronized void close() {, +        if (closed) {, +            return;, +        }, +        closed = true;, +        if (this.scheduledFuture != null) {, +            this.scheduledFuture.cancel(false);, +            this.scheduler.shutdown();, +        }, +        if (bulkRequest.numberOfActions() > 0) {, +            execute();, +        }, +        if (closed) {, +            throw new ElasticSearchIllegalStateException("bulk process already closed");, +        }, +        this.closed = true;, +        execute();]