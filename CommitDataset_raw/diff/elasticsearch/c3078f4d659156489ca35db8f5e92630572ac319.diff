[+++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.elasticsearch.common.util.IndexFolderUpgrader;, +    static String singleDataPathNodeName;, +    static String multiDataPathNodeName;, +        singleDataPathNodeName = null;, +        multiDataPathNodeName = null;, +        singleDataPathNodeName = singleDataPathNode.get();, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName).nodeDataPaths();, +        multiDataPathNodeName = multiDataPathNode.get();, +        nodePaths = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName).nodeDataPaths();, +    void upgradeIndexFolder() throws Exception {, +        final NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnvironment);, +        final NodeEnvironment nodeEnv = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnv);, +    }, +, +        // we explicitly upgrade the index folders as these indices, +        // are imported as dangling indices and not available on, +        // node startup, +        upgradeIndexFolder();, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.elasticsearch.common.util.IndexFolderUpgrader;, +    static String singleDataPathNodeName;, +    static String multiDataPathNodeName;, +        singleDataPathNodeName = null;, +        multiDataPathNodeName = null;, +        singleDataPathNodeName = singleDataPathNode.get();, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName).nodeDataPaths();, +        multiDataPathNodeName = multiDataPathNode.get();, +        nodePaths = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName).nodeDataPaths();, +    void upgradeIndexFolder() throws Exception {, +        final NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnvironment);, +        final NodeEnvironment nodeEnv = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnv);, +    }, +, +        // we explicitly upgrade the index folders as these indices, +        // are imported as dangling indices and not available on, +        // node startup, +        upgradeIndexFolder();, +++ b/core/src/test/java/org/elasticsearch/cluster/DiskUsageTests.java, +        final Index index = new Index("test", "0xdeadbeef");, +        Path test0Path = createTempDir().resolve("indices").resolve(index.getUUID()).resolve("0");, +        Path test1Path = createTempDir().resolve("indices").resolve(index.getUUID()).resolve("1");, +                new ShardStats(test_0, new ShardPath(false, test0Path, test0Path, test_0.shardId()), commonStats0 , null),, +                new ShardStats(test_1, new ShardPath(false, test1Path, test1Path, test_1.shardId()), commonStats1 , null), +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.elasticsearch.common.util.IndexFolderUpgrader;, +    static String singleDataPathNodeName;, +    static String multiDataPathNodeName;, +        singleDataPathNodeName = null;, +        multiDataPathNodeName = null;, +        singleDataPathNodeName = singleDataPathNode.get();, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName).nodeDataPaths();, +        multiDataPathNodeName = multiDataPathNode.get();, +        nodePaths = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName).nodeDataPaths();, +    void upgradeIndexFolder() throws Exception {, +        final NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnvironment);, +        final NodeEnvironment nodeEnv = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnv);, +    }, +, +        // we explicitly upgrade the index folders as these indices, +        // are imported as dangling indices and not available on, +        // node startup, +        upgradeIndexFolder();, +++ b/core/src/test/java/org/elasticsearch/cluster/DiskUsageTests.java, +        final Index index = new Index("test", "0xdeadbeef");, +        Path test0Path = createTempDir().resolve("indices").resolve(index.getUUID()).resolve("0");, +        Path test1Path = createTempDir().resolve("indices").resolve(index.getUUID()).resolve("1");, +                new ShardStats(test_0, new ShardPath(false, test0Path, test0Path, test_0.shardId()), commonStats0 , null),, +                new ShardStats(test_1, new ShardPath(false, test1Path, test1Path, test_1.shardId()), commonStats1 , null), +++ b/core/src/test/java/org/elasticsearch/cluster/allocation/ClusterRerouteIT.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.Index;, +        final Index index = resolveIndex("test");, +        Path[] shardLocation = internalCluster().getInstance(NodeEnvironment.class, node_1).availableShardPaths(new ShardId(index, 0));, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +import org.elasticsearch.common.util.IndexFolderUpgrader;, +    static String singleDataPathNodeName;, +    static String multiDataPathNodeName;, +        singleDataPathNodeName = null;, +        multiDataPathNodeName = null;, +        singleDataPathNodeName = singleDataPathNode.get();, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName).nodeDataPaths();, +        multiDataPathNodeName = multiDataPathNode.get();, +        nodePaths = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName).nodeDataPaths();, +    void upgradeIndexFolder() throws Exception {, +        final NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnvironment);, +        final NodeEnvironment nodeEnv = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNodeName);, +        IndexFolderUpgrader.upgradeIndicesIfNeeded(Settings.EMPTY, nodeEnv);, +    }, +, +        // we explicitly upgrade the index folders as these indices, +        // are imported as dangling indices and not available on]