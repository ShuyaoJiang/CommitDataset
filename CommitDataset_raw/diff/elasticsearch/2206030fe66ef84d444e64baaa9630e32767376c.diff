[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +        String seed = settings.get("discovery.id.seed");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +        String seed = settings.get("discovery.id.seed");, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/GlobalOrdinalsBuilder.java, +import org.elasticsearch.index.fielddata.AtomicOrdinalsFieldData;, +import org.elasticsearch.index.fielddata.IndexOrdinalsFieldData;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +        String seed = settings.get("discovery.id.seed");, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/GlobalOrdinalsBuilder.java, +import org.elasticsearch.index.fielddata.AtomicOrdinalsFieldData;, +import org.elasticsearch.index.fielddata.IndexOrdinalsFieldData;, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexFieldData.java, +            // If the field doesn't exist, then don't bother with loading and adding an empty instance to the field data cache, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +        String seed = settings.get("discovery.id.seed");, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/GlobalOrdinalsBuilder.java, +import org.elasticsearch.index.fielddata.AtomicOrdinalsFieldData;, +import org.elasticsearch.index.fielddata.IndexOrdinalsFieldData;, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexFieldData.java, +            // If the field doesn't exist, then don't bother with loading and adding an empty instance to the field data cache, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexOrdinalsFieldData.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                // We calculate nextDelay based on System.currentTimeMillis() here because we want the next delay from the "now" perspective, +                // rather than the delay from the last time the GatewayAllocator tried to assign/delay the shard., +                // The actual calculation is based on the latter though, to account for shards that should have been allocated, +                // between unassignedShardsAllocatedTimestamp and System.currentTimeMillis(), +                long nextDelayBasedOnUnassignedShardsAllocatedTimestamp = UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp, settings, event.state());, +                // adjust from unassignedShardsAllocatedTimestamp to now, +                long nextDelayMillis = nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);, +                if (nextDelayMillis < 0) {, +                    nextDelayMillis = 0;, +                }, +                TimeValue nextDelay = TimeValue.timeValueMillis(nextDelayMillis);, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +        String seed = settings.get("discovery.id.seed");, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ordinals/GlobalOrdinalsBuilder.java, +import org.elasticsearch.index.fielddata.AtomicOrdinalsFieldData;, +import org.elasticsearch.index.fielddata.IndexOrdinalsFieldData;, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/AbstractIndexFieldData.java]