[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.apache.lucene.util.ArrayUtil;, +import org.apache.lucene.util.CharsRef;, +    // we don't use a CharsRefBuilder since we exactly know the size of the character array up front, +    // this prevents calling grow for every character since we don't need this, +    private final CharsRef spare = new CharsRef();, +        // TODO it would be nice to not call readByte() for every character but we don't know how much to read up-front, +        // we can make the loop much more complicated but that won't buy us much compared to the bounds checks in readByte(), +        if (spare.chars.length < charCount) {, +            // we don't use ArrayUtils.grow since there is no need to copy the array, +            spare.chars = new char[ArrayUtil.oversize(charCount, Character.BYTES)];, +        }, +        spare.length = charCount;, +        final char[] buffer = spare.chars;, +        for (int i = 0; i < charCount; i++) {, +            final int c = readByte() & 0xff;, +                    buffer[i] = (char) c;, +                    buffer[i] = ((char) ((c & 0x1F) << 6 | readByte() & 0x3F));, +                    buffer[i] = ((char) ((c & 0x0F) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F) << 0));, +                default:, +                    new AssertionError("unexpected character: " + c + " hex: " + Integer.toHexString(c));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.apache.lucene.util.ArrayUtil;, +import org.apache.lucene.util.CharsRef;, +    // we don't use a CharsRefBuilder since we exactly know the size of the character array up front, +    // this prevents calling grow for every character since we don't need this, +    private final CharsRef spare = new CharsRef();, +        // TODO it would be nice to not call readByte() for every character but we don't know how much to read up-front, +        // we can make the loop much more complicated but that won't buy us much compared to the bounds checks in readByte(), +        if (spare.chars.length < charCount) {, +            // we don't use ArrayUtils.grow since there is no need to copy the array, +            spare.chars = new char[ArrayUtil.oversize(charCount, Character.BYTES)];, +        }, +        spare.length = charCount;, +        final char[] buffer = spare.chars;, +        for (int i = 0; i < charCount; i++) {, +            final int c = readByte() & 0xff;, +                    buffer[i] = (char) c;, +                    buffer[i] = ((char) ((c & 0x1F) << 6 | readByte() & 0x3F));, +                    buffer[i] = ((char) ((c & 0x0F) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F) << 0));, +                default:, +                    new AssertionError("unexpected character: " + c + " hex: " + Integer.toHexString(c));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import org.apache.lucene.util.ArrayUtil;, +    // we use a small buffer to convert strings to bytes since we want to prevent calling writeByte, +    // for every byte in the string (see #21660 for details)., +    // This buffer will never be the oversized limit of 1024 bytes and will not be shared across streams, +    private byte[] convertStringBuffer = BytesRef.EMPTY_BYTES; // TODO should we reduce it to 0 bytes once the stream is closed?, +, +        final int charCount = str.length();, +        final int bufferSize = Math.min(3 * charCount, 1024); // at most 3 bytes per character is needed here, +        if (convertStringBuffer.length < bufferSize) { // we don't use ArrayUtils.grow since copying the bytes is unnecessary, +            convertStringBuffer = new byte[ArrayUtil.oversize(bufferSize, Byte.BYTES)];, +        }, +        byte[] buffer = convertStringBuffer;, +        int offset = 0;, +            final int c = str.charAt(i);, +                buffer[offset++] = ((byte) c);, +                buffer[offset++] = ((byte) (0xE0 | c >> 12 & 0x0F));, +                buffer[offset++] = ((byte) (0x80 | c >> 6 & 0x3F));, +                buffer[offset++] = ((byte) (0x80 | c >> 0 & 0x3F));, +                buffer[offset++] = ((byte) (0xC0 | c >> 6 & 0x1F));, +                buffer[offset++] = ((byte) (0x80 | c >> 0 & 0x3F));, +            }, +            // make sure any possible char can fit into the buffer in any possible iteration, +            // we need at most 3 bytes so we flush the buffer once we have less than 3 bytes, +            // left before we start another iteration, +            if (offset > buffer.length-3) {, +                writeBytes(buffer, offset);, +                offset = 0;, +        writeBytes(buffer, offset);, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.apache.lucene.util.ArrayUtil;, +import org.apache.lucene.util.CharsRef;, +    // we don't use a CharsRefBuilder since we exactly know the size of the character array up front, +    // this prevents calling grow for every character since we don't need this, +    private final CharsRef spare = new CharsRef();, +        // TODO it would be nice to not call readByte() for every character but we don't know how much to read up-front, +        // we can make the loop much more complicated but that won't buy us much compared to the bounds checks in readByte(), +        if (spare.chars.length < charCount) {, +            // we don't use ArrayUtils.grow since there is no need to copy the array, +            spare.chars = new char[ArrayUtil.oversize(charCount, Character.BYTES)];, +        }, +        spare.length = charCount;, +        final char[] buffer = spare.chars;, +        for (int i = 0; i < charCount; i++) {, +            final int c = readByte() & 0xff;, +                    buffer[i] = (char) c;, +                    buffer[i] = ((char) ((c & 0x1F) << 6 | readByte() & 0x3F));, +                    buffer[i] = ((char) ((c & 0x0F) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F) << 0));, +                default:, +                    new AssertionError("unexpected character: " + c + " hex: " + Integer.toHexString(c));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import org.apache.lucene.util.ArrayUtil;, +    // we use a small buffer to convert strings to bytes since we want to prevent calling writeByte, +    // for every byte in the string (see #21660 for details)., +    // This buffer will never be the oversized limit of 1024 bytes and will not be shared across streams, +    private byte[] convertStringBuffer = BytesRef.EMPTY_BYTES; // TODO should we reduce it to 0 bytes once the stream is closed?, +, +        final int charCount = str.length();]