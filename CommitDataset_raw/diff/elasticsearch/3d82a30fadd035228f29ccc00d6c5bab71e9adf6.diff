[+++ b/docs/reference/index-modules.asciidoc, +    The same as `false`. This option is deprecated and will be completely removed in 7.0., +++ b/docs/reference/index-modules.asciidoc, +    The same as `false`. This option is deprecated and will be completely removed in 7.0., +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if ("fix".equals(checkIndexOnStartup)) {, +            deprecationLogger.deprecated("Setting [index.shard.check_on_startup] is set to deprecated value [fix], ", +                + "which has no effect and will not be accepted in future");, +        }, +        if (Booleans.isTrue(checkIndexOnStartup) || "checksum".equals(checkIndexOnStartup)) {, +            } catch (IOException e) {, +                store.markStoreCorrupted(e);, +                throw e;, +                throw new IOException("index check failure");, +++ b/docs/reference/index-modules.asciidoc, +    The same as `false`. This option is deprecated and will be completely removed in 7.0., +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if ("fix".equals(checkIndexOnStartup)) {, +            deprecationLogger.deprecated("Setting [index.shard.check_on_startup] is set to deprecated value [fix], ", +                + "which has no effect and will not be accepted in future");, +        }, +        if (Booleans.isTrue(checkIndexOnStartup) || "checksum".equals(checkIndexOnStartup)) {, +            } catch (IOException e) {, +                store.markStoreCorrupted(e);, +                throw e;, +                throw new IOException("index check failure");, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +    // public is for test purposes, +    public static final String CORRUPTED = "corrupted_";, +++ b/docs/reference/index-modules.asciidoc, +    The same as `false`. This option is deprecated and will be completely removed in 7.0., +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if ("fix".equals(checkIndexOnStartup)) {, +            deprecationLogger.deprecated("Setting [index.shard.check_on_startup] is set to deprecated value [fix], ", +                + "which has no effect and will not be accepted in future");, +        }, +        if (Booleans.isTrue(checkIndexOnStartup) || "checksum".equals(checkIndexOnStartup)) {, +            } catch (IOException e) {, +                store.markStoreCorrupted(e);, +                throw e;, +                throw new IOException("index check failure");, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +    // public is for test purposes, +    public static final String CORRUPTED = "corrupted_";, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.apache.lucene.index.IndexWriter;, +import org.elasticsearch.test.CorruptionUtils;, +import java.nio.file.FileVisitResult;, +import java.nio.file.Files;, +import java.nio.file.SimpleFileVisitor;, +import java.nio.file.attribute.BasicFileAttributes;, +            IndexShard shard = newShard(shardRouting, shardPath, metaData, i -> store,, +    public void testIndexCheckOnStartup() throws Exception {, +        final IndexShard indexShard = newStartedShard(true);, +, +        final long numDocs = between(10, 100);, +        for (long i = 0; i < numDocs; i++) {, +            indexDoc(indexShard, "_doc", Long.toString(i), "{}");, +        }, +        indexShard.flush(new FlushRequest());, +        closeShards(indexShard);, +, +        final ShardPath shardPath = indexShard.shardPath();, +, +        final Path indexPath = corruptIndexFile(shardPath);, +, +        final AtomicInteger corruptedMarkerCount = new AtomicInteger();, +        final SimpleFileVisitor<Path> corruptedVisitor = new SimpleFileVisitor<Path>() {, +            @Override, +            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {, +                if (Files.isRegularFile(file) && file.getFileName().toString().startsWith(Store.CORRUPTED)) {, +                    corruptedMarkerCount.incrementAndGet();, +                }, +                return FileVisitResult.CONTINUE;, +            }, +        };, +        Files.walkFileTree(indexPath, corruptedVisitor);, +, +        assertThat("corruption marker should not be there", corruptedMarkerCount.get(), equalTo(0));, +, +        final ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(indexShard.routingEntry(),, +            RecoverySource.StoreRecoverySource.EXISTING_STORE_INSTANCE, +        );, +        // start shard and perform index check on startup. It enforce shard to fail due to corrupted index files, +        final IndexMetaData indexMetaData = IndexMetaData.builder(indexShard.indexSettings().getIndexMetaData()), +            .settings(Settings.builder(), +                .put(indexShard.indexSettings.getSettings()), +                .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), randomFrom("true", "checksum"))), +            .build();, +, +        IndexShard corruptedShard = newShard(shardRouting, shardPath, indexMetaData,, +            null, null, indexShard.engineFactory,, +            indexShard.getGlobalCheckpointSyncer(), EMPTY_EVENT_LISTENER);, +, +        final IndexShardRecoveryException indexShardRecoveryException =, +            expectThrows(IndexShardRecoveryException.class, () -> newStartedShard(p -> corruptedShard, true));, +        assertThat(indexShardRecoveryException.getMessage(), equalTo("failed recovery"));, +, +        // check that corrupt marker is there, +        Files.walkFileTree(indexPath, corruptedVisitor);]