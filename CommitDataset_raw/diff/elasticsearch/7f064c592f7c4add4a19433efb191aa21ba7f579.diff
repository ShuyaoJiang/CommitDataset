[+++ b/docs/reference/search/percolate.asciidoc, +Traditionally you design documents based on your data, store them into an index, and then define queries via the search API, +in order to retrieve these documents. The percolator works in the opposite direction. First you store queries into an, +index and then, via the percolate API, you define documents in order to retrieve these queries., +JSON. This allows you to embed queries into documents via the index API. Elasticsearch can extract the query from a, +document and make it available to the percolate API. Since documents are also defined as JSON, you can define a document, +in a request to the percolate API., +in the percolate API., +Fields referred to in a percolator query must *already* exist in the mapping, +  <<indices-put-mapping,put mapping>> APIs., +=== Sample Usage, +=== Indexing Percolator Queries, +name `.percolator`. The query itself is placed as is in a JSON object under the top level field `query`., +On top of this, also a mapping type can be associated with this query. This allows to control how certain queries, +like range queries, shape filters, and other query & filters that rely on mapping settings get constructed. This is, +mapping settings would yield unexpected behaviour. Note: By default, field names do get resolved in a smart manner,, +but in certain cases with multiple types this can lead to unexpected behavior, so being explicit about it will help., +In the above example the range query really gets parsed into a Lucene numeric range query, based on the settings for, +Just as with any other type, the `.percolator` type has a mapping, which you can configure via the mappings APIs., +The default percolate mapping doesn't index the query field, only stores it., +If needed, this mapping can be modified with the update mapping API., +In order to un-register a percolate query the delete API can be used. So if the previous added query needs to be deleted, +=== Percolate API, +The percolate API executes in a distributed manner, meaning it executes on all shards an index points to., +* `doc` - The actual document to percolate. Unlike the other two options this needs to be specified in the request body. Note: This isn't required when percolating an existing document., +* `preference` - Controls which shard replicas are preferred to execute the request on. Works the same as in the search API., +* `ignore_unavailable` - Controls if missing concrete indices should silently be ignored. Same as is in the search API., +* `sort` - Define a sort specification like in the search API. Currently only sorting `_score` reverse (default relevancy), + in the percolate API depends of how many matches are being highlighted., +=== Dedicated Percolator Index, +can have its own index settings (For example the number of primary and replica shards). If you choose to have a dedicated, +Filtering allows to reduce the number of queries, any filter that the search API supports, (except the ones mentioned in important notes), +can also be used in the percolate API. The filter only works on the metadata fields. The `query` field isn't indexed by, +default. Based on the query we indexed before, the following filter can be defined:, +=== Percolator Count API, +The count percolate API, only keeps track of the number of matches and doesn't keep track of the actual matches, +=== Percolating an Existing Document, +In order to percolate a newly indexed document, the percolate existing document can be used. Based on the response, +from an index request, the `_id` and other meta information can be used to immediately percolate the newly added, +Internally the percolate API will issue a GET request for fetching the `_source` of the document to percolate., +For this feature to work, the `_source` for documents to be percolated needs to be stored., +Percolating an Existing Document:, +The response is the same as with the regular percolate API., +=== Multi Percolate API, +The multi percolate API allows to bundle multiple percolate requests into a single request, similar to what the multi, +search API does to search requests. The request body format is line based. Each percolate request item takes two lines,, +The index `twitter` is the default index, and the type `tweet` is the default type and will be used in the case a header, +For a percolate existing document item (headers with the `id` field), the response can be an empty JSON object., +=== How it Works Under the Hood, +When indexing a document that contains a query in an index and the `.percolator` type, the query part of the documents gets, +`.percolator` type gets removed. So, all the active percolator queries are kept in memory., +At percolate time, the document specified in the request gets parsed into a Lucene document and is stored in a in-memory, +that are registered to the index that the percolate request is targeted for, are going to be executed on this single document, +the time the percolate API needs to run can be decreased., +=== Important Notes, +The delete-by-query API doesn't work to unregister a query, it only deletes the percolate documents from disk. In order, +=== Forcing Unmapped Fields to be Handled as Strings, +In certain cases it is unknown what kind of percolator queries do get registered, and if no field mapping exists for fields, +to have the field with the appropriate settings, and then the percolator query can be added. But sometimes it is sufficient, +a percolator query does not exist, it will be handled as a default string field so that adding the percolator query doesn't]