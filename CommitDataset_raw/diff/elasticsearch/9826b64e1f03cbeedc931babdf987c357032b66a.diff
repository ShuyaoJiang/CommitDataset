[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]string[/\\]StringFieldMapperPositionIncrementGapTests.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]string[/\\]StringFieldMapperPositionIncrementGapTests.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = true;, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]string[/\\]StringFieldMapperPositionIncrementGapTests.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = true;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +import org.elasticsearch.Version;, +     * If set to true then this request will force an immediate refresh. Backwards compatibility layer for Elasticsearch's old, +     * {@code setRefresh} calls., +     *, +     * @deprecated use {@link #setRefreshPolicy(RefreshPolicy)} with {@link RefreshPolicy#IMMEDIATE} or {@link RefreshPolicy#NONE} instead., +     *             Will be removed in 6.0., +    @Deprecated, +    default B setRefresh(boolean refresh) {, +        assert Version.CURRENT.major < 6 : "Remove setRefresh(boolean) in 6.0";, +        return setRefreshPolicy(refresh ? RefreshPolicy.IMMEDIATE : RefreshPolicy.NONE);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]string[/\\]StringFieldMapperPositionIncrementGapTests.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = true;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +import org.elasticsearch.Version;, +     * If set to true then this request will force an immediate refresh. Backwards compatibility layer for Elasticsearch's old, +     * {@code setRefresh} calls., +     *, +     * @deprecated use {@link #setRefreshPolicy(RefreshPolicy)} with {@link RefreshPolicy#IMMEDIATE} or {@link RefreshPolicy#NONE} instead., +     *             Will be removed in 6.0., +    @Deprecated, +    default B setRefresh(boolean refresh) {, +        assert Version.CURRENT.major < 6 : "Remove setRefresh(boolean) in 6.0";, +        return setRefreshPolicy(refresh ? RefreshPolicy.IMMEDIATE : RefreshPolicy.NONE);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]string[/\\]StringFieldMapperPositionIncrementGapTests.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = true;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +import org.elasticsearch.Version;, +     * If set to true then this request will force an immediate refresh. Backwards compatibility layer for Elasticsearch's old, +     * {@code setRefresh} calls., +     *, +     * @deprecated use {@link #setRefreshPolicy(RefreshPolicy)} with {@link RefreshPolicy#IMMEDIATE} or {@link RefreshPolicy#NONE} instead., +     *             Will be removed in 6.0., +    @Deprecated, +    default B setRefresh(boolean refresh) {, +        assert Version.CURRENT.major < 6 : "Remove setRefresh(boolean) in 6.0";, +        return setRefreshPolicy(refresh ? RefreshPolicy.IMMEDIATE : RefreshPolicy.NONE);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, +import java.util.Arrays;, + *           a -> new Thing((String) a[0], (String) a[1]));, + *       PARSER.declareInt(Thing::setMineral, new ParseField("mineral"));, +     * Consumer that marks a field as a constructor argument instead of a real object field., +    private static final BiConsumer<Object, Object> CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +    private final List<ParseField> constructorArgNames = new ArrayList<>();, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a constructor argument. See this class's javadoc for an, +     * example. The order in which these are declared matters: it is the order that they come in the array passed to {@link #builder} and, +     * the order that missing arguments are reported to the user if any are missing. When all of these parameters are parsed from the, +     * {@linkplain XContentParser} the target object is immediately built., +        return (BiConsumer<Value, FieldT>) CONSTRUCTOR_ARG_MARKER;, +        if (consumer == CONSTRUCTOR_ARG_MARKER) {, +            int position = constructorArgNames.size();, +            constructorArgNames.add(parseField);, +        private final Object[] constructorArgs = new Object[constructorArgNames.size()];, +            if (constructorArgsCollected != constructorArgNames.size()) {, +                return;, +            }, +            try {, +                targetObject = builder.apply(constructorArgs);, +                while (queuedFieldsCount > 0) {, +                    queuedFieldsCount -= 1;, +                    queuedFields[queuedFieldsCount].accept(targetObject);, +                }, +            } catch (ParsingException e) {, +                throw new ParsingException(e.getLineNumber(), e.getColumnNumber(),, +                        "failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            } catch (Exception e) {, +                throw new ParsingException(null, "Failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            // The object hasn't been built which ought to mean we're missing some constructor arguments., +                if (constructorArgs[i] == null) {, +                    ParseField arg = constructorArgNames.get(i);, +                        message = new StringBuilder("Required [").append(arg);, +                        message.append(", ").append(arg);, +             * There won't be if there weren't any constructor arguments declared. That is fine, we'll just throw that error back at the to, +             * the user. This will happen every time so we can be confident that this'll be caught in testing so we can talk to the user, +             * like they are a developer. The only time a user will see this is if someone writes a parser and never tests it which seems, +             * like a bad idea., +            if (constructorArgNames.isEmpty()) {, +                throw new IllegalStateException("[" + objectParser.getName() + "] must configure at least on constructor argument. If it "]