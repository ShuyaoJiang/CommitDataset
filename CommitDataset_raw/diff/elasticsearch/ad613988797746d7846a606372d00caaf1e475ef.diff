[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * <p>, +     * A note on the optimization using max_seq_no_of_updates_or_deletes:, +     * For each operation O, the key invariants are:, +     * <ol>, +     *     <li> I1: There is no operation on docID(O) with seqno that is {@literal > MSU(O) and < seqno(O)} </li>, +     *     <li> I2: If {@literal MSU(O) < seqno(O)} then docID(O) did not exist when O was applied; more precisely, if there is any O', +     *              with {@literal seqno(O') < seqno(O) and docID(O') = docID(O)} then the one with the greatest seqno is a delete.</li>, +     * </ol>, +     * <p>, +     * When a receiving shard (either a replica or a follower) receives an operation O, it must first ensure its own MSU at least MSU(O),, +     * and then compares its MSU to its local checkpoint (LCP). If {@literal LCP < MSU} then there's a gap: there may be some operations, +     * that act on docID(O) about which we do not yet know, so we cannot perform an add. Note this also covers the case where a future, +     * operation O' with {@literal seqNo(O') > seqNo(O) and docId(O') = docID(O)} is processed before O. In that case MSU(O') is at least, +     * seqno(O') and this means {@literal MSU >= seqNo(O') > seqNo(O) > LCP} (because O wasn't processed yet)., +     * <p>, +     * However, if {@literal MSU <= LCP} then there is no gap: we have processed every {@literal operation <= LCP}, and no operation O', +     * with {@literal seqno(O') > LCP and seqno(O') < seqno(O) also has docID(O') = docID(O)}, because such an operation would have, +     * {@literal seqno(O') > LCP >= MSU >= MSU(O)} which contradicts the first invariant. Furthermore in this case we immediately know, +     * that docID(O) has been deleted (or never existed) without needing to check Lucene for the following reason. If there's no earlier, +     * operation on docID(O) then this is clear, so suppose instead that the preceding operation on docID(O) is O':, +     * 1. The first invariant above tells us that {@literal seqno(O') <= MSU(O) <= LCP} so we have already applied O' to Lucene., +     * 2. Also {@literal MSU(O) <= MSU <= LCP < seqno(O)} (we discard O if {@literal seqno(O) <= LCP}) so the second invariant applies,, +     *    meaning that the O' was a delete., +     * <p>, +     * Therefore, if {@literal MSU <= LCP < seqno(O)} we know that O can safely be optimized with and added to lucene with addDocument., +     * Moreover, operations that are optimized using the MSU optimization must not be processed twice as this will create duplicates, +     * in Lucene. To avoid this we check the local checkpoint tracker to see if an operation was already processed., +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * <p>, +     * A note on the optimization using max_seq_no_of_updates_or_deletes:, +     * For each operation O, the key invariants are:, +     * <ol>, +     *     <li> I1: There is no operation on docID(O) with seqno that is {@literal > MSU(O) and < seqno(O)} </li>, +     *     <li> I2: If {@literal MSU(O) < seqno(O)} then docID(O) did not exist when O was applied; more precisely, if there is any O', +     *              with {@literal seqno(O') < seqno(O) and docID(O') = docID(O)} then the one with the greatest seqno is a delete.</li>, +     * </ol>, +     * <p>, +     * When a receiving shard (either a replica or a follower) receives an operation O, it must first ensure its own MSU at least MSU(O),, +     * and then compares its MSU to its local checkpoint (LCP). If {@literal LCP < MSU} then there's a gap: there may be some operations, +     * that act on docID(O) about which we do not yet know, so we cannot perform an add. Note this also covers the case where a future, +     * operation O' with {@literal seqNo(O') > seqNo(O) and docId(O') = docID(O)} is processed before O. In that case MSU(O') is at least, +     * seqno(O') and this means {@literal MSU >= seqNo(O') > seqNo(O) > LCP} (because O wasn't processed yet)., +     * <p>, +     * However, if {@literal MSU <= LCP} then there is no gap: we have processed every {@literal operation <= LCP}, and no operation O', +     * with {@literal seqno(O') > LCP and seqno(O') < seqno(O) also has docID(O') = docID(O)}, because such an operation would have, +     * {@literal seqno(O') > LCP >= MSU >= MSU(O)} which contradicts the first invariant. Furthermore in this case we immediately know, +     * that docID(O) has been deleted (or never existed) without needing to check Lucene for the following reason. If there's no earlier, +     * operation on docID(O) then this is clear, so suppose instead that the preceding operation on docID(O) is O':, +     * 1. The first invariant above tells us that {@literal seqno(O') <= MSU(O) <= LCP} so we have already applied O' to Lucene., +     * 2. Also {@literal MSU(O) <= MSU <= LCP < seqno(O)} (we discard O if {@literal seqno(O) <= LCP}) so the second invariant applies,, +     *    meaning that the O' was a delete., +     * <p>, +     * Therefore, if {@literal MSU <= LCP < seqno(O)} we know that O can safely be optimized with and added to lucene with addDocument., +     * Moreover, operations that are optimized using the MSU optimization must not be processed twice as this will create duplicates, +     * in Lucene. To avoid this we check the local checkpoint tracker to see if an operation was already processed., +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            plan = IndexingStrategy.optimizedAppendOnly(index.seqNo(), 1L);, +                plan = IndexingStrategy.optimizedAppendOnly(generateSeqNoForOperation(index), 1L);, +        public static IndexingStrategy optimizedAppendOnly(long seqNoForIndexing, long versionForIndexing) {, +            return new IndexingStrategy(true, false, true, false, seqNoForIndexing, versionForIndexing, null);, +        public static IndexingStrategy processButSkipLucene(boolean currentNotFoundOrDeleted, long seqNoForIndexing,, +                                                            long versionForIndexing) {, +    /**, +     * Checks if the given operation has been processed in this engine or not., +     * @return true if the given operation was processed; otherwise false., +     */, +    protected final boolean hasBeenProcessedBefore(Operation op) {, +        assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no";, +        assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes());, +        return localCheckpointTracker.contains(op.seqNo());, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * <p>, +     * A note on the optimization using max_seq_no_of_updates_or_deletes:, +     * For each operation O, the key invariants are:, +     * <ol>, +     *     <li> I1: There is no operation on docID(O) with seqno that is {@literal > MSU(O) and < seqno(O)} </li>, +     *     <li> I2: If {@literal MSU(O) < seqno(O)} then docID(O) did not exist when O was applied; more precisely, if there is any O', +     *              with {@literal seqno(O') < seqno(O) and docID(O') = docID(O)} then the one with the greatest seqno is a delete.</li>, +     * </ol>, +     * <p>, +     * When a receiving shard (either a replica or a follower) receives an operation O, it must first ensure its own MSU at least MSU(O),, +     * and then compares its MSU to its local checkpoint (LCP). If {@literal LCP < MSU} then there's a gap: there may be some operations, +     * that act on docID(O) about which we do not yet know, so we cannot perform an add. Note this also covers the case where a future, +     * operation O' with {@literal seqNo(O') > seqNo(O) and docId(O') = docID(O)} is processed before O. In that case MSU(O') is at least, +     * seqno(O') and this means {@literal MSU >= seqNo(O') > seqNo(O) > LCP} (because O wasn't processed yet)., +     * <p>, +     * However, if {@literal MSU <= LCP} then there is no gap: we have processed every {@literal operation <= LCP}, and no operation O', +     * with {@literal seqno(O') > LCP and seqno(O') < seqno(O) also has docID(O') = docID(O)}, because such an operation would have, +     * {@literal seqno(O') > LCP >= MSU >= MSU(O)} which contradicts the first invariant. Furthermore in this case we immediately know, +     * that docID(O) has been deleted (or never existed) without needing to check Lucene for the following reason. If there's no earlier, +     * operation on docID(O) then this is clear, so suppose instead that the preceding operation on docID(O) is O':, +     * 1. The first invariant above tells us that {@literal seqno(O') <= MSU(O) <= LCP} so we have already applied O' to Lucene., +     * 2. Also {@literal MSU(O) <= MSU <= LCP < seqno(O)} (we discard O if {@literal seqno(O) <= LCP}) so the second invariant applies,, +     *    meaning that the O' was a delete., +     * <p>, +     * Therefore, if {@literal MSU <= LCP < seqno(O)} we know that O can safely be optimized with and added to lucene with addDocument., +     * Moreover, operations that are optimized using the MSU optimization must not be processed twice as this will create duplicates]