[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +import java.util.Collection;, +import static org.bouncycastle.asn1.x500.style.RFC4519Style.name;, +    private final IndicesAndAliasesResolver indicesAndAliasesResolver;, +        this.indicesAndAliasesResolver = new IndicesAndAliasesResolver(new IndexNameExpressionResolver(settings));, +        Collection<Role> roles = roles(authentication.getUser());, +        GlobalPermission permission = permission(roles);, +        // permission can be empty as it might be that the user's role is unknown, +        if (permission.isEmpty()) {, +                roles = roles(authentication.getRunAsUser());, +                permission = permission(roles);, +                // permission can be empty as it might be that the run as user's role is unknown, +                if (permission.isEmpty()) {, +        // first, we'll check if the action is a cluster action. If it is, we'll only check it against the cluster permissions, +        MetaData metaData = clusterService.state().metaData();, +        AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getRunAsUser(), roles, action, metaData);, +        Set<String> indexNames = indicesAndAliasesResolver.resolve(request, metaData, authorizedIndices);, +        if (indexNames.size() == 1 && indexNames.contains(IndicesAndAliasesResolver.NO_INDEX)) {, +    private GlobalPermission permission(Collection<Role> roles) {, +        GlobalPermission.Compound.Builder rolesBuilder = GlobalPermission.Compound.builder();, +        for (Role role : roles) {, +            rolesBuilder.add(role);, +        return rolesBuilder.build();, +    Collection<Role> roles(User user) {, +        Set<String> roleNames = new HashSet<>();, +        Collections.addAll(roleNames, user.roles());, +        if (isAnonymousEnabled && anonymousUser.equals(user) == false) {, +            if (anonymousUser.roles().length == 0) {, +                throw new IllegalStateException("anonymous is only enabled when the anonymous user has roles");, +            }, +            Collections.addAll(roleNames, anonymousUser.roles());, +        }, +        List<Role> roles = new ArrayList<>();, +        roles.add(DefaultRole.INSTANCE);, +        for (String roleName : roleNames) {, +        return Collections.unmodifiableList(roles);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +import java.util.Collection;, +import static org.bouncycastle.asn1.x500.style.RFC4519Style.name;, +    private final IndicesAndAliasesResolver indicesAndAliasesResolver;, +        this.indicesAndAliasesResolver = new IndicesAndAliasesResolver(new IndexNameExpressionResolver(settings));, +        Collection<Role> roles = roles(authentication.getUser());, +        GlobalPermission permission = permission(roles);, +        // permission can be empty as it might be that the user's role is unknown, +        if (permission.isEmpty()) {, +                roles = roles(authentication.getRunAsUser());, +                permission = permission(roles);, +                // permission can be empty as it might be that the run as user's role is unknown, +                if (permission.isEmpty()) {, +        // first, we'll check if the action is a cluster action. If it is, we'll only check it against the cluster permissions, +        MetaData metaData = clusterService.state().metaData();, +        AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getRunAsUser(), roles, action, metaData);, +        Set<String> indexNames = indicesAndAliasesResolver.resolve(request, metaData, authorizedIndices);, +        if (indexNames.size() == 1 && indexNames.contains(IndicesAndAliasesResolver.NO_INDEX)) {, +    private GlobalPermission permission(Collection<Role> roles) {, +        GlobalPermission.Compound.Builder rolesBuilder = GlobalPermission.Compound.builder();, +        for (Role role : roles) {, +            rolesBuilder.add(role);, +        return rolesBuilder.build();, +    Collection<Role> roles(User user) {, +        Set<String> roleNames = new HashSet<>();, +        Collections.addAll(roleNames, user.roles());, +        if (isAnonymousEnabled && anonymousUser.equals(user) == false) {, +            if (anonymousUser.roles().length == 0) {, +                throw new IllegalStateException("anonymous is only enabled when the anonymous user has roles");, +            }, +            Collections.addAll(roleNames, anonymousUser.roles());, +        }, +        List<Role> roles = new ArrayList<>();, +        roles.add(DefaultRole.INSTANCE);, +        for (String roleName : roleNames) {, +        return Collections.unmodifiableList(roles);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizedIndices.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.security.authz;, +, +import org.elasticsearch.cluster.metadata.AliasOrIndex;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.xpack.security.SecurityTemplateService;, +import org.elasticsearch.xpack.security.authz.permission.Role;, +import org.elasticsearch.xpack.security.authz.permission.SuperuserRole;, +import org.elasticsearch.xpack.security.user.User;, +import org.elasticsearch.xpack.security.user.XPackUser;, +, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +import java.util.Map;, +import java.util.function.Predicate;, +, +/**, + * Abstraction used to make sure that we lazily load authorized indices only when requested and only maximum once per request. Also, + * makes sure that authorized indices don't get updated throughout the same request for the same user., + */]