[+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotInfo.java, +    public SnapshotInfo(SnapshotId snapshotId, List<String> indices, SnapshotState state, Version version) {, +        this(snapshotId, indices, state, null, version, 0L, 0L, 0, 0, Collections.emptyList(), null);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotInfo.java, +    public SnapshotInfo(SnapshotId snapshotId, List<String> indices, SnapshotState state, Version version) {, +        this(snapshotId, indices, state, null, version, 0L, 0L, 0, 0, Collections.emptyList(), null);, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +    public synchronized <T> T getCurrentMasterNodeInstance(Class<T> clazz) {, +        return getInstance(clazz, new NodeNamePredicate(getMasterName()));, +    }, +, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotInfo.java, +    public SnapshotInfo(SnapshotId snapshotId, List<String> indices, SnapshotState state, Version version) {, +        this(snapshotId, indices, state, null, version, 0L, 0L, 0, 0, Collections.emptyList(), null);, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +    public synchronized <T> T getCurrentMasterNodeInstance(Class<T> clazz) {, +        return getInstance(clazz, new NodeNamePredicate(getMasterName()));, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +    private Client client;, +        this.client = client;, +        Repository.Factory repositoryFactory = (metadata) -> new CcrRepository(metadata, client, ccrLicenseChecker, settings);, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotInfo.java, +    public SnapshotInfo(SnapshotId snapshotId, List<String> indices, SnapshotState state, Version version) {, +        this(snapshotId, indices, state, null, version, 0L, 0L, 0, 0, Collections.emptyList(), null);, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +    public synchronized <T> T getCurrentMasterNodeInstance(Class<T> clazz) {, +        return getInstance(clazz, new NodeNamePredicate(getMasterName()));, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +    private Client client;, +        this.client = client;, +        Repository.Factory repositoryFactory = (metadata) -> new CcrRepository(metadata, client, ccrLicenseChecker, settings);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/repository/CcrRepository.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.action.support.PlainActionFuture;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.engine.EngineException;, +import org.elasticsearch.index.shard.IndexShardRecoveryException;, +import org.elasticsearch.snapshots.SnapshotState;, +import org.elasticsearch.xpack.ccr.Ccr;, +import org.elasticsearch.xpack.ccr.CcrLicenseChecker;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Set;, +    public static final String LATEST = "_latest_";, +    private static final SnapshotId SNAPSHOT_ID = new SnapshotId(LATEST, LATEST);, +    private final String remoteClusterAlias;, +    private final Client client;, +    private final CcrLicenseChecker ccrLicenseChecker;, +    public CcrRepository(RepositoryMetaData metadata, Client client, CcrLicenseChecker ccrLicenseChecker, Settings settings) {, +        assert metadata.name().startsWith(NAME_PREFIX) : "CcrRepository metadata.name() must start with: " + NAME_PREFIX;, +        this.remoteClusterAlias = Strings.split(metadata.name(), NAME_PREFIX)[1];, +        this.ccrLicenseChecker = ccrLicenseChecker;, +        this.client = client;, +        assert SNAPSHOT_ID.equals(snapshotId) : "RemoteClusterRepository only supports " + SNAPSHOT_ID + " as the SnapshotId";, +        Client remoteClient = client.getRemoteClusterClient(remoteClusterAlias);, +        ClusterStateResponse response = remoteClient.admin().cluster().prepareState().clear().setMetaData(true).setNodes(true).get();, +        ImmutableOpenMap<String, IndexMetaData> indicesMap = response.getState().metaData().indices();, +        ArrayList<String> indices = new ArrayList<>(indicesMap.size());, +        indicesMap.keysIt().forEachRemaining(indices::add);, +, +        return new SnapshotInfo(snapshotId, indices, SnapshotState.SUCCESS, response.getState().getNodes().getMaxNodeVersion());, +        assert SNAPSHOT_ID.equals(snapshotId) : "RemoteClusterRepository only supports " + SNAPSHOT_ID + " as the SnapshotId";, +        Client remoteClient = client.getRemoteClusterClient(remoteClusterAlias);, +        ClusterStateResponse response = remoteClient, +            .admin(), +            .cluster(), +            .prepareState(), +            .clear(), +            .setMetaData(true), +            .setIndices("dummy_index_name") // We set a single dummy index name to avoid fetching all the index data, +            .get();, +        return response.getState().metaData();, +        assert SNAPSHOT_ID.equals(snapshotId) : "RemoteClusterRepository only supports " + SNAPSHOT_ID + " as the SnapshotId";, +        String leaderIndex = index.getName();, +        Client remoteClient = client.getRemoteClusterClient(remoteClusterAlias);, +, +        ClusterStateResponse response = remoteClient, +            .admin(), +            .cluster(), +            .prepareState(), +            .clear(), +            .setMetaData(true), +            .setIndices(leaderIndex)]