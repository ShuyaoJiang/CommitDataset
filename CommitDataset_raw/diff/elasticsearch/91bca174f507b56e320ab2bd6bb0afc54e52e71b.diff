[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Attribute.java, +import java.util.List;, + * {@link Expression}s that can be materialized and represent the result columns sent to the client., + * Typically are converted into constants, functions or Elasticsearch order-bys,, + * aggregations, or queries. They can also be extracted from the result of a search., + * expressions {@code ABS(foo), A, B+C} get converted to attributes and the user can, + * In the statement {@code SELECT foo FROM TABLE WHERE foo > 10 + 1} both {@code foo} and, + * {@code 10 + 1} are named expressions, the first due to the SELECT, the second due to being a function., + * However since {@code 10 + 1} is used for filtering it doesn't appear appear in the result set, + * (derived table) and as such it is never translated to an attribute., + * "foo" on the other hand is since it's a column in the result set., + * Another example {@code SELECT foo FROM ... WHERE bar > 10 +1} {@code foo} gets, + * converted into an Attribute, bar does not. That's because {@code bar} is used for, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Attribute.java, +import java.util.List;, + * {@link Expression}s that can be materialized and represent the result columns sent to the client., + * Typically are converted into constants, functions or Elasticsearch order-bys,, + * aggregations, or queries. They can also be extracted from the result of a search., + * expressions {@code ABS(foo), A, B+C} get converted to attributes and the user can, + * In the statement {@code SELECT foo FROM TABLE WHERE foo > 10 + 1} both {@code foo} and, + * {@code 10 + 1} are named expressions, the first due to the SELECT, the second due to being a function., + * However since {@code 10 + 1} is used for filtering it doesn't appear appear in the result set, + * (derived table) and as such it is never translated to an attribute., + * "foo" on the other hand is since it's a column in the result set., + * Another example {@code SELECT foo FROM ... WHERE bar > 10 +1} {@code foo} gets, + * converted into an Attribute, bar does not. That's because {@code bar} is used for, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Expressions.java, +        return e instanceof NamedExpression ? ((NamedExpression) e).name() : e.nodeName();, +            return Literal.of(e).toAttribute();, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Attribute.java, +import java.util.List;, + * {@link Expression}s that can be materialized and represent the result columns sent to the client., + * Typically are converted into constants, functions or Elasticsearch order-bys,, + * aggregations, or queries. They can also be extracted from the result of a search., + * expressions {@code ABS(foo), A, B+C} get converted to attributes and the user can, + * In the statement {@code SELECT foo FROM TABLE WHERE foo > 10 + 1} both {@code foo} and, + * {@code 10 + 1} are named expressions, the first due to the SELECT, the second due to being a function., + * However since {@code 10 + 1} is used for filtering it doesn't appear appear in the result set, + * (derived table) and as such it is never translated to an attribute., + * "foo" on the other hand is since it's a column in the result set., + * Another example {@code SELECT foo FROM ... WHERE bar > 10 +1} {@code foo} gets, + * converted into an Attribute, bar does not. That's because {@code bar} is used for, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Expressions.java, +        return e instanceof NamedExpression ? ((NamedExpression) e).name() : e.nodeName();, +            return Literal.of(e).toAttribute();, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Literal.java, +import java.util.List;, +import static java.util.Collections.emptyList;, +, +/**, + * SQL Literal or constant., + */, +public class Literal extends NamedExpression {, +, +        this(location, null, value, dataType);, +    }, +, +    public Literal(Location location, String name, Object value, DataType dataType) {, +        super(location, name == null ? String.valueOf(value) : name, emptyList(), null);, +    @Override, +    public Attribute toAttribute() {, +        return new LiteralAttribute(location(), name(), null, false, id(), false, dataType, this);, +    }, +, +    @Override, +    public Expression replaceChildren(List<Expression> newChildren) {, +        throw new UnsupportedOperationException("this type of node doesn't have any children to replace");, +    }, +, +    @Override, +    public AttributeSet references() {, +        return AttributeSet.EMPTY;, +    }, +        return Objects.hash(name(), value, dataType);, +        return Objects.equals(name(), other.name()), +                && Objects.equals(value, other.value), +        String s = String.valueOf(value);, +        return name().equals(s) ? s : name() + "=" + value;, +    /**, +     * Utility method for creating 'in-line' Literals (out of values instead of expressions)., +     */, +    /**, +     * Utility method for creating a literal out of a foldable expression., +     * Throws an exception if the expression is not foldable., +     */, +        return of((String) null, foldable);, +    public static Literal of(String name, Expression foldable) {, +        if (foldable instanceof Literal) {, +            Literal l = (Literal) foldable;, +            if (name == null || l.name().equals(name)) {, +                return l;, +            }, +        }, +, +        Object fold = foldable.fold();, +, +        if (name == null) {, +            name = foldable instanceof NamedExpression ? ((NamedExpression) foldable).name() : String.valueOf(fold);, +        }, +]