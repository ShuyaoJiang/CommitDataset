[+++ b/server/src/main/java/org/elasticsearch/common/time/CompoundDateTimeFormatter.java, +import java.time.format.DateTimeFormatterBuilder;, +import java.time.temporal.TemporalField;, +import java.util.Arrays;, +import java.util.Locale;, +import java.util.Map;, +import java.util.function.Consumer;, +    private static final Consumer<DateTimeFormatter[]> SAME_TIME_ZONE_VALIDATOR = (parsers) -> {, +        long distinctZones = Arrays.stream(parsers).map(DateTimeFormatter::getZone).distinct().count();, +        if (distinctZones > 1) {, +            throw new IllegalArgumentException("formatters must have the same time zone");, +        }, +    };, +, +        SAME_TIME_ZONE_VALIDATOR.accept(parsers);, +    /**, +     * Configure a specific time zone for a date formatter, +     *, +     * @param zoneId The zoneId this formatter shoulduse, +     * @return       The new formatter with all parsers switched to the specified timezone, +     */, +        // shortcurt to not create new objects unnecessarily, +        if (zoneId.equals(parsers[0].getZone())) {, +            return this;, +        }, +, +    /**, +     * Configure defaults for missing values in a parser, then return a new compound date formatter, +     */, +    CompoundDateTimeFormatter parseDefaulting(Map<TemporalField, Long> fields) {, +        final DateTimeFormatter[] parsersWithDefaulting = new DateTimeFormatter[parsers.length];, +        for (int i = 0; i < parsers.length; i++) {, +            DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder().append(parsers[i]);, +            fields.forEach(builder::parseDefaulting);, +            parsersWithDefaulting[i] = builder.toFormatter(Locale.ROOT);, +        }, +, +        return new CompoundDateTimeFormatter(parsersWithDefaulting);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/common/time/CompoundDateTimeFormatter.java, +import java.time.format.DateTimeFormatterBuilder;, +import java.time.temporal.TemporalField;, +import java.util.Arrays;, +import java.util.Locale;, +import java.util.Map;, +import java.util.function.Consumer;, +    private static final Consumer<DateTimeFormatter[]> SAME_TIME_ZONE_VALIDATOR = (parsers) -> {, +        long distinctZones = Arrays.stream(parsers).map(DateTimeFormatter::getZone).distinct().count();, +        if (distinctZones > 1) {, +            throw new IllegalArgumentException("formatters must have the same time zone");, +        }, +    };, +, +        SAME_TIME_ZONE_VALIDATOR.accept(parsers);, +    /**, +     * Configure a specific time zone for a date formatter, +     *, +     * @param zoneId The zoneId this formatter shoulduse, +     * @return       The new formatter with all parsers switched to the specified timezone, +     */, +        // shortcurt to not create new objects unnecessarily, +        if (zoneId.equals(parsers[0].getZone())) {, +            return this;, +        }, +, +    /**, +     * Configure defaults for missing values in a parser, then return a new compound date formatter, +     */, +    CompoundDateTimeFormatter parseDefaulting(Map<TemporalField, Long> fields) {, +        final DateTimeFormatter[] parsersWithDefaulting = new DateTimeFormatter[parsers.length];, +        for (int i = 0; i < parsers.length; i++) {, +            DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder().append(parsers[i]);, +            fields.forEach(builder::parseDefaulting);, +            parsersWithDefaulting[i] = builder.toFormatter(Locale.ROOT);, +        }, +, +        return new CompoundDateTimeFormatter(parsersWithDefaulting);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +        .appendValue(ChronoField.YEAR, 1, 5, SignStyle.NORMAL), +        .optionalStart(), +        .optionalStart(), +        .optionalEnd(), +        .optionalEnd(), +            .optionalStart(), +            .appendValue(HOUR_OF_DAY, 1, 2, SignStyle.NOT_NEGATIVE), +            .optionalStart(), +            .appendLiteral(':'), +            .appendValue(MINUTE_OF_HOUR, 1, 2, SignStyle.NOT_NEGATIVE), +            .optionalEnd(), +            .optionalEnd(), +            .optionalStart(), +            .appendValue(HOUR_OF_DAY, 1, 2, SignStyle.NOT_NEGATIVE), +            .optionalStart(), +            .appendLiteral(':'), +            .appendValue(MINUTE_OF_HOUR, 1, 2, SignStyle.NOT_NEGATIVE), +            .optionalEnd(), +            .optionalEnd()]