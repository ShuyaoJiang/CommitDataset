[+++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.atomic.AtomicIntegerArray;, +        final AtomicReferenceArray<Object> percolateRequests = new AtomicReferenceArray<Object>(request.requests().size());, +        TIntArrayList getRequestSlots = new TIntArrayList();, +        List<GetRequest> existingDocsRequests = new ArrayList<GetRequest>();, +            percolateRequests.set(i, percolateRequest);, +                getRequestSlots.add(i);, +        // Can have a mixture of percolate requests. (normal percolate requests & percolate existing doc),, +        // so we need to keep track for what percolate request we had a get request, +        final AtomicIntegerArray percolateRequestSlotsWithGet = new AtomicIntegerArray(getRequestSlots.toArray());, +, +                        int slot = percolateRequestSlotsWithGet.get(i);, +    private void multiPercolate(MultiPercolateRequest multiPercolateRequest, final AtomicReferenceArray<Object> percolateRequests,, +        final AtomicInteger[] expectedOperationsPerItem = new AtomicInteger[percolateRequests.length()];, +        final AtomicArray<Object> reducedResponses = new AtomicArray<Object>(percolateRequests.length());, +, +        // Keep track what slots belong to what shard, in case a request to a shard fails on all copies, +        final ConcurrentMap<ShardId, AtomicIntegerArray> shardToSlots = ConcurrentCollections.newConcurrentMap();, +        Map<ShardId, TransportShardMultiPercolateAction.Request> requestsByShard = new HashMap<ShardId, TransportShardMultiPercolateAction.Request>();, +        Map<ShardId, TIntArrayList> shardToSlotsBuilder = new HashMap<ShardId, TIntArrayList>();, +        for (int i = 0;  i < percolateRequests.length(); i++) {, +                    TIntArrayList items = shardToSlotsBuilder.get(shardId);, +                        shardToSlotsBuilder.put(shardId, items = new TIntArrayList());, +        for (Map.Entry<ShardId, TIntArrayList> entry : shardToSlotsBuilder.entrySet()) {, +            shardToSlots.put(entry.getKey(), new AtomicIntegerArray(entry.getValue().toArray()));, +        }, +, +                        AtomicIntegerArray slots = shardToSlots.get(shardId);, +                        for (int i = 0; i < slots.length(); i++) {, +                        AtomicReferenceArray<Object> percolateRequests,, +        assert expectedOperations.get() >= 1 : "slot[" + slot + "] expected options should be >= 1 but is " + expectedOperations.get();, +            assert element != null : "Element[" + i + "] shouldn't be null";]