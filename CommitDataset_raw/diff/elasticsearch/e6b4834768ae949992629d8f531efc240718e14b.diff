[+++ b/.idea/libraries/lucene.xml, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-highlighter/jars/lucene-highlighter-3.0.3.jar!/" />, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-memory/jars/lucene-memory-3.0.3.jar!/" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/highlighter/src/java" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/memory/src/java" />, +++ b/.idea/libraries/lucene.xml, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-highlighter/jars/lucene-highlighter-3.0.3.jar!/" />, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-memory/jars/lucene-memory-3.0.3.jar!/" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/highlighter/src/java" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/memory/src/java" />, +++ b/modules/elasticsearch/build.gradle, +    compile 'org.apache.lucene:lucene-memory:3.0.3', +    compile 'org.apache.lucene:lucene-highlighter:3.0.3', +++ b/.idea/libraries/lucene.xml, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-highlighter/jars/lucene-highlighter-3.0.3.jar!/" />, +      <root url="jar://$GRADLE_REPOSITORY$/org.apache.lucene/lucene-memory/jars/lucene-memory-3.0.3.jar!/" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/highlighter/src/java" />, +      <root url="file://$USER_HOME$/opt/lucene/3.0.3.src/contrib/memory/src/java" />, +++ b/modules/elasticsearch/build.gradle, +    compile 'org.apache.lucene:lucene-memory:3.0.3', +    compile 'org.apache.lucene:lucene-highlighter:3.0.3', +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java, +import org.apache.lucene.analysis.Analyzer;, +import org.apache.lucene.analysis.TokenStream;, +import org.apache.lucene.document.Document;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.Fieldable;, +import org.apache.lucene.search.highlight.*;, +import org.apache.lucene.search.highlight.Formatter;, +import org.elasticsearch.common.io.FastStringReader;, +import org.elasticsearch.common.lucene.document.SingleFieldSelector;, +import org.elasticsearch.search.lookup.SearchLookup;, +import java.util.*;, +    private static final Encoder DEFAULT_ENCODER = new DefaultEncoder();, +, +                // if we can do highlighting using Term Vectors, use FastVectorHighlighter, otherwise, use the, +                // slower plain highlighter, +                if (mapper.termVector() != Field.TermVector.WITH_POSITIONS_OFFSETS) {, +                    if (!context.queryRewritten()) {, +                        try {, +                            context.updateRewriteQuery(context.searcher().rewrite(context.query()));, +                        } catch (IOException e) {, +                            throw new FetchPhaseExecutionException(context, "Failed to highlight field [" + field.field() + "]", e);, +                        }, +                    }, +                    // Don't use the context.query() since it might be rewritten, and we need to pass the non rewritten queries to, +                    // let the highlighter handle MultiTerm ones, +                    QueryScorer queryScorer = new QueryScorer(context.parsedQuery().query(), null);, +                    queryScorer.setExpandMultiTermQuery(true);, +                    Fragmenter fragmenter;, +                    if (field.numberOfFragments() == 0) {, +                        fragmenter = new NullFragmenter();, +                    } else {, +                        fragmenter = new SimpleSpanFragmenter(queryScorer, field.fragmentCharSize());, +                    }, +                    Formatter formatter = new SimpleHTMLFormatter(field.preTags()[0], field.postTags()[0]);, +                    Highlighter highlighter = new Highlighter(formatter, DEFAULT_ENCODER, queryScorer);, +                    highlighter.setTextFragmenter(fragmenter);, +, +                    List<Object> textsToHighlight;, +                    if (mapper.stored()) {, +                        try {, +                            Document doc = reader.document(docId, new SingleFieldSelector(mapper.names().indexName()));, +                            textsToHighlight = new ArrayList<Object>(doc.getFields().size());, +                            for (Fieldable docField : doc.getFields()) {, +                                if (docField.stringValue() != null) {, +                                    textsToHighlight.add(docField.stringValue());, +                                }, +                            }, +                        } catch (Exception e) {, +                            throw new FetchPhaseExecutionException(context, "Failed to highlight field [" + field.field() + "]", e);, +                        }, +                    } else {, +                        SearchLookup lookup = context.lookup();, +                        lookup.setNextReader(reader);, +                        lookup.setNextDocId(docId);, +                        textsToHighlight = lookup.source().getValues(mapper.names().fullName());, +                    }, +, +                    ArrayList<TextFragment> fragsList = new ArrayList<TextFragment>();, +                    try {, +                        for (Object textToHighlight : textsToHighlight) {, +                            String text = textToHighlight.toString();, +                            Analyzer analyzer = context.mapperService().documentMapper(hit.type()).mappers().indexAnalyzer();, +                            TokenStream tokenStream = analyzer.reusableTokenStream(mapper.names().indexName(), new FastStringReader(text));, +                            TextFragment[] bestTextFragments = highlighter.getBestTextFragments(tokenStream, text, false, field.numberOfFragments());, +                            Collections.addAll(fragsList, bestTextFragments);, +                        }, +                    } catch (Exception e) {, +                        throw new FetchPhaseExecutionException(context, "Failed to highlight field [" + field.field() + "]", e);, +                    }, +                    if (field.scoreOrdered()) {, +                        Collections.sort(fragsList, new Comparator<TextFragment>() {, +                            public int compare(TextFragment o1, TextFragment o2) {, +                                return Math.round(o2.getScore() - o1.getScore());, +                            }, +                        });, +                    }, +                    int numberOfFragments = fragsList.size() < field.numberOfFragments() ? fragsList.size() : field.numberOfFragments();, +                    String[] fragments = new String[numberOfFragments];]