[+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java, +    private final AtomicBoolean configurationFrozen = new AtomicBoolean(false);, +        checkFrozen();, +        checkFrozen();, +    public void start() {, +        logger.info("Starting `{}`", this);, +    public void stop(boolean tailLogs) {, +        logger.info("Stopping `{}`, tailLogs: {}", this, tailLogs);, +    public void freeze() {, +        logger.info("Locking configuration of `{}`", this);, +        configurationFrozen.set(true);, +    private void checkFrozen() {, +        if (configurationFrozen.get()) {, +            throw new IllegalStateException("Configuration can not be altered, already locked");, +, +    @Override, +    public String toString() {, +        return "ElasticsearchNode{name='" + name + "'}";, +    }, +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/ElasticsearchNode.java, +    private final AtomicBoolean configurationFrozen = new AtomicBoolean(false);, +        checkFrozen();, +        checkFrozen();, +    public void start() {, +        logger.info("Starting `{}`", this);, +    public void stop(boolean tailLogs) {, +        logger.info("Stopping `{}`, tailLogs: {}", this, tailLogs);, +    public void freeze() {, +        logger.info("Locking configuration of `{}`", this);, +        configurationFrozen.set(true);, +    private void checkFrozen() {, +        if (configurationFrozen.get()) {, +            throw new IllegalStateException("Configuration can not be altered, already locked");, +, +    @Override, +    public String toString() {, +        return "ElasticsearchNode{name='" + name + "'}";, +    }, +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/testclusters/TestClustersPlugin.java, +import java.util.HashSet;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.stream.Collectors;, +    public static final String PROPERTY_TESTCLUSTERS_RUN_ONCE = "_testclusters_run_once";, +    // this is static because we need a single mapping across multi project builds, as some of the listeners we use,, +    // like task graph are singletons across multi project builds., +    private static final Map<Task, List<ElasticsearchNode>> usedClusters = new ConcurrentHashMap<>();, +    private static final Map<ElasticsearchNode, Integer> claimsInventory = new ConcurrentHashMap<>();, +    private static final Set<ElasticsearchNode> runningClusters = Collections.synchronizedSet(new HashSet<>());, +, +        // enable the DSL to describe clusters, +        NamedDomainObjectContainer<ElasticsearchNode> container = createTestClustersContainerExtension(project);, +, +        // provide a task to be able to list defined clusters., +        createListClustersTask(project, container);, +, +        // create DSL for tasks to mark clusters these use, +        createUseClusterTaskExtension(project);, +, +        // There's a single Gradle instance for multi project builds, this means that some configuration needs to be, +        // done only once even if the plugin is applied multiple times as a part of multi project build, +        ExtraPropertiesExtension rootProperties = project.getRootProject().getExtensions().getExtraProperties();, +        if (rootProperties.has(PROPERTY_TESTCLUSTERS_RUN_ONCE) == false) {, +            rootProperties.set(PROPERTY_TESTCLUSTERS_RUN_ONCE, true);, +            // When running in the Daemon it's possible for this to hold references to past, +            usedClusters.clear();, +            claimsInventory.clear();, +            runningClusters.clear();, +, +            // When we know what tasks will run, we claim the clusters of those task to differentiate between clusters, +            // that are defined in the build script and the ones that will actually be used in this invocation of gradle, +            // we use this information to determine when the last task that required the cluster executed so that we can, +            // terminate the cluster right away and free up resources., +            configureClaimClustersHook(project);, +, +            // Before each task, we determine if a cluster needs to be started for that task., +            configureStartClustersHook(project);, +, +            // After each task we determine if there are clusters that are no longer needed., +            configureStopClustersHook(project);, +        }, +    }, +, +    private NamedDomainObjectContainer<ElasticsearchNode> createTestClustersContainerExtension(Project project) {, +        // Create an extensions that allows describing clusters, +        NamedDomainObjectContainer<ElasticsearchNode> container = project.container(, +            name -> new ElasticsearchNode(, +                name,, +                GradleServicesAdapter.getInstance(project), +            ), +        return container;, +    }, +, +    private void createListClustersTask(Project project, NamedDomainObjectContainer<ElasticsearchNode> container) {, +            container.forEach(cluster ->, +    }, +    private void createUseClusterTaskExtension(Project project) {, +                    new Closure<Void>(this, task) {, +                        public void doCall(ElasticsearchNode node) {, +                            usedClusters.computeIfAbsent(task, k -> new ArrayList<>()).add(node);]