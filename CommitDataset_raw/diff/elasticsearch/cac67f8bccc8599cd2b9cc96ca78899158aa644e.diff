[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportUnfollowAction.java, +import org.elasticsearch.index.IndexNotFoundException;, +        if (followerIMD == null) {, +            throw new IndexNotFoundException(followerIndex);, +        }, +, +        if (followerIMD.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY) == null) {, +            throw new IllegalArgumentException("index [" + followerIndex + "] is not a follower index");, +        }, +, +        if (followerIMD.getState() != IndexMetaData.State.CLOSE) {, +            throw new IllegalArgumentException("cannot convert the follower index [" + followerIndex +, +                "] to a non-follower, because it has not been closed");, +        }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportUnfollowAction.java, +import org.elasticsearch.index.IndexNotFoundException;, +        if (followerIMD == null) {, +            throw new IndexNotFoundException(followerIndex);, +        }, +, +        if (followerIMD.getCustomData(Ccr.CCR_CUSTOM_METADATA_KEY) == null) {, +            throw new IllegalArgumentException("index [" + followerIndex + "] is not a follower index");, +        }, +, +        if (followerIMD.getState() != IndexMetaData.State.CLOSE) {, +            throw new IllegalArgumentException("cannot convert the follower index [" + followerIndex +, +                "] to a non-follower, because it has not been closed");, +        }, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/TransportUnfollowActionTests.java, +import org.elasticsearch.index.IndexNotFoundException;, +    public void testUnfollowMissingIndex() {, +        IndexMetaData.Builder followerIndex = IndexMetaData.builder("follow_index"), +            .settings(settings(Version.CURRENT).put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)), +            .numberOfShards(1), +            .numberOfReplicas(0), +            .state(IndexMetaData.State.CLOSE), +            .putCustom(Ccr.CCR_CUSTOM_METADATA_KEY, new HashMap<>());, +, +        ClusterState current = ClusterState.builder(new ClusterName("cluster_name")), +            .metaData(MetaData.builder(), +                .put(followerIndex), +                .build()), +            .build();, +        expectThrows(IndexNotFoundException.class, () -> TransportUnfollowAction.unfollow("another_index", current));, +    }, +, +    public void testUnfollowNoneFollowIndex() {, +        IndexMetaData.Builder followerIndex = IndexMetaData.builder("follow_index"), +            .settings(settings(Version.CURRENT).put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true)), +            .numberOfShards(1), +            .numberOfReplicas(0), +            .state(IndexMetaData.State.CLOSE);, +, +        ClusterState current = ClusterState.builder(new ClusterName("cluster_name")), +            .metaData(MetaData.builder(), +                .put(followerIndex), +                .build()), +            .build();, +        expectThrows(IllegalArgumentException.class, () -> TransportUnfollowAction.unfollow("follow_index", current));, +    }, +]