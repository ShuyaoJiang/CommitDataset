[+++ b/docs/reference/index-modules/translog.asciidoc, +`index.translog.sync_interval`::, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.translog.sync_interval`::, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +--------------------------------------------------, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.translog.sync_interval`::, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +--------------------------------------------------, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +, +        // if the new cluster state has a new master then we cannot know if an index which is not in the cluster state, +        // is actually supposed to be deleted or imported as dangling instead. for example a new master might not have, +        // the index in its cluster state because it was started with an empty data folder and in this case we want to, +        // import as dangling. we check here for new master too to be on the safe side in this case., +        // norelease because we are not sure this is actually a good solution, +        // See discussion on https://github.com/elastic/elasticsearch/pull/9952, +        if (hasNewMaster() || previousState == null) {, +, +    /**, +     * Checks if this cluster state comes from a different master than the previous one., +     * This is a workaround for the scenario where a node misses a cluster state  that has either, +     * no master block or state not recovered flag set. In this case we must make sure that, +     * if an index is missing from the cluster state is not deleted immediately but instead imported, +     * as dangling. See discussion on https://github.com/elastic/elasticsearch/pull/9952, +     */, +    private boolean hasNewMaster() {, +        String oldMaster = previousState().getNodes().masterNodeId();, +        String newMaster = state().getNodes().masterNodeId();, +        if (oldMaster == null && newMaster == null) {, +            return false;, +        }, +        if (oldMaster == null && newMaster != null) {, +            return true;, +        }, +        return oldMaster.equals(newMaster) == false;, +    }, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.translog.sync_interval`::, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +--------------------------------------------------, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +, +        // if the new cluster state has a new master then we cannot know if an index which is not in the cluster state, +        // is actually supposed to be deleted or imported as dangling instead. for example a new master might not have, +        // the index in its cluster state because it was started with an empty data folder and in this case we want to, +        // import as dangling. we check here for new master too to be on the safe side in this case., +        // norelease because we are not sure this is actually a good solution, +        // See discussion on https://github.com/elastic/elasticsearch/pull/9952, +        if (hasNewMaster() || previousState == null) {, +, +    /**, +     * Checks if this cluster state comes from a different master than the previous one., +     * This is a workaround for the scenario where a node misses a cluster state  that has either, +     * no master block or state not recovered flag set. In this case we must make sure that, +     * if an index is missing from the cluster state is not deleted immediately but instead imported, +     * as dangling. See discussion on https://github.com/elastic/elasticsearch/pull/9952, +     */, +    private boolean hasNewMaster() {, +        String oldMaster = previousState().getNodes().masterNodeId();, +        String newMaster = state().getNodes().masterNodeId();, +        if (oldMaster == null && newMaster == null) {, +            return false;, +        }, +        if (oldMaster == null && newMaster != null) {, +            return true;, +        }, +        return oldMaster.equals(newMaster) == false;, +    }, +++ b/src/main/java/org/elasticsearch/common/io/Channels.java, +, +    /**, +     * read from a file channel into a byte buffer, starting at a certain position.  An EOFException will be thrown if you, +     * attempt to read beyond the end of file., +     *, +     * @param channel         channel to read from, +     * @param channelPosition position to read from, +     * @param dest            destination {@link java.nio.ByteBuffer} to put data in, +     */, +    public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException {, +        int read = readFromFileChannel(channel, channelPosition, dest);, +        if (read < 0) {, +            throw new EOFException("read past EOF. pos [" + channelPosition + "] length: [" + dest.limit() + "] end: [" + channel.size() + "]");, +        }, +    }, +, +++ b/docs/reference/index-modules/translog.asciidoc, +`index.translog.sync_interval`::, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +--------------------------------------------------, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +, +        // if the new cluster state has a new master then we cannot know if an index which is not in the cluster state, +        // is actually supposed to be deleted or imported as dangling instead. for example a new master might not have, +        // the index in its cluster state because it was started with an empty data folder and in this case we want to, +        // import as dangling. we check here for new master too to be on the safe side in this case., +        // norelease because we are not sure this is actually a good solution, +        // See discussion on https://github.com/elastic/elasticsearch/pull/9952, +        if (hasNewMaster() || previousState == null) {]