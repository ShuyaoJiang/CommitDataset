[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnPrimary;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnReplica;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnPrimary;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnReplica;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected PrimaryOperationResult<BulkShardResponse> onPrimaryShard(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new PrimaryOperationResult<>(response, location);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard primary,, +                                                     Translog.Location location, int requestIndex) throws Exception {, +            DocWriteRequest itemRequest = request.items()[requestIndex].request();, +            final PrimaryOperationResult<? extends DocWriteResponse> primaryOperationResult;, +            switch (itemRequest.opType()) {, +                case CREATE:, +                case INDEX:, +                    primaryOperationResult = executeIndexRequestOnPrimary(((IndexRequest) itemRequest), primary, mappingUpdatedAction);, +                    break;, +                case UPDATE:, +                    int maxAttempts = ((UpdateRequest) itemRequest).retryOnConflict();, +                    PrimaryOperationResult<? extends DocWriteResponse> shardUpdateOperation = null;, +                    for (int attemptCount = 0; attemptCount <= maxAttempts; attemptCount++) {, +                        shardUpdateOperation = shardUpdateOperation(metaData, primary, request, requestIndex, ((UpdateRequest) itemRequest));, +                        if (shardUpdateOperation.success(), +                                || shardUpdateOperation.getFailure() instanceof VersionConflictEngineException == false) {, +                            break;, +                        }, +                    }, +                    if (shardUpdateOperation == null) {, +                        throw new IllegalStateException("version conflict exception should bubble up on last attempt");, +                    }, +                    primaryOperationResult = shardUpdateOperation;, +                    break;, +                case DELETE:, +                    primaryOperationResult = executeDeleteRequestOnPrimary(((DeleteRequest) itemRequest), primary);, +                    break;, +                default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +            }, +            if (primaryOperationResult.success()) {, +                if (primaryOperationResult.getLocation() != null) {, +                    location = locationToSync(location, primaryOperationResult.getLocation());, +                    assert primaryOperationResult.getResponse().getResult() == DocWriteResponse.Result.NOOP, +                setResponse(item, new BulkItemResponse(item.id(), opType, primaryOperationResult.getResponse()));, +            } else {, +                BulkItemRequest item = request.items()[requestIndex];, +                DocWriteRequest docWriteRequest = item.request();, +                Exception failure = primaryOperationResult.getFailure();, +                if (isConflictException(failure)) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                } else {, +                    logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                }, +                // if its a conflict failure, and we already executed the request on a primary (and we execute it, +                // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +                // then just use the response we got from the successful execution, +                if (item.getPrimaryResponse() != null && isConflictException(failure)) {, +                    setResponse(item, item.getPrimaryResponse());, +                } else {, +                    setResponse(item, new BulkItemResponse(item.id(), docWriteRequest.opType(),, +                            new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), failure)));, +                }, +            }, +                throw e;, +            // TODO: maybe this assert is too strict, we can still get environment failures while executing write operations, +            assert false : "unexpected exception: " + e.getMessage() + " class:" + e.getClass().getSimpleName();, +    private PrimaryOperationResult<? extends DocWriteResponse> shardUpdateOperation(IndexMetaData metaData, IndexShard primary,, +        final UpdateHelper.Result translate;, +        try {, +            translate = updateHelper.prepare(updateRequest, primary, threadPool::estimatedTimeInMillis);, +        } catch (Exception e) {, +            return new PrimaryOperationResult<>(e);, +        }, +                PrimaryOperationResult<IndexResponse> writeResult = executeIndexRequestOnPrimary(indexRequest, primary, mappingUpdatedAction);, +                if (writeResult.success()) {, +                    return new PrimaryOperationResult<>(update, writeResult.getLocation());, +                } else {, +                    return writeResult;, +                }, +                PrimaryOperationResult<DeleteResponse> deleteResult = executeDeleteRequestOnPrimary(deleteRequest, primary);, +                if (deleteResult.success()) {, +                    return new PrimaryOperationResult<>(deleteUpdateResponse, deleteResult.getLocation());, +                } else {, +                    return deleteResult;, +                }, +                primary.noopUpdate(updateRequest.type());, +                return new PrimaryOperationResult<>(translate.action(), null);, +    protected ReplicaOperationResult onReplicaShard(BulkShardRequest request, IndexShard replica) throws Exception {, +            final ReplicaOperationResult replicaResult;]