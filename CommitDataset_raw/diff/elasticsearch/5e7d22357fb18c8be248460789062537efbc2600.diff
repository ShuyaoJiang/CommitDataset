[+++ b/core/src/main/java/org/elasticsearch/cluster/NodeConnectionsService.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.concurrent.CountDownLatch;, +    public void connectToNodes(DiscoveryNodes discoveryNodes) {, +        CountDownLatch latch = new CountDownLatch(discoveryNodes.getSize());, +            final boolean connected;, +                connected = transportService.nodeConnected(node);, +            if (connected) {, +                latch.countDown();, +            } else {, +                // spawn to another thread to do in parallel, +                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Exception e) {, +                        // both errors and rejections are logged here. the service, +                        // will try again after `cluster.nodes.reconnect_interval` on all nodes but the current master., +                        // On the master, node fault detection will remove these nodes from the cluster as their are not, +                        // connected. Note that it is very rare that we end up here on the master., +                        logger.warn((Supplier<?>) () -> new ParameterizedMessage("failed to connect to {}", node), e);, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        try (Releasable ignored = nodeLocks.acquire(node)) {, +                            validateAndConnectIfNeeded(node);, +                        }, +                    }, +, +                    @Override, +                    public void onAfter() {, +                        latch.countDown();, +                    }, +                });, +            }, +        }, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +    public void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep) {, +    void validateAndConnectIfNeeded(DiscoveryNode node) {, +        assert nodeLocks.isHeldByCurrentThread(node) : "validateAndConnectIfNeeded must be called under lock";, +                    validateAndConnectIfNeeded(node);, +++ b/core/src/main/java/org/elasticsearch/cluster/NodeConnectionsService.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.concurrent.CountDownLatch;, +    public void connectToNodes(DiscoveryNodes discoveryNodes) {, +        CountDownLatch latch = new CountDownLatch(discoveryNodes.getSize());, +            final boolean connected;, +                connected = transportService.nodeConnected(node);, +            if (connected) {, +                latch.countDown();, +            } else {, +                // spawn to another thread to do in parallel, +                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Exception e) {, +                        // both errors and rejections are logged here. the service, +                        // will try again after `cluster.nodes.reconnect_interval` on all nodes but the current master., +                        // On the master, node fault detection will remove these nodes from the cluster as their are not, +                        // connected. Note that it is very rare that we end up here on the master., +                        logger.warn((Supplier<?>) () -> new ParameterizedMessage("failed to connect to {}", node), e);, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        try (Releasable ignored = nodeLocks.acquire(node)) {, +                            validateAndConnectIfNeeded(node);, +                        }, +                    }, +, +                    @Override, +                    public void onAfter() {, +                        latch.countDown();, +                    }, +                });, +            }, +        }, +        try {, +            latch.await();, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +    public void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep) {, +    void validateAndConnectIfNeeded(DiscoveryNode node) {, +        assert nodeLocks.isHeldByCurrentThread(node) : "validateAndConnectIfNeeded must be called under lock";, +                    validateAndConnectIfNeeded(node);, +++ b/core/src/test/java/org/elasticsearch/cluster/NodeConnectionsServiceTests.java, +import org.elasticsearch.threadpool.TestThreadPool;, +    private ThreadPool threadPool;, +        NodeConnectionsService service = new NodeConnectionsService(Settings.EMPTY, threadPool, transportService);, +        NodeConnectionsService service = new NodeConnectionsService(Settings.EMPTY, threadPool, transportService);, +        service.connectToNodes(event.state().nodes());, +        this.threadPool = new TestThreadPool(getClass().getName());, +        transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR,, +        ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);, +        threadPool = null;, +++ b/core/src/main/java/org/elasticsearch/cluster/NodeConnectionsService.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import java.util.concurrent.CountDownLatch;, +    public void connectToNodes(DiscoveryNodes discoveryNodes) {]