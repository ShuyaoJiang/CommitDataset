[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                    rename { "${project.archivesBaseName}-${project.version}.pom" }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                    rename { "${project.archivesBaseName}-${project.version}.pom" }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +import nebula.plugin.info.scm.ScmInfoPlugin, +import org.gradle.api.InvalidUserDataException, +import org.gradle.api.Task, +import org.gradle.api.XmlProvider, +import java.nio.file.Files, +import java.nio.file.Path, +import java.nio.file.StandardCopyOption, +            if (project.pluginProperties.extension.hasClientJar) {, +                // for plugins which work with the transport client, we copy the jar, +                // file to a new name, copy the nebula generated pom to the same name,, +                // and generate a different pom for the zip, +                addClientJarPomGeneration(project), +                addClientJarTask(project), +            }, +            // while the jar isn't normally published, we still at least build a pom of deps, +            // in case it is published, for instance when other plugins extend this plugin, +            configureJarPom(project), +    protected static void addClientJarTask(Project project) {, +        Task clientJar = project.tasks.create('clientJar'), +        clientJar.dependsOn(project.jar, project.tasks.generatePomFileForClientJarPublication, project.javadocJar, project.sourcesJar), +        clientJar.doFirst {, +            Path jarFile = project.jar.outputs.files.singleFile.toPath(), +            String clientFileName = jarFile.fileName.toString().replace(project.version, "client-${project.version}"), +            Files.copy(jarFile, jarFile.resolveSibling(clientFileName), StandardCopyOption.REPLACE_EXISTING), +, +            String clientPomFileName = clientFileName.replace('.jar', '.pom'), +            Files.copy(, +                    project.tasks.generatePomFileForClientJarPublication.outputs.files.singleFile.toPath(),, +                    jarFile.resolveSibling(clientPomFileName),, +                    StandardCopyOption.REPLACE_EXISTING, +            ), +, +            String sourcesFileName = jarFile.fileName.toString().replace('.jar', '-sources.jar'), +            String clientSourcesFileName = clientFileName.replace('.jar', '-sources.jar'), +            Files.copy(jarFile.resolveSibling(sourcesFileName), jarFile.resolveSibling(clientSourcesFileName),, +                    StandardCopyOption.REPLACE_EXISTING), +, +            String javadocFileName = jarFile.fileName.toString().replace('.jar', '-javadoc.jar'), +            String clientJavadocFileName = clientFileName.replace('.jar', '-javadoc.jar'), +            Files.copy(jarFile.resolveSibling(javadocFileName), jarFile.resolveSibling(clientJavadocFileName),, +                    StandardCopyOption.REPLACE_EXISTING), +        }, +        project.assemble.dependsOn(clientJar), +    }, +        project.plugins.apply(MavenPublishPlugin.class), +, +        project.publishing {, +            publications {, +                clientJar(MavenPublication) {, +                    from project.components.java, +                    artifactId = project.pluginProperties.extension.name + '-client', +                    pom.withXml { XmlProvider xml ->, +                        Node root = xml.asNode(), +                        root.appendNode('name', project.pluginProperties.extension.name), +                        root.appendNode('description', project.pluginProperties.extension.description), +                        root.appendNode('url', urlFromOrigin(project.scminfo.origin)), +                        Node scmNode = root.appendNode('scm'), +                        scmNode.appendNode('url', project.scminfo.origin), +                    }, +                }, +            }, +        }, +    protected static void configureJarPom(Project project) {, +        project.plugins.apply(ScmInfoPlugin.class), +        project.plugins.apply(MavenPublishPlugin.class), +, +        project.publishing {, +            publications {, +                nebula(MavenPublication) {, +                    artifactId project.pluginProperties.extension.name, +                }, +            }, +        }, +    }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                    rename { "${project.archivesBaseName}-${project.version}.pom" }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +import nebula.plugin.info.scm.ScmInfoPlugin, +import org.gradle.api.InvalidUserDataException, +import org.gradle.api.Task, +import org.gradle.api.XmlProvider, +import java.nio.file.Files, +import java.nio.file.Path, +import java.nio.file.StandardCopyOption, +            if (project.pluginProperties.extension.hasClientJar) {, +                // for plugins which work with the transport client, we copy the jar, +                // file to a new name, copy the nebula generated pom to the same name,, +                // and generate a different pom for the zip, +                addClientJarPomGeneration(project), +                addClientJarTask(project), +            }, +            // while the jar isn't normally published, we still at least build a pom of deps, +            // in case it is published, for instance when other plugins extend this plugin, +            configureJarPom(project), +    protected static void addClientJarTask(Project project) {]