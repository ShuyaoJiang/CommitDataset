[+++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.gateway.MetaDataStateFormat;, +    /**, +     * Deletes the shards metadata state. This method can only be executed if the shard is not active., +     * @throws IOException if the delete fails, +     */, +    public void deleteShardState() throws IOException {, +        if (this.routingEntry() != null &&  this.routingEntry().active()) {, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on a active shard");, +        }, +        MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +    }, +, +            try {, +            } finally {, +                try {, +                    deleteShardState();, +                } catch (IOException e) {, +                    logger.warn("failed to delete shard state", e);, +                }, +            }, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.gateway.MetaDataStateFormat;, +    /**, +     * Deletes the shards metadata state. This method can only be executed if the shard is not active., +     * @throws IOException if the delete fails, +     */, +    public void deleteShardState() throws IOException {, +        if (this.routingEntry() != null &&  this.routingEntry().active()) {, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on a active shard");, +        }, +        MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +    }, +, +            try {, +            } finally {, +                try {, +                    deleteShardState();, +                } catch (IOException e) {, +                    logger.warn("failed to delete shard state", e);, +                }, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                recoveryStatus.indexShard().deleteShardState(); // we have to delete it first since even if we fail to rename the shard might be invalid, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.gateway.MetaDataStateFormat;, +    /**, +     * Deletes the shards metadata state. This method can only be executed if the shard is not active., +     * @throws IOException if the delete fails, +     */, +    public void deleteShardState() throws IOException {, +        if (this.routingEntry() != null &&  this.routingEntry().active()) {, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on a active shard");, +        }, +        MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +    }, +, +            try {, +            } finally {, +                try {, +                    deleteShardState();, +                } catch (IOException e) {, +                    logger.warn("failed to delete shard state", e);, +                }, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                recoveryStatus.indexShard().deleteShardState(); // we have to delete it first since even if we fail to rename the shard might be invalid, +++ b/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import java.io.IOException;, +    }, +, +    public void testDeleteShardState() throws IOException {, +        createIndex("test");, +        ensureGreen();, +        IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        NodeEnvironment env = getInstanceFromNode(NodeEnvironment.class);, +        IndexService test = indicesService.indexService("test");, +        IndexShard shard = test.shard(0);, +        try {, +            shard.deleteShardState();, +            fail("shard is active metadata delete must fail");, +        } catch (ElasticsearchIllegalStateException ex) {, +            // fine - only delete if non-active, +        }, +, +        ShardRouting routing = shard.routingEntry();, +        ShardStateMetaData shardStateMetaData = ShardStateMetaData.load(logger, shard.shardId, env.shardPaths(shard.shardId));, +        assertEquals(shardStateMetaData, getShardStateMetadata(shard));, +, +        routing = new MutableShardRouting(shard.shardId.index().getName(), shard.shardId.id(), routing.currentNodeId(), routing.primary(), ShardRoutingState.INITIALIZING, shard.shardRouting.version()+1);, +        shard.updateRoutingEntry(routing, true);, +        shard.deleteShardState();, +, +        assertNull("no shard state expected after delete on initializing", ShardStateMetaData.load(logger, shard.shardId, env.shardPaths(shard.shardId)));, +, +, +]