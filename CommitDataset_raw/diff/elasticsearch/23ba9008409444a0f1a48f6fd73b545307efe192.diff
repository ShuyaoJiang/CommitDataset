[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java, +            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {, +            });, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java, +            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {, +            });, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +        publishRequest.getAcceptedState().getNodes().mastersFirstStream().forEach(n -> publicationTargets.add(new PublicationTarget(n)));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java, +            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {, +            });, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +        publishRequest.getAcceptedState().getNodes().mastersFirstStream().forEach(n -> publicationTargets.add(new PublicationTarget(n)));, +++ b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +import java.util.stream.Stream;, +     * Returns a stream of all nodes, with master nodes at the front, +     */, +    public Stream<DiscoveryNode> mastersFirstStream() {, +        return Stream.concat(StreamSupport.stream(masterNodes.spliterator(), false).map(cur -> cur.value),, +            StreamSupport.stream(this.spliterator(), false).filter(n -> n.isMasterNode() == false));, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java, +            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {, +            });, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +        publishRequest.getAcceptedState().getNodes().mastersFirstStream().forEach(n -> publicationTargets.add(new PublicationTarget(n)));, +++ b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +import java.util.stream.Stream;, +     * Returns a stream of all nodes, with master nodes at the front, +     */, +    public Stream<DiscoveryNode> mastersFirstStream() {, +        return Stream.concat(StreamSupport.stream(masterNodes.spliterator(), false).map(cur -> cur.value),, +            StreamSupport.stream(this.spliterator(), false).filter(n -> n.isMasterNode() == false));, +    }, +, +    /**, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java, +import org.elasticsearch.test.transport.CapturingTransport;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +import static org.mockito.Mockito.mock;, +    private void testPreferMasterNodes() {, +        List<DiscoveryNode> nodes = randomNodes(10);, +        DiscoveryNodes.Builder discoNodesBuilder = DiscoveryNodes.builder();, +        nodes.forEach(dn -> discoNodesBuilder.add(dn));, +        DiscoveryNodes discoveryNodes = discoNodesBuilder.localNodeId(nodes.get(0).getId()).build();, +        CapturingTransport capturingTransport = new CapturingTransport();, +        TransportService transportService = capturingTransport.createTransportService(Settings.EMPTY, mock(ThreadPool.class),, +            TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> nodes.get(0), null, emptySet());, +        final FollowersChecker followersChecker = new FollowersChecker(Settings.EMPTY, transportService, fcr -> {, +            assert false : fcr;, +        }, (node, reason) -> {, +            assert false : node;, +        });, +        followersChecker.setCurrentNodes(discoveryNodes);, +        List<DiscoveryNode> followerTargets = Stream.of(capturingTransport.getCapturedRequestsAndClear()), +            .map(cr -> cr.node).collect(Collectors.toList());, +        List<DiscoveryNode> sortedFollowerTargets = new ArrayList<>(followerTargets);, +        Collections.sort(sortedFollowerTargets, Comparator.comparing(n -> n.isMasterNode() == false));, +        assertEquals(sortedFollowerTargets, followerTargets);, +    }, +, +    private static List<DiscoveryNode> randomNodes(final int numNodes) {, +        List<DiscoveryNode> nodesList = new ArrayList<>();, +        for (int i = 0; i < numNodes; i++) {, +            Map<String, String> attributes = new HashMap<>();, +            if (frequently()) {, +                attributes.put("custom", randomBoolean() ? "match" : randomAlphaOfLengthBetween(3, 5));, +            }, +            final DiscoveryNode node = newNode(i, attributes,, +                new HashSet<>(randomSubsetOf(Arrays.asList(DiscoveryNode.Role.values()))));, +            nodesList.add(node);, +        }, +        return nodesList;, +    }, +, +    private static DiscoveryNode newNode(int nodeId, Map<String, String> attributes, Set<DiscoveryNode.Role> roles) {, +        return new DiscoveryNode("name_" + nodeId, "node_" + nodeId, buildNewFakeTransportAddress(), attributes, roles,, +            Version.CURRENT);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java, +            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {, +            });, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +        publishRequest.getAcceptedState().getNodes().mastersFirstStream().forEach(n -> publicationTargets.add(new PublicationTarget(n)));, +++ b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +import java.util.stream.Stream;, +     * Returns a stream of all nodes, with master nodes at the front, +     */]