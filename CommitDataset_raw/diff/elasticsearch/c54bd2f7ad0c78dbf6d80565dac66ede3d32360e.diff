[+++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.store.*;, +     * a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has, +     * the given segments file., +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +        }, +    /**, +     * This method removes all lucene files from the given directory. It will first try to delete all commit points / segments, +     * files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted, +     * this operation fails., +     */, +    public static void cleanLuceneIndex(Directory directory) throws IOException {, +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +            for (final String file : directory.listAll()) {, +                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +                    directory.deleteFile(file); // remove all segment_N files, +                }, +            }, +        }, +        try (IndexWriter _ = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER), +                .setMergePolicy(NoMergePolicy.INSTANCE) // no merges, +                .setCommitOnClose(false) // no commits, +                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) // force creation - don't append..., +        {, +            // do nothing and close this will kick of IndexFileDeleter which will remove all pending files, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.store.*;, +     * a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has, +     * the given segments file., +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +        }, +    /**, +     * This method removes all lucene files from the given directory. It will first try to delete all commit points / segments, +     * files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted, +     * this operation fails., +     */, +    public static void cleanLuceneIndex(Directory directory) throws IOException {, +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +            for (final String file : directory.listAll()) {, +                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +                    directory.deleteFile(file); // remove all segment_N files, +                }, +            }, +        }, +        try (IndexWriter _ = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER), +                .setMergePolicy(NoMergePolicy.INSTANCE) // no merges, +                .setCommitOnClose(false) // no commits, +                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) // force creation - don't append..., +        {, +            // do nothing and close this will kick of IndexFileDeleter which will remove all pending files, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +                if (existingFile.equals(IndexWriter.WRITE_LOCK_NAME) || Store.isChecksum(existingFile) || sourceMetaData.contains(existingFile)) {, +                    continue; // don't delete snapshot file, or the checksums file (note, this is extra protection since the Store won't delete checksum), +                }, +                    // FNF should not happen since we hold a write lock?, +                } catch (IOException ex) {, +                    if (existingFile.startsWith(IndexFileNames.SEGMENTS), +                        || existingFile.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +                        // TODO do we need to also fail this if we can't delete the pending commit file?, +                        // if one of those files can't be deleted we better fail the cleanup otherwise we might leave an old commit point around?, +                        throw new ElasticsearchIllegalStateException("Can't delete " + existingFile + " - cleanup failed", ex);, +                    }, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.store.*;, +     * a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has, +     * the given segments file., +        try (Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +            if (!writeLock.obtain(IndexWriterConfig.getDefaultWriteLockTimeout())) { // obtain write lock, +                throw new LockObtainFailedException("Index locked for write: " + writeLock);, +            }, +                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {, +        }]