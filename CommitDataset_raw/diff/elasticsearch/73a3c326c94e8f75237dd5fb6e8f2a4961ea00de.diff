[+++ b/build.gradle, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.SourceToParse;, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +        processAfter(request.refresh(), indexShard, location);, +    private WriteResult shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +, +        return executeIndexRequestOnPrimary(indexRequest, indexShard);, +    }, +, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.PRIMARY);, +        indexShard.delete(delete);, +        // update the request with the version so it will go to the replicas, +        deleteRequest.versionType(delete.versionType().versionTypeForReplicationAndRecovery());, +        deleteRequest.version(delete.version());, +, +        assert deleteRequest.versionType().validateVersionForWrites(deleteRequest.version());, +, +        DeleteResponse deleteResponse = new DeleteResponse(request.index(), deleteRequest.type(), deleteRequest.id(), delete.version(), delete.found());, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +                    WriteResult result = shardDeleteOperation(bulkShardRequest, deleteRequest, indexShard);, +                    SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, indexRequest.source()).index(shardId.getIndex()).type(indexRequest.type()).id(indexRequest.id()), +                            .routing(indexRequest.routing()).parent(indexRequest.parent()).timestamp(indexRequest.timestamp()).ttl(indexRequest.ttl());, +, +                    final Engine.Index operation = indexShard.prepareIndex(sourceToParse, indexRequest.version(), indexRequest.versionType(), Engine.Operation.Origin.REPLICA);, +                    Mapping update = operation.parsedDoc().dynamicMappingsUpdate();, +                    if (update != null) {, +                        throw new RetryOnReplicaException(shardId, "Mappings are not available on the replica yet, triggered update: " + update);, +                    }, +                    indexShard.index(operation);, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.REPLICA);, +        processAfter(request.refresh(), indexShard, location);, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.SourceToParse;, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +        processAfter(request.refresh(), indexShard, location);, +    private WriteResult shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +, +        return executeIndexRequestOnPrimary(indexRequest, indexShard);, +    }, +, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.PRIMARY);, +        indexShard.delete(delete);, +        // update the request with the version so it will go to the replicas, +        deleteRequest.versionType(delete.versionType().versionTypeForReplicationAndRecovery());, +        deleteRequest.version(delete.version());, +, +        assert deleteRequest.versionType().validateVersionForWrites(deleteRequest.version());, +, +        DeleteResponse deleteResponse = new DeleteResponse(request.index(), deleteRequest.type(), deleteRequest.id(), delete.version(), delete.found());, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +                    WriteResult result = shardDeleteOperation(bulkShardRequest, deleteRequest, indexShard);, +                    SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, indexRequest.source()).index(shardId.getIndex()).type(indexRequest.type()).id(indexRequest.id()), +                            .routing(indexRequest.routing()).parent(indexRequest.parent()).timestamp(indexRequest.timestamp()).ttl(indexRequest.ttl());, +, +                    final Engine.Index operation = indexShard.prepareIndex(sourceToParse, indexRequest.version(), indexRequest.versionType(), Engine.Operation.Origin.REPLICA);, +                    Mapping update = operation.parsedDoc().dynamicMappingsUpdate();, +                    if (update != null) {, +                        throw new RetryOnReplicaException(shardId, "Mappings are not available on the replica yet, triggered update: " + update);, +                    }, +                    indexShard.index(operation);, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.REPLICA);, +        processAfter(request.refresh(), indexShard, location);, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +        Engine.Delete delete = indexShard.prepareDelete(request.type(), request.id(), request.version(), request.versionType(), Engine.Operation.Origin.PRIMARY);, +        processAfter(request.refresh(), indexShard, delete.getTranslogLocation());, +        DeleteResponse response = new DeleteResponse(shardRequest.shardId.getIndex(), request.type(), request.id(), delete.version(), delete.found());, +        return new Tuple<>(response, shardRequest.request);, +        Engine.Delete delete = indexShard.prepareDelete(request.type(), request.id(), request.version(), request.versionType(), Engine.Operation.Origin.REPLICA);, +, +        indexShard.delete(delete);, +        processAfter(request.refresh(), indexShard, delete.getTranslogLocation());, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.SourceToParse;, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +        processAfter(request.refresh(), indexShard, location);, +    private WriteResult shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +, +        return executeIndexRequestOnPrimary(indexRequest, indexShard);, +    }, +, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.PRIMARY);, +        indexShard.delete(delete);, +        // update the request with the version so it will go to the replicas, +        deleteRequest.versionType(delete.versionType().versionTypeForReplicationAndRecovery());, +        deleteRequest.version(delete.version());]