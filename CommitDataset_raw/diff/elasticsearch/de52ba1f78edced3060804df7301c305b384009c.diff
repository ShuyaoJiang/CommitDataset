[+++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/RollupDocumentationIT.java, +        // stop job to prevent spamming exceptions on next start request, +        StopRollupJobRequest stopRequest = new StopRollupJobRequest(id);, +        stopRequest.waitForCompletion();, +        stopRequest.timeout(TimeValue.timeValueSeconds(10));, +, +        StopRollupJobResponse response = client.rollup().stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +, +        response = rc.stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/RollupDocumentationIT.java, +        // stop job to prevent spamming exceptions on next start request, +        StopRollupJobRequest stopRequest = new StopRollupJobRequest(id);, +        stopRequest.waitForCompletion();, +        stopRequest.timeout(TimeValue.timeValueSeconds(10));, +, +        StopRollupJobResponse response = client.rollup().stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +, +        response = rc.stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java, +            logger.warn("Schedule was triggered for job [" + getJobId() + "], but prior indexer is still running " +, +                "(with state [" + currentState + "]");, +            doSaveState(finishAndSetState(), getPosition(), () -> {});, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/RollupDocumentationIT.java, +        // stop job to prevent spamming exceptions on next start request, +        StopRollupJobRequest stopRequest = new StopRollupJobRequest(id);, +        stopRequest.waitForCompletion();, +        stopRequest.timeout(TimeValue.timeValueSeconds(10));, +, +        StopRollupJobResponse response = client.rollup().stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +, +        response = rc.stopRollupJob(stopRequest, RequestOptions.DEFAULT);, +        assertTrue(response.isAcknowledged());, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java, +            logger.warn("Schedule was triggered for job [" + getJobId() + "], but prior indexer is still running " +, +                "(with state [" + currentState + "]");, +            doSaveState(finishAndSetState(), getPosition(), () -> {});, +++ b/x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/action/TransportStopRollupAction.java, +                                    + "] while waiting for rollup job [" + request.getId() + "] to stop. State was [", +                                    + ((RollupJobStatus) jobTask.getStatus()).getIndexerState() + "]"));, +                        } catch (Exception e) {, +                            listener.onFailure(new ElasticsearchTimeoutException("Encountered unexpected error while waiting for " +, +                                "rollup job [" + request.getId() + "] to stop.  State was [", +                                + ((RollupJobStatus) jobTask.getStatus()).getIndexerState() + "].", e));]