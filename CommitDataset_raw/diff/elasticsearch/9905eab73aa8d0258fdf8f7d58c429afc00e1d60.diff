[+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +            if (request.indexRequest() == null) {, +            IndexRequest indexRequest = request.indexRequest();, +            indexRequest.index(request.index()).type(request.type()).id(request.id()), +                    // it has to be a "create!", +                    .create(true), +                    .routing(request.routing()), +                    .percolate(request.percolate()), +                    .refresh(request.refresh()), +                    .replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());, +            indexRequest.operationThreaded(false);, +            // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request, +            final BytesHolder updateSourceBytes = indexRequest.underlyingSourceBytes();, +            indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {, +                @Override, +                public void onResponse(IndexResponse response) {, +                    UpdateResponse update = new UpdateResponse(response.index(), response.type(), response.id(), response.version());, +                    update.matches(response.matches());, +                    // TODO: we can parse the index _source and extractGetResult if applicable, +                    update.getResult(null);, +                    listener.onResponse(update);, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    e = ExceptionsHelper.unwrapCause(e);, +                    if (e instanceof VersionConflictEngineException) {, +                        if (retryCount < request.retryOnConflict()) {, +                            threadPool.executor(executor()).execute(new Runnable() {, +                                @Override, +                                public void run() {, +                                    shardOperation(request, listener, retryCount + 1);, +                                }, +                            });, +                            return;, +                        }, +                    }, +                    listener.onFailure(e);, +                }, +            });, +            return;, +        }, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +            if (request.indexRequest() == null) {, +            IndexRequest indexRequest = request.indexRequest();, +            indexRequest.index(request.index()).type(request.type()).id(request.id()), +                    // it has to be a "create!", +                    .create(true), +                    .routing(request.routing()), +                    .percolate(request.percolate()), +                    .refresh(request.refresh()), +                    .replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());, +            indexRequest.operationThreaded(false);, +            // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request, +            final BytesHolder updateSourceBytes = indexRequest.underlyingSourceBytes();, +            indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {, +                @Override, +                public void onResponse(IndexResponse response) {, +                    UpdateResponse update = new UpdateResponse(response.index(), response.type(), response.id(), response.version());, +                    update.matches(response.matches());, +                    // TODO: we can parse the index _source and extractGetResult if applicable, +                    update.getResult(null);, +                    listener.onResponse(update);, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    e = ExceptionsHelper.unwrapCause(e);, +                    if (e instanceof VersionConflictEngineException) {, +                        if (retryCount < request.retryOnConflict()) {, +                            threadPool.executor(executor()).execute(new Runnable() {, +                                @Override, +                                public void run() {, +                                    shardOperation(request, listener, retryCount + 1);, +                                }, +                            });, +                            return;, +                        }, +                    }, +                    listener.onFailure(e);, +                }, +            });, +            return;, +        }, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +import org.elasticsearch.action.index.IndexRequest;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentType;, +    private IndexRequest indexRequest;, +, +    /**, +     * Sets the index request to be used if the document does not exists. Otherwise, a {@link org.elasticsearch.index.engine.DocumentMissingException}, +     * is thrown., +     */, +    public UpdateRequest doc(IndexRequest indexRequest) {, +        this.indexRequest = indexRequest;, +        return this;, +    }, +, +    /**]