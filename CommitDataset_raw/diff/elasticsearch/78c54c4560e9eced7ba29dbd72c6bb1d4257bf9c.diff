[+++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +    /**, +     * Find all the shards for this index, returning a map of the {@code NodePath} to the number of shards on that path, +     * @param index the index by which to filter shards, +     * @return a map of NodePath to count of the shards for the index on that path, +     * @throws IOException if an IOException occurs, +     */, +    public Map<NodePath, Long> shardCountPerPath(final Index index) throws IOException {, +        assert index != null;, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assertEnvIsLocked();, +        final Map<NodePath, Long> shardCountPerPath = new HashMap<>();, +        final String indexUniquePathId = index.getUUID();, +        for (final NodePath nodePath : nodePaths) {, +            Path indexLocation = nodePath.indicesPath.resolve(indexUniquePathId);, +            if (Files.isDirectory(indexLocation)) {, +                shardCountPerPath.put(nodePath, (long) findAllShardsForIndex(indexLocation, index).size());, +            }, +        }, +        return shardCountPerPath;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +    /**, +     * Find all the shards for this index, returning a map of the {@code NodePath} to the number of shards on that path, +     * @param index the index by which to filter shards, +     * @return a map of NodePath to count of the shards for the index on that path, +     * @throws IOException if an IOException occurs, +     */, +    public Map<NodePath, Long> shardCountPerPath(final Index index) throws IOException {, +        assert index != null;, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assertEnvIsLocked();, +        final Map<NodePath, Long> shardCountPerPath = new HashMap<>();, +        final String indexUniquePathId = index.getUUID();, +        for (final NodePath nodePath : nodePaths) {, +            Path indexLocation = nodePath.indicesPath.resolve(indexUniquePathId);, +            if (Files.isDirectory(indexLocation)) {, +                shardCountPerPath.put(nodePath, (long) findAllShardsForIndex(indexLocation, index).size());, +            }, +        }, +        return shardCountPerPath;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/ShardPath.java, +import java.util.Arrays;, +import java.util.HashMap;, +import java.util.List;, +import java.util.stream.Collectors;, +, +            // If no better path is chosen, use the one with the most space by default, +            NodeEnvironment.NodePath bestPath = getPathWithMostFreeSpace(env);, +, +            if (paths.length != 1) {, +                int shardCount = indexSettings.getNumberOfShards();, +                // Maximum number of shards that a path should have for a particular index assuming, +                // all the shards were assigned to this node. For example, with a node with 4 data, +                // paths and an index with 9 primary shards, the maximum number of shards per path, +                // would be 3., +                int maxShardsPerPath = Math.floorDiv(shardCount, paths.length) + ((shardCount % paths.length) == 0 ? 0 : 1);, +, +                Map<NodeEnvironment.NodePath, Long> pathToShardCount = env.shardCountPerPath(shardId.getIndex());, +, +                // Compute how much space there is on each path, +                final Map<NodeEnvironment.NodePath, BigInteger> pathsToSpace = new HashMap<>(paths.length);, +                    pathsToSpace.put(nodePath, usableBytes);, +                }, +                bestPath = Arrays.stream(paths), +                        // Filter out paths that have enough space, +                        .filter((path) -> pathsToSpace.get(path).subtract(estShardSizeInBytes).compareTo(BigInteger.ZERO) > 0), +                        // Sort by the number of shards for this index, +                        .sorted((p1, p2) -> {, +                                int cmp = Long.compare(pathToShardCount.getOrDefault(p1, 0L), pathToShardCount.getOrDefault(p2, 0L));, +                                if (cmp == 0) {, +                                    // if the number of shards is equal, tie-break with the usable bytes, +                                    cmp = pathsToSpace.get(p2).compareTo(pathsToSpace.get(p1));, +                                return cmp;, +                            }), +                        // Return the first result, +                        .findFirst(), +                        // Or the existing best path if there aren't any that fit the criteria, +                        .orElse(bestPath);, +    static NodeEnvironment.NodePath getPathWithMostFreeSpace(NodeEnvironment env) throws IOException {, +        final NodeEnvironment.NodePath[] paths = env.nodePaths();, +        NodeEnvironment.NodePath bestPath = null;, +        long maxUsableBytes = Long.MIN_VALUE;, +        for (NodeEnvironment.NodePath nodePath : paths) {, +            FileStore fileStore = nodePath.fileStore;, +            long usableBytes = fileStore.getUsableSpace();, +            assert usableBytes >= 0 : "usable bytes must be >= 0, got: " + usableBytes;, +, +            if (bestPath == null || usableBytes > maxUsableBytes) {, +                // This path has been determined to be "better" based on the usable bytes, +                maxUsableBytes = usableBytes;, +                bestPath = nodePath;, +            }]