[+++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +import java.util.Map;, +    final Map<String,PermissionCollection> plugins;, +    public ESPolicy(PermissionCollection dynamic, Map<String,PermissionCollection> plugins) throws Exception {, +        this.plugins = plugins;, +            // check for an additional plugin permission, +            PermissionCollection plugin = plugins.get(location.getFile());, +            if (plugin != null && plugin.implies(permission)) {, +                return true;, +            }, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +import java.util.Map;, +    final Map<String,PermissionCollection> plugins;, +    public ESPolicy(PermissionCollection dynamic, Map<String,PermissionCollection> plugins) throws Exception {, +        this.plugins = plugins;, +            // check for an additional plugin permission, +            PermissionCollection plugin = plugins.get(location.getFile());, +            if (plugin != null && plugin.implies(permission)) {, +                return true;, +            }, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +import org.elasticsearch.plugins.PluginInfo;, +import java.security.NoSuchAlgorithmException;, +import java.security.PermissionCollection;, +import java.security.URIParameter;, + * Scripts (groovy, javascript, python) are assigned minimal permissions. This does not provide adequate, + * JAVA_OPTS="-Djava.security.debug=access,failure" bin/elasticsearch, +        // enable security policy: union of template and environment-based paths, and possibly plugin permissions, +        Policy.setPolicy(new ESPolicy(createPermissions(environment), getPluginPermissions(environment)));, +    static Map<String,PermissionCollection> getPluginPermissions(Environment environment) throws IOException, NoSuchAlgorithmException {, +        Map<String,PermissionCollection> map = new HashMap<>();, +                    Path policyFile = plugin.resolve(PluginInfo.ES_PLUGIN_POLICY);, +                    if (Files.exists(policyFile)) {, +                        // parse the plugin's policy file into a set of permissions, +                        Policy policy = Policy.getInstance("JavaPolicy", new URIParameter(policyFile.toUri()));, +                        PermissionCollection permissions = policy.getPermissions(Security.class.getProtectionDomain());, +                        // this method is supported with the specific implementation we use, but just check for safety., +                        if (permissions == Policy.UNSUPPORTED_EMPTY_COLLECTION) {, +                            throw new UnsupportedOperationException("JavaPolicy implementation does not support retrieving permissions");, +                        // grant the permissions to each jar in the plugin, +                        try (DirectoryStream<Path> jarStream = Files.newDirectoryStream(plugin, "*.jar")) {, +                            for (Path jar : jarStream) {, +                                if (map.put(jar.toUri().toURL().getFile(), permissions) != null) {, +                                    // just be paranoid ok?, +                                    throw new IllegalStateException("per-plugin permissions already granted for jar file: " + jar);, +        return Collections.unmodifiableMap(map);, +    }, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +import java.util.Map;, +    final Map<String,PermissionCollection> plugins;, +    public ESPolicy(PermissionCollection dynamic, Map<String,PermissionCollection> plugins) throws Exception {, +        this.plugins = plugins;, +            // check for an additional plugin permission, +            PermissionCollection plugin = plugins.get(location.getFile());, +            if (plugin != null && plugin.implies(permission)) {, +                return true;, +            }, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +import org.elasticsearch.plugins.PluginInfo;, +import java.security.NoSuchAlgorithmException;, +import java.security.PermissionCollection;, +import java.security.URIParameter;, + * Scripts (groovy, javascript, python) are assigned minimal permissions. This does not provide adequate, + * JAVA_OPTS="-Djava.security.debug=access,failure" bin/elasticsearch, +        // enable security policy: union of template and environment-based paths, and possibly plugin permissions, +        Policy.setPolicy(new ESPolicy(createPermissions(environment), getPluginPermissions(environment)));, +    static Map<String,PermissionCollection> getPluginPermissions(Environment environment) throws IOException, NoSuchAlgorithmException {, +        Map<String,PermissionCollection> map = new HashMap<>();, +                    Path policyFile = plugin.resolve(PluginInfo.ES_PLUGIN_POLICY);, +                    if (Files.exists(policyFile)) {, +                        // parse the plugin's policy file into a set of permissions, +                        Policy policy = Policy.getInstance("JavaPolicy", new URIParameter(policyFile.toUri()));, +                        PermissionCollection permissions = policy.getPermissions(Security.class.getProtectionDomain());, +                        // this method is supported with the specific implementation we use, but just check for safety., +                        if (permissions == Policy.UNSUPPORTED_EMPTY_COLLECTION) {, +                            throw new UnsupportedOperationException("JavaPolicy implementation does not support retrieving permissions");, +                        // grant the permissions to each jar in the plugin, +                        try (DirectoryStream<Path> jarStream = Files.newDirectoryStream(plugin, "*.jar")) {, +                            for (Path jar : jarStream) {, +                                if (map.put(jar.toUri().toURL().getFile(), permissions) != null) {, +                                    // just be paranoid ok?, +                                    throw new IllegalStateException("per-plugin permissions already granted for jar file: " + jar);, +        return Collections.unmodifiableMap(map);, +    }, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.Future;, +import java.util.concurrent.FutureTask;, +        Map<K, Future<Entry<K, V>>> map = new HashMap<>();, +, +            Future<Entry<K, V>> future;, +            Entry<K, V> entry = null;, +                future = map.get(key);, +            if (future != null) {, +                try {, +                    entry = future.get();, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException("future should be a completedFuture for which get should not throw", e);, +                }, +                try {]