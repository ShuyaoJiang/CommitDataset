[+++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import org.apache.lucene.search.BooleanClause.Occur;, +            // This query has the same problem as boolean queries when it comes to duplicated terms, +            // So to keep things simple, we just rewrite to a boolean query, +            BooleanQuery.Builder builder = new BooleanQuery.Builder();, +                BooleanQuery.Builder subBuilder = new BooleanQuery.Builder();, +                for (Term term : termArr) {, +                    subBuilder.add(new TermQuery(term), Occur.SHOULD);, +                builder.add(subBuilder.build(), Occur.FILTER);, +            // Make sure to unverify the result, +            return booleanQuery().apply(builder.build(), version).unverify();, +                // This has the same problem as boolean queries when it comes to duplicated clauses, +                // so we rewrite to a boolean query to keep things simple., +                BooleanQuery.Builder builder = new BooleanQuery.Builder();, +                for (SpanQuery clause : spanNearQuery.getClauses()) {, +                    builder.add(clause, Occur.FILTER);, +                // make sure to unverify the result, +                return booleanQuery().apply(builder.build(), version).unverify();, +                Result bestClause = null;, +                    bestClause = selectBestResult(temp, bestClause);, +                return bestClause;, +            // handle it like a boolean query to not dulplicate eg. logic, +            // about duplicated terms, +            BooleanQuery.Builder builder = new BooleanQuery.Builder();, +                builder.add(clause, Occur.SHOULD);, +            return booleanQuery().apply(builder.build(), version);, +                    Result bestClause = null;, +                    boolean hasProhibitedClauses = false;, +                        if (clause.isProhibited()) {, +                            hasProhibitedClauses = true;, +                        }, +                        bestClause = selectBestResult(temp, bestClause);, +                        if (hasProhibitedClauses || minimumShouldMatch > 0) {, +                            bestClause = bestClause.unverify();, +                        }, +                        return bestClause;, +                            return new Result(true, Collections.emptySet(), 0);, +    /**, +     * Return an extraction for the conjunction of {@code result1} and {@code result2}, +     * by picking up clauses that look most restrictive and making it unverified if, +     * the other clause is not null and doesn't match all documents. This is used by, +     * 6.0.0 indices which didn't use the terms_set query., +     */, +    static Result selectBestResult(Result result1, Result result2) {, +        assert result1 != null || result2 != null;, +        if (result1 == null) {, +            return result2;, +        } else if (result2 == null) {, +            return result1;, +        } else if (result1.matchAllDocs) { // conjunction with match_all, +            Result result = result2;, +            if (result1.verified == false) {, +                result = result.unverify();, +            }, +            return result;, +        } else if (result2.matchAllDocs) { // conjunction with match_all, +            Result result = result1;, +            if (result2.verified == false) {, +                result = result.unverify();, +            }, +            return result;, +            for (QueryExtraction clause : result1.extractions) {, +            for (QueryExtraction clause : result2.extractions) {, +                BytesRef extraction1SmallestRange = smallestRange(result1.extractions);, +                BytesRef extraction2SmallestRange = smallestRange(result2.extractions);, +                    return result2.unverify();, +                    return result1.unverify();, +                    return result1.unverify();, +                    return result2.unverify();, +                int extraction1ShortestTerm = minTermLength(result1.extractions);, +                int extraction2ShortestTerm = minTermLength(result2.extractions);, +                    return result1.unverify();, +                    return result2.unverify();, +    /**, +     * Query extraction result. A result is a candidate for a given document either if:, +     *  - `matchAllDocs` is true, +     *  - `extractions` and the document have `minimumShouldMatch` terms in common, +     *  Further more, the match doesn't need to be verified if `verified` is true, checking, +     *  `matchAllDocs` and `extractions` is enough., +     */, +        private Result(boolean matchAllDocs, boolean verified, Set<QueryExtraction> extractions, int minimumShouldMatch) {, +            this.matchAllDocs = matchAllDocs;, +        }, +, +        Result(boolean verified, Set<QueryExtraction> extractions, int minimumShouldMatch) {, +            this(false, verified, extractions, minimumShouldMatch);, +            this(matchAllDocs, verified, Collections.emptySet(), 0);, +        Result unverify() {, +            if (verified) {, +                return new Result(matchAllDocs, false, extractions, minimumShouldMatch);, +            } else {, +                return this;, +            }, +        }, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import org.apache.lucene.search.BooleanClause.Occur;, +            // This query has the same problem as boolean queries when it comes to duplicated terms, +            // So to keep things simple, we just rewrite to a boolean query, +            BooleanQuery.Builder builder = new BooleanQuery.Builder();, +                BooleanQuery.Builder subBuilder = new BooleanQuery.Builder();]