[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import java.util.Map;, +            String objectPath = "";, +            String fieldPath = field;, +            int posDot = field.lastIndexOf('.');, +            if (posDot > 0) {, +                objectPath = field.substring(0, posDot);, +                context.path().add(objectPath);, +                mapper = context.docMapper().objectMappers().get(objectPath);, +                fieldPath = field.substring(posDot + 1);, +            }, +                //TODO: Create an object dynamically?, +                throw new MapperParsingException("attempt to copy value to non-existing object [" + field + "]");, +            ObjectMapper update = parseDynamicValue(context, mapper, fieldPath, context.parser().currentToken());, +            // propagate the update to the root, +            while (objectPath.length() > 0) {, +                String parentPath = "";, +                posDot = objectPath.lastIndexOf('.');, +                if (posDot > 0) {, +                    parentPath = objectPath.substring(0, posDot);, +                    parent = context.docMapper().objectMappers().get(parentPath);, +                if (parent == null) {, +                    throw new IllegalStateException("[" + objectPath + "] has no parent for path [" + parentPath + "]");, +                }, +                objectPath = parentPath;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import java.util.Map;, +            String objectPath = "";, +            String fieldPath = field;, +            int posDot = field.lastIndexOf('.');, +            if (posDot > 0) {, +                objectPath = field.substring(0, posDot);, +                context.path().add(objectPath);, +                mapper = context.docMapper().objectMappers().get(objectPath);, +                fieldPath = field.substring(posDot + 1);, +            }, +                //TODO: Create an object dynamically?, +                throw new MapperParsingException("attempt to copy value to non-existing object [" + field + "]");, +            ObjectMapper update = parseDynamicValue(context, mapper, fieldPath, context.parser().currentToken());, +            // propagate the update to the root, +            while (objectPath.length() > 0) {, +                String parentPath = "";, +                posDot = objectPath.lastIndexOf('.');, +                if (posDot > 0) {, +                    parentPath = objectPath.substring(0, posDot);, +                    parent = context.docMapper().objectMappers().get(parentPath);, +                if (parent == null) {, +                    throw new IllegalStateException("[" + objectPath + "] has no parent for path [" + parentPath + "]");, +                }, +                objectPath = parentPath;, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.common.Nullable;, +    protected boolean shardAvailable(@Nullable IndexShard shard) {, +        return shard != null && shard.canIndex() && CAN_UPDATE_INDEX_BUFFER_STATES.contains(shard.state());, +        if (shard != null) {, +            } catch (EngineClosedException e) {, +                // ignore, +            } catch (FlushNotAllowedEngineException e) {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import java.util.Map;, +            String objectPath = "";, +            String fieldPath = field;, +            int posDot = field.lastIndexOf('.');, +            if (posDot > 0) {, +                objectPath = field.substring(0, posDot);, +                context.path().add(objectPath);, +                mapper = context.docMapper().objectMappers().get(objectPath);, +                fieldPath = field.substring(posDot + 1);, +            }, +                //TODO: Create an object dynamically?, +                throw new MapperParsingException("attempt to copy value to non-existing object [" + field + "]");, +            ObjectMapper update = parseDynamicValue(context, mapper, fieldPath, context.parser().currentToken());, +            // propagate the update to the root, +            while (objectPath.length() > 0) {, +                String parentPath = "";, +                posDot = objectPath.lastIndexOf('.');, +                if (posDot > 0) {, +                    parentPath = objectPath.substring(0, posDot);, +                    parent = context.docMapper().objectMappers().get(parentPath);, +                if (parent == null) {, +                    throw new IllegalStateException("[" + objectPath + "] has no parent for path [" + parentPath + "]");, +                }, +                objectPath = parentPath;, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.common.Nullable;, +    protected boolean shardAvailable(@Nullable IndexShard shard) {, +        return shard != null && shard.canIndex() && CAN_UPDATE_INDEX_BUFFER_STATES.contains(shard.state());, +        if (shard != null) {, +            } catch (EngineClosedException e) {, +                // ignore, +            } catch (FlushNotAllowedEngineException e) {, +    }, +++ b/core/src/main/java/org/elasticsearch/search/highlight/AbstractHighlighterBuilder.java]