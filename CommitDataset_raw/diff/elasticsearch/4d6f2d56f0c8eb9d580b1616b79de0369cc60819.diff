[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.Collections;, +import java.util.LinkedHashMap;, +    // An LRU (don't really care about concurrency here) that holds the latest timed out requests so if they, +    // do show up, we can print more descriptive information about them, +    final Map<Long, TimeoutInfoHolder> timeoutInfoHandlers = Collections.synchronizedMap(new LinkedHashMap<Long, TimeoutInfoHolder>(100, .75F, true) {, +        protected boolean removeEldestEntry(Map.Entry eldest) {, +            return size() > 100;, +        }, +    });, +, +                // lets see if its in the timeout holder, +                TimeoutInfoHolder timeoutInfoHolder = timeoutInfoHandlers.remove(requestId);, +                if (timeoutInfoHolder != null) {, +                    logger.warn("Transport response handler timed out, action [{}], node [{}]", timeoutInfoHolder.action(), timeoutInfoHolder.node());, +                } else {, +                    logger.warn("Transport response handler not found of id [{}]", requestId);, +                }, +                // add it to the timeout information holder, in case we are going to get a response later, +                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(holder.node(), holder.action()));, +, +    static class TimeoutInfoHolder {, +, +        private final DiscoveryNode node;, +, +        private final String action;, +, +        TimeoutInfoHolder(DiscoveryNode node, String action) {, +            this.node = node;, +            this.action = action;, +        }, +, +        public DiscoveryNode node() {, +            return node;, +        }, +, +        public String action() {, +            return action;, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.Collections;, +import java.util.LinkedHashMap;, +    // An LRU (don't really care about concurrency here) that holds the latest timed out requests so if they, +    // do show up, we can print more descriptive information about them, +    final Map<Long, TimeoutInfoHolder> timeoutInfoHandlers = Collections.synchronizedMap(new LinkedHashMap<Long, TimeoutInfoHolder>(100, .75F, true) {, +        protected boolean removeEldestEntry(Map.Entry eldest) {, +            return size() > 100;, +        }, +    });, +, +                // lets see if its in the timeout holder, +                TimeoutInfoHolder timeoutInfoHolder = timeoutInfoHandlers.remove(requestId);, +                if (timeoutInfoHolder != null) {, +                    logger.warn("Transport response handler timed out, action [{}], node [{}]", timeoutInfoHolder.action(), timeoutInfoHolder.node());, +                } else {, +                    logger.warn("Transport response handler not found of id [{}]", requestId);, +                }, +                // add it to the timeout information holder, in case we are going to get a response later, +                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(holder.node(), holder.action()));, +, +    static class TimeoutInfoHolder {, +, +        private final DiscoveryNode node;, +, +        private final String action;, +, +        TimeoutInfoHolder(DiscoveryNode node, String action) {, +            this.node = node;, +            this.action = action;, +        }, +, +        public DiscoveryNode node() {, +            return node;, +        }, +, +        public String action() {, +            return action;, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +                // ignore if its null, the adapter logs it, +                if (handler != null) {, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.Collections;, +import java.util.LinkedHashMap;, +    // An LRU (don't really care about concurrency here) that holds the latest timed out requests so if they, +    // do show up, we can print more descriptive information about them, +    final Map<Long, TimeoutInfoHolder> timeoutInfoHandlers = Collections.synchronizedMap(new LinkedHashMap<Long, TimeoutInfoHolder>(100, .75F, true) {, +        protected boolean removeEldestEntry(Map.Entry eldest) {, +            return size() > 100;, +        }, +    });, +, +                // lets see if its in the timeout holder, +                TimeoutInfoHolder timeoutInfoHolder = timeoutInfoHandlers.remove(requestId);, +                if (timeoutInfoHolder != null) {]