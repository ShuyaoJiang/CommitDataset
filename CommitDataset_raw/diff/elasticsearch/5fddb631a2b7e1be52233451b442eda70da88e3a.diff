[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +    public static class WriteReplicaResult<ReplicaRequest extends ReplicatedWriteRequest<ReplicaRequest>>, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +    public static class WriteReplicaResult<ReplicaRequest extends ReplicatedWriteRequest<ReplicaRequest>>, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.seqno.RetentionLeaseSyncer;, +    public synchronized IndexShard createShard(, +            final ShardRouting routing,, +            final Consumer<ShardId> globalCheckpointSyncer,, +            final RetentionLeaseSyncer retentionLeaseSyncer) throws IOException {, +        Objects.requireNonNull(retentionLeaseSyncer);, +                    (retentionLeases, listener) -> retentionLeaseSyncer.syncRetentionLeasesForShard(shardId, retentionLeases, listener),, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +    public static class WriteReplicaResult<ReplicaRequest extends ReplicatedWriteRequest<ReplicaRequest>>, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.seqno.RetentionLeaseSyncer;, +    public synchronized IndexShard createShard(, +            final ShardRouting routing,, +            final Consumer<ShardId> globalCheckpointSyncer,, +            final RetentionLeaseSyncer retentionLeaseSyncer) throws IOException {, +        Objects.requireNonNull(retentionLeaseSyncer);, +                    (retentionLeases, listener) -> retentionLeaseSyncer.syncRetentionLeasesForShard(shardId, retentionLeases, listener),, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.replication.ReplicationResponse;, +import java.util.ArrayList;, +import java.util.function.BiConsumer;, +     * A callback when a new retention lease is created. In practice, this callback invokes the retention lease sync action, to sync, +     * retention leases to replicas., +     */, +    private final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease;, +, +    /**, +     * Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned., +     * Adds a new retention lease., +     * @param listener                the callback when the retention lease is successfully added and synced to replicas, +     * @return the new retention lease, +     * @throws IllegalArgumentException if the specified retention lease already exists, +    public RetentionLease addRetentionLease(, +            final String id,, +            final long retainingSequenceNumber,, +            final String source,, +            final ActionListener<ReplicationResponse> listener) {, +        Objects.requireNonNull(listener);, +        final RetentionLease retentionLease;, +        final Collection<RetentionLease> currentRetentionLeases;, +        synchronized (this) {, +            if (retentionLeases.containsKey(id)) {, +                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists");, +            }, +            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source);, +            retentionLeases.put(id, retentionLease);, +            currentRetentionLeases = retentionLeases.values();, +        }, +        onNewRetentionLease.accept(Collections.unmodifiableCollection(new ArrayList<>(currentRetentionLeases)), listener);, +        return retentionLease;, +    }, +, +    /**, +     * Renews an existing retention lease., +     *, +     * @param id                      the identifier of the retention lease, +     * @param retainingSequenceNumber the retaining sequence number, +     * @param source                  the source of the retention lease, +     * @return the renewed retention lease, +     * @throws IllegalArgumentException if the specified retention lease does not exist, +     */, +    public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {, +        assert primaryMode;, +        if (retentionLeases.containsKey(id) == false) {, +            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist");, +        }, +        final RetentionLease retentionLease =, +                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source);, +        final RetentionLease existingRetentionLease = retentionLeases.put(id, retentionLease);, +        assert existingRetentionLease != null;, +        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :, +                "retention lease renewal for [" + id + "]", +                        + " from [" + source + "]", +                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]", +                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]";, +        return retentionLease;, +     * @param onNewRetentionLease a callback when a new retention lease is created, +            final LongSupplier currentTimeMillisSupplier,, +            final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease) {, +        this.onNewRetentionLease = Objects.requireNonNull(onNewRetentionLease);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +    public static class WriteReplicaResult<ReplicaRequest extends ReplicatedWriteRequest<ReplicaRequest>>, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.index.seqno.RetentionLeaseSyncer;, +    public synchronized IndexShard createShard(, +            final ShardRouting routing,, +            final Consumer<ShardId> globalCheckpointSyncer,, +            final RetentionLeaseSyncer retentionLeaseSyncer) throws IOException {, +        Objects.requireNonNull(retentionLeaseSyncer);, +                    (retentionLeases, listener) -> retentionLeaseSyncer.syncRetentionLeasesForShard(shardId, retentionLeases, listener),, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.replication.ReplicationResponse;, +import java.util.ArrayList;]