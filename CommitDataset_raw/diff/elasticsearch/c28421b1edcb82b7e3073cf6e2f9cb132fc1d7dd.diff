[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFDecoder.java, +     * Main decode from a stream.  Decompressed bytes are placed in the outputBuffer, inputBuffer, +     * is a "scratch-area"., +     * <p>, +     * If no, +        /* note: we do NOT read more than 5 bytes because otherwise might need to shuffle bytes, +           * for output buffer (could perhaps optimize in future?), +           */, +        int bytesRead = readHeader(is, inputBuffer);, +        if ((bytesRead < HEADER_BYTES), +                || inputBuffer[0] != LZFChunk.BYTE_Z || inputBuffer[1] != LZFChunk.BYTE_V) {, +            if (bytesRead == 0) { // probably fine, clean EOF, +            throw new IOException("Corrupt input data, block did not start with 2 byte signature ('ZV') followed by type byte, 2-byte length)");, +        int type = inputBuffer[2];, +        int compLen = uint16(inputBuffer, 3);, +    /**, +     * Helper method to forcibly load header bytes that must be read before, +     * chunk can be handled., +     */, +    protected static int readHeader(final InputStream is, final byte[] inputBuffer), +            throws IOException {, +        // Ok: simple case first, where we just get all data we need, +        int needed = HEADER_BYTES;, +        int count = is.read(inputBuffer, 0, needed);, +, +        if (count == needed) {, +            return count;, +        }, +        if (count <= 0) {, +            return 0;, +        }, +, +        // if not, a source that trickles data (network etc); must loop, +        int offset = count;, +        needed -= count;, +, +        do {, +            count = is.read(inputBuffer, offset, needed);, +            if (count <= 0) {, +                break;, +            }, +            offset += count;, +            needed -= count;, +        } while (needed > 0);, +        return offset;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFDecoder.java, +     * Main decode from a stream.  Decompressed bytes are placed in the outputBuffer, inputBuffer, +     * is a "scratch-area"., +     * <p>, +     * If no, +        /* note: we do NOT read more than 5 bytes because otherwise might need to shuffle bytes, +           * for output buffer (could perhaps optimize in future?), +           */, +        int bytesRead = readHeader(is, inputBuffer);, +        if ((bytesRead < HEADER_BYTES), +                || inputBuffer[0] != LZFChunk.BYTE_Z || inputBuffer[1] != LZFChunk.BYTE_V) {, +            if (bytesRead == 0) { // probably fine, clean EOF, +            throw new IOException("Corrupt input data, block did not start with 2 byte signature ('ZV') followed by type byte, 2-byte length)");, +        int type = inputBuffer[2];, +        int compLen = uint16(inputBuffer, 3);, +    /**, +     * Helper method to forcibly load header bytes that must be read before, +     * chunk can be handled., +     */, +    protected static int readHeader(final InputStream is, final byte[] inputBuffer), +            throws IOException {, +        // Ok: simple case first, where we just get all data we need, +        int needed = HEADER_BYTES;, +        int count = is.read(inputBuffer, 0, needed);, +, +        if (count == needed) {, +            return count;, +        }, +        if (count <= 0) {, +            return 0;, +        }, +, +        // if not, a source that trickles data (network etc); must loop, +        int offset = count;, +        needed -= count;, +, +        do {, +            count = is.read(inputBuffer, offset, needed);, +            if (count <= 0) {, +                break;, +            }, +            offset += count;, +            needed -= count;, +        } while (needed > 0);, +        return offset;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFInputStream.java, +     * Flag that indicates if we have already called 'inputStream.close()', +     * (to avoid calling it multiple times), +     */, +    protected boolean inputStreamClosed;, +]