[+++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldNamesFieldMapper.java, +            final List<String> paths = new ArrayList<>(document.getFields().size());, +            String previousPath = ""; // used as a sentinel - field names can't be empty, +                final String path = field.name();, +                if (path.equals(previousPath)) {, +                    // Sometimes mappers create multiple Lucene fields, eg. one for indexing,, +                    // one for doc values and one for storing. Deduplicating is not required, +                    // for correctness but this simple check helps save utf-8 conversions and, +                    // gives Lucene fewer values to deal with., +                    continue;, +                }, +                paths.add(path);, +                previousPath = path;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldNamesFieldMapper.java, +            final List<String> paths = new ArrayList<>(document.getFields().size());, +            String previousPath = ""; // used as a sentinel - field names can't be empty, +                final String path = field.name();, +                if (path.equals(previousPath)) {, +                    // Sometimes mappers create multiple Lucene fields, eg. one for indexing,, +                    // one for doc values and one for storing. Deduplicating is not required, +                    // for correctness but this simple check helps save utf-8 conversions and, +                    // gives Lucene fewer values to deal with., +                    continue;, +                }, +                paths.add(path);, +                previousPath = path;, +++ b/core/src/test/java/org/elasticsearch/index/mapper/FieldNamesFieldMapperTests.java, +import java.util.Set;, +    void assertFieldNames(Set<String> expected, ParsedDocument doc) {, +    public void testDedup() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +            .startObject("_field_names").field("enabled", true).endObject(), +            .endObject().endObject().string();, +        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping));, +        FieldNamesFieldMapper fieldNamesMapper = docMapper.metadataMapper(FieldNamesFieldMapper.class);, +        assertTrue(fieldNamesMapper.fieldType().isEnabled());, +, +        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", XContentFactory.jsonBuilder(), +            .startObject(), +            .field("field", 3) // will create 2 lucene fields under the hood: index and doc values, +            .endObject(), +            .bytes(),, +            XContentType.JSON));, +, +        Set<String> fields = set("field", "_id", "_version", "_seq_no", "_primary_term", "_source");, +        assertFieldNames(fields, doc);, +        assertEquals(fields.size(), doc.rootDoc().getValues("_field_names").length);, +    }, +]