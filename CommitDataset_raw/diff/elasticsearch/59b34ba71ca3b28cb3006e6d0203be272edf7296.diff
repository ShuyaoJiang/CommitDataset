[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import java.util.ArrayList;, +     * Generate a {@link ElasticsearchException} from a {@link XContentParser}. This does not, +     * return the original exception type (ie NodeClosedException for example) but just wraps, +     * the type, the reason and the cause of the exception. It also recursively parses the, +     * tree structure of the cause, returning it as a tree structure of {@link ElasticsearchException}, +     * instances., +     */, +    public static ElasticsearchException fromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.nextToken();, +        ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation);, +        return innerFromXContent(parser);, +    }, +, +    private static ElasticsearchException innerFromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation);, +, +        String type = null, reason = null, stack = null;, +        ElasticsearchException cause = null;, +        Map<String, List<String>> metadata = new HashMap<>();, +        Map<String, List<String>> headers = new HashMap<>();, +, +        for (; token == XContentParser.Token.FIELD_NAME; token = parser.nextToken()) {, +            String currentFieldName = parser.currentName();, +            token = parser.nextToken();, +, +            if (token.isValue()) {, +                if (TYPE.equals(currentFieldName)) {, +                    type = parser.text();, +                } else if (REASON.equals(currentFieldName)) {, +                    reason = parser.text();, +                } else if (STACK_TRACE.equals(currentFieldName)) {, +                    stack = parser.text();, +                } else if (token == XContentParser.Token.VALUE_STRING) {, +                    metadata.put(currentFieldName, Collections.singletonList(parser.text()));, +                }, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                if (CAUSED_BY.equals(currentFieldName)) {, +                    cause = fromXContent(parser);, +                } else if (HEADER.equals(currentFieldName)) {, +                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                        if (token == XContentParser.Token.FIELD_NAME) {, +                            currentFieldName = parser.currentName();, +                        } else {, +                            List<String> values = headers.getOrDefault(currentFieldName, new ArrayList<>());, +                            if (token == XContentParser.Token.VALUE_STRING) {, +                                values.add(parser.text());, +                            } else if (token == XContentParser.Token.START_ARRAY) {, +                                while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                                    if (token == XContentParser.Token.VALUE_STRING) {, +                                        values.add(parser.text());, +                                    } else {, +                                        parser.skipChildren();, +                                    }, +                                }, +                            } else if (token == XContentParser.Token.START_OBJECT) {, +                                parser.skipChildren();, +                            }, +                            headers.put(currentFieldName, values);, +                        }, +                    }, +                } else {, +                    // Any additional metadata object added by the metadataToXContent method is ignored, +                    // and skipped, so that the parser does not fail on unknown fields. The parser only, +                    // support metadata key-pairs and metadata arrays of values., +                    parser.skipChildren();, +                }, +            } else if (token == XContentParser.Token.START_ARRAY) {, +                // Parse the array and add each item to the corresponding list of metadata., +                // Arrays of objects are not supported yet and just ignored and skipped., +                List<String> values = new ArrayList<>();, +                while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                    if (token == XContentParser.Token.VALUE_STRING) {, +                        values.add(parser.text());, +                    } else {, +                        parser.skipChildren();, +                    }, +                }, +                if (values.size() > 0) {, +                    if (metadata.containsKey(currentFieldName)) {, +                        values.addAll(metadata.get(currentFieldName));, +                    }, +                    metadata.put(currentFieldName, values);, +                }, +            }, +        }, +, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +, +        ElasticsearchException e = new ElasticsearchException(message.toString(), cause);, +, +        for (Map.Entry<String, List<String>> entry : metadata.entrySet()) {, +            //subclasses can print out additional metadata through the metadataToXContent method. Simple key-value pairs will be]