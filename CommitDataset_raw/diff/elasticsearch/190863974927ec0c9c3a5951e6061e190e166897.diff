[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.DynamicExecutors;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.Executor;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.ThreadFactory;, +    private final int concurrentConnects;, +        this.concurrentConnects = componentSettings.getAsInt("concurrent_connects", 10);, +        logger.debug("using initial hosts {}, with concurrent_connects [{}]", hosts, concurrentConnects);, +        final SendPingsHandler sendPingsHandler = new SendPingsHandler(pingIdGenerator.incrementAndGet());, +        receivedResponses.put(sendPingsHandler.id(), new ConcurrentHashMap<DiscoveryNode, PingResponse>());, +        sendPings(timeout, false, sendPingsHandler);, +                sendPings(timeout, true, sendPingsHandler);, +                for (DiscoveryNode node : sendPingsHandler.nodeToDisconnect) {, +                ConcurrentMap<DiscoveryNode, PingResponse> responses = receivedResponses.remove(sendPingsHandler.id());, +                sendPingsHandler.close();, +    class SendPingsHandler {, +        private final int id;, +        private volatile ExecutorService executor;, +        private final Set<DiscoveryNode> nodeToDisconnect = ConcurrentCollections.newConcurrentSet();, +        private volatile boolean closed;, +, +        SendPingsHandler(int id) {, +            this.id = id;, +        }, +, +        public int id() {, +            return this.id;, +        }, +, +        public boolean isClosed() {, +            return this.closed;, +        }, +, +        public Executor executor() {, +            if (executor == null) {, +                ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(settings, "[unicast_connect]");, +                executor = DynamicExecutors.newScalingThreadPool(1, concurrentConnects, 60000, threadFactory);, +            }, +            return executor;, +        }, +, +        public void close() {, +            closed = true;, +            if (executor != null) {, +                executor.shutdownNow();, +                executor = null;, +            }, +            nodeToDisconnect.clear();, +        }, +    }, +, +    void sendPings(final TimeValue timeout, boolean wait, final SendPingsHandler sendPingsHandler) {, +        pingRequest.id = sendPingsHandler.id();, +                nodeFoundByAddressX = true;, +                nodeFoundByAddressX = false;, +                if (sendPingsHandler.isClosed()) {, +                sendPingsHandler.nodeToDisconnect.add(nodeToSend);, +                // fork the connection to another thread, +                sendPingsHandler.executor().execute(new Runnable() {, +                    @Override public void run() {, +                            sendPingRequestToNode(sendPingsHandler.id(), timeout, pingRequest, latch, node, nodeToSend);, +                            logger.trace("[{}] failed to connect to {}", e, sendPingsHandler.id(), nodeToSend);, +                sendPingRequestToNode(sendPingsHandler.id(), timeout, pingRequest, latch, node, nodeToSend);]