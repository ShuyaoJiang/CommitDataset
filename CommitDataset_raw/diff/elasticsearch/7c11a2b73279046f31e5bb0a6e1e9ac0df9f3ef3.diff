[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +        return new PrimaryResult(shardRequest, new ReplicationResponse(), null);, +        return new ReplicaResult(null);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +        return new PrimaryResult(shardRequest, new ReplicationResponse(), null);, +        return new ReplicaResult(null);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/refresh/TransportShardRefreshAction.java, +        return new PrimaryResult(shardRequest, new ReplicationResponse(), null);, +        return new ReplicaResult(null);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.index.engine.OperationFailedEngineException;, +        // 28 was DeleteFailedEngineException, +        OPERATION_FAILED_ENGINE_EXCEPTION(OperationFailedEngineException.class,, +                OperationFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +        return new PrimaryResult(shardRequest, new ReplicationResponse(), null);, +        return new ReplicaResult(null);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/refresh/TransportShardRefreshAction.java, +        return new PrimaryResult(shardRequest, new ReplicationResponse(), null);, +        return new ReplicaResult(null);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnPrimary;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnReplica;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnPrimary;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnReplica;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected WritePrimaryResult shardOperationOnPrimary(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new WritePrimaryResult(request, response, location, null, primary);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard primary,, +                                                     Translog.Location location, int requestIndex) throws Exception {, +            // execute item request, +            DocWriteRequest itemRequest = request.items()[requestIndex].request();, +            final Engine.Operation operation;, +            final DocWriteResponse response;, +            switch (itemRequest.opType()) {, +                case CREATE:, +                case INDEX:, +                    final IndexRequest indexRequest = (IndexRequest) itemRequest;, +                    operation = executeIndexRequestOnPrimary(indexRequest, primary, mappingUpdatedAction);, +                    response = operation.hasFailure() ? null, +                            : new IndexResponse(primary.shardId(), indexRequest.type(), indexRequest.id(),, +                                operation.version(), ((Engine.Index) operation).isCreated());, +                    break;, +                case UPDATE:, +                    UpdateResultHolder updateResultHolder = executeUpdateRequest(((UpdateRequest) itemRequest),, +                            primary, metaData, request, requestIndex);, +                    operation = updateResultHolder.operation;, +                    response = updateResultHolder.response;, +                    break;, +                case DELETE:, +                    final DeleteRequest deleteRequest = (DeleteRequest) itemRequest;, +                    operation = executeDeleteRequestOnPrimary(deleteRequest, primary);, +                    response = operation.hasFailure() ? null :, +                            new DeleteResponse(request.shardId(), deleteRequest.type(), deleteRequest.id(),, +                                operation.version(), ((Engine.Delete) operation).found());, +                    break;, +                default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +            if (operation == null // in case of a noop update operation, +                    || operation.hasFailure() == false) {, +                if (operation != null) {, +                    location = locationToSync(location, operation.getTranslogLocation());, +                } else {, +                    assert response.getResult() == DocWriteResponse.Result.NOOP, +                            : "only noop update can have null operation";, +                }, +                // set update response, +                item.setPrimaryResponse(new BulkItemResponse(item.id(), opType, response));, +            } else {, +                DocWriteRequest docWriteRequest = item.request();, +                Exception failure = operation.getFailure();, +                if (isConflictException(failure)) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                } else {, +                    logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                }, +                // if its a conflict failure, and we already executed the request on a primary (and we execute it, +                // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +                // then just use the response we got from the successful execution, +                if (item.getPrimaryResponse() == null || isConflictException(failure) == false) {, +                    item.setPrimaryResponse(new BulkItemResponse(item.id(), docWriteRequest.opType(),, +                            new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), failure)));, +                }]