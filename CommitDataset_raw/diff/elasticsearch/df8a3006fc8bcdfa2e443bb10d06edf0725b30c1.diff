[+++ b/core/src/main/java/org/elasticsearch/action/support/nodes/TransportNodesAction.java, +    protected String[] resolveNodes(NodesRequest request, ClusterState clusterState) {, +        return clusterState.nodes().resolveNodesIds(request.nodesIds());, +    }, +, +, +            String[] nodesIds = resolveNodes(request, clusterState);, +++ b/core/src/main/java/org/elasticsearch/action/support/nodes/TransportNodesAction.java, +    protected String[] resolveNodes(NodesRequest request, ClusterState clusterState) {, +        return clusterState.nodes().resolveNodesIds(request.nodesIds());, +    }, +, +, +            String[] nodesIds = resolveNodes(request, clusterState);, +++ b/core/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +            logger.trace("{} ignoring fetched [{}] results, already closed", shardId, type);, +        logger.trace("{} processing fetched [{}] results", shardId, type);, +, +                if (nodeEntry == null) {, +                    continue;, +                }, +                if (nodeEntry.isFailed()) {, +                    logger.trace("{} node {} has failed for [{}] (failure [{}])", shardId, nodeEntry.getNodeId(), type, nodeEntry.getFailure());, +                } else {, +                    logger.trace("{} marking {} as done for [{}]", shardId, nodeEntry.getNodeId(), type);, +                logger.trace("{} processing failure {} for [{}]", shardId, failure, type);, +        logger.trace("{} fetching [{}] from {}", shardId, type, nodesIds);, +++ b/core/src/main/java/org/elasticsearch/action/support/nodes/TransportNodesAction.java, +    protected String[] resolveNodes(NodesRequest request, ClusterState clusterState) {, +        return clusterState.nodes().resolveNodesIds(request.nodesIds());, +    }, +, +, +            String[] nodesIds = resolveNodes(request, clusterState);, +++ b/core/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +            logger.trace("{} ignoring fetched [{}] results, already closed", shardId, type);, +        logger.trace("{} processing fetched [{}] results", shardId, type);, +, +                if (nodeEntry == null) {, +                    continue;, +                }, +                if (nodeEntry.isFailed()) {, +                    logger.trace("{} node {} has failed for [{}] (failure [{}])", shardId, nodeEntry.getNodeId(), type, nodeEntry.getFailure());, +                } else {, +                    logger.trace("{} marking {} as done for [{}]", shardId, nodeEntry.getNodeId(), type);, +                logger.trace("{} processing failure {} for [{}]", shardId, failure, type);, +        logger.trace("{} fetching [{}] from {}", shardId, type, nodesIds);, +++ b/core/src/main/java/org/elasticsearch/gateway/TransportNodesListGatewayStartedShards.java, +import org.elasticsearch.cluster.ClusterState;, +    protected String[] resolveNodes(Request request, ClusterState clusterState) {, +        // default implementation may filter out non existent nodes. it's important to keep exactly the ids, +        // we were given for accounting on the caller, +        return request.nodesIds();, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/action/support/nodes/TransportNodesAction.java, +    protected String[] resolveNodes(NodesRequest request, ClusterState clusterState) {, +        return clusterState.nodes().resolveNodesIds(request.nodesIds());, +    }, +, +, +            String[] nodesIds = resolveNodes(request, clusterState);, +++ b/core/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +            logger.trace("{} ignoring fetched [{}] results, already closed", shardId, type);, +        logger.trace("{} processing fetched [{}] results", shardId, type);, +, +                if (nodeEntry == null) {, +                    continue;, +                }, +                if (nodeEntry.isFailed()) {, +                    logger.trace("{} node {} has failed for [{}] (failure [{}])", shardId, nodeEntry.getNodeId(), type, nodeEntry.getFailure());, +                } else {, +                    logger.trace("{} marking {} as done for [{}]", shardId, nodeEntry.getNodeId(), type);, +                logger.trace("{} processing failure {} for [{}]", shardId, failure, type);, +        logger.trace("{} fetching [{}] from {}", shardId, type, nodesIds);, +++ b/core/src/main/java/org/elasticsearch/gateway/TransportNodesListGatewayStartedShards.java, +import org.elasticsearch.cluster.ClusterState;, +    protected String[] resolveNodes(Request request, ClusterState clusterState) {, +        // default implementation may filter out non existent nodes. it's important to keep exactly the ids, +        // we were given for accounting on the caller, +        return request.nodesIds();, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/indices/store/TransportNodesListShardStoreMetaData.java, +import org.elasticsearch.cluster.ClusterState;, +    protected String[] resolveNodes(Request request, ClusterState clusterState) {, +        // default implementation may filter out non existent nodes. it's important to keep exactly the ids, +        // we were given for accounting on the caller, +        return request.nodesIds();, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/action/support/nodes/TransportNodesAction.java, +    protected String[] resolveNodes(NodesRequest request, ClusterState clusterState) {, +        return clusterState.nodes().resolveNodesIds(request.nodesIds());, +    }, +, +]