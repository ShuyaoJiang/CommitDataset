[+++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import com.google.common.collect.Iterables;, +import java.util.*;, +                Store.MetadataSnapshot recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY;, +                    recoveryTargetMetadata = store.getMetadata();, +                final List<FileInfo> filesToRecover = Lists.newArrayList();, +                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>();, +                final Map<String, FileInfo> fileInfos = new HashMap<>();, +, +                for (final FileInfo fileInfo : snapshot.indexFiles()) {, +                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata());, +                    fileInfos.put(fileInfo.metadata().name(), fileInfo);, +                }, +                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(snapshotMetaData);, +                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata);, +                for (StoreFileMetaData md : diff.identical) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                }, +, +                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                    numberOfFiles++;, +++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import com.google.common.collect.Iterables;, +import java.util.*;, +                Store.MetadataSnapshot recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY;, +                    recoveryTargetMetadata = store.getMetadata();, +                final List<FileInfo> filesToRecover = Lists.newArrayList();, +                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>();, +                final Map<String, FileInfo> fileInfos = new HashMap<>();, +, +                for (final FileInfo fileInfo : snapshot.indexFiles()) {, +                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata());, +                    fileInfos.put(fileInfo.metadata().name(), fileInfo);, +                }, +                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(snapshotMetaData);, +                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata);, +                for (StoreFileMetaData md : diff.identical) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                }, +, +                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                    numberOfFiles++;, +++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +import org.apache.lucene.util.BytesRef;, +            static final XContentBuilderString META_HASH = new XContentBuilderString("meta_hash");, +, +            if (file.metadata.hash() != null && file.metadata().hash().length > 0) {, +                builder.field(Fields.META_HASH, file.metadata.hash());, +            }, +            BytesRef metaHash = new BytesRef();, +                            } else if ("meta_hash".equals(currentFieldName)) {, +                                metaHash.bytes = parser.binaryValue();, +                                metaHash.offset = 0;, +                                metaHash.length = metaHash.bytes.length;, +            return new FileInfo(name, new StoreFileMetaData(physicalName, length, checksum, writtenBy, metaHash), partSize);, +++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import com.google.common.collect.Iterables;, +import java.util.*;, +                Store.MetadataSnapshot recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY;, +                    recoveryTargetMetadata = store.getMetadata();, +                final List<FileInfo> filesToRecover = Lists.newArrayList();, +                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>();, +                final Map<String, FileInfo> fileInfos = new HashMap<>();, +, +                for (final FileInfo fileInfo : snapshot.indexFiles()) {, +                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata());, +                    fileInfos.put(fileInfo.metadata().name(), fileInfo);, +                }, +                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(snapshotMetaData);, +                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata);, +                for (StoreFileMetaData md : diff.identical) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                }, +, +                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {, +                    FileInfo fileInfo = fileInfos.get(md.name());, +                    numberOfFiles++;, +++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +import org.apache.lucene.util.BytesRef;, +            static final XContentBuilderString META_HASH = new XContentBuilderString("meta_hash");, +, +            if (file.metadata.hash() != null && file.metadata().hash().length > 0) {, +                builder.field(Fields.META_HASH, file.metadata.hash());, +            }, +            BytesRef metaHash = new BytesRef();, +                            } else if ("meta_hash".equals(currentFieldName)) {, +                                metaHash.bytes = parser.binaryValue();, +                                metaHash.offset = 0;, +                                metaHash.length = metaHash.bytes.length;, +            return new FileInfo(name, new StoreFileMetaData(physicalName, length, checksum, writtenBy, metaHash), partSize);, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +import com.google.common.collect.Iterables;, +import org.apache.lucene.codecs.lucene46.Lucene46SegmentInfoFormat;, +import org.apache.lucene.index.*;, +import org.apache.lucene.util.BytesRef;, +        private final Map<String, StoreFileMetaData> metadata;, +, +        public static final MetadataSnapshot EMPTY = new MetadataSnapshot();]