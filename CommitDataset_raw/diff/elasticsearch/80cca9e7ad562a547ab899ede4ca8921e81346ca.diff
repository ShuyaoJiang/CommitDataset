[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    stringBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +                    numberBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    stringBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +                    numberBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                    boolean strict = updateAllTypes == false;, +                    throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with existing mapping in other types:\n" + conflicts.toString());, +            MappedFieldTypeReference indexNameRef = indexNameToFieldType.get(fieldMapper.fieldType().names().indexName());, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                    boolean strict = updateAllTypes == false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    stringBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +                    numberBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                    boolean strict = updateAllTypes == false;, +                    throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with existing mapping in other types:\n" + conflicts.toString());, +            MappedFieldTypeReference indexNameRef = indexNameToFieldType.get(fieldMapper.fieldType().names().indexName());, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                    boolean strict = updateAllTypes == false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +        if (!names().indexName().equals(other.names().indexName())) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    stringBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +                    numberBuilder.fieldDataSettings(existingFieldType.fieldDataType().getSettings());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                    boolean strict = updateAllTypes == false;, +                    throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with existing mapping in other types:\n" + conflicts.toString());, +            MappedFieldTypeReference indexNameRef = indexNameToFieldType.get(fieldMapper.fieldType().names().indexName());, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                    boolean strict = updateAllTypes == false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +        if (!names().indexName().equals(other.names().indexName())) {, +++ b/core/src/test/java/org/elasticsearch/index/mapper/FieldTypeLookupTests.java, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +    public void testCheckCompatibilityNewField() {, +        FakeFieldMapper f1 = new FakeFieldMapper("foo", "bar");, +        FieldTypeLookup lookup = new FieldTypeLookup();, +        lookup.checkCompatibility(newList(f1), false);, +    }, +, +    public void testCheckCompatibilityMismatchedTypes() {, +        FieldMapper f1 = new FakeFieldMapper("foo", "bar");, +        FieldTypeLookup lookup = new FieldTypeLookup();, +        lookup = lookup.copyAndAddAll(newList(f1));, +, +        MappedFieldType ft2 = FakeFieldMapper.makeOtherFieldType("foo", "foo");, +        FieldMapper f2 = new FakeFieldMapper("foo", ft2);, +        try {, +            lookup.checkCompatibility(newList(f2), false);, +            fail("expected type mismatch");, +        } catch (IllegalArgumentException e) {, +            assertTrue(e.getMessage().contains("cannot be changed from type [faketype] to [otherfaketype]"));, +        }, +        // fails even if updateAllTypes == true, +        try {, +            lookup.checkCompatibility(newList(f2), true);, +            fail("expected type mismatch");, +        } catch (IllegalArgumentException e) {, +            assertTrue(e.getMessage().contains("cannot be changed from type [faketype] to [otherfaketype]"));, +        }, +    }, +, +    public void testCheckCompatibilityConflict() {, +        FieldMapper f1 = new FakeFieldMapper("foo", "bar");, +        FieldTypeLookup lookup = new FieldTypeLookup();, +        lookup = lookup.copyAndAddAll(newList(f1));, +, +        MappedFieldType ft2 = FakeFieldMapper.makeFieldType("foo", "bar");, +        ft2.setBoost(2.0f);, +        FieldMapper f2 = new FakeFieldMapper("foo", ft2);, +        try {, +            lookup.checkCompatibility(newList(f2), false);, +            fail("expected conflict");, +        } catch (IllegalArgumentException e) {, +            assertTrue(e.getMessage().contains("to update [boost] across all types"));, +        }, +        lookup.checkCompatibility(newList(f2), true); // boost is updateable, so ok if forcing, +        // now with a non changeable setting, +        MappedFieldType ft3 = FakeFieldMapper.makeFieldType("foo", "bar");, +        ft3.setStored(true);, +        FieldMapper f3 = new FakeFieldMapper("foo", ft3);, +        try {, +            lookup.checkCompatibility(newList(f3), false);, +            fail("expected conflict");, +        } catch (IllegalArgumentException e) {, +            assertTrue(e.getMessage().contains("has different store values"));, +        }, +        // even with updateAllTypes == true, incompatible, +        try {, +            lookup.checkCompatibility(newList(f3), true);, +            fail("expected conflict");, +        } catch (IllegalArgumentException e) {, +            assertTrue(e.getMessage().contains("has different store values"));, +        }, +    }, +        public FakeFieldMapper(String fullName, MappedFieldType fieldType) {, +            super(fullName, fieldType, fieldType, dummySettings, null, null);, +        }]