[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +, +        // clear the index dir by creating a new index, +        try {, +            // release locks when started, +            if (IndexWriter.isLocked(store.directory())) {, +                logger.trace("Shard is locked, releasing lock");, +                store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);, +            }, +            IndexWriter writer = new IndexWriter(store.directory(), analysisService.defaultIndexAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);, +            writer.commit();, +            writer.close();, +        } catch (IOException e) {, +            logger.warn("Failed to clean the index", e);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +, +        // clear the index dir by creating a new index, +        try {, +            // release locks when started, +            if (IndexWriter.isLocked(store.directory())) {, +                logger.trace("Shard is locked, releasing lock");, +                store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);, +            }, +            IndexWriter writer = new IndexWriter(store.directory(), analysisService.defaultIndexAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);, +            writer.commit();, +            writer.close();, +        } catch (IOException e) {, +            logger.warn("Failed to clean the index", e);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/MmapFsStore.java, +import org.apache.lucene.store.*;, +        String fsLock = componentSettings.get("use_fs_lock", "none");, +        LockFactory lockFactory = new NoLockFactory();, +        if (fsLock.equals("native")) {, +            lockFactory = new NativeFSLockFactory();, +        } else if (fsLock.equals("simple")) {, +            lockFactory = new SimpleFSLockFactory();, +        }, +        this.fsDirectory = new CustomMMapDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);, +            logger.debug("Using [mmap_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());, +        private CustomMMapDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {, +            super(path, lockFactory);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +, +        // clear the index dir by creating a new index, +        try {, +            // release locks when started, +            if (IndexWriter.isLocked(store.directory())) {, +                logger.trace("Shard is locked, releasing lock");, +                store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);, +            }, +            IndexWriter writer = new IndexWriter(store.directory(), analysisService.defaultIndexAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);, +            writer.commit();, +            writer.close();, +        } catch (IOException e) {, +            logger.warn("Failed to clean the index", e);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/MmapFsStore.java, +import org.apache.lucene.store.*;, +        String fsLock = componentSettings.get("use_fs_lock", "none");, +        LockFactory lockFactory = new NoLockFactory();, +        if (fsLock.equals("native")) {, +            lockFactory = new NativeFSLockFactory();, +        } else if (fsLock.equals("simple")) {, +            lockFactory = new SimpleFSLockFactory();, +        }, +        this.fsDirectory = new CustomMMapDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);, +            logger.debug("Using [mmap_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());, +        private CustomMMapDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {, +            super(path, lockFactory);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/NioFsStore.java, +import org.apache.lucene.store.*;, +        String fsLock = componentSettings.get("use_fs_lock", "none");, +        LockFactory lockFactory = new NoLockFactory();, +        if (fsLock.equals("native")) {, +            lockFactory = new NativeFSLockFactory();, +        } else if (fsLock.equals("simple")) {, +            lockFactory = new SimpleFSLockFactory();, +        }, +        this.fsDirectory = new CustomNioFSDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);, +            logger.debug("Using [nio_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());, +        private CustomNioFSDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {, +            super(path, lockFactory);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +, +        // clear the index dir by creating a new index, +        try {, +            // release locks when started, +            if (IndexWriter.isLocked(store.directory())) {, +                logger.trace("Shard is locked, releasing lock");, +                store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);, +            }, +            IndexWriter writer = new IndexWriter(store.directory(), analysisService.defaultIndexAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);, +            writer.commit();, +            writer.close();, +        } catch (IOException e) {, +            logger.warn("Failed to clean the index", e);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/MmapFsStore.java]