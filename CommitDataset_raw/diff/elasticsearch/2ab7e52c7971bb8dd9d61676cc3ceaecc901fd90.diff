[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/audit/index/IndexAuditTrail.java, +import org.elasticsearch.action.ActionListener;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean putTemplatePending = new AtomicBoolean(false);, +            // just return true as we do not determine whether we can start or not based on the local cluster state, but must base it off, +            // of the remote cluster state and this method is called on the cluster state update thread, so we do not really want to, +            // execute remote calls on this thread, +            return true;, +            if (indexToRemoteCluster) {, +                client.admin().cluster().prepareState().execute(new ActionListener<ClusterStateResponse>() {, +                    @Override, +                    public void onResponse(ClusterStateResponse clusterStateResponse) {, +                        final boolean currentMaster = clusterService.state().getNodes().isLocalNodeElectedMaster();, +                        if (canStart(clusterStateResponse.getState(), currentMaster)) {, +                            if (currentMaster) {, +                                putTemplate(customAuditIndexSettings(settings), ActionListener.wrap((v) -> innerStart(),, +                                        (e) -> state.set(State.FAILED)));, +                            } else {, +                                innerStart();, +                        } else {, +                            if (state.compareAndSet(State.STARTING, State.INITIALIZED) == false) {, +                                throw new IllegalStateException("state transition from starting to initialized failed, current value: " +, +                                        state.get());, +                            }, +                        }, +                    }, +, +                    @Override, +                    public void onFailure(Exception e) {, +                        logger.error("failed to get remote cluster state", e);, +                    }, +                });, +            } else if (master) {, +                putTemplate(customAuditIndexSettings(settings), ActionListener.wrap((v) -> innerStart(),, +                        (e) -> state.set(State.FAILED)));, +            } else {, +                innerStart();, +            }, +        }, +    }, +, +    private void innerStart() {, +        if (indexToRemoteCluster == false) {, +        }, +    void putTemplate(Settings customSettings, ActionListener<Void> listener) {, +            final PutIndexTemplateRequest request = new PutIndexTemplateRequest(INDEX_TEMPLATE_NAME).source(template);, +            client.admin().indices().putTemplate(request, ActionListener.wrap((response) -> {, +                        if (response.isAcknowledged()) {, +                            final DateTime dateTime;, +                            final Message message = eventQueue.peek();, +                            final String index = resolve(INDEX_NAME_PREFIX, dateTime, rollover);, +                            checkIfCurrentIndexExists(index, request, listener);, +                            listener.onFailure(new IllegalStateException("failed to put index template for audit logging"));, +                    }, listener::onFailure));, +            listener.onFailure(e);, +    private void checkIfCurrentIndexExists(String index, PutIndexTemplateRequest indexTemplateRequest, ActionListener<Void> listener) {, +        client.admin().indices().prepareExists(index).execute(ActionListener.wrap((response) -> {, +            if (response.isExists()) {, +                logger.debug("index [{}] exists so we need to update mappings", index);, +                putAuditIndexMappings(index, indexTemplateRequest, listener);, +            } else {, +                logger.debug("index [{}] does not exist so we do not need to update mappings", index);, +                listener.onResponse(null);, +            }, +        }, listener::onFailure));, +    }, +, +    private void putAuditIndexMappings(String index, PutIndexTemplateRequest request, ActionListener<Void> listener) {, +        client.admin().indices().preparePutMapping(index), +                .setType(DOC_TYPE), +                .setSource(request.mappings(), +                .get(DOC_TYPE)), +                .execute(ActionListener.wrap((response) -> {, +                    if (response.isAcknowledged()) {, +                        listener.onResponse(null);, +                    } else {, +                        listener.onFailure(new IllegalStateException("failed to put mappings for audit logging index [" + index + "]"));, +                    }, +                },, +                listener::onFailure));, +    }, +, +        assert indexToRemoteCluster == false;, +        if (state() == State.STARTED, +                && clusterChangedEvent.localNodeMaster(), +                && clusterChangedEvent.state().metaData().templates().get(INDEX_TEMPLATE_NAME) == null, +                && putTemplatePending.compareAndSet(false, true)) {, +, +            putTemplate(customAuditIndexSettings(settings), new ActionListener<Void>() {, +                public void onResponse(Void aVoid) {, +                    putTemplatePending.set(false);, +                public void onFailure(Exception e) {, +                    putTemplatePending.set(false);, +                    logger.error((Supplier<?>) () -> new ParameterizedMessage(, +                            "failed to update security audit index template [{}]", INDEX_TEMPLATE_NAME), e);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/audit/index/IndexAuditTrail.java, +import org.elasticsearch.action.ActionListener;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean putTemplatePending = new AtomicBoolean(false);, +            // just return true as we do not determine whether we can start or not based on the local cluster state, but must base it off]