[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.common.logging.LoggerMessageFormat;, +import org.elasticsearch.xpack.sql.expression.Foldables;, +                    Expression child = order.child();, +                            // report error, +                            String message = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, orderBy.sourceText(), max);, +                            UnresolvedAttribute ua = new UnresolvedAttribute(child.source(), orderBy.sourceText(), null, message);, +                            newOrder.add(new Order(order.source(), ua, order.direction(), order.nullsPosition()));, +                        String errorMessage = null;, +                                errorMessage = LoggerMessageFormat.format(, +                                        "Ordinal [{}] in [{}] refers to an invalid argument, aggregate function [{}]",, +                                        ordinal, agg.sourceText(), reference.sourceText());, +, +                            } else {, +                        }, +                            errorMessage = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, agg.sourceText(), max);, +                        }, +                        if (errorMessage != null) {, +                            newGroupings.add(new UnresolvedAttribute(exp.source(), agg.sourceText(), null, errorMessage));, +            if (expression.foldable()) {, +                if (expression.dataType().isInteger()) {, +                    Object v = Foldables.valueOf(expression);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.common.logging.LoggerMessageFormat;, +import org.elasticsearch.xpack.sql.expression.Foldables;, +                    Expression child = order.child();, +                            // report error, +                            String message = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, orderBy.sourceText(), max);, +                            UnresolvedAttribute ua = new UnresolvedAttribute(child.source(), orderBy.sourceText(), null, message);, +                            newOrder.add(new Order(order.source(), ua, order.direction(), order.nullsPosition()));, +                        String errorMessage = null;, +                                errorMessage = LoggerMessageFormat.format(, +                                        "Ordinal [{}] in [{}] refers to an invalid argument, aggregate function [{}]",, +                                        ordinal, agg.sourceText(), reference.sourceText());, +, +                            } else {, +                        }, +                            errorMessage = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, agg.sourceText(), max);, +                        }, +                        if (errorMessage != null) {, +                            newGroupings.add(new UnresolvedAttribute(exp.source(), agg.sourceText(), null, errorMessage));, +            if (expression.foldable()) {, +                if (expression.dataType().isInteger()) {, +                    Object v = Foldables.valueOf(expression);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/AbstractBuilder.java, +    static Source source(TerminalNode begin, ParserRuleContext end) {, +        Check.notNull(begin, "begin is null");, +        Check.notNull(end, "end is null");, +        Token start = begin.getSymbol();, +        Token stop = end.stop != null ? end.stop : start;, +        String text = start.getInputStream().getText(new Interval(start.getStartIndex(), stop.getStopIndex()));, +        return new Source(new Location(start.getLine(), start.getCharPositionInLine()), text);, +    }, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.common.logging.LoggerMessageFormat;, +import org.elasticsearch.xpack.sql.expression.Foldables;, +                    Expression child = order.child();, +                            // report error, +                            String message = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, orderBy.sourceText(), max);, +                            UnresolvedAttribute ua = new UnresolvedAttribute(child.source(), orderBy.sourceText(), null, message);, +                            newOrder.add(new Order(order.source(), ua, order.direction(), order.nullsPosition()));, +                        String errorMessage = null;, +                                errorMessage = LoggerMessageFormat.format(, +                                        "Ordinal [{}] in [{}] refers to an invalid argument, aggregate function [{}]",, +                                        ordinal, agg.sourceText(), reference.sourceText());, +, +                            } else {, +                        }, +                            errorMessage = LoggerMessageFormat.format("Invalid ordinal [{}] specified in [{}] (valid range is [1, {}])",, +                                    ordinal, agg.sourceText(), max);, +                        }, +                        if (errorMessage != null) {, +                            newGroupings.add(new UnresolvedAttribute(exp.source(), agg.sourceText(), null, errorMessage));, +            if (expression.foldable()) {, +                if (expression.dataType().isInteger()) {, +                    Object v = Foldables.valueOf(expression);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/AbstractBuilder.java, +    static Source source(TerminalNode begin, ParserRuleContext end) {, +        Check.notNull(begin, "begin is null");, +        Check.notNull(end, "end is null");, +        Token start = begin.getSymbol();, +        Token stop = end.stop != null ? end.stop : start;, +        String text = start.getInputStream().getText(new Interval(start.getStartIndex(), stop.getStopIndex()));, +        return new Source(new Location(start.getLine(), start.getCharPositionInLine()), text);, +    }, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/LogicalPlanBuilder.java, +import org.antlr.v4.runtime.ParserRuleContext;, +import org.elasticsearch.xpack.sql.parser.SqlBaseParser.GroupingElementContext;, +import org.elasticsearch.xpack.sql.parser.SqlBaseParser.OrderByContext;, +            List<OrderByContext> orders = ctx.orderBy();, +            OrderByContext endContext = orders.get(orders.size() - 1);, +            plan = new OrderBy(source(ctx.ORDER(), endContext), plan, visitList(ctx.orderBy(), Order.class));, +            List<GroupingElementContext> groupingElement = groupByCtx.groupingElement();]