[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +, +        // We need to add the uid or id to this nested Lucene document too,, +        // If we do not do this then when a document gets deleted only the root Lucene document gets deleted and, +        // not the nested Lucene documents! Besides the fact that we would have zombie Lucene documents, the ordering of, +        // documents inside the Lucene index (document blocks) will be incorrect, as nested documents of different root, +        // documents are then aligned with other root documents. This will lead tothe nested query, sorting, aggregations, +        // and inner hits to fail or yield incorrect results., +        if (context.mapperService().getIndexSettings().isSingleType()) {, +            IndexableField idField = parentDoc.getField(IdFieldMapper.NAME);, +            if (idField != null) {, +                // We just need to store the id as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +                nestedDoc.add(new Field(IdFieldMapper.NAME, idField.stringValue(), IdFieldMapper.Defaults.NESTED_FIELD_TYPE));, +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an id field");, +            }, +        } else {, +                /// We just need to store the uid as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an uid field");, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +, +        // We need to add the uid or id to this nested Lucene document too,, +        // If we do not do this then when a document gets deleted only the root Lucene document gets deleted and, +        // not the nested Lucene documents! Besides the fact that we would have zombie Lucene documents, the ordering of, +        // documents inside the Lucene index (document blocks) will be incorrect, as nested documents of different root, +        // documents are then aligned with other root documents. This will lead tothe nested query, sorting, aggregations, +        // and inner hits to fail or yield incorrect results., +        if (context.mapperService().getIndexSettings().isSingleType()) {, +            IndexableField idField = parentDoc.getField(IdFieldMapper.NAME);, +            if (idField != null) {, +                // We just need to store the id as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +                nestedDoc.add(new Field(IdFieldMapper.NAME, idField.stringValue(), IdFieldMapper.Defaults.NESTED_FIELD_TYPE));, +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an id field");, +            }, +        } else {, +                /// We just need to store the uid as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an uid field");, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/IdFieldMapper.java, +        public static final MappedFieldType NESTED_FIELD_TYPE;, +, +            NESTED_FIELD_TYPE = FIELD_TYPE.clone();, +            NESTED_FIELD_TYPE.setStored(false);, +            NESTED_FIELD_TYPE.freeze();, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +, +        // We need to add the uid or id to this nested Lucene document too,, +        // If we do not do this then when a document gets deleted only the root Lucene document gets deleted and, +        // not the nested Lucene documents! Besides the fact that we would have zombie Lucene documents, the ordering of, +        // documents inside the Lucene index (document blocks) will be incorrect, as nested documents of different root, +        // documents are then aligned with other root documents. This will lead tothe nested query, sorting, aggregations, +        // and inner hits to fail or yield incorrect results., +        if (context.mapperService().getIndexSettings().isSingleType()) {, +            IndexableField idField = parentDoc.getField(IdFieldMapper.NAME);, +            if (idField != null) {, +                // We just need to store the id as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +                nestedDoc.add(new Field(IdFieldMapper.NAME, idField.stringValue(), IdFieldMapper.Defaults.NESTED_FIELD_TYPE));, +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an id field");, +            }, +        } else {, +                /// We just need to store the uid as indexed field, so that IndexWriter#deleteDocuments(term) can then, +                // delete it when the root document is deleted too., +            } else {, +                throw new IllegalStateException("The root document of a nested document should have an uid field");, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/IdFieldMapper.java, +        public static final MappedFieldType NESTED_FIELD_TYPE;, +, +            NESTED_FIELD_TYPE = FIELD_TYPE.clone();, +            NESTED_FIELD_TYPE.setStored(false);, +            NESTED_FIELD_TYPE.freeze();, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +    public void testNestedHaveIdAndTypeFields() throws Exception {, +        DocumentMapperParser mapperParser1 = createIndex("index1", Settings.builder(), +            .put("index.mapping.single_type", false).build(), +        ).mapperService().documentMapperParser();, +        DocumentMapperParser mapperParser2 = createIndex("index2", Settings.builder(), +            .put("index.mapping.single_type", true).build(), +        ).mapperService().documentMapperParser();, +, +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties");, +        {, +            mapping.startObject("foo");, +            mapping.field("type", "nested");, +            {, +                mapping.startObject("properties");]