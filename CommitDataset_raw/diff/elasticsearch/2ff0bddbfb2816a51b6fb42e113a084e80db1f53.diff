[+++ b/server/src/main/java/org/elasticsearch/Build.java, +            final Type buildType;, +            if (out.getVersion().before(Version.V_6_7_0) && build.type() == Type.DOCKER) {, +                buildType = Type.TAR;, +            } else {, +                buildType = build.type();, +            }, +            out.writeString(buildType.displayName());, +++ b/server/src/main/java/org/elasticsearch/Build.java, +            final Type buildType;, +            if (out.getVersion().before(Version.V_6_7_0) && build.type() == Type.DOCKER) {, +                buildType = Type.TAR;, +            } else {, +                buildType = build.type();, +            }, +            out.writeString(buildType.displayName());, +++ b/server/src/test/java/org/elasticsearch/BuildTests.java, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.test.EqualsHashCodeTestUtils;, +import java.util.List;, +import java.util.Objects;, +import static org.hamcrest.Matchers.equalTo;, +, +, +    private static class WriteableBuild implements Writeable {, +        private final Build build;, +, +        WriteableBuild(StreamInput in) throws IOException {, +            build = Build.readBuild(in);, +        }, +, +        WriteableBuild(Build build) {, +            this.build = build;, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            Build.writeBuild(build, out);, +        }, +, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +            WriteableBuild that = (WriteableBuild) o;, +            return build.equals(that.build);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(build);, +        }, +    }, +, +    private static String randomStringExcept(final String s) {, +        return randomAlphaOfLength(13 - s.length());, +    }, +, +    public void testSerialization() {, +        EqualsHashCodeTestUtils.checkEqualsAndHashCode(new WriteableBuild(new Build(, +                randomFrom(Build.Flavor.values()), randomFrom(Build.Type.values()),, +                randomAlphaOfLength(6), randomAlphaOfLength(6), randomBoolean(), randomAlphaOfLength(6))),, +            b -> copyWriteable(b, writableRegistry(), WriteableBuild::new, Version.CURRENT),, +            b -> {, +                switch (randomIntBetween(1, 6)) {, +                    case 1:, +                        return new WriteableBuild(new Build(, +                            randomValueOtherThan(b.build.flavor(), () -> randomFrom(Build.Flavor.values())), b.build.type(),, +                            b.build.shortHash(), b.build.date(), b.build.isSnapshot(), b.build.getQualifiedVersion()));, +                    case 2:, +                        return new WriteableBuild(new Build(b.build.flavor(),, +                            randomValueOtherThan(b.build.type(), () -> randomFrom(Build.Type.values())),, +                            b.build.shortHash(), b.build.date(), b.build.isSnapshot(), b.build.getQualifiedVersion()));, +                    case 3:, +                        return new WriteableBuild(new Build(b.build.flavor(), b.build.type(),, +                            randomStringExcept(b.build.shortHash()), b.build.date(), b.build.isSnapshot(), b.build.getQualifiedVersion()));, +                    case 4:, +                        return new WriteableBuild(new Build(b.build.flavor(), b.build.type(),, +                            b.build.shortHash(), randomStringExcept(b.build.date()), b.build.isSnapshot(), b.build.getQualifiedVersion()));, +                    case 5:, +                        return new WriteableBuild(new Build(b.build.flavor(), b.build.type(),, +                            b.build.shortHash(), b.build.date(), b.build.isSnapshot() == false, b.build.getQualifiedVersion()));, +                    case 6:, +                        return new WriteableBuild(new Build(b.build.flavor(), b.build.type(),, +                            b.build.shortHash(), b.build.date(), b.build.isSnapshot(), randomStringExcept(b.build.getQualifiedVersion())));, +                }, +                throw new AssertionError();, +            });, +    }, +, +    public void testSerializationBWC() throws IOException {, +        final WriteableBuild dockerBuild = new WriteableBuild(new Build(randomFrom(Build.Flavor.values()), Build.Type.DOCKER,, +            randomAlphaOfLength(6), randomAlphaOfLength(6), randomBoolean(), randomAlphaOfLength(6)));, +, +        final List<Version> versions = Version.getDeclaredVersions(Version.class);, +        final Version pre63Version = randomFrom(versions.stream().filter(v -> v.before(Version.V_6_3_0)).collect(Collectors.toList()));, +        final Version post63Pre67Version = randomFrom(versions.stream(), +            .filter(v -> v.onOrAfter(Version.V_6_3_0) && v.before(Version.V_6_7_0)).collect(Collectors.toList()));]