[+++ b/src/main/java/org/elasticsearch/index/fielddata/ordinals/InternalGlobalOrdinalsBuilder.java, +    public static abstract class GlobalOrdinalMapping implements Ordinals.Docs {, +        public abstract long getGlobalOrd(long segmentOrd);, +            public long getGlobalOrd(long segmentOrd) {, +            public long getGlobalOrd(long segmentOrd) {, +++ b/src/main/java/org/elasticsearch/index/fielddata/ordinals/InternalGlobalOrdinalsBuilder.java, +    public static abstract class GlobalOrdinalMapping implements Ordinals.Docs {, +        public abstract long getGlobalOrd(long segmentOrd);, +            public long getGlobalOrd(long segmentOrd) {, +            public long getGlobalOrd(long segmentOrd) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BucketsAggregator.java, +    public LongArray getDocCounts() {, +        return docCounts;, +    protected final void incrementBucketDocCount(long inc, long bucketOrd) throws IOException {, +++ b/src/main/java/org/elasticsearch/index/fielddata/ordinals/InternalGlobalOrdinalsBuilder.java, +    public static abstract class GlobalOrdinalMapping implements Ordinals.Docs {, +        public abstract long getGlobalOrd(long segmentOrd);, +            public long getGlobalOrd(long segmentOrd) {, +            public long getGlobalOrd(long segmentOrd) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BucketsAggregator.java, +    public LongArray getDocCounts() {, +        return docCounts;, +    protected final void incrementBucketDocCount(long inc, long bucketOrd) throws IOException {, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/GlobalOrdinalsStringTermsAggregator.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.common.util.LongArray;, +import static org.elasticsearch.index.fielddata.ordinals.InternalGlobalOrdinalsBuilder.GlobalOrdinalMapping;, +, +            long maxOrd, InternalOrder order, int requiredSize, int shardSize, long minDocCount, AggregationContext aggregationContext, Aggregator parent) {, +        super(name, factories, maxOrd, aggregationContext, parent, order, requiredSize, shardSize, minDocCount);, +                long maxOrd, InternalOrder order, int requiredSize, int shardSize, long minDocCount, AggregationContext aggregationContext,, +            // Set maxOrd to estimatedBucketCount! To be conservative with memory., +            super(name, factories, valuesSource, estimatedBucketCount, estimatedBucketCount, order, requiredSize, shardSize, minDocCount, aggregationContext, parent);, +    /**, +     * Variant of {@link GlobalOrdinalsStringTermsAggregator} that resolves global ordinals post segment collection, +     * instead of on the fly for each match.This is beneficial for low cardinality fields, because it can reduce, +     * the amount of look-ups significantly., +     */, +    public static class LowCardinality extends GlobalOrdinalsStringTermsAggregator {, +, +        private final LongArray segmentDocCounts;, +, +        private Ordinals.Docs segmentOrdinals;, +        private LongArray current;, +, +        public LowCardinality(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, long estimatedBucketCount,, +                              long maxOrd, InternalOrder order, int requiredSize, int shardSize, long minDocCount, AggregationContext aggregationContext, Aggregator parent) {, +            super(name, factories, valuesSource, estimatedBucketCount, maxOrd, order, requiredSize, shardSize, minDocCount, aggregationContext, parent);, +            this.segmentDocCounts = bigArrays.newLongArray(maxOrd, true);, +        }, +, +        @Override, +        public void collect(int doc, long owningBucketOrdinal) throws IOException {, +            final int numOrds = segmentOrdinals.setDocument(doc);, +            for (int i = 0; i < numOrds; i++) {, +                final long segmentOrd = segmentOrdinals.nextOrd();, +                current.increment(segmentOrd, 1);, +            }, +        }, +, +        @Override, +        public void setNextReader(AtomicReaderContext reader) {, +            if (segmentOrdinals != null && segmentOrdinals.getMaxOrd() != globalOrdinals.getMaxOrd()) {, +                mapSegmentCountsToGlobalCounts();, +            }, +, +            super.setNextReader(reader);, +            BytesValues.WithOrdinals bytesValues = valuesSource.bytesValues();, +            segmentOrdinals = bytesValues.ordinals();, +            if (segmentOrdinals.getMaxOrd() != globalOrdinals.getMaxOrd()) {, +                current = segmentDocCounts;, +            } else {, +                current = getDocCounts();, +            }, +        }, +, +        @Override, +        protected void doPostCollection() {, +            if (segmentOrdinals.getMaxOrd() != globalOrdinals.getMaxOrd()) {, +                mapSegmentCountsToGlobalCounts();, +            }, +        }, +, +        @Override, +        protected void doClose() {, +            Releasables.close(segmentDocCounts);, +        }, +, +        private void mapSegmentCountsToGlobalCounts() {, +            // There is no public method in Ordinals.Docs that allows for this mapping..., +            // This is the cleanest way I can think of so far, +            GlobalOrdinalMapping mapping = (GlobalOrdinalMapping) globalOrdinals;, +            for (int i = 0; i < segmentDocCounts.size(); i++) {, +                final long inc = segmentDocCounts.set(i, 0);, +                if (inc == 0) {, +                    continue;, +                }, +                final long globalOrd = mapping.getGlobalOrd(i);, +                try {, +                    incrementBucketDocCount(inc, globalOrd);]