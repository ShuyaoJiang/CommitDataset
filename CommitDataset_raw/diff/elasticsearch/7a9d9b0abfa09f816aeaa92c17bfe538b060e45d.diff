[+++ b/docs/reference/search/request/sort.asciidoc, +                "distance_type" : "arc",, +                "ignore_unmapped": true, +, +`ignore_unmapped`::, +, +    Indicates if the unmapped field should be treated as a missing value. Setting it to `true` is equivalent to specifying, +    an `unmapped_type` in the field sort. The default is `false` (unmapped field are causing the search to fail)., +, +++ b/docs/reference/search/request/sort.asciidoc, +                "distance_type" : "arc",, +                "ignore_unmapped": true, +, +`ignore_unmapped`::, +, +    Indicates if the unmapped field should be treated as a missing value. Setting it to `true` is equivalent to specifying, +    an `unmapped_type` in the field sort. The default is `false` (unmapped field are causing the search to fail)., +, +++ b/server/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    private static final ParseField IGNORE_UNMAPPED = new ParseField("ignore_unmapped");, +    private boolean ignoreUnmapped = false;, +, +        this.ignoreUnmapped = original.ignoreUnmapped;, +        // TODO: Change to 6_4_0 after backport, +        if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +            ignoreUnmapped = in.readBoolean();, +        }, +        // TODO: Change to 6_4_0 after backport, +        if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +            out.writeBoolean(ignoreUnmapped);, +        }, +    /**, +     * Returns true if unmapped geo fields should be treated as located at an infinite distance, +     */, +    public boolean ignoreUnmapped() {, +        return ignoreUnmapped;, +    }, +, +    public GeoDistanceSortBuilder ignoreUnmapped(boolean ignoreUnmapped) {, +        this.ignoreUnmapped = ignoreUnmapped;, +        return this;, +    }, +, +        builder.field(IGNORE_UNMAPPED.getPreferredName(), ignoreUnmapped);, +                Objects.equals(nestedSort, other.nestedSort) &&, +                ignoreUnmapped == other.ignoreUnmapped;, +                this.nestedPath, this.validation, this.nestedSort, this.ignoreUnmapped);, +        boolean ignoreUnmapped = false;, +                } else if (IGNORE_UNMAPPED.match(currentName, parser.getDeprecationHandler())) {, +                    ignoreUnmapped = parser.booleanValue();, +        result.ignoreUnmapped(ignoreUnmapped);, +            if (ignoreUnmapped) {, +                fieldType = context.getMapperService().unmappedFieldType("geo_point");, +            } else {, +                throw new IllegalArgumentException("failed to find mapper for [" + fieldName + "] for geo distance based sort");, +            }, +++ b/docs/reference/search/request/sort.asciidoc, +                "distance_type" : "arc",, +                "ignore_unmapped": true, +, +`ignore_unmapped`::, +, +    Indicates if the unmapped field should be treated as a missing value. Setting it to `true` is equivalent to specifying, +    an `unmapped_type` in the field sort. The default is `false` (unmapped field are causing the search to fail)., +, +++ b/server/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    private static final ParseField IGNORE_UNMAPPED = new ParseField("ignore_unmapped");, +    private boolean ignoreUnmapped = false;, +, +        this.ignoreUnmapped = original.ignoreUnmapped;, +        // TODO: Change to 6_4_0 after backport, +        if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +            ignoreUnmapped = in.readBoolean();, +        }, +        // TODO: Change to 6_4_0 after backport, +        if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +            out.writeBoolean(ignoreUnmapped);, +        }, +    /**, +     * Returns true if unmapped geo fields should be treated as located at an infinite distance, +     */, +    public boolean ignoreUnmapped() {, +        return ignoreUnmapped;, +    }, +, +    public GeoDistanceSortBuilder ignoreUnmapped(boolean ignoreUnmapped) {, +        this.ignoreUnmapped = ignoreUnmapped;, +        return this;, +    }, +, +        builder.field(IGNORE_UNMAPPED.getPreferredName(), ignoreUnmapped);, +                Objects.equals(nestedSort, other.nestedSort) &&, +                ignoreUnmapped == other.ignoreUnmapped;, +                this.nestedPath, this.validation, this.nestedSort, this.ignoreUnmapped);, +        boolean ignoreUnmapped = false;, +                } else if (IGNORE_UNMAPPED.match(currentName, parser.getDeprecationHandler())) {, +                    ignoreUnmapped = parser.booleanValue();, +        result.ignoreUnmapped(ignoreUnmapped);, +            if (ignoreUnmapped) {, +                fieldType = context.getMapperService().unmappedFieldType("geo_point");]