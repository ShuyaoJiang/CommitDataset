[+++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.cache;, +, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +, +import java.util.*;, +import java.util.concurrent.atomic.LongAdder;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +import java.util.function.Function;, +import java.util.function.ToLongBiFunction;, +, +/**, + * A simple concurrent cache., + * <p>, + * Cache is a simple concurrent cache that supports time-based and weight-based evictions, with notifications for all, + * evictions. The design goals for this cache were simplicity and read performance. This means that we are willing to, + * accept reduced write performance in exchange for easy-to-understand code. Cache statistics for hits, misses and, + * evictions are exposed., + * <p>, + * The design of the cache is relatively simple. The cache is segmented into 256 segments which are backed by HashMaps., + * The segments are protected by a re-entrant read/write lock. The read/write locks permit multiple concurrent readers, + * without contention, and the segments gives us write throughput without impacting readers (so readers are blocked only, + * if they are reading a segment that a writer is writing to)., + * <p>, + * The LRU functionality is backed by a single doubly-linked list chaining the entries in order of insertion. This, + * LRU list is protected by a lock that serializes all writes to it. There are opportunities for improvements, + * here if write throughput is a concern., + * <ol>, + * <li>LRU list mutations could be inserted into a blocking queue that a single thread is reading from, + * and applying to the LRU list.</li>, + * <li>Promotions could be deferred for entries that were "recently" promoted.</li>, + * <li>Locks on the list could be taken per node being modified instead of globally.</li>, + * </ol>, + * <p>, + * Evictions only occur after a mutation to the cache (meaning an entry promotion, a cache insertion, or a manual, + * invalidation) or an explicit call to {@link #refresh()}., + *, + * @param <K> The type of the keys, + * @param <V> The type of the values, + */, +public class Cache<K, V> {, +    // positive if entries have an expiration, +    private long expireAfterAccess = -1;, +, +    // positive if entries have an expiration after write, +    private long expireAfterWrite = -1;, +, +    // the number of entries in the cache, +    private int count = 0;, +, +    // the weight of the entries in the cache, +    private long weight = 0;, +, +    // the maximum weight that this cache supports, +    private long maximumWeight = -1;, +, +    // the weigher of entries, +    private ToLongBiFunction<K, V> weigher = (k, v) -> 1;, +, +    // the removal callback, +    private RemovalListener<K, V> removalListener = notification -> {, +    };, +, +    // use CacheBuilder to construct, +    Cache() {, +    }, +, +    void setExpireAfterAccess(long expireAfterAccess) {, +        if (expireAfterAccess <= 0) {, +            throw new IllegalArgumentException("expireAfterAccess <= 0");, +        }, +        this.expireAfterAccess = expireAfterAccess;, +    }, +, +    void setMaximumWeight(long maximumWeight) {, +        if (maximumWeight < 0) {, +            throw new IllegalArgumentException("maximumWeight < 0");, +        }]