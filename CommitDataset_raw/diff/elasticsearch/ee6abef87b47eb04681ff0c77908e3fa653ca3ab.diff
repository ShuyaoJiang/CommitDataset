[+++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +                .setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS);, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +                .setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS);, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientBuilderTests.java, +    /**, +     * This test verifies that we don't change the default value for the connection request timeout as that causes problems., +     * See https://github.com/elastic/elasticsearch/issues/24069, +     */, +    public void testDefaultConnectionRequestTimeout() throws IOException {, +        RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200));, +        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {, +            @Override, +            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {, +                RequestConfig requestConfig = requestConfigBuilder.build();, +                assertEquals(RequestConfig.DEFAULT.getConnectionRequestTimeout(), requestConfig.getConnectionRequestTimeout());, +                //this way we get notified if the default ever changes, +                assertEquals(-1, requestConfig.getConnectionRequestTimeout());, +                return requestConfigBuilder;, +            }, +        });, +        try (RestClient restClient = builder.build()) {, +            assertNotNull(restClient);, +        }, +    }, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +                .setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS);, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientBuilderTests.java, +    /**, +     * This test verifies that we don't change the default value for the connection request timeout as that causes problems., +     * See https://github.com/elastic/elasticsearch/issues/24069, +     */, +    public void testDefaultConnectionRequestTimeout() throws IOException {, +        RestClientBuilder builder = RestClient.builder(new HttpHost("localhost", 9200));, +        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {, +            @Override, +            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {, +                RequestConfig requestConfig = requestConfigBuilder.build();, +                assertEquals(RequestConfig.DEFAULT.getConnectionRequestTimeout(), requestConfig.getConnectionRequestTimeout());, +                //this way we get notified if the default ever changes, +                assertEquals(-1, requestConfig.getConnectionRequestTimeout());, +                return requestConfigBuilder;, +            }, +        });, +        try (RestClient restClient = builder.build()) {, +            assertNotNull(restClient);, +        }, +    }, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientSingleHostIntegTests.java, +import org.apache.http.nio.entity.NStringEntity;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +     * Tests sending a bunch of async requests works well (e.g. no TimeoutException from the leased pool), +     * See https://github.com/elastic/elasticsearch/issues/24069, +     */, +    public void testManyAsyncRequests() throws Exception {, +        int iters = randomIntBetween(500, 1000);, +        final CountDownLatch latch = new CountDownLatch(iters);, +        final List<Exception> exceptions = new CopyOnWriteArrayList<>();, +        for (int i = 0; i < iters; i++) {, +            Request request = new Request("PUT", "/200");, +            request.setEntity(new NStringEntity("{}", ContentType.APPLICATION_JSON));, +            restClient.performRequestAsync(request, new ResponseListener() {, +                @Override, +                public void onSuccess(Response response) {, +                    latch.countDown();, +                }, +, +                @Override, +                public void onFailure(Exception exception) {, +                    exceptions.add(exception);, +                    latch.countDown();, +                }, +            });, +        }, +, +        assertTrue("timeout waiting for requests to be sent", latch.await(10, TimeUnit.SECONDS));, +        if (exceptions.isEmpty() == false) {, +            AssertionError error = new AssertionError("expected no failures but got some. see suppressed for first 10 of [", +                                        + exceptions.size() + "] failures");, +            for (Exception exception : exceptions.subList(0, Math.min(10, exceptions.size()))) {, +                error.addSuppressed(exception);, +            }, +            throw error;, +        }, +    }, +, +    /**]