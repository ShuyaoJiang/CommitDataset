[+++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    public static final String INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING = "index.mapping.nested_fields.limit";, +                return merge(mergeWith, reason, updateAllTypes);, +    private synchronized DocumentMapper merge(DocumentMapper mapper, MergeReason reason, boolean updateAllTypes) {, +, +        if (reason == MergeReason.MAPPING_UPDATE) {, +            checkNestedFieldsLimit(fullPathObjectMappers);, +        }, +, +    private void checkNestedFieldsLimit(Map<String, ObjectMapper> fullPathObjectMappers) {, +        long allowedNestedFields = indexSettings.getSettings().getAsLong(INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING, 50L);, +        long actualNestedFields = 0;, +        for (ObjectMapper objectMapper : fullPathObjectMappers.values()) {, +            if (objectMapper.nested().isNested()) {, +                actualNestedFields++;, +            }, +        }, +        if (allowedNestedFields >= 0 && actualNestedFields > allowedNestedFields) {, +            throw new IllegalArgumentException("Limit of nested fields [" + allowedNestedFields + "] in index [" + index().name() + "] has been exceeded");, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    public static final String INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING = "index.mapping.nested_fields.limit";, +                return merge(mergeWith, reason, updateAllTypes);, +    private synchronized DocumentMapper merge(DocumentMapper mapper, MergeReason reason, boolean updateAllTypes) {, +, +        if (reason == MergeReason.MAPPING_UPDATE) {, +            checkNestedFieldsLimit(fullPathObjectMappers);, +        }, +, +    private void checkNestedFieldsLimit(Map<String, ObjectMapper> fullPathObjectMappers) {, +        long allowedNestedFields = indexSettings.getSettings().getAsLong(INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING, 50L);, +        long actualNestedFields = 0;, +        for (ObjectMapper objectMapper : fullPathObjectMappers.values()) {, +            if (objectMapper.nested().isNested()) {, +                actualNestedFields++;, +            }, +        }, +        if (allowedNestedFields >= 0 && actualNestedFields > allowedNestedFields) {, +            throw new IllegalArgumentException("Limit of nested fields [" + allowedNestedFields + "] in index [" + index().name() + "] has been exceeded");, +        }, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/mapper/nested/NestedMappingTests.java, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +import java.io.IOException;, +import java.io.UncheckedIOException;, +import java.util.function.Function;, +, +import static org.hamcrest.Matchers.containsString;, +, +    public void testLimitOfNestedFieldsPerIndex() throws Exception {, +        Function<String, String> mapping = type -> {, +            try {, +                return XContentFactory.jsonBuilder().startObject().startObject(type).startObject("properties"), +                    .startObject("nested1").field("type", "nested").startObject("properties"), +                    .startObject("nested2").field("type", "nested"), +                    .endObject().endObject(), +                    .endObject().endObject().endObject().string();, +            } catch (IOException e) {, +                throw new UncheckedIOException(e);, +            }, +        };, +, +        // default limit allows at least two nested fields, +        createIndex("test1").mapperService().merge("type", new CompressedXContent(mapping.apply("type")), MergeReason.MAPPING_UPDATE, false);, +, +        // explicitly setting limit to 0 prevents nested fields, +        try {, +            createIndex("test2", Settings.builder().put(MapperService.INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING, 0).build()), +                .mapperService().merge("type", new CompressedXContent(mapping.apply("type")), MergeReason.MAPPING_UPDATE, false);, +            fail("Expected IllegalArgumentException");, +        } catch (IllegalArgumentException e) {, +            assertThat(e.getMessage(), containsString("Limit of nested fields [0] in index [test2] has been exceeded"));, +        }, +, +        // setting limit to 1 with 2 nested fields fails, +        try {, +            createIndex("test3", Settings.builder().put(MapperService.INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING, 1).build()), +                .mapperService().merge("type", new CompressedXContent(mapping.apply("type")), MergeReason.MAPPING_UPDATE, false);, +            fail("Expected IllegalArgumentException");, +        } catch (IllegalArgumentException e) {, +            assertThat(e.getMessage(), containsString("Limit of nested fields [1] in index [test3] has been exceeded"));, +        }, +, +        MapperService mapperService = createIndex("test4", Settings.builder().put(MapperService.INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING, 2), +            .build()).mapperService();, +        mapperService.merge("type1", new CompressedXContent(mapping.apply("type1")), MergeReason.MAPPING_UPDATE, false);, +        // merging same fields, but different type is ok, +        mapperService.merge("type2", new CompressedXContent(mapping.apply("type2")), MergeReason.MAPPING_UPDATE, false);, +        // adding new fields from different type is not ok, +        String mapping2 = XContentFactory.jsonBuilder().startObject().startObject("type3").startObject("properties").startObject("nested3"), +            .field("type", "nested").startObject("properties").endObject().endObject().endObject().endObject().string();, +        try {, +            mapperService.merge("type3", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE, false);, +            fail("Expected IllegalArgumentException");, +        } catch (IllegalArgumentException e) {]