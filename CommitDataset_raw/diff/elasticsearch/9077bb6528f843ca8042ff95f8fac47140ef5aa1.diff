[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/geo/GeoPointFieldData.java, +            int comma = term.indexOf(',');, +            double lat = Double.parseDouble(term.substring(0, comma));, +            double lon = Double.parseDouble(term.substring(comma + 1));, +            terms.add(new GeoPoint(lat, lon));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/geo/GeoPointFieldData.java, +            int comma = term.indexOf(',');, +            double lat = Double.parseDouble(term.substring(0, comma));, +            double lon = Double.parseDouble(term.substring(comma + 1));, +            terms.add(new GeoPoint(lat, lon));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/geo/GeoPointFieldMapper.java, +        private boolean enableGeoHash = false;, +, +        public Builder enableGeoHash(boolean enableGeoHash) {, +            this.enableGeoHash = enableGeoHash;, +            return this;, +        }, +, +            GeoStringFieldMapper geoStringMapper = new GeoStringFieldMapper.Builder(name), +            StringFieldMapper geohashMapper = null;, +            if (enableGeoHash) {, +                geohashMapper = stringField(Names.GEOHASH).index(Field.Index.NOT_ANALYZED).includeInAll(false).omitNorms(true).omitTermFreqAndPositions(true).build(context);, +            }, +            return new GeoPointFieldMapper(name, pathType, enableLatLon, enableGeoHash, precisionStep, precision, latMapper, lonMapper, geohashMapper, geoStringMapper);, +                } else if (fieldName.equals("geohash")) {, +                    builder.enableGeoHash(XContentMapValues.nodeBooleanValue(fieldNode));, +                } else if (fieldName.equals("geohash_precision")) {, +    private final boolean enableGeoHash;, +, +    private final StringFieldMapper geoStringMapper;, +, +    public GeoPointFieldMapper(String name, ContentPath.Type pathType, boolean enableLatLon, boolean enableGeoHash, Integer precisionStep, int precision,, +                               NumberFieldMapper latMapper, NumberFieldMapper lonMapper, StringFieldMapper geohashMapper, StringFieldMapper geoStringMapper) {, +        this.enableGeoHash = enableGeoHash;, +        this.geoStringMapper = geoStringMapper;, +        context.externalValue(lat.toString() + ',' + lon.toString());, +        geoStringMapper.parse(context);, +        if (enableGeoHash) {, +        }, +        double[] values = GeoHashUtils.decode(geohash);, +        context.externalValue(Double.toString(values[0]) + ',' + Double.toString(values[1]));, +        geoStringMapper.parse(context);, +        if (enableGeoHash) {, +        }, +        geoStringMapper.traverse(fieldMapperListener);, +        if (enableGeoHash) {, +        }, +        builder.field("geohash", enableGeoHash);, +        builder.field("store", geoStringMapper.store().name().toLowerCase());, +        builder.field("geohash_precision", precision);, +    public static class GeoStringFieldMapper extends StringFieldMapper {, +            @Override public GeoStringFieldMapper build(BuilderContext context) {, +                GeoStringFieldMapper fieldMapper = new GeoStringFieldMapper(buildNames(context),, +        public GeoStringFieldMapper(Names names, Field.Index index, Field.Store store, Field.TermVector termVector, float boost, boolean omitNorms, boolean omitTermFreqAndPositions, String nullValue, NamedAnalyzer indexAnalyzer, NamedAnalyzer searchAnalyzer) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/geo/GeoPointFieldData.java, +            int comma = term.indexOf(',');, +            double lat = Double.parseDouble(term.substring(0, comma));, +            double lon = Double.parseDouble(term.substring(comma + 1));, +            terms.add(new GeoPoint(lat, lon));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/xcontent/geo/GeoPointFieldMapper.java, +        private boolean enableGeoHash = false;, +, +        public Builder enableGeoHash(boolean enableGeoHash) {, +            this.enableGeoHash = enableGeoHash;, +            return this;, +        }, +, +            GeoStringFieldMapper geoStringMapper = new GeoStringFieldMapper.Builder(name), +            StringFieldMapper geohashMapper = null;, +            if (enableGeoHash) {, +                geohashMapper = stringField(Names.GEOHASH).index(Field.Index.NOT_ANALYZED).includeInAll(false).omitNorms(true).omitTermFreqAndPositions(true).build(context);, +            }, +            return new GeoPointFieldMapper(name, pathType, enableLatLon, enableGeoHash, precisionStep, precision, latMapper, lonMapper, geohashMapper, geoStringMapper);, +                } else if (fieldName.equals("geohash")) {, +                    builder.enableGeoHash(XContentMapValues.nodeBooleanValue(fieldNode));, +                } else if (fieldName.equals("geohash_precision")) {, +    private final boolean enableGeoHash;, +, +    private final StringFieldMapper geoStringMapper;, +, +    public GeoPointFieldMapper(String name, ContentPath.Type pathType, boolean enableLatLon, boolean enableGeoHash, Integer precisionStep, int precision,, +                               NumberFieldMapper latMapper, NumberFieldMapper lonMapper, StringFieldMapper geohashMapper, StringFieldMapper geoStringMapper) {, +        this.enableGeoHash = enableGeoHash;, +        this.geoStringMapper = geoStringMapper;, +        context.externalValue(lat.toString() + ',' + lon.toString());, +        geoStringMapper.parse(context);, +        if (enableGeoHash) {, +        }, +        double[] values = GeoHashUtils.decode(geohash);, +        context.externalValue(Double.toString(values[0]) + ',' + Double.toString(values[1]));, +        geoStringMapper.parse(context);, +        if (enableGeoHash) {, +        }, +        geoStringMapper.traverse(fieldMapperListener);, +        if (enableGeoHash) {, +        }, +        builder.field("geohash", enableGeoHash);, +        builder.field("store", geoStringMapper.store().name().toLowerCase());, +        builder.field("geohash_precision", precision);, +    public static class GeoStringFieldMapper extends StringFieldMapper {]