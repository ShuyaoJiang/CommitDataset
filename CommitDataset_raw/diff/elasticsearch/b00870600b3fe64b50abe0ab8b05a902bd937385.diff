[+++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +                ReleasableLock newLock = tryCreateNewLock(key);, +                if (newLock != null) {, +                    return newLock;, +            } else {, +    }, +, +    /**, +     * Tries to acquire the lock for the given key and returns it. If the lock can't be acquired null is returned., +     */, +    public Releasable tryAcquire(T key) {, +        final KeyLock perNodeLock = map.get(key);, +        if (perNodeLock == null) {, +            return tryCreateNewLock(key);, +        }, +        if (perNodeLock.tryLock()) { // ok we got it - make sure we increment it accordingly otherwise release it again, +            int i;, +            while ((i = perNodeLock.count.get()) > 0) {, +                // we have to do this in a loop here since even if the count is > 0, +                // there could be a concurrent blocking acquire that changes the count and then this CAS fails. Since we already got, +                // the lock we should retry and see if we can still get it or if the count is 0. If that is the case and we give up., +                if (perNodeLock.count.compareAndSet(i, i + 1)) {, +                    return new ReleasableLock(key, perNodeLock);, +                }, +            }, +            perNodeLock.unlock(); // make sure we unlock and don't leave the lock in a locked state, +        }, +        return null;, +    }, +, +    private ReleasableLock tryCreateNewLock(T key) {, +        KeyLock newLock = new KeyLock(fair);, +        newLock.lock();, +        KeyLock keyLock = map.putIfAbsent(key, newLock);, +        if (keyLock == null) {, +            return new ReleasableLock(key, newLock);, +        }, +        return null;, +    }, +        final int decrementAndGet = lock.count.decrementAndGet();, +        assert decrementAndGet >= 0 : decrementAndGet + " must be >= 0 but wasn't";, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +                ReleasableLock newLock = tryCreateNewLock(key);, +                if (newLock != null) {, +                    return newLock;, +            } else {, +    }, +, +    /**, +     * Tries to acquire the lock for the given key and returns it. If the lock can't be acquired null is returned., +     */, +    public Releasable tryAcquire(T key) {, +        final KeyLock perNodeLock = map.get(key);, +        if (perNodeLock == null) {, +            return tryCreateNewLock(key);, +        }, +        if (perNodeLock.tryLock()) { // ok we got it - make sure we increment it accordingly otherwise release it again, +            int i;, +            while ((i = perNodeLock.count.get()) > 0) {, +                // we have to do this in a loop here since even if the count is > 0, +                // there could be a concurrent blocking acquire that changes the count and then this CAS fails. Since we already got, +                // the lock we should retry and see if we can still get it or if the count is 0. If that is the case and we give up., +                if (perNodeLock.count.compareAndSet(i, i + 1)) {, +                    return new ReleasableLock(key, perNodeLock);, +                }, +            }, +            perNodeLock.unlock(); // make sure we unlock and don't leave the lock in a locked state, +        }, +        return null;, +    }, +, +    private ReleasableLock tryCreateNewLock(T key) {, +        KeyLock newLock = new KeyLock(fair);, +        newLock.lock();, +        KeyLock keyLock = map.putIfAbsent(key, newLock);, +        if (keyLock == null) {, +            return new ReleasableLock(key, newLock);, +        }, +        return null;, +    }, +        final int decrementAndGet = lock.count.decrementAndGet();, +        assert decrementAndGet >= 0 : decrementAndGet + " must be >= 0 but wasn't";, +++ b/server/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +            final BytesRef uid = entry.getKey();, +            try (Releasable lock = keyedLock.tryAcquire(uid)) {, +                // we use tryAcquire here since this is a best effort and we try to be least disruptive, +                // this method is also called under lock in the engine under certain situations such that this can lead to deadlocks, +                // if we do use a blocking acquire. see #28714, +                if (lock != null) { // did we get the lock?, +                    // can we do it without this lock on each value? maybe batch to a set and get the lock once per set?, +                    final DeleteVersionValue versionValue = tombstones.get(uid);, +    }, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +                ReleasableLock newLock = tryCreateNewLock(key);, +                if (newLock != null) {, +                    return newLock;, +            } else {, +    }, +, +    /**]