[+++ b/docs/reference/sql/limitations.asciidoc, +sub-fields. Even though `SYS COLUMNS` in non-driver mode (in the CLI and in REST calls) and `DESCRIBE TABLE` will still display, +them as having the type `NESTED`, they cannot be used in a query. One can only reference its sub-fields in the form:, +++ b/docs/reference/sql/limitations.asciidoc, +sub-fields. Even though `SYS COLUMNS` in non-driver mode (in the CLI and in REST calls) and `DESCRIBE TABLE` will still display, +them as having the type `NESTED`, they cannot be used in a query. One can only reference its sub-fields in the form:, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysColumns.java, +        Mode mode = session.configuration().mode();, +        List<Attribute> output = output(mode == Mode.ODBC);, +                fillInRows(cluster, esIndex.name(), esIndex.mapping(), null, rows, columnMatcher, mode);, +            Pattern columnMatcher, Mode mode) {, +        boolean isOdbcClient = mode == Mode.ODBC;, +            // skip the nested, object and unsupported types for JDBC and ODBC, +            if (type.isPrimitive() || false == Mode.isDriver(mode)) {, +                fillInRows(clusterName, indexName, field.getProperties(), name, rows, columnMatcher, mode);, +++ b/docs/reference/sql/limitations.asciidoc, +sub-fields. Even though `SYS COLUMNS` in non-driver mode (in the CLI and in REST calls) and `DESCRIBE TABLE` will still display, +them as having the type `NESTED`, they cannot be used in a query. One can only reference its sub-fields in the form:, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysColumns.java, +        Mode mode = session.configuration().mode();, +        List<Attribute> output = output(mode == Mode.ODBC);, +                fillInRows(cluster, esIndex.name(), esIndex.mapping(), null, rows, columnMatcher, mode);, +            Pattern columnMatcher, Mode mode) {, +        boolean isOdbcClient = mode == Mode.ODBC;, +            // skip the nested, object and unsupported types for JDBC and ODBC, +            if (type.isPrimitive() || false == Mode.isDriver(mode)) {, +                fillInRows(clusterName, indexName, field.getProperties(), name, rows, columnMatcher, mode);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/DataType.java, +        return this != OBJECT && this != NESTED && this != UNSUPPORTED;, +++ b/docs/reference/sql/limitations.asciidoc, +sub-fields. Even though `SYS COLUMNS` in non-driver mode (in the CLI and in REST calls) and `DESCRIBE TABLE` will still display, +them as having the type `NESTED`, they cannot be used in a query. One can only reference its sub-fields in the form:, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysColumns.java, +        Mode mode = session.configuration().mode();, +        List<Attribute> output = output(mode == Mode.ODBC);, +                fillInRows(cluster, esIndex.name(), esIndex.mapping(), null, rows, columnMatcher, mode);, +            Pattern columnMatcher, Mode mode) {, +        boolean isOdbcClient = mode == Mode.ODBC;, +            // skip the nested, object and unsupported types for JDBC and ODBC, +            if (type.isPrimitive() || false == Mode.isDriver(mode)) {, +                fillInRows(clusterName, indexName, field.getProperties(), name, rows, columnMatcher, mode);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/DataType.java, +        return this != OBJECT && this != NESTED && this != UNSUPPORTED;, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysColumnsTests.java, +import org.elasticsearch.xpack.sql.proto.Mode;, +        SysColumns.fillInRows("test", "index", TypesTests.loadMapping("mapping-multi-field-variation.json", true), null, rows, null,, +                randomValueOtherThanMany(Mode::isDriver, () -> randomFrom(Mode.values())));, +        assertEquals(17, rows.size());, +        row = rows.get(3);, +        assertEquals("keyword", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +, +        row = rows.get(5);, +        assertEquals("unsupported", name(row));, +        assertEquals(Types.OTHER, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(0, bufferLength(row));, +        , +        row = rows.get(6);, +        assertEquals("some", name(row));, +        assertEquals(Types.STRUCT, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(-1, bufferLength(row));, +        , +        row = rows.get(8);, +        assertEquals("some.dotted.field", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +        , +        row = rows.get(9);, +        assertEquals("some.string", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +        , +        row = rows.get(10);, +        assertEquals("some.string.normalized", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +        , +        row = rows.get(11);, +        assertEquals("some.string.typical", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +        , +        row = rows.get(12);, +        assertEquals("some.ambiguous", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));, +        assertEquals(Integer.MAX_VALUE, bufferLength(row));, +        , +        row = rows.get(13);, +        assertEquals("some.ambiguous.one", name(row));, +        assertEquals(Types.VARCHAR, sqlType(row));, +        assertEquals(null, radix(row));]