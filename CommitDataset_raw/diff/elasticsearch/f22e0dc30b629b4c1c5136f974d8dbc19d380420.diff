[+++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +import org.elasticsearch.action.search.RemoteClusterService;, +import org.elasticsearch.rest.action.admin.cluster.RestRemoteClusterInfoAction;, +    public void initRestHandlers(Supplier<DiscoveryNodes> nodesInCluster, RemoteClusterService remoteClusterService) {, +        registerHandler.accept(new RestRemoteClusterInfoAction(settings, restController, remoteClusterService));, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +import org.elasticsearch.action.search.RemoteClusterService;, +import org.elasticsearch.rest.action.admin.cluster.RestRemoteClusterInfoAction;, +    public void initRestHandlers(Supplier<DiscoveryNodes> nodesInCluster, RemoteClusterService remoteClusterService) {, +        registerHandler.accept(new RestRemoteClusterInfoAction(settings, restController, remoteClusterService));, +++ b/core/src/main/java/org/elasticsearch/action/search/RemoteClusterConnection.java, +import org.elasticsearch.action.admin.cluster.node.info.NodeInfo;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoAction;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoRequest;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoResponse;, +import org.elasticsearch.common.transport.TransportAddress;, +import java.util.HashSet;, +import java.util.Optional;, +import java.util.stream.Collectors;, +, +    /**, +     * Fetches connection info for this connection, +     */, +    public void getConnectionInfo(ActionListener<RemoteConnectionInfo> listener) {, +        final Optional<DiscoveryNode> anyNode = connectedNodes.stream().findAny();, +        if (anyNode.isPresent() == false) {, +            // not connected we return immediately, +            RemoteConnectionInfo remoteConnectionStats = new RemoteConnectionInfo(clusterAlias,, +                Collections.emptyList(), Collections.emptyList(), maxNumRemoteConnections, 0,, +                RemoteClusterService.REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings));, +            listener.onResponse(remoteConnectionStats);, +        } else {, +            NodesInfoRequest request = new NodesInfoRequest();, +            request.clear();, +            request.http(true);, +, +            transportService.sendRequest(anyNode.get(), NodesInfoAction.NAME, request, new TransportResponseHandler<NodesInfoResponse>() {, +                @Override, +                public NodesInfoResponse newInstance() {, +                    return new NodesInfoResponse();, +                }, +, +                @Override, +                public void handleResponse(NodesInfoResponse response) {, +                    Collection<TransportAddress> httpAddresses = new HashSet<>();, +                    for (NodeInfo info : response.getNodes()) {, +                        if (connectedNodes.contains(info.getNode()) && info.getHttp() != null) {, +                            httpAddresses.add(info.getHttp().getAddress().publishAddress());, +                        }, +                    }, +, +                    if (httpAddresses.size() < maxNumRemoteConnections) {, +                        // just in case non of the connected nodes have http enabled we get other http enabled nodes instead., +                        for (NodeInfo info : response.getNodes()) {, +                            if (nodePredicate.test(info.getNode()) && info.getHttp() != null) {, +                                httpAddresses.add(info.getHttp().getAddress().publishAddress());, +                            }, +                            if (httpAddresses.size() == maxNumRemoteConnections) {, +                                break; // once we have enough return..., +                            }, +                        }, +                    }, +                    RemoteConnectionInfo remoteConnectionInfo = new RemoteConnectionInfo(clusterAlias,, +                        seedNodes.stream().map(n -> n.getAddress()).collect(Collectors.toSet()), httpAddresses, maxNumRemoteConnections,, +                        connectedNodes.size(), RemoteClusterService.REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings));, +                    listener.onResponse(remoteConnectionInfo);, +                }, +, +                @Override, +                public void handleException(TransportException exp) {, +                    listener.onFailure(exp);, +                }, +, +                @Override, +                public String executor() {, +                    return ThreadPool.Names.SAME;, +                }, +            });, +        }, +, +    }, +, +    int getNumNodesConnected() {, +        return connectedNodes.size();, +    }, +++ b/core/src/main/java/org/elasticsearch/action/ActionModule.java, +import org.elasticsearch.action.search.RemoteClusterService;, +import org.elasticsearch.rest.action.admin.cluster.RestRemoteClusterInfoAction;, +    public void initRestHandlers(Supplier<DiscoveryNodes> nodesInCluster, RemoteClusterService remoteClusterService) {, +        registerHandler.accept(new RestRemoteClusterInfoAction(settings, restController, remoteClusterService));, +++ b/core/src/main/java/org/elasticsearch/action/search/RemoteClusterConnection.java, +import org.elasticsearch.action.admin.cluster.node.info.NodeInfo;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoAction;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoRequest;, +import org.elasticsearch.action.admin.cluster.node.info.NodesInfoResponse;, +import org.elasticsearch.common.transport.TransportAddress;, +import java.util.HashSet;, +import java.util.Optional;, +import java.util.stream.Collectors;, +]