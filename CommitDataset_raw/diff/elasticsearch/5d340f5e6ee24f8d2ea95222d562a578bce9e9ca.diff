[+++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +        this.loadedFilters = CacheBuilder.<Object, Cache<Query, Value>>builder().removalListener(this).build();, +, +        Cache<Query, Value> filterToFbs = loadedFilters.computeIfAbsent(coreCacheReader, key -> {, +            return CacheBuilder.<Query, Value>builder().build();, +, +        return filterToFbs.computeIfAbsent(query, key -> {, +            try {, +            } catch (IOException e) {, +                throw new RuntimeException(e);, +            }, +        if (notification.getKey() == null) {, +        for (Value value : valueCache.values()) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +        this.loadedFilters = CacheBuilder.<Object, Cache<Query, Value>>builder().removalListener(this).build();, +, +        Cache<Query, Value> filterToFbs = loadedFilters.computeIfAbsent(coreCacheReader, key -> {, +            return CacheBuilder.<Query, Value>builder().build();, +, +        return filterToFbs.computeIfAbsent(query, key -> {, +            try {, +            } catch (IOException e) {, +                throw new RuntimeException(e);, +            }, +        if (notification.getKey() == null) {, +        for (Value value : valueCache.values()) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/request/ShardRequestCache.java, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +        if (removalNotification.getRemovalReason() == RemovalNotification.RemovalReason.EVICTED) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +        this.loadedFilters = CacheBuilder.<Object, Cache<Query, Value>>builder().removalListener(this).build();, +, +        Cache<Query, Value> filterToFbs = loadedFilters.computeIfAbsent(coreCacheReader, key -> {, +            return CacheBuilder.<Query, Value>builder().build();, +, +        return filterToFbs.computeIfAbsent(query, key -> {, +            try {, +            } catch (IOException e) {, +                throw new RuntimeException(e);, +            }, +        if (notification.getKey() == null) {, +        for (Value value : valueCache.values()) {, +++ b/core/src/main/java/org/elasticsearch/index/cache/request/ShardRequestCache.java, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +        if (removalNotification.getRemovalReason() == RemovalNotification.RemovalReason.EVICTED) {, +++ b/core/src/main/java/org/elasticsearch/indices/cache/request/IndicesRequestCache.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +import java.io.IOException;, +import java.util.*;, +import java.util.function.Function;, +        CacheBuilder<Key, Value> cacheBuilder = CacheBuilder.<Key, Value>builder(), +                .setMaximumWeight(sizeInBytes).weigher((k, v) -> k.ramBytesUsed() + v.ramBytesUsed()).removalListener(this);, +        // cacheBuilder.concurrencyLevel(concurrencyLevel);, +            cacheBuilder.setExpireAfter(TimeUnit.MILLISECONDS.toNanos(expire.millis()));, +        Loader loader = new Loader(queryPhase, context);, +        Value value = cache.computeIfAbsent(key, loader);, +    private static class Loader implements Function<Key, Value> {, +        Loader(QueryPhase queryPhase, SearchContext context) {, +        public Value apply(Key key) {, +            } catch (IOException e) {, +                throw new RuntimeException(e);, +                for (Iterator<Key> iterator = cache.keys().iterator(); iterator.hasNext(); ) {, +            cache.refresh();, +++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.cache.RemovalListener;, +import org.elasticsearch.common.cache.RemovalNotification;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +        this.loadedFilters = CacheBuilder.<Object, Cache<Query, Value>>builder().removalListener(this).build();, +, +        Cache<Query, Value> filterToFbs = loadedFilters.computeIfAbsent(coreCacheReader, key -> {]